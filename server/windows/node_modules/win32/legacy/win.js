'use strict';

var spawn = require('child_process').spawn;
var exec = require('child_process').exec;
var assert = require('assert');

var pullout = require('pullout/legacy');
var through = require('through2');
var iconv = require('iconv-lite');

var WIN = process.platform === 'win32';
var WIN_VOLUME = '^[a-z]{1}:$';

var chcp = store();

var CHCP = 'cp437';

exports.getVolumes = getVolumes;
exports.prepareCodePage = prepareCodePage;

exports.isVolume = isVolume;
exports.isChangeVolume = isChangeVolume;
exports.unicodify = unicodify;

function unicodify() {
    if (!WIN || chcp() === '65001')
        { return through(); }
   
    return iconv.decodeStream(("cp" + (chcp() || CHCP)));
}

function getVolumes(callback) {
    var wmic = spawn('wmic', ['logicaldisk', 'get', 'name']);
   
    assert(callback, 'callback could not be empty!');
    
    /* stream should be closed on win xp*/
    wmic.stdin.end();
    
    pullout(wmic.stdout, 'string', function(error, data) {
        if (error)
            { callback(error); }
        else
            { parse(data, callback); }
    });
    
    wmic.stderr.on('data', callback);
    wmic.on('error', callback);
}

function parse(data, callback) {
    var strDrop = /Name|\r| |\n/g;
    
    if (!data)
        { return callback(null, []); }
    
    var volumes = data
        .replace(strDrop, '')
        .split(':');
    
    volumes.pop();
    
    callback(null, volumes);
}

function prepareCodePage() {
    /* if we on windows and command is built in
     * change code page to unicode becouse
     * windows use unicode on non English versions
     */
     
    if (process.platform !== 'win32')
        { return; }
        
    getCodePage(function (codepage) {
        if (!codepage)
            { return; }
        
        process.on('SIGINT', function () {
            exec('chcp ' + codepage, function () {
                process.exit();
            });
        });
        
        exec('chcp 65001', function () {
            getCodePage(chcp);
        });
    });
}

function getCodePage(callback) {
    exec('chcp', function (error, stdout, stderror) {
        if (error || stderror || !stdout)
            { return; }
        
        var index = stdout.indexOf(':');
        var codepage = stdout
            .slice(index + 2)
            .replace('\r\n', '');
        
        callback(codepage);
    });
}

function isVolume(command) {
    assert(command, 'command could not be empty!');
    
    if (!WIN)
        { return; }
        
    var winVolume = new RegExp(WIN_VOLUME + '\\\\.*', 'i');
    return command.match(winVolume);
}

function isChangeVolume(command) {
    assert(command, 'command could not be empty!');
    
    if (!WIN)
        { return; }
    
    var winVolume = new RegExp(WIN_VOLUME, 'i');
    return command.match(winVolume);
}

function store() {
    var data;
    
    return function (value) {
        if (value)
            { data = value; }
        
        return data;
    };
}

