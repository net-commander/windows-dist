'use strict';

var zlib = require('zlib');
var assert = require('assert');

module.exports = function (streams, options, callback) {
    if (!callback) {
        callback = options;
        
        options = {
            end: true
        };
    } else if (typeof options.end === 'undefined') {
        options.end = true;
    }
    
    assert(streams, 'streams could not be empty!');
    assert(callback, 'callback could not be empty!');
    
    pipe(streams, options, callback);
}

function pipe(allStreams, options, callback) {
    var error, finish, end;
    var readError, writeError;
    
    var streams = allStreams.slice();
    var read = streams.shift();
    var write = streams.pop();
    var isGunzip = allStreams.some(function (write) {
        return write instanceof zlib.Gunzip
    });
    
    var isGzip = allStreams.some(function (write) {
        return write instanceof zlib.Gzip
    });
    
    var rm = function (event, stream, fn) {
        stream.removeListener(event, fn);
    };
    
    var rmAll = function () {
        rm('error', write, onWriteError);
        rm('error', read, onReadError);
        rm('end', read, onReadEnd);
        rm('finish', write, onWriteFinish);
    };
    
    read.on('end', onReadEnd);
    read.on('error', onReadError);
    
    if (options.end)
        { write.on('finish', onWriteFinish); }
    
    write.on('error', onWriteError);
    
    setListeners(streams, onError);
    fullPipe(allStreams, options);
    
    function onWriteError(error) {
        writeError  = true;
        finish      = true;
        
        read.on('readable', function () {
            read.resume();
        });
        
        onError(error);
        onResult();
    }
    
    function onReadError(error) {
        readError   = true;
        end         = true;
        onError(error);
        onResult();
    }
    
    function onReadEnd() {
        end = true;
        onResult();
    }
    
    function onWriteFinish() {
        finish = true;
        onResult();
    }
    
    function onError(e) {
        error = e;
        
        destroy(finish, write);
        
        if (!end && !finish)
            { onResult(); }
    }
    
    function onResult() {
        var justEnd = end && !options.end;
        var bothFinish = end && finish;
        
        if (readError && finish) {
            onEnd();
        } else if (writeError && end) {
            onEnd();
        } else if (readError) {
            onEnd();
        } else if (bothFinish || justEnd) {
            onEnd();
        } else if (error && (isGzip || isGunzip)) {
            onEnd();
        }
    }
    
    function onEnd() {
        rmAll();
        unsetListeners(streams, onError);
        
        callback(error);
    }
}

function fullPipe(streams, options) {
    var main;
    
    streams.forEach(function (stream) {
        if (!main)
            { return main = stream; }
        
        main = main.pipe(stream, {
            end: options.end
        });
    });
}

function setListeners(streams, fn) {
    streams.forEach(function (stream) {
        stream.on('error', fn);
    });
}

function destroy(finish, stream) {
    if (!finish || !stream.destroy)
        { return; }
    
    stream.destroy();
}

function unsetListeners(streams, fn) {
    streams.forEach(function (stream) {
        stream.removeListener('error', fn);
    });
}
