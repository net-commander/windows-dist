"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const has_1 = require("./support/has");
const global_1 = require("./support/global");
const util_1 = require("./support/util");
var Shim;
(function (Shim) {
    /* tslint:disable-next-line:variable-name */
    let Symbol;
    /* tslint:disable-next-line:variable-name */
    let InternalSymbol;
    const defineProperties = Object.defineProperties;
    const defineProperty = Object.defineProperty;
    const create = Object.create;
    const objPrototype = Object.prototype;
    const globalSymbols = {};
    const getSymbolName = (function () {
        const created = create(null);
        return function (desc) {
            let postfix = 0;
            let name;
            while (created[String(desc) + (postfix || '')]) {
                ++postfix;
            }
            desc += String(postfix || '');
            created[desc] = true;
            name = '@@' + desc;
            // FIXME: Temporary guard until the duplicate execution when testing can be
            // pinned down.
            if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {
                defineProperty(objPrototype, name, {
                    set: function (value) {
                        defineProperty(this, name, util_1.getValueDescriptor(value));
                    }
                });
            }
            return name;
        };
    }());
    InternalSymbol = function Symbol(description) {
        if (this instanceof InternalSymbol) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        return Symbol(description);
    };
    Symbol = function Symbol(description) {
        if (this instanceof Symbol) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        const sym = Object.create(InternalSymbol.prototype);
        description = (description === undefined ? '' : String(description));
        return defineProperties(sym, {
            __description__: util_1.getValueDescriptor(description),
            __name__: util_1.getValueDescriptor(getSymbolName(description))
        });
    };
    /**
     * A custom guard function that determines if an object is a symbol or not
     * @param  {any}       value The value to check to see if it is a symbol or not
     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)
     */
    function isSymbol(value) {
        return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;
    }
    Shim.isSymbol = isSymbol;
    /**
     * Throws if the value is not a symbol, used internally within the Shim
     * @param  {any}    value The value to check
     * @return {symbol}       Returns the symbol or throws
     */
    function validateSymbol(value) {
        if (!isSymbol(value)) {
            throw new TypeError(value + ' is not a symbol');
        }
        return value;
    }
    /* Decorate the Symbol function with the appropriate properties */
    defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {
        if (globalSymbols[key]) {
            return globalSymbols[key];
        }
        return (globalSymbols[key] = Symbol(String(key)));
    }));
    defineProperties(Symbol, {
        keyFor: util_1.getValueDescriptor(function (sym) {
            let key;
            validateSymbol(sym);
            for (key in globalSymbols) {
                if (globalSymbols[key] === sym) {
                    return key;
                }
            }
        }),
        hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),
        isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),
        iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),
        match: util_1.getValueDescriptor(Symbol.for('match'), false, false),
        observable: util_1.getValueDescriptor(Symbol.for('observable'), false, false),
        replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),
        search: util_1.getValueDescriptor(Symbol.for('search'), false, false),
        species: util_1.getValueDescriptor(Symbol.for('species'), false, false),
        split: util_1.getValueDescriptor(Symbol.for('split'), false, false),
        toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),
        toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),
        unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)
    });
    /* Decorate the InternalSymbol object */
    defineProperties(InternalSymbol.prototype, {
        constructor: util_1.getValueDescriptor(Symbol),
        toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)
    });
    /* Decorate the Symbol.prototype */
    defineProperties(Symbol.prototype, {
        toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
        valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })
    });
    defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));
    defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));
    defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));
    defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));
    /* tslint:disable-next-line:variable-name */
    Shim.Exposed = Symbol;
})(Shim = exports.Shim || (exports.Shim = {}));
/* tslint:disable-next-line:variable-name */
const SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;
/**
 * Fill any missing well known symbols if the native Symbol is missing them
 */
['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',
    'toStringTag', 'unscopables', 'observable'].forEach((wellKnown) => {
    if (!Symbol[wellKnown]) {
        Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));
    }
});
exports.isSymbol = Shim.isSymbol;
exports.default = SymbolShim;
//# sourceMappingURL=Symbol.js.map