(function(
	userConfig,
	defaultConfig
){
	// summary:
	//		This is the "source loader" and is the entry point for Dojo during development. You may also load Dojo with
	//		any AMD-compliant loader via the package main module dojo/main.
	// description:
	//		This is the "source loader" for Dojo. It provides an AMD-compliant loader that can be configured
	//		to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
	//		IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
	//		via the package main module dojo/main and this loader is not required; see dojo/package.json for details.
	//
	//		In order to keep compatibility with the v1.x line, this loader includes additional machinery that enables
	//		the dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed
	//		via the has.js API and statically removed via the build system.
	//
	//		This loader includes sniffing machinery to determine the environment; the following environments are supported:
	//
	//		- browser
	//		- node.js
	//		- rhino
	//
	//		This is the so-called "source loader". As such, it includes many optional features that may be discarded by
	//		building a customized version with the build system.

	// Design and Implementation Notes
	//
	// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.
	//
	// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)
	// loader that can be configured to operate in either synchronous or asynchronous modes.
	//
	// Since this machinery implements a loader, it does not have the luxury of using a load system and/or
	// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:
	//
	//	 1. Small library for use implementing the loader.
	//	 2. Define the has.js API; this is used throughout the loader to bracket features.
	//	 3. Define the node.js and rhino sniffs and sniff.
	//	 4. Define the loader's data.
	//	 5. Define the configuration machinery.
	//	 6. Define the script element sniffing machinery and sniff for configuration data.
	//	 7. Configure the loader IAW the provided user, default, and sniffing data.
	//	 8. Define the global require function.
	//	 9. Define the module resolution machinery.
	//	10. Define the module and plugin module definition machinery
	//	11. Define the script injection machinery.
	//	12. Define the window load detection.
	//	13. Define the logging API.
	//	14. Define the tracing API.
	//	16. Define the AMD define function.
	//	17. Define the dojo v1.x provide/require machinery--so called "legacy" modes.
	//	18. Publish global variables.
	//
	// Language and Acronyms and Idioms
	//
	// moduleId: a CJS module identifier, (used for public APIs)
	// mid: moduleId (used internally)
	// packageId: a package identifier (used for public APIs)
	// pid: packageId (used internally); the implied system or default package has pid===""
	// pack: package is used internally to reference a package object (since javascript has reserved words including "package")
	// prid: plugin resource identifier
	// The integer constant 1 is used in place of true and 0 in place of false.

	// define a minimal library to help build the loader
	var	noop = function(){
		},

		isEmpty = function(it){
			for(var p in it){
				return 0;
			}
			return 1;
		},

		toString = {}.toString,

		isFunction = function(it){
			return toString.call(it) == "[object Function]";
		},

		isString = function(it){
			return toString.call(it) == "[object String]";
		},

		isArray = function(it){
			return toString.call(it) == "[object Array]";
		},

		forEach = function(vector, callback){
			if(vector){
				for(var i = 0; i < vector.length;){
					callback(vector[i++]);
				}
			}
		},

		mix = function(dest, src){
			for(var p in src){
				dest[p] = src[p];
			}
			return dest;
		},

		makeError = function(error, info){
			return mix(new Error(error), {src:"dojoLoader", info:info});
		},

		uidSeed = 1,

		uid = function(){
			// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.
			return "_" + uidSeed++;
		},

		// FIXME: how to doc window.require() api

		// this will be the global require function; define it immediately so we can start hanging things off of it
		req = function(
			config,		  //(object, optional) hash of configuration properties
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback
			callback	  //(function, optional) lambda expression to apply to module values implied by dependencies
		){
			return contextRequire(config, dependencies, callback, 0, req);
		},

		// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout
		global = this,

		doc = global.document,

		element = doc && doc.createElement("DiV"),

		has = req.has = function(name){
			return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
		},

		hasCache = has.cache = defaultConfig.hasCache;

	has.add = function(name, test, now, force){
		(hasCache[name]===undefined || force) && (hasCache[name] = test);
		return now && has(name);
	};

	 0 && has.add("host-node", userConfig.has && "host-node" in userConfig.has ?
		userConfig.has["host-node"] :
		(typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
	if( 0 ){
		// fixup the default config for node.js environment
		require("./_base/configNode.js").config(defaultConfig);
		// remember node's require (with respect to baseUrl==dojo's root)
		defaultConfig.loaderPatch.nodeRequire = require;
	}

	 0 && has.add("host-rhino", userConfig.has && "host-rhino" in userConfig.has ?
		userConfig.has["host-rhino"] :
		(typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
	if( 0 ){
		// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...
		for(var baseUrl = userConfig.baseUrl || ".", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){
			arg = (rhinoArgs[i++] + "").split("=");
			if(arg[0] == "baseUrl"){
				baseUrl = arg[1];
				break;
			}
		}
		load(baseUrl + "/_base/configRhino.js");
		rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
	}

	has.add("host-webworker", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));
	if(has("host-webworker")){
		mix(defaultConfig.hasCache, {
			"host-browser": 0,
			"dom": 0,
			"dojo-dom-ready-api": 0,
			"dojo-sniff": 0,
			"dojo-inject-api": 1,
			"host-webworker": 1,
			"dojo-guarantee-console": 0 // console is immutable in FF30+, see https://bugs.dojotoolkit.org/ticket/18100
		});

		defaultConfig.loaderPatch = {
			injectUrl: function(url, callback){
				// TODO:
				//		This is not async, nor can it be in Webworkers.  It could be made better by passing
				//		the entire require array into importScripts at.  This way the scripts are loaded in
				//		async mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers
				//		tend to be long running where initial startup is not a major factor.

				try{
					importScripts(url);
					callback();
				}catch(e){
					console.info("failed to load resource (" + url + ")");
					console.error(e);
				}
			}
		};
	}

	// userConfig has tests override defaultConfig has tests; do this after the environment detection because
	// the environment detection usually sets some has feature values in the hasCache.
	for(var p in userConfig.has){
		has.add(p, userConfig.has[p], 0, 1);
	}

	//
	// define the loader data
	//

	// the loader will use these like symbols if the loader has the traceApi; otherwise
	// define magic numbers so that modules can be provided as part of defaultConfig
	var	requested = 1,
		arrived = 2,
		nonmodule = 3,
		executing = 4,
		executed = 5;

	if( 0 ){
		// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code
		requested = "requested";
		arrived = "arrived";
		nonmodule = "not-a-module";
		executing = "executing";
		executed = "executed";
	}

	var legacyMode = 0,
		sync = "sync",
		xd = "xd",
		syncExecStack = [],
		dojoRequirePlugin = 0,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	if( 0 ){
		req.isXdUrl = noop;

		req.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){
			// the first dojo/_base/loader loaded gets to define these variables; they are designed to work
			// in the presence of zero to many mapped dojo/_base/loaders
			if(!dojoRequirePlugin){
				dojoRequirePlugin = dojoRequirePlugin_;
				checkDojoRequirePlugin = checkDojoRequirePlugin_;
				transformToAmd = transformToAmd_;
			}

			return {
				sync:sync,
				requested:requested,
				arrived:arrived,
				nonmodule:nonmodule,
				executing:executing,
				executed:executed,
				syncExecStack:syncExecStack,
				modules:modules,
				execQ:execQ,
				getModule:getModule,
				injectModule:injectModule,
				setArrived:setArrived,
				signal:signal,
				finishExec:finishExec,
				execModule:execModule,
				dojoRequirePlugin:dojoRequirePlugin,
				getLegacyMode:function(){return legacyMode;},
				guardCheckComplete:guardCheckComplete
			};
		};

		if( 1  || has("host-webworker")){
			// in legacy sync mode, the loader needs a minimal XHR library

			var locationProtocol = location.protocol,
				locationHost = location.host;
			req.isXdUrl = function(url){
				if(/^\./.test(url)){
					// begins with a dot is always relative to page URL; therefore not xdomain
					return false;
				}
				if(/^\/\//.test(url)){
					// for v1.6- backcompat, url starting with // indicates xdomain
					return true;
				}
				// get protocol and host
				// \/+ takes care of the typical file protocol that looks like file:///drive/path/to/file
				// locationHost is falsy if file protocol => if locationProtocol matches and is "file:", || will return false
				var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
				return match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));
			};


			// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config
			 0 && has.add("dojo-xhr-factory", 1);
			has.add("dojo-force-activex-xhr",  1  && !doc.addEventListener && window.location.protocol == "file:");
			has.add("native-xhr", typeof XMLHttpRequest != "undefined");
			if(has("native-xhr") && !has("dojo-force-activex-xhr")){
				getXhr = function(){
					return new XMLHttpRequest();
				};
			}else{
				// if in the browser an old IE; find an xhr
				for(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){
					try{
						progid = XMLHTTP_PROGIDS[i++];
						if(new ActiveXObject(progid)){
							// this progid works; therefore, use it from now on
							break;
						}
					}catch(e){
						// squelch; we're just trying to find a good ActiveX progid
						// if they all fail, then progid ends up as the last attempt and that will signal the error
						// the first time the client actually tries to exec an xhr
					}
				}
				getXhr = function(){
					return new ActiveXObject(progid);
				};
			}
			req.getXhr = getXhr;

			has.add("dojo-gettext-api", 1);
			req.getText = function(url, async, onLoad){
				var xhr = getXhr();
				xhr.open('GET', fixupUrl(url), false);
				xhr.send(null);
				if(xhr.status == 200 || (!location.host && !xhr.status)){
					if(onLoad){
						onLoad(xhr.responseText, async);
					}
				}else{
					throw makeError("xhrFailed", xhr.status);
				}
				return xhr.responseText;
			};
		}
	}else{
		req.async = 1;
	}

	//
	// loader eval
	//
	var eval_ =  has("csp-restrictions") ?
		// noop eval if there are csp restrictions
		function(){} :
		// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution
		new Function('return eval(arguments[0]);');

	req.eval =
		function(text, hint){
			return eval_(text + "\r\n//# sourceURL=" + hint);
		};

	//
	// loader micro events API
	//
	var listenerQueues = {},
		error = "error",
		signal = req.signal = function(type, args){
			var queue = listenerQueues[type];
			// notice we run a copy of the queue; this allows listeners to add/remove
			// other listeners without affecting this particular signal
			forEach(queue && queue.slice(0), function(listener){
				listener.apply(null, isArray(args) ? args : [args]);
			});
		},
		on = req.on = function(type, listener){
			// notice a queue is not created until a client actually connects
			var queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			return {
				remove:function(){
					for(var i = 0; i<queue.length; i++){
						if(queue[i]===listener){
							queue.splice(i, 1);
							return;
						}
					}
				}
			};
		};

	// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
	// lexical variables hold key loader data structures to help with minification; these may be completely,
	// one-time initialized by defaultConfig for optimized/built versions
	var
		aliases
			// a vector of pairs of [regexs or string, replacement] => (alias, actual)
			= [],

		paths
			// CommonJS paths
			= {},

		pathsMapProg
			// list of (from-path, to-path, regex, length) derived from paths;
			// a "program" to apply paths; see computeMapProg
			= [],

		packs
			// a map from packageId to package configuration object; see fixupPackageInfo
			= {},

		map = req.map
			// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map
			= {},

		mapProgs
			// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
			= [],

		modules
			// A hash:(mid) --> (module-object) the module namespace
			//
			// pid: the package identifier to which the module belongs (e.g., "dojo"); "" indicates the system or default package
			// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., "dojo/io/script")
			// url: the URL from which the module was retrieved
			// pack: the package object of the package to which the module belongs
			// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed
			// deps: the dependency vector for this module (vector of modules objects)
			// def: the factory for this module
			// result: the result of the running the factory for this module
			// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define
			// load: plugin load function; applicable only for plugins
			//
			// Modules go through several phases in creation:
			//
			// 1. Requested: some other module's definition or a require application contained the requested module in
			//	  its dependency vector or executing code explicitly demands a module via req.require.
			//
			// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL
			//
			// 3. Loaded: the resource injected in [2] has been evaluated.
			//
			// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some
			//	  resources may just contain a bundle of code and never formally define a module via define
			//
			// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
			= {},

		cacheBust
			// query string to append to module URLs to bust browser cache
			= "",

		cache
			// hash:(mid | url)-->(function | string)
			//
			// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or
			// url --> string. The url key is distinguished from the mid key by always containing the prefix "url:". url keys as provided
			// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided
			// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.
			//
			// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given
			// by any mappings *iff* the config.cache was received as part of a module resource request.
			//
			// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules
			// to retrieve cached items that may have arrived consequent to another namespace.
			//
			= {},

		urlKeyPrefix
			// the prefix to prepend to a URL key in the cache.
			= "url:",

		pendingCacheInsert
			// hash:(mid)-->(function)
			//
			// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
			// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another
			// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending
			// cache for the local configuration, possibly relocating modules.
			= {},

		dojoSniffConfig
			// map of configuration variables
			// give the data-dojo-config as sniffed from the document (if any)
			= {},

		insertPointSibling
			// the nodes used to locate where scripts are injected into the document
			= 0;

	if( 1 ){
		var consumePendingCacheInsert = function(referenceModule, clear){
				clear = clear !== false;
				var p, item, match, now, m;
				for(p in pendingCacheInsert){
					item = pendingCacheInsert[p];
					match = p.match(/^url\:(.+)/);
					if(match){
						cache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;
					}else if(p=="*now"){
						now = item;
					}else if(p!="*noref"){
						m = getModuleInfo(p, referenceModule, true);
						cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
					}
				}
				if(now){
					now(createRequire(referenceModule));
				}
				if(clear){
					pendingCacheInsert = {};
				}
			},

			escapeString = function(s){
				return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c){ return "\\" + c; });
			},

			computeMapProg = function(map, dest){
				// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
				// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
				// of-map-key. The regex looks for the map-key followed by either "/" or end-of-string at the beginning
				// of a the search source. Notice the map-value is irrelevant to the algorithm
				dest.splice(0, dest.length);
				for(var p in map){
					dest.push([
						p,
						map[p],
						new RegExp("^" + escapeString(p) + "(\/|$)"),
						p.length]);
				}
				dest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });
				return dest;
			},

			computeAliases = function(config, dest){
				forEach(config, function(pair){
					// take a fixed-up copy...
					dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]]);
				});
			},


			fixupPackageInfo = function(packageInfo){
				// calculate the precise (name, location, main, mappings) for a package
				var name = packageInfo.name;
				if(!name){
					// packageInfo must be a string that gives the name
					name = packageInfo;
					packageInfo = {name:name};
				}
				packageInfo = mix({main:"main"}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;

				// packageMap is deprecated in favor of AMD map
				if(packageInfo.packageMap){
					map[name] = packageInfo.packageMap;
				}

				if(!packageInfo.main.indexOf("./")){
					packageInfo.main = packageInfo.main.substring(2);
				}

				// now that we've got a fully-resolved package object, push it into the configuration
				packs[name] = packageInfo;
			},

			delayedModuleConfig
				// module config cannot be consumed until the loader is completely initialized; therefore, all
				// module config detected during booting is memorized and applied at the end of loader initialization
				// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but
				// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete
				= [],


			config = function(config, booting, referenceModule){
				for(var p in config){
					if(p=="waitSeconds"){
						req.waitms = (config[p] || 0) * 1000;
					}
					if(p=="cacheBust"){
						cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + "") : "";
					}
					if(p=="baseUrl" || p=="combo"){
						req[p] = config[p];
					}
					if( 0  && p=="async"){
						// falsy or "sync" => legacy sync loader
						// "xd" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)
						// "legacyAsync" => permanently in "xd" by choice
						// "debugAtAllCosts" => trying to load everything via script injection (not implemented)
						// otherwise, must be truthy => AMD
						// legacyMode: sync | legacyAsync | xd | false
						var mode = config[p];
						req.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));
						req.async = !legacyMode;
					}
					if(config[p]!==hasCache){
						// accumulate raw config info for client apps which can use this to pass their own config
						req.rawConfig[p] = config[p];
						p!="has" && has.add("config-"+p, config[p], 0, booting);
					}
				}

				// make sure baseUrl exists
				if(!req.baseUrl){
					req.baseUrl = "./";
				}
				// make sure baseUrl ends with a slash
				if(!/\/$/.test(req.baseUrl)){
					req.baseUrl += "/";
				}

				// now do the special work for has, packages, packagePaths, paths, aliases, and cache

				for(p in config.has){
					has.add(p, config.has[p], 0, booting);
				}

				// for each package found in any packages config item, augment the packs map owned by the loader
				forEach(config.packages, fixupPackageInfo);

				// for each packagePath found in any packagePaths config item, augment the packageConfig
				// packagePaths is deprecated; remove in 2.0
				for(var baseUrl in config.packagePaths){
					forEach(config.packagePaths[baseUrl], function(packageInfo){
						var location = baseUrl + "/" + packageInfo;
						if(isString(packageInfo)){
							packageInfo = {name:packageInfo};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}

				// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
				// is published (see dojo-publish-privates), the published variable will always hold a valid value.

				// this must come after all package processing since package processing may mutate map
				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, function(item){
					item[1] = computeMapProg(item[1], []);
					if(item[0]=="*"){
						mapProgs.star = item;
					}
				});

				// push in any paths and recompute the internal pathmap
				computeMapProg(mix(paths, config.paths), pathsMapProg);

				// aliases
				computeAliases(config.aliases, aliases);

				if(booting){
					delayedModuleConfig.push({config:config.config});
				}else{
					for(p in config.config){
						var module = getModule(p, referenceModule);
						module.config = mix(module.config || {}, config.config[p]);
					}
				}

				// push in any new cache values
				if(config.cache){
					consumePendingCacheInsert();
					pendingCacheInsert = config.cache;
					//inject now all depencies so cache is available for mapped module
					consumePendingCacheInsert(0, !!config.cache["*noref"]);
				}

				signal("config", [config, req.rawConfig]);
			};

		//
		// execute the various sniffs; userConfig can override and value
		//

		if( 0  ||  0 ){
			// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.
			// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the
			// dojo location on CDN deployments and baseUrl when either/both of these are not provided
			// explicitly in the config data; this is the 1.6- behavior.

			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script, dojoDir, src, match;
			while(i < scripts.length){
				script = scripts[i++];
				if((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))){
					// sniff dojoDir and baseUrl
					dojoDir = match[3] || "";
					defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff configuration on attribute in script element
				if((src = (script.getAttribute("data-dojo-config") || script.getAttribute("djConfig")))){
					dojoSniffConfig = req.eval("({ " + src + " })", "data-dojo-config");

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff requirejs attribute
				if( 0 ){
					if((src = script.getAttribute("data-main"))){
						dojoSniffConfig.deps = dojoSniffConfig.deps || [src];
					}
				}
			}
		}

		if( 0 ){
			// pass down doh.testConfig from parent as if it were a data-dojo-config
			try{
				if(window.parent != window && window.parent.require){
					var doh = window.parent.require("doh");
					doh && mix(dojoSniffConfig, doh.testConfig);
				}
			}catch(e){}
		}

		// configure the loader; let the user override defaults
		req.rawConfig = {};
		config(defaultConfig, 1);

		// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides
		if( 0 ){
			packs.dojo.location = dojoDir;
			if(dojoDir){
				dojoDir += "/";
			}
			packs.dijit.location = dojoDir + "../dijit/";
			packs.dojox.location = dojoDir + "../dojox/";
		}

		config(userConfig, 1);
		config(dojoSniffConfig, 1);

	}else{
		// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application
		paths = defaultConfig.paths;
		pathsMapProg = defaultConfig.pathsMapProg;
		packs = defaultConfig.packs;
		aliases = defaultConfig.aliases;
		mapProgs = defaultConfig.mapProgs;
		modules = defaultConfig.modules;
		cache = defaultConfig.cache;
		cacheBust = defaultConfig.cacheBust;

		// remember the default config for other processes (e.g., dojo/config)
		req.rawConfig = defaultConfig;
	}


	if( 0 ){
		req.combo = req.combo || {add:noop};
		var	comboPending = 0,
			combosPending = [],
			comboPendingTimer = null;
	}


	// build the loader machinery iaw configuration, including has feature tests
	var	injectDependencies = function(module){
			// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
			guardCheckComplete(function(){
				forEach(module.deps, injectModule);
				if( 0  && comboPending && !comboPendingTimer){
					comboPendingTimer = setTimeout(function() {
						comboPending = 0;
						comboPendingTimer = null;
						req.combo.done(function(mids, url) {
							var onLoadCallback= function(){
								// defQ is a vector of module definitions 1-to-1, onto mids
								runDefQ(0, mids);
								checkComplete();
							};
							combosPending.push(mids);
							injectingModule = mids;
							req.injectUrl(url, onLoadCallback, mids);
							injectingModule = 0;
						}, req);
					}, 0);
				}
			});
		},

		contextRequire = function(a1, a2, a3, referenceModule, contextRequire){
			var module, syntheticMid;
			if(isString(a1)){
				// signature is (moduleId)
				module = getModule(a1, referenceModule, true);
				if(module && module.executed){
					return module.result;
				}
				throw makeError("undefinedModule", a1);
			}
			if(!isArray(a1)){
				// a1 is a configuration
				config(a1, 0, referenceModule);

				// juggle args; (a2, a3) may be (dependencies, callback)
				a1 = a2;
				a2 = a3;
			}
			if(isArray(a1)){
				// signature is (requestList [,callback])
				if(!a1.length){
					a2 && a2();
				}else{
					syntheticMid = "require*" + uid();

					// resolve the request list with respect to the reference module
					for(var mid, deps = [], i = 0; i < a1.length;){
						mid = a1[i++];
						deps.push(getModule(mid, referenceModule));
					}

					// construct a synthetic module to control execution of the requestList, and, optionally, callback
					module = mix(makeModuleInfo("", syntheticMid, 0, ""), {
						injected: arrived,
						deps: deps,
						def: a2 || noop,
						require: referenceModule ? referenceModule.require : req,
						gc: 1 //garbage collect
					});
					modules[module.mid] = module;

					// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
					injectDependencies(module);

					// try to immediately execute
					// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe
					// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.
					// ...but *always* insist on immediate in synch mode
					var strict = checkCompleteGuard && legacyMode!=sync;
					guardCheckComplete(function(){
						execModule(module, strict);
					});
					if(!module.executed){
						// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ
						execQ.push(module);
					}
					checkComplete();
				}
			}
			return contextRequire;
		},

		createRequire = function(module){
			if(!module){
				return req;
			}
			var result = module.require;
			if(!result){
				result = function(a1, a2, a3){
					return contextRequire(a1, a2, a3, module, result);
				};
				module.require = mix(result, req);
				result.module = module;
				result.toUrl = function(name){
					return toUrl(name, module);
				};
				result.toAbsMid = function(mid){
					return toAbsMid(mid, module);
				};

				result.undef = function(mid){
					req.undef(mid, module);
				};

				if( 0 ){
					result.syncLoadNls = function(mid){
						var nlsModuleInfo = getModuleInfo(mid, module),
							nlsModule = modules[nlsModuleInfo.mid];
						if(!nlsModule || !nlsModule.executed){
							cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
							if(cached){
								evalModuleText(cached);
								nlsModule = modules[nlsModuleInfo.mid];
							}
						}
						return nlsModule && nlsModule.executed && nlsModule.result;
					};
				}

			}
			return result;
		},

		execQ =
			// The list of modules that need to be evaluated.
			[],

		defQ =
			// The queue of define arguments sent to loader.
			[],

		waiting =
			// The set of modules upon which the loader is waiting for definition to arrive
		{},

		setRequested = function(module){
			module.injected = requested;
			waiting[module.mid] = 1;
			if(module.url){
				waiting[module.url] = module.pack || 1;
			}
			startTimer();
		},

		setArrived = function(module){
			module.injected = arrived;
			delete waiting[module.mid];
			if(module.url){
				delete waiting[module.url];
			}
			if(isEmpty(waiting)){
				clearTimer();
				 0  && legacyMode==xd && (legacyMode = sync);
			}
		},

		execComplete = req.idle =
			// says the loader has completed (or not) its work
			function(){
				return !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;
			},

		runMapProg = function(targetMid, map){
			// search for targetMid in map; return the map item if found; falsy otherwise
			if(map){
				for(var i = 0; i < map.length; i++){
					if(map[i][2].test(targetMid)){
						return map[i];
					}
				}
			}
			return 0;
		},

		compactPath = function(path){
			var result = [],
				segment, lastSegment;
			path = path.replace(/\\/g, '/').split('/');
			while(path.length){
				segment = path.shift();
				if(segment==".." && result.length && lastSegment!=".."){
					result.pop();
					lastSegment = result[result.length - 1];
				}else if(segment!="."){
					result.push(lastSegment= segment);
				} // else ignore "."
			}
			return result.join("/");
		},

		makeModuleInfo = function(pid, mid, pack, url){
			if( 0 ){
				var xd= req.isXdUrl(url);
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};
			}else{
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
			}
		},

		getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){
			// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
			// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader
			var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = /^\./.test(mid);
			if(/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative && !referenceModule)){
				// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
				// whatever it is, it's not a module but just a URL of some sort
				// note: pid===0 indicates the routine is returning an unmodified mid

				return makeModuleInfo(0, mid, 0, mid);
			}else{
				// relative module ids are relative to the referenceModule; get rid of any dots
				mid = compactPath(isRelative ? (referenceModule.mid + "/../" + mid) : mid);
				if(/^\./.test(mid)){
					throw makeError("irrationalPath", mid);
				}
				// at this point, mid is an absolute mid

				// map the mid
				if(!fromPendingCache && !isRelative && mapProgs.star){
					mapItem = runMapProg(mid, mapProgs.star[1]);
				}
				if(!mapItem && referenceModule){
					mapItem = runMapProg(referenceModule.mid, mapProgs);
					mapItem = mapItem && runMapProg(mid, mapItem[1]);
				}

				if(mapItem){
					mid = mapItem[1] + mid.substring(mapItem[3]);
				}

				match = mid.match(/^([^\/]+)(\/(.+))?$/);
				pid = match ? match[1] : "";
				if((pack = packs[pid])){
					mid = pid + "/" + (midInPackage = (match[3] || pack.main));
				}else{
					pid = "";
				}

				// search aliases
				var candidateLength = 0,
					candidate = 0;
				forEach(aliases, function(pair){
					var match = mid.match(pair[0]);
					if(match && match.length>candidateLength){
						candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
					}
				});
				if(candidate){
					return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
				}

				result = modules[mid];
				if(result){
					return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}
			// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
			// fully resolved (i.e., all relative indicators and package mapping resolved) module id

			// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid
			mapItem = runMapProg(mid, pathsMapProg);
			if(mapItem){
				url = mapItem[1] + mid.substring(mapItem[3]);
			}else if(pid){
				url = pack.location + "/" + midInPackage;
			}else if(has("config-tlmSiblingOfDojo")){
				url = "../" + mid;
			}else{
				url = mid;
			}
			// if result is not absolute, add baseUrl
			if(!(/(^\/)|(\:)/.test(url)) && url.indexOf('http')===-1){
				url = baseUrl + url;
			}
			url += ".js";
			return makeModuleInfo(pid, mid, pack, compactPath(url));
		},

		getModuleInfo = function(mid, referenceModule, fromPendingCache){
			return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);
		},

		resolvePluginResourceId = function(plugin, prid, referenceModule){
			return plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);
		},

		dynamicPluginUidGenerator = 0,

		getModule = function(mid, referenceModule, immediate){
			// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule
			var match, plugin, prid, result;
			match = mid.match(/^(.+?)\!(.*)$/);
			if(match){
				// name was <plugin-module>!<plugin-resource-id>
				plugin = getModule(match[1], referenceModule, immediate);

				if( 0  && legacyMode == sync && !plugin.executed){
					injectModule(plugin);
					if(plugin.injected===arrived && !plugin.executed){
						guardCheckComplete(function(){
							execModule(plugin);
						});
					}
					if(plugin.executed){
						promoteModuleToPlugin(plugin);
					}else{
						// we are in xdomain mode for some reason
						execQ.unshift(plugin);
					}
				}



				if(plugin.executed === executed && !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise
				if(plugin.load){
					prid = resolvePluginResourceId(plugin, match[2], referenceModule);
					mid = (plugin.mid + "!" + (plugin.dynamic ? ++dynamicPluginUidGenerator + "!" : "") + prid);
				}else{
					prid = match[2];
					mid = plugin.mid + "!" + (++dynamicPluginUidGenerator) + "!waitingForPlugin";
				}
				result = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};
			}else{
				result = getModuleInfo(mid, referenceModule);
			}
			return modules[result.mid] || (!immediate && (modules[result.mid] = result));
		},

		toAbsMid = req.toAbsMid = function(mid, referenceModule){
			return getModuleInfo(mid, referenceModule).mid;
		},

		toUrl = req.toUrl = function(name, referenceModule){
			var moduleInfo = getModuleInfo(name+"/x", referenceModule),
				url= moduleInfo.url;
			return fixupUrl(moduleInfo.pid===0 ?
				// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases
				name :
				// "/x.js" since getModuleInfo automatically appends ".js" and we appended "/x" to make name look like a module id
				url.substring(0, url.length-5)
			);
		},

		nonModuleProps = {
			injected: arrived,
			executed: executed,
			def: nonmodule,
			result: nonmodule
		},

		makeCjs = function(mid){
			return modules[mid] = mix({mid:mid}, nonModuleProps);
		},

		cjsRequireModule = makeCjs("require"),
		cjsExportsModule = makeCjs("exports"),
		cjsModuleModule = makeCjs("module"),

		runFactory = function(module, args){
			req.trace("loader-run-factory", [module.mid]);
			var factory = module.def,
				result;
			 0  && syncExecStack.unshift(module);
			if(has("config-dojo-loader-catches")){
				try{
					result= isFunction(factory) ? factory.apply(null, args) : factory;
				}catch(e){
					signal(error, module.result = makeError("factoryThrew", [module, e]));
				}
			}else{
				result= isFunction(factory) ? factory.apply(null, args) : factory;
			}
			module.result = result===undefined && module.cjs ? module.cjs.exports : result;
			 0  && syncExecStack.shift(module);
		},

		abortExec = {},

		defOrder = 0,

		promoteModuleToPlugin = function(pluginModule){
			var plugin = pluginModule.result;
			pluginModule.dynamic = plugin.dynamic;
			pluginModule.normalize = plugin.normalize;
			pluginModule.load = plugin.load;
			return pluginModule;
		},

		resolvePluginLoadQ = function(plugin){
			// plugins is a newly executed module that has a loadQ waiting to run

			// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid
			// recall the original mid was created before the plugin was on board and therefore it was impossible to
			// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change
			var map = {};
			forEach(plugin.loadQ, function(pseudoPluginResource){
				// manufacture and insert the real module in modules
				var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
					mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + "!" + prid),
					pluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});
				if(!modules[mid]){
					// create a new (the real) plugin resource and inject it normally now that the plugin is on board
					injectPlugin(modules[mid] = pluginResource);
				} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin

				// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)
				// mark is as arrived and delete it from modules; the real module was requested above
				map[pseudoPluginResource.mid] = modules[mid];
				setArrived(pseudoPluginResource);
				delete modules[pseudoPluginResource.mid];
			});
			plugin.loadQ = 0;

			// step2: replace all references to any placeholder modules with real modules
			var substituteModules = function(module){
				for(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){
					replacement = map[deps[i].mid];
					if(replacement){
						deps[i] = replacement;
					}
				}
			};
			for(var p in modules){
				substituteModules(modules[p]);
			}
			forEach(execQ, substituteModules);
		},

		finishExec = function(module){
			req.trace("loader-finish-exec", [module.mid]);
			module.executed = executed;
			module.defOrder = defOrder++;
			 0  && forEach(module.provides, function(cb){ cb(); });
			if(module.loadQ){
				// the module was a plugin
				promoteModuleToPlugin(module);
				resolvePluginLoadQ(module);
			}
			// remove all occurrences of this module from the execQ
			for(i = 0; i < execQ.length;){
				if(execQ[i] === module){
					execQ.splice(i, 1);
				}else{
					i++;
				}
			}
			// delete references to synthetic modules
			if (/^require\*/.test(module.mid)) {
				delete modules[module.mid];
			}
		},

		circleTrace = [],

		execModule = function(module, strict){
			// run the dependency vector, then run the factory for module
			if(module.executed === executing){
				req.trace("loader-circular-dependency", [circleTrace.concat(module.mid).join("->")]);
				return (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);
			}
			// at this point the module is either not executed or fully executed


			if(!module.executed){
				if(!module.def){
					return abortExec;
				}
				var mid = module.mid,
					deps = module.deps || [],
					arg, argResult,
					args = [],
					i = 0;

				if( 0 ){
					circleTrace.push(mid);
					req.trace("loader-exec-module", ["exec", circleTrace.length, mid]);
				}

				// for circular dependencies, assume the first module encountered was executed OK
				// modules that circularly depend on a module that has not run its factory will get
				// the pre-made cjs.exports===module.result. They can take a reference to this object and/or
				// add properties to it. When the module finally runs its factory, the factory can
				// read/write/replace this object. Notice that so long as the object isn't replaced, any
				// reference taken earlier while walking the deps list is still valid.
				module.executed = executing;
				while((arg = deps[i++])){
					argResult = ((arg === cjsRequireModule) ? createRequire(module) :
						((arg === cjsExportsModule) ? module.cjs.exports :
							((arg === cjsModuleModule) ? module.cjs :
								execModule(arg, strict))));
					if(argResult === abortExec){
						module.executed = 0;
						req.trace("loader-exec-module", ["abort", mid]);
						 0  && circleTrace.pop();
						return abortExec;
					}
					args.push(argResult);
				}
				runFactory(module, args);
				finishExec(module);
				 0  && circleTrace.pop();
			}
			// at this point the module is guaranteed fully executed

			return module.result;
		},


		checkCompleteGuard = 0,

		guardCheckComplete = function(proc){
			try{
				checkCompleteGuard++;
				proc();
			}catch(e){
				// https://bugs.dojotoolkit.org/ticket/16617
				if( 1 ){
					if(typeof logError!=='undefined'){
						logError(e);
					}
					throw e;
				}else{
					checkCompleteGuard--;
					//console.error('error loading ',e);
				}
			}finally{
				checkCompleteGuard--;
			}
			if(execComplete()){
				signal("idle", []);
			}
		},

		checkComplete = function(){
			// keep going through the execQ as long as at least one factory is executed
			// plugins, recursion, cached modules all make for many execution path possibilities
			if(checkCompleteGuard){
				return;
			}
			guardCheckComplete(function(){
				checkDojoRequirePlugin();
				for(var currentDefOrder, module, i = 0; i < execQ.length;){
					currentDefOrder = defOrder;
					module = execQ[i];
					execModule(module);
					if(currentDefOrder!=defOrder){
						// defOrder was bumped one or more times indicating something was executed (note, this indicates
						// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)
						checkDojoRequirePlugin();
						i = 0;
					}else{
						// nothing happened; check the next module in the exec queue
						i++;
					}
				}
			});
		};



	req.undef = function(moduleId, referenceModule){
		// In order to reload a module, it must be undefined (this routine) and then re-requested.
		// This is useful for testing frameworks (at least).
		var module = getModule(moduleId, referenceModule);
		setArrived(module);
		mix(module, {def:0, executed:0, injected:0, node:0});
	};


	if( 1 ){
		if(has("dojo-loader-eval-hint-url")===undefined){
			has.add("dojo-loader-eval-hint-url", 1);
		}

		var fixupUrl= typeof userConfig.fixupUrl == "function" ? userConfig.fixupUrl : function(url){
				url += ""; // make sure url is a Javascript string (some paths may be a Java string)
				return url + (cacheBust ? ((/\?/.test(url) ? "&" : "?") + cacheBust) : "");
			},

			injectPlugin = function(
				module
			){
				// injects the plugin module given by module; may have to inject the plugin itself
				var plugin = module.plugin;

				if(plugin.executed === executed && !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				var onLoad = function(def){
					module.result = def;
					setArrived(module);
					finishExec(module);
					checkComplete();
				};

				if(plugin.load){
					plugin.load(module.prid, module.req, onLoad);
				}else if(plugin.loadQ){
					plugin.loadQ.push(module);
				}else{
					// the unshift instead of push is important: we don't want plugins to execute as
					// dependencies of some other module because this may cause circles when the plugin
					// loadQ is run; also, generally, we want plugins to run early since they may load
					// several other modules and therefore can potentially unblock many modules
					plugin.loadQ = [module];
					execQ.unshift(plugin);
					injectModule(plugin);
				}
			},

			// for IE, injecting a module may result in a recursive execution if the module is in the cache

			cached = 0,

			injectingModule = 0,

			injectingCachedModule = 0,

			evalModuleText = function(text, module){
				// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit
				if(has("config-stripStrict")){
					text = text.replace(/(["'])use strict\1/g, '');
				}
				injectingCachedModule = 1;
				if(has("config-dojo-loader-catches")){
					try{
						if(text===cached){
							cached.call(null);
						}else{
							req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
						}
					}catch(e){
						signal(error, makeError("evalModuleThrew", module));
					}
				}else{
					if(text===cached){
						cached.call(null);
					}else{
						req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
					}
				}
				injectingCachedModule = 0;
			},

			injectModule = function(module){
				// Inject the module. In the browser environment, this means appending a script element into
				// the document; in other environments, it means loading a file.
				//
				// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.

				var mid = module.mid,
					url = module.url;
				if(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){
					return;
				}
				setRequested(module);

				if( 0 ){
					var viaCombo = 0;
					if(module.plugin && module.plugin.isCombo){
						// a combo plugin; therefore, must be handled by combo service
						// the prid should have already been converted to a URL (if required by the plugin) during
						// the normalize process; in any event, there is no way for the loader to know how to
						// to the conversion; therefore the third argument is zero
						req.combo.add(module.plugin.mid, module.prid, 0, req);
						viaCombo = 1;
					}else if(!module.plugin){
						viaCombo = req.combo.add(0, module.mid, module.url, req);
					}
					if(viaCombo){
						comboPending= 1;
						return;
					}
				}

				if(module.plugin){
					injectPlugin(module);
					return;
				} // else a normal module (not a plugin)


				var onLoadCallback = function(){
					runDefQ(module);
					if(module.injected !== arrived){
						// the script that contained the module arrived and has been executed yet
						// nothing was added to the defQ (so it wasn't an AMD module) and the module
						// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);
						// therefore, it must not have been a module; adjust state accordingly
						if(has("dojo-enforceDefine")){
							signal(error, makeError("noDefine", module));
							return;
						}
						setArrived(module);
						mix(module, nonModuleProps);
						req.trace("loader-define-nonmodule", [module.url]);
					}

					if( 0  && legacyMode){
						// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;
						// but, if xd loading, then don't call checkComplete until out of the current sync traversal
						// in order to preserve order of execution of the dojo.required modules
						!syncExecStack.length && checkComplete();
					}else{
						checkComplete();
					}
				};
				cached = cache[mid] || cache[urlKeyPrefix + module.url];
				if(cached){
					req.trace("loader-inject", ["cache", module.mid, url]);
					evalModuleText(cached, module);
					onLoadCallback();
					return;
				}
				if( 0  && legacyMode){
					if(module.isXd){
						// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}
						legacyMode==sync && (legacyMode = xd);
						// fall through and load via script injection
					}else if(module.isAmd && legacyMode!=sync){
						// fall through and load via script injection
					}else{
						// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain
						var xhrCallback = function(text){
							if(legacyMode==sync){
								// the top of syncExecStack gives the current synchronously executing module; the loader needs
								// to know this if it has to switch to async loading in the middle of evaluating a legacy module
								// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain
								// (using unshift/shift because there is no back() methods for Javascript arrays)
								syncExecStack.unshift(module);
								evalModuleText(text, module);
								syncExecStack.shift();

								// maybe the module was an AMD module
								runDefQ(module);

								// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing
								if(!module.cjs){
									setArrived(module);
									finishExec(module);
								}

								if(module.finish){
									// while synchronously evaluating this module, dojo.require was applied referencing a module
									// that had to be loaded async; therefore, the loader stopped answering all dojo.require
									// requests so they could be answered completely in the correct sequence; module.finish gives
									// the list of dojo.requires that must be re-applied once all target modules are available;
									// make a synthetic module to execute the dojo.require's in the correct order

									// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module
									// TODO: can we just leave the module.finish...what's it hurting?
									var finishMid = mid + "*finish",
										finish = module.finish;
									delete module.finish;

									def(finishMid, ["dojo", ("dojo/require!" + finish.join(",")).replace(/\./g, "/")], function(dojo){
										forEach(finish, function(mid){ dojo.require(mid); });
									});
									// unshift, not push, which causes the current traversal to be reattempted from the top
									execQ.unshift(getModule(finishMid));
								}
								onLoadCallback();
							}else{
								text = transformToAmd(module, text);
								if(text){
									evalModuleText(text, module);
									onLoadCallback();
								}else{
									// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected
									// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)
									injectingModule = module;
									req.injectUrl(fixupUrl(url), onLoadCallback, module);
									injectingModule = 0;
								}
							}
						};

						req.trace("loader-inject", ["xhr", module.mid, url, legacyMode!=sync]);
						if(has("config-dojo-loader-catches")){
							try{
								req.getText(url, legacyMode!=sync, xhrCallback);
							}catch(e){
								signal(error, makeError("xhrInjectFailed", [module, e]));
							}
						}else{
							req.getText(url, legacyMode!=sync, xhrCallback);
						}
						return;
					}
				} // else async mode or fell through in xdomain loading mode; either way, load by script injection
				req.trace("loader-inject", ["script", module.mid, url]);
				injectingModule = module;
				req.injectUrl(fixupUrl(url), onLoadCallback, module);
				injectingModule = 0;
			},

			defineModule = function(module, deps, def){
				req.trace("loader-define-module", [module.mid, deps]);

				if( 0  && module.plugin && module.plugin.isCombo){
					// the module is a plugin resource loaded by the combo service
					// note: check for module.plugin should be enough since normal plugin resources should
					// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders
					module.result = isFunction(def) ? def() : def;
					setArrived(module);
					finishExec(module);
					return module;
				}

				var mid = module.mid;
				if(module.injected === arrived){
					//signal(error, makeError("multipleDefine", module));
					//return module;
				}
				mix(module, {
					deps: deps,
					def: def,
					cjs: {
						id: module.mid,
						uri: module.url,
						exports: (module.result = {}),
						setExports: function(exports){
							module.cjs.exports = exports;
						},
						config:function(){
							return module.config;
						}
					}
				});

				// resolve deps with respect to this module
				for(var i = 0; deps[i]; i++){
					deps[i] = getModule(deps[i], module);
				}

				if( 0  && legacyMode && !waiting[mid]){
					// the module showed up without being asked for; it was probably in a <script> element
					injectDependencies(module);
					execQ.push(module);
					checkComplete();
				}
				setArrived(module);

				if(!isFunction(def) && !deps.length){
					module.result = def;
					finishExec(module);
				}

				return module;
			},

			runDefQ = function(referenceModule, mids){
				// defQ is an array of [id, dependencies, factory]
				// mids (if any) is a vector of mids given by a combo service
				var definedModules = [],
					module, args;
				while(defQ.length){
					args = defQ.shift();
					mids && (args[0]= mids.shift());
					// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully
					// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue
					// TODO: what if no args[0] and no referenceModule
					module = (args[0] && getModule(args[0])) || referenceModule;
					definedModules.push([module, args[1], args[2]]);
				}
				consumePendingCacheInsert(referenceModule);
				forEach(definedModules, function(args){
					injectDependencies(defineModule.apply(null, args));
				});
			};
	}

	var timerId = 0,
		clearTimer = noop,
		startTimer = noop;
	if( 0 ){
		// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.
		clearTimer = function(){
			timerId && clearTimeout(timerId);
			timerId = 0;
		};

		startTimer = function(){
			clearTimer();
			if(req.waitms){
				timerId = global.setTimeout(function(){
					clearTimer();
					signal(error, makeError("timeout", waiting));
				}, req.waitms);
			}
		};
	}

	if ( 1 ) {
		// Test for IE's different way of signaling when scripts finish loading.  Note that according to
		// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the
		// IE specific code path even though it has an addEventListener() method.
		// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.
		// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()
		//  is defined in both those environments.
		has.add("ie-event-behavior", doc.attachEvent && typeof Windows === "undefined" &&
			(typeof opera === "undefined" || opera.toString() != "[object Opera]"));
	}

	if( 1  && ( 1  ||  0 )){
		var domOn = function(node, eventName, ieEventName, handler){
				// Add an event listener to a DOM node using the API appropriate for the current browser;
				// return a function that will disconnect the listener.
				if(!has("ie-event-behavior")){
					node.addEventListener(eventName, handler, false);
					return function(){
						node.removeEventListener(eventName, handler, false);
					};
				}else{
					node.attachEvent(ieEventName, handler);
					return function(){
						node.detachEvent(ieEventName, handler);
					};
				}
			},
			windowOnLoadListener = domOn(window, "load", "onload", function(){
				req.pageLoaded = 1;
				// https://bugs.dojotoolkit.org/ticket/16248
				try{
					doc.readyState!="complete" && (doc.readyState = "complete");
				}catch(e){
				}
				windowOnLoadListener();
			});

		if( 1 ){
			// if the loader is on the page, there must be at least one script element
			// getting its parent and then doing insertBefore solves the "Operation Aborted"
			// error in IE from appending to a node that isn't properly closed; see
			// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example
			// don't use scripts with type dojo/... since these may be removed; see #15809
			// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958
			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script;
			while(!insertPointSibling){
				if(!/^dojo/.test((script = scripts[i++]) && script.type)){
					insertPointSibling= script;
				}
			}

			req.injectUrl = function(url, callback, owner){
				// insert a script element to the insert-point element with src=url;
				// apply callback upon detecting the script has loaded.

				var node = owner.node = doc.createElement("script"),
					onLoad = function(e){
						e = e || window.event;
						var node = e.target || e.srcElement;
						if(e.type === "load" || /complete|loaded/.test(node.readyState)){
							loadDisconnector();
							errorDisconnector();
							callback && callback();
						}
					},
					loadDisconnector = domOn(node, "load", "onreadystatechange", onLoad),
					errorDisconnector = domOn(node, "error", "onerror", function(e){
						loadDisconnector();
						errorDisconnector();
						signal(error, makeError("scriptError", [url, e]));
					});

				node.type = "text/javascript";
				node.charset = "utf-8";
				node.src = url;
				insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
				return node;
			};
		}
	}

	if( 0 ){
		req.log = function(){
			try{
				for(var i = 0; i < arguments.length; i++){
					console.log(arguments[i]);
				}
			}catch(e){}
		};
	}else{
		req.log = noop;
	}

	if( 0 ){
		var trace = req.trace = function(
			group,	// the trace group to which this application belongs
			args	// the contents of the trace
		){
			///
			// Tracing interface by group.
			//
			// Sends the contents of args to the console iff (req.trace.on && req.trace[group])

			if(trace.on && trace.group[group]){
				signal("trace", [group, args]);
				for(var arg, dump = [], text= "trace:" + group + (args.length ? (":" + args[0]) : ""), i= 1; i<args.length;){
					arg = args[i++];
					if(isString(arg)){
						text += ", " + arg;
					}else{
						dump.push(arg);
					}
				}
				req.log(text);
				dump.length && dump.push(".");
				req.log.apply(req, dump);
			}
		};
		mix(trace, {
			on:1,
			group:{},
			set:function(group, value){
				if(isString(group)){
					trace.group[group]= value;
				}else{
					mix(trace.group, group);
				}
			}
		});
		trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
		on("config", function(config){
			config.trace && trace.set(config.trace);
		});
	}else{
		req.trace = noop;
	}

	var def = function(
		mid,		  //(commonjs.moduleId, optional)
		dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory
		factory		  //(any)
	){
		///
		// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.
		///
		//note
		// CommonJS factory scan courtesy of http://requirejs.org

		var arity = arguments.length,
			defaultDeps = ["require", "exports", "module"],
			// the predominate signature...
			args = [0, mid, dependencies];
		if(arity==1){
			args = [0, (isFunction(mid) ? defaultDeps : []), mid];
		}else if(arity==2 && isString(mid)){
			args = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];
		}else if(arity==3){
			args = [mid, dependencies, factory];
		}

		if( 0  && args[1]===defaultDeps){
			args[2].toString()
				.replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, "")
				.replace(/require\(["']([\w\!\-_\.\/]+)["']\)/g, function(match, dep){
					args[1].push(dep);
				});
		}

		req.trace("loader-define", args.slice(0, 2));
		var targetModule = args[0] && getModule(args[0]),
			module;
		if(targetModule && !waiting[targetModule.mid]){
			// given a mid that hasn't been requested; therefore, defined through means other than injecting
			// consequent to a require() or define() application; examples include defining modules on-the-fly
			// due to some code path or including a module in a script element. In any case,
			// there is no callback waiting to finish processing and nothing to trigger the defQ and the
			// dependencies are never requested; therefore, do it here.
			injectDependencies(defineModule(targetModule, args[1], args[2]));
		}else if(!has("ie-event-behavior") || ! 1  || injectingCachedModule){
			// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately
			// after script finishes being evaluated and the defQ can be run from that callback to detect the module id
			defQ.push(args);
		}else{
			// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,
			// in-order exec of onLoad with script eval (since it's IE) and must manually detect here
			targetModule = targetModule || injectingModule;
			if(!targetModule){
				for(mid in waiting){
					module = modules[mid];
					if(module && module.node && module.node.readyState === 'interactive'){
						targetModule = module;
						break;
					}
				}
				if( 0  && !targetModule){
					for(var i = 0; i<combosPending.length; i++){
						targetModule = combosPending[i];
						if(targetModule.node && targetModule.node.readyState === 'interactive'){
							break;
						}
						targetModule= 0;
					}
				}
			}
			if( 0  && isArray(targetModule)){
				injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
				if(!targetModule.length){
					combosPending.splice(i, 1);
				}
			}else if(targetModule){
				consumePendingCacheInsert(targetModule);
				injectDependencies(defineModule(targetModule, args[1], args[2]));
			}else{
				signal(error, makeError("ieDefineFailed", args[0]));
			}
			checkComplete();
		}
	};
	def.amd = {
		vendor:"dojotoolkit.org"
	};

	if( 0 ){
		req.def = def;
	}

	// allow config to override default implementation of named functions; this is useful for
	// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
	// also useful for testing and monkey patching loader
	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);

	// now that req is fully initialized and won't change, we can hook it up to the error signal
	on(error, function(arg){
		try{
			console.error(arg);
			if(arg instanceof Error){
				for(var p in arg){
					console.log(p + ":", arg[p]);
				}
				console.log(".");
			}
		}catch(e){}
	});

	// always publish these
	mix(req, {
		uid:uid,
		cache:cache,
		packs:packs
	});


	if( 0 ){
		mix(req, {
			// these may be interesting to look at when debugging
			paths:paths,
			aliases:aliases,
			modules:modules,
			legacyMode:legacyMode,
			execQ:execQ,
			defQ:defQ,
			waiting:waiting,

			// these are used for testing
			// TODO: move testing infrastructure to a different has feature
			packs:packs,
			mapProgs:mapProgs,
			pathsMapProg:pathsMapProg,
			listenerQueues:listenerQueues,

			// these are used by the builder (at least)
			computeMapProg:computeMapProg,
			computeAliases:computeAliases,
			runMapProg:runMapProg,
			compactPath:compactPath,
			getModuleInfo:getModuleInfo_
		});
	}

	// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
	// *required* to define (as opposed to require, which is optional)
	if(global.define){
		if( 0 ){
			signal(error, makeError("defineAlreadyDefined", 0));
		}
		return;
	}else{
		global.define = def;
		global.require = req;
		if( 0 ){
			require = req;
		}
	}

	if( 0  && req.combo && req.combo.plugins){
		var plugins = req.combo.plugins,
			pluginName;
		for(pluginName in plugins){
			mix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:"executed", load:1});
		}
	}

	if( 1 ){
		forEach(delayedModuleConfig, function(c){ config(c); });
		var bootDeps = dojoSniffConfig.deps ||	userConfig.deps || defaultConfig.deps,
			bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
		req.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;
	}
	if(! 1 ){
		!req.async && req(["dojo"]);
		req.boot && req.apply(null, req.boot);
	}
})
(this.dojoConfig || this.djConfig || this.require || {}, {
		async:0,
		hasCache:{
				'config-selectorEngine':"lite",
				'config-tlmSiblingOfDojo':1,
				'dojo-built':1,
				'dojo-loader':1,
				dom:1,
				'host-browser':1
		},
		packages:[
				{
					 location:"../xfile",
					 name:"xfile"
				},
				{
					 location:"../xide",
					 name:"xide"
				},
				{
					 location:"../dgrid",
					 main:"OnDemandGrid",
					 name:"dgrid"
				},
				{
					 location:"../dcl",
					 main:"dcl.js",
					 name:"dcl"
				},
				{
					 location:"../davinci",
					 name:"davinci"
				},
				{
					 location:"../wcDocker",
					 name:"wcDocker"
				},
				{
					 location:"../xaction",
					 name:"xaction"
				},
				{
					 location:"../dstore",
					 main:"Store",
					 name:"dstore"
				},
				{
					 location:"../xdocker",
					 name:"xdocker"
				},
				{
					 location:"../xbox",
					 name:"xbox"
				},
				{
					 location:"../dijit",
					 name:"dijit"
				},
				{
					 location:"../xlog",
					 name:"xlog"
				},
				{
					 location:"../xconsole",
					 name:"xconsole"
				},
				{
					 location:"../xace",
					 name:"xace"
				},
				{
					 location:"../xgrid",
					 name:"xgrid"
				},
				{
					 location:"../xdojo",
					 name:"xdojo"
				},
				{
					 location:"../xlang",
					 name:"xlang"
				},
				{
					 location:".",
					 name:"dojo"
				}
		]
});require({cache:{
'dojo/request/default':function(){
define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'dojo/_base/array':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	 1  && lang.mixin(dojo, array);

	return array;
});

},
'xide/widgets/TemplatedWidgetBase':function(){
define([
    'dcl/dcl',
    'xide/utils',
    'xide/_base/_Widget'
], function (dcl,utils,_XWidget2) {

    var Implementation = {
        declaredClass: 'xide.widgets.TemplatedWidgetBase',
        data: null,
        delegate: null,
        didLoad: false,
        templateString: null,
        getParent: function () {
            return this._parent;
        },
        debounce: function (methodName, _function, delay, options, now) {
            return utils.debounce(this, methodName, _function, delay, options, now);
        },
        translate: function (value) {
            return this.localize(value);
        },
        _setupTranslations: function () {
            this._messages = [];
        },
        updateTitleNode: function (value) {}
    };

    //var Module = declare("xide.widgets.TemplatedWidgetBase", [_Widget, _XWidget,_TemplatedMixin, _WidgetsInTemplateMixin, EventedMixin],Implementation);
    var Module = dcl([_XWidget2],Implementation);
    dcl.chainAfter(Module,'startup');
    dcl.chainAfter(Module,'destroy');
    return Module;
});
},
'xide/views/_CIDialog':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/views/_Dialog',
    'xide/views/CIView'

], function (dcl,types,utils,_Dialog,CIView) {

    var Module =dcl(_Dialog, {
        declaredClass:'xide/views/_CIDialog',
        type: types.DIALOG_TYPE.INFO,
        size: types.DIALOG_SIZE.SIZE_NORMAL,
        bodyCSS: {
            'height': 'auto',
            'min-height': '200px',
            /*'width':'600px',
             'min-width':'600px',*/
            'padding': '8px',
            'margin-right': '16px'
        },
        cssClass:'bootstrap3-dialog CIDialog',
        failedText:' Failed!',
        successText:': Success!',
        showSpinner:true,
        spinner:'  <span class="fa-spinner fa-spin"/>',
        notificationMessage:null,
        cisView:null,
        getData:function(){
            var cis = this.cisView.getCIS();
            for (var i = 0; i < cis.length; i++) {
                var obj = cis[i];
                if (obj._widget) {
                    delete obj['_widget'];
                }
            }
            return cis;
        },
        getField:function(name){
            var cis = this.cisView.cis,
                ci = utils.getCIByChainAndName(cis,0,name),
                value = ci ? ci.value :null,
                invalid = null;
                if(ci){
                    invalid = ci.invalid == true;
                }
            return invalid ? null : value;
        },
        onShow:function(dlg){
            var cisView = this.cisView,
                self = this;
            cisView.startup();
            this.resize();
            this.startDfd.resolve();
        },
        onReady:function(){},
        message:function(dlg){
            var thiz = dlg.owner;
            //if(!thiz.cis){}
            var cisView = thiz.initWithCIS(thiz.cis);
            thiz.cisView = cisView;
            return $(cisView.domNode);
        },
        initWithCIS: function (cis) {

            cis = cis || [];

            var viewArgs = {
                delegate: this,
                options: {},
                cis: cis.inputs || cis,
                style: 'height:inherit',
                tabContainerStyle: 'height:inherit',
                resizeToParent:true

            },self = this;
            utils.mixin(viewArgs, this.viewArgs);
            var view = utils.addWidget(CIView, viewArgs, this.containerNode, null, false);

            self.onCIValueChanged && view._on('valueChanged',function(e){
                self.onCIValueChanged(e.ci, e.newValue, e.oldValue);
            });

            view._on('widget',function(e){
                self._emit('widget',e);
            });

            this.add(view);
            return view;
        }

    });


    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");
    dcl.chainAfter(Module, "onCIValueChanged");
    dcl.chainAfter(Module, "onShow");


    return Module;

});
},
'dojo/dom-form':function(){
define(["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
});

},
'xide/rpc/Service':function(){
define([
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/xhr",
    "dojo/_base/declare",
    "xide/rpc/AdapterRegistry",
    "dojo/_base/url",
    "xide/utils",
    "xide/lodash"
], function(dojo,lang,xhr,declare,AdapterRegistry,url,utils,_){
    var transportRegistry = new AdapterRegistry(true);
    var envelopeRegistry = new AdapterRegistry(true);
    var _nextId  = 1;
    var _sync = false;

    function getTarget(smd, method){
        var dest=smd._baseUrl;
        if(smd.target){
            dest = new dojo._Url(dest,smd.target) + '';
        }
        if(method.target){
            dest = new dojo._Url(dest,method.target) + '';
        }
        return dest;
    }

    function toOrdered(parameters, args){
        if(dojo.isArray(args)){ return args; }
        var data=[];
        for(var i=0;i<parameters.length;i++){
            data.push(args[parameters[i].name]);
        }
        return data;
    }

    var service = declare("xide.rpc.Service", null, {
        constructor: function(smd, options){
            // summary:
            //		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
            //		as a definition for the service
            // description:
            //		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
            //		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
            //		a "No match found" error.
            // smd: object
            //		Takes a number of properties as kwArgs for defining the service.  It also
            //		accepts a string.  When passed a string, it is treated as a url from
            //		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
            //		object.  It accepts serviceUrl, to manually define a url for the rpc service
            //		allowing the rpc system to be used without an smd definition. strictArgChecks
            //		forces the system to verify that the # of arguments provided in a call
            //		matches those defined in the smd.  smdString allows a developer to pass
            //		a jsonString directly, which will be converted into an object or alternatively
            //		smdObject is accepts an smdObject directly.

            var url;
            var self = this;
            var singleton = options ? options.singleton : false;
            function processSmd(smd){
                smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
                self._smd = smd;
                if(options && options.services==='methods'){
                    smd.services = smd.methods;
                    delete smd.methods;
                    smd.transport = "POST";
                    if(options.mixin){
                        lang.mixin(smd,options.mixin);
                    }
                    options = null;
                }

                //generate the methods
                for(var serviceName in self._smd.services){
                    var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
                    var current = self;
                    for(var i=0; i< pieces.length-1; i++){
                        // create or reuse each object as we go down the chain
                        current = current[pieces[i]] || (current[pieces[i]] = {});
                    }
                    current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
                }
            }
            if(smd){
                //ifthe arg is a string, we assume it is a url to retrieve an smd definition from
                if( (_.isString(smd)) || (smd instanceof dojo._Url)){
                    if(smd instanceof dojo._Url){
                        url = smd + "";
                    }else{
                        url = smd;
                    }

                    this.__init = xhr.getText(url);
                    var self = this;
                    this.__init.then(function(data){
                        processSmd(utils.fromJson(data));
                    });
                    /*

                    if(!text){
                        throw new Error("Unable to load SMD from " + smd);
                    }else{
                        processSmd(utils.fromJson(text));
                    }
                    */

                }else{
                    processSmd(smd);
                }
            }
            this._options = (options ? options : {});
            this._requestId = 0;
        },

        _generateService: function(serviceName, method){
            if(this[method]){
                throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
            }
            method.name = serviceName;

            var func = dojo.hitch(this, "_executeMethod",method);

            var transport = transportRegistry.match(method.transport || this._smd.transport);
            if(transport.getExecutor){
                func = transport.getExecutor(func,method,this);
            }
            var schema = method.returns || (method._schema = {}); // define the schema
            var servicePath = '/' + serviceName +'/';
            // schemas are minimally used to track the id prefixes for the different services
            schema._service = func;
            func.servicePath = servicePath;
            func._schema = schema;
            func.id = _nextId++;
            return func;
        },
        _getRequest: function(method,args){
            var smd = this._smd;
            var envDef = envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || []).concat(smd.parameters || []);
            if(envDef.namedParams){
                // the serializer is expecting named params
                if((args.length==1) && dojo.isObject(args[0])){
                    // looks like we have what we want
                    args = args[0];
                }else{
                    // they provided ordered, must convert
                    var data={};
                    for(var i=0;i<method.parameters.length;i++){
                        if(typeof args[i] != "undefined" || !method.parameters[i].optional){
                            data[method.parameters[i].name]=args[i];
                        }
                    }
                    args = data;
                }
                if(method.strictParameters||smd.strictParameters){
                    //remove any properties that were not defined
                    for(i in args){
                        var found=false;
                        for(var j=0; j<parameters.length;j++){
                            if(parameters[j].name==i){ found=true; }
                        }
                        if(!found){
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for(i=0; i< parameters.length; i++){
                    var param = parameters[i];
                    if(!param.optional && param.name && !args[param.name]){
                        if(param["default"]){
                            args[param.name] = param["default"];
                        }else if(!(param.name in args)){
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            }else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
                // looks like named params, we will convert
                if(envDef.namedParams === false){
                    // the serializer is expecting ordered params, must be ordered
                    args = toOrdered(parameters, args);
                }else{
                    // named is ok
                    args = args[0];
                }
            }

            if(dojo.isObject(this._options)){
                args = dojo.mixin(args, this._options);
            }
            delete args['mixin'];

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: _sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function(method){
            var args = [];
            var i;
            for(i=1; i< arguments.length; i++){
                args.push(arguments[i]);
            }
            var request = this._getRequest(method,args);
            var deferred = transportRegistry.match(request.transport).fire(request);

            deferred.addBoth(function(results){
                return request._envDef.deserialize.call(this,results);
            });
            return deferred;
        }
});

    service.transportRegistry = transportRegistry;
    service.envelopeRegistry = envelopeRegistry;
    service._nextId = _nextId;
    service.getTarget = getTarget;
    service.toOrdered= toOrdered;
    service._sync = _sync;
    envelopeRegistry.register("URL", function(str){ return str == "URL"; },{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	});
    envelopeRegistry.register("JSON",function(str){ return str == "JSON"; },{
        serialize: function(smd, method, data){
            var d = dojo.toJson(data);

            return {
                data: d,
                handleAs: 'json',
                contentType : 'application/json'
            };
        },
        deserialize: function(results){
            return results;
        }
    });
    envelopeRegistry.register("PATH",function(str){ return str == "PATH"; },{
        serialize:function(smd, method, data){
			var i;
			var target = getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}
			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	});
    //post is registered first because it is the default;
    transportRegistry.register("POST",function(str){ return str == "POST"; },{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	});
    transportRegistry.register("GET",function(str){ return str == "GET"; },{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return xhr.get(r);
		}
	});
    //only works ifyou include dojo.io.script
    /*
    transportRegistry.register("JSONP",function(str){ return str == "JSONP"; },{
        fire: function(r){
            r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
            r.callbackParamName = r.callbackParamName || "callback";
            return dojo.io.script.get(r);
        }
    });*/
    if(dojo._contentHandlers) {
        dojo._contentHandlers.auto = function (xhr) {
            // automatically choose the right handler based on the returned content type
            var handlers = dojo._contentHandlers;
            var retContentType = xhr.getResponseHeader("Content-Type");
            var results = !retContentType ? handlers.text(xhr) :
                retContentType.match(/\/.*json/) ? handlers.json(xhr) :
                    retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
                        retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
            return results;
        };
    }
    return service;
});

},
'xide/manager/WindowManager':function(){
/** @module xide/manager/WindowManager **/
define([
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xide/manager/ManagerBase',
    'xide/editor/Registry',
    'xide/registry',
    'xdojo/has',
    'xace/views/Editor'
], function (dcl, utils, types, ManagerBase, Registry, registry, has, Editor) {

    function register(what, where, _active) {
        where.addActionEmitter(what);
        if (_active !== false) {
            where.setActionEmitter(what);
        }
    }

    function clear(what, where, _active) {
        where.setActionEmitter(what);
    }

    function findFrame(docker) {
        var panels = docker.getPanels();
        if (docker._lastSelected) {
            for (var i = 0; i < panels.length; i++) {
                var panel = panels[i];
                if (panel == docker._lastSelected) {
                    var frame = panel.getFrame();
                    if (frame) {
                        return frame;
                    }
                }
            }
        }
    }

    /**
     * @class module:xide/manager/WindowManager
     * @extends module:xide/manager/ManagerBase
     */
    var Module = dcl(ManagerBase, {
        declaredClass: 'xide.manager.WindowManager',
        actionReceivers: null,
        /**
         *
         * @returns {Array}
         */
        getActions: function () {
            var result = [];
            var thiz = this;
            result.push(this.ctx.createAction('Next', 'View/Next', 'fa-cube', ['alt num_add'], 'Home', 'View', "global",
                //onCreate
                function (action) {
                },
                //handler
                function () {
                    var docker = thiz.ctx.mainView.getDocker();
                    var frame = findFrame(docker);
                    if (!frame) {
                        return;
                    }
                    var pos = frame._curTab;
                    var panel = frame.panel(pos);
                    var next = frame.panel(pos + 1);
                    if (panel || next) {
                        (next || panel ).select();
                        (next || panel ).resize();
                        docker.resize();
                    }
                },
                {
                    addPermission: true,
                    show: true
                }, null, null,
                //permissions:
                [], window, this
            ));
            result.push(this.ctx.createAction('Prev', 'View/Prev', 'fa-cube', ['alt num_subtract'], 'Home', 'View', "global",
                //onCreate
                function (action) {
                },
                //handler
                function () {
                    var docker = thiz.ctx.mainView.getDocker();
                    var frame = findFrame(docker);
                    if (!frame) {
                        return;
                    }
                    var pos = frame._curTab;

                    var panel = frame.panel(pos);
                    var next = frame.panel(pos - 1);
                    if (panel || next) {

                        (next || panel ).select();
                        (next || panel ).resize();
                        docker.resize();
                    }
                },
                {
                    addPermission: true,
                    show: true
                }, null, null,
                //permissions:
                [], window, this
            ));


            return result;
        },
        init: function () {
            this.ctx.addActions(this.getActions());
            this.actionReceivers = [];
        },
        addActionReceiver: function (receiver) {
            if (this.actionReceivers.indexOf(receiver) == -1) {
                this.actionReceivers.push(receiver);
                receiver._on('destroy', function () {
                    this.actionReceivers.remove(receiver);
                }, this);
            }
        },
        registerView: function (view, active) {
            var toolbar = this.getToolbar(),
                menu = this.getMainMenu();

            this.publish(types.EVENTS.ON_OPEN_VIEW, {
                view: view,
                menu: menu,
                toolbar: toolbar,
                src: this
            });
            toolbar && register(view, toolbar, active);
            menu && register(view, menu, active);
            var receivers = this.actionReceivers;
            _.each(receivers, function (widget) {
                widget && register(view, widget, active);
            });
            return true;
        },
        clearView: function (view, active) {
            var toolbar = this.getToolbar(),
                menu = this.getMainMenu(),
                breadcrumb = this.getBreadcrumb();
            toolbar && clear(view, toolbar, active);
            menu && clear(view, menu, active);
            return true;
        },
        getBreadcrumb: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView && mainView.getBreadcrumb ? mainView.getBreadcrumb() : null;
        },
        getToolbar: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView.getToolbar();
        },
        getMainMenu: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView.mainMenu;
        },
        /**
         *
         * @param title
         * @param icon
         * @param where
         * @returns {module:xdocker/Panel2}
         */
        createTab: function (title, icon, where) {
            var docker = this.getContext().getMainView().getDocker();
            return docker.addTab(null, {
                title: title,
                target: where ? where._parent : docker.getDefaultPanel(),
                icon: icon || 'fa-code'
            });
        },
        /**
         *
         * @returns {module:xdocker/Panel2}
         */
        getDefaultPanel: function () {
            return this.getContext().getMainView().getDocker().getDefaultPanel();
        },
        /**
         * @param title
         * @param icon
         * @returns {module:xdocker/Panel2}
         */
        createDefaultTab: function (title, icon) {
            return this.getContext().getMainView().getDocker().addTab(null, {
                title: title,
                icon: icon
            });
        },
        /**
         *
         * @param item {module:xfile/model/File}
         * @param where {module:xide/widgets/_Widget|null}
         * @param mixin {object} constructor argument mixin for the new view created
         * @param select {boolean} select the view (will update actions in global action receivers)
         * @returns {module:xide/editor/Base}
         */
        openItem: function (item, where, mixin, select) {
            if (!item || !item.getPath) {
                console.error('invalid item!');
                return null;
            }

            if (item && !item.getPath().match(/^(.*\.(?!(zip|tar|gz|bzip2)$))?[^.]*$/i)) {
                return;
            }
            var thiz = this,
                ctx = this.ctx;

            var root = where || registry.byId(this.appendTo);
            var docker = ctx.getMainView().getDocker();
            //create tab
            var title = utils.toString(item.name);
            if (_.isFunction(where)) {
                root = where({
                    title: title,
                    icon: 'fa-code',
                    location: null,
                    tabOrientation: null
                });
            } else {
                root = docker.addTab(null, {
                    title: title,
                    target: where ? where._parent : null,
                    icon: 'fa-code'
                });
            }

            if ( false ) {
                if (!root) {
                    console.error('have no attachment parent!');
                    return;
                }
            }

            var args = {
                dataItem: item,
                item: item,
                filePath: item.path,
                config: this.config,
                delegate: this,
                parentContainer: root,
                store: this.store,
                style: 'padding:0px;height:inherit;height:width;',
                iconClass: 'fa-code',
                autoSelect: true,
                ctx: ctx,
                /***
                 * Provide a text editor store delegate
                 */
                storeDelegate: {
                    getContent: function (onSuccess) {
                        thiz.ctx.getFileManager().getContent(item.mount, item.path, onSuccess);
                    },
                    saveContent: function (value, onSuccess, onError) {
                        thiz.ctx.getFileManager().setContent(item.mount, item.path, value, onSuccess);
                    }

                },
                title: title,
                closable: true,
                fileName: item.path
            };

            utils.mixin(args, mixin);
            var editor = utils.addWidget(Editor, args, this, root, true, null, null, select);
            root.resize();
            editor.resize();

            if (select !== false && root.selectChild) {
                root.selectChild(editor);
            }

            docker.resize();
            if (mixin && mixin.register) {
                this.registerView(editor, select);
            }
            return editor;
        }
    });
    return Module;
});
},
'dijit/Viewport':function(){
define([
	"dojo/Evented",
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff",	// has("ie"), has("ios")
	"dojo/window" // getBox()
], function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
});

},
'xide/views/_PanelDialog':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/utils',
    'xide/views/_Panel'
], function (dcl,utils,_Panel,CIView) {

    var Module = dcl(_Panel,{
        containerClass:'CIDialog',
        getDefaultOptions:function(mixin){
            var self = this;
            var options = {
                "contentSize": {
                    width: '600px',
                    height: '500px'
                },
                footerToolbar:[
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-danger btn-sm",
                        btntext:  " Cancel",
                        callback: function( event ){
                            event.data.close();
                            self.onCancel();
                        }
                    },
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-primary btn-sm",
                        btntext:  " Ok",
                        callback: function( event ){
                            self.onOk(self.changedCIS);
                            event.data.close();
                        }
                    }
                ]
            };
            utils.mixin(options,mixin);
            return options;
        },
        onShow:function(panel,contentNode,instance){

        }
    });

    dcl.chainAfter(Module,"onShow");
    return Module;
});
},
'xide/editor/Registry':function(){
define([
    'dcl/dcl',
    'xdojo/declare',
    'xide/factory',
    'xide/types',
    'xide/data/Memory'
], function (dcl,declare, factory, types,Memory) {

    //exported mixin
    var editorMixin;

    //singleton store
    var store;

    var debug=false;

    editorMixin = dcl(null, {
        declaredClass:"xide.editor.Registry",
        delegate: null,
        editors: null,
        _started: false,
        startup: function () {
            this.subscribe(types.EVENTS.REGISTER_EDITOR, function (data) {
                editorMixin.onRegisterEditor(data);
            });
        }
    });

    editorMixin.editors = [];

    var editors = editorMixin.editors;

    editorMixin.getStore = function(){
        if(!store){
            store = new Memory({
                idProperty:'name'
            })
        }
        return store;
    };

    editorMixin.getExtension = function (fname) {
        if (fname != null) {
            return fname.substr((~-fname.lastIndexOf(".") >>> 0) + 2);
        }
        return "";
    };

    editorMixin._hasEditor = function (name,extensions) {
        return _.find(editorMixin.editors,{
            name:name,
            extensions:extensions
        });
    };

    editorMixin.unregisterEditor = function (name) {
        var _store = editorMixin.getStore();
        var editors = _store._find({
            name:name
        });
        function unregister(editor){
            _store.removeSync(editor.name);
            _.each(editors,function(_editor){
                if(_editor && _editor.name === editor.name){
                    editors.remove(_editor);
                }
            });
        }
        _.each(editors,unregister);
    };

    editorMixin.onRegisterEditor = function (eventData) {
        var _store = editorMixin.getStore();
        var allEditors = _store._find({
            name:eventData.name
        });
       if(allEditors.length>0){
           debug && console.warn('Editor already registered',eventData);
           _.each(allEditors,function(editor){
               _store.removeSync(editor.name);
               editorMixin.unregisterEditor(editor.name);
           });
        }
        _store.putSync(eventData);
        if (!editorMixin._hasEditor(eventData.name,eventData.extensions)) {
            editors.push(eventData);
        }
    };

    editorMixin.getDefaultEditor = function (item) {
        var editors = editorMixin.getEditors(item);
        if (!editors) {
            return null;
        }

        for (var i = 0; i < editors.length; i++) {
            var obj = editors[i];
            if (obj.isDefault === true) {
                return obj;
            }
        }
        return null;
    };

    editorMixin.getEditor = function(name){
        return _.find(editors,{
            name:name
        });
    };

    editorMixin.getEditors = function (item) {
        if(!item){
            return editors;
        }
        var extension = editorMixin.getExtension(item.path);
        if (extension != null && extension.length == 0) {
            return null;
        }
        extension=extension.toLowerCase();
        var result = [];
        if (!editorMixin.editors) {
            return null;
        }

        var store = editorMixin.getStore();
        var _defaultEditor = store._find({
            defaultEditor:true
        });

        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (editor) {
                //check multiple extensions
                if (editor.extensions.indexOf('|') != -1) {
                    var supportedPluginExtensions = editor.extensions.split('|');
                    for (var j = 0; j < supportedPluginExtensions.length; j++) {
                        var supportedPluginExtension = supportedPluginExtensions[j];
                        if (supportedPluginExtension === extension) {
                            result.push(editor);
                        }
                    }
                } else {
                    //otherwise single extension match
                    if (editor.extensions === extension) {
                        result.push(editor);
                    }
                }
            }
        }

        if(_defaultEditor.length==1){
            result.push(_defaultEditor[0]);
        }

        if (result.length > 0) {
            return result;
        }
        return null;
    };

    return editorMixin;
});
},
'xide/utils':function(){
define([
    "dcl/dcl"
], function (dcl) {
    return dcl(null, {
        declaredClass:"xide.utils"
    });
});
},
'dojo/dom-construct':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"],
	function(exports, dojo, has, win, dom, attr){
		// module:
		//		dojo/dom-construct
		// summary:
		//		This module defines the core dojo DOM construction API.

		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

		// support stuff for toDom()
		var tagWrap = {
				option: ["select"],
				tbody: ["table"],
				thead: ["table"],
				tfoot: ["table"],
				tr: ["table", "tbody"],
				td: ["table", "tbody", "tr"],
				th: ["table", "thead", "tr"],
				legend: ["fieldset"],
				caption: ["table"],
				colgroup: ["table"],
				col: ["table", "colgroup"],
				li: ["ul"]
			},
			reTag = /<\s*([\w\:]+)/,
			masterNode = {}, masterNum = 0,
			masterName = "__" + dojo._scopeName + "ToDomId";

		// generate start/end tag strings to use
		// for the injection for each special tag wrap case.
		for(var param in tagWrap){
			if(tagWrap.hasOwnProperty(param)){
				var tw = tagWrap[param];
				tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
				tw.post = "</" + tw.reverse().join("></") + ">";
				// the last line is destructive: it reverses the array,
				// but we don't care at this point
			}
		}

		var html5domfix;
		if(has("ie") <= 8){
			html5domfix = function(doc){
				doc.__dojo_html5_tested = "yes";
				var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
				if(div.childNodes.length !== 1){
					('abbr article aside audio canvas details figcaption figure footer header ' +
					'hgroup mark meter nav output progress section summary time video').replace(
						/\b\w+\b/g, function(n){
							doc.createElement(n);
						}
					);
				}
				destroy(div);
			}
		}

		function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
			var parent = ref.parentNode;
			if(parent){
				parent.insertBefore(node, ref);
			}
		}

		function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
			// summary:
			//		Try to insert node after ref
			var parent = ref.parentNode;
			if(parent){
				if(parent.lastChild == ref){
					parent.appendChild(node);
				}else{
					parent.insertBefore(node, ref.nextSibling);
				}
			}
		}

		exports.toDom = function toDom(frag, doc){
			// summary:
			//		instantiates an HTML fragment returning the corresponding DOM.
			// frag: String
			//		the HTML fragment
			// doc: DocumentNode?
			//		optional document to use when creating DOM nodes, defaults to
			//		dojo/_base/window.doc if not specified.
			// returns:
			//		Document fragment, unless it's a single node in which case it returns the node itself
			// example:
			//		Create a table row:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
			//	|	});

			doc = doc || win.doc;
			var masterId = doc[masterName];
			if(!masterId){
				doc[masterName] = masterId = ++masterNum + "";
				masterNode[masterId] = doc.createElement("div");
			}

			if(has("ie") <= 8){
				if(!doc.__dojo_html5_tested && doc.body){
					html5domfix(doc);
				}
			}

			// make sure the frag is a string.
			frag += "";

			// find the starting tag, and get node wrapper
			var match = frag.match(reTag),
				tag = match ? match[1].toLowerCase() : "",
				master = masterNode[masterId],
				wrap, i, fc, df;
			if(match && tagWrap[tag]){
				wrap = tagWrap[tag];
				master.innerHTML = wrap.pre + frag + wrap.post;
				for(i = wrap.length; i; --i){
					master = master.firstChild;
				}
			}else{
				master.innerHTML = frag;
			}

			// one node shortcut => return the node itself
			if(master.childNodes.length == 1){
				return master.removeChild(master.firstChild); // DOMNode
			}

			// return multiple nodes as a document fragment
			df = doc.createDocumentFragment();
			while((fc = master.firstChild)){ // intentional assignment
				df.appendChild(fc);
			}
			return df; // DocumentFragment
		};

		exports.place = function place(node, refNode, position){
			// summary:
			//		Attempt to insert node into the DOM, choosing from various positioning options.
			//		Returns the first argument resolved to a DOM node.
			// node: DOMNode|DocumentFragment|String
			//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
			// refNode: DOMNode|String
			//		id or node reference to use as basis for placement
			// position: String|Number?
			//		string noting the position of node relative to refNode or a
			//		number indicating the location in the childNodes collection of refNode.
			//		Accepted string values are:
			//
			//		- before
			//		- after
			//		- replace
			//		- only
			//		- first
			//		- last
			//
			//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
			//		"only" replaces all children.  position defaults to "last" if not specified
			// returns: DOMNode
			//		Returned values is the first argument resolved to a DOM node.
			//
			//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
			// example:
			//		Place a node by string id as the last child of another node by string id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode");
			//	|	});
			// example:
			//		Place a node by string id before another node by string id
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode", "before");
			//	|	});
			// example:
			//		Create a Node, and place it in the body element (last child):
			//	|	require(["dojo/dom-construct", "dojo/_base/window"
			//	|	], function(domConstruct, win){
			//	|		domConstruct.place("<div></div>", win.body());
			//	|	});
			// example:
			//		Put a new LI as the first child of a list by id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("<li></li>", "someUl", "first");
			//	|	});

			refNode = dom.byId(refNode);
			if(!refNode){
				console.error('have no node in domConstruct');
				console.trace();
				return;
			}
			if(typeof node == "string"){ // inline'd type check
				node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
			}
			if(typeof position == "number"){ // inline'd type check
				var cn = refNode.childNodes;
				if(!cn.length || cn.length <= position){
					refNode.appendChild(node);
				}else{
					_insertBefore(node, cn[position < 0 ? 0 : position]);
				}
			}else{
				switch(position){
					case "before":
						_insertBefore(node, refNode);
						break;
					case "after":
						_insertAfter(node, refNode);
						break;
					case "replace":
						refNode.parentNode.replaceChild(node, refNode);
						break;
					case "only":
						exports.empty(refNode);
						refNode.appendChild(node);
						break;
					case "first":
						if(refNode.firstChild){
							_insertBefore(node, refNode.firstChild);
							break;
						}
					// else fallthrough...
					default: // aka: last
					{
						if(!refNode){
							console.error('bad');
							console.trace();
							return null;
						}
						refNode.appendChild(node);
					}
				}
			}
			return node; // DomNode
		};

		var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
			// summary:
			//		Create an element, allowing for optional attribute decoration
			//		and placement.
			// description:
			//		A DOM Element creation function. A shorthand method for creating a node or
			//		a fragment, and allowing for a convenient optional attribute setting step,
			//		as well as an optional DOM placement reference.
			//
			//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
			//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
			//
			//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
			//		the action node, passing along the optional reference node and position.
			// tag: DOMNode|String
			//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
			//		or an existing DOM node to process.
			// attrs: Object
			//		An object-hash of attributes to set on the newly created node.
			//		Can be null, if you don't want to set any attributes/styles.
			//		See: `dojo/dom-attr.set` for a description of available attributes.
			// refNode: DOMNode|String?
			//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
			//		node somewhere in the dom relative to refNode. Can be a DomNode reference
			//		or String ID of a node.
			// pos: String?
			//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
			//		though can be set to "first","after","before","last", "replace" or "only"
			//		to further control the placement of the new node relative to the refNode.
			//		'refNode' is required if a 'pos' is specified.
			// example:
			//		Create a DIV:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div");
			//	|	});
			//
			// example:
			//		Create a DIV with content:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
			//	|	});
			//
			// example:
			//		Place a new DIV in the BODY, with no attributes set
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		var n = domConstruct.create("div", null, win.body());
			//	|	});
			//
			// example:
			//		Create an UL, and populate it with LI's. Place the list as the first-child of a
			//		node with id="someId":
			//	|	require(["dojo/dom-construct", "dojo/_base/array"],
			//	|	function(domConstruct, arrayUtil){
			//	|		var ul = domConstruct.create("ul", null, "someId", "first");
			//	|		var items = ["one", "two", "three", "four"];
			//	|		arrayUtil.forEach(items, function(data){
			//	|			domConstruct.create("li", { innerHTML: data }, ul);
			//	|		});
			//	|	});
			//
			// example:
			//		Create an anchor, with an href. Place in BODY:
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
			//	|	});

			var doc = win.doc;
			if(refNode){
				refNode = dom.byId(refNode);
				doc = refNode.ownerDocument;
			}
			if(typeof tag == "string"){ // inline'd type check
				tag = doc.createElement(tag);
			}
			if(attrs){ attr.set(tag, attrs); }
			if(refNode){ exports.place(tag, refNode, pos); }
			return tag; // DomNode
		};

		function _empty(/*DomNode*/ node){
			// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
			// and then uncomment the emptyGrandchildren() test case from html.html.
			// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
			// see http://jsperf.com/clear-dom-node.
			if("innerHTML" in node){
				try{
					// fast path
					node.innerHTML = "";
					return;
				}catch(e){
					// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
					// Fall through (saves bytes)
				}
			}

			// SVG/strict elements don't support innerHTML
			for(var c; c = node.lastChild;){ // intentional assignment
				node.removeChild(c);
			}
		}

		exports.empty = function empty(/*DOMNode|String*/ node){
			// summary:
			//		safely removes all children of the node.
			// node: DOMNode|String
			//		a reference to a DOM node or an id.
			// example:
			//		Destroy node's children byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.empty("someId");
			//	|	});

			_empty(dom.byId(node));
		};


		function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
			// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
			if(node.firstChild){
				_empty(node);
			}
			if(parent){
				// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
				// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
				// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
				// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
				has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
			}
		}
		var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
			// summary:
			//		Removes a node from its parent, clobbering it and all of its
			//		children.
			//
			// description:
			//		Removes a node from its parent, clobbering it and all of its
			//		children. Function only works with DomNodes, and returns nothing.
			//
			// node: DOMNode|String
			//		A String ID or DomNode reference of the element to be destroyed
			//
			// example:
			//		Destroy a node byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.destroy("someId");
			//	|	});

			node = dom.byId(node);
			if(!node){ return; }
			_destroy(node, node.parentNode);
		};
	});

},
'xgrid/Clipboard':function(){
/** @module xgrid/Clipboard **/
define([
    "xdojo/declare",
    'xide/types'
], function (declare,types) {

    var Implementation = {
        runAction:function(action){
            switch (action.command){
                case types.ACTION.CLIPBOARD_COPY:{
                    this.clipboardCopy();
                    this.refreshActions();
                    return true;
                }
                case types.ACTION.CLIPBOARD_PASTE:{
                    return this.clipboardPaste();
                }
                case types.ACTION.CLIPBOARD_CUT:{
                    this.clipboardCut();
                    return true;
                }
            }
            return this.inherited(arguments);
        },
        clipboardPaste:function(){
            return this.inherited(arguments);
        },
        /**
         * Clipboard/Copy action
         */

        clipboardCopy:function(){
            this.currentCutSelection=null;
            this.currentCopySelection=this.getSelection();
            this.publish(types.EVENTS.ON_CLIPBOARD_COPY,{
                selection:this.currentCopySelection,
                owner:this,
                type:this.itemType
            });
        },
        clipboardCut:function(){
            this.currentCopySelection = null;
            this.currentCutSelection = this.getSelection();
        },
        getClipboardActions:function(addAction){
            var thiz = this,
                actions = [],
                ACTION = types.ACTION;

            function _selection(){
                var selection = thiz.getSelection();
                if (!selection || !selection.length) {
                    return null;
                }
                var item = selection[0];
                if(!item){
                    console.error('have no item');
                    return null;
                }
                return selection;
            }

            function isItem() {
                var selection = _selection();
                if (!selection) {
                    return true;
                }
                return false;
            }

            function disable(){
                switch (this.title){
                    case 'Cut':
                    case 'Copy':{
                        return isItem()!==false;
                    }
                    case 'Paste':{
                        return thiz.currentCopySelection==null;
                    }
                }
                return false;
            }
            function _createEntry(label,command,icon,keyCombo) {
                actions.push(thiz.createAction({
                    label: label,
                    command: command,
                    icon: icon,
                    tab: 'Home',
                    group: 'Clipboard',
                    keycombo: keyCombo,
                    mixin: {
                        addPermission:true,
                        quick:true
                    },
                    shouldDisable:disable
                }));
            }
            _createEntry('Copy',ACTION.CLIPBOARD_COPY,'fa-copy','ctrl c');
            _createEntry('Paste',ACTION.CLIPBOARD_PASTE,'fa-paste','ctrl v');
            _createEntry('Cut',ACTION.CLIPBOARD_CUT,'fa-cut','ctrl x');
            return actions;
        }
    };

    //package via declare
    var _class = declare('xgrid.Clipboard',null,Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'dstore/Filter':function(){
define(['dojo/_base/declare'], function (declare) {
	// a Filter builder
	function filterCreator(type) {
		// constructs a new filter based on type, used to create each method
		return function newFilter() {
			var Filter = this.constructor;
			var filter = new Filter();
			filter.type = type;
			filter.args = arguments;
			if (this.type) {
				// we are chaining, so combine with an and operator
				return filterCreator('and').call(Filter.prototype, this, filter);
			}
			return filter;
		};
	}
	var Filter = declare(null, {
		constructor: function (filterArg) {
			var argType = typeof filterArg;
			switch (argType) {
				case 'object':
					var filter = this;
					// construct a filter based on the query object
					for (var key in filterArg){
						var value = filterArg[key];
						if (value instanceof this.constructor) {
							// fully construct the filter from the single arg
							filter = filter[value.type](key, value.args[0]);
						} else if (value && value.test) {
							// support regex
							filter = filter.match(key, value);
						} else {
							filter = filter.eq(key, value);
						}
					}
					this.type = filter.type;
					this.args = filter.args;
					break;
				case 'function': case 'string':
					// allow string and function args as well
					this.type = argType;
					this.args = [filterArg];
			}
		},
		// define our operators
		and: filterCreator('and'),
		or: filterCreator('or'),
		eq: filterCreator('eq'),
		ne: filterCreator('ne'),
		lt: filterCreator('lt'),
		lte: filterCreator('lte'),
		gt: filterCreator('gt'),
		gte: filterCreator('gte'),
		contains: filterCreator('contains'),
		'in': filterCreator('in'),
		match: filterCreator('match')
	});
	Filter.filterCreator = filterCreator;
	return Filter;
});
},
'dstore/SimpleQuery':function(){
define([
	'dojo/_base/declare',
	'dojo/_base/array'
], function (declare, arrayUtil) {

	// module:
	//		dstore/SimpleQuery

	function makeGetter(property, queryAccessors) {
		if (property.indexOf('.') > -1) {
			var propertyPath = property.split('.');
			var pathLength = propertyPath.length;
			return function (object) {
				for (var i = 0; i < pathLength; i++) {
					object = object && (queryAccessors && object.get ? object.get(propertyPath[i]) : object[propertyPath[i]]);
				}
				return object;
			};
		}
		// else
		return function (object) {
			return object.get ? object.get(property) : object[property];
		};
	}

	var comparators = {
		eq: function (value, required) {
			return value === required;
		},
		'in': function(value, required) {
			// allow for a collection of data
			return arrayUtil.indexOf(required.data || required, value) > -1;
		},
		ne: function (value, required) {
			return value !== required;
		},
		lt: function (value, required) {
			return value < required;
		},
		lte: function (value, required) {
			return value <= required;
		},
		gt: function (value, required) {
			return value > required;
		},
		gte: function (value, required) {
			return value >= required;
		},
		match: function (value, required, object) {
			return required.test(value, object);
		},
		contains: function (value, required, object, key) {
			var collection = this;
			return arrayUtil.every(required.data || required, function (requiredValue) {
				if (typeof requiredValue === 'object' && requiredValue.type) {
					var comparator = collection._getFilterComparator(requiredValue.type);
					return arrayUtil.some(value, function (item) {
						return comparator.call(collection, item, requiredValue.args[1], object, key);
					});
				}
				return arrayUtil.indexOf(value, requiredValue) > -1;
			});
		}
	};

	return declare(null, {
		// summary:
		//		Mixin providing querier factories for core query types

		_createFilterQuerier: function (filter) {
			// create our matching filter function
			var queryAccessors = this.queryAccessors;
			var collection = this;
			var querier = getQuerier(filter);

			function getQuerier(filter) {
				var type = filter.type;
				var args = filter.args;
				var comparator = collection._getFilterComparator(type);
				if (comparator) {
					// it is a comparator
					var firstArg = args[0];
					var getProperty = makeGetter(firstArg, queryAccessors);
					var secondArg = args[1];
					if (secondArg && secondArg.fetchSync) {
						// if it is a collection, fetch the contents (for `in` and `contains` operators)
						secondArg = secondArg.fetchSync();
					}
					return function (object) {
						// get the value for the property and compare to expected value
						return comparator.call(collection, getProperty(object), secondArg, object, firstArg);
					};
				}
				switch (type) {
					case 'and': case 'or':
						for (var i = 0, l = args.length; i < l; i++) {
							// combine filters, using and or or
							var nextQuerier = getQuerier(args[i]);
							if (querier) {
								// combine the last querier with a new one
								querier = (function(a, b) {
									return type === 'and' ?
										function(object) {
											return a(object) && b(object);
										} :
										function(object) {
											return a(object) || b(object);

										};
								})(querier, nextQuerier);
							} else {
								querier = nextQuerier;
							}
						}
						return querier;
					case 'function':
						return args[0];
					case 'string':
						// named filter
						var filterFunction = collection[args[0]];
						if (!filterFunction) {
							throw new Error('No filter function ' + args[0] + ' was found in the collection');
						}
						return filterFunction;
					case undefined:
						return function () {
							return true;
						};
					default:
						throw new Error('Unknown filter operation "' + type + '"');
				}
			}
			return function (data) {
				return arrayUtil.filter(data, querier);
			};
		},

		_getFilterComparator: function (type) {
			// summary:
			//		Get the comparator for the specified type
			// returns: Function?

			return comparators[type] || this.inherited(arguments);
		},

		_createSelectQuerier: function (properties) {
			return function (data) {
				var l = properties.length;
				return arrayUtil.map(data, properties instanceof Array ?
					// array of properties
					function (object) {
						var selectedObject = {};
						for (var i = 0; i < l; i++) {
							var property = properties[i];
							selectedObject[property] = object[property];
						}
						return selectedObject;
					} :
					// single property
					function (object) {
						return object[properties];
					});
			};
		},

		_createSortQuerier: function (sorted) {
			var queryAccessors = this.queryAccessors;
			return function (data) {
				data = data.slice();
				data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
					for (var i = 0; i < sorted.length; i++) {
						var comparison;
						var sorter = sorted[i];
						if (typeof sorter == 'function') {
							comparison = sorter(a, b);
						} else {
							var getProperty = sorter.get || (sorter.get = makeGetter(sorter.property, queryAccessors));
							var descending = sorter.descending;
							var aValue = getProperty(a);
							var bValue = getProperty(b);

							aValue != null && (aValue = aValue.valueOf());
							bValue != null && (bValue = bValue.valueOf());

							comparison = aValue === bValue
								? 0
								: (!!descending === (aValue === null || aValue > bValue && bValue !== null) ? -1 : 1);
						}

						if (comparison !== 0) {
							return comparison;
						}
					}
					return 0;
				});
				return data;
			};
		}
	});
});

},
'xide/manager/PluginManager':function(){
/**
 * @module xide/manager/PluginManager
*/
define([
    'dcl/dcl',
    'dojo/has',
    'xide/manager/ManagerBase',
    'xide/utils',
    'xide/types',
    'xide/factory',
    "dojo/Deferred",
    "dojo/promise/all"
], function (dcl, has, ManagerBase, utils, types, factory, Deferred, all){
    var _debug = false;

    /**
     * Plugin manager which provides loading of additional modules at any time after the main layer(s)
     * have been loaded.
     * @class module:xide/manager/PluginManager
     * @extends module:xide/mixins/ReloadMixin
     */
    return dcl(ManagerBase,{
        declaredClass:"xide.manager.PluginManager",
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * When load() receives a module name without a slash, use this prefix
         *
         * @TODO: this must be changed into a map to configure this per 'run-time configuration'
         * @member string _defaultPackageLocationPrefix
         */
        _defaultPackageLocationPrefix:'../../',
        /**
         * When load() receives a module name without a slash, use this prefix
         * @member string _defaultPackageLocationSuffix
         */
        _defaultPackageLocationSuffix:'/component',
        /**
         * Whe loading a component, use this flags by default
         * @member module:xide.types.COMPONENT_FLAGS
         */
        _defaultComponentFlags:{
            /**
             * call load() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:LOAD
             */
            LOAD:1,
            /**
             * call run() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:RUN
             */
            RUN:2  //call run() when loaded
        },
        /**
         * Whe loading a component, mixin these properties/members
         * @member {Object}
         */
        defaultComponentMixin:function(flags){
            return {
                owner:this,
                ctx:this.ctx,
                flags:flags
            };
        },
        /**
         * List of modules to add to a components base classes. That will be used to add logging and others
         * @member {String[]}
         */
        componentBaseClasses:null,
        /**
         * Our context object
         * @member module: xide/manager/Context
         */
        ctx:null,
        /**
         * JSON data of plugin data
         * @member {Array}
         */
        pluginResources:null,
        /**
         * Array of plugin instances
         * @member {object[]}
         */
        pluginInstances:null,
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Components
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Called when component::load() is finish
         * @param component
         * @param flags
         * @param deferred
         * @private
         */
        _componentReady:function(component,flags,deferred){
            if (flags.RUN) {

                try {
                    component.run(this.ctx);//fire only, don't bother when it crashes
                }catch(e){
                    _debug && console.error('component: ' + component.getLabel() + ' crashed in run ' + e);
                }
            }
            return deferred.resolve(component);
        },
        /**
         * Called when a component has been loaded
         * @param component
         * @param flags
         * @param componentArguments
         * @param deferred
         * @private
         */
        _componentLoaded:function(component,flags,componentArguments,deferred){
            try {

                //add constructor arguments
                utils.mixin(componentArguments,this.defaultComponentMixin(flags));
                var componentInstance = factory.createInstance(component, componentArguments, this.componentBaseClasses);

                var _afterLoaded = function(componentInstance,flags,deferred){
                    this._componentReady(componentInstance,flags,deferred);
                }.bind(this);


                if (flags.LOAD) {
                    //call load, its async
                    componentInstance.load().then(function(){
                        _afterLoaded(componentInstance,flags,deferred);
                    });
                }else{
                    _afterLoaded(componentInstance,flags,deferred);
                }
            }catch(e){
                _debug && console.error('error in component creation!' + e);
                deferred.reject(arguments);
                logError(e);
            }

        },
        /**
         * Load a component
         *
         * @memberOf module:xide/manager/PluginManager#
         *
         * @param path {string} A require-js module path
         * @param {int} flags being used whilst loading
         * @param {object} componentArguments
         * @param packageLocation {string=}
         * @param packagePath {string=}
         */
        loadComponent:function(path,flags,componentArguments,packageLocation,packagePath){

            //defaults, sanitizing
            componentArguments = componentArguments ==='true' ? {} : componentArguments;

            path = path.indexOf('/') == -1 ? ( this._defaultPackageLocationPrefix + path + this._defaultPackageLocationSuffix ) : path;

            flags = flags!=null ? flags : this._defaultComponentFlags;

            var deferred = new Deferred(),
                self = this;

            var _component = utils.getObject(path);
            if(_component){
                //not loaded yet?
                if(_.isFunction(_component.then)){
                    _component.then(function(module){
                        self._componentLoaded(module,flags,componentArguments,deferred);
                    },function(err){
                        //shouldn't happen
                        console.error('error in loading component at path ' + path,err);
                    });
                }else{
                    //already loaded
                    this._componentLoaded(_component,flags,componentArguments,deferred);
                }
            }else{
                console.error('cant get object at ' + path);
            }

            _debug &&  console.log('load component ' + path);

            return deferred;
        },
        /**
         * Each component has a resource file within its directory with this pattern : resources-config.json.
         * When component is being loaded, we do load also client resources for that component (css,js,...)
         * @param component {xide.model.Component}
         * @param path
         */
        loadComponentResources:function(component,path){},
        /**
         * @TODO
         *
         * @param component
         */
        reloadComponent:function(component){},
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Plugins: to be removed soon.
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * @deprecated
         * @param pluginResources
         */
        loadPlugins:function(pluginResources){
            if(!has('plugins')) {
                return;
            }
            var dfd = new Deferred(),
                pluginPromises = [],
                thiz = this;

            this.pluginResources = pluginResources;
            this.pluginInstances = [];
            if(this.pluginResources){
                for(var i=0 ; i < this.pluginResources.length; i++){
                    var plug = this.pluginResources[i];
                    if(plug.type && plug.type=="JS-PLUGIN" && plug.path){
                        pluginPromises.push(this.loadComponent(plug.path,null,plug).then(function(component){
                            component.pluginResources = plug;
                            thiz.pluginInstances.push(component);
                        }));
                    }else{
                        _debug &&  console.warn('something wrong with plugin data');
                    }
                }
            }
            all(pluginPromises).then(function(){
                dfd.resolve(pluginPromises);
                _debug && console.log('plugins ready',thiz.pluginInstances);
                thiz.publish(types.EVENTS.ALL_PLUGINS_READY,{
                    instances:thiz.pluginInstances,
                    resources:pluginResources
                });
            });
            return dfd;
        }
    });
});
},
'wcDocker/docker':function(){
define([
    "dcl/dcl",
    "wcDocker/types",
    'wcDocker/panel',
    'wcDocker/ghost',
    'wcDocker/splitter',
    'wcDocker/frame',
    'wcDocker/collapser',
    'wcDocker/layoutsimple',
    'wcDocker/layouttable',
    'wcDocker/tabframe',
    'wcDocker/drawer',
    'wcDocker/base'
], function (dcl, wcDocker, wcPanel, wcGhost, wcSplitter, wcFrame, wcCollapser, wcLayoutSimple, wcLayoutTable, wcTabFrame, wcDrawer, base) {


    /**
     * Default class name to module mapping, being used for default options
     */
    var defaultClasses = {
        'wcPanel': wcPanel,
        'wcGhost': wcGhost,
        'wcSplitter': wcSplitter,
        'wcFrame': wcFrame,
        'wcCollapser': wcCollapser,
        'wcLayoutSimple': wcLayoutSimple,
        'wcLayoutTable': wcLayoutTable,
        'wcDrawer': wcDrawer,
        'wcTabFrame': wcTabFrame
    };

    /**
     * @class
     *
     * The main docker instance.  This manages all of the docking panels and user input.
     * There should only be one instance of this, although it is not enforced.<br>
     * See {@tutorial getting-started}
     */
    var Module = dcl(base, {
        declaredClass: 'wcDocker',
        /**
         *
         * @memberOf module:wcDocker
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element to store the contents of wcDocker.
         * @param {module:wcDocker~Options} [options] - Options for constructing the instance.
         */
        constructor: function (container, options) {

            this.$outer = $(container);
            this.$container = $('<div class="wcDocker">');
            this.$transition = $('<div class="wcDockerTransition">');
            this.$loading = null;

            this.$outer.append(this.$container);
            this.$container.append(this.$transition);

            this._canOrientTabs = true;

            this._events = {};

            this._root = null;
            this._frameList = [];
            this._floatingList = [];
            this._modalList = [];
            this._persistentList = [];
            this._focusFrame = null;
            this._placeholderPanel = null;
            this._contextTimer = 0;
            this._dirty = false;
            this._dirtyDontMove = false;

            this._splitterList = [];
            this._tabList = [];
            this._collapser = {};

            this._dockPanelTypeList = [];

            this._creatingPanel = false;
            this._draggingSplitter = null;
            this._draggingFrame = null;
            this._draggingFrameSizer = null;
            this._draggingFrameTab = null;
            this._draggingFrameTopper = false;
            this._draggingCustomTabFrame = null;
            this._ghost = null;
            this._menuTimer = 0;
            this._mouseOrigin = {x: 0, y: 0};

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            var defaultOptions = {
                themePath: 'Themes',
                theme: 'default',
                loadingClass: 'fa fa-spinner fa-pulse',
                allowContextMenu: true,
                hideOnResize: false,
                allowCollapse: true,
                responseRate: 10,
                moveStartDelay: 300,
                edgeAnchorSize: 50,
                panelAnchorSize: '15%',
                detachToWidth: '50%',
                detachToHeight: '50%'
            };

            this._options = {};

            //replay default classes into default options
            for (var prop in defaultClasses) {
                defaultOptions[prop + 'Class'] = defaultClasses[prop];
            }

            for (var prop in defaultOptions) {
                this._options[prop] = defaultOptions[prop];
            }

            for (var prop in options) {
                this._options[prop] = options[prop];
            }

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Retrieves whether panel collapsers are enabled.
         * @function module:wcDocker#isCollapseEnabled
         * @version 3.0.0
         * @returns {Boolean} - Collapsers are enabled.
         */
        isCollapseEnabled: function () {
            return (this._canOrientTabs && this._options.allowCollapse);
        },

        /**
         * Registers a new docking panel type to be used later.
         * @function module:wcDocker#registerPanelType
         * @version 3.0.0
         * @param {String} name - The name identifier for the new panel type.
         * @param {module:wcDocker~registerOptions} options  An options object for describing the panel type.
         * @param {Boolean} [isPrivate] - <b>DEPRECATED:</b> Use [options.isPrivate]{@link wcDocker~registerOptions} instead.
         * @returns {Boolean} - Success or failure. Failure usually indicates the type name already exists.
         */
        registerPanelType: function (name, optionsOrCreateFunc, isPrivate) {

            var options = optionsOrCreateFunc;
            if (typeof options === 'function') {
                options = {
                    onCreate: optionsOrCreateFunc
                };
                console.log("WARNING: Passing in the creation function directly to wcDocker.registerPanelType parameter 2 is now deprecated and will be removed in the next version!  Please use the preferred options object instead.");
            }

            if (typeof isPrivate != 'undefined') {
                options.isPrivate = isPrivate;
                console.log("WARNING: Passing in the isPrivate flag to wcDocker.registerPanelType parameter 3 is now deprecated and will be removed in the next version!  Please use the preferred options object instead.");
            }

            if (_.isEmpty(options)) {
                options = null;
            }

            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name === name) {
                    return false;
                }
            }

            this._dockPanelTypeList.push({
                name: name,
                options: options
            });
            return true;
        },

        /**
         * Retrieves a list of all currently registered panel types.
         * @function module:wcDocker#panelTypes
         * @param {Boolean} includePrivate - If true, panels registered as private will also be included with this list.
         * @returns {String[]} - A list of panel type names.
         */
        panelTypes: function (includePrivate) {
            var result = [];
            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (includePrivate || !this._dockPanelTypeList[i].options.isPrivate) {
                    result.push(this._dockPanelTypeList[i].name);
                }
            }
            return result;
        },

        /**
         * Retrieves the options data associated with a given panel type when it was registered.
         * @function module:wcDocker#panelTypeInfo
         * @param {String} typeName - The name identifier of the panel.
         * @returns {module:wcDocker~registerOptions} - Registered options of the panel type, or false if the panel was not found.
         */
        panelTypeInfo: function (typeName) {
            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name == typeName) {
                    return this._dockPanelTypeList[i].options;
                }
            }
            return false;
        },

        /**
         * Add a new docked panel to the docker instance.<br>
         * <b>Note:</b> It is best to use {@link wcDocker.COLLAPSED} after you have added your other docked panels, as it may ensure proper placement.
         * @function module:wcDocker#addPanel
         * @param {String} typeName - The name identifier of the panel to create.
         * @param {module:wcDocker.DOCK} location - The docking location to place this panel.
         * @param {module:wcPanel|module:wcDocker.COLLAPSED} [targetPanel] - A target panel to dock relative to, or use {@link wcDocker.COLLAPSED} to collapse it to the side or bottom.
         * @param {module:wcDocker~PanelOptions} [options] - Other options for panel placement.
         * @returns {module:wcPanel|Boolean} - The newly created panel object, or false if no panel was created.
         */
        addPanel: function (typeName, location, targetPanel, options) {
            function __addPanel(panel) {
                if (location === wcDocker.DOCK.STACKED) {
                    this.__addPanelGrouped(panel, targetPanel, options);
                } else {
                    this.__addPanelAlone(panel, location, targetPanel, options);
                }

                if (this._placeholderPanel && panel.moveable() &&
                    location !== wcDocker.DOCK.FLOAT &&
                    location !== wcDocker.DOCK.MODAL) {
                    if (this.removePanel(this._placeholderPanel)) {
                        this._placeholderPanel = null;
                    }
                }

                this.__forceUpdate();
            }

            // Find out if we have a persistent version of this panel type first.
            for (var a = 0; a < this._persistentList.length; ++a) {
                if (this._persistentList[a]._type === typeName) {
                    var panel = this._persistentList.splice(a, 1)[0];
                    __addPanel.call(this, panel);
                    panel.__trigger(wcDocker.EVENT.PERSISTENT_OPENED);
                    return panel;
                }
            }


            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name === typeName) {
                    var panelType = this._dockPanelTypeList[i];

                    var panel = new (this.__getClass('wcPanel'))(this, typeName, panelType.options);
                    panel.__container(this.$transition);
                    var panelOptions = (panelType.options && panelType.options.options) || options || {};
                    panel._panelObject = new panelType.options.onCreate(panel, panelOptions);

                    __addPanel.call(this, panel);
                    return panel;
                }
            }
            return false;
        },

        /**
         * Removes a docked panel from the window.
         * @function module:wcDocker#removePanel
         * @param {module:wcPanel} panel - The panel to remove.
         * @param {Boolean} dontDestroy - If true, the panel itself will not be destroyed.
         * @returns {Boolean} - Success or failure.
         */
        removePanel: function (panel, dontDestroy) {
            if (!panel) {
                return false;
            }

            // Do not remove if this is the last moveable panel.
            var lastPanel = this.__isLastPanel(panel);

            var parentFrame = panel._parent;
            if (parentFrame && parentFrame.instanceOf('wcFrame')) {
                // Trigger the closing event, if any explicitely returned false, we cancel the close event.
                var results = panel.__trigger(wcDocker.EVENT.CLOSING);
                for (var i = 0; i < results.length; ++i) {
                    if (!results[i]) {
                        return false;
                    }
                }

                if (dontDestroy) {
                    // Keep the panel in a hidden transition container so as to not
                    // destroy any event handlers that may be on it.
                    panel.__container(this.$transition);
                    panel._parent = null;
                } else {
                    panel.__trigger(wcDocker.EVENT.CLOSED);
                }

                // If no more panels remain in this frame, remove the frame.
                if (!parentFrame.removePanel(panel) && !parentFrame.isCollapser()) {
                    // If this is the last frame, create a dummy panel to take up
                    // the space until another one is created.
                    if (lastPanel) {
                        this.__addPlaceholder(parentFrame);

                        if (!dontDestroy) {
                            panel.__destroy();
                        } else {
                            panel.__trigger(wcDocker.EVENT.PERSISTENT_CLOSED);
                        }
                        return true;
                    }

                    var index = this._floatingList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._floatingList.splice(index, 1);
                    }
                    index = this._frameList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._frameList.splice(index, 1);
                    }
                    index = this._modalList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._modalList.splice(index, 1);
                    }

                    if (this._modalList.length) {
                        this.__focus(this._modalList[this._modalList.length - 1]);
                    } else if (this._floatingList.length) {
                        this.__focus(this._floatingList[this._floatingList.length - 1]);
                    }

                    var parentSplitter = parentFrame._parent;
                    if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                        parentSplitter.__removeChild(parentFrame);

                        var other;
                        if (parentSplitter.pane(0)) {
                            other = parentSplitter.pane(0);
                            parentSplitter._pane[0] = null;
                        } else {
                            other = parentSplitter.pane(1);
                            parentSplitter._pane[1] = null;
                        }

                        // Keep the panel in a hidden transition container so as to not
                        // destroy any event handlers that may be on it.
                        other.__container(this.$transition);
                        other._parent = null;

                        index = this._splitterList.indexOf(parentSplitter);
                        if (index !== -1) {
                            this._splitterList.splice(index, 1);
                        }

                        var parent = parentSplitter._parent;
                        var parentContainer = parentSplitter.__container();
                        parentSplitter.__destroy();

                        if (parent && parent.instanceOf('wcSplitter')) {
                            parent.__removeChild(parentSplitter);
                            if (!parent.pane(0)) {
                                parent.pane(0, other);
                            } else {
                                parent.pane(1, other);
                            }
                        } else if (parent === this) {
                            this._root = other;
                            other._parent = this;
                            other.__container(parentContainer);
                        }
                        this.__update();
                    } else if (parentFrame === this._root) {
                        this._root = null;
                    }

                    if (this._focusFrame === parentFrame) {
                        this._focusFrame = null;
                    }

                    parentFrame.__destroy();
                }

                if (!dontDestroy) {
                    panel.__destroy();
                } else {
                    panel.__trigger(wcDocker.EVENT.PERSISTENT_CLOSED);
                }
                return true;
            }
            return false;
        },

        /**
         * Moves a docking panel from its current location to another.
         * @function module:wcDocker#movePanel
         * @param {module:wcPanel} panel - The panel to move.
         * @param {module:wcDocker.DOCK} location - The new docking location of the panel.
         * @param {module:wcPanel|wcDocker.COLLAPSED} [targetPanel] - A target panel to dock relative to, or use {@link wcDocker.COLLAPSED} to collapse it to the side or bottom.
         * @param {module:wcDocker~PanelOptions} [options] - Other options for panel placement.
         * @returns {module:wcPanel|Boolean} - The panel that was created, or false on failure.
         */
        movePanel: function (panel, location, targetPanel, options) {
            var lastPanel = this.__isLastPanel(panel);

            var $elem = panel.$container;
            if (panel._parent && panel._parent.instanceOf('wcFrame')) {
                $elem = panel._parent.$frame;
            }
            var offset = $elem.offset();
            var width = $elem.width();
            var height = $elem.height();

            var parentFrame = panel._parent;
            var floating = false;
            if (parentFrame && parentFrame.instanceOf('wcFrame')) {
                floating = parentFrame._isFloating;
                // Remove the panel from the frame.
                for (var i = 0; i < parentFrame._panelList.length; ++i) {
                    if (parentFrame._panelList[i] === panel) {
                        if (parentFrame.isCollapser()) {
                            parentFrame._curTab = -1;
                        } else if (parentFrame._curTab >= i) {
                            parentFrame._curTab--;
                        }

                        // Keep the panel in a hidden transition container so as to not
                        // destroy any event handlers that may be on it.
                        panel.__container(this.$transition);
                        panel._parent = null;

                        parentFrame._panelList.splice(i, 1);
                        break;
                    }
                }

                if (!parentFrame.isCollapser() && parentFrame._curTab === -1 && parentFrame._panelList.length) {
                    parentFrame._curTab = 0;
                }

                parentFrame.__updateTabs();
                parentFrame.collapse();

                // If no more panels remain in this frame, remove the frame.
                if (!parentFrame.isCollapser() && parentFrame._panelList.length === 0) {
                    // If this is the last frame, create a dummy panel to take up
                    // the space until another one is created.
                    if (lastPanel) {
                        this.__addPlaceholder(parentFrame);
                    } else {
                        var index = this._floatingList.indexOf(parentFrame);
                        if (index !== -1) {
                            this._floatingList.splice(index, 1);
                        }
                        index = this._frameList.indexOf(parentFrame);
                        if (index !== -1) {
                            this._frameList.splice(index, 1);
                        }

                        var parentSplitter = parentFrame._parent;
                        if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                            parentSplitter.__removeChild(parentFrame);

                            var other;
                            if (parentSplitter.pane(0)) {
                                other = parentSplitter.pane(0);
                                parentSplitter._pane[0] = null;
                            } else {
                                other = parentSplitter.pane(1);
                                parentSplitter._pane[1] = null;
                            }

                            if (targetPanel === parentSplitter) {
                                targetPanel._shift = other;
                            }

                            // Keep the item in a hidden transition container so as to not
                            // destroy any event handlers that may be on it.
                            other.__container(this.$transition);
                            other._parent = null;

                            index = this._splitterList.indexOf(parentSplitter);
                            if (index !== -1) {
                                this._splitterList.splice(index, 1);
                            }

                            var parent = parentSplitter._parent;
                            var parentContainer = parentSplitter.__container();
                            parentSplitter.__destroy();

                            if (parent && parent.instanceOf('wcSplitter')) {
                                parent.__removeChild(parentSplitter);
                                if (!parent.pane(0)) {
                                    parent.pane(0, other);
                                } else {
                                    parent.pane(1, other);
                                }
                            } else if (parent === this) {
                                this._root = other;
                                other._parent = this;
                                other.__container(parentContainer);
                            }
                            this.__update();
                        }

                        if (this._focusFrame === parentFrame) {
                            this._focusFrame = null;
                        }

                        parentFrame.__destroy();
                    }
                }
            }

            panel.initSize(width, height);
            if (location === wcDocker.DOCK.STACKED) {
                this.__addPanelGrouped(panel, targetPanel, options);
            } else {
                this.__addPanelAlone(panel, location, targetPanel, options);
            }

            if (targetPanel == this._placeholderPanel) {
                this.removePanel(this._placeholderPanel);
                this._placeholderPanel = null;
            }

            var frame = panel._parent;
            if (frame && frame.instanceOf('wcFrame')) {
                if (frame._panelList.length === 1) {
                    frame.pos(offset.left + width / 2 + 20, offset.top + height / 2 + 20, true);
                }
            }

            this.__update(true);

            if (frame && frame.instanceOf('wcFrame')) {
                if (floating !== frame._isFloating) {
                    if (frame._isFloating) {
                        panel.__trigger(wcDocker.EVENT.DETACHED);
                    } else {
                        panel.__trigger(wcDocker.EVENT.ATTACHED);
                    }
                }
            }

            panel.__trigger(wcDocker.EVENT.MOVED);
            return panel;
        },

        /**
         * Finds all instances of a given panel type.
         * @function module:wcDocker#findPanels
         * @param {String} [typeName] - The name identifier for the panel. If not supplied, all panels are retrieved.
         * @returns {module:wcPanel[]} - A list of all panels found of the given type.
         */
        findPanels: function (typeName) {
            var result = [];
            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    if (!typeName || panel._type === typeName) {
                        result.push(panel);
                    }
                }
            }

            return result;
        },

        /**
         * Shows the loading screen.
         * @function module:wcDocker#startLoading
         * @param {String} [label] - An optional label to display.
         * @param {Number} [opacity=0.4] - If supplied, assigns a custom opacity value to the loading screen.
         * @param {Number} [textOpacity=1] - If supplied, assigns a custom opacity value to the loading icon and text displayed.
         */
        startLoading: function (label, opacity, textOpacity) {
            if (!this.$loading) {
                this.$loading = $('<div class="wcLoadingContainer"></div>');
                this.$outer.append(this.$loading);

                var $background = $('<div class="wcLoadingBackground"></div>');
                if (typeof opacity !== 'number') {
                    opacity = 0.4;
                }

                $background.css('opacity', opacity);
                this.$loading.append($background);

                var $icon = $('<div class="wcLoadingIconContainer"><i class="wcLoadingIcon ' + this._options.loadingClass + '"></i></div>');
                this.$loading.append($icon);

                if (label) {
                    var $label = $('<span class="wcLoadingLabel">' + label + '</span>');
                    this.$loading.append($label);
                }

                if (typeof textOpacity !== 'number') {
                    textOpacity = 1;
                }

                $icon.css('opacity', textOpacity);

                if ($label) {
                    $label.css('opacity', textOpacity);
                }
            }
        },

        /**
         * Hides the loading screen.
         * @function module:wcDocker#finishLoading
         * @param {Number} [fadeDuration=0] - The fade out duration for the loading screen.
         */
        finishLoading: function (fadeDuration) {
            if (this.$loading) {
                if (fadeDuration > 0) {
                    var self = this;
                    this.$loading.fadeOut(fadeDuration, function () {
                        self.$loading.remove();
                        self.$loading = null;
                    });
                } else {
                    this.$loading.remove();
                    this.$loading = null;
                }
            }
        },

        /**
         * Registers a global [event]{@link wcDocker.EVENT}.
         * @function module:wcDocker#on
         * @param {module:wcDocker.EVENT} eventType        - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} handler  - A handler function to be called for the event.
         * @returns {Boolean} Success or failure that the event has been registered.
         */
        on: function (eventType, handler) {
            if (!eventType) {
                return false;
            }

            if (!this._events[eventType]) {
                this._events[eventType] = [];
            }

            if (this._events[eventType].indexOf(handler) !== -1) {
                return false;
            }

            this._events[eventType].push(handler);
            return true;
        },

        /**
         * Unregisters a global [event]{@link wcDocker.EVENT}.
         * @function module:wcDocker#off
         * @param {module:wcDocker.EVENT} eventType          - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} [handler]  - The handler function registered with the event. If omitted, all events registered to the event type are unregistered.
         */
        off: function (eventType, handler) {
            if (typeof eventType === 'undefined') {
                this._events = {};
            } else {
                if (this._events[eventType]) {
                    if (typeof handler === 'undefined') {
                        this._events[eventType] = [];
                    } else {
                        for (var i = 0; i < this._events[eventType].length; ++i) {
                            if (this._events[eventType][i] === handler) {
                                this._events[eventType].splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },

        /**
         * Trigger an [event]{@link wcDocker.EVENT} on all panels.
         * @function module:wcDocker#trigger
         * @fires wcDocker~event:onEvent
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {Object} [data] - A custom data object to be passed along with the event.
         * @returns {Object[]} results - Returns an array with all results returned by event handlers.
         */
        trigger: function (eventName, data) {
            if (!eventName) {
                return false;
            }

            var results = [];

            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    results = results.concat(panel.__trigger(eventName, data));
                }
            }

            return results.concat(this.__trigger(eventName, data));
        },
        /**
         * Saves the current panel configuration into a serialized
         * string that can be used later to restore it.
         * @function module:wcDocker#save
         * @returns {String} - A serialized string that describes the current panel configuration.
         */
        save: function () {
            var data = {};

            data.floating = [];
            for (var i = 0; i < this._floatingList.length; ++i) {
                data.floating.push(this._floatingList[i].__save());
            }

            data.root = this._root.__save();

            if (!_.isEmpty(this._collapser)) {
                data.collapsers = {
                    left: this._collapser[wcDocker.DOCK.LEFT].__save(),
                    right: this._collapser[wcDocker.DOCK.RIGHT].__save(),
                    bottom: this._collapser[wcDocker.DOCK.BOTTOM].__save()
                };
            }

            return JSON.stringify(data, function (key, value) {
                if (value == Infinity) {
                    return "Infinity";
                }
                return value;
            });
        },

        /**
         * Restores a previously saved configuration.
         * @function module:wcDocker#restore
         * @param {String} dataString - A previously saved serialized string, See [wcDocker.save]{@link wcDocker#save}.
         */
        restore: function (dataString) {
            var data = JSON.parse(dataString, function (key, value) {
                if (value === 'Infinity') {
                    return Infinity;
                }
                return value;
            });

            this.clear();

            this._emit('beginRestore');

            this._root = this.__create(data.root, this, this.$container);
            this._root.__restore(data.root, this);

            for (var i = 0; i < data.floating.length; ++i) {
                var panel = this.__create(data.floating[i], this, this.$container);
                panel.__restore(data.floating[i], this);
            }

            this.__forceUpdate(false);

            if (!_.isEmpty(data.collapsers) && this.isCollapseEnabled()) {
                this.__initCollapsers();

                this._collapser[wcDocker.DOCK.LEFT].__restore(data.collapsers.left, this);
                this._collapser[wcDocker.DOCK.RIGHT].__restore(data.collapsers.right, this);
                this._collapser[wcDocker.DOCK.BOTTOM].__restore(data.collapsers.bottom, this);

                var self = this;
                setTimeout(function () {
                    self.__forceUpdate();
                });
            }
            this._emit('endRestore');
        },

        /**
         * Clears all contents from the docker instance.
         * @function module:wcDocker#clear
         */
        clear: function () {
            this._root = null;

            // Make sure we notify all panels that they are closing.
            this.trigger(wcDocker.EVENT.CLOSED);

            for (var i = 0; i < this._splitterList.length; ++i) {
                this._splitterList[i].__destroy();
            }

            for (var i = 0; i < this._frameList.length; ++i) {
                this._frameList[i].__destroy();
            }

            if (!_.isEmpty(this._collapser)) {
                this._collapser[wcDocker.DOCK.LEFT].__destroy();
                this._collapser[wcDocker.DOCK.RIGHT].__destroy();
                this._collapser[wcDocker.DOCK.BOTTOM].__destroy();
                this._collapser = {};
            }

            while (this._frameList.length) this._frameList.pop();
            while (this._floatingList.length) this._floatingList.pop();
            while (this._splitterList.length) this._splitterList.pop();

            this.off();
        },


        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Private Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        __init: function () {
            var self = this,
                body = $('body');


            this._root = null;
            this.__eventHandles = [];
            this.__addPlaceholder();

            // Setup our context menus.
            if (this._options.allowContextMenu) {
                this.menu('.wcFrame', [], true);
            }

            self.__on($(window), 'resize', this.__resize.bind(this));
            self.__on(body, 'contextmenu', '.wcSplitterBar', __onContextDisable);

            // $('body').on('selectstart', '.wcFrameTitleBar, .wcPanelTab, .wcFrameButton', function(event) {
            //   event.preventDefault();
            // });

            // Hovering over a panel creation context menu.
            self.__on(body, 'mouseenter', '.wcMenuCreatePanel', __onEnterCreatePanel);
            self.__on(body, 'mouseleave', '.wcMenuCreatePanel', __onLeaveCreatePanel);


            // Mouse move will allow you to move an object that is being dragged.
            self.__on(body, 'mousemove', __onMouseMove);
            self.__on(body, 'touchmove', __onMouseMove);

            // A catch all on mouse down to record the mouse origin position.
            self.__on(body, 'mousedown', __onMouseDown);
            self.__on(body, 'touchstart', __onMouseDown);

            self.__on(body, 'mousedown', '.wcModalBlocker', __onMouseDownModalBlocker);

            self.__on(body, 'touchstart', '.wcModalBlocker', __onMouseDownModalBlocker);
            // On some browsers, clicking and dragging a tab will drag it's graphic around.
            // Here I am disabling this as it interferes with my own drag-drop.
            self.__on(body, 'mousedown', '.wcPanelTab', __onPreventDefault);
            self.__on(body, 'touchstart', '.wcPanelTab', __onPreventDefault);
            self.__on(body, 'mousedown', '.wcFrameButtonBar > .wcFrameButton', __onMouseSelectionBlocker);
            self.__on(body, 'touchstart', '.wcFrameButtonBar > .wcFrameButton', __onMouseSelectionBlocker);
            // Mouse down on a frame title will allow you to move them.
            self.__on(body, 'mousedown', '.wcFrameTitleBar', __onMouseDownFrameTitle);
            self.__on(body, 'touchstart', '.wcFrameTitleBar', __onMouseDownFrameTitle);
            // Mouse down on a splitter bar will allow you to resize them.
            self.__on(body, 'mousedown', '.wcSplitterBar', __onMouseDownSplitter);
            self.__on(body, 'touchstart', '.wcSplitterBar', __onMouseDownSplitter);
            // Middle mouse button on a panel tab to close it.
            self.__on(body, 'mousedown', '.wcPanelTab', __onMouseDownPanelTab);
            self.__on(body, 'touchstart', '.wcPanelTab', __onMouseDownPanelTab);
            // Middle mouse button on a panel tab to close it.
            self.__on(body, 'mouseup', '.wcPanelTab', __onReleasePanelTab);
            self.__on(body, 'touchend', '.wcPanelTab', __onReleasePanelTab);
            // Mouse down on a panel will put it into focus.
            self.__on(body, 'mousedown', '.wcLayout', __onMouseDownLayout);
            self.__on(body, 'touchstart', '.wcLayout', __onMouseDownLayout);
            // Floating frames have resizable edges.
            self.__on(body, 'mousedown', '.wcFrameEdge', __onMouseDownResizeFrame);
            self.__on(body, 'touchstart', '.wcFrameEdge', __onMouseDownResizeFrame);
            // Create new panels.
            self.__on(body, 'mousedown', '.wcCreatePanel', __onMouseDownCreatePanel);
            self.__on(body, 'touchstart', '.wcCreatePanel', __onMouseDownCreatePanel);
            // Mouse released
            self.__on(body, 'mouseup', __onMouseUp);
            self.__on(body, 'touchend', __onMouseUp);

            // Clicking on a custom tab button.
            self.__on(body, 'click', '.wcCustomTab .wcFrameButton', __onClickCustomTabButton);
            // Clicking on a panel frame button.
            self.__on(body, 'click', '.wcFrameButtonBar > .wcFrameButton', __onClickPanelButton);

            // Escape key to cancel drag operations.
            self.__on(body, 'keyup', __onKeyup);

            // on mousedown
            function __onMouseDown(event) {
                var mouse = self.__mouse(event);
                self._mouseOrigin.x = mouse.x;
                self._mouseOrigin.y = mouse.y;
            }

            // on mouseup
            function __onMouseUp(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                $('body').removeClass('wcDisableSelection');
                if (self._draggingFrame) {
                    for (var i = 0; i < self._frameList.length; ++i) {
                        self._frameList[i].__shadow(false);
                    }
                }

                if(self._draggingFrameSizer){
                    self.trigger(wcDocker.EVENT.END_FLOAT_RESIZE);
                }
                
                if (self._ghost && (self._draggingFrame || self._creatingPanel)) {
                    var anchor = self._ghost.anchor();

                    if (self._draggingFrame) {
                        if (!anchor) {
                            if (!self._draggingFrameTab) {
                                self._draggingFrame.panel(0);
                            }

                            var panel = self._draggingFrame.panel(parseInt($(self._draggingFrameTab).attr('id')));
                            self.movePanel(panel, wcDocker.DOCK.FLOAT, null, self._ghost.__rect());
                            // Dragging the entire frame.
                            if (!self._draggingFrameTab) {
                                var count = self._draggingFrame._panelList.length;
                                if (count > 1 || self._draggingFrame.panel() !== self._placeholderPanel) {
                                    for (var i = 0; i < count; ++i) {
                                        self.movePanel(self._draggingFrame.panel(), wcDocker.DOCK.STACKED, panel, {tabOrientation: self._draggingFrame._tabOrientation});
                                    }
                                }
                            }

                            var frame = panel._parent;
                            if (frame && frame.instanceOf('wcFrame')) {
                                frame.pos(mouse.x, mouse.y + self._ghost.__rect().h / 2 - 10, true);

                                frame._size.x = self._ghost.__rect().w;
                                frame._size.y = self._ghost.__rect().h;
                            }

                            frame.__update();
                            self.__focus(frame);
                        } else if (!anchor.self && anchor.loc !== undefined) {
                            // Changing tab location on the same frame.
                            if (anchor.tab && anchor.item._parent._parent == self._draggingFrame) {
                                self._draggingFrame.tabOrientation(anchor.tab);
                            } else {
                                var index = 0;
                                if (self._draggingFrameTab) {
                                    index = parseInt($(self._draggingFrameTab).attr('id'));
                                } else {
                                    self._draggingFrame.panel(0);
                                }
                                var panel;
                                if (anchor.item) {
                                    panel = anchor.item._parent;
                                }
                                // If we are dragging a tab to split its own container, find another
                                // tab item within the same frame and split from there.
                                if (self._draggingFrame._panelList.indexOf(panel) > -1) {
                                    // Can not split the frame if it is the only panel inside.
                                    if (self._draggingFrame._panelList.length === 1) {
                                        return;
                                    }
                                    for (var i = 0; i < self._draggingFrame._panelList.length; ++i) {
                                        if (panel !== self._draggingFrame._panelList[i]) {
                                            panel = self._draggingFrame._panelList[i];
                                            index--;
                                            break;
                                        }
                                    }
                                }
                                var movingPanel = null;
                                if (self._draggingFrameTab) {
                                    movingPanel = self._draggingFrame.panel(parseInt($(self._draggingFrameTab).attr('id')));
                                } else {
                                    movingPanel = self._draggingFrame.panel();
                                }
                                panel = self.movePanel(movingPanel, anchor.loc, panel, self._ghost.rect());
                                panel._parent.panel(panel._parent._panelList.length - 1, true);
                                // Dragging the entire frame.
                                if (!self._draggingFrameTab) {
                                    var rect = self._ghost.rect();
                                    if (!rect.tabOrientation) {
                                        rect.tabOrientation = self._draggingFrame.tabOrientation();
                                    }
                                    var count = self._draggingFrame._panelList.length;
                                    if (count > 1 || self._draggingFrame.panel() !== self._placeholderPanel) {
                                        for (var i = 0; i < count; ++i) {
                                            self.movePanel(self._draggingFrame.panel(), wcDocker.DOCK.STACKED, panel, rect);
                                        }
                                    }
                                } else {
                                    var frame = panel._parent;
                                    if (frame && frame.instanceOf('wcFrame')) {
                                        index = index + frame._panelList.length;
                                    }
                                }

                                var frame = panel._parent;
                                if (frame && frame.instanceOf('wcFrame')) {
                                    frame.panel(index);
                                }
                                self.__focus(frame);
                            }
                        }
                    } else if (self._creatingPanel) {
                        var loc = wcDocker.DOCK.FLOAT;
                        var target = null;
                        if (anchor) {
                            loc = anchor.loc;
                            if (anchor.item) {
                                target = anchor.item._parent;
                            } else {
                                target = anchor.panel;
                            }
                        }
                        self.addPanel(self._creatingPanel, loc, target, self._ghost.rect());
                    }

                    self._ghost.destroy();
                    self._ghost = null;

                    self.trigger(wcDocker.EVENT.END_DOCK);
                    self.__update();
                }

                if (self._draggingSplitter) {
                    self._draggingSplitter.$pane[0].removeClass('wcResizing');
                    self._draggingSplitter.$pane[1].removeClass('wcResizing');
                }

                self._draggingSplitter = null;
                self._draggingFrame = null;
                self._draggingFrameSizer = null;
                self._draggingFrameTab = null;
                self._draggingFrameTopper = false;
                self._draggingCustomTabFrame = null;
                self._removingPanel = null;
                return true;
            }

            // on mousemove
            var lastMouseMove = new Date().getTime();
            var lastMouseEvent = null;
            var moveTimeout = 0;
            var lastLButtonDown = 0;

            function __onMouseMove(event) {

                lastMouseEvent = event;
                var mouse = self.__mouse(event);
                if (mouse.which === 3 || (
                    !self._draggingSplitter && !self._draggingFrameSizer && !self._draggingCustomTabFrame && !self._ghost && !self._draggingFrame && !self._draggingFrameTab)) {
                    return true;
                }

                var t = new Date().getTime();
                if (t - lastMouseMove < self._options.responseRate) {
                    if (!moveTimeout) {
                        moveTimeout = setTimeout(function () {
                            lastMouseMove = 0;
                            moveTimeout = 0;
                            __onMouseMove(lastMouseEvent);
                        }, self._options.responseRate);
                    }
                    return true;
                }
                lastMouseMove = new Date().getTime();

                if (self._draggingSplitter) {
                    self._draggingSplitter.__moveBar(mouse);
                } else if (self._draggingFrameSizer) {
                    var offset = self.$container.offset();
                    mouse.x += offset.left;
                    mouse.y += offset.top;
                    self._draggingFrame.__resize(self._draggingFrameSizer, mouse);
                    self._draggingFrame.__update();
                } else if (self._draggingCustomTabFrame) {
                    if (self._draggingCustomTabFrame.moveable()) {
                        var $hoverTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if (self._draggingFrameTab && $hoverTab && $hoverTab.length && self._draggingFrameTab !== event.target) {
                            self._draggingFrameTab = self._draggingCustomTabFrame.moveTab(parseInt($(self._draggingFrameTab).attr('id')), parseInt($hoverTab.attr('id')));
                        }
                    }
                } else if (self._ghost) {
                    if (self._draggingFrame) {
                        self._ghost.__move(mouse);
                        var forceFloat = !(self._draggingFrame._isFloating || mouse.which === 1);
                        var found = false;

                        // Check anchoring with self.
                        if (!self._draggingFrame.__checkAnchorDrop(mouse, true, self._ghost, self._draggingFrame._panelList.length > 1 && self._draggingFrameTab, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame))) {
                            // Introduce a delay before a panel begins movement to a new docking position.
                            if (new Date().getTime() - lastLButtonDown < self._options.moveStartDelay) {
                                return;
                            }
                            self._draggingFrame.__shadow(true);
                            self.__focus();
                            if (!forceFloat) {
                                for (var i = 0; i < self._frameList.length; ++i) {
                                    if (self._frameList[i] !== self._draggingFrame) {
                                        if (self._frameList[i].__checkAnchorDrop(mouse, false, self._ghost, true, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame))) {
                                            self._draggingFrame.__shadow(true);
                                            return;
                                        }
                                    }
                                }
                            }

                            if (self._draggingFrame.panel().detachable()) {
                                self._ghost.anchor(mouse, null);
                            }
                        } else {
                            self._draggingFrame.__shadow(false);
                            var $target = $(document.elementFromPoint(mouse.x, mouse.y));
                            var $hoverTab = $target.hasClass('wcPanelTab') ? $target : $target.parents('.wcPanelTab');
                            if (self._draggingFrameTab && $hoverTab.length && self._draggingFrameTab !== $hoverTab[0]) {
                                self._draggingFrameTab = self._draggingFrame.__tabMove(parseInt($(self._draggingFrameTab).attr('id')), parseInt($hoverTab.attr('id')));
                            }
                        }
                    } else if (self._creatingPanel) {
                        self._ghost.update(mouse, !self._creatingPanelNoFloating);
                    }
                } else if (self._draggingFrame && !self._draggingFrameTab) {
                    self._draggingFrame.__move(mouse);
                    self._draggingFrame.__update();
                    self.trigger(wcDocker.EVENT.MOVE_STARTED);
                }
                return true;
            }

            // on contextmenu for a, img
            function __onContextShowNormal() {
                if (self._contextTimer) {
                    clearTimeout(self._contextTimer);
                }

                $(".wcFrame").contextMenu(false);
                self._contextTimer = setTimeout(function () {
                    $(".wcFrame").contextMenu(true);
                    self._contextTimer = null;
                }, 100);
                return true;
            }

            // on contextmenu for .wcSplitterBar
            function __onContextDisable() {
                return false;
            }

            // on mouseenter for .wcMenuCreatePanel
            function __onEnterCreatePanel() {
                if (self._ghost) {
                    self._ghost.$ghost.stop().fadeIn(200);
                }
            }

            // on mouseleave for .wcMenuCreatePanel
            function __onLeaveCreatePanel() {
                if (self._ghost) {
                    self._ghost.$ghost.stop().fadeOut(200);
                }
            }

            // on mousedown for .wcModalBlocker
            function __onMouseDownModalBlocker(event) {
                // for (var i = 0; i < self._modalList.length; ++i) {
                //   self._modalList[i].__focus(true);
                // }
                if (self._modalList.length) {
                    self._modalList[self._modalList.length - 1].__focus(true);
                }
            }

            // on mousedown for .wcPanelTab
            function __onPreventDefault(event) {
                event.preventDefault();
                event.returnValue = false;
            }

            // on mousedown for .wcFrameButtonBar > .wcFrameButton
            function __onMouseSelectionBlocker() {
                $('body').addClass('wcDisableSelection');
            }

            // on click for .wcCustomTab .wcFrameButton
            function __onClickCustomTabButton(event) {
                $('body').removeClass('wcDisableSelection');
                for (var i = 0; i < self._tabList.length; ++i) {
                    var customTab = self._tabList[i];
                    if (customTab.$close[0] === this) {
                        var tabIndex = customTab.tab();
                        customTab.removeTab(tabIndex);
                        event.stopPropagation();
                        return;
                    }

                    if (customTab.$tabLeft[0] === this) {
                        customTab._tabScrollPos -= customTab.$tabBar.width() / 2;
                        if (customTab._tabScrollPos < 0) {
                            customTab._tabScrollPos = 0;
                        }
                        customTab.__updateTabs();
                        event.stopPropagation();
                        return;
                    }
                    if (customTab.$tabRight[0] === this) {
                        customTab._tabScrollPos += customTab.$tabBar.width() / 2;
                        customTab.__updateTabs();
                        event.stopPropagation();
                        return;
                    }
                }
            }

            // on click for .wcFrameButtonBar > .wcFrameButton
            function __onClickPanelButton() {
                $('body').removeClass('wcDisableSelection');
                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$close[0] === this) {
                        self.__closePanel(frame.panel());
                        return;
                    }
                    if (frame.$collapse[0] === this) {
                        var $icon = frame.$collapse.children('div');
                        var position = wcDocker.DOCK.BOTTOM;
                        if ($icon.hasClass('wcCollapseLeft')) {
                            position = wcDocker.DOCK.LEFT;
                        } else if ($icon.hasClass('wcCollapseRight')) {
                            position = wcDocker.DOCK.RIGHT;
                        }
                        if (frame.isCollapser()) {
                            // Un-collapse
                            // var target;
                            var opts = {};
                            switch (position) {
                                case wcDocker.DOCK.LEFT:
                                    // target = frame._parent._parent.right();
                                    opts.w = frame.$frame.width();
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    // target = frame._parent._parent.left();
                                    opts.w = frame.$frame.width();
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    // target = frame._parent._parent.top();
                                    opts.h = frame.$frame.height();
                                    break;
                            }
                            var target = self._collapser[wcDocker.DOCK.LEFT]._parent.right();
                            frame.collapse(true);
                            self.movePanel(frame.panel(), position, target, opts);
                        } else {
                            // collapse.
                            self.movePanel(frame.panel(), position, wcDocker.COLLAPSED);
                        }
                        self.__update();
                        return;
                    }
                    if (frame.$tabLeft[0] === this) {
                        frame._tabScrollPos -= frame.$tabBar.width() / 2;
                        if (frame._tabScrollPos < 0) {
                            frame._tabScrollPos = 0;
                        }
                        frame.__updateTabs();
                        return;
                    }
                    if (frame.$tabRight[0] === this) {
                        frame._tabScrollPos += frame.$tabBar.width() / 2;
                        frame.__updateTabs();
                        return;
                    }

                    for (var a = 0; a < frame._buttonList.length; ++a) {
                        if (frame._buttonList[a][0] === this) {
                            var $button = frame._buttonList[a];
                            var result = {
                                name: $button.data('name'),
                                isToggled: false
                            };

                            if ($button.hasClass('wcFrameButtonToggler')) {
                                $button.toggleClass('wcFrameButtonToggled');
                                if ($button.hasClass('wcFrameButtonToggled')) {
                                    result.isToggled = true;
                                }
                            }

                            var panel = frame.panel();
                            panel.buttonState(result.name, result.isToggled);
                            panel.__trigger(wcDocker.EVENT.BUTTON, result);
                            return;
                        }
                    }
                }
            }

            // on mouseup for .wcPanelTab
            function __onReleasePanelTab(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 2) {
                    return;
                }

                var index = parseInt($(this).attr('id'));

                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$tabBar[0] === $(this).parents('.wcFrameTitleBar')[0]) {
                        var panel = frame._panelList[index];
                        if (self._removingPanel === panel) {
                            self.removePanel(panel);
                            self.__update();
                        }
                        return;
                    }
                }
            }

            // on mousedown for .wcSplitterBar
            function __onMouseDownSplitter(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 1) {
                    return true;
                }

                $('body').addClass('wcDisableSelection');
                for (var i = 0; i < self._splitterList.length; ++i) {
                    if (self._splitterList[i].$bar[0] === this) {
                        self._draggingSplitter = self._splitterList[i];
                        self._draggingSplitter.$pane[0].addClass('wcResizing');
                        self._draggingSplitter.$pane[1].addClass('wcResizing');
                        event.preventDefault();
                        break;
                    }
                }
                return true;
            }

            // on mousedown for .wcFrameTitleBar
            function __onMouseDownFrameTitle(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                // Skip frame buttons, they are handled elsewhere (Buttons may also have a child image or span so we check parent as well);
                if ($(event.target).hasClass('wcFrameButton') || $(event.target).parents('.wcFrameButton').length) {
                    return true;
                }

                if ($(event.target).hasClass('wcPanelCloseIcon')) {
                    return self.__closePanel(event.target.__panel);
                }

                lastLButtonDown = new Date().getTime();

                $('body').addClass('wcDisableSelection');
                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i].$titleBar[0] == this ||
                        self._frameList[i].$tabBar[0] == this) {
                        self._draggingFrame = self._frameList[i];

                        self._draggingFrame.__anchorMove(mouse);

                        var $panelTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if ($panelTab && $panelTab.length) {
                            var index = parseInt($panelTab.attr('id'));
                            self._draggingFrame.panel(index, true);
                            self._draggingFrameTab = $panelTab[0];
                            $(window).focus();
                        }

                        // If the window is able to be docked, give it a dark shadow tint and begin the movement process
                        var shouldMove = true;
                        if (self._draggingFrameTab) {
                            if ($panelTab.hasClass('wcNotMoveable')) {
                                shouldMove = false;
                            }
                        } else {
                            if (self._draggingFrame._isFloating && mouse.which === 1) {
                                shouldMove = false;
                            }
                        }

                        // if (((!$panelTab.hasClass('wcNotMoveable') && self._draggingFrameTab) ||
                        //     !(self._draggingFrame.$titleBar.hasClass('wcNotMoveable') || self._draggingFrame.$tabBar.hasClass('wcNotMoveable'))) &&
                        //     (!self._draggingFrame._isFloating || mouse.which !== 1 || self._draggingFrameTab)) {
                        if (shouldMove) {
                            // Special case to allow users to drag out only a single collapsed tab even by dragging the title bar (which normally would drag out the entire frame).
                            if (!self._draggingFrameTab && self._draggingFrame.isCollapser()) {
                                self._draggingFrameTab = self._draggingFrame.panel();
                            }
                            self._draggingFrameTopper = $(event.target).parents('.wcFrameTopper').length > 0;
                            var rect = self._draggingFrame.__rect();
                            self._ghost = new (self.__getClass('wcGhost'))(rect, mouse, self);
                            self._draggingFrame.__checkAnchorDrop(mouse, true, self._ghost, true, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame));
                            self.trigger(wcDocker.EVENT.BEGIN_DOCK);
                        }
                        break;
                    }
                }
                for (var i = 0; i < self._tabList.length; ++i) {
                    if (self._tabList[i].$tabBar[0] == this) {
                        self._draggingCustomTabFrame = self._tabList[i];

                        var $panelTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if ($panelTab && $panelTab.length) {
                            var index = parseInt($panelTab.attr('id'));
                            self._draggingCustomTabFrame.tab(index, true);
                            self._draggingFrameTab = $panelTab[0];
                        }
                        break;
                    }
                }
                if (self._draggingFrame) {
                    self.__focus(self._draggingFrame);
                    //extra
                    var focusFrame = self._focusFrame;
                    var cPanel = focusFrame.currentPanel();
                    if (cPanel) {
                        cPanel._emit('ON_VIEW_SELECT');
                    }
                }
                return true;
            }

            // on mousedown for .wcLayout
            function __onMouseDownLayout(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i].panel() && self._frameList[i].panel().layout().scene()[0] == this) {
                        setTimeout(function () {
                            self.__focus(self._frameList[i]);
                        }, 10);
                        break;
                    }
                }
                return true;
            }

            // on mousedown for .wcFrameEdge
            function __onMouseDownResizeFrame(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                $('body').addClass('wcDisableSelection');

                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i]._isFloating) {
                        if (self._frameList[i].$top[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top'];
                            break;
                        } else if (self._frameList[i].$bottom[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom'];
                            break;
                        } else if (self._frameList[i].$left[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['left'];
                            break;
                        } else if (self._frameList[i].$right[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['right'];
                            break;
                        } else if (self._frameList[i].$corner1[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top', 'left'];
                            break;
                        } else if (self._frameList[i].$corner2[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top', 'right'];
                            break;
                        } else if (self._frameList[i].$corner3[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom', 'right'];
                            break;
                        } else if (self._frameList[i].$corner4[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom', 'left'];
                            break;
                        }
                    }
                }
                if (self._draggingFrame) {
                    self.__focus(self._draggingFrame);
                }

                if(self._draggingFrameSizer){
                    self.trigger(wcDocker.EVENT.BEGIN_FLOAT_RESIZE);
                }

                return true;
            }

            // on mousedown for .wcCreatePanel
            function __onMouseDownCreatePanel(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 1) {
                    return true;
                }


                var panelType = $(this).data('panel');
                var info = self.panelTypeInfo(panelType);
                if (info) {
                    var rect = {
                        x: mouse.x - 250,
                        y: mouse.y,
                        w: 500,
                        h: 500
                    };
                    $('body').addClass('wcDisableSelection');
                    self._ghost = new (self.__getClass('wcGhost'))(rect, mouse, self);
                    self._ghost.update(mouse);
                    self._ghost.anchor(mouse, self._ghost.anchor());
                    self._creatingPanel = panelType;
                    self.__focus();
                    self.trigger(wcDocker.EVENT.BEGIN_DOCK);
                }
            }

            // on mousedown for .wcPanelTab
            function __onMouseDownPanelTab(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 2) {
                    return true;
                }

                var index = parseInt($(this).attr('id'));

                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$tabBar[0] === $(this).parents('.wcFrameTitleBar')[0]) {
                        var panel = frame._panelList[index];
                        if (panel && panel.closeable()) {
                            self._removingPanel = frame._panelList[index];
                        }
                        return true;
                    }
                }
                return true;
            }

            // on keyup
            function __onKeyup(event) {
                if (event.keyCode == 27) {
                    if (self._ghost) {
                        self._ghost.destroy();
                        self._ghost = false;
                        self.trigger(wcDocker.EVENT.END_DOCK);

                        if (self._draggingFrame) {
                            self._draggingFrame.__shadow(false);
                        }
                        self._creatingPanel = false;
                        self._draggingSplitter = null;
                        self._draggingFrame = null;
                        self._draggingFrameSizer = null;
                        self._draggingFrameTab = null;
                        self._draggingFrameTopper = false;
                        self._draggingCustomTabFrame = null;
                        self._removingPanel = null;
                    }
                }
            }

            this._started = true;

            this.setupActions();

        },

        // Test for load completion.
        __testLoadFinished: function () {
            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    // Skip if any panels are not initialized yet.
                    if (panel._isVisible && !panel._initialized) {
                        return;
                    }

                    // Skip if any panels still have a loading screen.
                    if (panel.$loading) {
                        return;
                    }
                }
            }

            // If we reach this point, all existing panels are initialized and loaded!
            var self = this;
            setTimeout(function () {
                self.trigger(wcDocker.EVENT.LOADED);

                // Now unregister all loaded events so they do not fire again.
                self.off(wcDocker.EVENT.LOADED);
                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    for (var a = 0; a < frame._panelList.length; ++a) {
                        var panel = frame._panelList[a];
                        panel.off(wcDocker.EVENT.LOADED);
                    }
                }
            }, 0);
        },
        /*
         * Searches docked panels and splitters for a container that is within any static areas.
         */
        __findInner: function () {
            function isPaneStatic(pane) {
                return !!(pane && (pane.instanceOf('wcFrame') && pane.panel() && !pane.panel().moveable()) || (pane.instanceOf('wcCollapser')));
            }

            var parent = this._root;
            while (parent) {
                if (parent.instanceOf('wcSplitter')) {
                    var pane0 = isPaneStatic(parent._pane[0]);
                    var pane1 = isPaneStatic(parent._pane[1]);
                    if (pane0 && !pane1) {
                        parent = parent._pane[1];
                    } else if (pane1 && !pane0) {
                        parent = parent._pane[0];
                    } else if (!pane0 && !pane1) {
                        break;
                    }
                } else {
                    break;
                }
            }

            return parent;
        },

        /*
         * Sets up the collapsers for the panel.<br>
         * <b>Note: </b> This should be called AFTER you have initialized your panel layout, but BEFORE you add
         * any static panels that you do not wish to be overlapped by the collapsers (such as file menu panels).
         */
        __initCollapsers: function () {
            // Initialize collapsers if it is enabled and not already initialized.
            if (!this.isCollapseEnabled() || !_.isEmpty(this._collapser)) {
                return;
            }

            var parent = this.__findInner();

            function __createCollapser(location) {
                this._collapser[location] = this.__addCollapser(location, parent);
                parent = this._collapser[location]._parent;
                this._frameList.push(this._collapser[location]._drawer._frame);
            }

            __createCollapser.call(this, wcDocker.DOCK.LEFT);
            __createCollapser.call(this, wcDocker.DOCK.RIGHT);
            __createCollapser.call(this, wcDocker.DOCK.BOTTOM);

            var self = this;
            setTimeout(function () {
                self.__update();
            });
        },

        // Updates the sizing of all panels inside this window.
        __update: function (opt_dontMove) {
            this._dirty = true;
            this._dirtyDontMove = opt_dontMove;
        },

        // Forces an update, regardless of the response rate.
        __forceUpdate: function (opt_dontMove) {
            this._dirty = false;
            if (this._root) {
                this._root.__update(opt_dontMove);
            }

            for (var i = 0; i < this._floatingList.length; ++i) {
                this._floatingList[i].__update();
            }
        },

        __orderPanels: function () {
            if (this._floatingList.length === 0) {
                return;
            }

            var from = this._floatingList.indexOf(this._focusFrame);
            var to = this._floatingList.length - 1;

            this._floatingList.splice(to, 0, this._floatingList.splice(from, 1)[0]);

            var length = this._floatingList.length;
            var start = 10;
            var step = 5;
            var index = 0;
            var panel;

            for (var i = 0; i < this._floatingList.length; ++i) {
                panel = this._floatingList[i];
                if (panel) {
                    var layer = start + (i * step);
                    panel.$frame.css('z-index', layer);
                    panel.__trigger(wcDocker.EVENT.ORDER_CHANGED, layer);
                }
            }
        },

        // Retrieve mouse or touch position.
        __mouse: function (event) {
            if (event.originalEvent && (event.originalEvent.touches || event.originalEvent.changedTouches)) {
                var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];
                return {
                    x: touch.clientX,
                    y: touch.clientY,
                    which: 1
                };
            }

            return {
                x: event.clientX || event.pageX,
                y: event.clientY || event.pageY,
                which: event.which || 1
            };
        },

        // On window resized event.
        __resize: function (event) {
            this._resizeData.time = new Date();
            if (!this._resizeData.timeout) {
                this._resizeData.timeout = true;
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                this.__trigger(wcDocker.EVENT.RESIZE_STARTED);
            }
            this.__trigger(wcDocker.EVENT.RESIZED);
            this.__update(false);
        },

        // On window resize event ended.
        __resizeEnd: function () {
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
                this.__trigger(wcDocker.EVENT.RESIZE_ENDED);
            }
        },

        // Brings a floating window to the top.
        // Params:
        //    frame     The frame to focus.
        //    flash     Whether to flash the frame.
        __focus: function (frame, flash) {
            var differentFrames = this._focusFrame != frame;
            if (this._focusFrame) {
                if (this._focusFrame._isFloating) {
                    this._focusFrame.$frame.removeClass('wcFloatingFocus');
                }

                var oldFocusFrame = this._focusFrame;
                this._focusFrame = null;

                oldFocusFrame.__trigger(wcDocker.EVENT.LOST_FOCUS);
                if (oldFocusFrame.isCollapser() && differentFrames) {
                    oldFocusFrame.collapse();
                    oldFocusFrame.panel(-1);
                }
            }

            this._focusFrame = frame;
            if (this._focusFrame) {
                if (this._focusFrame._isFloating) {
                    this._focusFrame.$frame.addClass('wcFloatingFocus');

                    if (differentFrames) {
                        $('body').append(this._focusFrame.$frame);
                    }
                }
                this._focusFrame.__focus(flash);

                this._focusFrame.__trigger(wcDocker.EVENT.GAIN_FOCUS);
            }

            this.__orderPanels();
        },

        // Triggers an event exclusively on the docker and none of its panels.
        // Params:
        //    eventName   The name of the event.
        //    data        A custom data parameter to pass to all handlers.
        __trigger: function (eventName, data) {
            if (!eventName) {
                return;
            }

            var results = [];

            if (this._events[eventName]) {
                var events = this._events[eventName].slice(0);
                for (var i = 0; i < events.length; ++i) {
                    results.push(events[i].call(this, data));
                }
            }

            return results;
        },

        // Checks a given panel to see if it is the final remaining
        // moveable panel in the docker.
        // Params:
        //    panel     The panel.
        // Returns:
        //    true      The panel is the last.
        //    false     The panel is not the last.
        __isLastPanel: function (panel) {
            for (var i = 0; i < this._frameList.length; ++i) {
                var testFrame = this._frameList[i];
                if (testFrame._isFloating || testFrame.isCollapser()) {
                    continue;
                }
                for (var a = 0; a < testFrame._panelList.length; ++a) {
                    var testPanel = testFrame._panelList[a];
                    if (testPanel !== panel && testPanel.moveable()) {
                        return false;
                    }
                }
            }

            return true;
        },

        // Checks a given frame to see if it is the final remaining
        // moveable frame in the docker.
        // Params:
        //    frame     The frame.
        // Returns:
        //    true      The panel is the last.
        //    false     The panel is not the last.
        __isLastFrame: function (frame) {
            for (var i = 0; i < this._frameList.length; ++i) {
                var testFrame = this._frameList[i];
                if (testFrame._isFloating || testFrame === frame || testFrame.isCollapser()) {
                    continue;
                }
                for (var a = 0; a < testFrame._panelList.length; ++a) {
                    var testPanel = testFrame._panelList[a];
                    if (testPanel.moveable()) {
                        return false;
                    }
                }
            }

            return true;
        },

        // For restore, creates the appropriate object type.
        __create: function (data, parent, $container) {
            switch (data.type) {
                case 'wcSplitter':
                    var splitter = new (this.__getClass('wcSplitter'))($container, parent, data.horizontal);
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    return splitter;

                case 'wcFrame':
                    var frame = new (this.__getClass('wcFrame'))($container, parent, data.floating);
                    this._frameList.push(frame);
                    if (data.floating) {
                        this._floatingList.push(frame);
                    }
                    return frame;

                case 'wcPanel':
                    if (data.panelType === wcDocker.PANEL_PLACEHOLDER) {
                        if (!this._placeholderPanel) {
                            this._placeholderPanel = new (this.__getClass('wcPanel'))(parent, wcDocker.PANEL_PLACEHOLDER, {});
                            this._placeholderPanel._isPlaceholder = true;
                            this._placeholderPanel.__container(this.$transition);
                            this._placeholderPanel._panelObject = new function (myPanel) {
                                myPanel.title(false);
                                myPanel.closeable(false);
                            }(this._placeholderPanel);
                            this._placeholderPanel.__container($container);
                        }
                        return this._placeholderPanel;
                    } else {
                        for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                            if (this._dockPanelTypeList[i].name === data.panelType) {
                                var panel = new (this.__getClass('wcPanel'))(parent, data.panelType, this._dockPanelTypeList[i].options);
                                panel.__container(this.$transition);
                                var options = (this._dockPanelTypeList[i].options && this._dockPanelTypeList[i].options.options) || {};
                                panel._panelObject = new this._dockPanelTypeList[i].options.onCreate(panel, options);
                                panel.__container($container);
                                break;
                            }
                        }
                        return panel;
                    }
            }

            return null;
        },

        // Attempts to insert a given dock panel into an already existing frame.
        // If insertion is not possible for any reason, the panel will be
        // placed in its own frame instead.
        // Params:
        //    panel         The panel to insert.
        //    targetPanel   An optional panel to 'split', if not supplied the
        //                  new panel will split the center window.
        __addPanelGrouped: function (panel, targetPanel, options) {
            var frame = targetPanel;
            if (frame && frame.instanceOf('wcPanel')) {
                frame = targetPanel._parent;
            }

            if (frame && frame.instanceOf('wcFrame')) {
                if (options && options.tabOrientation) {
                    frame.tabOrientation(options.tabOrientation);
                }

                frame.addPanel(panel);
                return;
            }

            // If we did not manage to find a place for this panel, last resort is to put it in its own frame.
            this.__addPanelAlone(panel, wcDocker.DOCK.LEFT, targetPanel, options);
        },

        // Creates a new frame for the panel and then attaches it
        // to the window.
        // Params:
        //    panel         The panel to insert.
        //    location      The desired location for the panel.
        //    targetPanel   An optional panel to 'split', if not supplied the
        //                  new panel will split the center window.
        __addPanelAlone: function (panel, location, targetPanel, options) {
            if (targetPanel && targetPanel._shift) {
                var target = targetPanel;
                targetPanel = targetPanel._shift;
                target._shift = undefined;
            }

            if (options) {
                var width = this.$container.width();
                var height = this.$container.height();

                if (options.hasOwnProperty('x')) {
                    options.x = this.__stringToPixel(options.x, width);
                }
                if (options.hasOwnProperty('y')) {
                    options.y = this.__stringToPixel(options.y, height);
                }
                if (!options.hasOwnProperty('w')) {
                    options.w = panel.initSize().x;
                }
                if (!options.hasOwnProperty('h')) {
                    options.h = panel.initSize().y;
                }
                options.w = this.__stringToPixel(options.w, width);
                options.h = this.__stringToPixel(options.h, height);

                panel._size.x = options.w;
                panel._size.y = options.h;
            }

            // If we are collapsing the panel, put it into the collapser.
            if (targetPanel === wcDocker.COLLAPSED) {
                this.__initCollapsers();
                if (this._collapser[location]) {
                    targetPanel = this._collapser[location]._drawer._frame.addPanel(panel);
                    var self = this;
                    setTimeout(function () {
                        self.__update();
                    });
                    return panel;
                } else {
                    console.log('ERROR: Attempted to collapse panel "' + panel._type + '" to invalid location: ' + location);
                    return false;
                }
            }

            // Floating windows need no placement.
            if (location === wcDocker.DOCK.FLOAT || location === wcDocker.DOCK.MODAL) {
                var frame = new (this.__getClass('wcFrame'))(this.$container, this, true);
                if (options && options.tabOrientation) {
                    frame.tabOrientation(options.tabOrientation);
                }
                this._frameList.push(frame);
                this._floatingList.push(frame);
                this.__focus(frame);
                frame.addPanel(panel);
                frame.pos(panel._pos.x, panel._pos.y, false);

                if (location === wcDocker.DOCK.MODAL) {
                    frame.$modalBlocker = $('<div class="wcModalBlocker"></div>');
                    frame.$frame.prepend(frame.$modalBlocker);

                    panel.moveable(false);
                    frame.$frame.addClass('wcModal');
                    this._modalList.push(frame);
                }

                if (options) {
                    var pos = frame.pos(undefined, undefined, true);
                    if (options.hasOwnProperty('x')) {
                        pos.x = options.x + options.w / 2;
                    }
                    if (options.hasOwnProperty('y')) {
                        pos.y = options.y + options.h / 2;
                    }
                    frame.pos(pos.x, pos.y, true);
                    frame._size = {
                        x: options.w,
                        y: options.h
                    };
                }

                this.__orderPanels();
                return;
            }

            if (targetPanel) {
                var parentSplitter = targetPanel._parent;

                var splitterChild = targetPanel;

                while (parentSplitter && !(parentSplitter.instanceOf('wcSplitter') || parentSplitter.instanceOf('wcDocker'))) {
                    splitterChild = parentSplitter;
                    parentSplitter = parentSplitter._parent;
                }

                if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                    var splitter;
                    var left = parentSplitter.pane(0);
                    var right = parentSplitter.pane(1);
                    var size = {
                        x: -1,
                        y: -1
                    };
                    if (left === splitterChild) {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[0].width();
                        size.y = parentSplitter.$pane[0].height();
                        parentSplitter.pane(0, splitter);
                    } else {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[1].width();
                        size.y = parentSplitter.$pane[1].height();
                        parentSplitter.pane(1, splitter);
                    }

                    if (splitter) {
                        splitter.scrollable(0, false, false);
                        splitter.scrollable(1, false, false);

                        if (!options) {
                            options = {
                                w: panel._size.x,
                                h: panel._size.y
                            };
                        }

                        if (options) {
                            if (options.w < 0) {
                                options.w = size.x / 2;
                            }
                            if (options.h < 0) {
                                options.h = size.y / 2;
                            }

                            switch (location) {
                                case wcDocker.DOCK.LEFT:
                                    splitter.pos(options.w / size.x);
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    splitter.pos(1.0 - (options.w / size.x));
                                    break;
                                case wcDocker.DOCK.TOP:
                                    splitter.pos(options.h / size.y);
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    splitter.pos(1.0 - (options.h / size.y));
                                    break;
                            }
                        } else {
                            splitter.pos(0.5);
                        }

                        frame = new (this.__getClass('wcFrame'))(this.$transition, splitter, false);
                        this._frameList.push(frame);
                        if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                            splitter.pane(0, frame);
                            splitter.pane(1, splitterChild);
                        } else {
                            splitter.pane(0, splitterChild);
                            splitter.pane(1, frame);
                        }

                        frame.addPanel(panel);
                    }
                    return;
                }
            }

            var parent = this;
            var $container = this.$container;
            var frame = new (this.__getClass('wcFrame'))(this.$transition, parent, false);
            this._frameList.push(frame);

            if (!parent._root) {
                parent._root = frame;
                frame.__container($container);
            } else {
                var splitter = new (this.__getClass('wcSplitter'))($container, parent, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                if (splitter) {
                    frame._parent = splitter;
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    var size = {
                        x: $container.width(),
                        y: $container.height()
                    };

                    if (!options) {
                        splitter.__findBestPos();
                    } else {
                        if (options.w < 0) {
                            options.w = size.x / 2;
                        }
                        if (options.h < 0) {
                            options.h = size.y / 2;
                        }

                        switch (location) {
                            case wcDocker.DOCK.LEFT:
                                splitter.pos(options.w / size.x);
                                break;
                            case wcDocker.DOCK.RIGHT:
                                splitter.pos(1.0 - (options.w / size.x));
                                break;
                            case wcDocker.DOCK.TOP:
                                splitter.pos(options.h / size.y);
                                break;
                            case wcDocker.DOCK.BOTTOM:
                                splitter.pos(1.0 - (options.h / size.y));
                                break;
                        }
                    }

                    if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                        splitter.pane(0, frame);
                        splitter.pane(1, parent._root);
                    } else {
                        splitter.pane(0, parent._root);
                        splitter.pane(1, frame);
                    }

                    parent._root = splitter;
                }
            }

            frame.addPanel(panel);
        },

        __addCollapser: function (location, parent) {
            var collapser = null;
            if (parent) {
                var parentSplitter = parent._parent;
                var splitterChild = parent;
                while (parentSplitter && !(parentSplitter.instanceOf('wcSplitter') || parentSplitter.instanceOf('wcDocker'))) {
                    splitterChild = parentSplitter;
                    parentSplitter = parentSplitter._parent;
                }

                var splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);

                if (parentSplitter && parentSplitter.instanceOf('wcDocker')) {
                    this._root = splitter;
                    splitter.__container(this.$container);
                }

                if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                    var left = parentSplitter.left();
                    var right = parentSplitter.right();
                    var size = {
                        x: -1,
                        y: -1
                    };
                    if (left === splitterChild) {
                        size.x = parentSplitter.$pane[0].width();
                        size.y = parentSplitter.$pane[0].height();
                        parentSplitter.pane(0, splitter);
                    } else {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[1].width();
                        size.y = parentSplitter.$pane[1].height();
                        parentSplitter.pane(1, splitter);
                    }
                }


                if (splitter) {
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    collapser = new (this.__getClass('wcCollapser'))(this.$transition, splitter, location);
                    switch (location) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            splitter.pos(0);
                            break;
                        case wcDocker.DOCK.BOTTOM:
                        case wcDocker.DOCK.RIGHT:
                            splitter.pos(1);
                            break;
                    }

                    if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                        splitter.pane(0, collapser);
                        splitter.pane(1, splitterChild);
                    } else {
                        splitter.pane(0, splitterChild);
                        splitter.pane(1, collapser);
                    }
                }
            }
            return collapser;
        },

        // Adds the placeholder panel as needed
        __addPlaceholder: function (targetPanel) {
            if (this._placeholderPanel) {
                console.log('WARNING: wcDocker creating placeholder panel when one already exists');
            }

            this._placeholderPanel = new (this.__getClass('wcPanel'))(this, wcDocker.PANEL_PLACEHOLDER, {});
            this._placeholderPanel._isPlaceholder = true;
            this._placeholderPanel.__container(this.$transition);
            this._placeholderPanel._panelObject = new function (myPanel) {
                myPanel.title(false);
                myPanel.closeable(false);
            }(this._placeholderPanel);

            if (targetPanel) {
                this.__addPanelGrouped(this._placeholderPanel, targetPanel);
            } else {
                this.__addPanelAlone(this._placeholderPanel, wcDocker.DOCK.TOP);
            }

            this.__update();
        },

        __closePanel: function (panel) {
            // If the panel is persistent, instead of destroying it, add it to a persistent list instead.
            var dontDestroy = false;
            var panelOptions = this.panelTypeInfo(panel._type);
            if (panelOptions && panelOptions.isPersistent) {
                dontDestroy = true;
                this._persistentList.push(panel);
            }
            this.removePanel(panel, dontDestroy);
            this.__update();
        },

        // Converts a potential string value to a percentage.
        __stringToPercent: function (value, size) {
            if (typeof value === 'string') {
                if (value.indexOf('%', value.length - 1) !== -1) {
                    return parseFloat(value) / 100;
                } else if (value.indexOf('px', value.length - 2) !== -1) {
                    return parseFloat(value) / size;
                }
            }
            return parseFloat(value);
        },

        // Converts a potential string value to a pixel value.
        __stringToPixel: function (value, size) {
            if (typeof value === 'string') {
                if (value.indexOf('%', value.length - 1) !== -1) {
                    return (parseFloat(value) / 100) * size;
                } else if (value.indexOf('px', value.length - 2) !== -1) {
                    return parseFloat(value);
                }
            }
            return parseFloat(value);
        }
    });


    //merge types into module
    for (var prop in wcDocker) {
        Module[prop] = wcDocker[prop];
    }

    //track and expose default classes
    Module.defaultClasses = defaultClasses;

    return Module;
});
},
'xgrid/types':function(){
/** @module xgrid/types **/
define([
    "xdojo/declare",
    'xide/types',
    'xgrid/ColumnHider',
    'dgrid/extensions/ColumnReorder', //@todo : fork!
    'dgrid/extensions/ColumnResizer', //@todo : fork!
    'dgrid/extensions/Pagination',    //@todo : fork!
    'xgrid/Selection',
    'xgrid/Toolbar',
    'xgrid/ContextMenu',
    'xgrid/Keyboard',
    'xide/mixins/EventedMixin',
    'dgrid/OnDemandGrid',
    'xgrid/Defaults',
    'xgrid/Layout',
    'xgrid/Focus',
    'xgrid/ListRenderer',
    'xgrid/Clipboard',
    'xgrid/Actions',
    'xlang/i18'
], function (declare,types,
             ColumnHider, ColumnReorder, ColumnResizer,
             Pagination,
             Selection,Toolbar,ContextMenu,_GridKeyboardSelection,
             EventedMixin, OnDemandGrid,Defaults,Layout,Focus,
             ListRenderer,
             Clipboard,Actions,i18)
{
    /**
     * Grid Bases
     * @enum module:xgrid/types/GRID_BASES
     * @memberOf module:xgrid/types
     */
    types.GRID_BASES = {
        GRID: OnDemandGrid,
        LAYOUT:Layout,
        DEFAULTS: Defaults,
        RENDERER: ListRenderer,
        EVENTED: EventedMixin,
        FOCUS:Focus,
        i18:i18
    };
    /**
     * Default Grid Options
     * @deprecated
     * @enum module:xgrid/types/DEFAULT_GRID_OPTIONS
     * @memberOf module:xgrid/types
     */
    types.DEFAULT_GRID_OPTIONS = {
        /**
         * Instruct the grid to add jQuery theme classes
         * @default true
         * @type {bool}
         * @constant
         */
        USE_JQUERY_CSS: true,
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {bool}
         * @constant
         */
        DESELECT_SELECTED: true,
        /**
         * Behaviour flag to clear selection when clicked on the container node
         * @default true
         * @type {bool}
         * @constant
         */
        CLEAR_SELECTION_ON_CLICK: true,
        /**
         * Item actions
         * @default true
         * @type {object}
         * @constant
         */
        ITEM_ACTIONS: {},
        /**
         * Grid actions (sort, hide column, layout)
         * @default true
         * @type {object}
         * @constant
         */
        GRID_ACTIONS: {},
        /**
         * Publish selection change globally
         * @default true
         * @type {boolean}
         * @constant
         */
        PUBLISH_SELECTION: false
    };
    /**
     * Grid option keys
     * @enum module:xgrid/types/GRID_OPTION
     * @memberOf module:xgrid/types
     */
    types.GRID_OPTION = {
        /**
         * Instruct the grid to add jQuery theme classes
         * @default true
         * @type {string}
         * @constant
         */
        USE_JQUERY_CSS: 'USE_JQUERY_CSS',
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {string}
         * @constant
         */
        DESELECT_SELECTED: 'DESELECT_SELECTED',
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {string}
         * @constant
         */
        CLEAR_SELECTION_ON_CLICK:'CLEAR_SELECTION_ON_CLICK',
        /**
         * Actions
         * @default true
         * @type {string}
         * @constant
         */
        ITEM_ACTIONS:'ITEM_ACTIONS',
        /**
         * Actions
         * @default true
         * @type {string}
         * @constant
         */
        GRID_ACTIONS:'GRID_ACTIONS'
    };
    /**
     * All grid default features
     * @enum module:xgrid/types/GRID_DEFAULT_FEATURES
     * @memberOf module:xgrid/types
     */
    types.DEFAULT_GRID_FEATURES = {
        SELECTION: {
            CLASS: Selection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        KEYBOARD_SELECTION: {
            CLASS: _GridKeyboardSelection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_HIDER: {
            CLASS: ColumnHider,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_REORDER: {
            CLASS: ColumnReorder,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_RESIZER: {
            CLASS: ColumnResizer,
            IMPLEMENTATION: {},
            CLASSES: null
        }
    };
    /**
     * All Grid Features for easy access
     * @enum module:xgrid/types/GRID_FEATURES
     * @memberOf module:xgrid/types
     */
    types.GRID_FEATURES = {
        SELECTION: {
            CLASS: Selection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        KEYBOARD_SELECTION: {
            CLASS: _GridKeyboardSelection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_HIDER: {
            CLASS: ColumnHider,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_REORDER: {
            CLASS: ColumnReorder,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_RESIZER: {
            CLASS: ColumnResizer,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        PAGINATION: {
            CLASS: Pagination,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        TOOLBAR: {
            CLASS: Toolbar,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        CONTEXT_MENU: {
            CLASS: ContextMenu,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        ACTIONS: {
            CLASS: Actions,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        CLIPBOARD:{
            CLASS:Clipboard,
            IMPLEMENTATION:{},
            CLASSES:null
        }
    };
    return declare(null,[],{});
});
},
'xaction/ActionStore':function(){
/** @module xaction/ActionStore **/
define([
    "xdojo/declare",
    'xide/data/TreeMemory',
    'xide/utils',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xaction/ActionModel'
], function (declare, TreeMemory, utils, ObservableStore, Trackable, ActionModel) {
    /**
     * Default properties to be observed (in ObservableStore)
     * @type {string[]}
     */
    var DEFAULT_ACTION_PROPERTIES = [
        "value",
        "icon",
        "disabled",
        "enabled"
    ];

    /**
     * Default factory
     * @param composer
     * @param bases
     * @param Model
     * @param defaults
     * @param mixin
     * @returns {*}
     */
    function createClass(composer, bases, Model, defaults, mixin) {
        /**
         * @class module:xaction/ActionStore
         */
        return (composer || declare)(bases || [TreeMemory, Trackable, ObservableStore], utils.mixin({
            idProperty: 'command',
            declaredClass: "xaction/ActionStore",
            Model: Model || ActionModel,
            renderers: null,
            observedProperties: defaults || DEFAULT_ACTION_PROPERTIES,
            getAll: function () {
                return this.data;
            },
            addRenderer: function (renderer) {
                !this.renderers && (this.renderers = []);
                !_.contains(this.renderers, renderer) && this.renderers.push(renderer);
            }
        }, mixin));
    }

    var Module = createClass(null, null, null, null, null);
    Module.createDefault = function (args) {
        return new Module(args);
    };
    Module.createClass = createClass;
    Module.DEFAULT_ACTION_PROPERTIES = DEFAULT_ACTION_PROPERTIES;
    return Module;
});

},
'xide/model/Base':function(){
/** @module xide/model/Base **/
define([
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    
    var Implementation = {
        declaredClass:"xide/model/Base",
        /**
         * Mixin constructor arguments into this.
         * This could have been done in another base class but performance matters
         * @todo use a mixin from lodash
         * @constructor
         */
        constructor: function (args) {
            utils.mixin(this, args);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public interface, keep it small and easy
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Return a human friendly name
         * @abstract
         * @returns {string|null}
         */
        getLabel: function () {
            return null;
        },
        /**
         * Return a unique ID.
         * @abstract
         * @returns {string|null}
         */
        getID: function () {
            return null;
        }
    };

    var Module = declare("xide/model/Base",null,Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});


},
'dojo/dom-prop':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"],
	function(exports, dojo, has, lang, dom, style, ctr, conn){
		// module:
		//		dojo/dom-prop
		// summary:
		//		This module defines the core dojo DOM properties API.

		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

		// =============================
		// Element properties Functions
		// =============================

		// helper to connect events
		var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
		has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

		exports.names = {
			// properties renamed to avoid clashes with reserved words
			"class": "className",
			"for": "htmlFor",
			// properties written as camelCase
			tabindex: "tabIndex",
			readonly: "readOnly",
			colspan: "colSpan",
			frameborder: "frameBorder",
			rowspan: "rowSpan",
			textcontent: "textContent",
			valuetype: "valueType"
		};

		function getText(/*DOMNode*/node){
			// summary:
			//		recursion method for get('textContent') to use. Gets text value for a node.
			// description:
			//		Juse uses nodedValue so things like <br/> tags do not end up in
			//		the text as any sort of line return.
			var text = "", ch = node.childNodes;
			for(var i = 0, n; n = ch[i]; i++){
				//Skip comments.
				if(n.nodeType != 8){
					if(n.nodeType == 1){
						text += getText(n);
					}else{
						text += n.nodeValue;
					}
				}
			}
			return text;
		}

		exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Gets a property on an HTML element.
			// description:
			//		Handles normalized getting of properties on DOM nodes.
			//
			// node: DOMNode|String
			//		id or reference to the element to get the property on
			// name: String
			//		the name of the property to get.
			// returns:
			//		the value of the requested property or its default value
			//
			// example:
			//	|	// get the current value of the "foo" property on a node
			//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
			//	|		domProp.get(dom.byId("nodeId"), "foo");
			//	|		// or we can just pass the id:
			//	|		domProp.get("nodeId", "foo");
			//	|	});

			node = dom.byId(node);
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;

			if(propName == "textContent" && !has("dom-textContent")){
				return getText(node);
			}

			return node[propName];	// Anything
		};

		exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
			// summary:
			//		Sets a property on an HTML element.
			// description:
			//		Handles normalized setting of properties on DOM nodes.
			//
			//		When passing functions as values, note that they will not be
			//		directly assigned to slots on the node, but rather the default
			//		behavior will be removed and the new behavior will be added
			//		using `dojo.connect()`, meaning that event handler properties
			//		will be normalized and that some caveats with regards to
			//		non-standard behaviors for onsubmit apply. Namely that you
			//		should cancel form submission using `dojo.stopEvent()` on the
			//		passed event object instead of returning a boolean value from
			//		the handler itself.
			// node: DOMNode|String
			//		id or reference to the element to set the property on
			// name: String|Object
			//		the name of the property to set, or a hash object to set
			//		multiple properties at once.
			// value: String?
			//		The value to set for the property
			// returns:
			//		the DOM node
			//
			// example:
			//	|	// use prop() to set the tab index
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("nodeId", "tabIndex", 3);
			//	|	});
			//
			// example:
			//	Set multiple values at once, including event handlers:
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("formId", {
			//	|			"foo": "bar",
			//	|			"tabIndex": -1,
			//	|			"method": "POST",
			//	|		});
			//	|	});

			node = dom.byId(node);
			if(!node){
				console.error('invalid node!',node);
				return node;
			}
			var l = arguments.length;
			if(l == 2 && typeof name != "string"){ // inline'd type check
				// the object form of setter: the 2nd argument is a dictionary
				for(var x in name){
					exports.set(node, x, name[x]);
				}
				return node; // DomNode
			}
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;
			if(propName == "style" && typeof value != "string"){ // inline'd type check
				// special case: setting a style
				style.set(node, value);
				return node; // DomNode
			}
			if(propName == "innerHTML"){
				// special case: assigning HTML
				// the hash lists elements with read-only innerHTML on IE
				if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
					ctr.empty(node);
					node.appendChild(ctr.toDom(value, node.ownerDocument));
				}else{
					node[propName] = value;
				}
				return node; // DomNode
			}
			if(propName == "textContent" && !has("dom-textContent")) {
				ctr.empty(node);
				node.appendChild(node.ownerDocument.createTextNode(value));
				return node;
			}
			if(lang.isFunction(value)){
				// special case: assigning an event handler
				// clobber if we can
				var attrId = node[_attrId];
				if(!attrId){
					attrId = _ctr++;
					node[_attrId] = attrId;
				}
				if(!_evtHdlrMap[attrId]){
					_evtHdlrMap[attrId] = {};
				}
				var h = _evtHdlrMap[attrId][propName];
				if(h){
					//h.remove();
					conn.disconnect(h);
				}else{
					try{
						delete node[propName];
					}catch(e){}
				}
				// ensure that event objects are normalized, etc.
				if(value){
					//_evtHdlrMap[attrId][propName] = on(node, propName, value);
					_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
				}else{
					node[propName] = null;
				}
				return node; // DomNode
			}
			node[propName] = value;
			return node;	// DomNode
		};
	});

},
'xgrid/Keyboard':function(){
define([
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/dom-class',
	'dojo/on',
	'dojo/_base/lang',
	'dojo/has',
	'dgrid/util/misc',
	'dojo/_base/sniff',
	'dcl/dcl'
], function (declare, aspect, domClass, on, lang, has, miscUtil,dcl) {

	var delegatingInputTypes = {
			checkbox: 1,
			radio: 1,
			button: 1
		},
		hasGridCellClass = /\bdgrid-cell\b/,
		hasGridRowClass = /\bdgrid-row\b/,
		_debug = false;

    has.add("dom-contains", function(global, doc, element){
        return !!element.contains; // not supported by FF < 9
    });

    function contains(parent, node){
        // summary:
        //		Checks to see if an element is contained by another element.

        if(has("dom-contains")){
            return parent.contains(node);
        }else{
            return parent.compareDocumentPosition(node) & 8 /* DOCUMENT_POSITION_CONTAINS */;
        }
    }

	var _upDownSelect = function(event,who,steps) {

		var prev     = steps < 0,
			selector = prev ? 'first:' : 'last',
			s, n, sib, top, left;

		var _current = who.row(event).element;
		var sel = $(_current); // header reports row as undefined

		var clDisabled = 'ui-state-disabled';
		function sibling(n, direction) {
			return n[direction+'All']('[id]:not(.'+clDisabled+'):not(.dgrid-content-parent):first');
		}
		var hasLeftRight=false;
		if (sel.length) {
			var next = who.up(who._focusedNode,1, true);
			s = sel;
			sib = $(next.element);
			if (!sib.length) {
				// there is no sibling on required side - do not move selection
				n = s;
			} else if (hasLeftRight) {//done somewhere else
				n = sib;
			} else {
				// find up/down side file in icons view
				top = s.position().top;
				left = s.position().left;
				n = s;
				if (prev) {
					do {
						n = n.prev('[id]');
					} while (n.length && !(n.position().top < top && n.position().left <= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'next');
					}
				} else {
					do {
						n = n.next('[id]');
					} while (n.length && !(n.position().top > top && n.position().left >= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'prev');
					}
				}
			}
		}
		return n;
	};
	var _rightLeftSelect = function(event,who,steps) {

		var prev     = steps < 0,
			selector = prev ? 'first:' : 'last',
			s, n, sib, top, left;

		var _current = who.row(event).element;
		var sel = $(_current); // header reports row as undefined

		var clDisabled = 'ui-state-disabled';
		function sibling(n, direction) {
			return n[direction+'All']('[id]:not(.'+clDisabled+'):not(.dgrid-content-parent):first');
		}
		var hasLeftRight=true;
		if (sel.length) {
			var next = who.up(who._focusedNode,1, true);
			s = sel;
			sib = $(next.element);
			if (!sib.length) {
				// there is no sibling on required side - do not move selection
				n = s;
			} else if (hasLeftRight) {//done somewhere else
				n = sib;
			} else {
				// find up/down side file in icons view
				top = s.position().top;
				left = s.position().left;
				n = s;
				if (prev) {
					do {
						n = n.prev('[id]');
					} while (n.length && !(n.position().top < top && n.position().left <= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'next');
					}
				} else {
					do {
						n = n.next('[id]');
					} while (n.length && !(n.position().top > top && n.position().left >= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'prev');
					}
				}
			}
		}
		return n;
	};

	var Implementation = {
		// summary:
		//		Adds keyboard navigation capability to a list or grid.

		// pageSkip: Number
		//		Number of rows to jump by when page up or page down is pressed.
		pageSkip: 10,

		tabIndex: -1,

		// keyMap: Object
		//		Hash which maps key codes to functions to be executed (in the context
		//		of the instance) for key events within the grid's body.
		keyMap: null,

		// headerKeyMap: Object
		//		Hash which maps key codes to functions to be executed (in the context
		//		of the instance) for key events within the grid's header row.
		headerKeyMap: null,

		postMixInProperties: function () {
			this.inherited(arguments);

			if (!this.keyMap) {
				this.keyMap = lang.mixin({}, Implementation.defaultKeyMap);
			}
			if (!this.headerKeyMap) {
				this.headerKeyMap = lang.mixin({}, Implementation.defaultHeaderKeyMap);
			}
		},

		postCreate: function () {
			this.inherited(arguments);
			var grid = this;

			function handledEvent(event) {
				// Text boxes and other inputs that can use direction keys should be ignored
				// and not affect cell/row navigation
				var target = event.target;
				return target.type && (!delegatingInputTypes[target.type] || event.keyCode === 32);
			}

			function enableNavigation(areaNode) {

				var cellNavigation = grid.cellNavigation,
					isFocusableClass = cellNavigation ? hasGridCellClass : hasGridRowClass,
					isHeader = areaNode === grid.headerNode,
					initialNode = areaNode;

				function initHeader() {
					if (grid._focusedHeaderNode) {
						// Remove the tab index for the node that previously had it.
						grid._focusedHeaderNode.tabIndex = -1;
					}
					if (grid.showHeader) {
						if (cellNavigation) {
							// Get the focused element. Ensure that the focused element
							// is actually a grid cell, not a column-set-cell or some
							// other cell that should not be focused
							var elements = grid.headerNode.getElementsByTagName('th');
							for (var i = 0, element; (element = elements[i]); ++i) {
								if (isFocusableClass.test(element.className)) {
									grid._focusedHeaderNode = initialNode = element;
									break;
								}
							}
						}
						else {
							grid._focusedHeaderNode = initialNode = grid.headerNode;
						}

						// Set the tab index only if the header is visible.
						if (initialNode) {
							initialNode.tabIndex = grid.tabIndex;
						}
					}
				}

				if (isHeader) {
					// Initialize header now (since it's already been rendered),
					// and aspect after future renderHeader calls to reset focus.
					initHeader();
					aspect.after(grid, 'renderHeader', initHeader, true);
				}
				else {
					aspect.after(grid, 'renderArray', function (rows) {
						// summary:
						//		Ensures the first element of a grid is always keyboard selectable after data has been
						//		retrieved if there is not already a valid focused element.

						var focusedNode = grid._focusedNode || initialNode;

						// do not update the focused element if we already have a valid one
						if (isFocusableClass.test(focusedNode.className) && miscUtil.contains(areaNode, focusedNode)) {
							return rows;
						}

						// ensure that the focused element is actually a grid cell, not a
						// dgrid-preload or dgrid-content element, which should not be focusable,
						// even when data is loaded asynchronously
						var elements = areaNode.getElementsByTagName('*');
						for (var i = 0, element; (element = elements[i]); ++i) {
							if (isFocusableClass.test(element.className)) {
								focusedNode = grid._focusedNode = element;
								break;
							}
						}

						focusedNode.tabIndex = grid.tabIndex;
						return rows;
					});
				}

				grid._listeners.push(on(areaNode, 'mousedown', function (event) {
					if (!handledEvent(event)) {
						grid._focusOnNode(event.target, isHeader, event);
					}
				}));

				grid._listeners.push(on(areaNode, 'keydown', function (event) {
					//console.log('keyboardkey down : ',event);
					// For now, don't squash browser-specific functionalities by letting
					// ALT and META function as they would natively
					if (event.metaKey || event.altKey) {
						return;
					}

					var handler = grid[isHeader ? 'headerKeyMap' : 'keyMap'][event.keyCode];

					// Text boxes and other inputs that can use direction keys should be ignored
					// and not affect cell/row navigation
					if (handler && !handledEvent(event)) {
						handler.call(grid, event);
					}
				}));
			}

			if (this.tabableHeader) {
				enableNavigation(this.headerNode);
				on(this.headerNode, 'dgrid-cellfocusin', function () {
					grid.scrollTo({ x: this.scrollLeft });
				});
			}
			enableNavigation(this.contentNode);

			this._debouncedEnsureScroll = miscUtil.debounce(this._ensureScroll, this);
		},

		removeRow: function (rowElement) {
			if (!this._focusedNode) {
				// Nothing special to do if we have no record of anything focused
				return this.inherited(arguments);
			}

			var self = this,
				isActive = document.activeElement === this._focusedNode,

					focusedTarget = this[this.cellNavigation ? 'cell' : 'row'](this._focusedNode);

            if(!focusedTarget){
                console.error('no focus target');
                return this.inherited(arguments);
            }


				var focusedRow = focusedTarget.row || focusedTarget,
				sibling;
			rowElement = rowElement.element || rowElement;

			// If removed row previously had focus, temporarily store information
			// to be handled in an immediately-following insertRow call, or next turn
			if (rowElement === focusedRow.element) {
				sibling = this.down(focusedRow, true);

				// Check whether down call returned the same row, or failed to return
				// any (e.g. during a partial unrendering)
				if (!sibling || sibling.element === rowElement) {
					sibling = this.up(focusedRow, true);
				}

				this._removedFocus = {
					active: isActive,
					rowId: focusedRow.id,
					columnId: focusedTarget.column && focusedTarget.column.id,
					siblingId: !sibling || sibling.element === rowElement ? undefined : sibling.id
				};

				// Call _restoreFocus on next turn, to restore focus to sibling
				// if no replacement row was immediately inserted.
				// Pass original row's id in case it was re-inserted in a renderArray
				// call (and thus was found, but couldn't be focused immediately)
				setTimeout(function () {
					if (self._removedFocus) {
						self._restoreFocus(focusedRow.id);
					}
				}, 0);

				// Clear _focusedNode until _restoreFocus is called, to avoid
				// needlessly re-running this logic
				this._focusedNode = null;
			}

			this.inherited(arguments);
		},

		insertRow: function () {
			var rowElement = this.inherited(arguments);
			if (this._removedFocus && !this._removedFocus.wait) {
				this._restoreFocus(rowElement);
			}
			return rowElement;
		},

		_restoreFocus: function (row) {
			// summary:
			//		Restores focus to the newly inserted row if it matches the
			//		previously removed row, or to the nearest sibling otherwise.

			var focusInfo = this._removedFocus,
				newTarget,
				cell;

			row = row && this.row(row);
			newTarget = row && row.element && row.id === focusInfo.rowId ? row :
				typeof focusInfo.siblingId !== 'undefined' && this.row(focusInfo.siblingId);

			if (newTarget && newTarget.element) {
				if (!newTarget.element.parentNode.parentNode) {
					// This was called from renderArray, so the row hasn't
					// actually been placed in the DOM yet; handle it on the next
					// turn (called from removeRow).
					focusInfo.wait = true;
					return;
				}
				// Should focus be on a cell?
				if (typeof focusInfo.columnId !== 'undefined') {
					cell = this.cell(newTarget, focusInfo.columnId);
					if (cell && cell.element) {
						newTarget = cell;
					}
				}
				if (focusInfo.active && newTarget.element.offsetHeight !== 0) {
					// Row/cell was previously focused and is visible, so focus the new one immediately
					this._focusOnNode(newTarget, false, null);
				}
				else {
					// Row/cell was not focused or is not visible, but we still need to
					// update _focusedNode and the element's tabIndex/class
					domClass.add(newTarget.element, 'dgrid-focus');
					newTarget.element.tabIndex = this.tabIndex;
					this._focusedNode = newTarget.element;
				}
			}

			delete this._removedFocus;
		},

		addKeyHandler: function (key, callback, isHeader) {
			// summary:
			//		Adds a handler to the keyMap on the instance.
			//		Supports binding additional handlers to already-mapped keys.
			// key: Number
			//		Key code representing the key to be handled.
			// callback: Function
			//		Callback to be executed (in instance context) when the key is pressed.
			// isHeader: Boolean
			//		Whether the handler is to be added for the grid body (false, default)
			//		or the header (true).

			// Aspects may be about 10% slower than using an array-based appraoch,
			// but there is significantly less code involved (here and above).
			return aspect.after( // Handle
				this[isHeader ? 'headerKeyMap' : 'keyMap'], key, callback, true);
		},

		_ensureRowScroll: function (rowElement) {
			// summary:
			//		Ensures that the entire row is visible within the viewport.
			//		Called for cell navigation in complex structures.

			var scrollY = this.getScrollPosition().y;
			if (scrollY > rowElement.offsetTop) {
				// Row starts above the viewport
				this.scrollTo({ y: rowElement.offsetTop });
			}
			else if (scrollY + this.contentNode.offsetHeight < rowElement.offsetTop + rowElement.offsetHeight) {
				// Row ends below the viewport
				this.scrollTo({ y: rowElement.offsetTop - this.contentNode.offsetHeight + rowElement.offsetHeight });
			}
		},

		_ensureColumnScroll: function (cellElement) {
			// summary:
			//		Ensures that the entire cell is visible in the viewport.
			//		Called in cases where the grid can scroll horizontally.

			var scrollX = this.getScrollPosition().x;
			var cellLeft = cellElement.offsetLeft;
			if (scrollX > cellLeft) {
				this.scrollTo({ x: cellLeft });
			}
			else {
				var bodyWidth = this.bodyNode.clientWidth;
				var cellWidth = cellElement.offsetWidth;
				var cellRight = cellLeft + cellWidth;
				if (scrollX + bodyWidth < cellRight) {
					// Adjust so that the right side of the cell and grid body align,
					// unless the cell is actually wider than the body - then align the left sides
					this.scrollTo({ x: bodyWidth > cellWidth ? cellRight - bodyWidth : cellLeft });
				}
			}
		},

		_ensureScroll: function (cell, isHeader) {
			// summary:
			//		Corrects scroll based on the position of the newly-focused row/cell
			//		as necessary based on grid configuration and dimensions.

			if(this.cellNavigation && (this.columnSets || this.subRows.length > 1) && !isHeader){
				this._ensureRowScroll(cell.row.element);
			}
			if(this.bodyNode.clientWidth < this.contentNode.offsetWidth){
				this._ensureColumnScroll(cell.element);
			}
		},

		_focusOnNode: function (element,isHeader,event,emit) {
			var focusedNodeProperty = '_focused' + (isHeader ? 'Header' : '') + 'Node',
				focusedNode = this[focusedNodeProperty],
				cellOrRowType = this.cellNavigation ? 'cell' : 'row',
				cell = this[cellOrRowType](element),
				inputs,
				input,
				numInputs,
				inputFocused,
				i;

			element = cell && cell.element;

			if (!element /*|| element==this._focusedNode*/) {
				//console.error('same el');
				return;
			}

			if (this.cellNavigation) {
				inputs = element.getElementsByTagName('input');
				for (i = 0, numInputs = inputs.length; i < numInputs; i++) {
					input = inputs[i];
					if ((input.tabIndex !== -1 || '_dgridLastValue' in input) && !input.disabled) {
						input.focus();
						inputFocused = true;
						break;
					}
				}
			}

			// Set up event information for dgrid-cellfocusout/in events.
			// Note that these events are not fired for _restoreFocus.
			if (event !== null) {
				event = lang.mixin({ grid: this }, event);
				if (event.type) {
					event.parentType = event.type;
				}
				if (!event.bubbles) {
					// IE doesn't always have a bubbles property already true.
					// Opera throws if you try to set it to true if it is already true.
					event.bubbles = true;
				}
			}

			if (focusedNode) {
				// Clean up previously-focused element
				// Remove the class name and the tabIndex attribute
				domClass.remove(focusedNode, 'dgrid-focus');
				focusedNode.removeAttribute('tabindex');

				// Expose object representing focused cell or row losing focus, via
				// event.cell or event.row; which is set depends on cellNavigation.
				if (event) {
					event[cellOrRowType] = this[cellOrRowType](focusedNode);
					on.emit(focusedNode, 'dgrid-cellfocusout', event);
				}
			}
			focusedNode = this[focusedNodeProperty] = element;

			if (event) {
				// Expose object representing focused cell or row gaining focus, via
				// event.cell or event.row; which is set depends on cellNavigation.
				// Note that yes, the same event object is being reused; on.emit
				// performs a shallow copy of properties into a new event object.
				event[cellOrRowType] = cell;
			}

			var isFocusableClass = this.cellNavigation ? hasGridCellClass : hasGridRowClass;
			if (!inputFocused && isFocusableClass.test(element.className)) {

				element.tabIndex = this.tabIndex;
				element.focus();
			}
			domClass.add(element, 'dgrid-focus');


			if (event && emit!==false) {
				on.emit(focusedNode, 'dgrid-cellfocusin', event);
			}

			this._debouncedEnsureScroll(cell, isHeader);
		},

		focusHeader: function (element) {
			this._focusOnNode(element || this._focusedHeaderNode, true);
		},

		focus: function (element,emit) {
			_debug && console.log('focuse : ' + (element ? element.id : ''));
			var node = element || this._focusedNode;
			if (node) {
				if (element==this._focusedNode) {
					//console.error('same el');
					//return;
				}
				this._focusOnNode(node, false,null,emit);
			}
			else {
				this.contentNode.focus();
			}
		}
	};

	// Common functions used in default keyMap (called in instance context)

	var moveFocusVertical = Implementation.moveFocusVertical = function (event, steps) {
		if(this.isThumbGrid){
			var next = _upDownSelect(event,this,steps);
			if(next && next.length){
				this._focusOnNode(next[0], false, event);
				event.preventDefault();
				return;
			}
		}
		var cellNavigation = this.cellNavigation,
			target = this[cellNavigation ? 'cell' : 'row'](event),
			columnId = cellNavigation && target.column.id,
			next = this.down(this._focusedNode, steps, true);

		// Navigate within same column if cell navigation is enabled
		if (cellNavigation) {
			next = this.cell(next, columnId);
		}
		this._focusOnNode(next, false, event);

		event.preventDefault();
	};

	var moveFocusUp = Implementation.moveFocusUp = function (event) {
		moveFocusVertical.call(this, event, -1);
	};

	var moveFocusDown = Implementation.moveFocusDown = function (event) {
		moveFocusVertical.call(this, event, 1);
	};

	var moveFocusPageUp = Implementation.moveFocusPageUp = function (event) {
		moveFocusVertical.call(this, event, -this.pageSkip);
	};

	var moveFocusPageDown = Implementation.moveFocusPageDown = function (event) {
		moveFocusVertical.call(this, event, this.pageSkip);
	};

	var moveFocusHorizontal = Implementation.moveFocusHorizontal = function (event, steps) {

		if (!this.cellNavigation && this.isThumbGrid!==true) {
			return;
		}

		var isHeader = !this.row(event), // header reports row as undefined
			currentNode = this['_focused' + (isHeader ? 'Header' : '') + 'Node'];

		//var _row = this.row(event);
		if(this.isThumbGrid==true){

			var cellNavigation = this.cellNavigation,
				next = this.down(this._focusedNode, steps, true);

			// Navigate within same column if cell navigation is enabled
			this._focusOnNode(next, false, event);
			event.preventDefault();
			return ;
		}

		this._focusOnNode(this.right(currentNode, steps), isHeader, event);
		event.preventDefault();
	};

	var moveFocusLeft = Implementation.moveFocusLeft = function (event) {
		moveFocusHorizontal.call(this, event, -1);
	};

	var moveFocusRight = Implementation.moveFocusRight = function (event) {
		moveFocusHorizontal.call(this, event, 1);
	};

	var moveHeaderFocusEnd = Implementation.moveHeaderFocusEnd = function (event, scrollToBeginning) {
		// Header case is always simple, since all rows/cells are present
		var nodes;
		if (this.cellNavigation) {
			nodes = this.headerNode.getElementsByTagName('th');
			this._focusOnNode(nodes[scrollToBeginning ? 0 : nodes.length - 1], true, event);
		}
		// In row-navigation mode, there's nothing to do - only one row in header

		// Prevent browser from scrolling entire page
		event.preventDefault();
	};

	var moveHeaderFocusHome = Implementation.moveHeaderFocusHome = function (event) {
		moveHeaderFocusEnd.call(this, event, true);
	};

	var moveFocusEnd = Implementation.moveFocusEnd = function (event, scrollToTop) {
		// summary:
		//		Handles requests to scroll to the beginning or end of the grid.

		// Assume scrolling to top unless event is specifically for End key
		var cellNavigation = this.cellNavigation,
			contentNode = this.contentNode,
			contentPos = scrollToTop ? 0 : contentNode.scrollHeight,
			scrollPos = contentNode.scrollTop + contentPos,
			endChild = contentNode[scrollToTop ? 'firstChild' : 'lastChild'];

		if(endChild.className.indexOf('dgrid-extra') > -1){
			endChild = endChild['previousSibling'];
		}

		var	hasPreload = endChild.className.indexOf('dgrid-preload') > -1,
			endTarget = hasPreload ? endChild[(scrollToTop ? 'next' : 'previous') + 'Sibling'] : endChild,
			endPos = endTarget.offsetTop + (scrollToTop ? 0 : endTarget.offsetHeight),
			handle;

		if (hasPreload) {
			// Find the nearest dgrid-row to the relevant end of the grid
			while (endTarget && endTarget.className.indexOf('dgrid-row') < 0) {
				endTarget = endTarget[(scrollToTop ? 'next' : 'previous') + 'Sibling'];
			}
			// If none is found, there are no rows, and nothing to navigate
			if (!endTarget) {
				return;
			}
		}

		// Grid content may be lazy-loaded, so check if content needs to be
		// loaded first
		if (!hasPreload || endChild.offsetHeight < 1) {
			// End row is loaded; focus the first/last row/cell now
			if (cellNavigation) {
				// Preserve column that was currently focused
				endTarget = this.cell(endTarget, this.cell(event).column.id);
			}
			this._focusOnNode(endTarget, false, event);
		}
		else {
			// In IE < 9, the event member references will become invalid by the time
			// _focusOnNode is called, so make a (shallow) copy up-front
			if (!has('dom-addeventlistener')) {
				event = lang.mixin({}, event);
			}

			// If the topmost/bottommost row rendered doesn't reach the top/bottom of
			// the contentNode, we are using OnDemandList and need to wait for more
			// data to render, then focus the first/last row in the new content.
			handle = aspect.after(this, 'renderArray', function (rows) {
				var target = rows[scrollToTop ? 0 : rows.length - 1];
				if (cellNavigation) {
					// Preserve column that was currently focused
					target = this.cell(target, this.cell(event).column.id);
				}
				this._focusOnNode(target, false, event);
				handle.remove();
				return rows;
			});
		}

		if (scrollPos === endPos) {
			// Grid body is already scrolled to end; prevent browser from scrolling
			// entire page instead
			event.preventDefault();
		}
	};

	var moveFocusHome = Implementation.moveFocusHome = function (event) {
		moveFocusEnd.call(this, event, true);
	};

	function preventDefault(event) {
		event.preventDefault();
	}

	Implementation.defaultKeyMap = {
		32: preventDefault, // space
		33: moveFocusPageUp, // page up
		34: moveFocusPageDown, // page down
		35: moveFocusEnd, // end
		36: moveFocusHome, // home
		37: moveFocusLeft, // left
		38: moveFocusUp, // up
		39: moveFocusRight, // right
		40: moveFocusDown // down
	};

	// Header needs fewer default bindings (no vertical), so bind it separately
	Implementation.defaultHeaderKeyMap = {
		32: preventDefault, // space
		35: moveHeaderFocusEnd, // end
		36: moveHeaderFocusHome, // home
		37: moveFocusLeft, // left
		39: moveFocusRight // right
	};

	var Module = declare(null,Implementation);
	Module.dcl = dcl(null,Implementation);
	return Module;
});

},
'xide/utils/ObjectUtils':function(){
define([
    'xide/utils',
    'require',
    "dojo/Deferred",
    'xide/lodash'
], function (utils, require, Deferred,lodash) {
    var _debug = false;
    "use strict";
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Loader utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.debounce = function(who,methodName,_function,delay,options,now,args){
        var _place = who[methodName+'_debounced'];
        if(!_place){
            _place = who[methodName+'_debounced'] =  lodash.debounce(_function, delay,options);
        }
        if(now===true){
            if(!who[methodName+'_debouncedFirst']){
                who[methodName+'_debouncedFirst']=true;
                _function.apply(who,args);
            }
        }
        return _place();
    };


    utils.pluck=function(items,prop){
        return lodash.map(items,prop);
    };

    /**
     * Trigger downloadable file
     * @param filename
     * @param text
     */
    utils.download  = function(filename, text){
        var element = document.createElement('a');
        text = lodash.isString(text) ? text : JSON.stringify(text,null,2);
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    /**
     * Ask require registry at this path
     * @param mixed
     * @returns {*}
     */
    utils.hasObject = function (mixed) {
        var result = null;
        var _re = require;
        try {
            result = _re(mixed);
        } catch (e) {
            console.error('error in utils.hasObject ', e);
        }
        return result;
    };
    /**
     * Safe require.toUrl
     * @param mid {string}
     */
    utils.toUrl = function(mid){
        var _require = require;
        //make sure cache bust is off otherwise it appends ?time
        _require({
            cacheBust: null,
            waitSeconds: 5
        });
        return _require.toUrl(mid);
    }
    /**
     * Returns a module by module path
     * @param mixed {String|Object}
     * @param _default {Object} default object
     * @returns {Object|Promise}
     */
    utils.getObject = function (mixed, _default) {
        var result = null;
        if (utils.isString(mixed)) {
            var _re = require;
            try {
                result = _re(mixed);
            } catch (e) {
                _debug && console.warn('utils.getObject::require failed for ' + mixed);
            }
            //not a loaded module yet
            try {
                if (!result) {
                    var deferred = new Deferred();
                    //try loader
                    result = _re([
                        mixed
                    ], function (module) {
                        deferred.resolve(module);
                    });
                    return deferred.promise;
                }
            }catch(e){
                _debug &&  console.error('error in requiring '+mixed,e);
            }
            return result;

        } else if (utils.isObject(mixed)) {
            return mixed;//reflect
        }
        return result !== null ? result : _default;
    };


    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  True object utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.toArray = function (obj) {
        var result = [];
        for (var c in obj) {
            result.push({
                name: c,
                value: obj[c]
            });
        }
        return result;
    };
    /**
     * Array to object conversion
     * @param arr
     * @returns {Object}
     */
    utils.toObject = function (arr, lodash) {
        if (!arr) {
            return {};
        }
        if (lodash !== false) {
            return lodash.object(lodash.map(arr, lodash.values));
        } else {
            //CI related back compat hack
            if (utils.isObject(arr) && arr[0]) {
                return arr[0];
            }

            var rv = {};
            for (var i = 0; i < arr.length; ++i) {
                rv[i] = arr[i];
            }
            return rv;
        }
    };

    /**
     * Gets an object property by string, eg: utils.byString(someObj, 'part3[0].name');
     * @deprecated, see objectAtPath below
     * @param o {Object}    : the object
     * @param s {String}    : the path within the object
     * @param defaultValue {Object|String|Number} : an optional default value
     * @returns {*}
     */
    utils.byString = function (o, s, defaultValue) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, '');           // strip a leading dot
        var a = s.split('.');
        while (a.length) {
            var n = a.shift();
            if (n in o) {
                o = o[n];
            } else {
                return;
            }
        }
        return o;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Internals
     */

    //cache
    var toStr = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * @private
     * @param type
     * @returns {*}
     */
    function toString(type) {
        return toStr.call(type);
    }

    /**
     * @private
     * @param key
     * @returns {*}
     */
    function getKey(key) {
        var intKey = parseInt(key,10);
        if (intKey.toString() === key) {
            return intKey;
        }
        return key;
    }

    /**
     * internal set value at path in object
     * @private
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    function set(obj, path, value, doNotReplace) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return set(obj, path.split('.').map(getKey), value, doNotReplace);
        }
        var currentPath = path[0];

        if (path.length === 1) {
            var oldVal = obj[currentPath];
            if (oldVal === void 0 || !doNotReplace) {
                obj[currentPath] = value;
            }
            return oldVal;
        }

        if (obj[currentPath] === void 0) {
            //check if we assume an array
            if (lodash.isNumber(path[1])) {
                obj[currentPath] = [];
            } else {
                obj[currentPath] = {};
            }
        }
        return set(obj[currentPath], path.slice(1), value, doNotReplace);
    }

    /**
     * deletes an property by a path
     * @param obj
     * @param path
     * @returns {*}
     */
    function del(obj, path) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return del(obj, path.split('.'));
        }

        var currentPath = getKey(path[0]);
        var oldVal = obj[currentPath];

        if (path.length === 1) {
            if (oldVal !== void 0) {
                if (lodash.isArray(obj)) {
                    obj.splice(currentPath, 1);
                } else {
                    delete obj[currentPath];
                }
            }
        } else {
            if (obj[currentPath] !== void 0) {
                return del(obj[currentPath], path.slice(1));
            }
        }
        return obj;
    }

    /**
     * Private helper class
     * @private
     * @type {{}}
     */
    var objectPath = {};

    objectPath.has = function (obj, path) {
        if (lodash.isEmpty(obj)) {
            return false;
        }
        if (lodash.isNumber(path)) {
            path = [path];
        } else if (lodash.isString(path)) {
            path = path.split('.');
        }

        if (lodash.isEmpty(path) || path.length === 0) {
            return false;
        }

        for (var i = 0; i < path.length; i++) {
            var j = path[i];
            if ((lodash.isObject(obj) || lodash.isArray(obj)) && _hasOwnProperty.call(obj, j)) {
                obj = obj[j];
            } else {
                return false;
            }
        }

        return true;
    };

    /**
     * Define private public 'ensure exists'
     * @param obj
     * @param path
     * @param value
     * @returns {*}
     */
    objectPath.ensureExists = function (obj, path, value) {
        return set(obj, path, value, true);
    };

    /**
     * Define private public 'set'
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    objectPath.set = function (obj, path, value, doNotReplace) {
        return set(obj, path, value, doNotReplace);
    };

    /**
     Define private public 'insert'
     * @param obj
     * @param path
     * @param value
     * @param at
     */
    objectPath.insert = function (obj, path, value, at) {
        var arr = objectPath.get(obj, path);
        at = ~~at;
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.splice(at, 0, value);
    };

    /**
     * Define private public 'empty'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.empty = function (obj, path) {
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        var value, i;
        if (!(value = objectPath.get(obj, path))) {
            return obj;
        }

        if (lodash.isString(value)) {
            return objectPath.set(obj, path, '');
        } else if (lodash.isBoolean(value)) {
            return objectPath.set(obj, path, false);
        } else if (lodash.isNumber(value)) {
            return objectPath.set(obj, path, 0);
        } else if (lodash.isArray(value)) {
            value.length = 0;
        } else if (lodash.isObject(value)) {
            for (i in value) {
                if (_hasOwnProperty.call(value, i)) {
                    delete value[i];
                }
            }
        } else {
            return objectPath.set(obj, path, null);
        }
    };

    /**
     * Define private public 'push'
     * @param obj
     * @param path
     */
    objectPath.push = function (obj, path /*, values */) {
        var arr = objectPath.get(obj, path);
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };

    /**
     * Define private public 'coalesce'
     * @param obj
     * @param paths
     * @param defaultValue
     * @returns {*}
     */
    objectPath.coalesce = function (obj, paths, defaultValue) {
        var value;
        for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
                return value;
            }
        }
        return defaultValue;
    };

    /**
     * Define private public 'get'
     * @param obj
     * @param path
     * @param defaultValue
     * @returns {*}
     */
    objectPath.get = function (obj, path, defaultValue) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            //lodash doesnt seem to work with html nodes
            if (obj && obj.innerHTML === null) {
                return defaultValue;
            }
        }
        if (lodash.isString(path)) {
            return objectPath.get(obj, path.split('.'), defaultValue);
        }
        var currentPath = getKey(path[0]);
        if (path.length === 1) {
            if (obj && obj[currentPath] === void 0) {
                return defaultValue;
            }
            if (obj) {
                return obj[currentPath];
            }
        }
        if (!obj) {
            return defaultValue;
        }
        return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
    };

    /**
     * Define private public 'del'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.del = function (obj, path) {
        return del(obj, path);
    };
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path public xide/utils mixin
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *  Returns a value by a give object path
     *
     *  //works also with arrays
     *    objectPath.get(obj, "a.c.1");  //returns "f"
     *    objectPath.get(obj, ["a","c","1"]);  //returns "f"
     *
     * @param obj {object}
     * @param path {string}
     * @param _default {object|null}
     * @returns {*}
     */
    utils.getAt = function (obj, path, _default) {
        return objectPath.get(obj, path, _default);
    };

    /**
     * Sets a value in an object/array at a given path.
     * @example
     *
     * utils.setAt(obj, "a.h", "m"); // or utils.setAt(obj, ["a","h"], "m");
     *
     * //set will create intermediate object/arrays
     * objectPath.set(obj, "a.j.0.f", "m");
     *
     * @param obj{Object|Array}
     * @param path {string}
     * @param value {mixed}
     * @returns {Object|Array}
     */
    utils.setAt = function (obj, path, value) {
        return objectPath.set(obj, path, value);
    };

    /**
     * Returns there is anything at given path within an object/array.
     * @param obj
     * @param path
     */
    utils.hasAt = function (obj, path) {
        return objectPath.has(obj, path);
    };

    /**
     * Ensures at given path, otherwise _default will be placed
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.ensureAt = function (obj, path, _default) {
        return objectPath.ensureExists(obj, path, _default);
    };
    /**
     * Deletes at given path
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.deleteAt = function (obj, path) {
        return objectPath.del(obj, path);
    };

    /**
     *
     * @param to
     * @param from
     * @returns {*}
     */
    utils.merge = function (to, from) {
        for (var n in from) {
            if (typeof to[n] != 'object') {
                to[n] = from[n];
            } else if (typeof from[n] == 'object') {
                to[n] = utils.merge(to[n], from[n]);
            }
        }

        return to;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Dojo's most wanted
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    utils.clone=function(/*anything*/ src){
        // summary:
        // Clones objects (including DOM nodes) and all children.
        // Warning: do not clone cyclic structures.
        // src:
        // The object to clone
        if(!src || typeof src != "object" || utils.isFunction(src)){
            // null, undefined, any non-object, or function
            return src; // anything
        }
        if(src.nodeType && "cloneNode" in src){
            // DOM Node
            return src.cloneNode(true); // Node
        }
        if(src instanceof Date){
            // Date
            return new Date(src.getTime()); // Date
        }
        if(src instanceof RegExp){
            // RegExp
            return new RegExp(src); // RegExp
        }
        var r, i, l;
        if(utils.isArray(src)){
            // array
            r = [];
            for(i = 0, l = src.length; i < l; ++i){
                if(i in src){
                    r.push(utils.clone(src[i]));
                }
            }
            // we don't clone functions for performance reasons
            // }else if(d.isFunction(src)){
            // // function
            // r = function(){ return src.apply(this, arguments); };
        }else{
            // generic objects
            r = src.constructor ? new src.constructor() : {};
        }
        return utils._mixin(r, src, utils.clone);
    };

    /**
     * Copies/adds all properties of source to dest; returns dest.
     * @description All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
     * found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
     * delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
     * Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
     * @param dest {object} The object to which to copy/add all properties contained in source.
     * @param source {object} The object from which to draw all properties to copy into dest.
     * @param copyFunc {function} The process used to copy/add a property in source; defaults to the Javascript assignment operator.
     * @returns {object} dest, as modified
     * @private
     */
    utils._mixin=function (dest, source, copyFunc) {
        var name, s, i, empty = {};
        for (name in source) {
            // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
            // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
            // don't overwrite it with the toString() method that source inherited from Object.prototype
            s = source[name];
            if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                dest[name] = copyFunc ? copyFunc(s) : s;
            }
        }

        return dest; // Object
    };
    /**
     * Copies/adds all properties of one or more sources to dest; returns dest.
     * @param dest {object} The object to which to copy/add all properties contained in source. If dest is falsy, then
     * a new object is manufactured before copying/adding properties begins.
     *
     * @param sources One of more objects from which to draw all properties to copy into dest. sources are processed
     * left-to-right and if more than one of these objects contain the same property name, the right-most
     * value "wins".
     *
     * @returns {object} dest, as modified
     *
     * @example
     * make a shallow copy of an object
     * var copy = utils.mixin({}, source);
     *
     * @example
     *
     * many class constructors often take an object which specifies
     *        values to be configured on the object. In this case, it is
     *        often simplest to call `lang.mixin` on the `this` object:
     *        declare("acme.Base", null, {
    *			constructor: function(properties){
    *				//property configuration:
    *				lang.mixin(this, properties);
    *				console.log(this.quip);
    *			},
    *			quip: "I wasn't born yesterday, you know - I've seen movies.",
    *			* ...
    *		});
     *
     *        //create an instance of the class and configure it
     *        var b = new acme.Base({quip: "That's what it does!" });
     *
     */
    utils.mixin = function (dest, sources) {
        if(sources) {

            if (!dest) {
                dest = {};            }

            var l = arguments.length;
            for (var i = 1 ; i < l; i++) {
                utils._mixin(dest, arguments[i]);
            }
            return dest; // Object
        }
        return dest;
    };

    /**
     * Clone object keys
     * @param defaults
     * @returns {{}}
     */
    utils.cloneKeys = function (defaults, skipEmpty) {
        var result = {};
        for (var _class in defaults) {
            if (skipEmpty === true && !(_class in defaults)) {
                continue;
            }
            result[_class] = defaults[_class];
        }
        return result;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  STD
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isArray=function(what){
        return lodash.isArray(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isObject=function(what){
        return lodash.isObject(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isString=function(what){
        return lodash.isString(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isNumber=function(what){
        return lodash.isNumber(what);
    };
    /**
     *
     * @param it
     * @returns {*}
     */
    utils.isFunction=function(it){
        // summary:
        // Return true if it is a Function
        // it: anything
        // Item to test.
        return lodash.isFunction(it);
    };
    return utils;
});
},
'xfile/ThumbRenderer':function(){
/** @module xfile/ThumbRenderer **/
define([
    "xdojo/declare",
    'xide/utils',
    'dojo/dom-construct',
    'xgrid/ThumbRenderer'
], function (declare,utils,domConstruct,ThumbRenderer) {

    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xfile/ThumbRenderer
     * @extends module:xfile/Renderer
     */
    return declare('xfile.ThumbRenderer',[ThumbRenderer],{
        thumbSize: "400",
        resizeThumb: true,
        __type:'thumb',
        deactivateRenderer:function(){
            $(this.domNode.parentNode).removeClass('metro');
            $(this.domNode).css('padding','');
            this.isThumbGrid = false;

        },
        activateRenderer:function(){
            $(this.domNode.parentNode).addClass('metro');
            $(this.contentNode).css('padding','8px');
            this.isThumbGrid = true;
            this.refresh();
        },

        _renderUpload:function(name,progress,obj){

            progress = parseInt(progress.replace('%',''));
            if(progress==100){
                progress = 90;
            }

            var result = '<div class="tile widget uploadItem"><div class="radial-progress tile widget " data-progress="' + progress + '">'+
                '<div class="circle">'+
                '<div class="mask full">'+
                '<div class="fill"></div>'+
                '</div>'+
                '<div class="mask half">'+
                '<div class="fill"></div>'+
                '<div class="fill fix"></div>'+
                '</div>'+
                '<div class="shadow"></div>'+
                '</div>'+
                '<div class="inset">'+
                '<div class="percentage">'+
                '<div class="numbers"><span>-</span>';

            for(var i= 0 ; i< 99 ; i++){

                result+=('<span>' + i +'%' + '</span>');

            };

            result+='</div>'+
                '</div>'+
                '</div>'+
                '</div></div>';

            return result;

        },
        /**
         * Override renderRow
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {

            if(obj.isUpload === true){
                return $(this._renderUpload(obj.name, obj.progress + '%',obj))[0];
            }


            if(obj.renderRow){
                var _res = obj.renderRow.apply(this,[obj]);
                if(_res){
                    return _res;
                }
            }
            var thiz = this,
                div = domConstruct.create('div', {
                    className: "tile widget"
                }),
                icon = obj.icon,
                no_access = obj.read === false && obj.write === false,
                isBack = obj.name == '..',
                directory = obj && !!obj.directory,
                useCSS = false,
                label = '',
                imageClass = 'fa fa-folder fa-5x',
                isImage = false;

            this._doubleWidthThumbs = true;




            var iconStyle='text-shadow: 2px 2px 5px rgba(0,0,0,0.3);font-size: 72px;opacity: 0.7';
            var contentClass = 'icon';


            if (directory) {

                if (isBack) {
                    imageClass = 'fa fa-level-up fa-5x itemFolder';
                    useCSS = true;
                } else if (!no_access) {
                    imageClass = 'fa fa-folder fa-5x itemFolder';
                    useCSS = true;
                } else {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                }

            } else {

                imageClass = 'itemIcon';

                if (no_access) {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                } else {

                    if (utils.isImage(obj.path)) {

                        var url = this.getImageUrl(obj);
                        if (url) {
                            obj.icon = url;
                        } else {
                            obj.icon = thiz.config.REPO_URL + '/' + obj.path;
                        }

                        imageClass = 'imageFile';

                    } else {
                        imageClass = 'fa fa-5x ' + utils.getIconClass(obj.path);
                        useCSS = true;
                    }
                }

            }

            label = obj.name;

            var folderContent =  '<span style="' + iconStyle + '" class="fa fa-6x '+imageClass +'"></span>';

            if (utils.isImage(obj.path)) {

                var url = this.getImageUrl(obj);
                if (url) {
                    obj.icon = url;
                } else {
                    obj.icon = thiz.config.REPO_URL + '/' + obj.path;
                }

                imageClass = '';
                contentClass = 'image';
                //folderContent =  '<span style="' + iconStyle + '" class="fa fa-6x '+imageClass +'"></span>';
                folderContent = '<div style="" class="tile-content image">' +
                    '<img class=\"' + imageClass + '\" src="' + obj.icon + '"/>' +
                    '</div>';

                useCSS = true;
                isImage = true;

            }


            //var iconStyle='text-shadow: 2px 2px 5px rgba(0,0,0,0.3);left:40px;text-align:left;font-size: 72px;margin-top:-45px;opacity: 0.7';


            var label2 = label + '\n' + obj.modified;

            var html = '<div title="' + label2 +'" class="tile-content ' + contentClass +'">'+
                folderContent +
                '</div>'+

                '<div class="brand opacity">'+
                '<span class="thumbText text opacity ellipsis" style="">'+
                label +
                '</span>'+
                '</div>';


            if(isImage || this._doubleWidthThumbs){
                //$(div).addClass('double');
            }

            if (useCSS) {
                div.innerHTML = html;
                return div;
            }


            if (directory) {
                div.innerHTML = html;
            } else {
                div.innerHTML = '<img class=\"' + imageClass + '\" src="' + obj.icon + '"/>&nbsp;<div class="name">' + obj.name + '</div>';
            }
            return div;

        },
        renderRow2: function (obj) {




            var thiz = this,
                div = domConstruct.create('span', {
                    className: "cell"
                }),
                icon = obj.icon,
                no_access = obj.read === false && obj.write === false,
                isBack = obj.name == '..',
                directory = obj && !!obj.directory,
                imageClass = '',
                useCSS = false,
                label = '';


            if (directory) {

                if (isBack) {
                    imageClass = 'fa fa-level-up fa-5x itemFolder';
                    useCSS = true;
                } else if (!no_access) {
                    imageClass = 'fa fa-folder fa-5x itemFolder';
                    useCSS = true;
                } else {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                }

            } else {

                imageClass = 'itemIcon';

                if (no_access) {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                } else {

                    if (utils.isImage(obj.path)) {

                        var url = this.getImageUrl(obj);
                        if (url) {
                            obj.icon = url;
                        } else {
                            obj.icon = thiz.config.REPO_URL + '/' + obj.path;
                        }
                        imageClass = 'imageFile';

                    } else {
                        imageClass = 'fa fa-5x ' + utils.getIconClass(obj.path);
                        useCSS = true;
                    }
                }

            }

            label = obj.showPath === true ? obj.path : obj.name;
            if (useCSS) {
                div.innerHTML = '<span class=\"' + imageClass + '\""></span> <div class="name" style="">' + label + '</div>';
                return div;
            }

            if (directory) {
                div.innerHTML = '<span class=\"' + imageClass + '\""></span> <div class="name">' + obj.name + '</div>';
            } else {
                div.innerHTML = '<img class=\"' + imageClass + '\" src="' + obj.icon + '"/>&nbsp;<div class="name">' + obj.name + '</div>';
            }
            return div;
        },
        getImageUrl: function (item) {

            var fileManager = this.ctx.getFileManager();
            if (fileManager && fileManager) {
                var params = null;
                if (this.resizeThumb) {
                    params = {
                        width: this.thumbSize
                    }
                }
                return fileManager.getImageUrl(item, null, params);
            }
            return null;
        }
    });
});
},
'dgrid/extensions/ColumnReorder':function(){
define([
	'dojo/_base/lang',
	'dojo/_base/declare',
	'dojo/_base/array',
	'dojo/dom-class',
	'dojo/on',
	'dojo/query',
	'dojo/dnd/Source'
], function (lang, declare, arrayUtil, domClass, on, DndSource) {
	var dndTypeRx = /(\d+)(?:-(\d+))?$/; // used to determine subrow from dndType

	// The following 2 functions are used by onDropInternal logic for
	// retrieving/modifying a given subRow.  The `match` variable in each is
	// expected to be the result of executing dndTypeRx on a subRow ID.

	function getMatchingSubRow(grid, match) {
		var hasColumnSets = match[2],
			rowOrSet = grid[hasColumnSets ? 'columnSets' : 'subRows'][match[1]];

		return hasColumnSets ? rowOrSet[match[2]] : rowOrSet;
	}

	function setMatchingSubRow(grid, match, subRow) {
		if (match[2]) {
			grid.columnSets[match[1]][match[2]] = subRow;
		}
		else {
			grid.subRows[match[1]] = subRow;
		}
	}

	// Builds a prefix for a dndtype value based on a grid id.
	function makeDndTypePrefix(gridId) {
		return 'dgrid-' + gridId + '-';
	}

	// Removes the grid id prefix from a dndtype value.  This allows the grid id to contain
	// a dash-number suffix.  This works only if a column is dropped on the grid from which it
	// originated.  Otherwise, a dash-number suffix will cause the regex to match on the wrong values.
	function stripIdPrefix(gridId, dndtype) {
		return dndtype.slice(makeDndTypePrefix(gridId).length);
	}

	var ColumnDndSource = declare(DndSource, {
		// summary:
		//		Custom dojo/dnd source extension configured specifically for
		//		dgrid column reordering.

		copyState: function () {
			return false; // never copy
		},

		checkAcceptance: function (source) {
			return source === this; // self-accept only
		},

		_legalMouseDown: function (evt) {
			// Overridden to prevent blocking ColumnResizer resize handles.
			return evt.target.className.indexOf('dgrid-resize-handle') > -1 ? false :
				this.inherited(arguments);
		},

		onDropInternal: function (nodes) {
			var grid = this.grid,
				match = dndTypeRx.exec(stripIdPrefix(grid.id, nodes[0].getAttribute('dndType'))),
				structureProperty = match[2] ? 'columnSets' : 'subRows',
				oldSubRow = getMatchingSubRow(grid, match),
				columns = grid.columns;

			// First, allow original DnD logic to place node in new location.
			this.inherited(arguments);

			if (!match) {
				return;
			}

			// Then, iterate through the header cells in their new order,
			// to populate a new row array to assign as a new sub-row to the grid.
			// (Wait until the next turn to avoid errors in Opera.)
			setTimeout(function () {
				var newSubRow = arrayUtil.map(nodes[0].parentNode.childNodes, function (col) {
						return columns[col.columnId];
					}),
					eventObject;

				setMatchingSubRow(grid, match, newSubRow);

				eventObject = {
					grid: grid,
					subRow: newSubRow,
					column: columns[nodes[0].columnId],
					bubbles: true,
					cancelable: true,
					// Set parentType to indicate this is the result of user interaction.
					parentType: 'dnd'
				};
				// Set columnSets or subRows depending on which the grid is using.
				eventObject[structureProperty] = grid[structureProperty];

				// Emit a custom event which passes the new structure.
				// Allow calling preventDefault() to cancel the reorder operation.
				if (on.emit(grid.domNode, 'dgrid-columnreorder', eventObject)) {
					// Event was not canceled - force processing of modified structure.
					grid.set(structureProperty, grid[structureProperty]);
				}
				else {
					// Event was canceled - revert the structure and re-render the header
					// (since the inherited logic invoked above will have shifted cells).
					setMatchingSubRow(grid, match, oldSubRow);
					grid.renderHeader();
					// After re-rendering the header, re-apply the sort arrow if needed.
					if (grid.sort.length) {
						grid.updateSortArrow(grid.sort);
					}
				}
			}, 0);
		}
	});

	var ColumnReorder = declare('dgrid.ColumnReorder',null,{
		// summary:
		//		Extension allowing reordering of columns in a grid via drag'n'drop.
		//		Reordering of columns within the same subrow or columnset is also
		//		supported; between different ones is not.

		// columnDndConstructor: Function
		//		Constructor to call for instantiating DnD sources within the grid's
		//		header.
		columnDndConstructor: ColumnDndSource,

		_initSubRowDnd: function (subRow, dndType) {
			// summary:
			//		Initializes a dojo/dnd source for one subrow of a grid;
			//		this could be its only subrow, one of several, or a subrow within a
			//		columnset.

			var dndParent, c, len, col, th;

			for (c = 0, len = subRow.length; c < len; c++) {
				col = subRow[c];
				if (col.reorderable === false) {
					continue;
				}

				th = col.headerNode;
				// Add dojoDndItem class, and a dndType unique to this subrow.
				domClass.add(th, 'dojoDndItem');
				th.setAttribute('dndType', dndType);

				if (!dndParent) {
					dndParent = th.parentNode;
				}
			}

			if (dndParent) {
				this._columnDndSources.push(new this.columnDndConstructor(dndParent, {
					horizontal: true,
					grid: this
				}));
			}
			// (If dndParent wasn't set, no columns are draggable)
		},

		renderHeader: function () {
			var dndTypePrefix = makeDndTypePrefix(this.id),
				csLength, cs;

			this.inherited(arguments);

			// After header is rendered, set up a dnd source on each of its subrows.

			this._columnDndSources = [];

			if (this.columnSets) {
				// Iterate columnsets->subrows->columns.
				for (cs = 0, csLength = this.columnSets.length; cs < csLength; cs++) {
					arrayUtil.forEach(this.columnSets[cs], function (subRow, sr) {
						this._initSubRowDnd(subRow, dndTypePrefix + cs + '-' + sr);
					}, this);
				}
			}
			else {
				// Iterate subrows->columns.
				arrayUtil.forEach(this.subRows, function (subRow, sr) {
					this._initSubRowDnd(subRow, dndTypePrefix + sr);
				}, this);
			}
		},

		_destroyColumns: function () {
			if (this._columnDndSources) {
				// Destroy old dnd sources.
				arrayUtil.forEach(this._columnDndSources, function (source) {
					source && source.destroy && source.destroy();
				});
			}
			this.inherited(arguments);
		}
	});

	ColumnReorder.ColumnDndSource = ColumnDndSource;
	return ColumnReorder;
});

},
'dgrid/_StoreMixin':function(){
define([
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/Deferred',
	'dojo/aspect',
	'dojo/dom-construct',
	'dojo/has',
	'dojo/on',
	'dojo/when'
], function (declare, lang, Deferred, aspect, domConstruct, has, on, when) {
	// This module isolates the base logic required by store-aware list/grid
	// components, e.g. OnDemandList/Grid and the Pagination extension.

	function emitError(err) {
		// called by _trackError in context of list/grid, if an error is encountered
		if (typeof err !== 'object') {
			// Ensure we actually have an error object, so we can attach a reference.
			err = new Error(err);
		}
		else if (err.dojoType === 'cancel') {
			// Don't fire dgrid-error events for errors due to canceled requests
			// (unfortunately, the Deferred instrumentation will still log them)
			return;
		}

		var event = on.emit(this.domNode, 'dgrid-error', {
			grid: this,
			error: err,
			cancelable: true,
			bubbles: true
		});
		if (event) {
			console.error(err);
		}
	}

	return declare(null, {
		// collection: Object
		//		The base object collection (implementing the dstore/api/Store API) before being sorted
		//		or otherwise processed by the grid. Use it for general purpose store operations such as
		//		`getIdentity` and `get`, `add`, `put`, and `remove`.
		collection: null,

		// _renderedCollection: Object
		//		The object collection from which data is to be fetched. This is the sorted collection.
		//		Use it when retrieving data to be rendered by the grid.
		_renderedCollection: null,

		// _rows: Array
		//		Sparse array of row nodes, used to maintain the grid in response to events from a tracked collection.
		//		Each node's index corresponds to the index of its data object in the collection.
		_rows: null,

		// _observerHandle: Object
		//		The observer handle for the current collection, if trackable.
		_observerHandle: null,

		// shouldTrackCollection: Boolean
		//		Whether this instance should track any trackable collection it is passed.
		shouldTrackCollection: false,

		// getBeforePut: boolean
		//		If true, a get request will be performed to the store before each put
		//		as a baseline when saving; otherwise, existing row data will be used.
		getBeforePut: true,

		// noDataMessage: String
		//		Message to be displayed when no results exist for a collection, whether at
		//		the time of the initial query or upon subsequent observed changes.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		noDataMessage: '',

		// loadingMessage: String
		//		Message displayed when data is loading.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		loadingMessage: '',

		_total: 0,

		constructor: function () {
			// Create empty objects on each instance, not the prototype
			this.dirty = {};
			this._updating = {}; // Tracks rows that are mid-update
			this._columnsWithSet = {};

			// Reset _columnsWithSet whenever column configuration is reset
			aspect.before(this, 'configStructure', lang.hitch(this, function () {
				this._columnsWithSet = {};
			}));
		},

		destroy: function () {
			this.inherited(arguments);

			if (this._renderedCollection) {
				this._cleanupCollection();
			}
		},

		_configColumn: function (column) {
			// summary:
			//		Implements extension point provided by Grid to store references to
			//		any columns with `set` methods, for use during `save`.
			if (column.set) {
				this._columnsWithSet[column.field] = column;
			}
			this.inherited(arguments);
		},

		_setCollection: function (collection) {
			// summary:
			//		Assigns a new collection to the list/grid, sets up tracking
			//		if applicable, and tells the list/grid to refresh.

			if (this._renderedCollection) {
				this.cleanup();
				this._cleanupCollection({
					// Only clear the dirty hash if the collection being used is actually from a different store
					// (i.e. not just a re-sorted / re-filtered version of the same store)
					shouldRevert: !collection || collection.storage !== this._renderedCollection.storage
				});
			}

			this.collection = collection;

			// Avoid unnecessary rendering and processing before the grid has started up
			if (this._started) {
				// Once startup is called, List.startup sets the sort property which calls _StoreMixin._applySort
				// which sets the collection property again.  So _StoreMixin._applySort will be executed again
				// after startup is called.
				if (collection) {
					var renderedCollection = collection;
					if (this.sort && this.sort.length > 0) {
						renderedCollection = collection.sort(this.sort);
					}

					if (renderedCollection.track && this.shouldTrackCollection) {
						renderedCollection = renderedCollection.track();
						this._rows = [];

						this._observerHandle = this._observeCollection(
							renderedCollection,
							this.contentNode,
							{ rows: this._rows }
						);
					}

					this._renderedCollection = renderedCollection;
				}
				this.refresh();
			}
		},

		_setStore: function () {
			if (!this.collection) {
				console.debug('set(\'store\') call detected, but you probably meant set(\'collection\')');
			}
		},

		_getTotal: function () {
			// summary:
			//		Retrieves the currently-tracked total (as updated by
			//		subclasses after store queries, or by _StoreMixin in response to
			//		updated totalLength in events)

			return this._total;
		},

		_cleanupCollection: function (options) {
			// summary:
			//		Handles cleanup duty for the previous collection;
			//		called during _setCollection and destroy.
			// options: Object?
			//		* shouldRevert: Whether to clear the dirty hash

			options = options || {};

			if (this._renderedCollection.tracking) {
				this._renderedCollection.tracking.remove();
			}

			// Remove observer and existing rows so any sub-row observers will be cleaned up
			if (this._observerHandle) {
				this._observerHandle.remove();
				this._observerHandle = this._rows = null;
			}

			// Discard dirty map, as it applied to a previous collection
			if (options.shouldRevert !== false) {
				this.dirty = {};
			}

			this._renderedCollection = this.collection = null;
		},

		_applySort: function () {
			if (this.collection) {
				this.set('collection', this.collection);
			}
		},

		row: function () {
			// Extend List#row with more appropriate lookup-by-id logic
			var row = this.inherited(arguments);
			if (row && row.data && typeof row.id !== 'undefined') {

				if(this.collection) {
					row.id = this.collection.getIdentity(row.data);
				}else{
					console.error('_StoreMixin:have no collection!');
				}

			}
			return row;
		},

		refresh: function () {
			var result = this.inherited(arguments);

			if (!this.collection) {
				
				this.noDataNode = domConstruct.create('div', {
					className: 'dgrid-no-data',
					innerHTML: this.noDataMessage
				}, this.contentNode);
				
				this._emit('noData');
			}
			//{"values":[{"key":"Marantz-Power","value":"%%PowerState%%"}]}
			return result;
		},

		refreshCell: function (cell) {
			/*
			 this.inherited(arguments);
			 var row = cell.row;
			 var self = this;
			 */
			if (!this.collection || !this._createBodyRowCell) {
				//throw new Error('refreshCell requires a Grid with a collection.');
				return false;
			}

			if(!cell.column){
				return;
			}
			if (cell.column && cell.column.selector) {
				return (new Deferred()).resolve();
			}
			this.inherited(arguments);
			return this.collection.get(cell.row.id).then(lang.hitch(this, '_refreshCellFromItem', cell));

/*
			return this.collection.get(row.id).then(function (item) {

				var cellElement = cell.element;

				if(cellElement) {

					if (cellElement.widget) {
						cellElement.widget.destroyRecursive();
					}
					domConstruct.empty(cellElement);

					var dirtyItem = self.dirty && self.dirty[row.id];
					if (dirtyItem) {
						item = lang.delegate(item, dirtyItem);
					}

					self._createBodyRowCell(cellElement, cell.column, item);
				}
			});
			*/
		},
		_refreshCellFromItem: function (cell, item, options) {
			if(!cell || !cell.element){
				return;
			}
			var cellElement = cell.element;
			if (cellElement.widget) {
				cellElement.widget.destroyRecursive();
			}
			domConstruct.empty(cellElement);

			var dirtyItem = this.dirty && this.dirty[cell.row.id];
			if (dirtyItem) {
				item = lang.delegate(item, dirtyItem);
			}

			this._createBodyRowCell(cellElement, cell.column, item, options);
		},
		renderArray: function () {
			var rows = this.inherited(arguments);

			if (!this.collection) {
				if (rows.length && this.noDataNode) {
					domConstruct.destroy(this.noDataNode);
				}
			}
			return rows;
		},

		insertRow: function (object, parent, beforeNode, i, options) {
			var store = this.collection,
				dirty = this.dirty,
				id = store && store.getIdentity(object),
				dirtyObj,
				row;

			if (id in dirty && !(id in this._updating)) {
				dirtyObj = dirty[id];
			}
			if (dirtyObj) {
				// restore dirty object as delegate on top of original object,
				// to provide protection for subsequent changes as well
				object = lang.delegate(object, dirtyObj);
			}

			row = this.inherited(arguments);

			if (options && options.rows) {
				options.rows[i] = row;
			}

			// Remove no data message when a new row appears.
			// Run after inherited logic to prevent confusion due to noDataNode
			// no longer being present as a sibling.
			if (this.noDataNode) {
				domConstruct.destroy(this.noDataNode);
				this.noDataNode = null;
			}

			return row;
		},

		updateDirty: function (id, field, value) {
			// summary:
			//		Updates dirty data of a field for the item with the specified ID.
			var dirty = this.dirty,
				dirtyObj = dirty[id];

			if (!dirtyObj) {
				dirtyObj = dirty[id] = {};
			}
			dirtyObj[field] = value;
		},

		save: function () {
			// Keep track of the store and puts
			var self = this,
				store = this.collection,
				dirty = this.dirty,
				dfd = new Deferred(),
				results = {},
				getFunc = function (id) {
					// returns a function to pass as a step in the promise chain,
					// with the id variable closured
					var data;
					return (self.getBeforePut || !(data = self.row(id).data)) ?
						function () {
							return store.get(id);
						} :
						function () {
							return data;
						};
				};

			// function called within loop to generate a function for putting an item
			function putter(id, dirtyObj) {
				// Return a function handler
				return function (object) {
					var colsWithSet = self._columnsWithSet,
						updating = self._updating,
						key, data;

					if (typeof object.set === 'function') {
						object.set(dirtyObj);
					} else {
						// Copy dirty props to the original, applying setters if applicable
						for (key in dirtyObj) {
							object[key] = dirtyObj[key];
						}
					}

					// Apply any set methods in column definitions.
					// Note that while in the most common cases column.set is intended
					// to return transformed data for the key in question, it is also
					// possible to directly modify the object to be saved.
					for (key in colsWithSet) {
						data = colsWithSet[key].set(object);
						if (data !== undefined) {
							object[key] = data;
						}
					}

					updating[id] = true;
					// Put it in the store, returning the result/promise
					return store.put(object).then(function (result) {
						// Clear the item now that it's been confirmed updated
						delete dirty[id];
						delete updating[id];
						results[id] = result;
						return results;
					});
				};
			}

			var promise = dfd.then(function () {
				// Ensure empty object is returned even if nothing was dirty, for consistency
				return results;
			});

			// For every dirty item, grab the ID
			for (var id in dirty) {
				// Create put function to handle the saving of the the item
				var put = putter(id, dirty[id]);

				// Add this item onto the promise chain,
				// getting the item from the store first if desired.
				promise = promise.then(getFunc(id)).then(put);
			}

			// Kick off and return the promise representing all applicable get/put ops.
			// If the success callback is fired, all operations succeeded; otherwise,
			// save will stop at the first error it encounters.
			dfd.resolve();
			return promise;
		},

		revert: function () {
			// summary:
			//		Reverts any changes since the previous save.
			this.dirty = {};
			this.refresh();
		},

		_trackError: function (func) {
			// summary:
			//		Utility function to handle emitting of error events.
			// func: Function|String
			//		A function which performs some store operation, or a String identifying
			//		a function to be invoked (sans arguments) hitched against the instance.
			//		If sync, it can return a value, but may throw an error on failure.
			//		If async, it should return a promise, which would fire the error
			//		callback on failure.
			// tags:
			//		protected

			if (typeof func === 'string') {
				func = lang.hitch(this, func);
			}

			var self = this,
				promise;

			try {
				promise = when(func());
			} catch (err) {
				// report sync error
				var dfd = new Deferred();
				dfd.reject(err);
				promise = dfd.promise;
			}

			promise.otherwise(function (err) {
				emitError.call(self, err);
			});
			return promise;
		},

		removeRow: function (rowElement, preserveDom, options) {
			var row = {element: rowElement};
			// Check to see if we are now empty...
			if (!preserveDom && this.noDataMessage &&
					(this.up(row).element === rowElement) &&
					(this.down(row).element === rowElement)) {
				// ...we are empty, so show the no data message.
				this.noDataNode = domConstruct.create('div', {
					className: 'dgrid-no-data',
					innerHTML: this.noDataMessage
				}, this.contentNode);
				this._emit('noData');
			}

			var rows = (options && options.rows) || this._rows;
			if (rows) {
				delete rows[rowElement.rowIndex];
			}

			return this.inherited(arguments);
		},

		renderQueryResults: function (results, beforeNode, options) {
			// summary:
			//		Renders objects from QueryResults as rows, before the given node.

			options = lang.mixin({ rows: this._rows }, options);
			var self = this;

			if (! 1 ) {
				// Check for null/undefined totalResults to help diagnose faulty services/stores
				results.totalLength.then(function (total) {
					if (total == null) {
						console.warn('Store reported null or undefined totalLength. ' +
							'Make sure your store (and service, if applicable) are reporting total correctly!');
					}
				});
			}

			return results.then(function (resolvedResults) {
				var resolvedRows = self.renderArray(resolvedResults, beforeNode, options);
				delete self._lastCollection; // used only for non-store List/Grid
				return resolvedRows;
			});
		},

		_observeCollection: function (collection, container, options) {
			var self = this,
				rows = options.rows,
				row;

			var handles = [
				collection.on('delete, update', function (event) {
					var from = event.previousIndex;
					var to = event.index;

					if (from !== undefined && rows[from]) {
						if ('max' in rows && (to === undefined || to < rows.min || to > rows.max)) {
							rows.max--;
						}

						row = rows[from];

						// check to make the sure the node is still there before we try to remove it
						// (in case it was moved to a different place in the DOM)
						if (row.parentNode === container) {
							self.removeRow(row, false, options);
						}

						// remove the old slot
						rows.splice(from, 1);

						if (event.type === 'delete' ||
								(event.type === 'update' && (from < to || to === undefined))) {
							// adjust the rowIndex so adjustRowIndices has the right starting point
							rows[from] && rows[from].rowIndex--;
						}
					}
					if (event.type === 'delete') {
						// Reset row in case this is later followed by an add;
						// only update events should retain the row variable below
						row = null;
					}
				}),

				collection.on('add, update', function (event) {
					var from = event.previousIndex;
					var to = event.index;
					var nextNode;

					function advanceNext() {
						nextNode = (nextNode.connected || nextNode).nextSibling;
					}

					// When possible, restrict observations to the actually rendered range
					if (to !== undefined && (!('max' in rows) || (to >= rows.min && to <= rows.max))) {
						if ('max' in rows && (from === undefined || from < rows.min || from > rows.max)) {
							rows.max++;
						}
						// Add to new slot (either before an existing row, or at the end)
						// First determine the DOM node that this should be placed before.
						if (rows.length) {
							nextNode = rows[to];
							if (!nextNode) {
								nextNode = rows[to - 1];
								if (nextNode) {
									// Make sure to skip connected nodes, so we don't accidentally
									// insert a row in between a parent and its children.
									advanceNext();
								}
							}
						}
						else {
							// There are no rows.  Allow for subclasses to insert new rows somewhere other than
							// at the end of the parent node.
							nextNode = self._getFirstRowSibling && self._getFirstRowSibling(container);
						}
						// Make sure we don't trip over a stale reference to a
						// node that was removed, or try to place a node before
						// itself (due to overlapped queries)
						if (row && nextNode && row.id === nextNode.id) {
							advanceNext();
						}
						if (nextNode && !nextNode.parentNode) {
							nextNode = document.getElementById(nextNode.id);
						}
						rows.splice(to, 0, undefined);
						row = self.insertRow(event.target, container, nextNode, to, options);
						self.highlightRow(row);
					}
					// Reset row so it doesn't get reused on the next event
					row = null;
				}),

				collection.on('add, delete, update', function (event) {
					var from = (typeof event.previousIndex !== 'undefined') ? event.previousIndex : Infinity,
						to = (typeof event.index !== 'undefined') ? event.index : Infinity,
						adjustAtIndex = Math.min(from, to);
					from !== to && rows[adjustAtIndex] && self.adjustRowIndices(rows[adjustAtIndex]);

					// the removal of rows could cause us to need to page in more items
					if (from !== Infinity && self._processScroll && (rows[from] || rows[from - 1])) {
						self._processScroll();
					}

					// Fire _onNotification, even for out-of-viewport notifications,
					// since some things may still need to update (e.g. Pagination's status/navigation)
					self._onNotification(rows, event, collection);

					// Update _total after _onNotification so that it can potentially
					// decide whether to perform actions based on whether the total changed
					if (collection === self._renderedCollection && 'totalLength' in event) {
						self._total = event.totalLength;
					}
				})
			];

			return {
				remove: function () {
					while (handles.length > 0) {
						handles.pop().remove();
					}
				}
			};
		},

		_onNotification: function () {
			// summary:
			//		Protected method called whenever a store notification is observed.
			//		Intended to be extended as necessary by mixins/extensions.
			// rows: Array
			//		A sparse array of row nodes corresponding to data objects in the collection.
			// event: Object
			//		The notification event
			// collection: Object
			//		The collection that the notification is relevant to.
			//		Useful for distinguishing child-level from top-level notifications.
		}
	});
});

},
'dstore/Trackable':function(){
define([
	'dojo/_base/lang',
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/when',
	'dojo/promise/all',
	'dojo/_base/array',
	'dojo/on'
	/*=====, './api/Store' =====*/
], function (lang, declare, aspect, when, whenAll, arrayUtil, on /*=====, Store =====*/) {

	// module:
	//		dstore/Trackable
	var revision = 0;

	function createRange(newStart, newEnd) {
		return {
			start: newStart,
			count: newEnd - newStart
		};
	}

	function registerRange(ranges, newStart, newEnd) {
		for (var i = ranges.length - 1; i >= 0; --i) {
			var existingRange = ranges[i],
				existingStart = existingRange.start,
				existingEnd = existingStart + existingRange.count;

			if (newStart > existingEnd) {
				// existing range completely precedes new range. we are done.
				ranges.splice(i + 1, 0, createRange(newStart, newEnd));
				return;
			} else if (newEnd >= existingStart) {
				// the ranges overlap and must be merged into a single range
				newStart = Math.min(newStart, existingStart);
				newEnd = Math.max(newEnd, existingEnd);
				ranges.splice(i, 1);
			}
		}

		ranges.unshift(createRange(newStart, newEnd));
	}

	function unregisterRange(ranges, start, end) {
		for (var i = 0, range; (range = ranges[i]); ++i) {
			var existingStart = range.start,
				existingEnd = existingStart + range.count;

			if (start <= existingStart) {
				if (end >= existingEnd) {
					// The existing range is within the forgotten range
					ranges.splice(i, 1);
				} else {
					// The forgotten range overlaps the beginning of the existing range
					range.start = end;
					range.count = existingEnd - range.start;

					// Since the forgotten range ends before the existing range,
					// there are no more ranges to update, and we are done
					return;
				}
			} else if (start < existingEnd) {
				if (end > existingStart) {
					// The forgotten range is within the existing range
					ranges.splice(i, 1, createRange(existingStart, start), createRange(end, existingEnd));

					// We are done because the existing range bounded the forgotten range
					return;
				} else {
					// The forgotten range overlaps the end of the existing range
					range.count = start - range.start;
				}
			}
		}
	}

	var trackablePrototype = {
		track: function () {
			var store = this.store || this;

			// monitor for updates by listening to these methods
			var handles = [];
			var eventTypes = {add: 1, update: 1, 'delete': 1};
			// register to listen for updates
			for (var type in eventTypes) {
				handles.push(
					this.on(type, (function (type) {
						return function (event) {
							notify(type, event);
						};
					})(type))
				);
			}

			function makeFetch() {
				return function () {
					var self = this;
					var fetchResults = this.inherited(arguments);
					when(fetchResults, function (results) {
						results = self._results = results.slice();
						if (self._partialResults) {
							// clean this up, as we don't need this anymore
							self._partialResults = null;
						}
						self._ranges = [];
						registerRange(self._ranges, 0, results.length);
					});
					return fetchResults;
				};
			}
			function makeFetchRange() {
				return function (kwArgs) {
					var self = this,
						start = kwArgs.start,
						end = kwArgs.end,
						fetchResults = this.inherited(arguments);
					// only use this if we don't have all the data
					if (!this._results) {
						when(fetchResults, function (results) {
							return when(results.totalLength, function (totalLength) {
								var partialResults = self._partialResults || (self._partialResults = []);
								end = Math.min(end, start + results.length);

								partialResults.length = totalLength;

								// copy the new ranged data into the parent partial data set
								var spliceArgs = [ start, end - start ].concat(results);
								partialResults.splice.apply(partialResults, spliceArgs);
								registerRange(self._ranges, start, end);

								return results;
							});
						});
					}
					return fetchResults;
				};
			}

			// delegate rather than call _createSubCollection because we are not ultimately creating
			// a new collection, just decorating an existing collection with item index tracking.
			// If we use _createSubCollection, it will return a new collection that may exclude
			// important, defining properties from the tracked collection.
			var observed = declare.safeMixin(lang.delegate(this), {
				_ranges: [],

				fetch: makeFetch(),
				fetchRange: makeFetchRange(),

				releaseRange: function (start, end) {
					if (this._partialResults) {
						unregisterRange(this._ranges, start, end);

						for (var i = start; i < end; ++i) {
							delete this._partialResults[i];
						}
					}
				},

				on: function (type, listener) {
					var self = this,
						inheritedOn = this.getInherited(arguments);
					return on.parse(observed, type, listener, function (target, type) {
						return type in eventTypes ?
							aspect.after(observed, 'on_tracked' + type, listener, true) :
							inheritedOn.call(self, type, listener);
					});
				},

				tracking: {
					remove: function () {
						while (handles.length > 0) {
							handles.pop().remove();
						}

						this.remove = function () {};
					}
				},
				// make sure track isn't called twice
				track: null
			});
			if (this.fetchSync) {
				// only add these if we extending a sync-capable store
				declare.safeMixin(observed, {
					fetchSync: makeFetch(),
					fetchRangeSync: makeFetchRange()
				});

				// we take the presence of fetchSync to indicate that the results can be
				// retrieved cheaply, and then we can just automatically fetch and start
				// tracking results
				observed.fetchSync();
			}

			// Create a function that applies all queriers in the query log
			// in order to determine whether a new or updated item belongs
			// in the results and at what position.
			var queryExecutor;
			arrayUtil.forEach(this.queryLog, function (entry) {
				var existingQuerier = queryExecutor,
					querier = entry.querier;

				if (querier) {
					queryExecutor = existingQuerier
						? function (data) { return querier(existingQuerier(data)); }
						: querier;
				}
			});

			var defaultEventProps = {
					'add': { index: undefined },
					'update': { previousIndex: undefined, index: undefined },
					'delete': { previousIndex: undefined }
				},
				findObject = function (data, id, start, end) {
					start = start !== undefined ? start : 0;
					end = end !== undefined ? end : data.length;
					for (var i = start; i < end; ++i) {
						if (store.getIdentity(data[i]) === id) {
							return i;
						}
					}
					return -1;
				};

			function notify(type, event) {

				revision++;
				var target = event.target;
				event = lang.delegate(event, defaultEventProps[type]);

				when(observed._results || observed._partialResults, function (resultsArray) {
					/* jshint maxcomplexity: 32 */

					function emitEvent() {
						// TODO: Eventually we will want to aggregate all the listener events
						// in an event turn, but we will wait until we have a reliable, performant queueing
						// mechanism for this (besides setTimeout)
						var method = observed['on_tracked' + type];
						method && method.call(observed, event);
					}

					if (!resultsArray) {
						// without data, we have no way to determine the indices effected by the change,
						// so just pass along the event and return.
						emitEvent();
						return;
					}

					var i, j, l, ranges = observed._ranges, range;
					/*if(++queryRevision != revision){
						throw new Error('Query is out of date, you must observe() the' +
						' query prior to any data modifications');
					}*/

					var targetId = 'id' in event ? event.id : store.getIdentity(target);
					var removedFrom = -1,
						removalRangeIndex = -1,
						insertedInto = -1,
						insertionRangeIndex = -1;
					if (type === 'delete' || type === 'update') {
						// remove the old one
						for (i = 0; removedFrom === -1 && i < ranges.length; ++i) {
							range = ranges[i];
							for (j = range.start, l = j + range.count; j < l; ++j) {
								var object = resultsArray[j];
								// often ids can be converted strings (if they are used as keys in objects),
								// so we do a coercive equality check
								/* jshint eqeqeq: false */
								if (store.getIdentity(object) == targetId) {
									removedFrom = event.previousIndex = j;
									removalRangeIndex = i;
									resultsArray.splice(removedFrom, 1);

									range.count--;
									for (j = i + 1; j < ranges.length; ++j) {
										ranges[j].start--;
									}

									break;
								}
							}
						}
					}

					if (type === 'add' || type === 'update') {
						if (queryExecutor) {
							// with a queryExecutor, we can determine the correct sorted index for the change

							if (queryExecutor([target]).length) {
								var begin = 0,
									end = ranges.length - 1,
									sampleArray,
									candidateIndex = -1,
									sortedIndex,
									adjustedIndex;
								while (begin <= end && insertedInto === -1) {
									// doing a binary search for the containing range
									i = begin + Math.round((end - begin) / 2);
									range = ranges[i];

									sampleArray = resultsArray.slice(range.start, range.start + range.count);

									if ('beforeId' in event) {
										candidateIndex = event.beforeId === null
											? sampleArray.length
											: findObject(sampleArray, event.beforeId);
									}

									if (candidateIndex === -1) {
										// If the original index came from this range, put back in the original slot
										// so it doesn't move unless it needs to (relying on a stable sort below)
										if (removedFrom >= Math.max(0, range.start - 1)
											&& removedFrom <= (range.start + range.count)) {
											candidateIndex = removedFrom;
										} else {
											candidateIndex = store.defaultNewToStart ? 0 : sampleArray.length;
										}
									}
									sampleArray.splice(candidateIndex, 0, target);

									sortedIndex = arrayUtil.indexOf(queryExecutor(sampleArray), target);
									adjustedIndex = range.start + sortedIndex;

									if (sortedIndex === 0 && range.start !== 0) {
										end = i - 1;
									} else if (sortedIndex >= (sampleArray.length - 1) &&
											adjustedIndex < resultsArray.length) {
										begin = i + 1;
									} else {
										insertedInto = adjustedIndex;
										insertionRangeIndex = i;
									}
								}
								if (insertedInto === -1 && begin > 0 && begin < ranges.length) {
									var betweenRanges = true;
								}
							}
						} else {
							// we don't have a queryExecutor, so we can't provide any information
							// about where it was inserted or moved to. If it is an update, we leave
							// its position alone. otherwise, we at least indicate a new object

							var range,
								possibleRangeIndex = -1;
							if ('beforeId' in event) {
								if (event.beforeId === null) {
									insertedInto = resultsArray.length;
									possibleRangeIndex = ranges.length - 1;
								} else {
									for (i = 0, l = ranges.length; insertionRangeIndex === -1 && i < l; ++i) {
										range = ranges[i];

										insertedInto = findObject(
											resultsArray,
											event.beforeId,
											range.start,
											range.start + range.count
										);

										if (insertedInto !== -1) {
											insertionRangeIndex = i;
										}
									}
								}
							} else {
								if (type === 'update') {
									insertedInto = removedFrom;
									insertionRangeIndex = removalRangeIndex;
								} else {
									if (store.defaultNewToStart) {
										insertedInto = 0;
										possibleRangeIndex = 0;
									} else {
										// default to the bottom
										insertedInto = resultsArray.length;
										possibleRangeIndex = ranges.length - 1;
									}
								}
							}

							if (possibleRangeIndex !== -1 && insertionRangeIndex === -1) {
								range = ranges[possibleRangeIndex];
								if (range && range.start <= insertedInto
									&& insertedInto <= (range.start + range.count)) {
									insertionRangeIndex = possibleRangeIndex;
								}
							}
						}

						// an item only truly has a known index if it is in a known range
						if (insertedInto > -1 && insertionRangeIndex > -1) {
							event.index = insertedInto;
							resultsArray.splice(insertedInto, 0, target);

							// update the count and start of the appropriate ranges
							ranges[insertionRangeIndex].count++;
							for (i = insertionRangeIndex + 1; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						} else if (betweenRanges) {
							// the begin index will be after the inserted item, and is
							// where we can begin incrementing start values
							event.beforeIndex = ranges[begin].start;
							for (i = begin; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						}
					}
					// update the total
					event.totalLength = resultsArray.length;

					emitEvent();
				});
			}

			return observed;
		}
	};

	var Trackable =  declare(null, trackablePrototype);

	Trackable.create = function (target, properties) {
		// create a delegate of an existing store with trackability functionality mixed in
		target = declare.safeMixin(lang.delegate(target), trackablePrototype);
		declare.safeMixin(target, properties);
		return target;
	};
	return Trackable;
});

},
'xide/action/ActionContext':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    'xide/types',
    'dojo/aspect',
    'xide/views/History'
], function (dcl, declare, types, aspect, History) {

    var _debug = false;
    /**
     * Mixin to handle different action contexts.
     *
     * @mixin module:xide/action/ActionContext
     */
    var Implementation = {
        currentActionEmitter: null,
        _history: null,
        isEmpty: function () {
            var _emitter = this.getCurrentEmitter();
            if (_emitter) {
                return _emitter.getActionStore().getAll().length == 0;
            }
            return true;
        },
        getCurrentEmitter: function () {
            return this.currentActionEmitter;
        },
        _onRemoveEmitter: function (emitter) {
            this._history.remove(emitter);
            var _next = this._history.getNow();
            var cEmitter = this.currentActionEmitter;
            if (cEmitter == emitter) {
                this.currentActionEmitter = null;
            }
            var _last = _next;
            if (_last) {
                this.setActionEmitter(_last);
            }
        },
        refreshActions: function (actions) {
            var _self = this;
            _.each(actions, function (action) {
                if (_self.renderAction) {
                    _self.renderAction(action, null, null, null, null);
                } else {
                    console.error('renderAction not implemented for refresh actions ' + _self.declaredClass);
                }
            });
        },
        setActionEmitter: function (emitter, what, event) {
            if (emitter && emitter.getActionStore && !emitter.getActionStore()) {
                _debug && console.warn('setActionEmitter: emitter returns null action store! abort ' + emitter.declaredClass, emitter);
                return;
            }
            if (this.currentActionEmitter == emitter) {
                if (!emitter) {
                    this.setActionStore(null);
                } else {

                }
                return;
            }
            _debug && console.log('setActionEmitter ' + this.id + ' ' + this.declaredClass + ' for : ' + what + ' emitter : ' + emitter.id);
            try {
                var cEmitter = this.currentActionEmitter;
                if (cEmitter) {
                    if (cEmitter.getActionStore) {
                        var store = cEmitter.getActionStore();
                        if (store) {
                            store._all = null;
                        } else {
                            _debug && console.warn('setActionEmitter no store');
                        }
                        this.clearActions();
                    } else {
                        _debug && console.warn('setActionEmitter current emitter has no getActionStore', cEmitter);
                    }
                    cEmitter && cEmitter.onDeactivateActionContext && cEmitter.onDeactivateActionContext(this, event);
                }
            } catch (e) {
                console.warn('setActionEmitter crash', e);
                logError(e);
            }
            if (emitter && !emitter.getActionStore) {
                _debug && console.error('not an action emitter ' + emitter.declaredClass);
                return;
            }
            this.currentActionEmitter = emitter;
            if (!emitter) {
                this.setActionStore(null);
                return;
            }
            var newEmitterStore = emitter.getActionStore();
            if (!newEmitterStore) {
                _debug && console.error('new emitter has no action store ! ' + emitter.declaredClass);
                return;
            }

            newEmitterStore.__all = null;
            this.setActionStore(newEmitterStore, emitter);
            newEmitterStore.addRenderer(this);
            emitter && emitter.onActivateActionContext && emitter.onActivateActionContext(this, event);
            this._emit('setActionEmitter', {
                emitter: emitter
            });
            !this._history && (this._history = new History());
            this._history.setNow(emitter);
        },
        _registerActionEmitter: function (emitter) {
            if (emitter && !emitter.getActionStore) {
                _debug && console.error('_registerActionEmitter: is not an action provider');
                return;
            }
            if (!emitter || !emitter.on) {
                _debug && console.warn('register action emitter : emitter = null');
                return false;
            }
            var thiz = this,
                handler = function (what, e) {
                    thiz.setActionEmitter(emitter, what, e);
                },
                _handle = emitter._on('selectionChanged', function (e) {
                    e[thiz.id + '_aceDid'] = true;
                    var type = e.why == 'clear' ? 'selectionCleared' : 'selectionChanged';
                    handler(type, e);
                });


            emitter.on('click', function (e) {
                var doHandler = true;
                if (emitter.handleActionClick) {
                    doHandler = emitter.handleActionClick(e);
                }
                doHandler && handler('click', e);
            });
            !this._history && (this._history = new History());
            emitter._on(types.EVENTS.ON_VIEW_SHOW, function (view) {
                if (thiz._history.indexOf(view)) {
                    view.view && (view = view.view);
                    thiz.setActionEmitter(view, types.EVENTS.ON_VIEW_SHOW, view);
                }
            });
        },
        destroy: function () {
            this.inherited && this.inherited(arguments);
            this._history && this._history.destroy() && delete this._history;
        },
        addActionEmitter: function (emitter) {
            if (!emitter) {
                _debug && console.warn('addActionEmitter::emitter is null');
                return;
            }
            var thiz = this;

            !this._history && (this._history = new History());
            if (!emitter.getActionStore) {
                _debug && console.error('invalid emitter ', emitter);
                return;
            }

            this._history.push(emitter);
            thiz._registerActionEmitter(emitter);
            function remove(emitter) {
                thiz._onRemoveEmitter(emitter);
            }

            aspect.after(emitter, 'destroy', function () {
                remove(emitter);
            }, true);

            emitter._on(emitter, 'destroy', function () {
                try {
                    remove(emitter);
                } catch (e) {
                    logError(e, 'addActionEmitter');
                }
            }, true);
        }
    };
    //package via declare
    var Module = declare('xide/action/ActionContext', null, Implementation);
    //package via dcl
    Module.dcl = dcl(null, Implementation);

    return Module;
});
},
'xfile/views/FileConsole':function(){
/** @module xgrid/Base **/
define([
    "xdojo/declare",
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/PersistenceMixin",
    'xide/layout/_TabContainer',
    'xide/views/_Console',
    'xide/views/_ConsoleWidget',
    "xfile/views/FileSize",
    'xide/views/ConsoleView',
    'xide/lodash',
    'xace/views/Editor'
], function (declare, dcl, types,
             utils, PersistenceMixin, _TabContainer, Console, ConsoleWidget, FileSize, ConsoleView, _, Editor) {

    function createConsoleAceWidgetClass() {
        return dcl([ConsoleWidget, PersistenceMixin.dcl], {
            createEditor: function (ctx) {
                return createEditor(this.consoleParent, this.value, this, {
                    options: this.options,
                    ctx: ctx
                });
            }
        });
    }

    function createEditor(root, value, owner, mixin) {
        var item = {
            filePath: '',
            fileName: ''
        };
        var title = "No Title";
        var args = {
            _permissions: [],
            item: item,
            value: value,
            style: 'padding:0px;top:0 !important',
            iconClass: 'fa-code',
            options: utils.mixin(mixin, {
                filePath: item.path,
                fileName: item.name
            }),
            /***
             * Provide a text editor store delegate
             */
            storeDelegate: {},
            title: title
        };
        utils.mixin(args, mixin);
        var editor = utils.addWidget(Editor, args, owner, root, true, null, null, false);
        editor.resize();
        return editor;
    }

    function createShellViewDelegate() {
        return dcl(null, {
            owner: null,
            onServerResponse: function (theConsole, data, addTimes) {

                if (theConsole && data && theConsole.owner && theConsole.owner.onServerResponse) {
                    return theConsole.owner.onServerResponse(data, addTimes);
                }
            },
            runBash: function (theConsole, value, cwd, commandNode) {
                var thiz = this,
                    ctx = thiz.ctx;
                var server = ctx.fileManager;
                var _value = server.serviceObject.base64_encode(value);
                server.runDeferred('XShell', 'run', ['sh', _value, cwd]).then(function (response) {
                    if (commandNode) {
                        $(commandNode).find('.consoleRunningCommand').remove();
                    }
                    thiz.onServerResponse(theConsole, response, false);
                });
            },

            runPHP: function (theConsole, value, cwd) {
                var thiz = this,
                    ctx = thiz.ctx;
                var server = ctx.fileManager;
                var _value = server.serviceObject.base64_encode(value);
                server.runDeferred('XShell', 'run', ['php', _value, cwd]).then(function (response) {
                    thiz.onServerResponse(theConsole, response, false);
                });
            },
            runJavascript: function (theConsole, value, context, args) {
                var _function = new Function("{" + value + "; }");
                var response = _function.call(context, args);
                if (response != null) {
                    this.onServerResponse(theConsole, response);
                    return response;
                }
                return value;
            },
            onConsoleCommand: function (data, value) {
                var thiz = this,
                    theConsole = data.console;
                if (theConsole.type === 'sh') {
                    var commandNode = thiz.onServerResponse(theConsole, "<span class='consoleRunningCommand fa-spinner fa-spin'></span><pre style='font-weight: bold'># " + value + "</pre>", true);
                    var dstPath = null;
                    if (this.owner && this.owner.getCurrentFolder) {
                        var cwd = this.owner.getCurrentFolder();
                        if (cwd) {
                            dstPath = utils.buildPath(cwd.mount, cwd.path, false);
                        }
                    }
                    return this.runBash(theConsole, value, dstPath, commandNode);
                }
                if (theConsole.type === 'php') {
                    var dstPath = null;
                    if (theConsole.isLinked()) {
                        dstPath = this.getCurrentPath();
                    }
                    return this.runPHP(theConsole, value, dstPath);
                }

                if (theConsole.type === 'javascript') {
                    return this.runJavascript(theConsole, value);
                }
            },
            onConsoleEnter: function (data, input) {
                return this.onConsoleCommand(data, input);
            }
        });
    }

    function createShellViewClass() {
        return dcl(Console, {
            lazy: true,
            consoleClass: createConsoleAceWidgetClass(),
            getServer: function () {
                return this.server || this.ctx.fileManager;
            },
            log: function (msg, addTimes) {
                utils.destroy(this.progressItem);
                var out = '',
                    isHTML = false;
                if (_.isString(msg)) {

                    if (msg.indexOf('<body') != -1 || /<[a-z][\s\S]*>/i.test(msg)) {
                        isHTML = true;
                        out = msg;
                    } else {
                        out += msg.replace(/\n/g, '<br/>');
                    }

                } else if (_.isObject(msg) || _.isArray(msg)) {
                    out += JSON.stringify(msg, null, true);
                } else if (_.isNumber(msg)) {
                    out += msg + '';
                }

                var dst = this.getLoggingContainer();
                var items = out.split('<br/>');
                var last = null;
                var lastMessageNode = null;
                var thiz = this;
                if (isHTML) {
                    lastMessageNode = dojo.create("div", {
                        className: 'html_response',
                        innerHTML: out
                    });
                    dst.appendChild(lastMessageNode);
                    last = dst.appendChild(dojo.create("div", {
                        innerHTML: '&nbsp;',
                        style: 'height:1px;font-size:1px'
                    }));
                } else {

                    for (var i = 0; i < items.length; i++) {
                        var _class = 'logEntry' + (this.lastIndex % 2 === 1 ? 'row-odd' : 'row-even');
                        var item = items[i];
                        if (!item || !item.length) {
                            continue;
                        }
                        last = dst.appendChild(dojo.create("div", {
                            className: _class,
                            innerHTML: this._toString(items[i], addTimes)

                        }));
                        this.lastIndex++;
                    }
                }
                if (last) {
                    last.scrollIntoViewIfNeeded();
                }
                return lastMessageNode;
            }
        });
    }

    function createShellViewClass2() {
        var EditorClass = dcl(ConsoleView.Editor, {
            didAddMCompleter: false,
            multiFileCompleter: null,
            blockScope: null,
            driverInstance: null,
            onACEReady: function (editor) {
            },
            onEditorCreated: function (editor, options) {
                this.inherited(arguments);
                this.onACEReady(editor);
            }
        });
        return dcl(ConsoleView, {
            EditorClass: EditorClass,
            onAddEditorActions: dcl.superCall(function (sup) {
                return function (evt) {
                    //grab the result from the handler

                    var res = sup.call(this, evt);


                    var thiz = this;

                    var actions = evt.actions,
                        owner = evt.owner;

                    var save = _.find(actions, {
                        command: 'File/Save'
                    });

                    actions.remove(_.find(actions, {
                        command: 'File/Save'
                    }));

                    actions.remove(_.find(actions, {
                        command: "File/Reload"
                    }));


                    var mixin = {
                        addPermission: true
                    }


                };
            }),
            logTemplate: '<pre style="font-size:100%;padding: 0px;" class="">    ${time} - ${result}</pre>',
            _parse: function (scope, expression, errorCB) {
                var str = '' + expression;
                if (str.indexOf('{{') > 0 || str.indexOf('}}') > 0) {
                    str = _parser.parse(types.EXPRESSION_PARSER.FILTREX,
                        str, this,
                        {
                            variables: scope.getVariablesAsObject(),
                            delimiters: {
                                begin: '{{',
                                end: '}}'
                            }
                        }
                    );
                    console.timeEnd('parse expression');
                } else {
                    var _text = scope.parseExpression(expression, null, null, null, errorCB);
                    if (_text) {
                        str = _text;
                    }
                }
                return str;
            },
            parse: function (str, errorCB) {
                var driverInstance = this.driverInstance;
                if (driverInstance && driverInstance.blockScope) {
                    return this._parse(driverInstance.blockScope, str, errorCB);
                }
                return str;
            }
        });
    }

    var Module = declare("xfile.views.FileConsole", null, {
        isStatusbarOpen: false,
        resizeToParent: true,
        __bottomTabContainer: null,
        onCloseStatusPanel: function (e) {
        },
        onOpenStatusPanel: function (panel) {
            if (!panel._tabs) {
                var thiz = this;
                var tabContainer = this.__bottomTabContainer || utils.addWidget(_TabContainer, {
                        direction: 'below'
                    }, null, panel, true);

                panel._tabs = tabContainer;
                this.__bottomTabContainer = tabContainer;
                var consoleViewClass = createShellViewClass2(),
                    handlerClass = createShellViewDelegate(),
                    delegate = new handlerClass();

                delegate.ctx = thiz.ctx;

                delegate.owner = this;
                var tab = tabContainer.createTab('Bash', 'fa-terminal'),
                    bashShell = tab.add(consoleViewClass, {
                        type: 'sh',
                        title: 'Bash',
                        icon: 'fa-terminal',
                        ctx: thiz.ctx,
                        owner: thiz,
                        value: 'ls -l --color=always'
                    }, null, true);

                bashShell.delegate = delegate;
                tab._onShown();
                var tab2 = tabContainer.createTab('Javascript', 'fa-code');
                var jsShell = tab2.add(consoleViewClass, {
                    type: 'javascript',
                    title: 'Javascript',
                    ctx: thiz.ctx,
                    value: 'return 2+2;',
                    owner: thiz
                }, null, false);
                jsShell.delegate = delegate;
                var tab3 = tabContainer.createTab('PHP', 'fa-terminal');
                var jsShell = tab3.add(consoleViewClass, {
                    type: 'php',
                    title: 'PHP',
                    ctx: thiz.ctx,
                    value: '<?php \n\n>',
                    owner: thiz
                }, null, false);
                var tab4 = tabContainer.createTab('Sizes', 'fa-bar-chart');
                var fileSize = tab4.add(FileSize, {
                    owner: this,
                    ctx: thiz.ctx
                }, null, false);
                this.__fileSize = fileSize;
                this._on('openedFolder', function (data) {
                    utils.destroy(thiz.__fileSize);
                    tab4.resize();
                    thiz.resize();
                    thiz.__fileSize = null;
                    thiz.__fileSize = tab4.add(FileSize, {
                        owner: thiz,
                        ctx: thiz.ctx
                    }, null, false);
                    utils.resizeTo(thiz.__fileSize, tab4, true, true);
                    thiz.__fileSize.startup();
                });

                panel.add(tabContainer, null, false);

            }
            return this.inherited(arguments);
        },
        onStatusbarCollapse: function (collapser) {
            var panel = null;
            if (this.isStatusbarOpen) {
                panel = this.getBottomPanel(false, 0.2);
                panel.collapse();
                this.onCloseStatusPanel(collapser);
                collapser && collapser.removeClass('fa-caret-down');
                collapser && collapser.addClass('fa-caret-up');
            } else {
                panel = this._getBottom();
                if (!panel) {
                    panel = this.getBottomPanel(false, 0.2);
                } else {
                    panel.expand();
                }
                this.onOpenStatusPanel(panel);

                collapser && collapser.removeClass('fa-caret-up');
                collapser && collapser.addClass('fa-caret-down');
            }
            this.isStatusbarOpen = !this.isStatusbarOpen;
            panel.resize();
        }
    });
    Module.createEditor = createEditor;
    Module.createShellViewDelegate = createShellViewDelegate;
    return Module;
});
},
'xide/views/_ConsoleWidget':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/utils',
    "xide/_base/_Widget",
    'xide/views/History',
    'xide/mixins/PersistenceMixin'
], function (dcl, utils, _Widget, History, PersistenceMixin) {

    var Module = dcl([_Widget, PersistenceMixin.dcl], {

        declaredClass: "xide.views._ConsoleWidget",
        delegate: null,
        value: null,
        editNode: null,
        labelTextNode: null,
        labelNode: null,
        type: null,
        linkToggle: null,
        edit: null,
        consoleParent: null,
        isExpanded: false,
        theme: 'View/Themes/idle_fingers',
        consoleEditor: null,
        jsContext: null,
        //resizeToParent:true,
        templateString: '<div class="consoleWidget">' +
        '<div class="" style="margin:0">' +
        '<div class="input-group border-top-dark">' +
        '<div attachTo="consoleParent" class="form-control input-transparent" style="height: 2em;padding: 0;margin: 0;overflow-y: auto"></div>' +
        '<div class="input-group-btn btn-toolbar">' +
        '<button attachTo="clearButton" type="button" class="btn btn-danger btn-sm"><i class="fa fa-remove"></i></button>' +
        '<button attachTo="expandButton" type="button" class="btn btn-danger btn-sm"><i class="fa fa-expand"></i></button>' +
        '<button type="button" class="btn btn-danger btn-sm" style="bottom:0"><i class="fa fa-link"></i></button>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>',
        isLinked: function () {
            if (this.linkToggle) {
                return this.linkToggle.get('checked');
            }
            return false;
        },
        getEditor: function () {
            return this.consoleEditor;
        },
        resize: function () {
            this.inherited(arguments);

            if (this.isExpanded) {
                var total = $(this.domNode.parentNode).height();

                $(this.consoleParent).css({
                    height: total / 2 + 'px'
                });
            }
            this.aceEditor && this.aceEditor.resize();
        },
        onClear:function(){
            this.delegate.onButton();
        },
        maximize:function(){
            if(this.delegate && this.delegate.maximize){
                return this.delegate.maximize();
            }
        },
        expandEditor: function () {
            var thiz = this,
                editor = thiz.getEditor(),
                aceEditor = this.aceEditor;

            if (thiz.isExpanded) {
                $(thiz.consoleParent).css({
                    height: '2em'
                });

                thiz.isExpanded = false;
                editor.renderer.$maxLines = 1;
                editor.renderer.setShowGutter(false);
                editor.renderer.setHighlightGutterLine(false);
                aceEditor.showToolbar(false);
            } else {
                $(thiz.consoleParent).css({
                    height: $(this.domNode.parentNode).height() / 2 + 'px'
                });
                editor.renderer.$maxLines = Infinity;
                thiz.isExpanded = true;
                editor.renderer.setShowGutter(true);
                editor.renderer.setHighlightGutterLine(true);
                utils.resizeTo(editor.renderer.container, thiz.consoleParent, true, true);
                editor.resize();
                aceEditor.resize();
                aceEditor.showToolbar(true);
                var toolbar = aceEditor.getToolbar();
                toolbar && $(toolbar.domNode).css({
                    top: '0%',
                    position: "absolute"
                });
            }

            if (this.delegate && this.delegate.onConsoleExpanded) {
                this.delegate.onConsoleExpanded();
            }

            this.resize();
        },
        createEditor: function () {
            var _thiz = this;
            return createEditor(this.consoleParent, this.value, this, {
                options: this.options,
                ctx:this.ctx
            });
        },
        createWidgets: function () {


            var aceEditor = this.createEditor(this.ctx);


            this.add(aceEditor, null, false);
            this.aceEditor = aceEditor;
            aceEditor.showToolbar(false);

            var editor = aceEditor.getEditor(),
                self = this;


            aceEditor.maximize = function(){
                return self.maximize();
            }


            this.aceEditorEditor = aceEditor;
            this.consoleEditor = editor;

            editor.renderer.$maxLines = 1;
            editor.renderer.setShowGutter(false);
            editor.renderer.setHighlightGutterLine(false);
            editor.$mouseHandler.$focusWaitTimout = 0;
            editor.setOptions({
                enableBasicAutocompletion: true,
                enableLiveAutocompletion: true,
                enableSnippets: true
            });

            aceEditor.setMode(this.delegate.type);
            aceEditor.set('value', this.value);
            aceEditor.runAction(this.theme);
            aceEditor.set('value', this.value);


            $(this.expandButton).click(function (e) {
                return self.expandEditor();
            });

            $(this.clearButton).on('click', function () {

                if (self.delegate && self.delegate.onButton) {
                    self.delegate.onButton();
                }
            });

            this.expandEditor();

            editor.commands.bindKeys({
                "Ctrl-Return": function (cmdLine) {
                    if (self.isExpanded) {
                        editor.focus();
                        self.onEnter(editor.getValue());
                    } else {
                        //editor.insert("\n");
                        editor.focus();
                        self.onEnter(editor.getValue());
                    }

                },
                "Shift-Return": function (cmdLine) {
                    self.onClear();
                },
                "Esc|Shift-Esc": function (cmdLine) {
                    editor.focus();
                },
                "Return": function (cmdLine) {
                    var command = editor.getValue().split(/\s+/);
                    if (self.isExpanded) {
                        editor.insert("\n");
                    } else {
                        editor.focus();
                        self.onEnter(editor.getValue());
                    }
                }
            });
            editor.commands.removeCommands(["find", "gotoline", "findall", "replace", "replaceall"]);
        },
        getValue: function () {
            return this.consoleEditor.getValue();
        },
        startup: function () {
            this.history = new History();
            this.inherited(arguments);
            this.createWidgets();
        },
        onEnter: function (val) {
            this.delegate.onEnter(val, this.isExpanded == false);
            this.history.push(val);
        }
    });
    return Module;

});
},
'xgrid/Renderer':function(){
/** @module xgrid/Renderer **/
define([
    "xdojo/declare",
    'xide/types'
], function (declare,types) {
    var Implementation = {
        _renderIndex: 0,
        _lastRenderedArray: null,
        publishRendering: false,
        _getLabel:function(){return ''},
        activateRenderer:function(renderer){},
        deactivateRenderer:function(renderer){},
        runAction:function(action){},
        /**
         * Placeholder
         */
        delegate: {
            onDidRenderCollection: function () {}
        },
        /**
         * Override render row to enable model side rendering
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {
            if (obj.render) {
                return obj.render(obj, this.inherited);
            }
            return this.inherited(arguments);
        },
        /**
         * Override renderArray in dgrid/List to track the
         * last rendered array
         * @returns {HTMLElement[]}
         */
        renderArray: function () {
            this._lastRenderedArray = this.inherited(arguments);
            this._onDidRenderCollection(arguments);
            return this._lastRenderedArray;
        },
        /**
         * Callback for dgrid/List#refresh promise, used to publish
         * the last rendered collection
         *
         */
        _onDidRenderCollection: function () {
            var info = {
                collection: this._renderedCollection,
                elements: this._lastRenderedArray,
                grid: this
            };
            this._renderIndex++;
        },
        /**
         * Return that this grid has actually rendered anything.
         * @returns {boolean}
         */
        didRender: function () {
            return this._renderIndex >= 0;
        }
    };

    //package via declare
    var _class = declare('xgrid.Renderer',null,Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'xgrid/ColumnHider':function(){
define([
	'xdojo/declare',
    'dojo/has',
    'dgrid/util/misc',
    'xide/types',
    'xide/utils'
], function (declare, has, misc,types,utils) {

    /*
     *	Column Hider plugin for dgrid
     *	Originally contributed by TRT 2011-09-28
     *
     *	A dGrid plugin that attaches a menu to a dgrid, along with a way of opening it,
     *	that will allow you to show and hide columns.  A few caveats:
     *
     *	1. Menu placement is entirely based on CSS definitions.
     *	2. If you want columns initially hidden, you must add "hidden: true" to your
     *		column definition.
     *	3. This implementation does NOT support ColumnSet, and has not been tested
     *		with multi-subrow records.
     *	4. Column show/hide is controlled via straight up HTML checkboxes.  If you
     *		are looking for something more fancy, you'll probably need to use this
     *		definition as a template to write your own plugin.
     *
     */
	return declare('xgrid.ColumnHider',null, {
        columnHiderActionRootCommand:'View/Columns',
		// i18nColumnHider: Object
		//		This object contains all of the internationalized strings for
		//		the ColumnHider extension as key/value pairs.
		i18nColumnHider: {},

		// _columnHiderRules: Object
		//		Hash containing handles returned from addCssRule.
		_columnHiderRules: null,
        _runAction:function(action,update,value){
            if(action && action.command.indexOf(this.columnHiderActionRootCommand)!=-1 ){
                var col = action.column;
                var isHidden = this.isColumnHidden(col.id);
                this.showColumn(col.id,isHidden);
                update!==false && action.set('value', !this.isColumnHidden(col.id));
            }
            return this.inherited(arguments);
        },
        /**
         *
         * @param permissions
         * @param actions
         * @returns {Array}
         */
		getColumnHiderActions:function(permissions,actions){
            var root = this.columnHiderActionRootCommand,
                thiz = this,
                columnActions = [],
                VISIBILITY = types.ACTION_VISIBILITY,
                node = this.domNode;

            actions = actions || [];
            var rootAction = _.find(actions,{
                command:root
            });
            if(!rootAction) {
                columnActions.push(this.createAction({
                    label:'Columns',
                    command:root,
                    icon:'fa-columns',
                    tab:'View',
                    group:'Columns',
                    toggleGroup:thiz.id + 'Columns',
                    onCreate:function(action){
                        action.setVisibility(VISIBILITY.RIBBON,{
                            expand:true
                        }).setVisibility(VISIBILITY.ACTION_TOOLBAR, false);
                    }
                }));
            }
            /**
             *
             * @param col
             * @private
             */
            function _createEntry(col) {

                var id = col.id,
                    label = 'Show ' + ( col.label || col.field || ''),
                    icon = col.icon || 'fa-cogs';

                // Allow cols to opt out of the hider (e.g. for selector column).
                if (col.unhidable) {
                    return;
                }
                var _action = thiz.createAction(label, root + '/' + label , icon, null, 'View', 'Columns', 'item|view',

                    //oncreate
                    function(action){

                        var widgetImplementation = {
                            postMixInProperties: function() {
                                this.inherited(arguments);
                                this.checked = this.item.get('value') === true;
                            },
                            startup:function(){
                                this.inherited(arguments);
                                this.on('change',function(val){
                                    thiz.showColumn(id,val);
                                });
                            }
                        };
                        var widgetArgs  ={
                            checked:!col.hidden,
                            iconClass:icon,
                            style:'float:inherit;'
                        };


                        var _visibilityMixin = {
                            //widgetClass:declare.classFactory('_Checked', [CheckedMenuItem,_ActionValueWidgetMixin], null, widgetImplementation ,null),
                            widgetArgs:widgetArgs,
                            actionType : 'multiToggle'
                        };

                        action.actionType = 'multiToggle';


                        action.setVisibility(types.ACTION_VISIBILITY_ALL,utils.cloneKeys(_visibilityMixin,false));

                        label = action.label.replace('Show ','');


                        //for ribbons we collapse into 'Checkboxes'
                        /*
                        action.setVisibility(VISIBILITY.RIBBON,{
                            widgetClass:declare.classFactory('_CheckedGroup', [ActionValueWidget], null,{
                                iconClass:"",
                                postMixInProperties: function() {
                                    this.inherited(arguments);
                                    this.checked = this.item.get('value') == true;
                                },
                                startup:function(){
                                    this.inherited(arguments);
                                    this.widget.on('change', function (val) {
                                        thiz.showColumn(id,val);
                                    }.bind(this));
                                }
                            } ,null),
                            widgetArgs:{
                                renderer:CheckBox,
                                checked:!col.hidden,
                                label:action.label.replace('Show ','')
                            }
                        });
                        */

                    }, /*handler*/ null ,
                    {
                        column:col,
                        filterGroup:"item|view",
                        tab:'View',
                        value:!col.hidden,
                        addPermission:true
                    },
                    null, null, permissions, node,thiz,thiz);

                if(_action){
                    columnActions.push(_action);
                }

                /**

                columnActions.push(_ActionMixin.createActionParameters(label, root + '/' + label, 'Columns', icon, function () {
                    console.log('handler');

                }, '', null, null, thiz, thiz, {
                    column:col,
                    filterGroup:"item|view",
                    tab:'View',
                    value:!col.hidden,
                    onCreate:function(action){

                        var _action = this;

                        action.owner = thiz;

                        var widgetImplementation = {
                            postMixInProperties: function() {
                                this.inherited(arguments);
                                this.checked = this.item.get('value') == true;
                            },
                            startup:function(){
                                this.inherited(arguments);
                                this.on('change',function(val){
                                    thiz.showColumn(id,val);
                                })
                            },
                            destroy:function(){

                                this.inherited(arguments);
                            }
                        };
                        var widgetArgs  ={
                            checked:!col.hidden,
                            iconClass:icon,
                            style:'float:inherit;'
                        };

                        var _visibilityMixin = {
                            widgetClass:declare.classFactory('_Checked', [CheckedMenuItem,_ActionValueWidgetMixin], null, widgetImplementation ,null),
                            widgetArgs:widgetArgs
                        };

                        action.setVisibility(types.ACTION_VISIBILITY_ALL,_visibilityMixin);

                        label = action.label.replace('Show ','');


                        //for ribbons we collapse into 'Checkboxes'
                        action.setVisibility(VISIBILITY.RIBBON,{
                            widgetClass:declare.classFactory('_CheckedGroup', [ActionValueWidget], null,{
                                iconClass:"",
                                postMixInProperties: function() {
                                    this.inherited(arguments);
                                    this.checked = this.item.get('value') == true;
                                },
                                startup:function(){
                                    this.inherited(arguments);
                                    this.widget.on('change', function (val) {
                                        thiz.showColumn(id,val);
                                    }.bind(this));
                                }
                            } ,null),
                            widgetArgs:{
                                renderer:CheckBox,
                                checked:!col.hidden,
                                label:action.label.replace('Show ','')
                            }
                        });

                    }
                }));

                */

            }
            var subRows = this.subRows,
                first = true,
                srLength, cLength, sr, c;
            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {
                    _createEntry(subRows[sr][c]);
                    if (first) {
                        first = false;
                    }
                }
            }
            return columnActions;

        },
        resize:function(){
            this.inherited(arguments);
            this._checkHiddenColumns();
        },
        _checkHiddenColumns:function(){
            var subRows = this.subRows,
                srLength, cLength, sr, c,
                totalWidth = $(this.domNode).width();

            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {
                    var col = subRows[sr][c];
                    if(col.minWidth){
                        if(totalWidth < col.minWidth){
                            if(!col.unhidable) {
                                this.showColumn(col.id,false);
                            }
                        }else{
                            this.showColumn(col.id,true);
                        }
                    }
                }
            }
        },
        startup:function(){
            if(this._started){
                return;
            }

            this._columnHiderCheckboxes = {};
            this._columnHiderRules = {};
            var res = this.inherited(arguments);
            this._checkHiddenColumns();
            var subRows = this.subRows,
                srLength, cLength, sr, c,
                thiz = this;

            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {

                    var col = subRows[sr][c],
                        id = col.id;

                    if (col.hidden===true) {
                        // Hide the column (reset first to avoid short-circuiting logic)
                        col.hidden = false;
                        thiz._hideColumn(id);
                        col.hidden = true;
                    }
                }
            }
            if(this.getActionStore){
                this.getActionStore().on('update',function(evt){
                    var action = evt.target;
                    if(action.command.indexOf('View/Columns')!==-1){
                        var col = action.column;
                        thiz.showColumn(col.id,action.get('value'));
                        thiz.onAfterAction(action);

                    }
                });
            }
            return res;

        },
		left: function (cell, steps) {
			return this.right(cell, -steps);
		},
		right: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			var nextCell = this.inherited(arguments),
				prevCell = cell;

			// Skip over hidden cells
			while (nextCell.column.hidden) {
				nextCell = this.inherited(arguments, [nextCell, steps > 0 ? 1 : -1]);
				if (prevCell.element === nextCell.element) {
					// No further visible cell found - return original
					return cell;
				}
				prevCell = nextCell;
			}
			return nextCell;
		},
		isColumnHidden: function (id) {
			// summary:
			//		Convenience method to determine current hidden state of a column
			return !!this._columnHiderRules[id];
		},
		_hideColumn: function (id) {
			// summary:
			//		Hides the column indicated by the given id.

			// Use misc function directly, since we clean these up ourselves anyway
			var grid = this,
                domId = this.template ? this.template.id : this.domNode.id,
                selectorPrefix = '#' + misc.escapeCssIdentifier(domId) + ' .dgrid-column-',
				tableRule; // used in IE8 code path

			if (this._columnHiderRules[id]) {
				return;
			}

			this._columnHiderRules[id] = misc.addCssRule(selectorPrefix + misc.escapeCssIdentifier(id, '-'), 'display: none;');
            
			if (has('ie') === 8 || has('ie') === 10) {
				// Work around IE8 display issue and IE10 issue where
				// header/body cells get out of sync when ColumnResizer is also used
				tableRule = misc.addCssRule('.dgrid-row-table', 'display: inline-table;');
				window.setTimeout(function () {
					tableRule.remove();
					grid.resize();
				}, 0);
			}
		},
		_showColumn: function (id) {
			// summary:
			//		Shows the column indicated by the given id
			//		(by removing the rule responsible for hiding it).

			if (this._columnHiderRules[id]) {
				this._columnHiderRules[id].remove();
				delete this._columnHiderRules[id];
			}
		},
        showColumn:function(id,show){
            if(this.isColumnHidden(id)){
                if(show) {
                    this._showColumn(id);
                }
            }else if(!show){
                this._hideColumn(id);
            }
        }
	});
});

},
'dojo/request':function(){
define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'xfile/Statusbar':function(){
/** @module xfile/Statusbar **/
define([
    "xdojo/declare",
    'xide/types',
    'xfile/Breadcrumb'
], function (declare, types, Breadcrumb) {

    //package via declare
    var _class = declare('xgrid.Statusbar', null, {
        statusbar: null,
        setState: function (state) {
            this.showStatusbar(state.statusBar);
            return this.inherited(arguments);
        },
        getState: function (state) {
            state = this.inherited(arguments) || {};
            state.statusBar = this.statusbar != null;
            return state;
        },
        runAction: function (action) {
            if (action.command == types.ACTION.STATUSBAR) {
                this.showStatusbar(this.statusbar ? false : true);
            }
            return this.inherited(arguments);
        },
        showStatusbar: function (show,priorityChange) {

            if (!show && this.statusbar) {
                this._destroyStatusbar();
            } else if (show) {
                this.getStatusbar();
            }

            this.resize();

            if(this._statusbarAction && priorityChange!==true){
                this._statusbarAction.set('value',show);
            }

        },
        _destroyStatusbar: function () {

            this.statusbarRoot && this.statusbarRoot.remove();
            this.statusbar = null;
            this.statusbarRoot = null;
        },
        _statusbarAction:null,
        buildRendering: function () {

            this.inherited(arguments);

            var self = this,
                node = this.domNode;

            this._on('onAddActions', function (evt) {

                var actions = evt.actions,
                    permissions = evt.permissions,
                    action = types.ACTION.STATUSBAR;

                if (!evt.store.getSync(action)) {

                    var _action = self.createAction({
                        label: 'Statusbar',
                        command: action,
                        icon: types.ACTION_ICON.STATUSBAR,
                        tab: 'View',
                        group: 'Show',
                        mixin:{
                            actionType:'multiToggle'
                        },
                        onCreate:function(action){
                            action.set('value',self.statusbar!==null);
                            self._statusbarAction = action;
                        },
                        onChange:function(property,value,action){
                            self.showStatusbar(value,true);

                        }
                    });

                    actions.push(_action);


                    /*
                    var _action = grid.createAction('Statusbar', action,
                        types.ACTION_ICON.STATUSBAR, null, 'View', 'Show', 'item|view', null,
                        null, null, null, null, permissions, node, grid);
                    if (!_action) {

                        return;
                    }
                    */
                    //actions.push(_action);
                }
            });
        },
        getStatusbar: function () {

            if (this.statusbar) {
                return this.statusbar;
            } else {
                return this.createStatusbar();
            }
        },
        onRenderedStatusBar: function (statusbar, root, text) {

            var bc = this.__bc;
            if (!bc && root && root.append) {
                bc = new Breadcrumb({}, $('<div>'));
                root.append(bc.domNode);

                $(bc.domNode).css({
                    "float": "right",
                    "padding": 0,
                    "margin-right": 10,
                    "top": 0,
                    "right": 50,
                    /*"right":0,*/
                    "position": "absolute"
                });

                this.__bc = bc;
                //bc.startup();
                bc.setSource(this);
            }
            if (bc) {

                bc.clear();


                var store = this.collection,
                    cwdItem = this.getCurrentFolder(),
                    cwd = cwdItem ? cwdItem.path : '';

                bc.setPath('.', store.getRootItem(), cwd, store);
            }

        },
        onStatusbarCollapse:function(e){

        },
        createStatusbar: function (where) {

            where = where = this.footer;
            var statusbar = this.statusbar,
                self = this;

            if (!statusbar) {


                var root = $('<div class="statusbar widget" style="width:inherit;padding: 0;margin:0;padding-left: 4px;"></div>')[0];

                where.appendChild(root);



                statusbar = $('<div class="status-bar-text ellipsis" style="display: inline-block;">0 items selected</div>')[0];

                root.appendChild(statusbar);

                var $collapser = $('<div class="status-bar-collapser fa-caret-up" style="" ></div>');
                $collapser.click(function(e){
                    self.onStatusbarCollapse($collapser);
                });
                var collapser  = $collapser[0];
                root.appendChild(collapser);
                this.statusbar = statusbar;
                this.statusbarCollapse = collapser;
                this.statusbarRoot = root;

                this._emit('createStatusbar', {
                    root: root,
                    statusbar: statusbar,
                    collapser: collapser
                })

            }

            return statusbar;

        },
        startup: function () {

            this.inherited(arguments);


            function bytesToSize(bytes) {
                var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                if (bytes == 0) return '0 Byte';
                var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
                return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
            }


            function calculateSize(items) {


                var bytes = 0;
                var sizeStr = '0 KB';
                _.each(items, function (item) {

                    var _bytes = item.sizeBytes || 0;
                    bytes += _bytes;
                });

                if (bytes > 0) {
                    sizeStr = bytesToSize(bytes);
                }

                return {
                    bytes: bytes,
                    sizeStr: sizeStr
                }


            }

            if (!this.hasPermission(types.ACTION.STATUSBAR)) {
                return;
            }
            var statusbar = this.getStatusbar(),
                self = this;

            if (statusbar) {

                function selectionChanged(evt) {
                    var selection = evt.selection || [],
                        nbItems = selection.length,
                        size = calculateSize(selection),
                        text = nbItems + '  ' +self.localize('selected') + ' (' + size.sizeStr + ')';

                    statusbar.innerHTML = text;

                    if (self.onRenderedStatusBar) {
                        self.onRenderedStatusBar(statusbar, self.statusbarRoot, text);
                    }

                }

                this._on('selectionChanged', selectionChanged);
            }
        }
    });

    return _class;
});
},
'dojo/_base/Deferred':function(){
define([
	"./kernel",
	"../Deferred",
	"../promise/Promise",
	"../errors/CancelError",
	"../has",
	"./lang",
	"../when"
], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
});

},
'xfile/FolderSize':function(){
/** @module xfile/Statusbar **/
define([
    "xdojo/declare",
    'xide/types',
    'xide/utils',
    'xfile/Breadcrumb',
    'xide/layout/_TabContainer',
    'xfile/views/FileSize'
], function (declare, types,utils,Breadcrumb,_TabContainer,FileSize) {

    //package via declare

    var _class = declare('xfile.FolderSize', null, {

        __sizeDisplay:null,
        __bottomTabContainer:null,
        __bottomPanel:null,
        __sizesTab:null,

        showStats:function(show){

            var bottomTabContainer = this.getBottomTabContainer(),
                tab = this.__sizesTab,
                display = this.__sizeDisplay,
                self = this,
                bottom = this._getBottom(),
                open = (bottom && bottom.isExpanded());

            if(open==true && bottom){
                show=false;
            }else if(!open && bottom){
                return bottom.expand();
            }


            if(show){


                if(!bottom){
                    bottom = this.getBottomPanel(false, 0.2);
                }

                if(bottom && display){
                    return bottom.expand();
                }

                if(!bottomTabContainer){

                    var tabContainer = utils.addWidget(_TabContainer, {
                        direction: 'below'
                    }, null, bottom, true);

                    this.__bottomTabContainer = bottomTabContainer  = tabContainer;
                    bottom._tabs = tabContainer;
                }

                if(!tab){
                    tab = this.__sizesTab = bottomTabContainer.createTab('Sizes', 'fa-bar-chart');
                }

                if(!display){

                    display = this.__sizeDisplay = tab.add(FileSize, {
                        owner:self
                    }, null, false);

                    display.startup();


                    this._on('openedFolder',function(data){

                        utils.destroy(self.__sizeDisplay);

                        tab.resize();
                        self.resize();
                        self.__sizeDisplay = null;
                        self.__sizeDisplay = utils.addWidget(FileSize, {
                            owner:self
                        }, null,tab,false);

                        utils.resizeTo(self.__sizeDisplay,tab,true,true);
                        self.__sizeDisplay.startup();

                    });
                }




            }else{
                bottom && bottom.collapse();
            }

        },
        _runAction: function (action) {


            var _action = this.getAction(action);
            if (_action && _action.command == types.ACTION.SIZE_STATS) {
                return this.showStats(this.__sizeDisplay ? false : true);
            }
            return this.inherited(arguments);
        },
        buildRendering: function () {

            this.inherited(arguments);

            var grid = this,
                node = this.domNode;


            this._on('onAddActions', function (evt) {

                var actions = evt.actions,
                    permissions = evt.permissions,
                    action = types.ACTION.SIZE_STATS;

                /*
                if (!evt.store.getSync(action) &&typeof d3 !=='undefined') {

                    var _action = grid.createAction('Sizes', action, 'fa-bar-chart', null, 'View', 'Show', 'item|view', null, null, null, null, null, permissions, node, grid);
                    if (!_action) {

                        return;
                    }
                    actions.push(_action);
                }
                */
            });
        }

    });

    return _class;
});
},
'dojo/keys':function(){
define(["./_base/kernel", "./sniff"], function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
});

},
'xide/views/_ActionMixin':function(){
define([
    "dojo/_base/declare",
    'dojo/_base/lang',
    "xide/utils",
    "xide/types",
    'xide/Keyboard',
    'xaction/Action',
    'xide/mixins/EventedMixin'
], function (declare,lang,utils,types,Keyboard, Action,EventedMixin) {
    /**
     * Provides tools to deal with 'actions' (xaction/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/_MenuMixin) in a subclass.
     *
     * @mixin module:xide/mixins/ActionMixin
     */
    var Implementation = {
        /**
         *
         * @param title
         * @param command
         * @param group
         * @param icon
         * @param handler
         * @param accelKey
         * @param keyCombo
         * @param keyProfile
         * @param keyTarget
         * @param keyScope
         * @param mixin
         * @returns {{title: *, command: *, group: *, icon: *, handler: *, accelKey: *, keyCombo: *, keyProfile: *, keyTarget: *, keyScope: *}}
         */
        createActionParameters:function(title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope,mixin){
            return {
                title: title,
                command: command,
                group: group,
                icon: icon,
                handler: handler,
                accelKey: accelKey,
                keyCombo: keyCombo,
                keyProfile: keyProfile,
                keyTarget: keyTarget,
                keyScope: keyScope,
                mixin:mixin
            };
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        addAction:function(where,action){
            var actions = where || [],
                thiz = this;

            var eventCallbackResult = this._emit('addAction',action);
            if(eventCallbackResult===false){
                return false;

            }else if(_.isObject(eventCallbackResult)){
                utils.mixin(action,eventCallbackResult);
            }
            actions.push(action);
            return true;
        }
    };

   //package via declare
    var _class = declare("xide/views/_ActionMixin",[EventedMixin,Keyboard],Implementation);
    _class.Implementation = Implementation;
    _class.createActionParameters = Implementation.createActionParameters;
    return _class;

});

},
'xide/views/_Dialog':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    'dojo/Deferred',
    'xide/_Popup'

], function (dcl,types,
             utils, EventedMixin,
             _Widget,Deferred,_Popup
) {



    var ctx = window.sctx,
        root;

    var _BootstrapDialog  = typeof BootstrapDialog !=='undefined' ? BootstrapDialog : {};

    var Module = dcl([_Widget.dcl,EventedMixin.dcl],{
        declaredClass:'xide/views/_Dialog',
        //message: null,
        cssClass:'bootstrap3-dialog',
        containerClass:'',
        type: types.DIALOG_TYPE.WARNING,
        size: types.DIALOG_SIZE.SIZE_WIDE,
        //defaultOptions:_BootstrapDialog.defaultOptions,
        dlg:null,
        bodyCSS:null,
        okButtonClass:'btn-danger',
        startDfd:null,
        _ready:false,
        getData:function(){
            return null;
        },
        getInstance:function(args){

            this.defaultOptions  = typeof BootstrapDialog !=='undefined' ? BootstrapDialog.defaultOptions : {};

            if(this.dlg){
                return this.dlg;
            }

            args = this.buildArgs(args);

            var instance = new _BootstrapDialog(args),
                oldRealize = instance.realize,
                self = this;

            if(!instance){
                console.error('BootstrapDialog not loaded, abort');
                return;
            }

            instance.realize = function(){
                oldRealize.apply(instance,null);
                self.buildRendering(instance);
                $.each(args.buttons, function (index, button) {
                    var $button = instance.getButton(button.id);
                    if($button && button.focus==true){
                        $button.addClass('active');
                    }
                });

                $(instance.$modalDialog).draggable({ handle: ".modal-header" });
            }

            instance.owner = this;


            this.dlg = instance;

            return instance;

        },
        buildRendering:function(dlg){
            this.containerNode= this.domNode = dlg.$modalBody[0];
            dlg.$modalBody.addClass(this.containerClass);
            this.bodyCSS && dlg.$modalBody.css(this.bodyCSS);
        },
        onshown:function(dlg){
            dlg.owner.resize();
            dlg.owner.onShow.apply(dlg.owner,[]);
            var zIndexBackdrop = window.__nextZ ? window.__nextZ(1) : 1040;
            var zIndexModal = window.__nextZ ? window.__nextZ() : 1050;

            dlg.$modal.css('z-index',zIndexBackdrop);
            dlg.$modalDialog.css('z-index',zIndexModal);

            this._ready = true;
        },
        onReady:function(){
            var self = this;
            setTimeout(function(){
                self._ready = true;
            },100);

        },
        startup:function(){
            var dlg = this.getInstance();
        },
        destroy:function(){
            this.dlg && this.dlg.close();
        },
        show:function(args){

            var self=this;

            if(!this.startDfd){
                this.startDfd = new Deferred();
                this.startDfd.then(function(){
                    self.onReady();
                });
            }

            var dlg = this.getInstance(args);

            dlg.open();

            setTimeout(function(){
                self._ready=true;
            },1000);

            return this.startDfd;

        },

        getButtons:function(){

            var thiz = this;

            var buttons = [{
                icon: 'fa-check',
                label: thiz.localize('Ok'),
                cssClass: thiz.okButtonClass || 'btn-primary',
                hotkey: 13, // Enter.
                autospin: false,
                focus:true,
                id:utils.createUUID(),
                action: function(dialogRef) {
                    if(!thiz._ready){
                        return;
                    }
                    dialogRef.close(false);
                    dialogRef.owner.onOk(thiz.getData());
                }
            },
            {
                icon: 'glyphicon glyphicon-check',
                label: thiz.localize('CANCEL'),
                cssClass: 'btn-info',
                autospin: false,
                id:utils.createUUID(),
                action: function (dialogRef) {
                    dialogRef.close();
                    dialogRef.owner.onCancel();
                }

            }
            ];

            return buttons;

        },
        buildArgs:function(args){
            args = args || this.defaultOptions || {};
            utils.mixin(args,{
                type: this.type,
                size: this.size,
                message:this.message,
                title:this.title,
                buttons:this.buttons,
                onOk:this.onOk,
                onCancel:this.onCancel,
                onShow:this.onShow,
                onshown:this.onshown
                //defaultOptions:_BootstrapDialog.defaultOptions,
            });
            args.title = this.localize(args.title)
            return args;
        },
        constructor:function(args){
            this.buttons = this.getButtons();
            utils.mixin(this,args);
        },
        onOk:function(){},
        onCancel:function(){}
    });

    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");


    return Module;

});
},
'xide/mixins/ReloadMixin':function(){
/** @module xide/mixins/ReloadMixin **/
define([
    "xdojo/declare",
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (declare,dcl,types, utils,EventedMixin) {

    /**
     * Mixin which adds functions for module reloading to the consumer. All functions
     * of the reloaded module will be overridden with the re-loaded module's version.
     * Recommended: turn off web-cache and use turn on 'cacheBust' in your Dojo-Config.
     *
     *
     *  <b>Usage</b> :
     *  1. call initReload manually (subscribes to types.EVENTS.ON_MODULE_RELOADED which is triggered by module:xide/manager/Context )
     *  2. that's it actually.
     *  3. optionally add a function 'onReloaded' to your sub class and refresh yourself, ie: re-create widgets or simply test
     *  a piece of code
     *
     *
     * @mixin module:xide/mixins/ReloadMixin
     * @requires module:xide/mixins/EventedMixin
     */
    var Impl = {
        /**
         *
         * Not used yet, but at @TODO: some flags to describe the hot-replace for reloaded modules
         *
         */
        _mergeFunctions: true,
        _mergeMissingVariables: true,
        /**
         * Cross instanceOf equal check, tries:
         *
         *  1. native
         *  2. Dojo::isInstanceOf
         *  3. baseClasses
         *
         * @param cls {Object}
         * @returns {boolean}
         */
        isInstanceOf_: function (cls) {

            try {

                //Try native and then Dojo declare's _Stateful::isInstanceOf
                if (!!this instanceof cls
                    || (this.isInstanceOf && this.isInstanceOf(cls))) {

                    return true;

                }else{

                    //manual lookup, browse all base classes and their superclass
                    var bases = utils.getAt(this, 'constructor._meta.bases', []),//save get, return base::at[path] or empty array
                        _clsClass = cls.prototype.declaredClass;    //cache

                    //save space
                    return _.findWhere(bases, function (_base) {

                        return _base == cls    //direct cmp
                        || utils.getAt(_base, 'superclass.declaredClass') === _clsClass   //mostly here
                        || utils.getAt(_base, 'prototype.declaredClass') === _clsClass;    //sometimes

                    });

                }

            } catch (e) {
                //may crash, no idea why!
                console.log('ReloadMixin :: this.isInstanceOf_ crashed ' + e);
            }

            return false;

        },
        /**
         * @TODO: use flag guarded mixin
         *
         * @param target
         * @param source
         */
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (_.isFunction(source[i])) {
                    target[i] = null;//be nice
                    target[i] = source[i];//override
                }
                //support missing properties
                if (_.isArray(source[i])) {
                    if (target[i] == null) {
                        target[i] = source[i];
                    }
                }
            }
        },
        /**
         * Event callback for xide/types/EVENTS/ON_MODULE_RELOADED when a module has been reloaded.
         * @member
         * @param evt
         */
        onModuleReloaded: function (evt) {
            //console.log('on module reloaded');
            var newModule = evt.newModule;
            if (!newModule || !newModule.prototype || evt._processed) {
                return;
            }
            var moduleProto = newModule.prototype,
                moduleClass = moduleProto.declaredClass,
                matchedByClass = false,
                thisClass = this.declaredClass,
                thiz=this;

            if(!moduleClass){
                return;
            }
            if (moduleClass && thisClass) {
                //determine by dotted normalized declaredClass
                matchedByClass = utils.replaceAll('/', '.', thisClass) === utils.replaceAll('/', '.', moduleClass);
            }
            if (matchedByClass) {
                thiz.mergeFunctions(thiz, moduleProto);
                if (thiz.onReloaded) {
                    evt._processed = true;
                    thiz.onReloaded(newModule);
                }
            } else if (evt.module && utils.replaceAll('//', '/', evt.module) === thisClass) {//not sure this needed left
                //dcl module!
                thiz.mergeFunctions(thiz, moduleProto);
            }
        },
        /**
         * Public entry; call that in your sub-class to init this functionality!
         */
        initReload: function () {
            this.subscribe(types.EVENTS.ON_MODULE_RELOADED);
        }
    };

    //package via declare
    var _class = declare(null,Impl);

    //static access to Impl.
    _class.Impl = Impl;

    _class.dcl = dcl(EventedMixin.dcl,Impl);

    return _class;

});
},
'xfile/config':function(){
define([
    'dojo/_base/declare',
    'xide/types'
],function(declare,types){

    types.config={

        /**
         * Root node id to for xfile main application, can be ignored for embedded mode.
         */
        ROOT_NODE:'xapp',
        /***
         * The absolute url to server rpc end-point
         */
        FILE_SERVICE:'',
        /***
         * Default start path
         */
        START_PATH:'./',
        /***
         * A pointer to a resolved AMD prototype. This should be xfile/data/FileStore
         */
        FILES_STORE_SERVICE_CLASS:'XCOM_Directory_Service',
        /***
         *  Enables file picker controls, obsolete at the moment
         */
        IS_MEDIA_PICKER:null,
        EDITOR_NODE:null,
        EDITOR_AFTER_NODE:null,
        ACTION_TOOLBAR:null,

        ALLOWED_DISPLAY_MODES:{
            TREE:1,
            LIST:1,
            THUMB:1,
            IMAGE_GRID:1
        },

        LAYOUT_PRESET:null,

        beanContextName:null

    };
    return types
});

},
'xfile/xfile':function(){

},
'dcl/inherited':function(){
(function(factory){
	if(typeof define != "undefined"){
		define(["./mini", "./advise"], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory(require("./mini"), require("./advise"));
	}else{
		factory(dcl, advise);
	}
})(function(dcl, advise){
	var empty = {}, t;

	function inherited(ctor, name, args){
		var callee = arguments.length < 3 && ctor.callee, // callee is truthy if in non-strict mode.
			f = get.call(this, callee ? callee.ctr : ctor, callee ? callee.nom : name);
		if(f){ return f.apply(this, callee ? ctor || name : args); }
		// intentionally no return
	}

	function get(ctor, name){
		var meta = this.constructor._meta, bases, base, i, l;
		if(+meta.weaver[name]){
			return; // return undefined
		}
		if(meta){
			if(meta.chains.hasOwnProperty(name)){
				if((bases = meta.chains[name])){	// intentional assignment
					for(i = bases.length - 1; i >= 0; --i){
						base = bases[i];
						if(base.ctr === ctor){
							return i > 0 ? bases[i - 1] : 0;
						}
					}
				}
				return; // return undefined
			}
			for(bases = meta.bases, i = bases.length - 1; i >= 0; --i){
				if(bases[i] === ctor){
					break;
				}
			}
			if(i >= 0){
				for(++i, l = bases.length; i < l; ++i){
					if((meta = (base = bases[i])._meta)){	// intentional assignments
						if((meta = meta.ownProps).hasOwnProperty(name)){	// intentional assignment
							return meta[name];
						}
					}else{
						return base.prototype[name];
					}
				}
			}
		}
		return empty[name];
	}

	advise.after(dcl, "_postprocess", function(args, ctor){
		// decorate all methods with necessary nom/ctr variables
		var bases = ctor._meta.bases, i = bases.length - 1, base, meta, name, f;
		for(; i >= 0; --i){
			base = bases[i];
			if((meta = base._meta)){ // intentional assignment
				meta = meta.ownProps;
				dcl.allKeys(meta).some(function(name){
					f = meta[name];
					if(typeof f == "function"){
						if(f.nom === name){ return 1; }
						f.nom = name;
						f.ctr = base;
					}
				});
			}
		}
		ctor.prototype.inherited = inherited;
		ctor.prototype.getInherited = get;
	});

	dcl.getInherited = inherited.get = get;
	return dcl.inherited = inherited;   // intentional assignment
});

},
'xaction/ActionModel':function(){
/** module:xaction/ActionModel **/
define([
    "xdojo/declare",
    'xaction/Action',
    'xide/data/Model',
    "xide/data/Source",
    'xide/model/Path',
    'xide/utils'
], function (declare, Action, Model, Source, Path, utils) {
    var debug = false;
    /**
     * @class module:xaction/ActionModel
     * @extends module:xide/data/Source
     * @extends module:xaction/Action
     * @extends module:xide/mixins/EventedMixin
     */
    return declare("xaction/ActionModel", [Action, Model, Source], {
        filterGroup: "item|view",
        keyboardMappings: null,
        bindWidgetProperties: [
            //2-way bindings for these props:
            'value',
            'icon',
            'disabled'
        ],
        items: null,
        onRemove: function () {
            _.invoke(this.getReferences(), 'destroy');
            this.keyboardMappings && _.invoke(this.keyboardMappings, "destroy");
            this.destroy();
        },
        shouldShow: function () {
            return true;
        },
        shouldDisable: function () {
            return false;
        },
        updateReference: function (selection, reference, visibility) {
            reference.set('disabled', this.shouldDisable(selection, reference, visibility));
            if (this.icon !== null && reference.icon !== null && this.icon !== reference.icon) {
                reference.set('icon', this.icon);
            }
            if (this.value !== null && reference.value !== null && this.value !== reference.value) {
                reference.set('value', this.value);
            }
        },
        refreshReferences: function (property, value) {
            _.each(this.getReferences(), function (ref) {
                ref.set(property, value);
            }, this);
        },
        refresh: function (selection) {
            this._emit('refresh', {
                action: this,
                selection: selection
            });
            _.each(this.getReferences(), function (ref) {
                this.updateReference(selection, ref, ref.visibility);
            }, this);
        },
        setProperty: function (key, value, updateReferences) {
            return this.set(key, value);
        },
        complete: function () {
            this.items = this.getChildren();
        },
        getParent: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return this._store.getSync(segments.slice(0, segments.length - 1).join('/'));
            }
        },
        getParentCommand: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return segments.slice(0, segments.length - 1).join('/');
            }
        },
        getSegments: function (command) {
            return command.split('/');
        },
        getRoot: function () {
            return this.command.split('/')[0];
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(utils.pluck(items, 'command'), false);
        },
        getChildren: function () {
            var children = this.getItemsAtBranch(this._store.getAll(), this.command),
                self = this;

            //return an action from both stores
            function getAction(command) {
                return self._store.getSync(command);
            }

            //command strings to actions
            function toActions(paths) {
                var result = [];
                _.each(paths, function (path) {
                    result.push(getAction(path));
                });
                return result;
            }

            return toActions(children);
        },
        /**
         * @TODO: remove back compat
         * @param evt {object}
         * @param evt.parent {widget}
         * @param evt.widget {widget}
         * @param evt.visibility {string}
         * @private
         */
        _onWidgetCreated: function (evt) {
            if (evt.widget.addSource) {
                this.addReference(evt.widget, {
                    properties: {
                        "value": true
                    }
                }, true);
            } else {
                debug && console.warn('widget is not a reference! ', evt);
            }
        },
        /**
         * @TODO: remove back compat
         * @private
         */
        _onCreated: function () {
        }
    });
});
},
'xide/editor/Default':function(){
define([
    'xdojo/declare',
    'xide/utils',
    'xdojo/has!xace?xace/views/Editor'
],function (declare,utils,Editor){

    var debug = false;
    /**
    * A default editor, using ACE!
     */
    var Implementation = {
        ctx:null,
        /**
         *
         * @param item
         * @param where
         * @param mixin
         * @returns {Editor}
         */
        open:function(item,where,mixin,select,owner){

            if(!Editor){
                debug && console.error('have no xace! abort opening default editor!');
            }

            if(!item){
                debug && console.error('invalid item!');
                return null;
            }

            if(!item.getPath().match(/^(.*\.(?!(zip|tar|gz|bzip2)$))?[^.]*$/i)) {
                return null;
            }

            var mime = item.mime,
                mediaTypes = ["image/png","image/jpg"];

            if(mime){
                if(mediaTypes.indexOf(mime)!==-1||
                    mime.indexOf('video')!==-1||
                    mime.indexOf('audio')!==-1 ||
                    mime.indexOf('image')!==-1)
                {
                    return null;
                }
            }

            var thiz=this,
                ctx = thiz.ctx,
                mainView = ctx ? ctx.mainView : null,
                title = utils.toString(item.name) ||  (utils.pathinfo(item.path,'PATHINFO_FILENAME') + '.'+ utils.pathinfo(item.path,'PATHINFO_EXTENSION')),
                docker = mainView ? mainView.getDocker() : null,
                registerInWindowManager = owner && owner.registerEditors===true ? true : false,
                container  = where || mainView.layoutCenter,
                root = null;

            mixin = mixin || {}

            if(!where) {
                root = mixin.attachTo || docker.addTab(null, {
                    title: title,
                    target: container ? container._parent : null,
                    icon: 'fa-code'
                });
            }else{
                root = container;
            }

            var args = {

                item:item,
                style:'padding:0px;',
                iconClass:'fa-code',
                options:utils.mixin(mixin,{
                    filePath:item.path,
                    fileName:item.name
                }),
                ctx:ctx,
                /***
                 * Provide a text editor store delegate
                 */
                storeDelegate:{
                    getContent:function(onSuccess,_item){
                        var file = _item || item;
                        return thiz.ctx.getFileManager().getContent(file.mount,file.path,onSuccess);
                    },
                    saveContent:function(value,onSuccess,onError){
                        return thiz.ctx.getFileManager().setContent(item.mount,item.path,value,onSuccess);
                    }
                },
                title:title
            };

            utils.mixin(args,mixin);

            var editor = utils.addWidget(Editor,args,this,root,true,null,null,select);

            root.resize && root.resize() && editor.resize();

            select!==false && root.selectChild && root.selectChild(editor);

            docker.resize();

            registerInWindowManager && ctx.getWindowManager().registerView(editor,false);

            return editor;
        }
    };

    //package via declare
    var _class = declare('xide.editor.Default',null,Implementation);
    _class.Implementation = Implementation;
    return _class;

});
},
'dojo/dnd/common':function(){
define(["../sniff", "../_base/kernel", "../_base/lang", "../dom"],
	function(has, kernel, lang, dom){

// module:
//		dojo/dnd/common

var exports = lang.getObject("dojo.dnd", true);
/*=====
// TODO: for 2.0, replace line above with this code.
var exports = {
	// summary:
	//		TODOC
};
=====*/

exports.getCopyKeyState = function(evt){
	return evt[has("mac") ? "metaKey" : "ctrlKey"]
};

exports._uniqueId = 0;
exports.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = kernel._scopeName + "Unique" + (++exports._uniqueId);
	}while(dom.byId(id));
	return id;
};

exports._empty = {};

exports.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

return exports;
});

},
'dojo/when':function(){
define([
	"./Deferred",
	"./promise/Promise"
], function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
});

},
'xide/lodash':function(){
/** @module xide/lodash **/
define([],function(){
    /**
     * temp. wanna be shim for lodash til dojo-2/loader lands here
     */
    if(typeof _ !=="undefined"){
        return _;
    }
});

},
'xaction/ActionProvider':function(){
define([
    "xdojo/declare",
    'dcl/dcl',
    "xide/types",
    "xide/utils",
    "xide/model/Path",
    'xaction/ActionStore',
    'xaction/Action',
    'xide/Keyboard',
    'xide/mixins/EventedMixin',
    'xaction/DefaultActions',
    'xide/lodash'
], function (declare, dcl, types, utils, Path, ActionStore, Action, Keyboard, EventedMixin, DefaultActions,_) {

    var Implementation = {
        /**
         * @type module:xaction/ActionStore
         */
        actionStore: null,
        actions: null,
        allowActionOverride: true,
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (groupMap[a] != null && groupMap[b] != null) {
                    var orderA = groupMap[a];
                    var orderB = groupMap[b];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(_.map(items, 'command'), false);
        },
        /////////////////////////////////////////////////////
        //
        //  Store Based Extension -
        //
        /////////////////////////////////////////////////////
        /**
         * Update all actions referencing widgets
         */
        refreshActions: function () {
            var allActions = this.getActions();
            for (var i = 0; i < allActions.length; i++) {
                var action = allActions[i];
                if (action.refresh) {
                    action.refresh();
                }
            }
        },
        getAction: function (mixed) {
            if (_.isString(mixed)) {
                return this.getActionStore().getSync(mixed);
            }
            return mixed;
        },
        clearActions: function () {
            var store = this.getActionStore(),
                actions = store ? store.query() : [];

            _.each(actions, function (action) {
                action && store.removeSync(action.command);
            });
            store && store.setData([]);
        },
        destroy: function () {
            this.clearActions();
            return this.inherited(arguments);
        },
        /**
         *
         * @param title
         * @param command
         * @param group
         * @param icon
         * @param handler
         * @param accelKey
         * @param keyCombo
         * @param keyProfile
         * @param keyTarget
         * @param keyScope
         * @param mixin
         * @returns {xaction/Action}
         */
        __createAction: function (title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope, mixin) {
            icon = icon || types.ACTION_ICON[command];
            var args = {accelKey: accelKey};
            utils.mixin(args, mixin);
            var action = Action.createDefault(title, icon, command, group, handler, args);
            if (keyCombo) {
                var keyboardMappings;
                if (this.keyboardMappings) {
                    keyboardMappings = this.keyboardMappings;
                } else {
                    action.keyboardMappings = keyboardMappings = [];
                }
                var mapping = Keyboard.defaultMapping(keyCombo, handler, keyProfile || types.KEYBOARD_PROFILE.DEFAULT, keyTarget, keyScope, [action]);
                mapping = this.registerKeyboardMapping(mapping);
                keyboardMappings.push(mapping);
                action.keyboardMappings = keyboardMappings;
            }
            return action;
        },
        updateAction: function (action, what, value) {
            action = action || this.getAction(action);
            if (action) {
                action.set(what, value);
                setTimeout(function () {
                    action.getReferences().forEach(function (ref) {
                        ref.set(what, value);
                    });
                }, 100);
            }
        },
        _completeActions: function (actions) {
            var result = [];
            var keyTarget = this.getKeyTarget ? this.getKeyTarget() : null;
            for (var i = 0; i < actions.length; i++) {
                var config = actions[i],
                    action;

                if (!config) {
                    continue;
                }

                if (!(config instanceof Action)) {
                    action = this.__createAction(
                        config.title,
                        config.command,
                        config.group,
                        config.icon,
                        config.handler,
                        config.accelKey,
                        config.keyCombo,
                        config.keyProfile,
                        keyTarget || config.keyTarget,
                        config.keyScope,
                        config.mixin);

                    action.parameters = config;
                } else {
                    action = config;
                }
                this._addAction(result, action);
            }
            if (this.keyboardMappings) {
                console.error('have mappings');
            }
            _.each(this.keyboardMappings, function (mapping) {
                this.registerKeyboardMapping(mapping);
            }, this);
            return result;
        },
        createActionStore: function () {
            if (!this.actionStore) {
                var _actions = this._completeActions(this.actions || []);
                this.actionStore = new ActionStore({
                    id: utils.createUUID(),
                    data: _actions,
                    observedProperties: [
                        "value",
                        "icon",
                        "label"
                    ],
                    tabOrder: this.tabOrder,
                    groupOrder: this.groupOrder,
                    tabSettings: this.tabSettings,
                    menuOrder: this.menuOrder
                });
            }
            return this.actionStore;
        },
        /**
         * Get all actions via query from Action store
         * @param mixed
         * @param allowCache
         * @returns {*}
         */
        getActions: function (mixed, allowCache) {
            if (!mixed && allowCache !== false && this.__actions) {
                return this.__actions;
            }
            var query = mixed;
            //no query or function given
            if (!mixed) {
                query = {
                    command: /\S+/
                };
            }
            this.__actions = this.getActionStore().query(query);
            return this.__actions;

        },
        /**
         * Safe getter for action store
         * @returns {*}
         */
        getActionStore: function () {
            return this.createActionStore();
        },
        /**
         * Create action store upon construction
         */
        postMixInProperties: function () {
            this.inherited && this.inherited(arguments);
            this.createActionStore();
        },
        addActions: function (actions) {
            var store = this.getActionStore();
            if (!store['subscribedToUpdates_' + this.id]) {
                store['subscribedToUpdates_' + this.id] = true;
                this.addHandle('update', store.on('update', function (evt) {
                    var action = evt.target;
                    if (action._isCreating || !evt.property) {
                        return;
                    }
                    if (action && action.onChange) {
                        action.onChange(evt.property, evt.value, action);
                    }

                }));
            }
            var result = [];
            this._emit('onAddActions', {
                actions: actions,
                permissions: this.permissions,
                store: store
            });

            //remove existing
            this.allowActionOverride && _.each(actions, function (action) {
                if (action) {
                    var existing = store.getSync(action.command);
                    if (existing) {
                        store.removeSync(existing.command);
                    }
                }
            });
            actions = this._completeActions(actions);

            _.each(actions, function (action) {
                if (this.allowActionOverride && store.getSync(action.command)) {
                    store.removeSync(action.command);
                }
                var _action = store.putSync(action);
                result.push(_action);
                _action._isCreating = true;
                _action.onCreate && _action.onCreate(_action);
                this._emit('onAddAction', _action);
                _action._isCreating = false;
            }.bind(this));
            return result;

        },
        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param props
         * @param mixin
         * @returns {*}
         */
        createActionShort: function (label, command, icon, props, mixin) {
            return this.createAction(_.extend({
                label: label,
                command: command,
                icon: icon,
                mixin: props && props.mixin ? props.mixin : mixin
            }, props));
        },
        /**
         *
         * @param options
         * @returns {*}
         */
        createAction2: function (options) {

            var thiz = this,
                action = null,
                mixin = options.mixin || {},
                owner = options.owner || mixin.owner || thiz,
                permissions = options.permissions || this.permissions || [],
                command = options.command,
                keycombo = options.keycombo,
                label = options.label,
                icon = options.icon,
                tab = options.tab,
                group = options.group,
                filterGroup = options.filterGroup,
                onCreate = options.onCreate,
                handler = options.handler,
                container = options.container || thiz.domNode,
                shouldShow = options.shouldShow,
                shouldDisable = options.shouldDisable;

            utils.mixin(mixin, {
                owner: owner,
                onChange: options.onChange

            });

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {

                handler = handler || DefaultActions.defaultHandler;
                if (keycombo) {
                    if (_.isString(keycombo)) {
                        keycombo = [keycombo];
                    }
                    mixin.tooltip = keycombo.join('<br/>').toUpperCase();
                }

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);
                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        /**
         * Create Action
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         * @param permissions
         * @param container
         * @param owner
         * @returns {*}
         */
        createAction: function (label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, permissions, container, owner) {
            if (arguments.length == 1) {
                return this.createAction2(arguments[0]);
            }
            var thiz = this,
                action = null;

            mixin = mixin || {};
            utils.mixin(mixin, {owner: owner || thiz});

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {
                if (!handler) {
                    handler = function (action) {
                        this.runAction && this.runAction.apply(this, [action]);
                    };
                }
                keycombo && _.isString(keycombo) && (keycombo = [keycombo]);

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);

                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        addAction: function (where, action) {
            var actions = where || [];
            var eventCallbackResult = this._emit('addAction', action);
            if (eventCallbackResult === false) {
                return false;
            } else if (_.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        _addAction: function (where, action) {
            var actions = where || [],
                eventCallbackResult = this._emit('addAction', action);

            if (eventCallbackResult === false) {
                return false;
            } else if (utils.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        hasAction: function (action) {
            return DefaultActions.hasAction(this.permissions, action);
        }
    };

    /**
     * Provides tools to deal with 'actions' (xaction/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/EventedMixin) in a subclass.
     *
     * @class module:xide/mixins/ActionProvider
     * @extends module:xide/mixins/EventedMixin
     */
    var Module = declare("xaction/ActionProvider", [EventedMixin, Keyboard], Implementation);
    Module.dcl = dcl([EventedMixin.dcl, Keyboard.dcl], Implementation);
    return Module;
});

},
'dojo/dom-attr':function(){
define(["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"],
		function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)

	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie"),
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}

	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}

		if(propName == "textContent"){
			return prop.get(node, propName);
		}

		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
});

},
'xide/widgets/_MenuKeyboard':function(){
define([
    "dcl/dcl",
    "xide/$",
    "xide/lodash",
    "xide/mixins/EventedMixin"
], function (dcl, $, _, EventedMixin) {

    var skip = [
        '.divider',
        '.nav-header',
        '.disabled'
    ];

    var Module = dcl(EventedMixin.dcl, {
        owner: null,
        /**
         *
         * @param owner
         */
        setup: function (owner) {
            this.owner = owner;
        },
        /**
         * Return parent action container for an element
         * @param $el {jQuery}
         * @param $max {jQuery}
         * @param dataIdentifier {string} The data identifier to find some object in $el
         * @returns {jQuery|null}
         */
        findNavigationContainerElement: function ($el, $max, dataIdentifier) {
            if (!$el || !$el[0]) {
                return null;
            }
            if ($el && $max && $el[0] == $max[0]) {
                return $el;
            }

            var data = $el.data(dataIdentifier || 'data');
            if (data && data != null) {
                return $el;
            }
            return this.findNavigationContainerElement($el.parent(), $max, dataIdentifier);
        },
        /**
         *
         * @param $el
         * @param $max
         * @param dataIdentifier
         * @returns {jQuery|null}
         */
        findNavigationElement: function ($el, $max, dataIdentifier) {
            if (!$el || !$el[0]) {
                return null;
            }
            if ($el && $max && $el[0] == $max[0]) {
                return $el;
            }
            var data = $el.data(dataIdentifier || 'item') || $el.data(dataIdentifier || 'data');
            if (data && !_.isEmpty(data)) {
                return $el;
            }
            return this.findNavigationElement($el.parent());
        },
        /**
         *
         * @param $el {jQuery}
         * @param $max {jQuery}
         * @param dataIdentifier {string} The data identifier to find some object in $el
         * @param findParent
         * @returns {{element: Object, data: (*|{}), parent: *}}
         */
        toNavigationData: function ($el, $max, dataIdentifier, findParent) {
            var element = this.findNavigationElement($el, $max, dataIdentifier);
            if (element) {
                var data = element.data(dataIdentifier || 'item') || element.data(dataIdentifier || 'data');
                if (data) {
                    return {
                        element: element,
                        data: data,
                        parent: findParent !== false ? this.findNavigationContainerElement($el, $max, dataIdentifier) : null
                    };
                }
            }
        },
        /**
         *
         * @param $parent
         * @param $origin
         * @param direction
         * @returns {*}
         */
        next: function ($parent, $origin, direction) {
            if ($origin) {
                var result = $origin[direction == 1 ? 'next' : 'prev']();
                if (!this.canSelect(result)) {
                    return this.next($parent, result, direction);
                } else {
                    return result;
                }
            }
        },
        /**
         * Return valid children
         * @param $el{jQuery}
         * @returns {*}
         */
        canSelect: function ($el) {
            return $($el).is(skip.join(',')) == false;
        },
        /**
         *
         * @param $parent{jQuery}
         * @param all {boolean}
         * @returns {HTMLElement[]}
         */
        children: function ($parent, all) {
            var self = this;
            return $parent.children('LI').filter(function (i, child) {
                if (all !== true) {
                    return self.canSelect(child);
                } else {
                    return child;
                }
            });
        },
        /**
         *
         * @param $el {jQuery}
         */
        close: function ($el) {
            var _parent = $el.parent();
            var _parentParent = $el.parent().parent();
            _parent.css('display', '');
            _parent.removeClass('open');
            $el.removeClass('open');
            $el.removeClass('focus');
            $el.removeClass('active');
            _parentParent.removeClass('open');
            _parentParent.focus();
        },
        /**
         * Opens the very root menu by a given origin
         * @param $el
         * @param $next
         * @param direction {init} left = -1, right = 1
         * @returns {*}
         */
        openRoot: function ($el, $next, direction) {
            var _next = $next || this.topMost($el).parent()[direction === -1 ? 'prev' : 'next']();
            var _trigger = $(_next.find('A')[0]);
            _trigger.trigger('click');
            var _navData = this.toNavigationData($(_next.find('UL')[0]), this.owner.getRootContainer());
            if (_navData) {
                return this.activate($(this.children(_navData.element)[0]), _navData.element, true);
            }

        },
        destroy: function () {
            delete this.owner;
        },
        /**
         *
         * @param $el {jQuery}
         */
        open: function ($el) {
            $el.css('display', 'block');
            var _navData = this.toNavigationData($el, this.owner.getRootContainer(), 'data', null, null);
            var firstInner = this.children(_navData.parent)[0];
            if (firstInner) {
                _navData = this.toNavigationData($(firstInner), this.owner.getRootContainer());
                this.activate(_navData.element, _navData.parent, true);
            }
        },
        topMost: function ($el) {
            if ($el) {
                var data = $el.data();
                if (data.item || data.data) {
                    var next = $el.parent();
                    var parentData = next.data();
                    if (next && next[0] && (parentData.item || parentData.data)) {
                        return this.topMost(next);
                    }
                    return $el;
                }
            }
        },
        keyboardHandler: function (event, $parent) {
            var origin = $parent.data('currentTarget');
            if (event.keyCode === 13) {
                var trigger = origin.find("A");
                var handler = trigger.data('handler');
                if (handler) {
                    var actionResult = handler();
                    if (actionResult && actionResult.then) {
                        actionResult.then(function () {
                            origin.focus();
                        });
                    }
                    return;
                }
                //perform action
                origin.find("A").click();
                origin.focus();
                return;
            }

            var vertical = event.keyCode == 38 || event.keyCode == 40 || event.keyCode == 36 || event.keyCode == 35;
            var horizontal = event.keyCode == 37 || event.keyCode == 39;
            var direction = vertical ? (event.keyCode == 38 || event.keyCode == 36) ? -1 : 1 : (event.keyCode == 37 ? -1 : 1 );
            var max = !!(event.keyCode == 36 || event.keyCode == 35 );

            var nextElement = null;
            var nextData = {};
            var navData = null;
            if (vertical) {
                nextElement = max ? direction == 1 ? $(_.last(this.children($parent))) : $(_.first(this.children($parent))) : this.next($parent, origin, direction);
                nextElement && (nextData = nextElement.data('item'));
            }
            if (horizontal) {
                var data = origin.data('item');
                if (data) {
                    if (direction > 0) {
                        //sub - items?, open them
                        if (data.subMenuData) {
                            var isOpen = data.subMenuData.css('display') === 'block';
                            if (!isOpen) {
                                return this.open(data.subMenuData);
                            } else {
                                //root bounce
                                if (this.openRoot(origin, null, 1)) {
                                    return;
                                }
                            }
                        } else {
                            //root bounce
                            if (this.openRoot(origin, null, 1)) {
                                return;
                            }
                        }
                    } else {
                        //left
                        this.close(origin);
                        navData = this.toNavigationData(origin, this.owner.getRootContainer());
                        //root bounce
                        if (_.isEmpty(navData.parent.parent().data())) {
                            return this.openRoot(origin, null, -1);
                        }
                        return;
                    }
                }
            }
            if (nextElement && nextData) {
                navData = this.toNavigationData(nextElement, this.owner.getRootContainer());
                this.activate(navData.element, navData.parent, true);
            }
        },
        initContainer: function ($container) {
            var self = this;
            if (!$container.data('didSetup')) {
                $container.data('didSetup', true);
                this.__on($container, 'keydown', null, function (evt) {
                    if (($(evt.target).parent()[0] == $container[0])) {
                        self.keyboardHandler(evt, $container);
                    }
                });
            }
        },
        activate: function ($next, $parent, clear) {
            if ($parent) {
                this.initContainer($parent);
            }
            if (clear && $parent) {
                this.children($parent, true).each(function (i, c) {
                    $(c).removeClass('focus');
                    $(c).removeClass('open');
                    $(c).removeClass('active');
                    var _s = $(c).find('.dropdown-context-sub');
                    if (_s[0] && _s.css('display') === 'block') {
                        _s.css('display', '');
                        _s.removeClass('open');
                        _s.removeClass('active');
                    }
                });
            }
            $next.addClass('focus');
            $next.addClass('active');
            $next.focus();
            $parent.addClass('open');
            $parent.data('currentTarget', $next);
            return true;
        },
        clear: function ($parent) {
            this.children($parent, true).each(function (i, c) {
                $(c).removeClass('focus');
                $(c).removeClass('open');
                $(c).removeClass('active');
                var _s = $(c).find('.dropdown-context-sub');
                if (_s[0] && _s.css('display') === 'block') {
                    _s.css('display', '');
                    _s.removeClass('open');
                }
            });
        }
    });
    return Module;
});
},
'xide/Lang':function(){
define([
    'xdojo/has',
    'xdojo/declare',
    'xlang/i18',
    'xide/utils/StringUtils',
    'dojo/Deferred',
    'require'
],function(has,declare,i18,StringUtils,Deferred,require){


    var Module = declare('xide/Lang',null,{});
    var validLanguages = ['ar','bg','ca','cs','da','de','el','en','es','fa','fr','he','hu','id','it','jp','ko','nl','no','pl','pt_BR','ro','ru','sk','sl','sr','sv','tr','uk','vi','zh_CN','zh_TW'];
    function isValidLanguage(lang){
        return validLanguages.indexOf(lang) !==-1;
    }

    Module.getLanguage = function(){
        var _lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
        var language = 'en';
        if (typeof navigator !== 'undefined') {
            if (navigator.appName == 'Netscape')
                language = navigator.language.substring(0, 2);
            else
                language = navigator.browserLanguage.substring(0, 2);
        }

        if (language != _lang && _lang) {
            language = _lang;
        }

        var urlParts = StringUtils.urlArgs(location.href);
        if(urlParts.lang){
            language = urlParts.lang.value;
        }

        if(isValidLanguage(language)){
            return language;
        }else{
            var _short = language.substring(0,2);
            if(isValidLanguage(_short)){
                return _short;
            }
        }
        return 'en';
    };

    Module.loadLanguage = function(_lang){
        _lang = _lang || Module.getLanguage();
        var dfd = new Deferred(),
            re = require;
        if(_lang!=='en'){
            re(['xlang/'+_lang],function(langModule){
                i18.setLanguage(langModule);
                dfd.resolve(langModule);
            });
        }else{
            dfd.resolve();
        }
        return dfd;
    };
    return Module;
});
},
'xide/widgets/NativeWidget':function(){
define([
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/widgets/WidgetBase",
    "xide/factory"
], function (dcl,declare, WidgetBase, factory) {
    return dcl(WidgetBase, {
        declaredClass:'xide.widgets.NativeWidget',
        value: "unset",
        _lastValue: null,
        _nativeHandles:false,
        widgetChanged: function (value) {
            this.changed = true;

            if (this.userData) {
                this.userData.changed = true;
            }

            //if (this.nativeWidget) {
                this.setValue(value);
           // }
        },
        setupNativeWidgetHandler: function () {

            var thiz = this;

            if (this.nativeWidget && !this._nativeHandles) {

                this.nativeWidget._added = true;

                if(!this.nativeWidget._started){
                    //console.error('native widget not started : ' + this.nativeWidget.declaredClass);
                    this.valueNode.innerHTML = "";
                    this.valueNode.appendChild(this.nativeWidget.domNode);
                    this.nativeWidget.startup();
                }

                this._nativeHandles = true;


                if(this.nativeWidget._on){


                    //console.log('sub ', thiz.nativeWidget.id + '  ' + this.id);
                    this.nativeWidget._on("change", function (value) {
                        if (thiz._lastValue !== null && thiz._lastValue === value) {
                            return;
                        }
                        thiz._lastValue = value;
                        thiz.widgetChanged(this);

                    });

                }else {

                    this.addHandle("change", this.nativeWidget.on("change", function (value) {
                        if (thiz._lastValue !== null && thiz._lastValue === value) {
                            return;
                        }

                        thiz._lastValue = value;
                        thiz.widgetChanged(this);

                    }));
                }

                this.addHandle("blur", this.nativeWidget.on("blur", function () {
                    thiz.setActive(false);
                }));
                this.addHandle("focus", this.nativeWidget.on("focus", function () {
                    thiz.setActive(true);
                }));
            }
        },
        startup: function () {




            var data = this.userData;
            var type = this.type;
            var label = data.title;
            var value = this.value;
            var $root = $(this.valueNode);
            var thiz = this;

            //console.error('start native widget ',data);
            if(type){

                this.valueNode.innerHTML = "";

                this.titleNode.innerHTML = "";


                if(type ==='CheckBox') {


                    $root = $(this.titleNode);


                    var id = this.id + '_Checkbox';

                    var element = '';
                    element += '<div class="checkbox checkbox-success ">';
                    if (typeof data.icon !== 'undefined') {
                        //element += '<span style="float: left" class="' + data.icon + '"></span>';
                    }
                    element += '<input id="' + id + '" type="checkbox" ' + (value == true ? 'checked' : '') + '>';
                    element += '<label for="' + id + '">';
                    element += this.localize(label) + '</label>';
                    element += '</div>';

                    var $widget = $(element);

                    $root.append($widget);

                    var $nativeWidget = $widget.find('INPUT');
                    this.__on($nativeWidget,'change',null,function(){

                        var _value = $nativeWidget[0].checked;

                        if (thiz._lastValue !== null && thiz._lastValue === _value) {
                            return;
                        }
                        thiz._lastValue = _value;
                        thiz.widgetChanged(_value);
                    });
                }
            }
            this.onReady();
        }
    });
});
},
'xgrid/Selection':function(){
/** @module xgrid/Selection **/
define([
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/utils',
    'dgrid/Selection',
    'dojo/dom-class',
    'dojo/on',
    'dojo/Deferred',
    'xide/lodash',
    'xide/$'
], function (declare,has,types,utils,Selection,domClass,on,Deferred,_,$) {

    /////////////////////////////////////////////////////////////////////
    //
    //  Utils
    //
    //
    /**
     * Event filter
     * @param event
     * @returns {string|boolean}
     */
    function handledEvent(event) {
        // Text boxes and other inputs that can use direction keys should be ignored
        // and not affect cell/row navigation
        var target = event.target;
        return target.type && (event.keyCode === 32);
    }

    /**
     *
     * @param selection to ids
     * @returns {string[]}
     */
    function rows(selection){
        var result = [];
        if(selection && selection.rows){
            selection.rows.forEach(function(row){
                result.push(row.id);
            });
        }
        return result;
    }

    /**
     *
     * @param arrays
     * @returns {*|Array}
     */
    function allArraysAlike(arrays) {
        return _.all(arrays, function(array) {
            return array.length == arrays[0].length && _.difference(array, arrays[0]).length == 0;
        });
    }

    /**
     *
     * @param lastSelection
     * @param newSelection
     * @returns {*|Array}
     */
    function equals(lastSelection,newSelection){
        var cSelected = rows(lastSelection);
        var nSelected = rows(newSelection);
        return allArraysAlike([cSelected,nSelected]);
    }

    /**
     *
     * @param items
     * @param now
     * @param idProperty
     * @returns {boolean}
     */
    function isSame(items,now,idProperty){
        var newSelection = items ? items.map(function(item){
            return item ? item.data || item : {};
        }) : [];
        var idsNew = newSelection.map( function(x){ return x[idProperty]; } );
        var idsNow = now.map( function(x){ return x[idProperty]; } );
        return (idsNew.join(',') === idsNow.join(',') );
    }

    /**
     *
     * @param self {module:xgrid/Base}
     */
    function clearFocused(self){
        $(self.domNode).find('.dgrid-focus').each(function(i,el){
            $(el).removeClass('dgrid-focus');
        });
    }

    var _debug = false;
    var debugSelect = false;
    /**
     * @class module:xgrid/Selection
     */
    var Implementation = {
        _lastSelection:null,
        _lastFocused:null,
        _refreshInProgress:null,
        __lastLast:null,
        __lastFirst:null,
        /**
         * Mute any selection events.
         */
        _muteSelectionEvents:true,
        selectAll:function(filter){
            this.select(this.getRows(filter),null,true,{
                append:false,
                delay:1
            });
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        setState:function(state) {
            state && state.selection && state.selection.selection && this.select(state.selection.selection,null,true,{
                expand:true,
                append:false,
                scrollInto:true
            },'restore');
            return this.inherited(arguments);
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        getState:function(state) {
            state = this.inherited(arguments) || {};
            var selection = this._preserveSelection();
            var thisState = {
                selection:[]
            };
            var collection = this.collection;
            var idProp = collection.idProperty;
            if(selection.selection && idProp){
                _.each(selection.selection,function(item){
                    if(item && item[idProp]) {
                        thisState.selection.push(item[idProp]);
                    }
                });
            }
            if(selection.focused){
                thisState.focused = selection.focused.path;
            }
            state.selection = thisState;
            return state;
        },

        refresh:function(restoreSelection){
            if(this._refreshInProgress){
                return this._refreshInProgress;
            }

            var _restore = restoreSelection !==false ? this._preserveSelection() : null,
                thiz = this,
                active = this.isActive(),
                res = this.inherited(arguments);

            this._refreshInProgress = res;

            res && res.then && res.then(function(){
                thiz._refreshInProgress = null;
                active && _restore && thiz._restoreSelection(_restore,1,!active,'restore');
            });
            return res;
        },
        /**
         * Normalize an item
         * @param what
         * @returns {*}
         * @private
         */
        _normalize:function(what){
            if(!what){
                return null;
            }
            if(!what.element){
                what = this.cell(what);
            }
            if(what && what.row){
                what=what.row;
            }
            return what;
        },
        /**
         * save deselect
         */
        deselectAll:function(){
            if(!this._lastSelection){
                return;
            }
            this.clearSelection();
            this._lastSelection=null;
            this._lastFocused=null;
            $(this.domNode).find('.dgrid-focus').each(function(i,el){
                $(el).removeClass('dgrid-focus');
            });
            this._emit('selectionChanged',{
                selection:[],
                why:"clear",
                source:'code'
            });
        },
        invertSelection:function(items){
            var selection = items || this.getSelection() || [];
            var newSelection = [],
                all = this.getRows();
            _.each(all,function(data){
                if(selection.indexOf(data)===-1){
                    newSelection.push(data);
                }
            });
            return this.select(newSelection,null,true,{
                append:false
            });
        },
        runAction:function(action){
            if(_.isString(action)){
                action = this.getActionStore().getSync(action);
            }
            if(action.command==='File/Select/None'){
                this.deselectAll();
                return true;
            }
            if(action.command==='File/Select/All'){
                this.selectAll();
                return true;
            }
            if(action.command==='File/Select/Invert'){
                return this.invertSelection();
            }
            return this.inherited(arguments);
        },
        _preserveSelection:function(){
            this.__lastSelection = this.getSelection();
            this._lastFocused = this.getFocused();
            return {
                selection : this.getSelection(),
                focused : this.getFocused()
            };
        },
        _restoreSelection:function(what,delay,silent,reason){
            var lastFocused = what ? what.focused : this._lastFocused;
            var lastSelection = what ? what.selection : this.__lastSelection;
            if(_.isEmpty(lastSelection)){
                lastFocused=null;
                this._lastFocused=null;
            }else {
                //restore:
                var dfd = this.select(lastSelection, null, true, {
                    silent: silent != null ? silent : true,
                    append: false,
                    delay: delay !=null ? delay : 0
                },reason);

                if (lastFocused && this.isActive()) {
                    this.focus(this.row(lastFocused));
                }
                return dfd;
            }
        },
        /**
         * get previous item
         * @param from
         * @param domNode
         * @param skipSelected
         * @returns {*}
         */
        getPrevious:function(from,domNode,skipSelected){
            from = from || this.getFocused(domNode);
            from = this._normalize(from);
            var nextNode = this.cell(this._move(from, -1, "dgrid-row"));
            if(nextNode && nextNode.row){
                nextNode = nextNode.row[domNode? 'element' : 'data' ];
                if(skipSelected===true) {
                    if(this.isSelected(nextNode)){
                        //nothing previous here
                        if(from && from.data && from.data == nextNode){
                            return null;
                        }
                        var _nextNode = this.getPrevious(nextNode,domNode,skipSelected);
                        if(_nextNode){
                            return _nextNode;
                        }
                    }
                }
            }
            return nextNode;
        },
        /**
         * get next item
         * @param from
         * @param domNode
         * @param skipSelected
         * @returns {*}
         */
        getNext:function(from,domNode,skipSelected){
            from = from || this.getFocused(domNode);
            from = this._normalize(from);
            var nextNode = this.cell(this._move(from, 1, "dgrid-row"));
            if(nextNode && nextNode.row){
                nextNode = nextNode.row[domNode? 'element' : 'data' ];
                if(skipSelected===true) {
                    if(this.isSelected(nextNode)){
                        //nothing previous here
                        if(from && from.data && from.data == nextNode){
                            return null;
                        }
                        var _nextNode = this.getNext(nextNode,domNode,skipSelected);
                        if(_nextNode){
                            return _nextNode;
                        }
                    }
                }
            }
            return nextNode;
        },
        /**
         *
         * @param filterFunction
         * @returns selection {Object[] | NULL }
         */
        getSelection:function(filterFunction){
            var result = [];
            var collection =this.collection;
            if(collection) {
                for (var id in this.selection) {
                    var item = this.collection.getSync(id);
                    item && result.push(item);
                }
                if (filterFunction) {
                    return result.filter(filterFunction);
                }
            }
            return result;
        },
        /**
         *
         * @param filter
         * @returns {*}
         */
        getSelectedItem:function(filter){
            var _selection = this.getSelection(filter);
            if(_selection.length==1){
                return _selection[0];
            }
            return null;
        },
        /**
         * Override std::postCreate
         * @returns {*}
         */
        postCreate:function(){
            var thiz = this;
            if(this.options[types.GRID_OPTION.CLEAR_SELECTION_ON_CLICK]===true){
                var clickHandler = function(evt) {
                    if (evt && evt.target && domClass.contains(evt.target, 'dgrid-content')) {
                        this.deselectAll();                    }
                }.bind(this);
                this.on("click", function (evt) {
                    clickHandler(evt);
                }.bind(this));
            }
            this.on("dgrid-select", function (data) {
                if(!equals(thiz._lastSelection,data)){
                    thiz._lastSelection=data;
                    thiz._emit('selectionChanged',{
                        selection:thiz.getSelection(),
                        why:"select",
                        source:data.parentType
                    })
                }
            });
            return this.inherited(arguments);
        },
        /**
         * Override dgrid/Selection::_fireSelectionEvents
         * @returns {*}
         * @private
         */
        _fireSelectionEvents:function(){
            if(this._muteSelectionEvents===true){
                return;
            }
            return this.inherited(arguments);
        },
        __select:function(items,toRow,select,dfd,reason){
            _.each(items,function(item){
                if(item) {
                    var _row = this.row(item);
                    if(_row) {
                        this._select(_row, toRow, select);
                    }
                }
            },this);
            dfd && dfd.resolve(items);
            this._muteSelectionEvents=false;
            this._fireSelectionEvents();
            var rows = this.getRows();
            if(rows && rows.length && items && items.length && select && reason && reason!=='mouse'){
                //trigger bounce if we hit
                var _last = items[items.length-1];
                if(rows[rows.length-1] == _last){
                    if(this.__lastLast && this.__lastLast==_last){
                        reason.indexOf('pointer') ===-1 && this._emit('bounced',{
                            direction:1,
                            item:_last
                        });
                        return;
                    }
                    this.__lastLast = _last;
                }else{
                    this.__lastLast = null;
                }


                var _first = items[0];
                if(rows[0] == _first){
                    if(this.__lastFirst && this.__lastFirst==_first){
                        reason.indexOf('pointer') ===-1 && this._emit('bounced',{
                            direction:-1,
                            item:_first
                        })
                        return;
                    }
                    this.__lastFirst = _first;
                }else{
                    this.__lastFirst = null;
                }
            }else {
                this.__lastFirst = null;
            }
        },
        /**
         * Overrides dgrid selection
         * @param mixed
         * @param toRow {object|null} preserve super
         * @param select {boolean|null} preserve super
         * @param options {object}
         * @param options.focus {boolean}
         * @param options.silent {boolean}
         * @param options.append {boolean}
         * @param options.expand {boolean}
         * @param options.scrollInto {boolean}
         * @param reason {string} the origin event's type
         * returns dojo/Deferred
         */
        select:function(mixed,toRow,select,options,reason){
            clearTimeout(this._selectTimer);
            this._selectTimer = null;

            var isMouse = reason ==='mouse',
                isPrioritySelect= isMouse || reason==='update',
                isActive = this.isActive();

            var def  = new Deferred();
            reason = reason  || '';

            //sanitize/defaults
            options = options || {};

            if(isPrioritySelect){
                isActive = true;
            }
            if(isMouse){
                options.focus=true;
            }
            select = select === null ? true : select;
            var delay = options.delay || 0,
                self = this,
                coll = this.collection,
                idProperty = coll.idProperty;

            //silence selection change (batch or state restoring job)
            if(options.silent===true){
                self._muteSelectionEvents=true;
            }

            //normalize to array
            var items = utils.isArray(mixed) ? mixed : [mixed];
            if(_.isEmpty(items)){
                return;
            }
            var _newItems = [];

            //indices to items
            if(_.isNumber(items[0])){
                var rows = self.getRows();
                _.each(items,function(item){
                    _newItems.push(rows[item]);
                });
                items = _newItems;
            }else if(_.isString(items[0])){
                _.each(items,function(item) {
                    var _item = coll.getSync(item);
                    if(_item) {
                        _newItems.push(_item);
                    }
                });

                items = _newItems;
            }else if(items && items[0] && items[0].tagName){
                _.each(items,function(item){
                    _newItems.push(self.row(item).data);
                });
                items = _newItems;
            }

            if(!items.length){
                if( false ) {
                    _debug && console.log('nothing to select!');
                }
                def.resolve();
                return def;
            }


            if( false ) {
                debugSelect && console.log('selected : ', _.map(items, "name"));
            }

            var _last = this._lastSelection ? this._lastSelection.rows : [];
            var now = _last.map(function(x){return x.data;});

            var isEqual=isSame(items,now,idProperty);

            //store update
            if(reason==='update' && select){
                options.focus=true;
                options.append=false;
                options.delay=1;
                //this.focus();
            }

            if(reason==='dgrid-cellfocusin'){
                options.focus=true;
            }

            //clear previous selection
            if(options.append===false && select && !isEqual){
                self.clearSelection(items);
                clearFocused(self);
            }

            if(isEqual && (reason==='update' || reason === 'dgrid-cellfocusin')){
                if(options.focus){
                    clearFocused(self);
                    self.focus(items[0]);
                }
                return;
            }

            //focus
            if(options.focus===true){
                if(options.expand){
                    if(!self.isRendered(items[0])){
                        self._expandTo(items[0]);
                    }
                }
            }
            if(options.expand){
                if(!self.isRendered(items[0])){
                    self._expandTo(items[0]);
                }
            }
            if(options.scrollInto && reason!=='restore'){
                var row = this.row(items[0]);
                if(row.element){
                    row.element.scrollIntoView();
                }
            }

            if(delay && items.length) {
                this._selectTimer = setTimeout(function () {
                    if(self.destroyed || !self.collection){
                        return;
                    }
                    if(options.append===false) {
                        self.clearSelection();
                    }
                    clearFocused(self);
                    self.focus(items[0],false);
                    self.__select(items,toRow,select,def,reason);
                }, delay);
            }else{
                self.__select(items,toRow,select,def,reason);
            }
            return def;
        },

        _setLast:function(selection){
            var _ids = [];
            for (var i = 0; i < selection.length; i++) {
                var obj = selection[i];
                _ids.push(this.collection.getIdentity(obj));
            }
        },
        isExpanded: function (item) {
            item  = this._normalize('root');
            return !!this._expanded[item.id];
        },
        _expandTo:function(item){
            if(!item){
                return;
            }
            var store = this.collection;
            if(_.isString(item)){
                item = store.getSync(item);
            }
            var parent = store.getSync(item[store.parentField]) || item.getParent ? item.getParent() : null;
            if(parent){
                if(!this.isRendered(parent)) {
                    this._expandTo(parent);
                }else{
                    if(!this.isExpanded(parent)){
                        this.expand(parent, true, true);
                    }
                    if(!this.isExpanded(item)){
                        this.expand(item, true, true);
                    }
                }
            }
        },
        startup: function () {
            var result = this.inherited(arguments);
            //we want keyboard navigation also when nothing is selected
            this.addHandle('keyup',on(this.domNode, 'keyup', function (event) {
                // For now, don't squash browser-specific functionality by letting
                // ALT and META function as they would natively
                if (event.metaKey || event.altKey) {
                    return;
                }
                var handler = this['keyMap'][event.keyCode];
                // Text boxes and other inputs that can use direction keys should be ignored
                // and not affect cell/row navigation
                if (handler && !handledEvent(event) && this.getSelection().length == 0) {
                    handler.call(this, event);
                }
            }.bind(this)));
            return result;
        }
    };
    //package via declare
    var _class = declare('xgrid.Selection',Selection,Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'xide/widgets/ActionToolbar':function(){
/** @module xide/widgets/ActionToolbar **/
define([
    "xide/widgets/ActionToolbar4"
], function (ActionToolbar4) {
    return ActionToolbar4;
});


},
'xace/views/Editor':function(){
/** @module xace/views/Editor **/
define([
    'dcl/dcl',
    'xide/types',
    'xide/utils',
    'xaction/ActionProvider',
    'xace/views/ACEEditor',
    'xace/views/_Actions',
    'xaction/Toolbar',
    "xide/mixins/PersistenceMixin"
], function (dcl, types, utils, ActionProvider, ACEEditor, _Actions, Toolbar, PersistenceMixin) {

    var Persistence = dcl([PersistenceMixin.dcl], {
        declaredClass: 'xace.views.EditorPersistence',
        defaultPrefenceTheme: 'idle_fingers',
        defaultPrefenceFontSize: 14,
        saveValueInPreferences: true,
        getDefaultPreferences: function () {
            return utils.mixin(
                {
                    theme: this.defaultPrefenceTheme,
                    fontSize: this.defaultPrefenceFontSize
                },
                this.saveValueInPreferences ? {value: this.get('value')} : null);
        },
        onAfterAction: function (action) {
            var _theme = this.getEditor().getTheme();
            this.savePreferences({
                theme: _theme.replace('ace/theme/', ''),
                fontSize: this.getEditor().getFontSize()
            });
            return this.inherited(arguments);
        },
        /**
         * Override id for pref store:
         * know factors:
         *
         * - IDE theme
         * - per bean description and context
         * - by container class string
         * - app / plugins | product / package or whatever this got into
         * -
         **/
        toPreferenceId: function (prefix) {
            prefix = prefix;
            if (!prefix) {
                var body = $('body'), prefix = 'xTheme-', search;
                _.each(['blue', 'gray', 'white', 'transparent'], function (theme) {
                    search = prefix + theme
                    if (body.hasClass(search)) {
                        prefix = search;
                    }
                });
            }
            return (prefix || this.cookiePrefix || '') + '_xace';
        },
        getDefaultOptions: function () {
            //take our defaults, then mix with prefs from store,
            var _super = this.inherited(arguments),
                _prefs = this.loadPreferences(null);
            (_prefs && utils.mixin(_super, _prefs) ||
            //else store defaults
            this.savePreferences(this.getDefaultPreferences()));
            return _super;
        }
    });
    /**
     * Default Editor with all extras added : Actions, Toolbar and ACE-Features
     @class module:xgrid/Base
     */
    var Module = dcl([_Actions, ACEEditor, ActionProvider.dcl, Persistence, Toolbar.dcl], {
        toolbarArgs:{
            actionFilter:{}
        },
        getBreadcrumbPath: function () {
            if (this.item) {
                return {
                    path: utils.replaceAll('/', '', this.item.mount) + ':/' + this.item.path.replace('./', '/')
                }
            }
        },
        tabOrder: {
            'Home': 100,
            'View': 50,
            'Settings': 20
        },
        menuOrder: {
            'File': 110,
            'Edit': 100,
            'View': 90,
            'Block': 50,
            'Settings': 20,
            'Navigation': 10,
            'Editor': 9,
            'Step': 5,
            'New': 4,
            'Window': 3,
            'Help': 2
        },
        declaredClass: 'xace/views/Editor',
        options: null,
        /**
         * The icon class when doing any storage operation
         * @member loadingIcon {string}
         */
        loadingIcon: 'fa-spinner fa-spin',
        /**
         * The original icon class
         * @member iconClassNormal {string}
         */
        iconClassNormal: 'fa-code',
        templateString: '<div attachTo="template" class="grid-template widget" style="width: 100%;height: 100%;overflow: hidden !important;position: relative;padding: 0px;margin: 0px">' +
        '<div attachTo="header" class="view-header row bg-opaque" style="height: auto;width:inherit;height:auto;min-height: 30px"></div>' +
        '<div attachTo="aceNode" class="view-body row" style="height:100%;width: 100%;position: relative;"></div>' +
        '<div attachTo="footer" class="view-footer" style="position: absolute;bottom: 0px;width: 100%"></div></div>',
        getContent: function (item, onSuccess, onError) {
            if (!this.storeDelegate) {
                onError && onError('Editor::getContent : Have no store delegate!');
            } else {
                this.storeDelegate.getContent(function (content) {
                    onSuccess(content);
                }, item || this.item);
            }
        },
        saveContent: function (value, onSuccess, onError) {
            var thiz = this;
            this.set('iconClass', 'fa-spinner fa-spin');
            var _value = value || this.get('value');
            if (!_value) {
                console.warn('Editor::saveContent : Have nothing to save, editor seems empty');
            }
            if (!this.storeDelegate) {
                if (onError) {
                    onError('Editor::saveContent : Have no store delegate!');
                }
                return false;
            } else {
                return this.storeDelegate.saveContent(_value, function () {
                    thiz.set('iconClass', thiz.iconClassNormal);
                    thiz.lastSavedContent = _value;
                    thiz.onContentChange(_value);
                    var struct = {
                        path: thiz.options.filePath,
                        item: thiz.item,
                        content: _value,
                        editor: thiz
                    };
                    thiz.publish(types.EVENTS.ON_FILE_CONTENT_CHANGED, struct, thiz);
                }, null, thiz.item);
            }
        },
        addCommands: function () {
            var aceEditor = this.getAce(),
                thiz = this;

            var config = ace.require("ace/config");
            config.init();
            var commands = [];
            if (this.hasHelp) {
                commands.push({
                    name: "showKeyboardShortcuts",
                    bindKey: {win: "Ctrl-Alt-h", mac: "Command-Alt-h"},
                    exec: function (editor) {
                        thiz.showHelp(editor);
                    }
                });
            }
            if (this.hasConsole) {
                commands.push({
                    name: "gotoline",
                    bindKey: {win: "Ctrl-L", mac: "Command-L"},
                    exec: function (editor, line) {
                        if (typeof line == "object") {
                            var arg = this.name + " " + editor.getCursorPosition().row;
                            editor.cmdLine.setValue(arg, 1);
                            editor.cmdLine.focus();
                            return;
                        }
                        line = parseInt(line, 10);
                        if (!isNaN(line))
                            editor.gotoLine(line);
                    },
                    readOnly: true
                });
            }
            aceEditor.commands.addCommands(commands);
        },
        getWebRoot: function () {
            return this.ctx.getResourceManager().getVariable(types.RESOURCE_VARIABLES.APP_URL);
        },
        resize: function () {
            return this._resize();
        },
        onResize: function () {
            return this._resize();
        },
        _resize: function () {
            var parent = this.getParent();
            if (!this._isMaximized) {
                parent && utils.resizeTo(this, parent, true, true);
            } else {
                utils.resizeTo(this, this._maximizeContainer, true, true);
            }

            var thiz = this,
                toolbar = this.getToolbar(),
                noToolbar = false,
                topOffset = 0,
                aceNode = $(this.aceNode);

            if (this._isMaximized && toolbar) {
                utils.resizeTo(toolbar, this.header, true, true);
            }

            if (!toolbar || (toolbar && toolbar.isEmpty())) {
                noToolbar = true;
            } else {
                if (toolbar) {
                    utils.resizeTo(toolbar, this.header, false,true);
                    toolbar.resize();
                    utils.resizeTo(this.header,toolbar,true,false);
                }
            }

            var totalHeight = $(thiz.domNode).height(),
                topHeight = noToolbar == true ? 0 : $(thiz.header).height(),
                footerHeight = $(thiz.footer).height(),
                finalHeight = totalHeight - topHeight - footerHeight;

            if (toolbar) {
                finalHeight -= 4;
            }
            if (finalHeight > 50) {
                aceNode.height(finalHeight + 'px');
            } else {
                aceNode.height('inherited');
            }
        },
        __set: function (what, value) {
            var _res = this.inherited(arguments);
            if (what === 'iconClass') {
                var _parent = this._parent;
                if (_parent && _parent.icon) {
                    this._parent.icon(value);
                }
            }
            return _res;
        },
        __get: function (what) {
            if (what === 'value') {
                var self = this,
                    editor = self.getEditor(),
                    session = editor ? editor.session : null;
                return session ? session.getValue() : null;
            }
            return this.inherited(arguments);
        }
    });

    //pass through defaults
    Module.DEFAULT_PERMISSIONS = _Actions.DEFAULT_PERMISSIONS;

    return Module;

});
},
'dstore/Promised':function(){
define([
	'dojo/_base/declare',
	'dojo/Deferred',
	'./QueryResults',
	'dojo/when'
], function (declare, Deferred, QueryResults, when) {
	// module:
	//		this is a mixin that can be used to provide async methods,
	// 		by implementing their sync counterparts
	function promised(method, query) {
		return function() {
			var deferred = new Deferred();
			try {
				deferred.resolve(this[method].apply(this, arguments));
			} catch (error) {
				deferred.reject(error);
			}
			if (query) {
				// need to create a QueryResults and ensure the totalLength is
				// a promise.
				var queryResults = new QueryResults(deferred.promise);
				queryResults.totalLength = when(queryResults.totalLength);
				return queryResults;
			}
			return deferred.promise;
		};
	}
	return declare(null, {
		get: promised('getSync'),
		put: promised('putSync'),
		add: promised('addSync'),
		remove: promised('removeSync'),
		fetch: promised('fetchSync', true),
		fetchRange: promised('fetchRangeSync', true)
	});
});

},
'dojo/regexp':function(){
define(["./_base/kernel", "./_base/lang"], function(dojo, lang){

// module:
//		dojo/regexp

var regexp = {
	// summary:
	//		Regular expressions and Builder resources
};
lang.setObject("dojo.regexp", regexp);

regexp.escapeString = function(/*String*/str, /*String?*/except){
	// summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	// summary:
	//		Builds a regular expression that groups subexpressions
	// description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return regexp.group(b.join("|"), nonCapture); // String
};

regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return regexp;
});

},
'dojo/_base/config':function(){
define(["../has", "require"], function(has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// useCustomLogger: Anything?
	//		If set to a value that evaluates to true such as a string or array and
	//		isDebug is true and Firebug is not available or running, then it bypasses
	//		the creation of Firebug Lite allowing you to define your own console object.
	useCustomLogger: undefined,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if( 1 ){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		var global = (function () { return this; })();
		result =  1  ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
});


},
'xide/manager/Application_UI':function(){
/** module:xide/manager/Application_UI **/
define([
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/has',
    'xide/registry',
    'xide/editor/Default',
    "xide/mixins/PersistenceMixin",
    "dojo/dom-geometry",
    'xdojo/has!xcf-ui?xide/editor/Registry',
    'xfile/views/FileConsole',
    'dojo/window',
    'xide/editor/Default',
    'require',
    'require',
    'xide/manager/Application_XFILE',
    'require',
    'xace/views/Editor'

], function (dcl,utils, types, has,registry,ACEEditor,PersistenceMixin,domGeometry,Registry,FileConsole,
             win, Default, Application_XIDEVE, Application_XNODE, Application_XFILE, Application_XBLOX, Editor) {

    var bases = [];
    Application_XIDEVE && bases.push(Application_XIDEVE);
    Application_XNODE && bases.push(Application_XNODE);
    Application_XFILE && bases.push(Application_XFILE);
    Application_XBLOX && bases.push(Application_XBLOX);

    var Persistence = dcl([PersistenceMixin.dcl], {

        declaredClass:'xcf.manager.ApplicationPersistence',
        defaultPrefenceTheme: 'idle_fingers',
        defaultPrefenceFontSize: 14,
        saveValueInPreferences: true,
        cookiePrefix:'_xcf_application',
        getDefaultPreferences: function () {
            return utils.mixin(
                {
                    theme: this.defaultPrefenceTheme,
                    fontSize: this.defaultPrefenceFontSize
                },
                this.saveValueInPreferences ? {

                } : null);

        },
        onAfterAction: function (action) {
            this.savePreferences({});
            return this.inherited(arguments);
        },
        /**
         * Override id for pref store:
         * know factors:
         *
         * - IDE theme
         * - per bean description and context
         * - by container class string
         * - app / plugins | product / package or whatever this got into
         * -
         **/
        toPreferenceId: function (prefix) {
            prefix = '';
            return (prefix || this.cookiePrefix || '') + '_xcf_application';
        },
        getDefaultOptions: function () {
            //take our defaults, then mix with prefs from store,
            var _super = this.inherited(arguments);
            var _prefs = this.loadPreferences(null);
            (_prefs && utils.mixin(_super, _prefs) || this.savePreferences(this.getDefaultPreferences()));
            return _super;
        }
    });
    /**
     * @class module:xide/manager/Application_UI
     * @augments module:xide/manager/Application
     */
    return dcl(bases,{
        declaredClass:"xide.manager.Application_UI",
        mainView: null,
        leftLayoutContainer: null,
        rightLayoutContainer: null,
        showGUI: true,
        showFiles: true,
        lastPane: null,
        _lastWizard: null,
        _statusMessageTimer:null,
        _maximized:false,
        openFile:function(args){
            var self = this;
            var _editor=args.editor;
            var editor = Registry.getEditor(_editor) || Registry.getDefaultEditor({
                    path:args.file
                }) || Registry.getEditor('Default Editor');

            var _require = window['eRequire'];
            //var app = _require('remote').require('app');
            var app = _require('electron').remote.app;
            //var BrowserWindow = _require('remote').require('browser-window');
            var BrowserWindow = _require('electron').remote.BrowserWindow;
            var wind = BrowserWindow.getFocusedWindow() || BrowserWindow.mainWindow;
            wind && wind.setTitle(args.file);

            if(editor){
                var editorInstance =  editor.onEdit({
                    path:args.file,
                    mount:'__direct__',
                    getPath:function(){
                        return this.path;
                    }
                });
                if(editorInstance._on) {
                    this.ctx.getWindowManager().registerView(editorInstance, true);
                }else if(editorInstance.then){
                    editorInstance.then(function(instance){
                        self.ctx.getWindowManager().registerView(instance, true);
                    });
                }
            }else{
                console.error('--have no editor ',args.editor);
            }
        },
        /***
         * Register custom types
         */
        registerCustomTypes: function () {},
        /**
         * Register new editors for xfile
         */
        registerEditorExtensions: function () {

            var ctx = this.ctx;

            Default.Implementation.ctx = ctx;
            Default.ctx = ctx;

            //sample default text editor open function, not needed
            var editInACE = function (item, owner) {
                var where = null;
                if (owner) {
                    //where = owner ? owner.newTarget : null;
                    if (_.isFunction(owner.newTarget)) {
                        where = owner.newTarget({
                            title: item.name,
                            icon: 'fa-code'
                        });
                    }
                }
                return Default.Implementation.open(item, where, null, null, owner);
            };

            ctx.registerEditorExtension('Default Editor', '*', 'fa-code', this, false, editInACE, ACEEditor, {
                updateOnSelection: false,
                leftLayoutContainer: this.leftLayoutContainer,
                ctx: ctx,
                defaultEditor: true
            });
            if(typeof JSONEditor!=='undefined') {
                ctx.registerEditorExtension('JSON Editor', 'json', 'fa-code', this, true, null, JSONEditor, {
                    updateOnSelection: false,
                    leftLayoutContainer: this.leftLayoutContainer,
                    ctx: ctx,
                    registerView: true
                });
            }


            types.registerCustomMimeIconExtension('cfhtml', 'fa-laptop');

            this.registerSplitEditors && this.registerSplitEditors();
        },
        getActions:function(){

            var result = [];
            var thiz = this;

            function collapseNavigation(force){
                var panel = thiz.ctx.mainView.layoutLeft;
                if(!panel){
                    return;
                }
                var splitter = panel.getSplitter();
                if(splitter) {
                    if (splitter.isCollapsed()) {
                        splitter.expand() && console.log('expand');

                    }else{
                        splitter.collapse(0,0) && console.log('collapse');
                    }
                }
            }
            if(has('electronx')){
                var _require = window['eRequire'],
                    electron = _require('electron'),
                    frame = electron.webFrame;

                function zoom(zoomStep){
                    var now = frame.getZoomFactor();
                    frame.setZoomFactor(now +zoomStep);
                }


                result.push(this.ctx.createAction({
                    label: 'Zoom In',
                    command: 'Window/Zoom In',
                    icon: 'fa-search-plus',
                    keycombo: ['ctrl +'],
                    tab: 'Home',
                    group: 'Window',
                    owner: thiz,
                    handler:function(){
                        zoom(0.1);
                    },
                    mixin: {
                        addPermission: true
                    },
                    onCreate:function(action){
                        action.setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU,false);
                    }
                }));

                result.push(this.ctx.createAction({
                    label: 'Zoom Out',
                    command: 'Window/Zoom Out',
                    icon: 'fa-search-minus',
                    keycombo: ['ctrl -'],
                    tab: 'Home',
                    group: 'Window',
                    owner: thiz,
                    handler:function(){
                        zoom(-0.1);
                    },
                    mixin: {
                        addPermission: true
                    },
                    onCreate:function(action){
                        action.setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU,false);
                    }
                }));

                if(window['eRequire']) {
                    result.push(this.ctx.createAction({
                        label: 'Open In Browser',
                        command: 'Window/Open In Browser',
                        icon: 'fa-share',
                        tab: 'Home',
                        group: 'Window',
                        owner: thiz,
                        handler: function () {
                            var _require = window['eRequire'];
                            var shell = _require("electron").shell;
                            shell.openExternal(location.href);
                        },
                        mixin: {
                            addPermission: true
                        },
                        onCreate: function (action) {
                            action.setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, false);
                        }
                    }));
                }
            }

            result.push(this.ctx.createAction({
                label: 'Show Navigation',
                command: 'Window/Navigation',
                icon: 'fa-cube',
                keycombo: ['ctrl f11'],
                tab: 'Home',
                group: 'Window',
                owner: thiz,
                handler:collapseNavigation,
                mixin: {
                    addPermission: true
                },
                onCreate:function(action){
                    action.setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU,{
                        label:'Show Nav',
                        group:'Organize'
                    });
                }
            }));


            result.push(this.ctx.createAction({
                label:'Maximize',
                command:'View/Maximize',
                icon:types.ACTION_ICON.MAXIMIZE,
                keycombo:['alt f11'],
                tab:'Home',
                group:'View',
                owner:thiz,
                mixin:{
                    addPermission:true
                },
                handler:function(){

                    var toolbar = thiz.ctx.mainView.getToolbar();

                    if(thiz._maximized) {
                        collapseNavigation();
                        if(toolbar){
                            toolbar.expand();
                        }
                        thiz._maximized = false;
                    }else{
                        collapseNavigation(true);
                        thiz._maximized = true;
                        if(toolbar){
                            toolbar.collapse();
                        }
                    }
                    setTimeout(function(){
                        thiz.ctx.mainView.resize();
                        thiz.publish(types.EVENTS.RESIZE);
                    },100);
                }
            }));

            if(this.createAppActions){
                result = result.concat(this.createAppActions());
            }

            return result;
        },
        getConsoleActions:function(where){
            var ctx = this.ctx,
                self = this;
            var windowManager = ctx.getWindowManager();
            //	adds 3 shells
            var result = [],
                shells = [
                    ["Javacript", "fa-terminal", 'javascript',null,null,'return 2'],
                    ["Bash-Shell", "fa-terminal", 'sh',null,null,'ls -l --color=always'],
                    ["PHP-Shell", "fa-code", 'php',null,null,'<?php \n\n>']
                ];
            function createShell(action) {
                var mainView = ctx.mainView;
                var container  = where || mainView.layoutCenter;
                var parent = windowManager.createTab(action.label,action.icon,container);
                var shell = utils.addWidget(FileConsole.createShellViewClass(), {
                    type: action.shellType,
                    title: action.label,
                    icon: action.icon,
                    ctx:ctx,
                    owner:self,
                    value:action.value
                }, null,parent,true);

                var handlerClass = FileConsole.createShellViewDelegate();
                shell.delegate = new handlerClass();
                return shell;
            }
            function mkAction(title, icon, type, owner, handler,value) {
                var _action =
                {
                    label: title,
                    command: "Window/" + title,
                    icon: icon || 'fa-code',
                    tab: "Home",
                    group: 'View',
                    handler: handler || createShell,
                    mixin: {
                        addPermission: true,
                        shellType: type,
                        value:value
                    },
                    owner: self
                };
                result.push(ctx.createAction(_action));
            }
            for(var i = 0 ; i < shells.length ; i++){
                mkAction.apply(self,shells[i]);
            }
            return result;
        },
        getTheme:function(){
            return this.ctx.getSettingsManager().getSetting('theme');
        },
        getThemeActions: function () {
            var result = [];
            var thiz = this,
                ctx = thiz.ctx;

            // Function to reload page with specified theme, rtl, and a11y settings
            function setUrl(theme, rtl, a11y) {

                var aParams = utils.getUrlArgs(location.href);
                var _newUrl = "?theme=" + theme + (rtl ? "&dir=rtl" : "") + (a11y ? "&a11y=true" : "");
                if (aParams) {
                    _.each(aParams, function (value, key) {
                        if (key !== 'theme') {
                            _newUrl += '&' + key + '=' + value;
                        }
                    });
                }
                location.search = _newUrl;
            }

            //in between theme action handler
            function changeTheme(action) {
                var theme = action.theme;
                ctx.getSettingsManager().write2(null, '.',
                    {
                        id: 'theme'
                    },{
                        value:theme
                    }, true, null
                ).then(function(){
                    location.reload();
                });
            }

            //default action props
            var defaults = {
                    tab: "Window",
                    group: 'View',
                    handler: has("xcf") ?  changeTheme :function(action){
                        setUrl(action.value);
                    },
                    owner: this
                },
                mixin = {
                    addPermission: true,
                    actionType : types.ACTION_TYPE.SINGLE_TOGGLE
                },
                root = 'Window/IDE-Theme/',
                icon = 'fa-paint-brush';

            //factory
            function _createAction(item){
                var parts = item.split('|'),
                    label = parts[0],
                    theme = parts[1];

                result.push(ctx.createActionShort(label,root + label,icon,defaults,utils.mixin({theme:theme,value:theme},mixin)));
            }

            //loop with factory
            _.each([
                'Dark|transparent',
                'White|white',
                'Blue Transparent|blue',
                'Gray|gray'
            ],_createAction);

            return result;
        },
        /**
         * Does all
         * @returns {*}
         */
        init:function(){

            this.ctx.router =

            this.ctx.addActions(this.getActions());
            this.ctx.addActions(this.getConsoleActions(this.ctx.permissions));
            this.ctx.addActions(this.getThemeActions());
            return this.inherited(arguments);
        },
        /***********************************************************************/
        /*
         * Window utils
         */
        resizeToNode: function (parent) {
            if (parent != null) {
                var parentO = dojo.byId(parent);
                if (parentO) {
                    var size = domGeometry.getMarginBox(parentO);
                    var dstHeight = size.h;
                    dstHeight -= 20;
                    var mainContainer = registry.byId("main");
                    if (mainContainer) {
                        mainContainer.containerNode.style.height = dstHeight + "px";
                        mainContainer.resize();
                        setTimeout(function () {
                            mainContainer.resize();
                        }, 300);
                    }
                }
            }
        },
        /**
         *
         */
        repaint: function () {
            /*
            if (!this.mainView) {
                return;
            }
            var winSize = win.getBox();
            var dstHeight = winSize.h;
            var mainContainer = this.mainView.layoutMain;
            if (mainContainer) {
                mainContainer.containerNode.style.height = dstHeight + "px";
                mainContainer.resize();
                setTimeout(function () {
                    mainContainer.resize();
                }, 300);
            }
            */
        }
    });
});

},
'xide/data/Model':function(){
define([
	'dcl/dcl',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/Deferred',
	'dojo/aspect',
	'dojo/when'
], function (dcl,declare, lang, Deferred, aspect, when) {

	function getSchemaProperty(object, key) {
		// this function will retrieve the individual property definition
		// from the schema, for the provided object and key
		var definition = object.schema[key];
		if (definition !== undefined && !(definition instanceof Property)) {
			definition = new Property(definition);
			definition._parent = object;
		}
		if (definition) {
			definition.name = key;
		}
		return definition;
	}

	function validate(object, key) {
		// this performs validation, delegating validation, and coercion
		// handling to the property definitions objects.
		var hasOwnPropertyInstance,
			property = object.hasOwnProperty('_properties') && object._properties[key];
		
		hasOwnPropertyInstance = property;

		if (!property) {
			// or, if we don't our own property object, we inherit from the schema
			property = getSchemaProperty(object, key);
			if (property && property.validate) {
				property = lang.delegate(property, {
					_parent: object,
					key: key
				});
			}
		}

		if (property && property.validate) {
			return when(property.validate(), function (isValid) {
				if (!isValid) {
					// errors, so don't perform set
					if (!hasOwnPropertyInstance) {
						// but we do need to store our property
						// instance if we don't have our own
						(object.hasOwnProperty('_properties') ?
							object._properties :
							object._properties = new Hidden())[key] = property;
					}
				}
				return isValid;
			});
		}
		return true;
	}

	function whenEach(iterator) {
		// this is responsible for collecting values from an iterator,
		// and waiting for the results if promises are returned, returning
		// a new promise represents the eventual completion of all the promises
		// this will consistently preserve a sync (non-promise) return value if all
		// sync values are provided
		var deferred;
		var remaining = 1;
		// start the iterator
		iterator(function (value, callback, key) {
			if (value && value.then) {
				// it is a promise, have to wait for it
				remaining++;
				if (!deferred) {
					// make sure we have a deferred
					deferred = new Deferred();
				}
				value.then(function (value) {
					// result received, call callback, and then indicate another item is done
					doneItem(callback(value, key));
				}).then(null, deferred.reject);
			} else {
				// not a promise, just a direct sync callback
				callback(value, key);
			}
		});
		if (deferred) {
			// if we have a deferred, decrement one more time
			doneItem();
			return deferred.promise;
		}
		function doneItem() {
			// called for each promise as it is completed
			remaining--;
			if (!remaining) {
				// all done
				deferred.resolve();
			}
		}
	}
	var slice = [].slice;

	var Model = declare('xide/data/Model',null,{
		//	summary:
		//		A base class for modelled data objects.

		//	schema: Object | dstore/Property
		//		A hash map where the key corresponds to a property definition. 
		//		This can be a string corresponding to a JavaScript
		//		primitive values (string, number, boolean), a constructor, a
		//		null (to allow any type), or a Property object with more advanced
		//		definitions.
		schema: {},

		//	additionalProperties: boolean
		//		This indicates whether properties are allowed that are not 
		//		defined in the schema.
		additionalProperties: true,

		//	_scenario: string
		//		The scenario that is used to determine which validators should
		//		apply to this model. There are two standard values for _scenario,
		//		"insert" and "update", but it can be set to any arbitrary value
		//		for more complex validation scenarios.
		_scenario: 'update',

		constructor: function (options) {
			this.init(options);
		},

		refresh:function(silent){

			var _store = this._store;
			_store && _store.refreshItem(this,silent);

		},
		getStore:function(){
			return this._store;
		},

		init: function (values) {
			// if we are being constructed, we default to the insert scenario
			this._scenario = 'insert';
			// copy in the default values
			values = this._setValues(values);

			// set any defaults
			for (var key in this.schema) {
				var definition = this.schema[key];
				if (definition && typeof definition === 'object' && 'default' in definition &&
						!values.hasOwnProperty(key)) {
					var defaultValue = definition['default'];
					values[key] = typeof defaultValue === 'function' ? defaultValue.call(this) : defaultValue;
				}
			}
			
		},

		_setValues: function (values) {
			return lang.mixin(this, values);
		},

		_getValues: function () {
			return this._values || this;
		},

		save: function (/*Object*/ options) {
			//	summary:
			//		Saves this object, calling put or add on the attached store.
			//	options.skipValidation:
			//		Normally, validation is performed to ensure that the object
			//		is not invalid before being stored. Set `skipValidation` to
			//		true to skip it.
			//	returns: any

			var object = this;
			return when((options && options.skipValidation) ? true : this.validate(), function (isValid) {
				if (!isValid) {
					throw object.createValidationError(object.errors);
				}
				var scenario = object._scenario;
				// suppress any non-date from serialization output
				object.prepareForSerialization();
				return object._store && when(object._store[scenario === 'insert' ? 'add' : 'put'](object),
						function (returned) {
					// receive any updates from the server
					object.set(returned);
					object._scenario = 'update';
					return object;
				});
			});
		},

		remove: function () {
			var store = this._store;
			return store.remove(store.getIdentity(this));
		},

		prepareForSerialization: function () {
			//	summary:
			//		This method is responsible for cleaing up any properties on the instance
			//		object to ensure it can easily be serialized (by JSON.stringify at least)
			this._scenario = undefined;
			if (this._inherited) {
				this._inherited.toJSON = toJSONHidden;
			}
		},

		createValidationError: function (errors) {
			//	summary:
			//		This is called when a save is attempted and a validation error was found.
			//		This can be overriden with locale-specific messages
			//	errors:
			//		Errors that were found in validation
			return new Error('Validation error');
		},

		property: function (/*String...*/ key, nextKey) {
			//	summary:
			//		Gets a new reactive property object, representing the present and future states
			//		of the provided property. The returned property object gives access to methods for changing,
			//		retrieving, and observing the property value, any validation errors, and property metadata.
			//	key: String...
			//		The name of the property to retrieve. Multiple key arguments can be provided
			//		nested property access.

			// create the properties object, if it doesn't exist yet
			var properties = this.hasOwnProperty('_properties') ? this._properties :
				(this._properties = new Hidden());
			var property = properties[key];
			// if it doesn't exist, create one, delegated from the schema's property definition
			// (this gives an property instance, owning the current property value and listeners,
			// while inheriting metadata from the schema's property definitions)
			if (!property) {
				property = getSchemaProperty(this, key);
				// delegate, or just create a new instance if no schema definition exists
				property = properties[key] = property ? lang.delegate(property) : new Property();
				property.name = key;
				// give it the correct initial value
				property._parent = this;
			}
			if (nextKey) {
				// go to the next property, if there are multiple
				return property.property.apply(property, slice.call(arguments, 1));
			}
			return property;
		},

		get: function (/*string*/ key) {
			// TODO: add listener parameter back in
			//	summary:
			//		Standard get() function to retrieve the current value
			//		of a property, augmented with the ability to listen
			//		for future changes

			var property, definition = this.schema[key];
			// now we need to see if there is a custom get involved, or if we can just
			// shortcut to retrieving the property value
			definition = property || this.schema[key];
			if (definition && definition.valueOf &&
					(definition.valueOf !== simplePropertyValueOf || definition.hasCustomGet)) {
				// we have custom get functionality, need to create at least a temporary property
				// instance
				property = property || (this.hasOwnProperty('_properties') && this._properties[key]);
				if (!property) {
					// no property instance, so we create a temporary one
					property = lang.delegate(getSchemaProperty(this, key), {
						name: key,
						_parent: this
					});
				}
				// let the property instance handle retrieving the value
				return property.valueOf();
			}
			// default action of just retrieving the property value
			return this._getValues()[key];
		},

		set: function (/*string*/ key, /*any?*/ value) {
            //	summary:
			//		Only allows setting keys that are defined in the schema,
			//		and remove any error conditions for the given key when
			//		its value is set.
			if (typeof key === 'object') {
				startOperation();
				try {
					for (var i in key) {
						value = key[i];
						if (key.hasOwnProperty(i) && !(value && value.toJSON === toJSONHidden)) {
							this.set(i, value);
						}
					}
				} finally {
					endOperation();
				}
				return;
			}
			var definition = this.schema[key];
			if (!definition && !this.additionalProperties) {
				// TODO: Shouldn't this throw an error instead of just giving a warning?
				return console.warn('Schema does not contain a definition for', key);
			}
			var property = this.hasOwnProperty('_properties') && this._properties[key];
			if (!property &&
					// we need a real property instance if it is an object or if we have a custom put method
					((value && typeof value === 'object') ||
						(definition && definition.put !== simplePropertyPut))) {
				property = this.property(key);
			}
			if (property) {
				// if the property instance exists, use this to do the set
				property.put(value);
			} else {
				if (definition && definition.coerce) {
					// if a schema definition exists, and has a coerce method,
					// we can use without creating a new instance
					value = definition.coerce(value);
				}
				// we can shortcut right to just setting the object property
				this._getValues()[key] = value;
				// check to see if we should do validation
				if (definition && definition.validateOnSet !== false) {
					validate(this, key);
				}
			}

			return value;
		},

		observe: function (/*string*/ key, /*function*/ listener, /*object*/ options) {
			//	summary:
			//		Registers a listener for any changes in the specified property
			//	key:
			//		The name of the property to listen to
			//	listener:
			//		Function to be called for each change
			//	options.onlyFutureUpdates
			//		If this is true, it won't call the listener for the current value,
			//		just future updates. If this is true, it also won't return
			//		a new reactive object
			return this.property(key).observe(listener, options);
		},

		validate: function (/*string[]?*/ fields) {
			//	summary:
			//		Validates the current object.
			//	fields:
			//		If provided, only the fields listed in the array will be
			//		validated.
			//	returns: boolean | dojo/promise/Promise
			//		A boolean or a promise that resolves to a boolean indicating whether
			//		or not the model is in a valid state.

			var object = this,
				isValid = true,
				errors = [],
				fieldMap;

			if (fields) {
				fieldMap = {};
				for (var i = 0; i < fields.length; i++) {
					fieldMap[i] = true;
				}
			}
			return when(whenEach(function (whenItem) {
				// iterate through the keys in the schema.
				// note that we will always validate every property, regardless of when it fails,
				// and we will execute all the validators immediately (async validators will
				// run in parallel)
				for (var key in object.schema) {
					// check to see if we are allowed to validate this key
					if (!fieldMap || (fieldMap.hasOwnProperty(key))) {
						// run validation
						whenItem(validate(object, key), function (isValid, key) {
							if (!isValid) {
								notValid(key);
							}
						}, key);
					}
				}
			}), function () {
				object.set('errors', isValid ? undefined : errors);
				// it wasn't async, so we just return the synchronous result
				return isValid;
			});
			function notValid(key) {
				// found an error, mark valid state and record the errors
				isValid = false;
				errors.push.apply(errors, object.property(key).errors);
			}
		},

		isValid: function () {
			//	summary:
			//		Returns whether or not there are currently any errors on
			//		this model due to validation failures. Note that this does
			//		not run validation but merely returns the result of any
			//		prior validation.
			//	returns: boolean

			var isValid = true,
				key;

			for (key in this.schema) {
				var property = this.hasOwnProperty('_properties') && this._properties[key];
				if (property && property.errors && property.errors.length) {
					isValid = false;
				}
			}
			return isValid;
		}
	});

	// define the start and end markers of an operation, so we can
	// fire notifications at the end of the operation, by default
	function startOperation() {
		setCallDepth++;
	}
	function endOperation() {
		// if we are ending this operation, start executing the queue
		if (setCallDepth < 2 && onEnd) {
			onEnd();
			onEnd = null;
		}
		setCallDepth--;
	}
	var setCallDepth = 0;
	var callbackQueue;
	var onEnd;
	// the default nextTurn executes at the end of the current operation
	// The intent with this function is that it could easily be replaced
	// with something like setImmediate, setTimeout, or nextTick to provide
	// next turn handling
	(Model.nextTurn = function (callback) {
		// set the callback for the end of the current operation
		onEnd = callback;
	}).atEnd = true;

	var Reactive = declare([Model], {
		//	summary:
		//		A reactive object is a data model that can contain a value,
		//		and notify listeners of changes to that value, in the future.
		observe: function (/*function*/ listener, /*object*/ options) {
			//	summary:
			//		Registers a listener for any changes in the current value
			//	listener:
			//		Function to be called for each change
			//	options.onlyFutureUpdates
			//		If this is true, it won't call the listener for the current value,
			//		just future updates. If this is true, it also won't return
			//		a new reactive object
			
			var reactive;
			if (typeof listener === 'string') {
				// a property key was provided, use the Model's method
				return this.inherited(arguments);
			}
			if (!options || !options.onlyFutureUpdates) {
				// create a new reactive to contain the results of the execution
				// of the provided function
				reactive = new Reactive();
				if (this._has()) {
					// we need to notify of the value of the present (as well as future)
					reactive.value = listener(this.valueOf());
				}
			}
			// add to the listeners
			var handle = this._addListener(function (value) {
				var result = listener(value);
				if (reactive) {
					// TODO: once we have a real notification API again, call that, instead 
					// of requesting a change
					reactive.put(result);
				}
			});
			if (reactive) {
				reactive.remove = handle.remove;
				return reactive;
			} else {
				return handle;
			}
		},

		//	validateOnSet: boolean
		//		Indicates whether or not to perform validation when properties
		//		are modified.
		//		This can provided immediate feedback and on the success
		//		or failure of a property modification. And Invalid property 
		//		values will be rejected. However, if you are
		//		using asynchronous validation, invalid property values will still
		//		be set.
		validateOnSet: false,

		//	validators: Array
		//		An array of additional validators to apply to this property
		validators: null,

		_addListener: function (listener) {
			// add a listener for the property change event
			return aspect.after(this, 'onchange', listener, true);
		},

		valueOf: function () {
			return this._get();
		},

		_get: function () {
			return this.value;
		},

		_has: function () {
			return this.hasOwnProperty('value');
		},
		setValue: function (value) {
			//	summary:
			//		This method is responsible for storing the value. This can
			//		be overriden to define a custom setter
			//	value: any
			//		The value to be stored
			//	parent: Object
			//		The parent object of this propery
			this.value = value;
		},

		put: function (/*any*/ value) {
			//	summary:
			//		Indicates a new value for this reactive object

			// notify all the listeners of this object, that the value has changed
			var oldValue = this._get();
			value = this.coerce(value);
			if (this.errors) {
				// clear any errors
				this.set('errors', undefined);
			}
			var property = this;
			// call the setter and wait for it
			startOperation();
			return when(this.setValue(value, this._parent), function (result) {
				if (result !== undefined) {
					// allow the setter to change the value
					value = result;
				}
				// notify listeners
				if (property.onchange) {
					// queue the callback
					property._queueChange(property.onchange, oldValue);
				}
				// if this was set to an object (or was an object), we need to notify.
				// update all the sub-property objects, so they can possibly notify their
				// listeners
				var key,
					hasOldObject = oldValue && typeof oldValue === 'object' && !(oldValue instanceof Array),
					hasNewObject = value && typeof value === 'object' && !(value instanceof Array);
				if (hasOldObject || hasNewObject) {
					// we will iterate through the properties recording the changes
					var changes = {};
					if (hasOldObject) {
						oldValue = oldValue._getValues ? oldValue._getValues() : oldValue;
						for (key in oldValue) {
							changes[key] = {old: oldValue[key]};
						}
					}
					if (hasNewObject) {
						value = value._getValues ? value._getValues() : value;
						for (key in value) {
							(changes[key] = changes[key] || {}).value = value[key];
						}
					}
					property._values = hasNewObject && value;
					for (key in changes) {
						// now for each change, we can notify the property object
						var change = changes[key];
						var subProperty = property._properties && property._properties[key];
						if (subProperty && subProperty.onchange) {
							// queue the callback
							subProperty._queueChange(subProperty.onchange, change.old);
						}
					}
				}
				if (property.validateOnSet) {
					property.validate();
				}
				endOperation();
			});
		},

		coerce: function (value) {
			//	summary:
			//		Given an input value, this method is responsible
			//		for converting it to the appropriate type for storing on the object.

			var type = this.type;
			if (type) {
				if (type === 'string') {
					value = '' + value;
				}
				else if (type === 'number') {
					value = +value;
				}
				else if (type === 'boolean') {
					// value && value.length check is because dijit/_FormMixin
					// returns an array for checkboxes; an array coerces to true,
					// but an empty array should be set as false
					value = (value === 'false' || value === '0' || value instanceof Array && !value.length) ?
						false : !!value;
				}
				else if (typeof type === 'function' && !(value instanceof type)) {
					/* jshint newcap: false */
					value = new type(value);
				}
			}
			return value;
		},

		addError: function (error) {
			//	summary:
			//		Add an error to the current list of validation errors
			//	error: String
			//		Error to add
			this.set('errors', (this.errors || []).concat([error]));
		},

		checkForErrors: function (value) {
			//	summary:
			//		This method can be implemented to simplify validation.
			//		This is called with the value, and this method can return
			//		an array of any errors that were found. It is recommended
			//		that you call this.inherited(arguments) to permit any
			//		other validators to perform validation
			//	value:
			//		This is the value to validate.
			var errors = [];
			if (this.type && !(typeof this.type === 'function' ? (value instanceof this.type) :
				(this.type === typeof value))) {
				errors.push(value + ' is not a ' + this.type);
			}
			
			if (this.required && !(value != null && value !== '')) {
				errors.push('required, and it was not present');
			}
			return errors;
		},

		validate: function () {
			//	summary:
			//		This method is responsible for validating this particular
			//		property instance.
			var property = this;
			var model = this._parent;
			var validators = this.validators;
			var value = this.valueOf();
			var totalErrors = [];

			return when(whenEach(function (whenItem) {
				// iterator through any validators (if we have any)
				if (validators) {
					for (var i = 0; i < validators.length; i++) {
						whenItem(validators[i].checkForErrors(value, property, model), addErrors);
					}
				}
				// check our own validation
				whenItem(property.checkForErrors(value, property, model), addErrors);
				function addErrors(errors) {
					if (errors) {
						// if we have an array of errors, add it to the total of all errors
						totalErrors.push.apply(totalErrors, errors);
					}
				}
			}), function () {
				if (totalErrors.length) {
					// errors exist
					property.set('errors', totalErrors);
					return false;
				}
				// no errors, valid value, if there were errors before, remove them
				if(property.get('errors') !== undefined){
					property.set('errors', undefined);
				}
				return true;
			});
		},
		_queueChange: function (callback, oldValue) {
			// queue up a notification callback
			if (!callback._queued) {
				// make sure we only queue up once before it is called by flagging it
				callback._queued = true;
				var reactive = this;
				// define a function for when it is called that will clear the flag
				// and provide the correct args
				var dispatch = function () {
					callback._queued = false;
					callback.call(reactive, reactive._get(), oldValue);
				};

				if (callbackQueue) {
					// we already have a waiting queue of callbacks, add our callback
					callbackQueue.push(dispatch);
				}
				if (!callbackQueue) {
					// no waiting queue, check to see if we have a custom nextTurn
					// or we are in an operation
					if (!Model.nextTurn.atEnd || setCallDepth > 0) {
						// create the queue (starting with this callback)
						callbackQueue = [dispatch];
						// define the callback executor for the next turn
						Model.nextTurn(function () {
							// pull out all the callbacks
							for (var i = 0; i < callbackQueue.length; i++) {
								// call each one
								callbackQueue[i]();
							}
							// clear it
							callbackQueue = null;
						});
					} else {
						// no set call depth, so just immediately execute
						dispatch();
					}
				}
			}
		},
		toJSON: function () {
			return this._values || this;
		}
	});
	// a function that returns a function, to stop JSON serialization of an
	// object
	function toJSONHidden() {
		return toJSONHidden;
	}
	// An object that will be hidden from JSON serialization
	var Hidden = function () {
	};
	Hidden.prototype.toJSON = toJSONHidden;

	var Property = Model.Property = declare(Reactive, {
		//	summary:
		//		A Property represents a time-varying property value on an object,
		//		along with meta-data. One can listen to changes in this value (through
		//		receive), as well as access and monitor metadata, like default values,
		//		validation information, required status, and any validation errors.

		//	value: any
		//		This represents the value of this property, which can be
		//		monitored for changes and validated

		init: function (options) {
			// handle simple definitions
			if (typeof options === 'string' || typeof options === 'function') {
				options = {type: options};
			}
			// and/or mixin any provided properties
			if (options) {
				declare.safeMixin(this, options);
			}
		},

		_get: function () {
			return this._parent._getValues()[this.name];
		},
		_has: function () {
			return this.name in this._parent._getValues();
		},
		setValue: function (value, parent) {
			parent._getValues()[this.name] = value;
		}
	});

	var simplePropertyValueOf = Property.prototype.valueOf;
	var simplePropertyPut = Property.prototype.put;

	return Model;
});
},
'dojo/Evented':function(){
define(["./aspect", "./on"], function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
});

},
'dgrid/extensions/Pagination':function(){
define([
	'../_StoreMixin',
	'dojo/_base/declare',
	'dojo/_base/array',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/query',
	'dojo/string',
	'dojo/has',
	'dojo/when',
	'../util/misc',
	'dojo/_base/sniff'
], function (_StoreMixin, declare, arrayUtil, lang, domConstruct, domClass, on, query, string, has, when,
		miscUtil) {


	function cleanupContent(grid) {
		// Remove any currently-rendered rows, or noDataMessage
		if (grid.noDataNode) {
			domConstruct.destroy(grid.noDataNode);
			delete grid.noDataNode;
		}
		else {
			grid.cleanup();
		}
		grid.contentNode.innerHTML = '';
	}
	function cleanupLoading(grid) {
		if (grid.loadingNode) {
			domConstruct.destroy(grid.loadingNode);
			delete grid.loadingNode;
		}
		else if (grid._oldPageNodes) {
			// If cleaning up after a load w/ showLoadingMessage: false,
			// be careful to only clean up rows from the old page, not the new one
			for (var id in grid._oldPageNodes) {
				grid.removeRow(grid._oldPageNodes[id]);
			}
			delete grid._oldPageNodes;
		}
		delete grid._isLoading;
	}

	return declare(_StoreMixin, {
		// summary:
		//		An extension for adding discrete pagination to a List or Grid.

		// rowsPerPage: Number
		//		Number of rows (items) to show on a given page.
		rowsPerPage: 10,

		// pagingTextBox: Boolean
		//		Indicates whether or not to show a textbox for paging.
		pagingTextBox: false,
		// previousNextArrows: Boolean
		//		Indicates whether or not to show the previous and next arrow links.
		previousNextArrows: true,
		// firstLastArrows: Boolean
		//		Indicates whether or not to show the first and last arrow links.
		firstLastArrows: false,

		// pagingLinks: Number
		//		The number of page links to show on each side of the current page
		//		Set to 0 (or false) to disable page links.
		pagingLinks: 2,
		// pageSizeOptions: Array[Number]
		//		This provides options for different page sizes in a drop-down.
		//		If it is empty (default), no page size drop-down will be displayed.
		pageSizeOptions: null,

		// showLoadingMessage: Boolean
		//		If true, clears previous data and displays loading node when requesting
		//		another page; if false, leaves previous data in place until new data
		//		arrives, then replaces it immediately.
		showLoadingMessage: true,

		// i18nPagination: Object
		//		This object contains all of the internationalized strings as
		//		key/value pairs.
		i18nPagination: {
			status: '${start} - ${end} of ${total} results',
			gotoFirst: 'Go to first page',
			gotoNext: 'Go to next page',
			gotoPrev: 'Go to previous page',
			gotoLast: 'Go to last page',
			gotoPage: 'Go to page',
			jumpPage: 'Jump to page',
			rowsPerPage: 'Number of rows per page'
		},

		showFooter: true,
		_currentPage: 1,

		buildRendering: function () {
			this.inherited(arguments);

			// add pagination to footer
			var grid = this,
				paginationNode = this.paginationNode =
					domConstruct.create('div', { className: 'dgrid-pagination' }, this.footerNode),
				statusNode = this.paginationStatusNode =
					domConstruct.create('div', { className: 'dgrid-status' }, paginationNode),
				i18n = this.i18nPagination,
				navigationNode,
				node;

			statusNode.tabIndex = 0;

            if(this.addUiClasses){
                domClass.add(this.footerNode,'ui-widget-content');
            }

			// Initialize UI based on pageSizeOptions and rowsPerPage
			this._updatePaginationSizeSelect();
			this._updateRowsPerPageOption();

			// initialize some content into paginationStatusNode, to ensure
			// accurate results on initial resize call
			this._updatePaginationStatus(this._total);

			navigationNode = this.paginationNavigationNode =
				domConstruct.create('div', { className: 'dgrid-navigation' }, paginationNode);

			if (this.firstLastArrows) {
				// create a first-page link
				node = this.paginationFirstNode = domConstruct.create('span', {
					'aria-label': i18n.gotoFirst,
					className: 'dgrid-first dgrid-page-link',
					innerHTML: '',
					tabIndex: 0
				}, navigationNode);
			}
			if (this.previousNextArrows) {
				// create a previous link
				node = this.paginationPreviousNode = domConstruct.create('span', {
					'aria-label': i18n.gotoPrev,
					className: 'dgrid-previous dgrid-page-link',
					innerHTML: '',
					tabIndex: 0
				}, navigationNode);
			}

			this.paginationLinksNode = domConstruct.create('span', {
				className: 'dgrid-pagination-links'
			}, navigationNode);

			if (this.previousNextArrows) {
				// create a next link
				node = this.paginationNextNode = domConstruct.create('span', {
					'aria-label': i18n.gotoNext,
					className: 'dgrid-next dgrid-page-link',
					innerHTML: '',
					tabIndex: 0
				}, navigationNode);
			}
			if (this.firstLastArrows) {
				// create a last-page link
				node = this.paginationLastNode = domConstruct.create('span', {
					'aria-label': i18n.gotoLast,
					className: 'dgrid-last dgrid-page-link',
					innerHTML: '',
					tabIndex: 0
				}, navigationNode);
			}

			/* jshint maxlen: 121 */
			this._listeners.push(on(navigationNode, '.dgrid-page-link:click,.dgrid-page-link:keydown', function (event) {
				// For keyboard events, only respond to enter
				if (event.type === 'keydown' && event.keyCode !== 13) {
					return;
				}

				var cls = this.className,
					curr, max;

				if (grid._isLoading || cls.indexOf('dgrid-page-disabled') > -1) {
					return;
				}

				curr = grid._currentPage;
				max = Math.ceil(grid._total / grid.rowsPerPage);

				// determine navigation target based on clicked link's class
				if (this === grid.paginationPreviousNode) {
					grid.gotoPage(curr - 1);
				}
				else if (this === grid.paginationNextNode) {
					grid.gotoPage(curr + 1);
				}
				else if (this === grid.paginationFirstNode) {
					grid.gotoPage(1);
				}
				else if (this === grid.paginationLastNode) {
					grid.gotoPage(max);
				}
				else if (cls === 'dgrid-page-link') {
					grid.gotoPage(+this.innerHTML); // the innerHTML has the page number
				}
			}));
		},

		destroy: function () {
			this.inherited(arguments);
			if (this._pagingTextBoxHandle) {
				this._pagingTextBoxHandle.remove();
			}
		},

		_updatePaginationSizeSelect: function () {
			// summary:
			//		Creates or repopulates the pagination size selector based on
			//		the values in pageSizeOptions. Called from buildRendering
			//		and _setPageSizeOptions.

			var pageSizeOptions = this.pageSizeOptions,
				paginationSizeSelect = this.paginationSizeSelect,
				handle;

			if (pageSizeOptions && pageSizeOptions.length) {
				if (!paginationSizeSelect) {
					// First time setting page options; create the select
					paginationSizeSelect = this.paginationSizeSelect = domConstruct.create('select', {
						'aria-label': this.i18nPagination.rowsPerPage,
						className: 'dgrid-page-size'
					}, this.paginationNode);

					handle = this._paginationSizeChangeHandle =
						on(paginationSizeSelect, 'change', lang.hitch(this, function () {
							this.set('rowsPerPage', +this.paginationSizeSelect.value);
						}));
					this._listeners.push(handle);
				}

				// Repopulate options
				paginationSizeSelect.options.length = 0;
				for (var i = 0; i < pageSizeOptions.length; i++) {
					domConstruct.create('option', {
						innerHTML: pageSizeOptions[i],
						selected: this.rowsPerPage === pageSizeOptions[i],
						value: pageSizeOptions[i]
					}, paginationSizeSelect);
				}
				// Ensure current rowsPerPage value is in options
				this._updateRowsPerPageOption();
			}
			else if (!(pageSizeOptions && pageSizeOptions.length) && paginationSizeSelect) {
				// pageSizeOptions was removed; remove/unhook the drop-down
				domConstruct.destroy(paginationSizeSelect);
				this.paginationSizeSelect = null;
				this._paginationSizeChangeHandle.remove();
			}
		},

		_setPageSizeOptions: function (pageSizeOptions) {
			this.pageSizeOptions = pageSizeOptions && pageSizeOptions.sort(function (a, b) {
				return a - b;
			});
			this._updatePaginationSizeSelect();
		},

		_updateRowsPerPageOption: function () {
			// summary:
			//		Ensures that an option for rowsPerPage's value exists in the
			//		paginationSizeSelect drop-down (if one is rendered).
			//		Called from buildRendering and _setRowsPerPage.

			var rowsPerPage = this.rowsPerPage,
				pageSizeOptions = this.pageSizeOptions,
				paginationSizeSelect = this.paginationSizeSelect;

			if (paginationSizeSelect) {
				if (arrayUtil.indexOf(pageSizeOptions, rowsPerPage) < 0) {
					this._setPageSizeOptions(pageSizeOptions.concat([rowsPerPage]));
				}
				else {
					paginationSizeSelect.value = '' + rowsPerPage;
				}
			}
		},

		_setRowsPerPage: function (rowsPerPage) {
			this.rowsPerPage = rowsPerPage;
			this._updateRowsPerPageOption();
			this.gotoPage(1);
		},

		_updateNavigation: function (total) {
			// summary:
			//		Update status and navigation controls based on total count from query

			var grid = this,
				i18n = this.i18nPagination,
				linksNode = this.paginationLinksNode,
				currentPage = this._currentPage,
				pagingLinks = this.pagingLinks,
				paginationNavigationNode = this.paginationNavigationNode,
				end = Math.ceil(total / this.rowsPerPage),
				pagingTextBoxHandle = this._pagingTextBoxHandle,
				focused = document.activeElement,
				focusedPage,
				lastFocusablePageLink,
				focusableNodes;

			function pageLink(page, addSpace) {
				var link;
				var disabled;
				if (grid.pagingTextBox && page === currentPage && end > 1) {
					// use a paging text box if enabled instead of just a number
					link = domConstruct.create('input', {
						'aria-label': i18n.jumpPage,
						className: 'dgrid-page-input',
						type: 'text',
						value: currentPage
					}, linksNode);
					grid._pagingTextBoxHandle = on(link, 'change', function () {
						var value = +this.value;
						if (!isNaN(value) && value > 0 && value <= end) {
							grid.gotoPage(+this.value);
						}
					});
					if (focused && focused.tagName === 'INPUT') {
						link.focus();
					}
				}
				else {
					// normal link
					disabled = page === currentPage;
					link = domConstruct.create('span', {
						'aria-label': i18n.gotoPage,
						className: 'dgrid-page-link' + (disabled ? ' dgrid-page-disabled' : ''),
						innerHTML: page + (addSpace ? ' ' : ''),
						tabIndex: disabled ? -1 : 0
					}, linksNode);

					// Try to restore focus if applicable;
					// if we need to but can't, try on the previous or next page,
					// depending on whether we're at the end
					if (focusedPage === page) {
						if (!disabled) {
							link.focus();
						}
						else if (page < end) {
							focusedPage++;
						}
						else {
							lastFocusablePageLink.focus();
						}
					}

					if (!disabled) {
						lastFocusablePageLink = link;
					}
				}
			}

			function setDisabled(link, disabled) {
				domClass.toggle(link, 'dgrid-page-disabled', disabled);
				link.tabIndex = disabled ? -1 : 0;
			}

			function addSkipNode() {
				// Adds visual indication of skipped page numbers in navigation area
				domConstruct.create('span', {
					className: 'dgrid-page-skip',
					innerHTML: '...'
				}, linksNode);
			}

			if (!focused || !miscUtil.contains(this.paginationNavigationNode, focused)) {
				focused = null;
			}
			else if (focused.className === 'dgrid-page-link') {
				focusedPage = +focused.innerHTML;
			}

			if (pagingTextBoxHandle) {
				pagingTextBoxHandle.remove();
			}
			linksNode.innerHTML = '';
			query('.dgrid-first, .dgrid-previous', paginationNavigationNode).forEach(function (link) {
				setDisabled(link, currentPage === 1);
			});
			query('.dgrid-last, .dgrid-next', paginationNavigationNode).forEach(function (link) {
				setDisabled(link, currentPage >= end);
			});

			if (pagingLinks && end > 0) {
				// always include the first page (back to the beginning)
				pageLink(1, true);
				var start = currentPage - pagingLinks;
				if (start > 2) {
					addSkipNode();
				}
				else {
					start = 2;
				}
				// now iterate through all the page links we should show
				for (var i = start; i < Math.min(currentPage + pagingLinks + 1, end); i++) {
					pageLink(i, true);
				}
				if (currentPage + pagingLinks + 1 < end) {
					addSkipNode();
				}
				// last link
				if (end > 1) {
					pageLink(end);
				}
			}
			else if (grid.pagingTextBox) {
				// The pageLink function is also used to create the paging textbox.
				pageLink(currentPage);
			}

			if (focused && focused.tabIndex === -1) {
				// One of the first/last or prev/next links was focused but
				// is now disabled, so find something focusable
				focusableNodes = query('[tabindex="0"]', this.paginationNavigationNode);
				if (focused === this.paginationPreviousNode || focused === this.paginationFirstNode) {
					focused = focusableNodes[0];
				}
				else if (focusableNodes.length) {
					focused = focusableNodes[focusableNodes.length - 1];
				}
				if (focused) {
					focused.focus();
				}
			}
		},

		_updatePaginationStatus: function (total) {
			var count = this.rowsPerPage;
			var start = Math.min(total, (this._currentPage - 1) * count + 1);
			this.paginationStatusNode.innerHTML = string.substitute(this.i18nPagination.status, {
				start: start,
				end: Math.min(total, start + count - 1),
				total: total
			});
		},

		refresh: function (options) {
			// summary:
			//		Re-renders the first page of data, or the current page if
			//		options.keepCurrentPage is true.

			var self = this;
			var page = options && options.keepCurrentPage ?
				Math.min(this._currentPage, Math.ceil(this._total / this.rowsPerPage)) : 1;

			this.inherited(arguments);

			// Reset to first page and return promise from gotoPage
			return this.gotoPage(page).then(function (results) {
				// Emit on a separate turn to enable event to be used consistently for
				// initial render, regardless of whether the backing store is async
				setTimeout(function () {
					on.emit(self.domNode, 'dgrid-refresh-complete', {
						bubbles: true,
						cancelable: false,
						grid: self
					});
				}, 0);

				return results;
			});
		},

		_onNotification: function (rows, event, collection) {
			var rowsPerPage = this.rowsPerPage;
			var pageEnd = this._currentPage * rowsPerPage;
			var needsRefresh = (event.type === 'add' && event.index < pageEnd) ||
				(event.type === 'delete' && event.previousIndex < pageEnd) ||
				(event.type === 'update' &&
					Math.floor(event.index / rowsPerPage) !== Math.floor(event.previousIndex / rowsPerPage));

			if (needsRefresh) {
				// Refresh the current page to maintain correct number of rows on page
				this.gotoPage(Math.min(this._currentPage, Math.ceil(event.totalLength / this.rowsPerPage)));
			}
			// If we're not updating the whole page, check if we at least need to update status/navigation
			else if (collection === this._renderedCollection && event.totalLength !== this._total) {
				this._updatePaginationStatus(event.totalLength);
				this._updateNavigation(event.totalLength);
			}
		},

		renderQueryResults: function (results, beforeNode) {
			var grid = this,
				rows = this.inherited(arguments);

			if (!beforeNode) {
				if (this._topLevelRequest) {
					// Cancel previous async request that didn't finish
					this._topLevelRequest.cancel();
					delete this._topLevelRequest;
				}

				if (typeof rows.cancel === 'function') {
					// Store reference to new async request in progress
					this._topLevelRequest = rows;
				}

				rows.then(function () {
					if (grid._topLevelRequest) {
						// Remove reference to request now that it's finished
						delete grid._topLevelRequest;
					}
				});
			}

			return rows;
		},

		insertRow: function () {
			var oldNodes = this._oldPageNodes,
				row = this.inherited(arguments);

			if (oldNodes && row === oldNodes[row.id]) {
				// If the previous row was reused, avoid removing it in cleanup
				delete oldNodes[row.id];
			}

			return row;
		},

		gotoPage: function (page) {
			// summary:
			//		Loads the given page.  Note that page numbers start at 1.
			var grid = this,
				start = (this._currentPage - 1) * this.rowsPerPage;

			if (!this._renderedCollection) {
				console.warn('Pagination requires a collection to operate.');
				return when([]);
			}

			if (this._renderedCollection.releaseRange) {
				this._renderedCollection.releaseRange(start, start + this.rowsPerPage);
			}

			return this._trackError(function () {
				var count = grid.rowsPerPage,
					start = (page - 1) * count,
					options = {
						start: start,
						count: count
					},
					results,
					contentNode = grid.contentNode,
					loadingNode,
					oldNodes,
					children,
					i,
					len;

				if (grid.showLoadingMessage) {
					cleanupContent(grid);
					loadingNode = grid.loadingNode = domConstruct.create('div', {
						className: 'dgrid-loading',
						innerHTML: grid.loadingMessage
					}, contentNode);
				}
				else {
					// Reference nodes to be cleared later, rather than now;
					// iterate manually since IE < 9 doesn't like slicing HTMLCollections
					grid._oldPageNodes = oldNodes = {};
					children = contentNode.children;
					for (i = 0, len = children.length; i < len; i++) {
						oldNodes[children[i].id] = children[i];
					}
				}

				// set flag to deactivate pagination event handlers until loaded
				grid._isLoading = true;

				results = grid._renderedCollection.fetchRange({
					start: start,
					end: start + count
				});

				return grid.renderQueryResults(results, null, options).then(function (rows) {
					cleanupLoading(grid);
					// Reset scroll Y-position now that new page is loaded.
					grid.scrollTo({ y: 0 });

					if (grid._rows) {
						grid._rows.min = start;
						grid._rows.max = start + count - 1;
					}

					results.totalLength.then(function (total) {
						if (!total) {
							if (grid.noDataNode) {
								domConstruct.destroy(grid.noDataNode);
								delete grid.noDataNode;
							}
							// If there are no results, display the no data message.
							grid.noDataNode = domConstruct.create('div', {
								className: 'dgrid-no-data',
								innerHTML: grid.noDataMessage
							}, grid.contentNode);
						}

						// Update status text based on now-current page and total.
						grid._total = total;
						grid._currentPage = page;
						grid._rowsOnPage = rows.length;
						grid._updatePaginationStatus(total);

						// It's especially important that _updateNavigation is called only
						// after renderQueryResults is resolved as well (to prevent jumping).
						grid._updateNavigation(total);
					});

					return results;
				}, function (error) {
					cleanupLoading(grid);
					throw error;
				});
			});
		}
	});
});

},
'dojo/dnd/Avatar':function(){
define([
	"../_base/declare",
	"../_base/window",
	"../dom",
	"../dom-attr",
	"../dom-class",
	"../dom-construct",
	"../hccss",
	"../query"
], function(declare, win, dom, domAttr, domClass, domConstruct, has, query){

// module:
//		dojo/dnd/Avatar

return declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need

		var a = domConstruct.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = domConstruct.create("tbody", null, a),
			tr = domConstruct.create("tr", null, b),
			td = domConstruct.create("td", null, tr),
			k = Math.min(5, this.manager.nodes.length), i = 0;

		if(has("highcontrast")){
			domConstruct.create("span", {
				id : "a11yIcon",
				innerHTML : this.manager.copy ? '+' : "<"
			}, td)
		}
		domConstruct.create("span", {
			innerHTML: source.generateText ? this._generateText() : ""
		}, td);

		// we have to set the opacity on IE only after the node is live
		domAttr.set(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = domConstruct.create("table"),
						tbody = domConstruct.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = domConstruct.create("tr", null, b);
			td = domConstruct.create("td", null, tr);
			td.appendChild(node);
			domAttr.set(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		domConstruct.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		domClass.toggle(this.node, "dojoDndAvatarCanDrop", this.manager.canDropFlag);
		if(has("highcontrast")){
			var icon = dom.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy){
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy){
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		query(("tr.dojoDndAvatarHeader td span" +(has("highcontrast") ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this.manager.source.generateText ? this._generateText() : "";
			}, this);
	},
	_generateText: function(){
		// summary:
		//		generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

});

},
'dojo/string':function(){
define([
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string

var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});

},
'dgrid/Tree':function(){
define([
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/query',
	'dojo/when',
	'./util/has-css3',
	'./Grid',
	'xdojo/has!touch?./util/touch'
], function (declare, lang, arrayUtil, aspect, domConstruct, domClass, on, querySelector, when, has, Grid, touchUtil) {

	return declare(null, {
		// collapseOnRefresh: Boolean
		//		Whether to collapse all expanded nodes any time refresh is called.
		collapseOnRefresh: false,

		// enableTreeTransitions: Boolean
		//		Enables/disables all expand/collapse CSS transitions.
		enableTreeTransitions: false,

		// treeIndentWidth: Number
		//		Width (in pixels) of each level of indentation.
		treeIndentWidth: 9,

		constructor: function () {
			this._treeColumnListeners = [];
		},

		shouldExpand: function (row, level, previouslyExpanded) {
			// summary:
			//		Function called after each row is inserted to determine whether
			//		expand(rowElement, true) should be automatically called.
			//		The default implementation re-expands any rows that were expanded
			//		the last time they were rendered (if applicable).

			return previouslyExpanded;
		},

		expand: function (target, expand, noTransition) {
			// summary:
			//		Expands the row corresponding to the given target.
			// target: Object
			//		Row object (or something resolvable to one) to expand/collapse.
			// expand: Boolean?
			//		If specified, designates whether to expand or collapse the row;
			//		if unspecified, toggles the current state.

			if (!this._treeColumn) {
				return;
			}

			var grid = this,
				row = target.element ? target : this.row(target),
				isExpanded = !!this._expanded[row.id],
				hasTransitionend = has('transitionend'),
				promise;

			target = row.element;
			target = target.className.indexOf('dgrid-expando-icon') > -1 ? target :
				querySelector('.dgrid-expando-icon', target)[0];

			noTransition = noTransition || !this.enableTreeTransitions;

			if (target && target.mayHaveChildren && (noTransition || expand !== isExpanded)) {
				// toggle or set expand/collapsed state based on optional 2nd argument
				var expanded = expand === undefined ? !this._expanded[row.id] : expand;

				// update the expando display
				domClass.replace(target, 'ui-icon-triangle-1-' + (expanded ? 'se' : 'e'),
					'ui-icon-triangle-1-' + (expanded ? 'e' : 'se'));
				domClass.toggle(row.element, 'dgrid-row-expanded', expanded);

				var rowElement = row.element,
					container = rowElement.connected,
					containerStyle,
					scrollHeight,
					options = {};

				if (!container) {
					// if the children have not been created, create a container, a preload node and do the
					// query for the children
					container = options.container = rowElement.connected =
						domConstruct.create('div', { className: 'dgrid-tree-container' }, rowElement, 'after');
					var query = function (options) {
						var childCollection = grid._renderedCollection.getChildren(row.data),
								results;
						if (grid.sort) {
							childCollection = childCollection.sort(grid.sort);
						}
						if (childCollection.track && grid.shouldTrackCollection) {
							container._rows = options.rows = [];

							childCollection = childCollection.track();

							// remember observation handles so they can be removed when the parent row is destroyed
							container._handles = [
								childCollection.tracking,
								grid._observeCollection(childCollection, container, options)
							];
						}
						if ('start' in options) {
							var rangeArgs = {
								start: options.start,
								end: options.start + options.count
							};
							results = childCollection.fetchRange(rangeArgs);
						} else {
							results = childCollection.fetch();
						}
						return results;
					};
					// Include level information on query for renderQuery case
					if ('level' in target) {
						query.level = target.level;
					}

					// Add the query to the promise chain
					if (this.renderQuery) {
						promise = this.renderQuery(query, options);
					}
					else {
						// If not using OnDemandList, we don't need preload nodes,
						// but we still need a beforeNode to pass to renderArray,
						// so create a temporary one
						var firstChild = domConstruct.create('div', null, container);
						promise = this._trackError(function () {
							return grid.renderQueryResults(
								query(options),
								firstChild,
								lang.mixin({ rows: options.rows },
									'level' in query ? { queryLevel: query.level } : null
								)
							).then(function (rows) {
								domConstruct.destroy(firstChild);
								return rows;
							});
						});
					}

					if (hasTransitionend) {
						// Update height whenever a collapse/expand transition ends.
						// (This handler is only registered when each child container is first created.)
						on(container, hasTransitionend, this._onTreeTransitionEnd);
					}
				}

				// Show or hide all the children.

				container.hidden = !expanded;
				containerStyle = container.style;

				// make sure it is visible so we can measure it
				if (!hasTransitionend || noTransition) {
					containerStyle.display = expanded ? 'block' : 'none';
					containerStyle.height = '';
				}
				else {
					if (expanded) {
						containerStyle.display = 'block';
						scrollHeight = container.scrollHeight;
						containerStyle.height = '0px';
					}
					else {
						// if it will be hidden we need to be able to give a full height
						// without animating it, so it has the right starting point to animate to zero
						domClass.add(container, 'dgrid-tree-resetting');
						containerStyle.height = container.scrollHeight + 'px';
					}
					// Perform a transition for the expand or collapse.
					setTimeout(function () {
						domClass.remove(container, 'dgrid-tree-resetting');
						containerStyle.height =
							expanded ? (scrollHeight ? scrollHeight + 'px' : 'auto') : '0px';
					}, 0);
				}

				// Update _expanded map.
				if (expanded) {
					this._expanded[row.id] = true;
				}
				else {
					delete this._expanded[row.id];
				}
			}

			// Always return a promise
			return when(promise);
		},

		_configColumns: function () {
			var columnArray = this.inherited(arguments);

			// Set up hash to store IDs of expanded rows (here rather than in
			// _configureTreeColumn so nothing breaks if no column has renderExpando)
			this._expanded = {};

			for (var i = 0, l = columnArray.length; i < l; i++) {
				if (columnArray[i].renderExpando) {
					this._configureTreeColumn(columnArray[i]);
					break; // Allow only one tree column.
				}
			}
			return columnArray;
		},

		insertRow: function (object) {
			var rowElement = this.inherited(arguments);

			// Auto-expand (shouldExpand) considerations
			var row = this.row(rowElement),
				expanded = this.shouldExpand(row, this._currentLevel, this._expanded[row.id]);

			if (expanded) {
				this.expand(rowElement, true, true);
			}

			if (expanded || (!this.collection.mayHaveChildren || this.collection.mayHaveChildren(object))) {
				domClass.add(rowElement, 'dgrid-row-expandable');
			}

			return rowElement; // pass return value through
		},

		removeRow: function (rowElement, preserveDom) {
			var connected = rowElement.connected,
				childOptions = {};
			if (connected) {
				if (connected._handles) {
					arrayUtil.forEach(connected._handles, function (handle) {
						handle.remove();
					});
					delete connected._handles;
				}

				if (connected._rows) {
					childOptions.rows = connected._rows;
				}

				querySelector('>.dgrid-row', connected).forEach(function (element) {
					this.removeRow(element, true, childOptions);
				}, this);

				if (connected._rows) {
					connected._rows.length = 0;
					delete connected._rows;
				}

				if (!preserveDom) {
					domConstruct.destroy(connected);
				}
			}

			this.inherited(arguments);
		},

		_refreshCellFromItem: function (cell, item) {
			if (!cell.column.renderExpando) {
				return this.inherited(arguments);
			}

			this.inherited(arguments, [ cell, item, {
				queryLevel: querySelector('.dgrid-expando-icon', cell.element)[0].level - 1
			}]);
		},

		cleanup: function () {
			this.inherited(arguments);

			if (this.collapseOnRefresh) {
				// Clear out the _expanded hash on each call to cleanup
				// (which generally coincides with refreshes, as well as destroy)
				this._expanded = {};
			}
		},

		_destroyColumns: function () {
			this.inherited(arguments);
			var listeners = this._treeColumnListeners;

			for (var i = listeners.length; i--;) {
				listeners[i].remove();
			}
			this._treeColumnListeners = [];
			this._treeColumn = null;
		},

		_calcRowHeight: function (rowElement) {
			// Override this method to provide row height measurements that
			// include the children of a row
			var connected = rowElement.connected;
			// if connected, need to consider this in the total row height
			return this.inherited(arguments) + (connected ? connected.offsetHeight : 0);
		},

		_configureTreeColumn: function (column) {
			// summary:
			//		Adds tree navigation capability to a column.

			var grid = this;
			var collection = this.collection;
			var colSelector = '.dgrid-content .dgrid-column-' + column.id;
			var clicked; // tracks row that was clicked (for expand dblclick event handling)

			this._treeColumn = column;
			if (!column._isConfiguredTreeColumn) {
				var originalRenderCell = column.renderCell || this._defaultRenderCell;
				column._isConfiguredTreeColumn = true;
				column.renderCell = function (object, value, td, options) {
					// summary:
					//		Renders a cell that can be expanded, creating more rows

					if(!collection){
						return;
					}

					var level = Number(options && options.queryLevel) + 1,
							mayHaveChildren = !collection.mayHaveChildren || collection.mayHaveChildren(object),
							expando, node;

					level = grid._currentLevel = isNaN(level) ? 0 : level;

					expando = column.renderExpando(level, mayHaveChildren,
							grid._expanded[collection.getIdentity(object)], object);

					expando.level = level;
					expando.mayHaveChildren = mayHaveChildren;

					node = originalRenderCell.call(column, object, value, td, options);
					if (node && node.nodeType) {
						td.appendChild(expando);
						td.appendChild(node);
					}
					else {
						td.insertBefore(expando, td.firstChild);
					}
				};

				if (typeof column.renderExpando !== 'function') {
					column.renderExpando = this._defaultRenderExpando;
				}
			}

			var treeColumnListeners = this._treeColumnListeners;
			if (treeColumnListeners.length === 0) {
				// Set up the event listener once and use event delegation for better memory use.
				treeColumnListeners.push(this.on(column.expandOn ||
						'.dgrid-expando-icon:click,' + colSelector + ':dblclick,' + colSelector + ':keydown',
						function (event) {
							var row = grid.row(event);
							if ((!grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(row.data)) &&
									(event.type !== 'keydown' || event.keyCode === 32) && !(event.type === 'dblclick' &&
									clicked && clicked.count > 1 && row.id === clicked.id &&
									event.target.className.indexOf('dgrid-expando-icon') > -1)) {
								grid.expand(row);
							}

							// If the expando icon was clicked, update clicked object to prevent
							// potential over-triggering on dblclick (all tested browsers but IE < 9).
							if (event.target.className.indexOf('dgrid-expando-icon') > -1) {
								if (clicked && clicked.id === grid.row(event).id) {
									clicked.count++;
								}
								else {
									clicked = {
										id: grid.row(event).id,
										count: 1
									};
								}
							}
						})
				);

				if (has('touch')) {
					// Also listen on double-taps of the cell.
					treeColumnListeners.push(this.on(touchUtil.selector(colSelector, touchUtil.dbltap),
							function () {
								grid.expand(this);
							}));
				}
			}

			/*
			 column.renderCell = function (object, value, td, options) {
			 // summary:
			 //		Renders a cell that can be expanded, creating more rows

			 var grid = column.grid,
			 level = Number(options && options.queryLevel) + 1,
			 mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
			 expando, node;

			 level = grid._currentLevel = isNaN(level) ? 0 : level;
			 expando = column.renderExpando(level, mayHaveChildren,
			 grid._expanded[grid.collection.getIdentity(object)], object);
			 expando.level = level;
			 expando.mayHaveChildren = mayHaveChildren;

			 node = originalRenderCell.call(column, object, value, td, options);
			 if (node && node.nodeType) {
			 td.appendChild(expando);
			 td.appendChild(node);
			 }
			 else {
			 td.insertBefore(expando, td.firstChild);
			 }
			 };
			 *//*
			if (!column.originalRenderCell)
			{
				column.originalRenderCell = column.renderCell || this._defaultRenderCell;
				column.renderCell = function (object, value, td, options) {
					// summary:
					//              Renders a cell that can be expanded, creating more rows
					var grid = column.grid,
							level = Number(options && options.queryLevel) + 1,
							mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
							expando,
							node;

					level = grid._currentLevel = isNaN(level) ? 0 : level;
					expando = column.renderExpando(level, mayHaveChildren,
							grid._expanded[grid.collection.getIdentity(object)], object);
					expando.level = level;
					expando.mayHaveChildren = mayHaveChildren;
					node = column.originalRenderCell(object, value, td, options);
					if (node && node.nodeType) {
						td.appendChild(expando);
						td.appendChild(node);
					}
					else {
						td.insertBefore(expando, td.firstChild);
					}
				};
			}
			*/
		},

		_defaultRenderExpando: function (level, hasChildren, expanded) {
			// summary:
			//		Default implementation for column.renderExpando.
			//		NOTE: Called in context of the column definition object.
			// level: Number
			//		Level of indentation for this row (0 for top-level)
			// hasChildren: Boolean
			//		Whether this item may have children (in most cases this determines
			//		whether an expando icon should be rendered)
			// expanded: Boolean
			//		Whether this item is currently in expanded state
			// object: Object
			//		The item that this expando pertains to

			var dir = this.grid.isRTL ? 'right' : 'left',
				cls = 'dgrid-expando-icon';
			if (hasChildren) {
				cls += ' ui-icon ui-icon-triangle-1-' + (expanded ? 'se' : 'e');
			}
			return domConstruct.create('div', {
				className: cls,
				innerHTML: '&nbsp;',
				style: 'margin-' + dir + ': ' + (level * this.grid.treeIndentWidth) + 'px; float: ' + dir + ';'
			});
		},

		_onNotification: function (rows, event) {
			if (event.type === 'delete') {
				delete this._expanded[event.id];
			}
			this.inherited(arguments);
		},

		_onTreeTransitionEnd: function (event) {
			var container = this,
				height = this.style.height;
			if (height) {
				// After expansion, ensure display is correct;
				// after collapse, set display to none to improve performance
				this.style.display = height === '0px' ? 'none' : 'block';
			}

			// Reset height to be auto, so future height changes (from children
			// expansions, for example), will expand to the right height.
			if (event) {
				// For browsers with CSS transition support, setting the height to
				// auto or "" will cause an animation to zero height for some
				// reason, so temporarily set the transition to be zero duration
				domClass.add(this, 'dgrid-tree-resetting');
				setTimeout(function () {
					// Turn off the zero duration transition after we have let it render
					domClass.remove(container, 'dgrid-tree-resetting');
				}, 0);
			}
			// Now set the height to auto
			this.style.height = '';
		}
	});
});
},
'xgrid/Toolbar':function(){
/** @module xgrid/Toolbar **/
define([
    "xdojo/declare",
    'xide/utils',
    'xide/types',
    'xide/widgets/ActionToolbar'
], function (declare,utils,types,ActionToolbar) {
    /**
     *
     * @class module:xgrid/Toolbar
     */
    var Implementation = {
        _toolbar:null,
        toolbarClass:null,
        toolbarInitiallyHidden:false,
        runAction:function(action){
            if(action.command==types.ACTION.TOOLBAR){
                this.showToolbar(this._toolbar==null);
                return true;
            }
            return this.inherited(arguments);
        },
        getToolbar:function(){
            return this._toolbar;
        },
        /**
         *
         * @param show
         * @param toolbarClass
         * @param where
         * @param setEmitter
         * @param args
         * @returns {null}
         */
        showToolbar:function(show,toolbarClass,where,setEmitter,args){
            //remember toolbar class
            toolbarClass = toolbarClass || this.toolbarClass;
            if(toolbarClass) {
                this.toolbarClass = toolbarClass;
            }
            if(show==null){
                show = this._toolbar==null;
            }
            if(show && !this._toolbar){
                var toolbar = utils.addWidget(toolbarClass || ActionToolbar ,utils.mixin({
                        style:'min-height:30px;height:auto;width:100%'
                    },args),this,where||this.header,true);

                if(setEmitter !==false) {
                    toolbar.addActionEmitter(this);
                    //at this point the actions are rendered!
                    toolbar.setActionEmitter(this);
                    this.refreshActions && this.refreshActions();
                }
                this._toolbar = toolbar;
                this.add && this.add(toolbar);
                this._emit('showToolbar',toolbar);
            }
            if(!show && this._toolbar){
                utils.destroy(this._toolbar,true,this);
                $(where||this.header).css('height','auto');
            }
            this.resize();
            return this._toolbar;
        },
        getState:function(state) {
            state = this.inherited(arguments) || {};
            state.toolbar = this._toolbar!==null;
            return state;
        },
        setState:function(state) {
            if(state && state.toolbar){
                this.showToolbar(state.toolbar);
            }
            return this.inherited(arguments);
        },
        startup:function(){
            var thiz = this;
            if(this._started){
                return;
            }
            this._on('onAddActions', function (evt) {
                var actions = evt.actions,
                    action = types.ACTION.TOOLBAR;
                if(!evt.store.getSync(action) && this.hasPermission(action)) {
                    actions.push(thiz.createAction({
                        label: 'Toolbar',
                        command: action,
                        icon: types.ACTION_ICON.TOOLBAR,
                        tab: 'View',
                        group: 'Show',
                        keycombo:['ctrl b'],
                        mixin:{
                            actionType:'multiToggle',
                            value:false,
                            id:utils.createUUID()
                        },
                        onCreate:function(action){
                            action.set('value',thiz._toolbar!==null);
                        },
                        onChange:function(property,value){
                            thiz.showToolbar(value);
                            thiz.onAfterAction(types.ACTION.TOOLBAR);
                        }
                    }));
                }
            });
            this.inherited(arguments);
            this.showToolbar(!this.toolbarInitiallyHidden);
        }
    };
    //package via declare
    var _class = declare('xgrid.Toolbar',null,Implementation);
    _class.Implementation = Implementation;
    return _class;
});
},
'xide/manager/Application_XFILE':function(){
define([
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xdojo/has',
    'dojo/Deferred'
], function (dcl,utils,types,has,Deferred) {
    return dcl(null,{
        declaredClass:"xide.manager.Application_XFILE",
        onXFileReady: function (config,gridClass) {
            if(location.href.indexOf('files=false')!=-1){
                return;
            }
            var _require = require,
                thiz = this,
                mainView = thiz.mainView;

            var toolbar = mainView.getToolbar(),
                container = this.leftLayoutContainer,
                breadcrumb = mainView && mainView.getBreadcrumb ? mainView.getBreadcrumb() : null,
                state = this.getNavigationState && this.getNavigationState() || {files:false};

            if(breadcrumb) {
                this.subscribe(types.EVENTS.ON_OPEN_VIEW, function (e) {
                    var view = e.view;
                    if(view instanceof gridClass) {
                        view.addHandle('click',view.on('click',function(){
                            breadcrumb.setSource(view);
                        }));
                        breadcrumb.setSource(view);
                        var srcStore = view.collection;
                        function _onChangeFolder(store,item,grid){
                            if(breadcrumb.grid!=grid){
                                breadcrumb.setSource(grid);
                            }
                            breadcrumb.clear();
                            breadcrumb.setPath('.',srcStore.getRootItem(),item.getPath(),store);
                        }

                        view._on('openFolder', function (evt) {
                            _onChangeFolder(srcStore,evt.item,view);
                        });
                    }
                });
            }

            if(!container){
                return;
            }

            var newTarget= mainView.layoutCenter,
                ctx = this.ctx;

            if(mainView.getNewDefaultTab){
                newTarget = function(args){
                    return mainView.getNewDefaultTab(args);
                }
            }
            _require([
                'xfile/factory/Store',
                'xfile/types',
                'xfile/views/Grid',
                'xfile/views/FileGrid',
                'xfile/views/FilePreview'
            ],function(factory,types,Grid,FileGrid,FilePreview){

                ctx.registerEditorExtension('Preview', 'mp4|ma4|mov|html|pdf|avi|mp3|mkv|ogg|png|jpg', 'fa-play', this, true, null, FilePreview.EditorClass, {
                    updateOnSelection: false,
                    leftLayoutContainer: newTarget,
                    ctx: ctx
                });

                var store = factory.createFileStore('workspace_user',null,config,null,thiz.ctx);
                var tab = container.createTab('Files','fa-folder',state.files ? true : ! false );
                var grid = utils.addWidget(FileGrid,{
                    newTabArgs:{
                        showHeader:true
                    },
                    style:'height:100%',

                    newTarget: newTarget,
                    collection: store.getDefaultCollection(),
                    showHeader: false,
                    registerEditors:true,
                    open: state.files ? true : ! false ,
                    resizeToParent:true,
                    _columns: {
                        "Name": true,
                        "Path": false,
                        "Size": false,
                        "Modified": false
                    },
                    title:'Files',
                    icon:'fa-folder'
                },null,tab,false);
                tab.add(grid);
                thiz.ctx.getWindowManager().registerView(grid,true);
                if(breadcrumb){
                    breadcrumb.setSource(grid);
                    var srcStore = grid.collection;

                    function _onChangeFolder(store, item, grid) {
                        if (breadcrumb.grid != grid) {
                            breadcrumb.setSource(grid);
                        }
                        breadcrumb.clear();
                        breadcrumb.setPath('.', srcStore.getRootItem(), item.getPath(), store);
                    }

                    grid._on('openedFolder', function (evt) {
                        _onChangeFolder(srcStore, evt.item, grid);
                    });
                }
                thiz.fileGrid = grid;

                grid._on('startup',function(){
                    grid.showStatusbar(false);
                });



                if(! false ){
                    grid.startup();
                    grid.resize();
                }

                thiz.addNavigationGrid && thiz.addNavigationGrid(grid);
                if(thiz._saveNavigationState) {
                    state.files && setTimeout(function(){
                        grid.startup();
                    },500);
                }

            });
        },
        initXFile: function () {
            var config = {};
            var dfd = new Deferred();
            types.config = config = {};
            var xFileConfiguration = config || typeof(xFileConfig) !== 'undefined' ? xFileConfig : null;
            if (xFileConfiguration) {
                if (typeof xFileConfigMixin != 'undefined') {
                    utils.mixin(xFileConfiguration, xFileConfigMixin);
                }
                utils.mixin(types.config, xFileConfiguration);
            }

            var _re = require;
            var thiz = this,
                ctx = this.ctx;

            var fMgr = _re([
                'xfile/manager/FileManager',
                'xfile/manager/MountManager',
                'xfile/views/FileGrid'
            ],function(FileManager,MountManager,FileGrid){

                FileGrid.prototype.ctx = ctx;
                ctx.doMixins(ctx.mixins);
                utils.mixin(thiz.config,types.config);

                ctx.fileManager = ctx.createManager(FileManager,thiz.config);
                ctx.fileManager.init();

                ctx.mountManager = ctx.createManager(MountManager,thiz.config);
                ctx.mountManager.init();
                ctx.mountManager.ls().then(function(){
                    thiz.onXFileReady(thiz.config,FileGrid);
                });
                dfd.resolve();
            });

            return dfd;
        }
    });
});
},
'xide/utils/CIUtils':function(){
define([
    'xide/utils',
    'xide/types',
    'xide/factory',
    'dojo/has',
    'xide/lodash'
],function(utils,types,factory,has,_){
    "use strict";
    /**
     *
     * @param cis
     * @returns {Array}
     */
    utils.toOptions  = function(cis){
        cis = utils.flattenCIS(cis);
        var result = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            result.push({
                name:utils.toString(ci['name']),
                value:utils.getCIValue(ci),
                type: utils.toInt(ci['type']),
                enumType:utils.toString(ci['enumType']),
                visible:utils.toBoolean(ci['visible']),
                active:utils.toBoolean(ci['active']),
                changed:utils.toBoolean(ci['changed']),
                group:utils.toString(ci['group']),
                user:utils.toObject(ci['user']),
                dst:utils.toString(ci['dst']),
                params:utils.toString(ci['params'])
            })
        }
        return result;
    };

    if( false  ||  false ) {
        utils.getEventsAsOptions = function (selected) {
            var result = [
                {label: "Select Event", value: ""}
            ];
            for (var e in types.EVENTS) {
                var label = types.EVENTS[e];

                var item = {
                    label: label,
                    value: types.EVENTS[e]
                };
                result.push(item);
            }
            result = result.concat(
                [{label: "onclick", value: "onclick"},
                    {label: "ondblclick", value: "dblclick"},
                    {label: "onmousedown", value: "mousedown"},
                    {label: "onmouseup", value: "mouseup"},
                    {label: "onmouseover", value: "mouseover"},
                    {label: "onmousemove", value: "mousemove"},
                    {label: "onmouseout", value: "mouseout"},
                    {label: "onkeypress", value: "keypress"},
                    {label: "onkeydown", value: "keydown"},
                    {label: "onkeyup", value: "keyup"},
                    {label: "onfocus", value: "focus"},
                    {label: "onblur", value: "blur"},
                    {label: "On Load", value: "Load"}
                ]);
            //select the event we are listening to
            for (var i = 0; i < result.length; i++) {
                var obj = result[i];
                if (obj.value === selected) {
                    obj.selected = true;
                    break;
                }
            }
            return result;
        };
    }

    utils.flattenCIS  = function(cis){
        var addedCIS = [];
        var removedCIs = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];

            var ciType = utils.toInt(ci.type);

            if(ciType > types.ECIType.END){//type is higher than core types, try to resolve it
                var resolved = types.resolveType(ciType);
                if(resolved){
                    utils.mixin(addedCIS,resolved);
                    removedCIs.push(ci);
                }
            }
        }
        if(addedCIS.length>0){
            cis = cis.concat(addedCIS);
        }
        if(removedCIs){
            for(var i in removedCIs){
                cis.remove(removedCIs[i]);
            }
        }
        return cis;
    };

    utils.arrayContains=function(array,element){
        for (var i = 0; i < array.length; i++){
            var _e = array[i];
            if(_e===element){
                return true;
            }
        }
        return false;
    };

    utils.setStoreCIValueByField = function (d, field, value) {
        if (d[field] == null) {
            d[field] = [];
        }
        d[field][0] = utils.getStringValue(value);
        return d;
    };
    /**
     *
     * @param label
     * @param value
     * @param extra
     * @returns {Object}
     */
    utils.createOption=function(label,value,extra){
        return utils.mixin({
            label:label,
            value:value !=null ? value : label
        },extra);
    };
    /**
     *
     * @param name
     * @param type
     * @param value
     * @param args
     * @param settings
     * @returns {{dataRef: null, dataSource: null, name: *, group: number, id: *, title: *, type: *, uid: number, value: *, visible: boolean, enumType: number, class: string}}
     */
    utils.createCI = function (name, type, value,args,settings) {
        var res = {
            dataRef:null,
            dataSource:null,
            name:name,
            group:-1,
            id:name,
            title:name,
            type:type,
            uid:-1,
            value: value!=null ? value : -1,
            visible:true,
            enumType:-1,
            "class":"cmx.types.ConfigurableInformation"
        };
        utils.mixin(res,args);
        if(settings){
            if(settings.publish){
                factory.publish(settings.publish,{
                    CI:res,
                    owner:settings.owner
                },settings.owner);
            }
        }
        return res;
    };

    utils.createCIAsArray = function (name, type, chain,value) {
        return {
            chainType:[chain ? chain : 0],
            dataRef:[null],
            dataSource:[null],
            params:[],
            name:[name],
            group:[-1],
            id:[name],
            title:[name],
            type:[type],
            uid:[-1],
            value: [value ? value : -1],
            visible:[true],
            enumType:[-1],
            parentId:[-1],
            "class":["cmx.types.ConfigurableInformation"]
        };
    };

    utils.hasValue = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset";
    };

    utils.hasValueAndDataRef = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset" &&
            data.dataRef &&  data.dataRef[0] !=null && data.dataRef[0].length > 0 && data.dataRef[0] !="0" && data.dataRef[0] !="undefined";
    };

    utils.getInputCIByName = function (data,name){
        if(!data){
            return null;
        }
        var chain = 0;
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains, be nice
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    /***
     *
     * @param data
     * @param chain
     * @param name
     * @returns {*}
     */
    utils.getCIByChainAndName = function (data, chain, name) {
        if(!data){
            return null;
        }
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIByUid= function (dstChain, uid) {
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.uid);
                if (_n!=null && _n === uid)
                {
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIById= function (data, chain, id) {
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                if (ci.id[0] == id[0]  )
                    return ci;
            }
        }
        return null;
    };
    utils.getCIInputValueByName = function (data, name) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci.value;
        }
        return null;
    };
    utils.getCIValue = function (data){
        return utils.getCIValueByField(data,"value");
    };
    utils.getStringValue = function (d){
        return utils.toString(d);
    };
    utils.toString = function (d){
        if (d != null) {
            if(!_.isArray(d))
            {
                return ''+ d;
            }
            if(d && d.length==1 && d[0]==null)
            {
                return null;
            }
            return '' + (d[0] !=null ? d[0] : d);
        }
        return null;
    };
    utils.setIntegerValue = function (data,value){
        if (data != null) {

            if(dojo.isArray(data))
            {
                data[0]=value;
            }else{
                data=value;
            }
        }
    };

    utils.getCIValueByField = function (data, field) {
        if (data[field] != null) {
            if(_.isArray(data[field])){
                return data[field][0] ? data[field][0] : data[field];
            }else{
                return data[field];
            }
        }
        return null;
    };
    utils.setCIValueByField = function (data, field, value) {
        if(!data){
            return data;
        }
        if (data[field] == null) {
            data[field] = [];
        }
        data[field]=value
        return data;
    };

    utils.setCIValue = function (data, field, value) {
        var ci = utils.getInputCIByName(data,field);
        if(ci){
            utils.setCIValueByField(ci,'value',value);
        }
        return ci;
    };
    utils.getCIInputValueByNameAndField = function (data, name, field) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci["" + field];
        }
        return null;
    };

    utils.getCIInputValueByNameAndFieldStr = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.getStringValue(rawValue);
        }
        return null;
    };
    utils.getCIInputValueByNameAndFieldBool = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.toBoolean(rawValue);
        }
        return null;
    };
    utils.getCIWidgetByName=function(cis,name){

        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            if(ci['_widget'] && ci.name===name){
                return ci['_widget'];
            }
        }
        return null;
    };
    return utils;
});
},
'dstore/QueryResults':function(){
define(['dojo/_base/lang', 'dojo/when'], function (lang, when) {
	function forEach(callback, instance) {
		return when(this, function(data) {
			for (var i = 0, l = data.length; i < l; i++){
				callback.call(instance, data[i], i, data);
			}
		});
	}
	return function (data, options) {
		var hasTotalLength = options && 'totalLength' in options;
		if(data.then) {
			data = lang.delegate(data);
			// a promise for the eventual realization of the totalLength, in
			// case it comes from the resolved data
			var totalLengthPromise = data.then(function (data) {
				// calculate total length, now that we have access to the resolved data
				var totalLength = hasTotalLength ? options.totalLength :
						data.totalLength || data.length;
				// make it available on the resolved data
				data.totalLength = totalLength;
				// don't return the totalLength promise unless we need to, to avoid
				// triggering a lazy promise
				return !hasTotalLength && totalLength;
			});
			// make the totalLength available on the promise (whether through the options or the enventual
			// access to the resolved data)
			data.totalLength = hasTotalLength ? options.totalLength : totalLengthPromise;
			// make the response available as well
			data.response = options && options.response;
		} else {
			data.totalLength = hasTotalLength ? options.totalLength : data.length;
		}

		data.forEach = forEach;

		return data;
	};
});

},
'xace/views/ACEEditor':function(){
/** @module xace/views/ACEEditor **/
define([
    'dcl/dcl',
    'dojo/has',
    'dojo/dom-construct',
    'xide/utils',
    'xide/types',
    'xide/widgets/TemplatedWidgetBase',
    'xace/views/_Split',
    'xaction/DefaultActions',
    'xace/views/_AceMultiDocs'
], function (dcl, has, domConstruct,utils, types, TemplatedWidgetBase, Splitter, DefaultActions, _AceMultiDocs) {
    var _loadedModes = {};//global cache for loaded modes
    var containerClass = dcl([TemplatedWidgetBase], {
        resizeToParent: true,
        templateString: '<div attachTo="aceNode" style="width: 100%;height: 100%" class=""></div>'
    });

    var EditorInterfaceImplementation = dcl(_AceMultiDocs, {
        declaredClass: 'xace/views/EditorInterface',
        editorSession: null,
        _lastValue:null,
        enableMultiDocuments: function () {
            var completer = this.addFileCompleter();
            var text = "var xxxTop = 2*3;";
            var path = "asdf.js";
            completer.addDocument(path, text);
        },
        loadScript: function (url, attributes, readyCB) {
            // DOM: Create the script element
            var jsElm = document.createElement("script");
            // set the type attribute
            jsElm.type = "application/javascript";
            // make the script element load file
            jsElm.src = url;
            jsElm.onload = function () {
                if (readyCB) {
                    readyCB();
                }
            };
            // finally insert the element to the body element in order to load the script
            document.body.appendChild(jsElm);
        },
        setMode: function (mode, _ctx, cb) {
            var ctx = _ctx || this.ctx || window['sctx'];
            if (ctx && ctx.getResourceManager()) {
                var thiz = this;
                if (!_loadedModes[mode]) {
                    var modeFile = null;
                    var aceRoot = ctx.getResourceManager().getVariable(types.RESOURCE_VARIABLES.ACE);
                    if (!aceRoot) {
                        var webRoot = ctx.getResourceManager().getVariable(types.RESOURCE_VARIABLES.APP_URL);
                        if ( false  === true) {
                            webRoot += '/xfile/ext/ace/';
                        } else {
                            webRoot += '/xfile/ext/ace/'
                        }
                        modeFile = webRoot + '/mode-' + mode + '.js';
                    } else {
                        modeFile = aceRoot + '/mode-' + mode + '.js';
                    }
                    this.loadScript(modeFile, null, function () {
                        _loadedModes[mode] = true;//update cache
                        thiz.set('mode', mode);
                        cb && cb(mode);

                    });
                } else {
                    thiz.set('mode', mode);
                    cb && cb(mode);
                }

            } else {
                console.error('have no resource manager!');
            }
        },
        get: function (what) {
            if (what === 'value') {
                var self = this,
                    editor = self.getEditor(),

                    session = editor ? editor.session : null;

                return session ? session.getValue() : null;

            }
            return this.inherited(arguments);
        },
        set: function (key, value) {
            var self = this,
                editor = this.getEditor(),
                session = this.editorSession;

            if (key === 'iconClass') {
                var _parent = this._parent;
                if (_parent && _parent.icon) {
                    this._parent.icon(value);
                }
            }

            if (editor && session) {
                //console.log('set ace option ' + key,value);
                var node = editor.container;
                if (key == 'item') {
                    session.setUseWorker(false);
                    self.getContent(value,
                        function (content) {
                            var newMode = self._getMode(value.path);
                            self.set('value', content);
                            self.setMode(newMode);
                            session.setUseWorker(self.options.useWorker);
                        });
                }

                if (key == "value" && value) {
                    session.setValue(value);
                }
                else if (key == "theme") {
                    if (typeof value == "string") {
                        value = "ace/theme/" + value;
                    }
                    editor.setTheme(value);
                    if (this.split) {
                        this.split.setTheme(value);
                    }
                }
                else if (key == "mode") {
                    try {
                        if ( 1 ) {
                            ace.require(["ace/mode/" + value], function (modeModule) {
                                if (modeModule && modeModule.Mode) {
                                    self.split.$editors.forEach(function (editor) {
                                        editor.session.setMode(new modeModule.Mode());
                                    });
                                }
                            });
                        }
                    } catch (e) {
                        console.error('ace mode failed : ' + value);
                    }
                }
                else if (key == "readOnly") {
                    editor.setReadOnly(value);
                }
                else if (key == "tabSize") {
                    session.setTabSize(value);
                }
                else if (key == "softTabs") {
                    session.setUseSoftTabs(value);
                }
                else if (key == "wordWrap") {
                    session.setUseWrapMode(value);
                }
                else if (key == "printMargin") {
                    editor.renderer.setPrintMarginColumn(value);
                }
                else if (key == "showPrintMargin") {
                    editor.setShowPrintMargin(value);
                }
                else if (key == "highlightActiveLine") {
                    editor.setHighlightActiveLine(value);
                }
                else if (key == "fontSize") {
                    $(node).css(key, value);
                }
                else if (key == "showIntentGuides") {
                    editor.setDisplayIndentGuides(value);
                }
                else if (key == "elasticTabstops") {
                    editor.setOption("useElasticTabstops", value);
                }
                else if (key == "useIncrementalSearch") {
                    editor.setOption("useIncrementalSearch", value);
                }
                else if (key == "showGutter") {
                    editor.renderer.setShowGutter(value);
                }
            }
            return this.inherited("set", arguments);
        },
        _getMode: function (fileName) {
            fileName = fileName || this.fileName;
            var ext = 'javascript';
            if (fileName) {

                ext = utils.getFileExtension(fileName) || 'js';

                if (ext === 'js' || ext === 'xblox') {
                    ext = 'javascript';
                }

                if (ext === 'h' || ext === 'cpp') {
                    ext = 'c_cpp';
                }

                if (ext === 'html' || ext === 'cfhtml' || ext === 'dhtml') {
                    ext = 'html';
                }
                if (ext === 'cp') {
                    ext = 'xml';
                }
                if (ext === 'md') {
                    ext = 'markdown';
                }
                if (ext === 'hbs') {
                    ext = 'handlebars';
                }
            }
            return ext;
        },
        setOptions: function (options) {
            this.options = options;
            _.each(options, function (value, name) {
                this.set(name, value);
            }, this);

            var editor = this.getEditor();
            if (editor && options.aceOptions) {
                editor.setOptions(options.aceOptions);
                editor.session.setUseWorker(options.useWorker);
                editor.setOptions({
                    enableBasicAutocompletion: true,
                    enableSnippets: true,
                    enableLiveAutocompletion: true
                });
                this.setMode(options.mode);
            }
            return this.options;
        },
        getOptions: function () {
            return this.options;
        },
        onContentChange: function (value) {
            if(this._parent && this._parent.set){
                this._parent.set('changed',value!==this.lastSavedContent);
            }
        },
        onDidChange: function () {
            var value = this.get('value');
            if(this._lastValue!==value){
                this._lastValue = value;
                this._emit('change',value);
                this.onContentChange(value);
            }
        },
        getDefaultOptions: function (value, mixin) {
            var thiz = this;
            return utils.mixin({
                region: "center",
                style: "margin: 0; padding: 0; position:relative;overflow: auto;height:inherit;width:inherit;text-align:left;",
                readOnly: false,
                tabSize: 2,
                wordWrap: false,
                showPrintMargin: false,
                highlightActiveLine: true,
                fontSize: 16,
                showGutter: true,
                showLineNumbers: true,
                useWorker: true,
                showInvisibles: false,
                displayIndentGuides: true,
                useSoftTabs: true,
                fileName: 'none',
                mode: 'javascript',
                value: value || this.value || 'No value',
                theme: 'idle_fingers',
                splits: 1,
                useElasticTabstops: false,
                animatedScroll: false,
                highlightActive: true,
                aceOptions: {
                    enableBasicAutocompletion: true,
                    enableSnippets: true,
                    enableLiveAutocompletion: true
                },
                onLoad: function (_editor) {
                    // This is to remove following warning message on console:
                    // Automatically scrolling cursor into view after selection change this will be disabled in the next version
                    // set editor.$blockScrolling = Infinity to disable this message
                    _editor.$blockScrolling = Infinity;
                },
                onDidChange: function () {
                    var value = thiz.get('value');
                    if(value!==thiz.lastSavedContent) {
                        thiz.onContentChange(value);
                    }
                },
                onPrefsChanged: function () {
                    thiz.setPreferences && thiz.setPreferences();
                }
            }, mixin);
        },
        getEditor: function (index) {
            if (this.split) {
                return index == null ? this.split.getCurrentEditor() : this.split.getEditor(index != null ? index : 0);
            } else if (this.editor) {
                return this.editor;
            }
        },
        resize: function (what, target, event) {
            var options = this.options || {};

            this.onResize && this.onResize();

            function _resize() {
                var editor = this.getEditor(),
                    widget = this.split || this.editor;
                if (!editor || !this.aceNode || !editor.container) {
                    this['resize_debounced'].cancel();
                    this['resize_debounced'] = null;
                    return;
                }
                editor && utils.resizeTo(editor.container, this.aceNode, true, true);
                return widget ? widget.resize() : null;
            }
            return this.debounce('resize', _resize.bind(this), options.resizeDelay || 300, null);
            //_resize().bind(this);
        },
        getAce: function () {
            return this.getEditor();
        },
        addBasicCommands: function (editor) {
            editor = editor || this.getEditor();
            var thiz = this,
                whiteSpace = ace.require("ace/ext/whitespace");

            this._whiteSpaceExt = whiteSpace;


            editor.commands.addCommands(whiteSpace.commands);

            editor.commands.addCommands([
                {
                    name: "gotoline",
                    bindKey: {win: "Ctrl-L", mac: "Command-L"},
                    exec: function (editor, line) {
                        if (typeof line == "object") {
                            var arg = this.name + " " + editor.getCursorPosition().row;
                            editor.cmdLine.setValue(arg, 1);
                            editor.cmdLine.focus();
                            return;
                        }
                        line = parseInt(line, 10);
                        if (!isNaN(line))
                            editor.gotoLine(line);
                    },
                    readOnly: true
                },
                {
                    name: "snippet",
                    bindKey: {win: "Alt-C", mac: "Command-Alt-C"},
                    exec: function (editor, needle) {
                        if (typeof needle == "object") {
                            editor.cmdLine.setValue("snippet ", 1);
                            editor.cmdLine.focus();
                            return;
                        }
                        var s = snippetManager.getSnippetByName(needle, editor);
                        if (s)
                            snippetManager.insertSnippet(editor, s.content);
                    },
                    readOnly: true
                },
                {
                    name: "increaseFontSize",
                    bindKey: "Ctrl-+",
                    exec: function (editor) {
                        editor.setFontSize(editor.getFontSize() + 1);
                        thiz.onAfterAction();
                    }
                }, {
                    name: "decreaseFontSize",
                    bindKey: "Ctrl+-",
                    exec: function (editor) {
                        editor.setFontSize(editor.getFontSize() - 1);
                        thiz.onAfterAction();
                    }
                }, {
                    name: "resetFontSize",
                    bindKey: "Ctrl+0",
                    exec: function (editor) {
                        editor.setFontSize(12);
                        thiz.onAfterAction();
                    }
                }
            ]);
        },
        onEditorCreated: function (editor, options) {
            var thiz = this;
            editor.getSelectedText = function () {
                return thiz.editorSession.getTextRange(this.getSelectionRange());
            };
            editor.on('change', function () {
                thiz.onDidChange(arguments);
            });
            this.addBasicCommands(editor);
            editor.setFontSize(options.fontSize);
            editor.$blockScrolling = Infinity;
            //var a = editor.session.doc.getNewLineCharacter();

            if(this._whiteSpaceExt){
                this._whiteSpaceExt.detectIndentation(editor.session);
            }

        },
        destroy: function () {
            var editor = this.getEditor();
            editor && editor.destroy();
            var _resize = this['resize_debounced'];
            if (_resize) {
                _resize.cancel();
            }
        },
        getOptionsMixed: function (_options) {
            var settings = this.getPreferences ? this.getPreferences() : {};
            var options = this.getDefaultOptions(this.value, _options || this.options);
            //apply overrides
            utils.mixin(options, _options);
            //apply settings from persistence store
            utils.mixin(options, settings);
            options.mode = this._getMode(options.fileName);
            return options;
        },
        createEditor: function (_options, value) {

            this.set('iconClass', this.iconClassNormal);

            if (this.editor || this.split) {
                return this.editor || this.split;
            }
            var settings = this.getPreferences ? this.getPreferences() : {};
            var options = this.getDefaultOptions(value);

            //apply overrides
            utils.mixin(options, _options);
            //apply settings from persistence store
            utils.mixin(options, settings);
            options.mode = this._getMode(options.fileName);

            var node = options.targetNode || domConstruct.create('div');
            $(node).css({
                padding: "0",
                margin: "0",
                height: '100%',
                width: '100%'
            });


            this.aceNode.appendChild(node);

            var config = ace.require("ace/config"),
                split = null,
                editor = null;
            ace.require("ace/ext/language_tools");
            try {
                var Split = Splitter.getSplitter();
                split = new Split(node, null, 1);
                this.split = split;
                this._aceConfig = config;
                config.init();
                //ace.require('ace/ext/language_tools');
                this.editor = editor = split.getEditor(0);
                this.editorSession = this.editor.getSession();
                if (value) {
                    this.editorSession.setValue(value);
                }
                split && split.setSplits(options.splits);
            } catch (e) {
                logError(e, 'error creating editor');
            }
            this.setOptions(options);
            this.onEditorCreated(editor, options);
            return editor;
        },
        addAutoCompleter: function (list) {
            var langTools = ace.require("ace/ext/language_tools");
            var rhymeCompleter = {
                getCompletions: function (editor, session, pos, prefix, callback) {
                    if (prefix.length === 0) {
                        callback(null, []);
                        return;
                    }
                    if (!list) {
                        callback(null, []);
                        return;
                    }
                    callback(null, list.map(function (ea) {
                        return {name: ea.value, value: ea.word, meta: ea.meta}
                    }));
                }
            };
            langTools.addCompleter(rhymeCompleter);
        }
    });

    var EditorClass = dcl(null, {
        declaredClass: 'xace/views/ACE',
        onLoaded: function () {
            this.set('iconClass', this.iconClassNormal);
        },
        getKeyTarget: function () {
            return this.aceNode;
        },
        startup: function () {
            this.aceNode.id = utils.createUUID();
            if (this.permissions) {
                var _defaultActions = DefaultActions.getDefaultActions(this.permissions, this, this);
                _defaultActions = _defaultActions.concat(this.getEditorActions(this.permissions));
                this.addActions(_defaultActions);
            }

            //save icon class normal
            this.iconClassNormal = '' + this.iconClass;
            this.set('iconClass', 'fa-spinner fa-spin');
            var self = this,
                options = this.options || {};

            if (!this.item && this.value == null) {
                return;
            }

            function createEditor(options, value) {
                /*
                if(typeof ace === "function"){
                    ace(function(_ace){
                        ACE = _ace;
                        self.createEditor(self.options || options, value);
                    });
                    return;
                }
                */
                self.createEditor(self.options || options, value);
            }




            if (this.value != null) {
                this.lastSavedContent = '' + this.value;
                createEditor(null, this.value);
            } else {
                //we have no content yet, call in _TextEditor::getContent, this will be forwarded
                //to our 'storeDelegate'
                this.getContent(
                    this.item,
                    function (content) {//onSuccess
                        self.lastSavedContent = content;
                        createEditor(options, content);
                    },
                    function (e) {//onError
                        createEditor(null, '');
                        logError(e, 'error loading content from file');
                    }
                );
            }
        }
    });
    var Module = dcl([containerClass, EditorClass, EditorInterfaceImplementation], {});
    Module.EditorImplementation = EditorInterfaceImplementation;
    Module.Editor = EditorClass;
    Module.Container = containerClass;
    Module.Splitter = Splitter;
    return Module;
});
},
'xfile/views/FilePicker':function(){
/** @module xfile/views/FilePicker **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/factory',
    'module',
    'xide/_base/_Widget',
    'xdocker/Docker2',
    'xfile/ThumbRenderer',
    'dojo/promise/all',
    'xfile/Breadcrumb'
], function (dcl, types, utils, factory,
             module, _Widget, Docker2, ThumbRenderer, all, Breadcrumb) {

    var ACTION = types.ACTION;
    var Module = dcl(_Widget, {
        declaredClass:'xfile.views.FilePicker',
        templateString: '<div class="FilePicker"></div>',
        resizeToParent: true,
        docker: null,
        dockerOptions : {
            resizeToParent: true
        },
        breadcrumb: null,
        leftStore: null,
        rightStore: null,

        storeOptionsMixin: null,
        storeOptions: null,

        leftGrid: null,
        leftGridArgs: null,

        rightGrid: null,
        rightGridArgs: null,
        removePermissions:[
            ACTION.OPEN_IN_TAB
        ],
        defaultGridArgs: {
            registerEditors: false,
            _columns: {
                "Name": true,
                "Path": false,
                "Size": false,
                "Modified": false
            }
        },
        selection:null,
        mount: 'root',
        _selection:null,
        getDocker:function(){
            if(this.docker){
                return this.docker;
            }
            var dockerOptions = this.dockerOptions || {
                resizeToParent: true
            };
            var docker = this.docker || Docker2.createDefault(this.domNode, dockerOptions);
            docker.resizeToParent = true;
            this.add(docker, null, false);

            this.docker = docker;
            return docker;
        },
        createLayout: function () {
            var docker = this.getDocker();
            this.layoutTop = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.TOP, null, {
                h: 50,
                title: false
            });
            this.layoutTop._minSize.y = 50;
            this.layoutTop._maxSize.y = 50;
            this.layoutTop._scrollable = {
                x: false,
                y: false
            };
            this.breadcrumb = utils.addWidget(Breadcrumb, {}, null, this.layoutTop, true);
            this.layoutLeft = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.BOTTOM, null, {
                w: 100,
                title: false
            });
            this.layoutLeft._minSize.x = 150;
            this.layoutLeft.moveable(true);
            this.layoutMain = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.RIGHT, this.layoutLeft, {
                w: '70%',
                title: false
            });
            this.layoutTop.initSize(100,'100%');
            this.layoutLeft.initSize('100%',150);
            docker.resize();
        },
        setSelection:function(selection){
            this._selection=selection;
        },
        connectGrids:function(src,target){

            var self = this;

            target._on('selectionChanged', function (event) {
                if(event.why !=='deselect') {
                    var selection = target.getSelection(),
                        item = target.getSelectedItem();

                    if(item){
                        self.setSelection(selection);
                    }
                }
            });
            src._on('selectionChanged', function (event) {
                var selection = src.getSelection(),
                    item = src.getSelectedItem();
                if (!item) {
                    item = src.getCurrentFolder();
                }
                if(!item){
                    return;
                }
                var targetFolder = null;
                if (item.directory) {
                    targetFolder = item;
                } else {
                    if(!item.getParent){
                        console.error('item has no item.getParent!');
                    }
                    targetFolder = item.getParent ? item.getParent() : null;
                }
                if (targetFolder) {
                    target.openFolder(targetFolder.path, false);
                }

                if(item){
                    self.setSelection(selection);
                }
            });

        },
        createFileGrid: function (store, parent, args) {
            var GridClass = this.Module /*|| FileGrid*/;
            return GridClass.createDefault(this.ctx, args, parent, false, true, store);
        },
        onLeftGridReady:function(grid){},
        onRightGridReady:function(grid){},
        onError:function(err,where){
            //console.error('File Picker Error: '+ where + ' : ' + err,err);
        },
        startGrids:function(left,right){
            var self = this,
                srcStore = left.collection,
                targetStore = right.collection,
                _selectArgs = {
                    focus: true,
                    append: false
                },
                both = [left.refresh(), right.refresh()];
            var selected = this.selection;// './AA/xfile_last/Selection_002.png';
            var pathInfo = utils.pathinfo(selected, types.PATH_PARTS.ALL);
            var path = pathInfo.dirname || "";
            if(path==='.'){
                path = selected;
            }
            left.showStatusbar && left.showStatusbar(false);

            left._on('changeSource',function(mountdata){
                right.changeSource(mountdata,true);
            });
            left._on('changedSource',function(mountdata){
                left.select([0],null,true,_selectArgs);
            });
            right._on('changeSource',function(mountdata){
                left.changeSource(mountdata,true);
            });
            right._on('changedSource',function(mountdata){
                left.select([0],null,true,_selectArgs);
            });

            all(both).then(function () {
                self.onLeftGridReady(left);
                self.onRightGridReady(right);
                self.getDocker().resize();
                //load the selected item in the store
                all([srcStore.getItem(path, true), targetStore.getItem(path, true)]).then(function (what) {
                    //when loaded, open that folder!
                    all(_.invoke([left], 'openFolder', path)).then(function () {
                        //when opened, select the selected item
                        all(_.invoke([left,right], 'select', [selected], null, true, _selectArgs)).then(function () {
                            //when selected, complete grids
                            selected._selection = selected;
                            self.connectGrids(left, right);
                            self.setupBreadcrumb(left, right,selected);
                        },function(err){
                            self.onError(err,'selecting items');
                        });

                    },function(err){
                        self.onError(err,'open folder');
                    });
                },function(err){
                    self.onError(err,'loading items');
                });
            },function(error){
                self.onError(err,'refresh grid');
            });
        },
        /**
         * Function called right after left & right grid is ready (opened folders,...)
         * @param src
         * @param target
         */
        setupBreadcrumb:function(src,target,openPath){
            
            var breadcrumb = this.breadcrumb,
                cwd = src.getCurrentFolder(),
                srcStore = src.collection,
                targetStore = target.collection;
            breadcrumb.setSource(src);

            function _onChangeFolder(store,item,grid){
                if(breadcrumb.grid!=grid){
                    breadcrumb.setSource(grid);
                }
                breadcrumb.clear();
                breadcrumb.setPath('.',srcStore.getRootItem(),item.getPath(),store);
            }

            this.addHandle('click',src.on('click',function(){
                breadcrumb.setSource(src);
            }));
            this.addHandle('click',target.on('click',function(){
                breadcrumb.setSource(target);
            }));
            src._on('openFolder', function (evt) {
                _onChangeFolder(srcStore,evt.item,src);
            });
            target._on('openFolder', function (evt) {
                _onChangeFolder(targetStore,evt.item,target);
            });

        },
        destroy:function(){
          
            utils.destroy(this.leftStore);
            utils.destroy(this.rightStore);
            utils.destroy(this.leftGrid);
            utils.destroy(this.rightGrid);
            utils.destroy(this.breadcrumb);
            utils.destroy(this.docker);
            
        },
        startup: function () {
            this.createLayout();
            var leftParent = this.layoutLeft;
            var rightParent = this.layoutMain;
            var self = this,
                ctx = self.ctx,
                config = ctx.config;

            /**
             * File Stores
             */
            var mount = this.mount || 'root';
            var storeOptions = this.storeOptions;
            var storeOptionsMixin = this.storeOptionsMixin || {
                    "includeList": "*.jpg,*.png",
                    "excludeList": "*"
                };

            var leftStore = this.leftStore || factory.createFileStore(mount, storeOptions, config, storeOptionsMixin, ctx);
            var rightStore = this.rightStore || factory.createFileStore(mount, storeOptions, config, storeOptionsMixin, ctx);
            var newTabTarget = this.layoutMain;
            var defaultGridArgs = utils.mixin({},utils.clone(this.defaultGridArgs));
            var removePermissions = this.removePermissions;
            /**
             *  Left - Grid :
             */
            var leftGridArgs = utils.mixin(defaultGridArgs, this.leftGridArgs || {
                    newTarget: newTabTarget
                });
            _.remove(leftGridArgs.permissions, function (permission) {
                return _.indexOf(removePermissions, permission) !== -1;
            });
            //eg: leftGridArgs.permissions.remove(types.ACTION.STATUSBAR);
            var gridLeft = this.leftGrid || this.createFileGrid(leftStore, leftParent, leftGridArgs);
            this.leftGrid = gridLeft;
            /**
             *  Right - Grid :
             */
            var rightGridArgs = utils.mixin(defaultGridArgs,this.rightGridArgs || {
                    selectedRenderer: ThumbRenderer
                });
            _.remove(rightGridArgs.permissions, function (permission) {
                return _.indexOf(removePermissions, permission) !== -1;
            });
            var gridMain = this.rightGrid || this.createFileGrid(rightStore, rightParent, rightGridArgs);
            this.rightGrid = gridMain;
            return this.startGrids(gridLeft,gridMain);
        }
    });

    return Module;

});

},
'xide/model/Component':function(){
/** @module xide/model/Component **/
define([
    "dcl/dcl",
    "dojo/Deferred",
    "dojo/has",
    "require",
    "xide/model/Base",
    "xide/types",
    "xide/mixins/EventedMixin"
], function (dcl, Deferred, has, require, Base, types, EventedMixin) {
    /**
     * COMPONENT_FLAGS is a number of flags being used for the component's instance creation. Use an object instead of
     * an integer, never know how big this becomes and messing with 64bit integers doesn't worth the effort.
     *
     * @enum module:xide/types/COMPONENT_FLAGS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.COMPONENT_FLAGS = {
        /**
         * Due the object instantiation, instruct the component loader to call ::load()
         * @constant
         */
        LOAD: 1,
        /**
         * Due the object instantiation, instruct the component loader to call ::run()
         * @constant
         */
        RUN: 1
    };

    /**
     * @class xide/model/Component
     * @extends module:xide/mixins/EventedMixin
     * @extends module:xide/model/Base
     */
    return dcl([Base.dcl, EventedMixin.dcl], {
        declaredClass:"xide/model/Component",
        /**
         * Flag indicating that all dependencies are fully loaded
         * @type {boolean}
         * @default false
         */
        _loaded: false,
        /**
         * Pointer to a context, filled by the component loader
         * @member module:xide/manager/Context
         */
        ctx: null,
        /**
         * Pointer to an optional owner
         * @member {Object|null}
         */
        owner: {
            reloadComponent: function () {
            }
        },
        /**
         * Usually a component is about a new beantype.
         * @TODO handle many
         */
        beanType: null,
        /**
         * Array of typical JS packages
         * @member {Array|null} packages
         */
        packages: null,

        /**
         * Array of resources. A components has typically a bunch of resources like CSS.
         * @member {Array} resources
         */
        resources: [],
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies: function () {
            return [];
        },
        hasEditors: function () {
            return [];
        },
        /**
         * Return a human readable string
         * @returns {string}
         */
        getLabel: function () {
            return "Have no label";
        },
        /**
         * If this component has additional dependencies, load them here!
         * @returns {dojo.Deferred}
         */
        load: function (hasName) {
            var _defered = new Deferred(),
                thiz = this,
                _re = require;

            hasName = hasName || this.getLabel();

            _re(this.getDependencies(), function () {
                thiz._loaded = true;
                if (hasName) {
                    has.add(hasName, function () {
                        return true;
                    });
                }
                _defered.resolve();
            });
            return _defered.promise;
        },
        run: function () {
            return false;
        },
        onModuleReloaded: function () {
            this.owner.reloadComponent(this);
        },
        isLoaded: function () {
            return this._loaded;
        }
    });
});


},
'xfile/manager/FileManager':function(){
/** @module xfile/manager/FileManager */
define([
    'dcl/dcl',
    'dojo/_base/kernel',
    'xide/manager/ServerActionBase',
    'xide/types',
    'xfile/types',
    'xide/utils',
    'xide/encoding/SHA1',
    'xide/manager/RPCService',
    'dojo/Deferred',
    'xdojo/has',
    'xfile/manager/FileManagerActions',
    'require',
    'xfile/factory/Store',
    "xide/lodash",
    'xdojo/has!electron?xfile/manager/Electron'
], function (dcl,dojo,ServerActionBase, types, fTypes, utils, SHA1, RPCService, Deferred,has,FileManagerActions,require,StoreFactory,_,Electron) {
    var bases = [ServerActionBase, FileManagerActions];
    if(has('electronx') && Electron){
        bases.push(Electron);
    }
    var debug = false;
    /**
     * @class module:xfile.manager.FileManager
     * @extends {module:xide/manager/ServerActionBase}
     * @extends {module:xide/manager/ManagerBase}
     * @augments {module:xide/mixins/EventedMixin}
     */
    return dcl(bases, {
        declaredClass:"xfile.manager.FileManager",
        /**
         * Returns a new name 
         * @param item
         * @param others
         * @returns {*}
         */
        getNewName:function(item,others){
            var name = item.name.replace('.meta.json','');
            var found = false;
            var i = 1;
            var newName = null;
            while (!found){
                newName = name + '-' + i + '.meta.json';
                var colliding = _.find(others,{
                    name:newName
                });

                if(!colliding){
                    found = true;
                }else{
                    i++;
                }
            }
            return newName;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _uploadXHR: null,
        store: null,
        config: null,
        filesToUpload: null,
        serviceUrl: "index.php",
        serviceClass: 'XCOM_Directory_Service',
        settingsStore: null,
        stores:[],
        getStore:function(mount,cache){
            var store =  _.find(this.stores,{
                mount:mount
            });
            if(store){
                return store;
            }
            return StoreFactory.createFileStore(mount,null,this.config,null,this.ctx);
        },
        addStore:function(store){
            this.stores.push(store);
            store._on('destroy',this.removeStore.bind(this));
        },
        removeStore:function(store){
            var index = this.stores.indexOf(store);
            if(index) {
                this.stores.remove(store);
            }
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard manager interface implementation
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        download: function (src) {
            var selection = [];
            selection.push(src.path);
            var thiz = this;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            var serviceClass = this.serviceClass || 'XCOM_Directory_Service';
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html",
                "attachment": "1",
                "send": "1"
            });
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            delete  aParams['attachment'];
            delete  aParams['send'];
            var pStr = dojo.toJson(JSON.string(aParams));
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            window.open(downloadUrl);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  File manager only related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getImageUrl: function (src, preventCache, extraParams) {
            preventCache = location.href.indexOf('noImageCache') != -1 || preventCache === true || src.dirty === true;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);

            var serviceClass = this.ctx.getFileManager().serviceClass || 'XCOM_Directory_Service';
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=0';
            downloadUrl += '&send=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html"
            });
            utils.mixin(aParams, extraParams);
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            var pStr = dojo.toJson(aParams);
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            if (preventCache) {
                downloadUrl += '&time=' + new Date().getTime();
            }
            if (extraParams) {
                for (var p in extraParams) {
                    downloadUrl += '&' + p + '=' + extraParams[p];
                }
            }
            return downloadUrl;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Upload related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onFileUploadFailed: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;
            if (item.dfd) {
                item.dfd.reject(item);
            }
            thiz.filesToUpload.remove(item);
            thiz.publish(eventKeys.ON_UPLOAD_FAILED, {item: item}, thiz);
        },
        onFileUploaded: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;

            setTimeout(function () {
                var struct1 = {
                    message: '' + item.file.name + ' uploaded to ' + item.dstDir,
                    messageArgs: {}
                };
                thiz.publish(eventKeys.STATUS, struct1, thiz);
                if (item.dfd) {
                    item.dfd.resolve(item);
                }
                thiz.filesToUpload.remove(item);
                thiz.publish(eventKeys.ON_UPLOAD_FINISH, {item: item});
            }, 500);
        },
        getUploadUrl: function () {
            var url = '' + decodeURIComponent(this.serviceUrl);
            url = url.replace('view=rpc', 'view=upload');
            url = url.replace('../../../../', './');
            url += '&service=';
            url += this.serviceClass;
            url += '.put&callback=nada';
            return url;
        },
        initXHRUpload: function (item, autoRename, dstDir, mount) {
            var xhr = new XMLHttpRequest();
            var uploadUrl = this.getUploadUrl();
            var uri = '' + uploadUrl;
            uri += '&mount=' + encodeURIComponent(mount);
            uri += '&dstDir=' + encodeURIComponent(dstDir);
            var thiz = this;
            var upload = xhr.upload;
            upload.addEventListener("progress", function (e) {
                if (!e.lengthComputable) {
                    thiz.onFileUploaded(item);
                } else {
                    var struct = {
                        item: item,
                        progress: e
                    };
                    item.isLoading = true;
                    item.dfd.progress(struct);
                }
            }.bind(this), false);

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.responseText && xhr.responseText != 'OK') {
                        var error = utils.getJson(xhr.responseText);
                        if (!error && xhr.responseText.indexOf('Fata Error')) {
                            error = {
                                result: [xhr.responseText],
                                code: 1
                            };
                        }
                        if (error && error.result && _.isArray(error.result) && error.result.length > 0) {
                            var _message = null;
                            for (var i = 0; i < error.result.length; i++) {
                                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.result[i], thiz);
                                _message = error.result[i];
                            }
                            if (_message) {
                                item.error = _message;
                            }
                            thiz.onFileUploadFailed(item);
                            thiz.submitNext();
                            return;
                        }
                        if (error && error.error) {
                            thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.error.message, thiz);
                            thiz.onFileUploadFailed(item);
                        }
                    }
                    thiz.onFileUploaded(item);
                    thiz.submitNext();
                }
            }.bind(this);
            upload.onerror = function () {
                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name, thiz);
            };
            xhr.open("POST", uri, true);
            return xhr;
        },
        hasLoadingItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (this.filesToUpload[i].status == 'loading') {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        /**
         *
         * @param files
         * @param mount
         * @param path
         * @param callee
         * @param view
         * @returns {Deferred[]}
         */
        upload: function (files, mount, path, callee, view) {
            var dfds = [];
            for (var i = 0; i < files.length; i++) {
                var uploadStruct = {
                    file: files[i],
                    dstDir: '' + path,
                    mount: '' + mount,
                    callee: callee,
                    view: callee,
                    dfd: new Deferred()
                };
                dfds.push(uploadStruct['dfd']);
                this.filesToUpload.push(uploadStruct);
            }
            this.submitNext();
            return dfds;
        },
        sendFileUsingFormData: function (xhr, file) {
            var formData = new FormData();
            formData.append("userfile_0", file.file);
            xhr.send(formData);
        },
        sendFileMultipart: function (item) {
            var auto_rename = false;
            item.status = 'loading';
            var xhr = this.initXHRUpload(item, (auto_rename ? "auto_rename=true" : ""), item['dstDir'], item['mount']);
            this.publish(types.EVENTS.ON_UPLOAD_BEGIN,{
                item: item,
                name: item.name
            }, this);
            if (window.FormData) {
                this.sendFileUsingFormData(xhr, item);
            }
        },
        submitNext: function () {
            var item = this.getNextUploadItem();
            if (item) {
                this.sendFileMultipart(item);
            }
        },
        getNextUploadItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (!this.filesToUpload[i].status) {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Error handling
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, err.message.join('<br/>'), this);
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok', this);
                }
            }
            this.publish(types.EVENTS.ERROR, {
                error: err
            }, this);
        },
        addError: function (def) {
            var thiz = this;
            var _cb = function () {
                thiz.onError();
            };
            def.addCallback(_cb);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  pre RPC roundup
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        downloadItem: function (src, readyCB) {
            return this.callMethod(types.OPERATION.DOWNLOAD, [src], readyCB, true);
        },
        downloadTo: function (url, mount, dst, readyCB, dstItem) {
            if (dstItem) {
                var thiz = this;
                var _cb = function (result) {
                    var _failed = false;
                    if (result && result.error && result.error.code == 1) {
                        _failed = true;
                    }
                    thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_END, {
                        terminatorItem: dstItem,
                        failed: _failed
                    }, this);

                    readyCB(arguments);
                };
                thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_BEGIN, {
                    dst: dstItem,
                    url: url,
                    items: [dstItem]
                }, this);
            } else {
                console.log('download from remote url have no dest item');
            }
            return this.callMethod(types.OPERATION.DOWNLOAD_TO, [url, mount, dst], _cb, true);
        },
        find: function (mount, conf, readyCB) {
            try {
                return this.callMethod(types.OPERATION.FIND, [mount, conf], readyCB, true);
            } catch (e) {
                logError(e,'find');
            }
        },
        getContent: function (mount, path, readyCB, emit) {
            if(this.getContentE){
                var res = this.getContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            if( true ) {
                var _path = this.serviceObject.base64_encode(utils.buildPath(mount, path, true));
                return this.callMethod(types.OPERATION.GET_CONTENT, [_path, false, false], readyCB, false);
            }else{
                return this._getText(require.toUrl(mount).replace('main.js','') + '/' + path,{
                    sync: false,
                    handleAs: 'text'
                }).then(function(res){
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, 'error running RPC');
                    }
                });
            }
        },
        setContent: function (mount, path, content, readyCB) {
            this.publish(types.EVENTS.ON_CHANGED_CONTENT, {
                'mount': mount,
                'path': path,
                'content': content
            });
            this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                text: "Did save file : " + mount + '://' + path
            });
            if(this.setContentE){
                var res = this.setContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            return this.callMethod(types.OPERATION.SET_CONTENT, [mount, path, content], readyCB, true);
        },
        onMessages: function (res) {
            var events = utils.getJson(res.events);
            if (events && _.isArray(events)) {
                for (var i = 0; i < events.length; i++) {
                    var struct = {
                        path: events[i].relPath
                    };
                    utils.mixin(struct, events[i]);
                    this.publish(events[i].clientEvent, struct, this);
                }
            }
        },
        onErrors: function (res) {},
        init:function(){
            this.stores = [];
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  RPC helpers
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        callMethodEx: function (serverClassIn, method, args, readyCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = serverClassIn || this.serviceClass;
            var thiz = this;
            if (!this.serviceObject[serviceClass][method]) {
                if (omitError === true) {
                    this.onError({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method]
                    });
                }
                return null;
            }
            /***
             * Build signature
             */
            var params = {};
            params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
            /**
             * Mixin mandatory fields
             */
            params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
            this.serviceObject.extraArgs = params;
            this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
            this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            this.serviceObject[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }
                if (res && res.error && res.error.code == 3) {
                    setTimeout(function () {
                        thiz.onMessages(res.error);
                    }, 50);
                }

                if (res && res.error && res.error && res.error.code !== 0) {
                    thiz.onError(res.error);
                    return;
                }

                thiz.publish(types.EVENTS.STATUS, {
                    message: 'Ok!'
                }, this);

            }, function (err) {
                thiz.onError(err);
            });


        },
        callMethod: function (method, args, readyCB, omitError) {
            var thiz = this;
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = this.serviceClass;
            try {
                if (!this.serviceObject[serviceClass][method]) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                var dfd = this.serviceObject[this.serviceClass][method](args);
                dfd.then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        logError(e, 'error running RPC');

                    }
                    //@TODO: batch, still needed?
                    if (res && res.error && res.error.code == 3) {
                        setTimeout(function () {
                            thiz.onMessages(res.error);
                        }, 50);
                    }

                    if (res && res.error && res.error && res.error.code == 1) {
                        thiz.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        thiz.publish(types.EVENTS.STATUS, struct, this);
                    }
                }, function (err) {
                    thiz.onError(err);
                });
                return dfd;
            } catch (e) {
                console.error('crash calling method' + e,arguments);
                thiz.onError(e);
                logError(e,'error ');
            }
        },
        init:function(){
            this.filesToUpload = [];
        },
        __initService: function () {
            this.filesToUpload = [];
            if (!this.serviceObject) {
                if(this.serviceUrl) {
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl));
                    this.serviceObject.config = this.config;
                }
            }
        }
    });
});
},
'dojo/request/watch':function(){
define([
	'./util',
	'../errors/RequestTimeoutError',
	'../errors/CancelError',
	'../_base/array',
	'../_base/window',
	'../has!host-browser?dom-addeventlistener?:../on:'
], function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
});

},
'xide/manager/Context':function(){
/** module:xide/manager/Context **/
define([
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/has',
    'xide/manager/ContextBase',
    'xide/types',
    'xide/utils',
    'require',
    "dojo/promise/all",
    'xdojo/has!host-browser?xide/manager/Context_UI'
], function (dcl, Deferred, has, ContextBase, types, utils, _require, all, Context_UI) {

    ! 1  &&  false && has.add('xlog', function () {
        return true;
    }, true);

    var isServer =  0 ,
        isBrowser =  1 ,
        bases = isBrowser ? [ContextBase, Context_UI] : [ContextBase],
        debugFileChanges = false,
        debugModuleReload = true;





    /**
     * @class module:xide/manager/Context
     * @extends module:xide/manager/ContextBase
     */
    var Module = dcl(bases, {
        declaredClass: "xide.manager.Context",
        application: null,
        contextManager: null,
        fileManager: null,
        resourceManager: null,
        notificationManager: null,
        serviceObject: null,
        pluginManager: null,
        windowManager: null,
        logManager: null,
        mountManager: null,
        config: null,
        managers: null,
        namespace: 'xide.manager.',
        defaultNamespace: 'xide.manager.',
        vfsMounts: null,
        xideServiceClient: null,
        fileUpdateTimes: {},
        /***********************************************************************/
        /*
         * Global event handlers
         */
        onXIDEMessage: function (data, publish) {
            if (!data || !data.event) {
                return;
            }
            var thiz = this;
            if (data.event === types.EVENTS.ON_FILE_CHANGED) {
                debugFileChanges && console.log("on file changed ", data);
                //inotify plus
                if (data.data && data.data.mask && data.data.mask.indexOf('delete') !== -1) {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }

                if (data.data && data.data.type == 'delete') {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }
                var _path = data.data.path;
                var timeNow = new Date().getTime();
                if (thiz.fileUpdateTimes[_path]) {
                    var last = thiz.fileUpdateTimes[_path];
                    var diff = timeNow - last;
                    if (diff < 1000) {
                        thiz.fileUpdateTimes[_path] = timeNow;
                        return;
                    }
                }


                publish !== false && thiz.publish(data.event, data);
                thiz.fileUpdateTimes[_path] = timeNow;
                //path is absolute and might look like: /PMaster/projects/xbox-app/client/src/lib/xfile/Views.js
                //fix windows path
                var path = utils.replaceAll('\\', '/', data.data.path);
                path = utils.replaceAll('//', '/', data.data.path);
                path = path.replace(/\\/g, "/");

                if (path.indexOf('/build/') !== -1) {
                    return;
                }

                if (path == null || path.indexOf == null) {
                    return;
                }
                if (path.match(/\.css$/)) {
                    thiz.onCSSChanged({
                        path: path
                    });
                }
                /**
                 * Try generic
                 */
                if (path.match(/\.js$/)) {
                    var modulePath = data.data.modulePath;
                    if (modulePath) {
                        modulePath = modulePath.replace('.js', '');
                        var _re = _require;//hide from gcc
                        //try pre-amd module
                        var module = null;
                        try {
                            module = _re(modulePath);
                        } catch (e) {
                        }


                        //special: driver
                        var _start = 'data/system/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'system_drivers/' + libPath;
                        }

                        _start = 'user/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'user_drivers/' + libPath;
                        }


                        var resourceManager = this.getResourceManager(),
                            vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

                        if (vfsConfig && vfsConfig['user_drivers']) {

                            if (path.indexOf(vfsConfig['user_drivers']) !== -1) {
                                var _start = vfsConfig['user_drivers'];
                                _start = _start.replace(/\/+$/, "");
                                var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                                libPath = libPath.replace('.js', '');
                                modulePath = 'user_drivers/' + libPath;
                            }
                        }
                        modulePath = utils.replaceAll('.', '/', modulePath);
                        if (modulePath.indexOf('/build/') === -1 && !isServer) {
                            setTimeout(function () {
                                debugModuleReload && console.log('reloading module ' + modulePath);
                                thiz._reloadModule(modulePath, true);
                            }, 400);
                        }
                    }
                }
            }
        },
        onNodeServiceStoreReady: function (evt) {
        },
        mergeFunctions: function (target, source, oldModule, newModule) {
            for (var i in source) {
                var o = source[i];
                if (_.isFunction(source[i])) {
                    if (source[i] && target) {
                        target[i] = source[i];//swap
                    }
                }
            }
        },
        /***********************************************************************/
        /*
         * File - Change - Handlers
         */
        /**
         * Special case when module has been reloaded : update all functions in our singleton
         * managers!
         * @param evt
         */
        reloadModules: function (modules, patch) {
            var head = new Deferred(),
                pluginPromises = [],
                newModules = [],
                thiz = this;

            _require({
                cacheBust: 'time=' + new Date().getTime()
            });

            _.each(modules, function (module) {
                var oldModule = null,
                    dfd = new Deferred();
                if (patch !== false) {
                    oldModule = _require(module);
                }
                _require.undef(module);
                _require([module], function (moduleLoaded) {
                    oldModule && thiz.mergeFunctions(oldModule.prototype, moduleLoaded.prototype);
                    newModules.push(moduleLoaded);
                    dfd.resolve();
                });
                pluginPromises.push(dfd);
            });

            all(pluginPromises).then(function () {
                head.resolve(newModules);
                _require({
                    cacheBust: null
                });
            });
            return head;
        },
        _reloadModule: function (_module, reload) {
            var _errorHandle = null;
            var dfd = new Deferred();
            if (!isServer && _module.indexOf('nodejs') !== -1) {
                return;
            }

            _module = _module.replace('0/8', '0.8');
            _module = _module.replace('/src/', '/');
            function handleError(error) {
                debugModuleReload && console.log(error.src, error.id);
                debugModuleReload && console.error('require error ' + _module, error);
                _errorHandle.remove();
                dfd.reject(error);
            }


            //has its own impl.
            var obj = this.getModule(_module);
            if (obj && obj.prototype && obj.prototype.reloadModule) {
                return obj.prototype.reloadModule();
            }

            _errorHandle = _require.on("error", handleError);

            var oldModule = this.getModule(_module);
            if (!oldModule) {
                oldModule = typeof _module !== 'undefined' ? oldModule : null;
                if (!oldModule && typeof window !== 'undefined') {
                    //try global namespace
                    oldModule = utils.getAt(window, utils.replaceAll('/', '.', _module), null);
                    if (oldModule) {
                        obj = oldModule;
                    } else {
                        try {
                            oldModule = _require(utils.replaceAll('.', '/', _module));
                        } catch (e) {
                            //logError(e,'error requiring '+_module);
                            //dfd.reject(e);
                            debugModuleReload && console.log('couldnt require old module', _module);
                        }
                    }
                }
            }
            if (oldModule) {
                obj = oldModule;
            }

            //remove from dom
            if (isBrowser) {
                var scripts = document.getElementsByTagName('script');
                _.each(scripts, function (script) {
                    if (script && script.src && script.src.indexOf(_module) !== -1) {
                        script.parentElement.removeChild(script);
                    }
                })
            }

            _require.undef(_module);

            var thiz = this;
            if (reload) {
                setTimeout(function () {
                    _require({
                        cacheBust: 'time=' + new Date().getTime(),
                        waitSeconds: 5
                    });
                    try {
                        _require([_module], function (moduleLoaded) {

                            _require({
                                cacheBust: null
                            });
                            if (_.isString(moduleLoaded)) {
                                console.error('module reloaded failed : ' + moduleLoaded + ' for module : ' + _module);
                                return;
                            }
                            moduleLoaded.modulePath = _module;
                            if (obj) {
                                thiz.mergeFunctions(obj.prototype, moduleLoaded.prototype, obj, moduleLoaded);
                                if (obj.prototype && obj.prototype._onReloaded) {
                                    obj.prototype._onReloaded(moduleLoaded);
                                }
                            }

                            if (oldModule && oldModule.onReloaded) {
                                oldModule.onReloaded(moduleLoaded, oldModule);
                            }

                            thiz.publish(types.EVENTS.ON_MODULE_RELOADED, {
                                module: _module,
                                newModule: moduleLoaded
                            });

                            if (moduleLoaded.prototype && moduleLoaded.prototype.declaredClass) {
                                thiz.publish(types.EVENTS.ON_MODULE_UPDATED, {
                                    moduleClass: moduleLoaded.prototype.declaredClass,
                                    moduleProto: moduleLoaded.prototype
                                });
                            }
                            dfd.resolve(moduleLoaded);
                        });
                    } catch (e) {
                        console.error('error reloading module', e);
                        logError(e, 'error reloading module');
                        dfd.reject(e);
                    }
                }, 100);
            } else {
                dfd.resolve();
            }
            return dfd;
        },
        onCSSChanged: function (evt) {
            if (isBrowser) {
                var path = evt.path;
                var _p = this.findVFSMount(path);
                var _p2 = this.toVFSShort(path, _p);
                path = utils.replaceAll('//', '/', path);
                path = path.replace('/PMaster/', '');
                var reloadFn = window['xappOnStyleSheetChanged'];
                if (reloadFn) {
                    reloadFn(path);
                }
            }
        },
        onDidChangeFileContent: function (evt) {
            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;
            if (!this.vfsMounts) {
                return;
            }
            if (!evt.path) {
                return;
            }
            var path = evt.path;
            if (path.indexOf('.css') != -1) {
                if (isBrowser) {
                    this.onCSSChanged(evt);
                }
                return;
            }

            if (path.indexOf('resources') != -1 ||
                path.indexOf('meta') != -1 ||
                path.indexOf('.js') == -1) {
                return;
            }

            var mount = evt.mount.replace('/', ''),
                module = null;

            if (!this.vfsMounts[mount]) {
                return;
            }
            module = '' + evt.path;
            module = module.replace('./', '');
            module = module.replace('/', '.');
            module = module.replace('.js', '');
            module = utils.replaceAll('.', '/', module);
            var thiz = this;
            setTimeout(function () {
                try {
                    thiz._reloadModule(module, true);
                } catch (e) {
                    console.error('error reloading module', e);
                }
            }, 100);

        },
        /***********************************************************************/
        /*
         * get/set
         */
        getMount: function (mount) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig && vfsConfig[mount]) {
                return vfsConfig[mount];
            }
            return null;
        },
        toVFSShort: function (path, mount) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig && vfsConfig[mount]) {
                var mountPath = vfsConfig[mount];
                mountPath = utils.replaceAll('//', '/', mountPath);
                mountPath = mountPath.replace(/\/+$/, "");
                if (path.indexOf(mountPath) !== -1) {
                    var _start = mountPath;
                    _start = _start.replace(/\/+$/, "");
                    var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
                    return libPath;
                }
            }
            return null;
        },
        findVFSMount: function (path) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig) {
                for (var mount in vfsConfig) {
                    var mountPath = vfsConfig[mount];
                    mountPath = utils.replaceAll('//', '/', mountPath);
                    mountPath = mountPath.replace(/\/+$/, "");
                    if (path.indexOf(mountPath) !== -1) {
                        return mount;
                    }
                }

            }
            return null;
        },
        getBlockManager: function () {
            return this.blockManager;
        },
        getPluginManager: function () {
            return this.pluginManager;
        },
        getService: function () {
            return this.serviceObject;
        },
        getFileManager: function () {
            return this.fileManager;
        },
        getResourceManager: function () {
            return this.resourceManager;
        },
        getMountManager: function () {
            return this.mountManager;
        },
        getContextManager: function () {
            return this.contextManager;
        },
        getLogManager: function () {
            return this.logManager;
        },
        getApplication: function () {
            return this.application;
        },
        /***********************************************************************/
        /*
         * STD - API
         */
        constructor: function (config) {
            this.managers = [];
            this.config = config;
            this.language = 'en';
            this.subscribe(types.EVENTS.ON_CHANGED_CONTENT, this.onDidChangeFileContent);
        },
        prepare: function () {
            if (this.config) {
                this.initWithConfig(this.config);
            }
        },
        /**
         * The config is put into the index.php as JSON. The server has also some data
         * which gets mixed into the manager instances.
         * @param config
         */
        initWithConfig: function (config) {
            if (config && config.mixins) {
                this.doMixins(config.mixins);
            }
        },
        isEditor: function () {
            return this.args && this.args.file;
        }
    });
    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');
    return Module;
});
},
'xide/widgets/_MenuMixin4':function(){
/** @module xide/widgets/_MenuMixin **/
define([
    'dcl/dcl',
    'xide/types',
    'xide/utils',
    'xide/registry',
    'xaction/Action',
    'xaction/DefaultActions',
    "xide/popup"
], function (dcl, types, utils, registry, Action, DefaultActions,popup) {

    var createCallback = function (func, menu, item) {
        return function (event) {
            /*
            if(item) {

                var _parent = item.parent();
                _parent.data('open', false);
                _parent[0] && popup.close(_parent[0]);

            }
            */
            return func(event, menu, item);
        };
    };

    var ACTION = types.ACTION;
    var _debug = false;
    var _debugWidgets = false;
    /**
     * Mixin which provides utils for menu & action related render tasks.
     * @mixin module:xide/widgets/_MenuMixin
     */
    var _Module = dcl(null, {
        actionStores: null,
        correctSubMenu: false,
        _didInit: null,
        actionFilter: null,
        hideSubsFirst: false,
        collapseSmallGroups: 0,
        containerClass: '',
        lastTree:null,
        onActionAdded: function (actions) {
            this.setActionStore(this.getActionStore(), actions.owner || this, false, true, actions);
        },
        onActionRemoved: function (evt) {
            this.clearAction(evt.target);
        },
        clearAction: function (action) {
            var self = this;
            if (action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    widget && action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        removeCustomActions: function () {
            var oldStore = this.store;
            var oldActions = oldStore._find({
                    custom: true
                });

            var menuData = this.menuData;
            _.each(oldActions, function (action) {
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData, {
                    command: action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField: function (action, field, _default) {
            var actionVisibility = action.getVisibility !== null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !== null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField: function (action, field, value) {
            var _default = {};
            if (action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction: function (action) {
            if (this.getVisibilityField(action, 'show') === false) {
                return false;
            } else if (action.getVisibility && action.getVisibility(this.visibility) == null) {
                return false;
            }
            return true;
        },
        addActionStore: function (store) {
            if (!this.actionStores) {
                this.actionStores = [];
            }
            if (this.actionStores.indexOf(store) == -1) {
                this.actionStores.push(store);
            }
        },
        /**

         tree structure :

         {
            root: {
                Block:{
                    grouped:{
                        Step:[action,action]
                    }
                }
            },
            rootActions: string['File','Edit',...],

            allActionPaths: string[command],

            allActions:[action]
         }

         * @param store
         * @param owner
         * @returns {{root: {}, rootActions: Array, allActionPaths: *, allActions: *}}
         */
        constructor: function (options, node) {
            this.target = node;
            utils.mixin(this, options);
        },
        onClose: function (e) {
            this._rootMenu && this._rootMenu.parent().removeClass('open');
        },
        onOpen: function () {
            this._rootMenu && this._rootMenu.parent().addClass('open');
        },
        isLeftToRight: function () {
            return false;
        },
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });
            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            this.__on(root, 'mouseenter', '.dropdown-submenu', function (e) {
                try {
                    var _root = $(e.currentTarget);
                    var $sub = _root.find('.dropdown-context-sub:first');
                    var didPopup = false;
                    if ($sub.length === 0) {
                        $sub = _root.data('sub');
                        if ($sub) {
                            didPopup = true;
                        } else {
                            return;
                        }
                    }
                    var data = $sub.data('data');
                    var level = data ? data[0].level : 0;
                    var isFirst = level === 1;
                    if (self.menu) {
                        if (!$.contains(self.menu[0], _root[0])) {
                            return;
                        }
                    }

                    var _disabled = _root.hasClass('disabled');
                    if (_disabled) {
                        $sub.css('display', 'none');
                        return;
                    } else {
                        $sub.css('display', 'block');
                    }

                    if (isFirst) {
                        $sub.css('display', 'initial');
                        $sub.css('position', 'initial');
                        function close() {
                            var _wrapper = $sub.data('_popupWrapper');
                            popup.close({
                                domNode: $sub[0],
                                _popupWrapper: _wrapper
                            });
                        }

                        if (!didPopup) {
                            _root.data('sub', $sub);
                            $sub.data('owner', self);
                            $sub.on('mouseleave', function () {
                                close();
                            });
                            _root.on('mouseleave', function () {
                            });
                        }

                        popup.open({
                            //parent: self,
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                close();
                            },
                            onClose: function () {
                                //console.log('close');
                                //domAttr.set(self._popupStateNode, "popupActive", false);
                                //domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                                //self._set("_opened", false);	// use set() because _CssStateMixin is watching
                            }
                        });
                        return;
                    } else {
                        if (!$sub.data('didSetup')) {
                            $sub.data('didSetup', true);
                            _root.on('mouseleave', function () {
                                $sub.css('display', '');
                            });
                        }
                    }

                    //reset top
                    $sub.css({
                        top: 0
                    });

                    var autoH = $sub.height() + 0;
                    var totalH = $('html').height();
                    var pos = $sub.offset();
                    var overlapYDown = totalH - (pos.top + autoH);
                    if ((pos.top + autoH) > totalH) {
                        $sub.css({
                            top: overlapYDown - 30
                        }).fadeIn(options.fadeSpeed);
                    }
                    ////////////////////////////////////////////////////////////
                    var subWidth = $sub.width(),
                        subLeft = $sub.offset().left,
                        collision = (subWidth + subLeft) > window.innerWidth;

                    if (collision) {
                        $sub.addClass('drop-left');
                    }
                } catch (e) {
                    logError(e);
                }
            });
        },
        getDefaultOptions: function () {
            return {
                fadeSpeed: 0,
                above: 'auto',
                left: 'auto',
                preventDoubleContext: false,
                compress: true
            };
        },
        buildMenuItems: function ($menu, data, id, subMenu, addDynamicTag) {
            //this._debugMenu && console.log('build - menu items ', arguments);
            var linkTarget = '',
                self = this,
                visibility = this.visibility;

            for (var i = 0; i < data.length; i++) {
                var item = data[i],
                    $sub,
                    widget = item.widget;

                if (typeof item.divider !== 'undefined' && !item.widget) {
                    var divider = '<li class="divider';
                    divider += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    divider += '"></li>';
                    item.widget = divider;
                    $menu.append(divider);
                    divider.data('item',item);

                } else if (typeof item.header !== 'undefined' && !item.widget) {
                    var header = item.vertical ? '<li class="divider-vertical' : '<li class="nav-header testClass';
                    header += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    header += '">' + item.header + '</li>';
                    header = $(header);
                    item.widget = header;
                    $menu.append(header);
                    header.data('item',item);

                } else if (typeof item.menu_item_src !== 'undefined') {

                } else {

                    if (!widget && typeof item.target !== 'undefined') {
                        linkTarget = ' target="' + item.target + '"';
                    }
                    if (typeof item.subMenu !== 'undefined' && !widget) {
                        var sub_menu = '<li tabindex="-1" class="dropdown-submenu ' + this.containerClass;
                        sub_menu += (addDynamicTag) ? ' dynamic-menu-item' : '';
                        sub_menu += '"><a>';

                        if (typeof item.icon !== 'undefined') {
                            sub_menu += '<span class="icon ' + item.icon + '"></span> ';
                        }
                        sub_menu += item.text + '';
                        sub_menu += '</a></li>';
                        $sub = $(sub_menu);

                    } else {
                        if (!widget) {
                            if (item.render) {
                                $sub = item.render(item, $menu);
                            } else {
                                var element = '<li tabindex="-1" class="" ';
                                element += (addDynamicTag) ? ' class="dynamic-menu-item"' : '';
                                element += '><a >';
                                if (typeof data[i].icon !== 'undefined') {
                                    element += '<span class="' + item.icon + '"></span> ';
                                }
                                element += item.text + '</a></li>';
                                $sub = $(element);
                                if (item.postRender) {
                                    item.postRender($sub);
                                }
                            }
                        }
                    }

                    if (typeof item.action !== 'undefined' && !item.widget) {
                        if (item.addClickHandler && item.addClickHandler() === false) {
                        } else {
                            var $action = item.action;
                            if ($sub && $sub.find) {
                                var trigger = $sub.find('a');
                                trigger.addClass('context-event');
                                var handler = createCallback($action, item, $sub);
                                trigger.data('handler',handler).on('click',handler);
                            }
                        }
                    }

                    if ($sub && !widget) {

                        item.widget = $sub;
                        $sub.menu = $menu;
                        $sub.data('item', item);

                        item.$menu = $menu;
                        item.$sub = $sub;

                        item._render = function () {
                            if (item.index === 0) {
                                this.$menu.prepend(this.$sub);
                            } else {
                                this.$menu.append(this.$sub);
                            }
                        };
                        if (!item.lazy) {
                            item._render();
                        }
                    }

                    if ($sub) {
                        $sub.attr('level', item.level);
                    }

                    if (typeof item.subMenu != 'undefined' && !item.subMenuData) {
                        var subMenuData = self.buildMenu(item.subMenu, id, true);
                        $menu.subMenuData = subMenuData;
                        item.subMenuData = subMenuData;
                        $menu.find('li:last').append(subMenuData);
                        subMenuData.attr('level', item.subMenu.level);
                        if (self.hideSubsFirst) {
                            subMenuData.css('display', 'none');
                        }
                        $menu.data('item', item);
                    } else {
                        if (item.subMenu && item.subMenuData) {
                            this.buildMenuItems(item.subMenuData, item.subMenu, id, true);
                        }
                    }
                }

                if (!$menu._didOnClick) {
                    $menu.on('click', '.dropdown-menu > li > input[type="checkbox"] ~ label, .dropdown-menu > li > input[type="checkbox"], .dropdown-menu.noclose > li', function (e) {
                        e.stopPropagation();
                    });
                    $menu._didOnClick = true;
                }

            }
            return $menu;
        },
        buildMenu: function (data, id, subMenu) {
            var subClass = (subMenu) ? (' dropdown-context-sub ' + this.containerClass ) : ' scrollable-menu ';
            var $menu = $('<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>');
            if (!subMenu) {
                this._rootMenu = $menu;
            }
            var result = this.buildMenuItems($menu, data, id, subMenu);
            $menu.data('data', data);
            return result;
        },
        createNewAction: function (command) {
            var segments = command.split('/');
            var lastSegment = segments[segments.length - 1];
            var action = new Action({
                command: command,
                label: lastSegment,
                group: lastSegment,
                dynamic: true
            });
            return action;
        },
        findAction: function (command) {
            var stores = this.actionStores,
                action = null;
            _.each(stores, function (store) {
                var _action = store ? store.getSync(command) : null;
                if (_action) {
                    action = _action;
                }
            });

            return action;
        },
        getAction: function (command, store) {
            store = store || this.store;
            var action = null;
            if (store) {
                action = this.findAction(command);
                if (!action) {
                    action = this.createNewAction(command);
                }
            }
            return action;
        },
        getActions: function (query) {
            var result = [];
            var stores = this.actionStores,
                visibility = this.visibility;

            query = query || this.actionFilter;
            _.each(stores, function (store) {
                store && (result = result.concat(store._find(query)));
                //store && (result2= result2.concat(store._find(query)));
            });
            result = result.filter(function (action) {
                var actionVisibility = action.getVisibility != null ? action.getVisibility(visibility) : {};
                return !(action.show === false || actionVisibility === false || actionVisibility.show === false);
            });
            /*
            console.log('action: ',[result,result2]);
            */
            return result;
        },
        toActions: function (commands, store) {
            var result = [],
                self = this;
            _.each(commands, function (path) {
                var _action = self.getAction(path, store);
                _action && result.push(_action);
            });
            return result;
        },
        onRunAction: function (action, owner, e) {
            var command = action.command;
            action = this.findAction(command);
            return DefaultActions.defaultHandler.apply(action.owner || owner, [action, e]);
        },
        getActionProperty: function (action, visibility, prop) {
            var value = prop in action ? action[prop] : null;
            if (visibility && prop in visibility) {
                value = visibility[prop];
            }
            return value;
        },
        toMenuItem: function (action, owner, label, icon, visibility, showKeyCombo, lazy) {
            var self = this,
                labelLocalized = self.localize(label),
                actionType = visibility.actionType || action.actionType;

            var item = {
                text: labelLocalized,
                icon: icon,
                data: action,
                owner: owner,
                command: action.command,
                lazy: lazy,
                addClickHandler: function () {
                    return actionType !== types.ACTION_TYPE.MULTI_TOGGLE;

                },
                render: function (data, $menu) {
                    if (self.renderItem) {
                        return self.renderItem(this, data, $menu, this.data, owner, label, icon, visibility, showKeyCombo, lazy);
                    }
                    var action = this.data;
                    var parentAction = action.getParent ? action.getParent() : null;
                    var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
                    var keyComboString = ' \n';
                    var element = null;
                    if (action.keyboardMappings && showKeyCombo !== false) {
                        var mappings = action.keyboardMappings;
                        var keyCombos = mappings[0].keys;
                        if (keyCombos && keyCombos.length) {
                            keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                        }
                    }

                    if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                        element = '<li tabindex="-1" class="" >';
                        var id = action._store.id + '_' + action.command + '_' + self.id;
                        var checked = action.get('value');
                        //checkbox-circle
                        element += '<div class="action-checkbox checkbox checkbox-success ">';
                        element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                        element += '<label for="' + id + '">';
                        element += self.localize(data.text);
                        element += '</label>';
                        element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                        element += '</li>';

                        $menu.addClass('noclose');
                        var result = $(element);
                        var checkBox = result.find('INPUT');
                        checkBox.on('change', function (e) {
                            action._originReference = data;
                            action._originEvent = e;
                            action.set('value', checkBox[0].checked);
                            action._originReference = null;
                        });
                        self.setVisibilityField(action, 'widget', data);
                        return result;
                    }
                    closeOnClick === false && $menu.addClass('noclose');
                    if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                        var value = action.value || action.get('value');
                        var parentValue = parentAction.get('value');
                        if (value == parentValue) {
                            icon = 'fa fa-check';
                        }
                    }

                    var title = data.text || labelLocalized || self.localize(action.title);


                    //default:
                    element = '<li tabindex="-1"><a title="' + title + ' ' + keyComboString + '">';
                    var _icon = data.icon || icon;

                    //icon
                    if (typeof _icon !== 'undefined') {
                        //already html string
                        if (/<[a-z][\s\S]*>/i.test(_icon)) {
                            element += _icon;
                        } else {
                            element += '<span class="icon ' + _icon + '"/> ';
                        }
                    }
                    element += data.text;
                    element += '<span style="max-width:100px" class="text-muted pull-right ellipsis keyboardShortCut">' + (showKeyCombo ? keyComboString : "") + '</span></a></li>';
                    self.setVisibilityField(action, 'widget', data);
                    return $(element);
                },
                get: function (key) {
                },
                set: function (key, value) {
                    //_debugWidgets && _.isString(value) && console.log('set ' + key + ' ' + value);
                    var widget = this.widget;

                    function updateCheckbox(widget, checked) {
                        var what = widget.find("input[type=checkbox]");
                        if (what) {
                            if (checked) {
                                what.prop("checked", true);
                            } else {
                                what.removeAttr('checked');
                            }
                        }
                    }

                    if (widget) {
                        if (key === 'disabled') {
                            if (widget.toggleClass) {
                                widget.toggleClass('disabled', value);
                            }
                        }
                        if (key === 'icon') {
                            var _iconNode = widget.find('.icon');
                            if (_iconNode) {
                                _iconNode.attr('class', 'icon');
                                this._lastIcon = this.icon;
                                this.icon = value;
                                _iconNode.addClass(value);
                            }
                        }
                        if (key === 'value') {
                            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE ||
                                actionType === types.ACTION_TYPE.SINGLE_TOGGLE) {
                                updateCheckbox(widget, value);
                            }
                        }
                    }
                },
                action: function (e, data, menu) {
                    _debug && console.log('menu action', data);
                    return self.onRunAction(data.data, owner, e);
                },
                destroy: function () {
                    if (this.widget) {
                        this.widget.remove();
                    }
                }
            };
            return item;
        },
        attach: function (selector, data) {
            this.target = selector;
            this.menu = this.addContext(selector, data);
            this.domNode = this.menu[0];
            this.id = this.domNode.id;
            registry.add(this);
            return this.menu;
        },
        addReference: function (action, item) {
            if (action.addReference) {
                action.addReference(item, {
                    properties: {
                        "value": true,
                        "disabled": true,
                        "enabled": true
                    }
                }, true);
            }
        },
        onDidRenderActions: function (store, owner) {
            if (owner && owner.refreshActions) {
                owner.refreshActions();
            }
        },
        getActionData: function (action) {
            var actionVisibility = action.getVisibility != null ? action.getVisibility(this.visibility) : {};
            return {
                label: actionVisibility.label != null ? actionVisibility.label : action.label,
                icon: actionVisibility.icon != null ? actionVisibility.icon : action.icon,
                command: actionVisibility.command != null ? actionVisibility.command : action.command,
                visibility: actionVisibility,
                group: actionVisibility.group != null ? actionVisibility.group : action.group,
                tab: actionVisibility.tab != null ? actionVisibility.tab : action.tab,
                expand: actionVisibility.expand != null ? actionVisibility.expand : false,
                widget: actionVisibility.widget
            };
        },
        _clearAction: function (action) {

        },
        _findParentData: function (oldMenuData, parentCommand) {
            var parent = _.find(oldMenuData, {
                command: parentCommand
            });
            if (parent) {
                return parent;
            }
            for (var i = 0; i < oldMenuData.length; i++) {
                var data = oldMenuData[i];
                if (data.subMenu) {
                    var found = this._findParentData(data.subMenu, parentCommand);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        },
        _clear: function () {
            var actions = this.getActions();
            var store = this.store;
            if (store) {
                this.actionStores.remove(store);
            }
            var self = this;
            actions = actions.concat(this._tmpActions);
            _.each(actions, function (action) {
                if (action) {
                    var actionVisibility = action.getVisibility != null ? action.getVisibility(self.visibility) : {};
                    if (actionVisibility) {
                        var widget = actionVisibility.widget;
                        action.removeReference && action.removeReference(widget);
                        if (widget && widget.destroy) {
                            widget.destroy();
                        }
                        delete actionVisibility.widget;
                        actionVisibility.widget = null;
                    }
                }
            });
            this.$navBar && this.$navBar.empty();
        },
        buildActionTree: function (store, owner) {
            var self = this,
                allActions = self.getActions(),
                visibility = self.visibility;

            self.wireStore(store, function (evt) {
                if (evt.type === 'update') {
                    var action = evt.target;
                    if (action.refreshReferences) {
                        action.refreshReferences(evt.property, evt.value);
                    }
                }
            });

            //return all actions with non-empty tab field
            var tabbedActions = allActions.filter(function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),

                //group all tabbed actions : { Home[actions], View[actions] }
                groupedTabs = _.groupBy(tabbedActions, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),
                //now flatten them
                _actionsFlattened = [];


            _.each(groupedTabs, function (items) {
                _actionsFlattened = _actionsFlattened.concat(items);
            });

            var rootActions = [];
            _.each(tabbedActions, function (action) {
                var rootCommand = action.getRoot();
                rootActions.indexOf(rootCommand) == -1 && rootActions.push(rootCommand);
            });

            //owner sort of top level
            store.menuOrder && (rootActions = owner.sortGroups(rootActions, store.menuOrder));

            var tree = {};
            //stats to count groups per tab
            var biggestTab = rootActions[0];
            var nbGroupsBiggest = 0;

            _.each(rootActions, function (level) {
                // collect all actions at level (File/View/...)
                var menuActions = owner.getItemsAtBranch(allActions, level);
                // convert action command strings to Action references
                var grouped = self.toActions(menuActions, store);

                // expand filter -------------------
                var addedExpanded = [];
                var toRemove = [];
                _.each(grouped, function (action) {
                    var actionData = self.getActionData(action);
                    if (actionData.expand) {
                        var children = action.getChildren();
                        children && children.length && (addedExpanded = addedExpanded.concat(children));
                        toRemove.push(action);
                    }
                });
                grouped = grouped.concat(addedExpanded);
                grouped = grouped.filter(function (action) {
                    return toRemove.indexOf(action) == -1;
                });
                // expand filter ---------------    end

                // group all actions by group
                var groupedActions = _.groupBy(grouped, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.group || action.group;
                    }
                });

                var _actions = [];
                _.each(groupedActions, function (items, level) {
                    if (level !== 'undefined') {
                        _actions = _actions.concat(items);
                    }
                });

                //flatten out again
                menuActions = _.pluck(_actions, 'command');
                menuActions.grouped = groupedActions;
                tree[level] = menuActions;

                //update stats
                if (self.collapseSmallGroups) {
                    var nbGroups = _.keys(menuActions.grouped).length;
                    if (nbGroups > nbGroupsBiggest) {
                        nbGroupsBiggest = nbGroups;
                        biggestTab = level;
                    }
                }
            });

            //now move over any tab with less than 2 groups to the next bigger tab
            this.collapseSmallGroups && _.each(tree, function (actions, level) {
                if (_.keys(actions.grouped).length < self.collapseSmallGroups) {
                    //append tab groups of the biggest tab
                    tree[biggestTab] && _.each(actions.grouped, function (group, name) {
                        tree[biggestTab].grouped[name] = group;
                    });
                    //copy manually commands to that tab
                    tree[biggestTab] && _.each(actions, function (action) {
                        tree[biggestTab].push(action);
                    });
                    tree[biggestTab] && delete tree[level];
                }
            });
            var result = {
                root: tree,
                rootActions: rootActions,
                allActionPaths: _.pluck(allActions, 'command'),
                allActions: allActions
            };

            this.lastTree = result;
            return result;
        }
    });
    var Module = dcl(null, {
        actionStores: null,
        correctSubMenu: false,
        _didInit: null,
        actionFilter: null,
        hideSubsFirst: false,
        collapseSmallGroups: 0,
        containerClass: '',
        lastTree:null,
        ITEM_TAG : "li",
        CONTAINER_TAG : "ul",
        ITEM_CLASS : "actionItem",
        onActionAdded: function (actions) {
            this.setActionStore(this.getActionStore(), actions.owner || this, false, true, actions);
        },
        onActionRemoved: function (evt) {
            this.clearAction(evt.target);
        },
        clearAction: function (action) {
            var self = this;
            if (action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    widget && action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        removeCustomActions: function () {
            var oldStore = this.store;
            var oldActions = oldStore._find({
                custom: true
            });

            var menuData = this.menuData;
            _.each(oldActions, function (action) {
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData, {
                    command: action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField: function (action, field, _default) {
            var actionVisibility = action.getVisibility !== null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !== null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField: function (action, field, value) {
            var _default = {};
            if (action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction: function (action) {
            if (this.getVisibilityField(action, 'show') === false) {
                return false;
            } else if (action.getVisibility && action.getVisibility(this.visibility) == null) {
                return false;
            }
            return true;
        },
        addActionStore: function (store) {
            if (!this.actionStores) {
                this.actionStores = [];
            }
            if (this.actionStores.indexOf(store) == -1) {
                this.actionStores.push(store);
            }
        },
        /**

         tree structure :

         {
            root: {
                Block:{
                    grouped:{
                        Step:[action,action]
                    }
                }
            },
            rootActions: string['File','Edit',...],

            allActionPaths: string[command],

            allActions:[action]
         }

         * @param store
         * @param owner
         * @returns {{root: {}, rootActions: Array, allActionPaths: *, allActions: *}}
         */
        constructor: function (options, node) {
            this.target = node;
            utils.mixin(this, options);
        },
        onClose: function (e) {
            this._rootMenu && this._rootMenu.parent().removeClass('open');
        },
        onOpen: function () {
            this._rootMenu && this._rootMenu.parent().addClass('open');
        },
        isLeftToRight: function () {
            return false;
        },
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });
            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            this.__on(root, 'mouseenter', '.dropdown-submenu', function (e) {
                try {
                    var _root = $(e.currentTarget);
                    var $sub = _root.find('.dropdown-context-sub:first');
                    var didPopup = false;
                    if ($sub.length === 0) {
                        $sub = _root.data('sub');
                        if ($sub) {
                            didPopup = true;
                        } else {
                            return;
                        }
                    }
                    var data = $sub.data('data');
                    var level = data ? data[0].level : 0;
                    var isFirst = level === 1;
                    if (self.menu) {
                        if (!$.contains(self.menu[0], _root[0])) {
                            return;
                        }
                    }

                    var _disabled = _root.hasClass('disabled');
                    if (_disabled) {
                        $sub.css('display', 'none');
                        return;
                    } else {
                        $sub.css('display', 'block');
                    }

                    if (isFirst) {
                        $sub.css('display', 'initial');
                        $sub.css('position', 'initial');
                        function close() {
                            var _wrapper = $sub.data('_popupWrapper');
                            popup.close({
                                domNode: $sub[0],
                                _popupWrapper: _wrapper
                            });
                        }

                        if (!didPopup) {
                            _root.data('sub', $sub);
                            $sub.data('owner', self);
                            $sub.on('mouseleave', function () {
                                close();
                            });
                            _root.on('mouseleave', function () {
                            });
                        }

                        popup.open({
                            //parent: self,
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                close();
                            },
                            onClose: function () {
                                //console.log('close');
                                //domAttr.set(self._popupStateNode, "popupActive", false);
                                //domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                                //self._set("_opened", false);	// use set() because _CssStateMixin is watching
                            }
                        });
                        return;
                    } else {
                        if (!$sub.data('didSetup')) {
                            $sub.data('didSetup', true);
                            _root.on('mouseleave', function () {
                                $sub.css('display', '');
                            });
                        }
                    }

                    //reset top
                    $sub.css({
                        top: 0
                    });

                    var autoH = $sub.height() + 0;
                    var totalH = $('html').height();
                    var pos = $sub.offset();
                    var overlapYDown = totalH - (pos.top + autoH);
                    if ((pos.top + autoH) > totalH) {
                        $sub.css({
                            top: overlapYDown - 30
                        }).fadeIn(options.fadeSpeed);
                    }
                    ////////////////////////////////////////////////////////////
                    var subWidth = $sub.width(),
                        subLeft = $sub.offset().left,
                        collision = (subWidth + subLeft) > window.innerWidth;

                    if (collision) {
                        $sub.addClass('drop-left');
                    }
                } catch (e) {
                    logError(e);
                }
            });
        },
        getDefaultOptions: function () {
            return {
                fadeSpeed: 0,
                above: 'auto',
                left: 'auto',
                preventDoubleContext: false,
                compress: true
            };
        },
        buildMenuItems: function ($menu, data, id, subMenu, addDynamicTag) {
            //this._debugMenu && console.log('build - menu items ', arguments);
            var linkTarget = '',
                self = this,
                visibility = this.visibility;

            var ITEM_TAG_START = '<' + this.ITEM_TAG + ' ';
            var ITEM_TAG_END = '</' + this.ITEM_TAG + '>';
            var ITEM_CLASS = this.ITEM_CLASS;
            for (var i = 0; i < data.length; i++) {
                var item = data[i],
                    $sub,
                    widget = item.widget;

                if (typeof item.divider !== 'undefined' && !item.widget) {
                    var divider = ITEM_TAG_START + 'class="divider';
                    divider += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    divider += '">' + ITEM_TAG_END;
                    item.widget = divider;
                    $menu.append(divider);
                    divider.data('item',item);

                } else if (typeof item.header !== 'undefined' && !item.widget) {
                    var header = item.vertical ? '<li class="divider-vertical' : '<li class="nav-header testClass';
                    header += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    header += '">' + item.header + '</li>';
                    header = $(header);
                    item.widget = header;
                    $menu.append(header);
                    header.data('item',item);

                } else if (typeof item.menu_item_src !== 'undefined') {



                } else {

                    if (!widget && typeof item.target !== 'undefined') {
                        linkTarget = ' target="' + item.target + '"';
                    }

                    if (typeof item.subMenu !== 'undefined' && !widget) {
                        var sub_menu = ITEM_TAG_START + 'tabindex="-1" class="dropdown-submenu ' + ITEM_CLASS + this.containerClass;
                        sub_menu += (addDynamicTag) ? ' dynamic-menu-item' : '';
                        sub_menu += '"><a>';

                        if (typeof item.icon !== 'undefined') {
                            sub_menu += '<span class="icon ' + item.icon + '"></span> ';
                        }
                        sub_menu += item.text + '';
                        sub_menu += '</a>'+ITEM_TAG_END;
                        $sub = $(sub_menu);

                    } else {
                        if (!widget) {
                            if (item.render) {
                                $sub = item.render(item, $menu);
                            } else {
                                var element = ITEM_TAG_START + ' tabindex="-1" ';
                                element += (addDynamicTag) ? ' class="dynamic-menu-item"' : '';
                                element += '><a >';
                                if (typeof data[i].icon !== 'undefined') {
                                    element += '<span class="' + item.icon + '"></span> ';
                                }
                                element += item.text + '</a>' + ITEM_TAG_END;
                                $sub = $(element);
                                if (item.postRender) {
                                    item.postRender($sub);
                                }
                            }
                        }
                    }

                    if (typeof item.action !== 'undefined' && !item.widget) {
                        if (item.addClickHandler && item.addClickHandler() === false) {
                        } else {
                            var $action = item.action;
                            if ($sub && $sub.find) {
                                var trigger = $sub.find('a');
                                trigger.addClass('context-event');
                                var handler = createCallback($action, item, $sub);
                                trigger.data('handler',handler).on('click',handler);
                                //trigger.data('handler',handler).on('click',function(e){
                                    //return func(event, menu, item);
                                //});

                                /*
                                trigger.data('handler',handler).on('click',function(e){
                                    handler();
                                    var _parent = $sub.parent();
                                    _parent.data('open',false);
                                    _parent[0] && popup.close(_parent[0]);
                                });
                                */
                            }
                        }
                    }

                    if ($sub && !widget) {
                        item.widget = $sub;
                        $sub.menu = $menu;
                        $sub.data('item', item);
                        item.$menu = $menu;
                        item.$sub = $sub;
                        item._render = function () {
                            if (item.index === 0) {
                                this.$menu.prepend(this.$sub);
                            } else {
                                this.$menu.append(this.$sub);
                            }
                        };
                        if (!item.lazy) {
                            item._render();
                        }
                    }
                    if ($sub) {
                        $sub.attr('level', item.level);
                    }
                    if (typeof item.subMenu != 'undefined' && !item.subMenuData) {
                        var subMenuData = self.buildMenu(item.subMenu, id, true);
                        $menu.subMenuData = subMenuData;
                        item.subMenuData = subMenuData;
                        $menu.find(this.ITEM_TAG +':last').append(subMenuData);
                        subMenuData.attr('level', item.subMenu.level);
                        if (self.hideSubsFirst) {
                            subMenuData.css('display', 'none');
                        }
                        $menu.data('item', item);
                    } else {
                        if (item.subMenu && item.subMenuData) {
                            this.buildMenuItems(item.subMenuData, item.subMenu, id, true);
                        }
                    }
                }

                if (!$menu._didOnClick) {
                    $menu.on('click', '.dropdown-menu > li > input[type="checkbox"] ~ label, .dropdown-menu > li > input[type="checkbox"], .dropdown-menu.noclose > li', function (e) {
                        e.stopPropagation();
                    });
                    $menu._didOnClick = true;
                }

            }
            return $menu;
        },
        buildMenu: function (data, id, subMenu) {
            var subClass = (subMenu) ? (' dropdown-context-sub ' + this.containerClass ) : ' scrollable-menu ';
            var $menu = $('<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>');
            if (!subMenu) {
                this._rootMenu = $menu;
            }
            var result = this.buildMenuItems($menu, data, id, subMenu);
            $menu.data('data', data);
            return result;
        },
        createNewAction: function (command) {
            var segments = command.split('/');
            var lastSegment = segments[segments.length - 1];
            var action = new Action({
                command: command,
                label: lastSegment,
                group: lastSegment,
                dynamic: true
            });
            return action;
        },
        findAction: function (command) {
            var stores = this.actionStores,
                action = null;
            _.each(stores, function (store) {
                var _action = store ? store.getSync(command) : null;
                if (_action) {
                    action = _action;
                }
            });

            return action;
        },
        getAction: function (command, store) {
            store = store || this.store;
            var action = null;
            if (store) {
                action = this.findAction(command);
                if (!action) {
                    action = this.createNewAction(command);
                }
            }
            return action;
        },
        getActions: function (query) {
            var result = [];
            var stores = this.actionStores,
                visibility = this.visibility;

            query = query || this.actionFilter;
            _.each(stores, function (store) {
                store && (result = result.concat(store._find(query)));
                //store && (result2= result2.concat(store._find(query)));
            });
            result = result.filter(function (action) {
                var actionVisibility = action.getVisibility != null ? action.getVisibility(visibility) : {};
                return !(action.show === false || actionVisibility === false || actionVisibility.show === false);

            });

            return result;
        },
        toActions: function (commands, store) {
            var result = [],
                self = this;
            _.each(commands, function (path) {
                var _action = self.getAction(path, store);
                _action && result.push(_action);
            });
            return result;
        },
        onRunAction: function (action, owner, e) {
            var command = action.command;
            action = this.findAction(command);
            return DefaultActions.defaultHandler.apply(action.owner || owner, [action, e]);
        },
        getActionProperty: function (action, visibility, prop) {
            var value = prop in action ? action[prop] : null;
            if (visibility && prop in visibility) {
                value = visibility[prop];
            }
            return value;
        },
        toMenuItem: function (action, owner, label, icon, visibility, showKeyCombo, lazy) {
            var self = this,
                labelLocalized = self.localize(label),
                actionType = visibility.actionType || action.actionType;

            var ITEM_CLASS = this.ITEM_CLASS;
            var ITEM_TAG_START = '<' + this.ITEM_TAG + ' class="'+ ITEM_CLASS + '" ';
            var ITEM_TAG_END = '</' + this.ITEM_TAG + '>';

            var item = {
                text: labelLocalized,
                icon: icon,
                data: action,
                owner: owner,
                command: action.command,
                lazy: lazy,
                addClickHandler: function () {
                    return actionType !== types.ACTION_TYPE.MULTI_TOGGLE;

                },
                render: function (data, $menu) {
                    if (self.renderItem) {
                        return self.renderItem(this, data, $menu, this.data, owner, label, icon, visibility, showKeyCombo, lazy);
                    }
                    var action = this.data;
                    var parentAction = action.getParent ? action.getParent() : null;
                    var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
                    var keyComboString = ' \n';
                    var element = null;
                    if (action.keyboardMappings && showKeyCombo !== false) {
                        var mappings = action.keyboardMappings;
                        var keyCombos = mappings[0].keys;
                        if (keyCombos && keyCombos.length) {
                            keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                        }
                    }

                    if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                        element = ITEM_TAG_START + 'tabindex="-1" class="" >';
                        var id = action._store.id + '_' + action.command + '_' + self.id;
                        var checked = action.get('value');
                        //checkbox-circle
                        element += '<div class="action-checkbox checkbox checkbox-success ">';
                        element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                        element += '<label for="' + id + '">';
                        element += self.localize(data.text);
                        element += '</label>';
                        element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                        element += ITEM_TAG_END;

                        $menu.addClass('noclose');
                        var result = $(element);
                        var checkBox = result.find('INPUT');
                        checkBox.on('change', function (e) {
                            action._originReference = data;
                            action._originEvent = e;
                            action.set('value', checkBox[0].checked);
                            action._originReference = null;
                        });
                        self.setVisibilityField(action, 'widget', data);
                        return result;
                    }
                    closeOnClick === false && $menu.addClass('noclose');
                    if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                        var value = action.value || action.get('value');
                        var parentValue = parentAction.get('value');
                        if (value == parentValue) {
                            icon = 'fa fa-check';
                        }
                    }

                    var title = data.text || labelLocalized || self.localize(action.title);

                    //default:
                    element = ITEM_TAG_START +  'class="'+ITEM_CLASS + '" ' +  'tabindex="-1"><a title="' + title + ' ' + keyComboString + '">';
                    var _icon = data.icon || icon;

                    //icon
                    if (typeof _icon !== 'undefined') {
                        //already html string
                        if (/<[a-z][\s\S]*>/i.test(_icon)) {
                            element += _icon;
                        } else {
                            element += '<span class="icon ' + _icon + '"/> ';
                        }
                    }
                    element += data.text;
                    element += '<span style="max-width:100px" class="text-muted pull-right ellipsis keyboardShortCut">' + (showKeyCombo ? keyComboString : "") + '</span></a>'+ITEM_TAG_END;
                    self.setVisibilityField(action, 'widget', data);
                    return $(element);
                },
                get: function (key) {
                },
                set: function (key, value) {
                    //_debugWidgets && _.isString(value) && console.log('set ' + key + ' ' + value);
                    var widget = this.widget;

                    function updateCheckbox(widget, checked) {
                        var what = widget.find("input[type=checkbox]");
                        if (what) {
                            if (checked) {
                                what.prop("checked", true);
                            } else {
                                what.removeAttr('checked');
                            }
                        }
                    }

                    if (widget) {
                        if (key === 'disabled') {
                            if (widget.toggleClass) {
                                widget.toggleClass('disabled', value);
                            }
                        }
                        if (key === 'icon') {
                            var _iconNode = widget.find('.icon');
                            if (_iconNode) {
                                _iconNode.attr('class', 'icon');
                                this._lastIcon = this.icon;
                                this.icon = value;
                                _iconNode.addClass(value);
                            }
                        }
                        if (key === 'value') {
                            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE ||
                                actionType === types.ACTION_TYPE.SINGLE_TOGGLE) {
                                updateCheckbox(widget, value);
                            }
                        }
                    }
                },
                action: function (e, data, menu) {
                    return self.onRunAction(data.data, owner, e);
                },
                destroy: function () {
                    if (this.widget) {
                        this.widget.remove();
                    }
                }
            };
            return item;
        },
        attach: function (selector, data) {
            this.target = selector;
            this.menu = this.addContext(selector, data);
            this.domNode = this.menu[0];
            this.id = this.domNode.id;
            registry.add(this);
            return this.menu;
        },
        addReference: function (action, item) {
            if (action.addReference) {
                action.addReference(item, {
                    properties: {
                        "value": true,
                        "disabled": true,
                        "enabled": true
                    }
                }, true);
            }
        },
        onDidRenderActions: function (store, owner) {
            if (owner && owner.refreshActions) {
                owner.refreshActions();
            }
        },
        getActionData: function (action) {
            var actionVisibility = action.getVisibility != null ? action.getVisibility(this.visibility) : {};
            return {
                label: actionVisibility.label != null ? actionVisibility.label : action.label,
                icon: actionVisibility.icon != null ? actionVisibility.icon : action.icon,
                command: actionVisibility.command != null ? actionVisibility.command : action.command,
                visibility: actionVisibility,
                group: actionVisibility.group != null ? actionVisibility.group : action.group,
                tab: actionVisibility.tab != null ? actionVisibility.tab : action.tab,
                expand: actionVisibility.expand != null ? actionVisibility.expand : false,
                widget: actionVisibility.widget
            };
        },
        _clearAction: function (action) {

        },
        _findParentData: function (oldMenuData, parentCommand) {
            var parent = _.find(oldMenuData, {
                command: parentCommand
            });
            if (parent) {
                return parent;
            }
            for (var i = 0; i < oldMenuData.length; i++) {
                var data = oldMenuData[i];
                if (data.subMenu) {
                    var found = this._findParentData(data.subMenu, parentCommand);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        },
        _clear: function () {
            var actions = this.getActions();
            var store = this.store;
            if (store) {
                this.actionStores.remove(store);
            }
            var self = this;
            actions = actions.concat(this._tmpActions);
            _.each(actions, function (action) {
                if (action) {
                    var actionVisibility = action.getVisibility != null ? action.getVisibility(self.visibility) : {};
                    if (actionVisibility) {
                        var widget = actionVisibility.widget;
                        action.removeReference && action.removeReference(widget);
                        if (widget && widget.destroy) {
                            widget.destroy();
                        }
                        delete actionVisibility.widget;
                        actionVisibility.widget = null;
                    }
                }
            });
            this.$navBar && this.$navBar.empty();
        },
        buildActionTree: function (store, owner) {
            var self = this,
                allActions = self.getActions(),
                visibility = self.visibility;

            self.wireStore(store, function (evt) {
                if (evt.type === 'update') {
                    var action = evt.target;
                    if (action.refreshReferences) {
                        action.refreshReferences(evt.property, evt.value);
                    }
                }
            });

            //return all actions with non-empty tab field
            var tabbedActions = allActions.filter(function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),

                //group all tabbed actions : { Home[actions], View[actions] }
                groupedTabs = _.groupBy(tabbedActions, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),
                //now flatten them
                _actionsFlattened = [];


            _.each(groupedTabs, function (items) {
                _actionsFlattened = _actionsFlattened.concat(items);
            });

            var rootActions = [];
            _.each(tabbedActions, function (action) {
                var rootCommand = action.getRoot();
                rootActions.indexOf(rootCommand) == -1 && rootActions.push(rootCommand);
            });

            //owner sort of top level
            store.menuOrder && (rootActions = owner.sortGroups(rootActions, store.menuOrder));

            var tree = {};
            //stats to count groups per tab
            var biggestTab = rootActions[0];
            var nbGroupsBiggest = 0;

            _.each(rootActions, function (level) {
                // collect all actions at level (File/View/...)
                var menuActions = owner.getItemsAtBranch(allActions, level);
                // convert action command strings to Action references
                var grouped = self.toActions(menuActions, store);

                // expand filter -------------------
                var addedExpanded = [];
                var toRemove = [];
                _.each(grouped, function (action) {
                    var actionData = self.getActionData(action);
                    if (actionData.expand) {
                        var children = action.getChildren();
                        children && children.length && (addedExpanded = addedExpanded.concat(children));
                        toRemove.push(action);
                    }
                });
                grouped = grouped.concat(addedExpanded);
                grouped = grouped.filter(function (action) {
                    return toRemove.indexOf(action) == -1;
                });
                // expand filter ---------------    end

                // group all actions by group
                var groupedActions = _.groupBy(grouped, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.group || action.group;
                    }
                });

                var _actions = [];
                _.each(groupedActions, function (items, level) {
                    if (level !== 'undefined') {
                        _actions = _actions.concat(items);
                    }
                });

                //flatten out again
                menuActions = _.pluck(_actions, 'command');
                menuActions.grouped = groupedActions;
                tree[level] = menuActions;

                //update stats
                if (self.collapseSmallGroups) {
                    var nbGroups = _.keys(menuActions.grouped).length;
                    if (nbGroups > nbGroupsBiggest) {
                        nbGroupsBiggest = nbGroups;
                        biggestTab = level;
                    }
                }
            });

            //now move over any tab with less than 2 groups to the next bigger tab
            this.collapseSmallGroups && _.each(tree, function (actions, level) {
                if (_.keys(actions.grouped).length < self.collapseSmallGroups) {
                    //append tab groups of the biggest tab
                    tree[biggestTab] && _.each(actions.grouped, function (group, name) {
                        tree[biggestTab].grouped[name] = group;
                    });
                    //copy manually commands to that tab
                    tree[biggestTab] && _.each(actions, function (action) {
                        tree[biggestTab].push(action);
                    });
                    tree[biggestTab] && delete tree[level];
                }
            });
            var result = {
                root: tree,
                rootActions: rootActions,
                allActionPaths: _.pluck(allActions, 'command'),
                allActions: allActions
            };

            this.lastTree = result;
            return result;
        }
    });
    dcl.chainAfter(Module, 'destroy');
    return Module;
});



},
'xide/views/CIViewMixin':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    "dojo/Stateful",
    'xide/utils',
    'xide/factory',
    'xide/mixins/EventedMixin',
    'xide/layout/_TabContainer',
    'xide/widgets/_Widget',
    'dojo/Deferred',
    "dojo/promise/all",
    'dojo/when'
], function (dcl,declare, Stateful, utils, factory, EventedMixin,_TabContainer,_Widget,Deferred,all,when) {
    var _debug = false;
    var Implementation = {
        declaredClass:'xide.views.CIViewMixin',
        widgets: null,
        delegate: null,
        helpNodes: null,
        store: null,
        groups: null,
        groupContainer: null,
        cssClass: 'CIView',
        ciSort:true,
        options: {
        },
        tabContainer: null,
        viewStyle: '',
        tabs: null,
        tabContainerClass:_TabContainer,
        _didRenderCIS:false,
        typeMap:null,
        getWidgetByType: function (type) {
            for (var i = 0; i < this.widgets.length; i++) {
                var widget = this.widgets[i];
                if (widget.userData.type == type) {
                    return widget;

                }
            }
            return null;
        },
        constructor:function(args){
            utils.mixin(this,args);
        },
        onValueChanged:function(evt){
            this._emit('valueChanged',evt);
        },
        createGroupContainer: function () {

            if (this.tabContainer) {
                return this.tabContainer;
            }
            var tabContainer = utils.addWidget(this.tabContainerClass || _TabContainer,{
                direction:'left',
                style: "min-width:450px;",
                _parent:this,
                resizeToParent:true
            },null,this,true);
            this.tabContainer = tabContainer;
            this.add(tabContainer,null,false);
            return tabContainer;
        },
        getGroupContainer: function () {
            if (this.groupContainer) {
                return this.groupContainer;
            }
            this.groupContainer = this.createGroupContainer();
            return this.groupContainer;
        },
        createGroupView: function (groupContainer, group,icon,selected) {
            return groupContainer.createTab(group,icon,selected,this.tabContainerClass.tabClass ||  _TabContainer.tabClass);
        },
        attachWidgets: function (data, dstNode,view) {
            var thiz = this;
            this.helpNodes = [];
            this.widgets = [];

            dstNode = dstNode || this.domNode;

            var isSingle = !dstNode;

            if(!dstNode && this.tabContainer){
                dstNode = this.tabContainer.containerNode;
            }
            if (!dstNode) {
                console.error('have no parent dstNode!');
                return;
            }
            data = data.reverse();

            for (var i = 0; i < data.length; i++) {
                var widget = data[i];
                widget.delegate = this.owner || this;
                dstNode.appendChild(widget.domNode);
                _debug && console.log('attach widget ',widget);
                if(view && view.lazy===true) {
                    widget._startOnShow = true;
                }else{
                    try {
                        widget.startup();
                    }catch(e){
                        logError(e,'Error starting widget');
                    }
                }
                widget._on('valueChanged',function(evt){
                    evt.view = view;
                    evt.widget = widget;
                    thiz.onValueChanged(evt);
                });
                this._emit('widget',{
                    widget:widget,
                    ci:widget.userData
                });

                this.widgets.push(widget);
                widget.userData.view=view;
                widget.onAttached && widget.onAttached(view);
                if(view && view.add && view.add(widget)){

                }else{
                    _debug && console.error('view has no add',view);
                    this.add(widget);
                }
            }
        },
        empty: function (destroyHandles) {
            if (this.helpNodes) {
                for (var i = 0; i < this.helpNodes.length; i++) {
                    utils.destroy(this.helpNodes[i]);
                }
            }
            if (this.widgets) {
                for (var i = 0; i < this.widgets.length; i++) {
                    utils.destroy(this.widgets[i],true)
                }
            }
            destroyHandles !==false && this._destroyHandles();
            this.tabs = [];

        },
        toArray: function (obj) {
            var result = [];
            for (var c in obj) {
                result.push({
                    name: c,
                    value: obj[c]
                });
            }
            return result;
        },
        onRendered:function(){
            var container = this.getGroupContainer();
            if(this.options.select) {
                container.selectChild(this.options.select);
            }else{
                container.selectChild(0);
            }
            container.resize();
        },
        getTypeMap:function(){
        },
        renderGroup:function(container,title,data){
            var view = this.createGroupView(container, title);
            this.tabs.push(view);
            if(this.ciSort) {
                data = data.sort(function (left, right) {
                    var a = left.order || 0;
                    var b = right.order || 0;
                    return a > b ? -1 : 1;
                });
            }
            var groupDfd = factory.createWidgetsFromArray(data, this, null, false,this.getTypeMap(),!this.ciSort),
                thiz  = this;

            when(groupDfd,function(widgets){
                if (widgets) {
                    _debug && console.log('render group : ' + title,[data,widgets]);
                    thiz.attachWidgets(widgets,view.containerNode,view);
                }
            });

            return groupDfd;
        },
        renderGroups: function (groups) {
            var groupContainer = this.getGroupContainer(),
                _array = groups,
                thiz = this,
                dfd = new Deferred(),
                promises = [];

            for (var i = 0; i < _array.length; i++) {
                try {
                    var groupDfd = this.renderGroup(groupContainer,_array[i].name,_array[i].value);
                    promises.push(groupDfd);
                } catch (e) {
                    console.error('ciview::renderGroups failed ' +e);
                    logError(e);
                }
            }
            all(promises).then(function(){
                groupContainer.resize();
                thiz.onRendered();
                dfd.resolve();
            });
            return dfd;
        },
        getCIS: function () {
            return this.data;
        },

        initWithCIS: function (data) {
            if(this._didRenderCIS){
                _debug && console.warn('CIS already renderers');
                return null;
            }

            this._didRenderCIS = true;
            this.empty(false);
            data = data || this.cis;
            data = utils.flattenCIS(data);
            _debug && console.log('---- init with CIS', _.pluck(data,'title'));
            this.data = data;
            var head = null,
                thiz = this,
                groups = _.groupBy(data,function(obj){
                    return obj.group;
                }),
                groupOrder = this.options.groupOrder || {};

            var groupsToRender = [];

            groups = this.toArray(groups);

            //filter groups for visible CIs
            _.each(groups,function(group){
                _.find(group.value,{visible:true}) && groupsToRender.push(group);
            });
            groups = groupsToRender;

            var grouped = _.sortByOrder(groups, function(obj){
                return groupOrder[obj.name] || 100;
            });

            if (grouped != null && grouped.length > 1) {
                head = this.renderGroups(grouped);
            } else {
                head = factory.createWidgetsFromArray(data, thiz, null, false,this.getTypeMap(),!this.ciSort);
                when(head,function(widgets){
                    thiz.widgets = widgets;
                    _debug && console.log('attach widgets',widgets);
                    if (widgets) {
                        thiz.attachWidgets(widgets);
                    }
                });
            }

            head.then(function(){
                _.invoke(thiz.widgets,'onDidRenderWidgets',thiz,thiz.widgets);
            });

            return head;
        },
        destroy:function(){
            this.cis && _.each(this.cis,function(ci){
                ci['_widget']=null;
                ci['view']=null;
            });
            delete this.helpNodes;
            this.delegate = null;
            this.cis=null;
            this.data=null;
            this.groupContainer=null;
            this.tabContainer=null;
            delete this.tabs;
            this.owner = null;
            this.storeItem = null;
            this.storeDelegate = null;

        }
    };

    var Module = declare("xide.views.CIViewMixin", [_Widget,EventedMixin],Implementation);
    Module.dcl = dcl([_Widget.dcl,EventedMixin.dcl],Implementation);

    return Module;


});
},
'dojo/topic':function(){
define(["./Evented"], function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
});

},
'wcDocker/base':function(){
/** @module wcBase */
define([
    "dcl/dcl",
    "xide/utils"
], function (dcl, utils) {
    /**
     * Base class for all docker classes
     * @class module:wcBase
     */
    return dcl(null, {
        _saveProp: function (what, args) {
            var who = this;
            who['__' + what] = _.isFunction(who[what]) ? who[what]() : who[what];
            args && who[what]!=null && who[what].apply && who[what].apply(who, args);
        },
        _restoreProp: function (what, call) {

            var who = this;

            //this prop also exists
            if (who['_' + what]) {
                who['_' + what] = who['__' + what];
            }
            var _args = who['__' + what];
            if (call !== false) {
                return _.isFunction(who[what]) ? who[what].apply(who, [_args]) : who[what];
            } else {
                return _args;
            }
        },
        debounce: function (methodName, _function, delay, options, now) {
            return utils.debounce(this, methodName, _function, delay, options, now);
        },
        /**
         * Returns this or the docker's options
         * @TODO: better looking through the parents?
         * @function module:wcBase#getOptions
         * @returns {Object|null}
         */
        getOptions: function () {
            return this._options || this.docker()._options || {};
        },

        /**
         * Return an option found in this or in the docker.
         * @function module:wcBase#option
         * @param name
         * @param _default {Object|null}
         * @returns {Object|null}
         */
        option: function(name,_default) {
            return this.getOptions()[name] || _default;
        },

        /**
         * Return a module (dcl) by class name.
         * @param name {string} the class name, for instance "wcPanel", "wcSplitter" and so forth. Please see in wcDocker#defaultClasses for available class names.
         * @returns {object} the dcl module found in options
         * @private
         */
        __getClass: function (name) {
            return this.getOptions()[name + 'Class'];
        },

        /**
         * Class eq function
         * @function module:wcBase#instanceOf
         * @param {string} what
         * @param {object} [who]
         * @returns {boolean}
         */
        instanceOf: function (what, who) {
            who = who || this;
            return !!(who && (who.declaredClass.indexOf(what) != -1));
        },
        /**
         * Retrieves the main [docker]{@link module:wcDocker} instance.
         * @function module:wcBase#docker
         * @returns {module:wcDocker} - The top level docker object.
         */
        docker: function (startNode) {
            var parent = startNode || this._parent;
            while (parent && !(parent.instanceOf('wcDocker'))) {
                parent = parent._parent;
            }
            return parent;
        },
        /**
         * Search upwards for a parent by class string or module
         * @todo get rid of declared class in xDocker
         * @param className {string|Object}
         * @returns {*}
         * @private
         */
        _parentByClass: function(className) {
            var parent = this._parent;
            if(_.isString(className)) {
                while (parent && !(parent.declaredClass.indexOf(className)!==-1)) {
                    parent = parent._parent;
                }
            }
            return parent;
        }
    });
});

},
'xfile/views/FileGrid':function(){
/** @module xfile/views/FileGrid **/
define([
    "xdojo/declare",
    'dojo/Deferred',
    'xide/types',
    'xide/utils',
    'xide/views/History',
    'xaction/DefaultActions',
    'xfile/views/Grid',
    'xfile/factory/Store',
    'xide/model/Path',
    'xfile/model/File',
    "xfile/types",
    'xlang/i18',
    'xide/$'
], function (declare, Deferred, types, utils, History, DefaultActions, Grid, factory, Path, File, fTypes, il8,$) {
    var DEFAULT_PERMISSIONS = fTypes.DEFAULT_FILE_GRID_PERMISSIONS;
    /**
     * A grid feature
     * @class module:xfile/views/FileGrid
     */
    var GridClass = declare('xfile.views.FileGrid', Grid, {
        resizeAfterStartup: true,
        formatters:{},
        menuOrder: {
            'File': 110,
            'Edit': 100,
            'View': 50,
            'Settings': 20,
            'Navigation': 10,
            'Window': 5
        },
        groupOrder: {
            'Clipboard': 110,
            'File': 100,
            'Step': 80,
            'Open': 70,
            'Organize': 60,
            'Insert': 10,
            'Navigation': 5,
            'Select': 0
        },
        tabOrder: {
            'Home': 100,
            'View': 50,
            'Settings': 20,
            'Navigation': 10
        },
        /**
         *
         */
        noDataMessage: '<span/>',
        /**
         * history {module:xide/views/History}
         */
        _history: null,
        options: utils.clone(types.DEFAULT_GRID_OPTIONS),
        _columns: {},
        toolbarInitiallyHidden: true,
        itemType: types.ITEM_TYPE.FILE,
        permissions: DEFAULT_PERMISSIONS,
        contextMenuArgs: {
            limitTo: null,
            actionFilter: {
                quick: true
            }
        },
        /**
         *
         * @param state
         * @returns {*}
         */
        setState: function (state) {
            this.inherited(arguments);
            var self = this,
                collection = self.collection,
                path = state.store.path,
                item = collection.getSync(path),
                dfd = self.refresh();

            dfd.then(function () {
                item = collection.getItem(path, true).then(function (item) {
                    self.openFolder(item);
                });
            });
            return dfd;
        },
        postMixInProperties: function () {
            var state = this.state;
            if (state) {
                if (state._columns) {
                    this._columns = state._columns;
                }
            }
            if (!this.columns) {
                this.columns = this.getColumns();
            }
            if (!this.collection && this.state) {
                var _store = this.state.store,
                    ctx = this.ctx,
                    store = factory.createFileStore(_store.mount, _store.storeOptions, ctx.config);
                this.collection = store.getDefaultCollection();
            }
            return this.inherited(arguments);
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        getState: function (state) {
            state = this.inherited(arguments) || {};
            state.store = {
                mount: this.collection.mount,
                path: this.getCurrentFolder().path,
                storeOptions: this.collection.options
            };
            state._columns = {};
            _.each(this._columns, function (c) {
                state._columns[c.label] = !this.isColumnHidden(c.id);
            }, this);
            return state;
        },
        onSaveLayout: function (e) {
            var customData = e.data,
                gridState = this.getState(),
                data = {
                    widget: this.declaredClass,
                    state: gridState
                };
            customData.widgets.push(data);

            return customData;
        },
        formatColumn: function (field, value, obj) {
            var renderer = this.selectedRenderer ? this.selectedRenderer.prototype : this;
            if (renderer.formatColumn) {
                var result = renderer.formatColumn.apply(arguments);
                if (result) {
                    return result;
                }
            }
            if (obj.renderColumn) {
                var rendered = obj.renderColumn.apply(this, arguments);
                if (rendered) {
                    return rendered;
                }
            }
            switch (field) {
                case "fileType": {
                    if (value == 'folder') {
                        return il8.localize('kindFolder');
                    } else {
                        if (obj.mime) {
                            var mime = obj.mime.split('/')[1] || "unknown";
                            var key = 'kind' + mime.toUpperCase();
                            var _translated = il8.localize(key);
                            return key !== _translated ? _translated : value;
                        }
                    }
                }
                case "name": {
                    var directory = obj && obj.directory != null && obj.directory === true;
                    var no_access = obj.read === false && obj.write === false;
                    var isBack = obj.name == '..';
                    var folderClass = 'fa-folder';
                    var icon = '';
                    var imageClass = '';
                    var useCSS = false;
                    if (directory) {
                        if (isBack) {
                            imageClass = 'fa fa-level-up itemFolderList';
                            useCSS = true;
                        } else if (!no_access) {
                            imageClass = 'fa ' + folderClass + ' itemFolderList';

                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }
                    } else {
                        if (!no_access) {
                            imageClass = 'itemFolderList fa ' + utils.getIconClass(obj.path);
                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }
                    }
                    var label = obj.showPath === true ? obj.path : value;
                    if (!useCSS) {
                        return '<img class="fileGridIconCell" src="' + icon + ' "/><span class="fileGridNameCell">' + label + '</span>';
                    } else {
                        return '<span class=\"' + imageClass + '\""></span><span class="name fileGridNameNode" style="vertical-align: middle;padding-top: 0px">' + label + '</span>';
                    }
                }
                case "sizeBytes": {
                    return obj.size;
                }
                case "fileType": {
                    return utils.capitalize(obj.fileType || 'unknown');
                }
                case "mediaInfo": {
                    return obj.mediaInfo || 'unknown';
                }
                case "owner": {
                    if (obj) {
                        var owner = obj.owner;
                        if (owner && owner.user) {
                            return owner.user.name;
                        }
                    }
                    return "";
                }
                case "modified": {
                    if (value === '') {
                        return value;
                    }
                    var directory = !obj.directory == null;
                    if (!directory) {
                        if(il8.translations.dateFormat){
                            return il8.formatDate(value).replace('ms', '');
                        }
                    }
                    return '';
                }
            }
            return value;
        },
        /**
         *
         * @param formatters
         * @returns {object|null}
         */
        getColumns: function (formatters) {
            formatters = formatters || this.formatters;
            var self = this;
            this.columns = [];
            function createColumn(label, field, sortable, hidden) {
                if (self._columns[label] != null) {
                    hidden = !self._columns[label];
                }
                self.columns.push({
                    renderExpando: label === 'Name',
                    label: label,
                    field: field,
                    sortable: sortable,
                    formatter: function (value, obj) {
                        return label in formatters ? formatters[label].apply(self,[field, value, obj]) : self.formatColumn(field, value, obj);
                    },
                    hidden: hidden
                });
            }
            createColumn('Name', 'name', true, false);
            createColumn('Type', 'fileType', true, true);
            createColumn('Path', 'path', true, true);
            createColumn('Size', 'sizeBytes', true, false);
            createColumn('Modified', 'modified', true, false);
            createColumn('Owner', 'owner', true, true);
            createColumn('Media', 'mediaInfo', true, true);
            return this.columns;
        },
        _focus: function () {
            var rows = this.getRows();
            if (rows[0]) {
                this.focus(this.row(rows[0]));
            }
        },
        /**
         *
         * @param item
         * @returns {boolean}
         */
        setQueryEx: function (item) {
            if (!item || !item.directory) {
                return false;
            }
            this._lastPath = item.getPath();
            var self = this, dfd = new Deferred();
            var col = self.collection;
            if (item.path === '.') {
                col.resetQueryLog();
                self.set("collection", col.getDefaultCollection(item.getPath()));
                dfd.resolve();
            } else {
                col.open(item).then(function (items) {
                    col.resetQueryLog();
                    self.set("collection", col.getDefaultCollection(item.getPath()));
                    dfd.resolve(items);
                });
            }
            return dfd;
        },
        getCurrentFolder: function () {
            var renderer = this.getSelectedRenderer();
            if (renderer && renderer.getCurrentFolder) {
                var _result = renderer.getCurrentFolder.apply(this);
                if (_result) {
                    if (_result.isBack) {
                        var __result = this.collection.getSync(_result.rPath);
                        if (__result) {
                            _result = __result;
                        }
                    }
                    return _result;
                }
            }

            var item = this.getRows()[0];
            if (item && (item._S || item._store)) {
                if (item.isBack === true) {
                    var _now = this.getHistory().getNow();
                    if (_now) {
                        return this.collection.getSync(_now);
                    }
                }
                //current folder:
                var _parent = item._S.getParent(item);
                if (_parent) {
                    return _parent;
                }
            }
            return null;
        },
        getClass: function () {
            return GridClass;
        },
        getHistory: function () {
            if (!this._history) {
                this._history = new History();
            }
            return this._history;
        },
        _createBackItem:function(path){
            return {
                name: '..',
                path: '..',
                rPath: path,
                sizeBytes: 0,
                size: '',
                icon: 'fa-level-up',
                isBack: true,
                modified: '',
                _S: this.collection,
                directory: true,
                _EX: true,
                children: [],
                mayHaveChildren: false
            }
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var res = this.inherited(arguments);
            $(this.domNode).addClass('xfileGrid');
            this.set('loading', true);
            if (this.permissions) {
                this.addActions([].concat(DefaultActions.getDefaultActions(this.permissions, this, this).concat(this.getFileActions(this.permissions))));
            }
            this._history = new History();
            var self = this;
            this.subscribe(types.EVENTS.ON_CLIPBOARD_COPY, function (evt) {
                if (evt.type === self.itemType) {
                    self.currentCopySelection = evt.selection;
                    self.refreshActions();
                }
            });
            self._on('noData', function () {
                if (self._total > 0) {
                    return;
                }
                var _history = self._history,
                    now = _history.getNow();

                if (!now || now === './.') {
                    return;
                }
                self.renderArray([this._createBackItem(now)]);
            });
            this.on('dgrid-refresh-complete', function () {
                var rows = self.getRows();
                if (rows && rows.length > 1) {
                    var back = _.find(rows, {
                        isBack: true
                    });
                    if (back) {
                        self.removeRow(back);
                        self.refresh(now);
                    }
                }
            });

            this._on('openFolder', function (evt) {
                self.set('title', evt.item.name);
            });

            if (self.selectedRenderer) {
                res = this.refresh();
                res && res.then(function () {
                    self.set('loading', false);
                    self.setRenderer(self.selectedRenderer, false);
                });
            }
            this._on('onChangeRenderer',this.refresh);
            this._emit('startup');
            res.then(this.resize.bind(this));
            return res;
        }
    });

    /**
     *
     * @param ctx
     * @param args
     * @param parent
     * @param register
     * @param startup
     * @param store
     * @returns {module:xfile/views/Grid}
     */
    function createDefault(ctx, args, parent, register, startup, store) {
        var defaults = {
            collection: store.getDefaultCollection(),
            _parent: parent,
            Module: GridClass,
            ctx: ctx
        };
        utils.mixin(defaults, args || {});
        var grid = utils.addWidget(GridClass, defaults, null, parent, startup, null, null, true, null);
        register &&ctx.getWindowManager().registerView(grid, false);
        return grid;
    }

    GridClass.prototype.Module = GridClass;
    GridClass.Module = GridClass;
    GridClass.createDefault = createDefault;
    GridClass.DEFAULT_PERMISSIONS = DEFAULT_PERMISSIONS;
    return GridClass;
});
},
'xide/manager/ResourceManager':function(){
/** @module xide/manager/ResourceManager **/
define([
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    'xide/mixins/VariableMixin'
], function (dcl,ServerActionBase, utils, VariableMixin) {
    /**
     *
     * Resource manager which provides:
     *
     * - Resolving variables in strings
     * - Loading & unloading of resources: CSS,JS, Blox, API-Docs and plugins
     *
     * @class xide.manager.ResourceManager
     */
    return dcl([ServerActionBase,VariableMixin.dcl], {
        declaredClass:"xide.manager.ResourceManager",
        serviceClass: "XApp_Resource_Service",
        resourceData: null,
        resourceVariables: null,
        getResourceVariables:function(){
            return this.resourceVariables;
        },
        setVariable: function (variableName,value) {
            return this.resourceVariables[variableName]=value;
        },
        getVariable: function (variableName) {
            return this.resourceVariables[variableName];
        },
        init: function () {
            if (!this.resourceVariables) {
                this.resourceVariables = {};
            }
        },
        replaceVariables: function (string, variables) {
            
            return utils.multipleReplace('' + string, variables || this.resourceVariables);
        }
    });
});
},
'xace/lib_jsbeautify':function(){
define(['require', 'exports', 'module'], function(_r, _e, module) {
var define, window = module.exports = {};
/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {

    var acorn = {};
    (function (exports) {
      // This section of code is taken from acorn.
      //
      // Acorn was written by Marijn Haverbeke and released under an MIT
      // license. The Unicode regexps (for identifiers and whitespace) were
      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
      //
      // Git repositories for Acorn are available at
      //
      //     http://marijnhaverbeke.nl/git/acorn
      //     https://github.com/marijnh/acorn.git

      // ## Character categories

      // Big ugly regular expressions that match characters in the
      // whitespace, identifier, and identifier-start categories. These
      // are only applied when a character is found to actually have a
      // code point above 128.

      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
      var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

      // Whether a single character denotes a newline.

      var newline = exports.newline = /[\n\r\u2028\u2029]/;

      // Matches a whole line break (where CRLF is considered a single
      // line break). Used to count lines.

      var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

      // Test whether a given character code starts an identifier.

      var isIdentifierStart = exports.isIdentifierStart = function(code) {
        if (code < 65) return code === 36;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      };

      // Test whether a given character is part of an identifier.

      var isIdentifierChar = exports.isIdentifierChar = function(code) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      };
    })(acorn);

    function in_array(what, arr) {
        for (var i = 0; i < arr.length; i += 1) {
            if (arr[i] === what) {
                return true;
            }
        }
        return false;
    }

    function trim(s) {
        return s.replace(/^\s+|\s+$/g, '');
    }

    function js_beautify(js_source_text, options) {
        "use strict";
        var beautifier = new Beautifier(js_source_text, options);
        return beautifier.beautify();
    }

    var MODE = {
            BlockStatement: 'BlockStatement', // 'BLOCK'
            Statement: 'Statement', // 'STATEMENT'
            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
            Conditional: 'Conditional', //'(COND-EXPRESSION)',
            Expression: 'Expression' //'(EXPRESSION)'
        };

    function Beautifier(js_source_text, options) {
        "use strict";
        var output
        var tokens = [], token_pos;
        var Tokenizer;
        var current_token;
        var last_type, last_last_text, indent_string;
        var flags, previous_flags, flag_store;
        var prefix;

        var handlers, opt;
        var baseIndentString = '';

        handlers = {
            'TK_START_EXPR': handle_start_expr,
            'TK_END_EXPR': handle_end_expr,
            'TK_START_BLOCK': handle_start_block,
            'TK_END_BLOCK': handle_end_block,
            'TK_WORD': handle_word,
            'TK_RESERVED': handle_word,
            'TK_SEMICOLON': handle_semicolon,
            'TK_STRING': handle_string,
            'TK_EQUALS': handle_equals,
            'TK_OPERATOR': handle_operator,
            'TK_COMMA': handle_comma,
            'TK_BLOCK_COMMENT': handle_block_comment,
            'TK_INLINE_COMMENT': handle_inline_comment,
            'TK_COMMENT': handle_comment,
            'TK_DOT': handle_dot,
            'TK_UNKNOWN': handle_unknown,
            'TK_EOF': handle_eof
        };

        function create_flags(flags_base, mode) {
            var next_indent_level = 0;
            if (flags_base) {
                next_indent_level = flags_base.indentation_level;
                if (!output.just_added_newline() &&
                    flags_base.line_indent_level > next_indent_level) {
                    next_indent_level = flags_base.line_indent_level;
                }
            }

            var next_flags = {
                mode: mode,
                parent: flags_base,
                last_text: flags_base ? flags_base.last_text : '', // last token text
                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
                declaration_statement: false,
                declaration_assignment: false,
                multiline_frame: false,
                if_block: false,
                else_block: false,
                do_block: false,
                do_while: false,
                in_case_statement: false, // switch(..){ INSIDE HERE }
                in_case: false, // we're on the exact line with "case 0:"
                case_body: false, // the indented case-action block
                indentation_level: next_indent_level,
                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
                start_line_index: output.get_line_number(),
                ternary_depth: 0
            };
            return next_flags;
        }

        // Some interpreters have unexpected results with foo = baz || bar;
        options = options ? options : {};
        opt = {};

        // compatibility
        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
            opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
        }
        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");

        // graceful handling of deprecated option
        if (opt.brace_style === "expand-strict") {
            opt.brace_style = "expand";
        }


        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
        opt.indent_char = options.indent_char ? options.indent_char : ' ';
        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;
        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
        opt.e4x = (options.e4x === undefined) ? false : options.e4x;
        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;


        // force opt.space_after_anon_function to true if opt.jslint_happy
        if(opt.jslint_happy) {
            opt.space_after_anon_function = true;
        }

        if(options.indent_with_tabs){
            opt.indent_char = '\t';
            opt.indent_size = 1;
        }

        //----------------------------------
        indent_string = '';
        while (opt.indent_size > 0) {
            indent_string += opt.indent_char;
            opt.indent_size -= 1;
        }

        var preindent_index = 0;
        if(js_source_text && js_source_text.length) {
            while ( (js_source_text.charAt(preindent_index) === ' ' ||
                    js_source_text.charAt(preindent_index) === '\t')) {
                baseIndentString += js_source_text.charAt(preindent_index);
                preindent_index += 1;
            }
            js_source_text = js_source_text.substring(preindent_index);
        }

        last_type = 'TK_START_BLOCK'; // last token type
        last_last_text = ''; // pre-last token text
        output = new Output(indent_string, baseIndentString);


        // Stack of parsing/formatting states, including MODE.
        // We tokenize, parse, and output in an almost purely a forward-only stream of token input
        // and formatted output.  This makes the beautifier less accurate than full parsers
        // but also far more tolerant of syntax errors.
        //
        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
        // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
        // most full parsers would die, but the beautifier gracefully falls back to
        // MODE.BlockStatement and continues on.
        flag_store = [];
        set_mode(MODE.BlockStatement);

        this.beautify = function() {

            /*jshint onevar:true */
            var local_token, sweet_code;
            Tokenizer = new tokenizer(js_source_text, opt, indent_string);
            tokens = Tokenizer.tokenize();
            token_pos = 0;

            while (local_token = get_token()) {
                for(var i = 0; i < local_token.comments_before.length; i++) {
                    // The cleanest handling of inline comments is to treat them as though they aren't there.
                    // Just continue formatting and the behavior should be logical.
                    // Also ignore unknown tokens.  Again, this should result in better behavior.
                    handle_token(local_token.comments_before[i]);
                }
                handle_token(local_token);

                last_last_text = flags.last_text;
                last_type = local_token.type;
                flags.last_text = local_token.text;

                token_pos += 1;
            }

            sweet_code = output.get_code();
            if (opt.end_with_newline) {
                sweet_code += '\n';
            }

            return sweet_code;
        };

        function handle_token(local_token) {
            var newlines = local_token.newlines;
            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);

            if (keep_whitespace) {
                for (i = 0; i < newlines; i += 1) {
                    print_newline(i > 0);
                }
            } else {
                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {
                    newlines = opt.max_preserve_newlines;
                }

                if (opt.preserve_newlines) {
                    if (local_token.newlines > 1) {
                        print_newline();
                        for (var i = 1; i < newlines; i += 1) {
                            print_newline(true);
                        }
                    }
                }
            }

            current_token = local_token;
            handlers[current_token.type]();
        }

        // we could use just string.split, but
        // IE doesn't like returning empty strings

        function split_newlines(s) {
            //return s.split(/\x0d\x0a|\x0a/);

            s = s.replace(/\x0d/g, '');
            var out = [],
                idx = s.indexOf("\n");
            while (idx !== -1) {
                out.push(s.substring(0, idx));
                s = s.substring(idx + 1);
                idx = s.indexOf("\n");
            }
            if (s.length) {
                out.push(s);
            }
            return out;
        }

        function allow_wrap_or_preserved_newline(force_linewrap) {
            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

            // Never wrap the first token on a line
            if (output.just_added_newline()) {
                return
            }

            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {
                print_newline(false, true);
            } else if (opt.wrap_line_length) {
                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +
                    (output.space_before_token ? 1 : 0);
                if (proposed_line_length >= opt.wrap_line_length) {
                    print_newline(false, true);
                }
            }
        }

        function print_newline(force_newline, preserve_statement_flags) {
            if (!preserve_statement_flags) {
                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
                        restore_mode();
                    }
                }
            }

            if (output.add_new_line(force_newline)) {
                flags.multiline_frame = true;
            }
        }

        function print_token_line_indentation() {
            if (output.just_added_newline()) {
                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {
                    output.current_line.push(current_token.whitespace_before);
                    output.space_before_token = false;
                } else if (output.set_indent(flags.indentation_level)) {
                    flags.line_indent_level = flags.indentation_level;
                }
            }
        }

        function print_token(printable_token) {
            printable_token = printable_token || current_token.text;
            print_token_line_indentation();
            output.add_token(printable_token);
        }

        function indent() {
            flags.indentation_level += 1;
        }

        function deindent() {
            if (flags.indentation_level > 0 &&
                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))
                flags.indentation_level -= 1;
        }

        function set_mode(mode) {
            if (flags) {
                flag_store.push(flags);
                previous_flags = flags;
            } else {
                previous_flags = create_flags(null, mode);
            }

            flags = create_flags(previous_flags, mode);
        }

        function is_array(mode) {
            return mode === MODE.ArrayLiteral;
        }

        function is_expression(mode) {
            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
        }

        function restore_mode() {
            if (flag_store.length > 0) {
                previous_flags = flags;
                flags = flag_store.pop();
                if (previous_flags.mode === MODE.Statement) {
                    output.remove_redundant_indentation(previous_flags);
                }
            }
        }

        function start_of_object_property() {
            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (
                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));
        }

        function start_of_statement() {
            if (
                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||
                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
                    (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||
                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||
                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement
                        && !flags.in_case
                        && !(current_token.text === '--' || current_token.text === '++')
                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||
                    (flags.mode === MODE.ObjectLiteral && (
                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))
                ) {

                set_mode(MODE.Statement);
                indent();

                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {
                    flags.declaration_statement = true;
                }

                // Issue #276:
                // If starting a new statement with [if, for, while, do], push to a new line.
                // if (a) if (b) if(c) d(); else e(); else f();
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline(
                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));
                }

                return true;
            }
            return false;
        }

        function all_lines_start_with(lines, c) {
            for (var i = 0; i < lines.length; i++) {
                var line = trim(lines[i]);
                if (line.charAt(0) !== c) {
                    return false;
                }
            }
            return true;
        }

        function each_line_matches_indent(lines, indent) {
            var i = 0,
                len = lines.length,
                line;
            for (; i < len; i++) {
                line = lines[i];
                // allow empty lines to pass through
                if (line && line.indexOf(indent) !== 0) {
                    return false;
                }
            }
            return true;
        }

        function is_special_word(word) {
            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
        }

        function get_token(offset) {
            var index = token_pos + (offset || 0);
            return (index < 0 || index >= tokens.length) ? null : tokens[index];
        }

        function handle_start_expr() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            }

            var next_mode = MODE.Expression;
            if (current_token.text === '[') {

                if (last_type === 'TK_WORD' || flags.last_text === ')') {
                    // this is array index specifier, break immediately
                    // a[x], fn()[x]
                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {
                        output.space_before_token = true;
                    }
                    set_mode(next_mode);
                    print_token();
                    indent();
                    if (opt.space_in_paren) {
                        output.space_before_token = true;
                    }
                    return;
                }

                next_mode = MODE.ArrayLiteral;
                if (is_array(flags.mode)) {
                    if (flags.last_text === '[' ||
                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
                        // ], [ goes to new line
                        // }, [ goes to new line
                        if (!opt.keep_array_indentation) {
                            print_newline();
                        }
                    }
                }

            } else {
                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
                    next_mode = MODE.ForInitializer;
                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
                    next_mode = MODE.Conditional;
                } else {
                    // next_mode = MODE.Expression;
                }
            }

            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
                print_newline();
            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
                // TODO: Consider whether forcing this is required.  Review failing tests when removed.
                allow_wrap_or_preserved_newline(current_token.wanted_newline);
                // do nothing on (( and )( and ][ and ]( and .(
            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
                output.space_before_token = true;
            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
                (flags.last_text === '*' && last_last_text === 'function')) {
                // function() vs function ()
                if (opt.space_after_anon_function) {
                    output.space_before_token = true;
                }
            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {
                if (opt.space_before_conditional) {
                    output.space_before_token = true;
                }
            }

            // Support of this kind of newline preservation.
            // a = (b &&
            //     (c || d));
            if (current_token.text === '(') {
                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                    if (!start_of_object_property()) {
                        allow_wrap_or_preserved_newline();
                    }
                }
            }

            set_mode(next_mode);
            print_token();
            if (opt.space_in_paren) {
                output.space_before_token = true;
            }

            // In all cases, if we newline while inside an expression it should be indented.
            indent();
        }

        function handle_end_expr() {
            // statements inside expressions are not valid syntax, but...
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (flags.multiline_frame) {
                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
            }

            if (opt.space_in_paren) {
                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {
                    // () [] no inner space in empty parens like these, ever, ref #320
                    output.trim();
                    output.space_before_token = false;
                } else {
                    output.space_before_token = true;
                }
            }
            if (current_token.text === ']' && opt.keep_array_indentation) {
                print_token();
                restore_mode();
            } else {
                restore_mode();
                print_token();
            }
            output.remove_redundant_indentation(previous_flags);

            // do {} while () // no statement required after
            if (flags.do_while && previous_flags.mode === MODE.Conditional) {
                previous_flags.mode = MODE.Expression;
                flags.do_block = false;
                flags.do_while = false;

            }
        }

        function handle_start_block() {
            // Check if this is should be treated as a ObjectLiteral
            var next_token = get_token(1)
            var second_token = get_token(2)
            if (second_token && (
                    (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))
                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))
                )) {
                // We don't support TypeScript,but we didn't break it for a very long time.
                // We'll try to keep not breaking it.
                if (!in_array(last_last_text, ['class','interface'])) {
                    set_mode(MODE.ObjectLiteral);
                } else {
                    set_mode(MODE.BlockStatement);
                }
            } else {
                set_mode(MODE.BlockStatement);
            }

            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';
            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
                last_type === 'TK_END_EXPR';

            if (opt.brace_style === "expand" ||
                (opt.brace_style === "none" && current_token.wanted_newline)) {
                if (last_type !== 'TK_OPERATOR' &&
                    (empty_anonymous_function ||
                        last_type === 'TK_EQUALS' ||
                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
                    output.space_before_token = true;
                } else {
                    print_newline(false, true);
                }
            } else { // collapse
                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                    if (last_type === 'TK_START_BLOCK') {
                        print_newline();
                    } else {
                        output.space_before_token = true;
                    }
                } else {
                    // if TK_OPERATOR or TK_START_EXPR
                    if (is_array(previous_flags.mode) && flags.last_text === ',') {
                        if (last_last_text === '}') {
                            // }, { in array context
                            output.space_before_token = true;
                        } else {
                            print_newline(); // [a, b, c, {
                        }
                    }
                }
            }
            print_token();
            indent();
        }

        function handle_end_block() {
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }
            var empty_braces = last_type === 'TK_START_BLOCK';

            if (opt.brace_style === "expand") {
                if (!empty_braces) {
                    print_newline();
                }
            } else {
                // skip {}
                if (!empty_braces) {
                    if (is_array(flags.mode) && opt.keep_array_indentation) {
                        // we REALLY need a newline here, but newliner would skip that
                        opt.keep_array_indentation = false;
                        print_newline();
                        opt.keep_array_indentation = true;

                    } else {
                        print_newline();
                    }
                }
            }
            restore_mode();
            print_token();
        }

        function handle_word() {
            if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&
                in_array(current_token.text, ['set', 'get'])) {
                current_token.type = 'TK_WORD';
            }

            if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {
                var next_token = get_token(1);
                if (next_token.text == ':') {
                    current_token.type = 'TK_WORD';
                }
            }

            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&
                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
                last_type !== 'TK_EQUALS' &&
                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {

                print_newline();
            }

            if (flags.do_block && !flags.do_while) {
                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {
                    // do {} ## while ()
                    output.space_before_token = true;
                    print_token();
                    output.space_before_token = true;
                    flags.do_while = true;
                    return;
                } else {
                    // do {} should always have while as the next word.
                    // if we don't see the expected while, recover
                    print_newline();
                    flags.do_block = false;
                }
            }

            // if may be followed by else, or not
            // Bare/inline ifs are tricky
            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
            if (flags.if_block) {
                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {
                    flags.else_block = true;
                } else {
                    while (flags.mode === MODE.Statement) {
                        restore_mode();
                    }
                    flags.if_block = false;
                    flags.else_block = false;
                }
            }

            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {
                print_newline();
                if (flags.case_body || opt.jslint_happy) {
                    // switch cases following one another
                    deindent();
                    flags.case_body = false;
                }
                print_token();
                flags.in_case = true;
                flags.in_case_statement = true;
                return;
            }

            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {
                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {
                    // make sure there is a nice clean space of at least one blank line
                    // before a new function definition
                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {
                        print_newline();
                        print_newline(true);
                    }
                }
                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export'])) {
                        output.space_before_token = true;
                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {
                        output.space_before_token = true;
                    } else {
                        print_newline();
                    }
                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                    // foo = function
                    output.space_before_token = true;
                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {
                    // (function
                } else {
                    print_newline();
                }
            }

            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            }

            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {
                print_token();
                flags.last_word = current_token.text;
                return;
            }

            prefix = 'NONE';

            if (last_type === 'TK_END_BLOCK') {
                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {
                    prefix = 'NEWLINE';
                } else {
                    if (opt.brace_style === "expand" ||
                        opt.brace_style === "end-expand" ||
                        (opt.brace_style === "none" && current_token.wanted_newline)) {
                        prefix = 'NEWLINE';
                    } else {
                        prefix = 'SPACE';
                        output.space_before_token = true;
                    }
                }
            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
                // TODO: Should this be for STATEMENT as well?
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
                prefix = 'SPACE';
            } else if (last_type === 'TK_STRING') {
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
                (flags.last_text === '*' && last_last_text === 'function')) {
                prefix = 'SPACE';
            } else if (last_type === 'TK_START_BLOCK') {
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_END_EXPR') {
                output.space_before_token = true;
                prefix = 'NEWLINE';
            }

            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
                if (flags.last_text === 'else' || flags.last_text === 'export') {
                    prefix = 'SPACE';
                } else {
                    prefix = 'NEWLINE';
                }

            }

            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {
                if (last_type !== 'TK_END_BLOCK' ||
                    opt.brace_style === "expand" ||
                    opt.brace_style === "end-expand" ||
                    (opt.brace_style === "none" && current_token.wanted_newline)) {
                    print_newline();
                } else {
                    output.trim(true);
                    var line = output.current_line;
                    // If we trimmed and there's something other than a close block before us
                    // put a newline back in.  Handles '} // comment' scenario.
                    if (line.last() !== '}') {
                        print_newline();
                    }
                    output.space_before_token = true;
                }
            } else if (prefix === 'NEWLINE') {
                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                    // no newline between 'return nnn'
                    output.space_before_token = true;
                } else if (last_type !== 'TK_END_EXPR') {
                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
                        // no need to force newline on 'var': for (var x = 0...)
                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {
                            // no newline for } else if {
                            output.space_before_token = true;
                        } else {
                            print_newline();
                        }
                    }
                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {
                    print_newline();
                }
            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
                print_newline(); // }, in lists get a newline treatment
            } else if (prefix === 'SPACE') {
                output.space_before_token = true;
            }
            print_token();
            flags.last_word = current_token.text;

            if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {
                flags.do_block = true;
            }

            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {
                flags.if_block = true;
            }
        }

        function handle_semicolon() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
                // Semicolon can be the start (and end) of a statement
                output.space_before_token = false;
            }
            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
                restore_mode();
            }
            print_token();
        }

        function handle_string() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
                // One difference - strings want at least a space before
                output.space_before_token = true;
            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
                output.space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (!start_of_object_property()) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
            print_token();
        }

        function handle_equals() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            }

            if (flags.declaration_statement) {
                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
                flags.declaration_assignment = true;
            }
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
        }

        function handle_comma() {
            if (flags.declaration_statement) {
                if (is_expression(flags.parent.mode)) {
                    // do not break on comma, for(var a = 1, b = 2)
                    flags.declaration_assignment = false;
                }

                print_token();

                if (flags.declaration_assignment) {
                    flags.declaration_assignment = false;
                    print_newline(false, true);
                } else {
                    output.space_before_token = true;
                }
                return;
            }

            print_token();
            if (flags.mode === MODE.ObjectLiteral ||
                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
                if (flags.mode === MODE.Statement) {
                    restore_mode();
                }
                print_newline();
            } else {
                // EXPR or DO_BLOCK
                output.space_before_token = true;
            }

        }

        function handle_operator() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            }

            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                // "return" had a special handling in TK_WORD. Now we need to return the favor
                output.space_before_token = true;
                print_token();
                return;
            }

            // hack for actionscript's import .*;
            if (current_token.text === '*' && last_type === 'TK_DOT') {
                print_token();
                return;
            }

            if (current_token.text === ':' && flags.in_case) {
                flags.case_body = true;
                indent();
                print_token();
                print_newline();
                flags.in_case = false;
                return;
            }

            if (current_token.text === '::') {
                // no spaces around exotic namespacing syntax operator
                print_token();
                return;
            }

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {
                print_newline(false, true);
            }

            // Allow line wrapping between operators
            if (last_type === 'TK_OPERATOR') {
                allow_wrap_or_preserved_newline();
            }

            var space_before = true;
            var space_after = true;

            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {
                // unary operators (and binary +/- pretending to be unary) special cases

                space_before = false;
                space_after = false;

                if (flags.last_text === ';' && is_expression(flags.mode)) {
                    // for (;; ++i)
                    //        ^^^
                    space_before = true;
                }

                if (last_type === 'TK_RESERVED' || last_type === 'TK_END_EXPR') {
                    space_before = true;
                } else if (last_type === 'TK_OPERATOR') {
                    space_before =
                        (in_array(current_token.text, ['--', '-']) && in_array(flags.last_text, ['--', '-'])) ||
                        (in_array(current_token.text, ['++', '+']) && in_array(flags.last_text, ['++', '+']));
                }

                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
                    // { foo; --i }
                    // foo(); --bar;
                    print_newline();
                }
            } else if (current_token.text === ':') {
                if (flags.ternary_depth === 0) {
                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                    space_before = false;
                } else {
                    flags.ternary_depth -= 1;
                }
            } else if (current_token.text === '?') {
                flags.ternary_depth += 1;
            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
                space_before = false;
                space_after = false;
            }
            output.space_before_token = output.space_before_token || space_before;
            print_token();
            output.space_before_token = space_after;
        }

        function handle_block_comment() {
            var lines = split_newlines(current_token.text);
            var j; // iterator for this case
            var javadoc = false;
            var starless = false;
            var lastIndent = current_token.whitespace_before;
            var lastIndentLength = lastIndent.length;

            // block comment starts with a new line
            print_newline(false, true);
            if (lines.length > 1) {
                if (all_lines_start_with(lines.slice(1), '*')) {
                    javadoc = true;
                }
                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {
                    starless = true;
                }
            }

            // first line always indented
            print_token(lines[0]);
            for (j = 1; j < lines.length; j++) {
                print_newline(false, true);
                if (javadoc) {
                    // javadoc: reformat and re-indent
                    print_token(' ' + trim(lines[j]));
                } else if (starless && lines[j].length > lastIndentLength) {
                    // starless: re-indent non-empty content, avoiding trim
                    print_token(lines[j].substring(lastIndentLength));
                } else {
                    // normal comments output raw
                    output.add_token(lines[j]);
                }
            }

            // for comments of more than one line, make sure there's a new line after
            print_newline(false, true);
        }

        function handle_inline_comment() {
            output.space_before_token = true;
            print_token();
            output.space_before_token = true;
        }

        function handle_comment() {
            if (current_token.wanted_newline) {
                print_newline(false, true);
            } else {
                output.trim(true);
            }

            output.space_before_token = true;
            print_token();
            print_newline(false, true);
        }

        function handle_dot() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            }

            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
                output.space_before_token = true;
            } else {
                // allow preserved newlines before dots in general
                // force newlines on dots after close paren when break_chained - for bar().baz()
                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
            }

            print_token();
        }

        function handle_unknown() {
            print_token();

            if (current_token.text[current_token.text.length - 1] === '\n') {
                print_newline();
            }
        }

        function handle_eof() {
            // Unwind any open statements
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }
        }
    }


    function OutputLine(parent) {
        var _character_count = 0;
        // use indent_count as a marker for lines that have preserved indentation
        var _indent_count = -1;

        var _items = [];
        var _empty = true;

        this.set_indent = function(level) {
            _character_count = parent.baseIndentLength + level * parent.indent_length
            _indent_count = level;
        }

        this.get_character_count = function() {
            return _character_count;
        }

        this.is_empty = function() {
            return _empty;
        }

        this.last = function() {
            if (!this._empty) {
              return _items[_items.length - 1];
            } else {
              return null;
            }
        }

        this.push = function(input) {
            _items.push(input);
            _character_count += input.length;
            _empty = false;
        }

        this.remove_indent = function() {
            if (_indent_count > 0) {
                _indent_count -= 1;
                _character_count -= parent.indent_length
            }
        }

        this.trim = function() {
            while (this.last() === ' ') {
                var item = _items.pop();
                _character_count -= 1;
            }
            _empty = _items.length === 0;
        }

        this.toString = function() {
            var result = '';
            if (!this._empty) {
                if (_indent_count >= 0) {
                    result = parent.indent_cache[_indent_count];
                }
                result += _items.join('')
            }
            return result;
        }
    }

    function Output(indent_string, baseIndentString) {
        baseIndentString = baseIndentString || '';
        this.indent_cache = [ baseIndentString ];
        this.baseIndentLength = baseIndentString.length;
        this.indent_length = indent_string.length;

        var lines =[];
        this.baseIndentString = baseIndentString;
        this.indent_string = indent_string;
        this.current_line = null;
        this.space_before_token = false;

        this.get_line_number = function() {
            return lines.length;
        }

        // Using object instead of string to allow for later expansion of info about each line
        this.add_new_line = function(force_newline) {
            if (this.get_line_number() === 1 && this.just_added_newline()) {
                return false; // no newline on start of file
            }

            if (force_newline || !this.just_added_newline()) {
                this.current_line = new OutputLine(this);
                lines.push(this.current_line);
                return true;
            }

            return false;
        }

        // initialize
        this.add_new_line(true);

        this.get_code = function() {
            var sweet_code = lines.join('\n').replace(/[\r\n\t ]+$/, '');
            return sweet_code;
        }

        this.set_indent = function(level) {
            // Never indent your first output indent at the start of the file
            if (lines.length > 1) {
                while(level >= this.indent_cache.length) {
                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);
                }

                this.current_line.set_indent(level);
                return true;
            }
            this.current_line.set_indent(0);
            return false;
        }

        this.add_token = function(printable_token) {
            this.add_space_before_token();
            this.current_line.push(printable_token);
        }

        this.add_space_before_token = function() {
            if (this.space_before_token && !this.just_added_newline()) {
                this.current_line.push(' ');
            }
            this.space_before_token = false;
        }

        this.remove_redundant_indentation = function (frame) {
            // This implementation is effective but has some issues:
            //     - can cause line wrap to happen too soon due to indent removal
            //           after wrap points are calculated
            // These issues are minor compared to ugly indentation.

            if (frame.multiline_frame ||
                frame.mode === MODE.ForInitializer ||
                frame.mode === MODE.Conditional) {
                return;
            }

            // remove one indent from each line inside this section
            var index = frame.start_line_index;
            var line;

            var output_length = lines.length;
            while (index < output_length) {
                lines[index].remove_indent();
                index++;
            }
        }

        this.trim = function(eat_newlines) {
            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

            this.current_line.trim(indent_string, baseIndentString);

            while (eat_newlines && lines.length > 1 &&
                this.current_line.is_empty()) {
                lines.pop();
                this.current_line = lines[lines.length - 1]
                this.current_line.trim();
            }
        }

        this.just_added_newline = function() {
            return this.current_line.is_empty();
        }

        this.just_added_blankline = function() {
            if (this.just_added_newline()) {
                if (lines.length === 1) {
                    return true; // start of the file and newline = blank
                }

                var line = lines[lines.length - 2];
                return line.is_empty();
            }
            return false;
        }
    }


    var Token = function(type, text, newlines, whitespace_before, mode, parent) {
        this.type = type;
        this.text = text;
        this.comments_before = [];
        this.newlines = newlines || 0;
        this.wanted_newline = newlines > 0;
        this.whitespace_before = whitespace_before || '';
        this.parent = null;
    }

    function tokenizer(input, opts, indent_string) {

        var whitespace = "\n\r\t ".split('');
        var digit = /[0-9]/;

        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>'
                +' <%= <% %> <?= <? ?>').split(' '); // try to be a good boy and try not to break the markup language identifiers

        // words which should always start on new line.
        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield,import,export'.split(',');
        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);

        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;
        var input_length;

        this.tokenize = function() {
            // cache the source's length.
            input_length = input.length
            parser_pos = 0;
            in_html_comment = false
            tokens = [];

            var next, last;
            var token_values;
            var open = null;
            var open_stack = [];
            var comments = [];

            while (!(last && last.type === 'TK_EOF')) {
                token_values = tokenize_next();
                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
                while(next.type === 'TK_INLINE_COMMENT' || next.type === 'TK_COMMENT' ||
                    next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {
                    comments.push(next);
                    token_values = tokenize_next();
                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);
                }

                if (comments.length) {
                    next.comments_before = comments;
                    comments = [];
                }

                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {
                    next.parent = last;
                    open = next;
                    open_stack.push(next);
                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&
                    (open && (
                        (next.text === ']' && open.text === '[') ||
                        (next.text === ')' && open.text === '(') ||
                        (next.text === '}' && open.text === '}')))) {
                    next.parent = open.parent;
                    open = open_stack.pop();
                }

                tokens.push(next);
                last = next;
            }

            return tokens;
        }

        function tokenize_next() {
            var i, resulting_string;
            var whitespace_on_this_line = [];

            n_newlines = 0;
            whitespace_before_token = '';

            if (parser_pos >= input_length) {
                return ['', 'TK_EOF'];
            }

            var last_token;
            if (tokens.length) {
                last_token = tokens[tokens.length-1];
            } else {
                // For the sake of tokenizing we can pretend that there was on open brace to start
                last_token = new Token('TK_START_BLOCK', '{');
            }


            var c = input.charAt(parser_pos);
            parser_pos += 1;

            while (in_array(c, whitespace)) {

                if (c === '\n') {
                    n_newlines += 1;
                    whitespace_on_this_line = [];
                } else if (n_newlines) {
                    if (c === indent_string) {
                        whitespace_on_this_line.push(indent_string);
                    } else if (c !== '\r') {
                        whitespace_on_this_line.push(' ');
                    }
                }

                if (parser_pos >= input_length) {
                    return ['', 'TK_EOF'];
                }

                c = input.charAt(parser_pos);
                parser_pos += 1;
            }

            if(whitespace_on_this_line.length) {
                whitespace_before_token = whitespace_on_this_line.join('');
            }

            if (digit.test(c)) {
                var allow_decimal = true;
                var allow_e = true;
                var local_digit = digit;

                if (c === '0' && parser_pos < input_length && /[Xx]/.test(input.charAt(parser_pos))) {
                    // switch to hex number, no decimal or e, just hex digits
                    allow_decimal = false;
                    allow_e = false;
                    c += input.charAt(parser_pos);
                    parser_pos += 1;
                    local_digit = /[0123456789abcdefABCDEF]/
                } else {
                    // we know this first loop will run.  It keeps the logic simpler.
                    c = '';
                    parser_pos -= 1
                }

                // Add the digits
                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {
                    c += input.charAt(parser_pos);
                    parser_pos += 1;

                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;
                        allow_decimal = false;
                    }

                    if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;

                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {
                            c += input.charAt(parser_pos);
                            parser_pos += 1;
                        }

                        allow_e = false;
                        allow_decimal = false;
                    }
                }

                return [c, 'TK_WORD'];
            }

            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {
                if (parser_pos < input_length) {
                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos === input_length) {
                            break;
                        }
                    }
                }

                if (!(last_token.type === 'TK_DOT' ||
                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))
                    && in_array(c, reserved_words)) {
                    if (c === 'in') { // hack for 'in' operator
                        return [c, 'TK_OPERATOR'];
                    }
                    return [c, 'TK_RESERVED'];
                }

                return [c, 'TK_WORD'];
            }

            if (c === '(' || c === '[') {
                return [c, 'TK_START_EXPR'];
            }

            if (c === ')' || c === ']') {
                return [c, 'TK_END_EXPR'];
            }

            if (c === '{') {
                return [c, 'TK_START_BLOCK'];
            }

            if (c === '}') {
                return [c, 'TK_END_BLOCK'];
            }

            if (c === ';') {
                return [c, 'TK_SEMICOLON'];
            }

            if (c === '/') {
                var comment = '';
                // peek for comment /* ... */
                var inline_comment = true;
                if (input.charAt(parser_pos) === '*') {
                    parser_pos += 1;
                    if (parser_pos < input_length) {
                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
                            c = input.charAt(parser_pos);
                            comment += c;
                            if (c === "\n" || c === "\r") {
                                inline_comment = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                break;
                            }
                        }
                    }
                    parser_pos += 2;
                    if (inline_comment && n_newlines === 0) {
                        return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
                    } else {
                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
                    }
                }
                // peek for comment // ...
                if (input.charAt(parser_pos) === '/') {
                    comment = c;
                    while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
                        comment += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos >= input_length) {
                            break;
                        }
                    }
                    return [comment, 'TK_COMMENT'];
                }

            }

            if (c === '`' || c === "'" || c === '"' || // string
                (
                    (c === '/') || // regexp
                    (opts.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*\/?\s*>/)) // xml
                ) && ( // regex and xml can only appear in specific locations during parsing
                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&
                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||
                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
                    ]))
                )) {

                var sep = c,
                    esc = false,
                    has_char_escapes = false;

                resulting_string = c;

                if (sep === '/') {
                    //
                    // handle regexp
                    //
                    var in_char_class = false;
                    while (parser_pos < input_length &&
                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&
                            !acorn.newline.test(input.charAt(parser_pos)))) {
                        resulting_string += input.charAt(parser_pos);
                        if (!esc) {
                            esc = input.charAt(parser_pos) === '\\';
                            if (input.charAt(parser_pos) === '[') {
                                in_char_class = true;
                            } else if (input.charAt(parser_pos) === ']') {
                                in_char_class = false;
                            }
                        } else {
                            esc = false;
                        }
                        parser_pos += 1;
                    }
                } else if (opts.e4x && sep === '<') {
                    //
                    // handle e4x xml literals
                    //
                    var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*(\/?)\s*>/g;
                    var xmlStr = input.slice(parser_pos - 1);
                    var match = xmlRegExp.exec(xmlStr);
                    if (match && match.index === 0) {
                        var rootTag = match[2];
                        var depth = 0;
                        while (match) {
                            var isEndTag = !! match[1];
                            var tagName = match[2];
                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
                            if (tagName === rootTag && !isSingletonTag) {
                                if (isEndTag) {
                                    --depth;
                                } else {
                                    ++depth;
                                }
                            }
                            if (depth <= 0) {
                                break;
                            }
                            match = xmlRegExp.exec(xmlStr);
                        }
                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;
                        parser_pos += xmlLength - 1;
                        return [xmlStr.slice(0, xmlLength), "TK_STRING"];
                    }
                } else {
                    //
                    // handle string
                    //
                    // Template strings can travers lines without escape characters.
                    // Other strings cannot
                    while (parser_pos < input_length &&
                            (esc || (input.charAt(parser_pos) !== sep &&
                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {
                        resulting_string += input.charAt(parser_pos);
                        if (esc) {
                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
                                has_char_escapes = true;
                            }
                            esc = false;
                        } else {
                            esc = input.charAt(parser_pos) === '\\';
                        }
                        parser_pos += 1;
                    }

                }

                if (has_char_escapes && opts.unescape_strings) {
                    resulting_string = unescape_string(resulting_string);
                }

                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {
                    resulting_string += sep;
                    parser_pos += 1;

                    if (sep === '/') {
                        // regexps may have modifiers /regexp/MOD , so fetch those, too
                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {
                            resulting_string += input.charAt(parser_pos);
                            parser_pos += 1;
                        }
                    }
                }
                return [resulting_string, 'TK_STRING'];
            }

            if (c === '#') {

                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {
                    // shebang
                    resulting_string = c;
                    while (parser_pos < input_length && c !== '\n') {
                        c = input.charAt(parser_pos);
                        resulting_string += c;
                        parser_pos += 1;
                    }
                    return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
                }



                // Spidermonkey-specific sharp variables for circular references
                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
                var sharp = '#';
                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {
                    do {
                        c = input.charAt(parser_pos);
                        sharp += c;
                        parser_pos += 1;
                    } while (parser_pos < input_length && c !== '#' && c !== '=');
                    if (c === '#') {
                        //
                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
                        sharp += '[]';
                        parser_pos += 2;
                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
                        sharp += '{}';
                        parser_pos += 2;
                    }
                    return [sharp, 'TK_WORD'];
                }
            }

            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
                parser_pos += 3;
                c = '<!--';
                while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
                    c += input.charAt(parser_pos);
                    parser_pos++;
                }
                in_html_comment = true;
                return [c, 'TK_COMMENT'];
            }

            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
                in_html_comment = false;
                parser_pos += 2;
                return ['-->', 'TK_COMMENT'];
            }

            if (c === '.') {
                return [c, 'TK_DOT'];
            }

            if (in_array(c, punct)) {
                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
                    c += input.charAt(parser_pos);
                    parser_pos += 1;
                    if (parser_pos >= input_length) {
                        break;
                    }
                }

                if (c === ',') {
                    return [c, 'TK_COMMA'];
                } else if (c === '=') {
                    return [c, 'TK_EQUALS'];
                } else {
                    return [c, 'TK_OPERATOR'];
                }
            }

            return [c, 'TK_UNKNOWN'];
        }


        function unescape_string(s) {
            var esc = false,
                out = '',
                pos = 0,
                s_hex = '',
                escaped = 0,
                c;

            while (esc || pos < s.length) {

                c = s.charAt(pos);
                pos++;

                if (esc) {
                    esc = false;
                    if (c === 'x') {
                        // simple hex-escape \x24
                        s_hex = s.substr(pos, 2);
                        pos += 2;
                    } else if (c === 'u') {
                        // unicode-escape, \u2134
                        s_hex = s.substr(pos, 4);
                        pos += 4;
                    } else {
                        // some common escape, e.g \n
                        out += '\\' + c;
                        continue;
                    }
                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
                        // some weird escaping, bail out,
                        // leaving whole string intact
                        return s;
                    }

                    escaped = parseInt(s_hex, 16);

                    if (escaped >= 0x00 && escaped < 0x20) {
                        // leave 0x00...0x1f escaped
                        if (c === 'x') {
                            out += '\\x' + s_hex;
                        } else {
                            out += '\\u' + s_hex;
                        }
                        continue;
                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                        // single-quote, apostrophe, backslash - escape these
                        out += '\\' + String.fromCharCode(escaped);
                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
                        // we bail out on \x7f..\xff,
                        // leaving whole string escaped,
                        // as it's probably completely binary
                        return s;
                    } else {
                        out += String.fromCharCode(escaped);
                    }
                } else if (c === '\\') {
                    esc = true;
                } else {
                    out += c;
                }
            }
            return out;
        }

    }


    if (typeof define === "function" && define.amd) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        define([], function() {
            return { js_beautify: js_beautify };
        });
    } else if (typeof exports !== "undefined") {
        // Add support for CommonJS. Just put this file somewhere on your require.paths
        // and you will be able to `var js_beautify = require("beautify").js_beautify`.
        exports.js_beautify = js_beautify;
    } else if (typeof window !== "undefined") {
        // If we're running a web page and don't have either of the above, add our one global
        window.js_beautify = js_beautify;
    } else if (typeof global !== "undefined") {
        // If we don't even have window, try global.
        global.js_beautify = js_beautify;
    }

}());
/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
        http://jsbeautifier.org/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                    indentation size,
        indent_char (space)                character to indent with,
        selector_separator_newline (true) - separate selectors with newline or
                                            not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)          - end with a newline

    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {
    function css_beautify(source_text, options) {
        options = options || {};
        var indentSize = options.indent_size || 4;
        var indentCharacter = options.indent_char || ' ';
        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;

        // compatibility
        if (typeof indentSize === "string") {
            indentSize = parseInt(indentSize, 10);
        }


        // tokenizer
        var whiteRe = /^\s+$/;
        var wordRe = /[\w$\-_]/;

        var pos = -1,
            ch;

        function next() {
            ch = source_text.charAt(++pos);
            return ch || '';
        }

        function peek(skipWhitespace) {
            var prev_pos = pos;
            if (skipWhitespace) {
                eatWhitespace();
            }
            result = source_text.charAt(pos + 1) || '';
            pos = prev_pos - 1;
            next();
            return result;
        }

        function eatString(endChars) {
            var start = pos;
            while (next()) {
                if (ch === "\\") {
                    next();
                } else if (endChars.indexOf(ch) !== -1) {
                    break;
                } else if (ch === "\n") {
                    break;
                }
            }
            return source_text.substring(start, pos + 1);
        }

        function peekString(endChar) {
            var prev_pos = pos;
            var str = eatString(endChar);
            pos = prev_pos - 1;
            next();
            return str;
        }

        function eatWhitespace() {
            var result = '';
            while (whiteRe.test(peek())) {
                next()
                result += ch;
            }
            return result;
        }

        function skipWhitespace() {
            var result = '';
            if (ch && whiteRe.test(ch)) {
                result = ch;
            }
            while (whiteRe.test(next())) {
                result += ch
            }
            return result;
        }

        function eatComment(singleLine) {
            var start = pos;
            var singleLine = peek() === "/";
            next();
            while (next()) {
                if (!singleLine && ch === "*" && peek() === "/") {
                    next();
                    break;
                } else if (singleLine && ch === "\n") {
                    return source_text.substring(start, pos);
                }
            }

            return source_text.substring(start, pos) + ch;
        }


        function lookBack(str) {
            return source_text.substring(pos - str.length, pos).toLowerCase() ===
                str;
        }

        // Nested pseudo-class if we are insideRule
        // and the next special character found opens
        // a new block
        function foundNestedPseudoClass() {
            for (var i = pos + 1; i < source_text.length; i++){
                var ch = source_text.charAt(i);
                if (ch === "{"){
                    return true;
                } else if (ch === ";" || ch === "}" || ch === ")") {
                    return false;
                }
            }
            return false;
        }

        // printer
        var basebaseIndentString = source_text.match(/^[\t ]*/)[0];
        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
        var indentLevel = 0;
        var nestedLevel = 0;

        function indent() {
            indentLevel++;
            basebaseIndentString += singleIndent;
        }

        function outdent() {
            indentLevel--;
            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);
        }

        var print = {};
        print["{"] = function(ch) {
            print.singleSpace();
            output.push(ch);
            print.newLine();
        };
        print["}"] = function(ch) {
            print.newLine();
            output.push(ch);
            print.newLine();
        };

        print._lastCharWhitespace = function() {
            return whiteRe.test(output[output.length - 1]);
        };

        print.newLine = function(keepWhitespace) {
            if (!keepWhitespace) {
                print.trim();
            }

            if (output.length) {
                output.push('\n');
            }
            if (basebaseIndentString) {
                output.push(basebaseIndentString);
            }
        };
        print.singleSpace = function() {
            if (output.length && !print._lastCharWhitespace()) {
                output.push(' ');
            }
        };

        print.trim = function() {
            while (print._lastCharWhitespace()) {
                output.pop();
            }
        };

        
        var output = [];
        if (basebaseIndentString) {
            output.push(basebaseIndentString);
        }
        /*_____________________--------------------_____________________*/

        var insideRule = false;
        var enteringConditionalGroup = false;
        var top_ch = '';
        var last_top_ch = '';

        while (true) {
            var whitespace = skipWhitespace();
            var isAfterSpace = whitespace !== '';
            var isAfterNewline = whitespace.indexOf('\n') !== -1;
            var last_top_ch = top_ch;
            var top_ch = ch;

            if (!ch) {
                break;
            } else if (ch === '/' && peek() === '*') { /* css comment */
                var header = lookBack("");
                print.newLine();
                output.push(eatComment());
                print.newLine();
                if (header) {
                    print.newLine(true);
                }
            } else if (ch === '/' && peek() === '/') { // single line comment
                if (!isAfterNewline && last_top_ch !== '{') {
                    print.trim();
                }
                print.singleSpace();
                output.push(eatComment());
                print.newLine();
            } else if (ch === '@') {
                // pass along the space we found as a separate item
                if (isAfterSpace) {
                    print.singleSpace();
                }
                output.push(ch);

                // strip trailing space, if present, for hash property checks
                var variableOrRule = peekString(": ,;{}()[]/='\"").replace(/\s$/, '');

                // might be a nesting at-rule
                if (variableOrRule in css_beautify.NESTED_AT_RULE) {
                    nestedLevel += 1;
                    if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {
                        enteringConditionalGroup = true;
                    }
                } else if (': '.indexOf(variableOrRule[variableOrRule.length -1]) >= 0) {
                    //we have a variable, add it and insert one space before continuing
                    next();
                    variableOrRule = eatString(": ").replace(/\s$/, '');
                    output.push(variableOrRule);
                    print.singleSpace();
                }
            } else if (ch === '{') {
                if (peek(true) === '}') {
                    eatWhitespace();
                    next();
                    print.singleSpace();
                    output.push("{}");
                } else {
                    indent();
                    print["{"](ch);
                    // when entering conditional groups, only rulesets are allowed
                    if (enteringConditionalGroup) {
                        enteringConditionalGroup = false;
                        insideRule = (indentLevel > nestedLevel);
                    } else {
                        // otherwise, declarations are also allowed
                        insideRule = (indentLevel >= nestedLevel);
                    }
                }
            } else if (ch === '}') {
                outdent();
                print["}"](ch);
                insideRule = false;
                if (nestedLevel) {
                    nestedLevel--;
                }
            } else if (ch === ":") {
                eatWhitespace();
                if ((insideRule || enteringConditionalGroup) && 
                        !(lookBack("&") || foundNestedPseudoClass())) {
                    // 'property: value' delimiter
                    // which could be in a conditional group query
                    output.push(':');
                    print.singleSpace();
                } else {
                    // sass/less parent reference don't use a space
                    // sass nested pseudo-class don't use a space
                    if (peek() === ":") {
                        // pseudo-element
                        next();
                        output.push("::");
                    } else {
                        // pseudo-class
                        output.push(':');
                    }
                }
            } else if (ch === '"' || ch === '\'') {
                if (isAfterSpace) {
                    print.singleSpace();
                }
                output.push(eatString(ch));
            } else if (ch === ';') {
                output.push(ch);
                print.newLine();
            } else if (ch === '(') { // may be a url
                if (lookBack("url")) {
                    output.push(ch);
                    eatWhitespace();
                    if (next()) {
                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
                            output.push(eatString(')'));
                        } else {
                            pos--;
                        }
                    }
                } else {
                    if (isAfterSpace) {
                        print.singleSpace();
                    }
                    output.push(ch);
                    eatWhitespace();
                }
            } else if (ch === ')') {
                output.push(ch);
            } else if (ch === ',') {
                output.push(ch);
                eatWhitespace();
                if (!insideRule && selectorSeparatorNewline) {
                    print.newLine();
                } else {
                    print.singleSpace();
                }
            } else if (ch === ']') {
                output.push(ch);
            } else if (ch === '[') {
                if (isAfterSpace) {
                    print.singleSpace();
                }
                output.push(ch);
            } else if (ch === '=') { // no whitespace before or after
                eatWhitespace();
                output.push(ch);
            } else {
                if (isAfterSpace) {
                    print.singleSpace();
                }

                output.push(ch);
            }
        }


        var sweetCode = output.join('').replace(/[\r\n\t ]+$/, '');

        // establish end_with_newline
        if (end_with_newline) {
            sweetCode += "\n";
        }

        return sweetCode;
    }

    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
    css_beautify.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        // also in CONDITIONAL_GROUP_RULE below
        "@media": true,
        "@supports": true,
        "@document": true
    };
    css_beautify.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
    };

    /*global define */
    if (typeof define === "function" && define.amd) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        define([], function() {
            return {
                css_beautify: css_beautify
            };
        });
    } else if (typeof exports !== "undefined") {
        // Add support for CommonJS. Just put this file somewhere on your require.paths
        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
        exports.css_beautify = css_beautify;
    } else if (typeof window !== "undefined") {
        // If we're running a web page and don't have either of the above, add our one global
        window.css_beautify = css_beautify;
    } else if (typeof global !== "undefined") {
        // If we don't even have window, try global.
        global.css_beautify = css_beautify;
    }

}());
/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)   indent <head> and <body> sections,
    indent_size (default 4)           indentation size,
    indent_char (default space)       character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline


    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false
    });
*/

(function() {

    function trim(s) {
        return s.replace(/^\s+|\s+$/g, '');
    }

    function ltrim(s) {
        return s.replace(/^\s+/g, '');
    }

    function rtrim(s) {
        return s.replace(/\s+$/g,'');
    }

    function style_html(html_source, options, js_beautify, css_beautify) {
        //Wrapper function to invoke all the necessary constructors and deal with the output.

        var multi_parser,
            indent_inner_html,
            indent_size,
            indent_character,
            wrap_line_length,
            brace_style,
            unformatted,
            preserve_newlines,
            max_preserve_newlines,
            indent_handlebars,
            end_with_newline;

        options = options || {};

        // backwards compatibility to 1.3.4
        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
            options.wrap_line_length = options.max_char;
        }

        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
        unformatted = options.unformatted || ['a', 'span', 'img', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
        max_preserve_newlines = preserve_newlines ?
            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))
            : 0;
        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;
        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;

        function Parser() {

            this.pos = 0; //Parser position
            this.token = '';
            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
                parent: 'parent1',
                parentcount: 1,
                parent1: ''
            };
            this.tag_type = '';
            this.token_text = this.last_token = this.last_text = this.token_type = '';
            this.newlines = 0;
            this.indent_content = indent_inner_html;

            this.Utils = { //Uilities made available to the various functions
                whitespace: "\n\r\t ".split(''),
                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML
                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
                in_array: function(what, arr) {
                    for (var i = 0; i < arr.length; i++) {
                        if (what === arr[i]) {
                            return true;
                        }
                    }
                    return false;
                }
            };

            // Return true iff the given text is composed entirely of
            // whitespace.
            this.is_whitespace = function(text) {
                for (var n = 0; n < text.length; text++) {
                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {
                        return false;
                    }
                }
                return true;
            }

            this.traverse_whitespace = function() {
                var input_char = '';

                input_char = this.input.charAt(this.pos);
                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                    this.newlines = 0;
                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
                            this.newlines += 1;
                        }

                        this.pos++;
                        input_char = this.input.charAt(this.pos);
                    }
                    return true;
                }
                return false;
            };

            // Append a space to the given content (string array) or, if we are
            // at the wrap_line_length, append a newline/indentation.
            this.space_or_wrap = function(content) {
                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
                    this.print_newline(false, content);
                    this.print_indentation(content);
                } else {
                    this.line_char_count++;
                    content.push(' ');
                }
            };

            this.get_content = function() { //function to capture regular content between tags
                var input_char = '',
                    content = [],
                    space = false; //if a space is needed

                while (this.input.charAt(this.pos) !== '<') {
                    if (this.pos >= this.input.length) {
                        return content.length ? content.join('') : ['', 'TK_EOF'];
                    }

                    if (this.traverse_whitespace()) {
                        this.space_or_wrap(content);
                        continue;
                    }

                    if (indent_handlebars) {
                        // Handlebars parsing is complicated.
                        // {{#foo}} and {{/foo}} are formatted tags.
                        // {{something}} should get treated as content, except:
                        // {{else}} specifically behaves like {{#if}} and {{/if}}
                        var peek3 = this.input.substr(this.pos, 3);
                        if (peek3 === '{{#' || peek3 === '{{/') {
                            // These are tags and not content.
                            break;
                        } else if (this.input.substr(this.pos, 2) === '{{') {
                            if (this.get_tag(true) === '{{else}}') {
                                break;
                            }
                        }
                    }

                    input_char = this.input.charAt(this.pos);
                    this.pos++;
                    this.line_char_count++;
                    content.push(input_char); //letter at-a-time (or string) inserted to an array
                }
                return content.length ? content.join('') : '';
            };

            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
                if (this.pos === this.input.length) {
                    return ['', 'TK_EOF'];
                }
                var input_char = '';
                var content = '';
                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
                reg_match.lastIndex = this.pos;
                var reg_array = reg_match.exec(this.input);
                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
                if (this.pos < end_script) { //get everything in between the script tags
                    content = this.input.substring(this.pos, end_script);
                    this.pos = end_script;
                }
                return content;
            };

            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
                if (this.tags[tag + 'count']) { //check for the existence of this tag type
                    this.tags[tag + 'count']++;
                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
                } else { //otherwise initialize this tag type
                    this.tags[tag + 'count'] = 1;
                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
                }
                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
            };

            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
                    while (temp_parent) { //till we reach '' (the initial value);
                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
                            break;
                        }
                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
                    }
                    if (temp_parent) { //if we caught something
                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
                    }
                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
                    if (this.tags[tag + 'count'] === 1) {
                        delete this.tags[tag + 'count'];
                    } else {
                        this.tags[tag + 'count']--;
                    }
                }
            };

            this.indent_to_tag = function(tag) {
                // Match the indentation level to the last use of this tag, but don't remove it.
                if (!this.tags[tag + 'count']) {
                    return;
                }
                var temp_parent = this.tags.parent;
                while (temp_parent) {
                    if (tag + this.tags[tag + 'count'] === temp_parent) {
                        break;
                    }
                    temp_parent = this.tags[temp_parent + 'parent'];
                }
                if (temp_parent) {
                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
                }
            };

            this.get_tag = function(peek) { //function to get a full tag and parse its type
                var input_char = '',
                    content = [],
                    comment = '',
                    space = false,
                    tag_start, tag_end,
                    tag_start_char,
                    orig_pos = this.pos,
                    orig_line_char_count = this.line_char_count;

                peek = peek !== undefined ? peek : false;

                do {
                    if (this.pos >= this.input.length) {
                        if (peek) {
                            this.pos = orig_pos;
                            this.line_char_count = orig_line_char_count;
                        }
                        return content.length ? content.join('') : ['', 'TK_EOF'];
                    }

                    input_char = this.input.charAt(this.pos);
                    this.pos++;

                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
                        space = true;
                        continue;
                    }

                    if (input_char === "'" || input_char === '"') {
                        input_char += this.get_unformatted(input_char);
                        space = true;

                    }

                    if (input_char === '=') { //no space before =
                        space = false;
                    }

                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
                        //no space after = or before >
                        this.space_or_wrap(content);
                        space = false;
                    }

                    if (indent_handlebars && tag_start_char === '<') {
                        // When inside an angle-bracket tag, put spaces around
                        // handlebars not inside of strings.
                        if ((input_char + this.input.charAt(this.pos)) === '{{') {
                            input_char += this.get_unformatted('}}');
                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
                                input_char = ' ' + input_char;
                            }
                            space = true;
                        }
                    }

                    if (input_char === '<' && !tag_start_char) {
                        tag_start = this.pos - 1;
                        tag_start_char = '<';
                    }

                    if (indent_handlebars && !tag_start_char) {
                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {
                            if (input_char === '#' || input_char === '/') {
                                tag_start = this.pos - 3;
                            } else {
                                tag_start = this.pos - 2;
                            }
                            tag_start_char = '{';
                        }
                    }

                    this.line_char_count++;
                    content.push(input_char); //inserts character at-a-time (or string)

                    if (content[1] && content[1] === '!') { //if we're in a comment, do something special
                        // We treat all comments as literals, even more than preformatted tags
                        // we just look for the appropriate close tag
                        content = [this.get_comment(tag_start)];
                        break;
                    }

                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
                        break;
                    }
                } while (input_char !== '>');

                var tag_complete = content.join('');
                var tag_index;
                var tag_offset;

                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
                    tag_index = tag_complete.indexOf(' ');
                } else if (tag_complete[0] === '{') {
                    tag_index = tag_complete.indexOf('}');
                } else { //otherwise go with the tag ending
                    tag_index = tag_complete.indexOf('>');
                }
                if (tag_complete[0] === '<' || !indent_handlebars) {
                    tag_offset = 1;
                } else {
                    tag_offset = tag_complete[2] === '#' ? 3 : 2;
                }
                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
                    if (!peek) {
                        this.tag_type = 'SINGLE';
                    }
                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {
                    if (!peek) {
                        this.indent_to_tag('if');
                        this.tag_type = 'HANDLEBARS_ELSE';
                        this.indent_content = true;
                        this.traverse_whitespace();
                    }
                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the "unformatted" tags
                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
                    content.push(comment);
                    tag_end = this.pos - 1;
                    this.tag_type = 'SINGLE';
                } else if (tag_check === 'script' &&
                    (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 &&
                    tag_complete.search(/\b(text|application)\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {
                    if (!peek) {
                        this.record_tag(tag_check);
                        this.tag_type = 'SCRIPT';
                    }
                } else if (tag_check === 'style' &&
                    (tag_complete.search('type') === -1 ||
                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
                    if (!peek) {
                        this.record_tag(tag_check);
                        this.tag_type = 'STYLE';
                    }
                } else if (tag_check.charAt(0) === '!') { //peek for <! comment
                    // for comments content is already correct.
                    if (!peek) {
                        this.tag_type = 'SINGLE';
                        this.traverse_whitespace();
                    }
                } else if (!peek) {
                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
                        this.tag_type = 'END';
                    } else { //otherwise it's a start-tag
                        this.record_tag(tag_check); //push it on the tag stack
                        if (tag_check.toLowerCase() !== 'html') {
                            this.indent_content = true;
                        }
                        this.tag_type = 'START';
                    }

                    // Allow preserving of newlines after a start or end tag
                    if (this.traverse_whitespace()) {
                        this.space_or_wrap(content);
                    }

                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
                        this.print_newline(false, this.output);
                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
                            this.print_newline(true, this.output);
                        }
                    }
                }

                if (peek) {
                    this.pos = orig_pos;
                    this.line_char_count = orig_line_char_count;
                }

                return content.join(''); //returns fully formatted tag
            };

            this.get_comment = function(start_pos) { //function to return comment content in its entirety
                // this is will have very poor perf, but will work for now.
                var comment = '',
                    delimiter = '>',
                    matched = false;

                this.pos = start_pos;
                input_char = this.input.charAt(this.pos);
                this.pos++;

                while (this.pos <= this.input.length) {
                    comment += input_char;

                    // only need to check for the delimiter if the last chars match
                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&
                        comment.indexOf(delimiter) !== -1) {
                        break;
                    }

                    // only need to search for custom delimiter for the first few characters
                    if (!matched && comment.length < 10) {
                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
                            delimiter = '<![endif]>';
                            matched = true;
                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
                            delimiter = ']]>';
                            matched = true;
                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
                            delimiter = ']>';
                            matched = true;
                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
                            delimiter = '-->';
                            matched = true;
                        }
                    }

                    input_char = this.input.charAt(this.pos);
                    this.pos++;
                }

                return comment;
            };

            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety

                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
                    return '';
                }
                var input_char = '';
                var content = '';
                var min_index = 0;
                var space = true;
                do {

                    if (this.pos >= this.input.length) {
                        return content;
                    }

                    input_char = this.input.charAt(this.pos);
                    this.pos++;

                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
                        if (!space) {
                            this.line_char_count--;
                            continue;
                        }
                        if (input_char === '\n' || input_char === '\r') {
                            content += '\n';
                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
                for (var i=0; i<this.indent_level; i++) {
                  content += this.indent_string;
                }
                space = false; //...and make sure other indentation is erased
                */
                            this.line_char_count = 0;
                            continue;
                        }
                    }
                    content += input_char;
                    this.line_char_count++;
                    space = true;

                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {
                        // Handlebars expressions in strings should also be unformatted.
                        content += this.get_unformatted('}}');
                        // These expressions are opaque.  Ignore delimiters found in them.
                        min_index = content.length;
                    }
                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);
                return content;
            };

            this.get_token = function() { //initial handler for token-retrieval
                var token;

                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
                    var type = this.last_token.substr(7);
                    token = this.get_contents_to(type);
                    if (typeof token !== 'string') {
                        return token;
                    }
                    return [token, 'TK_' + type];
                }
                if (this.current_mode === 'CONTENT') {
                    token = this.get_content();
                    if (typeof token !== 'string') {
                        return token;
                    } else {
                        return [token, 'TK_CONTENT'];
                    }
                }

                if (this.current_mode === 'TAG') {
                    token = this.get_tag();
                    if (typeof token !== 'string') {
                        return token;
                    } else {
                        var tag_name_type = 'TK_TAG_' + this.tag_type;
                        return [token, tag_name_type];
                    }
                }
            };

            this.get_full_indent = function(level) {
                level = this.indent_level + level || 0;
                if (level < 1) {
                    return '';
                }

                return Array(level + 1).join(this.indent_string);
            };

            this.is_unformatted = function(tag_check, unformatted) {
                //is this an HTML5 block-level link?
                if (!this.Utils.in_array(tag_check, unformatted)) {
                    return false;
                }

                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
                    return true;
                }

                //at this point we have an  tag; is its first child something we want to remain
                //unformatted?
                var next_tag = this.get_tag(true /* peek. */ );

                // test next_tag to see if it is just html tag (no external content)
                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

                // if next_tag comes back but is not an isolated tag, then
                // let's treat the 'a' tag as having content
                // and respect the unformatted option
                if (!tag || this.Utils.in_array(tag, unformatted)) {
                    return true;
                } else {
                    return false;
                }
            };

            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

                this.input = js_source || ''; //gets the input for the Parser
                this.output = [];
                this.indent_character = indent_character;
                this.indent_string = '';
                this.indent_size = indent_size;
                this.brace_style = brace_style;
                this.indent_level = 0;
                this.wrap_line_length = wrap_line_length;
                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

                for (var i = 0; i < this.indent_size; i++) {
                    this.indent_string += this.indent_character;
                }

                this.print_newline = function(force, arr) {
                    this.line_char_count = 0;
                    if (!arr || !arr.length) {
                        return;
                    }
                    if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
                        if ((arr[arr.length - 1] !== '\n')) {
                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);
                        }
                        arr.push('\n');
                    }
                };

                this.print_indentation = function(arr) {
                    for (var i = 0; i < this.indent_level; i++) {
                        arr.push(this.indent_string);
                        this.line_char_count += this.indent_string.length;
                    }
                };

                this.print_token = function(text) {
                    // Avoid printing initial whitespace.
                    if (this.is_whitespace(text) && !this.output.length) {
                        return;
                    }
                    if (text || text !== '') {
                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
                            this.print_indentation(this.output);
                            text = ltrim(text);
                        }
                    }
                    this.print_token_raw(text);
                };

                this.print_token_raw = function(text) {
                    // If we are going to print newlines, truncate trailing
                    // whitespace, as the newlines will represent the space.
                    if (this.newlines > 0) {
                        text = rtrim(text);
                    }

                    if (text && text !== '') {
                        if (text.length > 1 && text[text.length - 1] === '\n') {
                            // unformatted tags can grab newlines as their last character
                            this.output.push(text.slice(0, -1));
                            this.print_newline(false, this.output);
                        } else {
                            this.output.push(text);
                        }
                    }

                    for (var n = 0; n < this.newlines; n++) {
                        this.print_newline(n > 0, this.output);
                    }
                    this.newlines = 0;
                };

                this.indent = function() {
                    this.indent_level++;
                };

                this.unindent = function() {
                    if (this.indent_level > 0) {
                        this.indent_level--;
                    }
                };
            };
            return this;
        }

        /*_____________________--------------------_____________________*/

        multi_parser = new Parser(); //wrapping functions Parser
        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

        while (true) {
            var t = multi_parser.get_token();
            multi_parser.token_text = t[0];
            multi_parser.token_type = t[1];

            if (multi_parser.token_type === 'TK_EOF') {
                break;
            }

            switch (multi_parser.token_type) {
                case 'TK_TAG_START':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_STYLE':
                case 'TK_TAG_SCRIPT':
                    multi_parser.print_newline(false, multi_parser.output);
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_END':
                    //Print new line only if the tag has no content and has child
                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
                        var tag_name = multi_parser.token_text.match(/\w+/)[0];
                        var tag_extracted_from_last_output = null;
                        if (multi_parser.output.length) {
                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
                        }
                        if (tag_extracted_from_last_output === null ||
                            tag_extracted_from_last_output[1] !== tag_name) {
                            multi_parser.print_newline(false, multi_parser.output);
                        }
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_SINGLE':
                    // Don't add a newline before elements that should remain unformatted.
                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z-]+)/i);
                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
                        multi_parser.print_newline(false, multi_parser.output);
                    }
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_TAG_HANDLEBARS_ELSE':
                    multi_parser.print_token(multi_parser.token_text);
                    if (multi_parser.indent_content) {
                        multi_parser.indent();
                        multi_parser.indent_content = false;
                    }
                    multi_parser.current_mode = 'CONTENT';
                    break;
                case 'TK_CONTENT':
                    multi_parser.print_token(multi_parser.token_text);
                    multi_parser.current_mode = 'TAG';
                    break;
                case 'TK_STYLE':
                case 'TK_SCRIPT':
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_newline(false, multi_parser.output);
                        var text = multi_parser.token_text,
                            _beautifier,
                            script_indent_level = 1;
                        if (multi_parser.token_type === 'TK_SCRIPT') {
                            _beautifier = typeof js_beautify === 'function' && js_beautify;
                        } else if (multi_parser.token_type === 'TK_STYLE') {
                            _beautifier = typeof css_beautify === 'function' && css_beautify;
                        }

                        if (options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (options.indent_scripts === "separate") {
                            script_indent_level = -multi_parser.indent_level;
                        }

                        var indentation = multi_parser.get_full_indent(script_indent_level);
                        if (_beautifier) {
                            // call the Beautifier if avaliable
                            text = _beautifier(text.replace(/^\s*/, indentation), options);
                        } else {
                            // simply indent the string otherwise
                            var white = text.match(/^\s*/)[0];
                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
                            text = text.replace(/^\s*/, indentation)
                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
                                .replace(/\s+$/, '');
                        }
                        if (text) {
                            multi_parser.print_token_raw(text);
                            multi_parser.print_newline(true, multi_parser.output);
                        }
                    }
                    multi_parser.current_mode = 'TAG';
                    break;
                default:
                    // We should not be getting here but we don't want to drop input on the floor
                    // Just output the text and move on
                    if (multi_parser.token_text !== '') {
                        multi_parser.print_token(multi_parser.token_text);
                    }
                    break;
            }
            multi_parser.last_token = multi_parser.token_type;
            multi_parser.last_text = multi_parser.token_text;
        }
        var sweet_code = multi_parser.output.join('').replace(/[\r\n\t ]+$/, '');
        if (end_with_newline) {
            sweet_code += '\n';
        }
        return sweet_code;
    }

    if (typeof define === "function" && define.amd) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        define(["require", "./beautify", "./beautify-css"], function(requireamd) {
            var js_beautify =  requireamd("./beautify");
            var css_beautify =  requireamd("./beautify-css");

            return {
              html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
              }
            };
        });
    } else if (typeof exports !== "undefined") {
        // Add support for CommonJS. Just put this file somewhere on your require.paths
        // and you will be able to `var html_beautify = require("beautify").html_beautify`.
        var js_beautify = require('./beautify.js');
        var css_beautify = require('./beautify-css.js');

        exports.html_beautify = function(html_source, options) {
            return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
        };
    } else if (typeof window !== "undefined") {
        // If we're running a web page and don't have either of the above, add our one global
        window.html_beautify = function(html_source, options) {
            return style_html(html_source, options, window.js_beautify, window.css_beautify);
        };
    } else if (typeof global !== "undefined") {
        // If we don't even have window, try global.
        global.html_beautify = function(html_source, options) {
            return style_html(html_source, options, global.js_beautify, global.css_beautify);
        };
    }

}());
});

},
'xdocker/Panel2':function(){
/** @module xdocker/Panel2 */
define([
    "dcl/dcl",
    "dcl/inherited",
    'xide/types',
    'xide/utils',
    'wcDocker/panel',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'wcDocker/types',
    'xide/widgets/_Widget'
], function (dcl,inherited,types,utils,panel,EventedMixin,registry,wcDocker,_Widget) {

    /**
     * @class module:xdocker/Panel2
     * @extends module:wcDocker/panel
     */
    return dcl([panel,_Widget.dcl,EventedMixin.dcl], {
        selected:false,
        _isVisible:function(){
            var node = $(this.containerNode);
            if(!node.length){
                return false;
            }
            if(node[0].offsetHeight === 0){
                return false;
            }else if(node.css("display") == "none"){
                return false;
            }else if((node.css("visibility") == "hidden")){
                return false;
            }
            return true;
        },
        next:function(direction){
            var frame = this.getFrame();
            if(!frame){
                return;
            }
            var pos = parseInt(frame._curTab,10);
            return frame.panelAt(pos + direction);
        },
        set:function(key,value){
            if(key==='changed'){
                if(this.$title){
                    value ? this.$title.addClass('changed') : this.$title.removeClass('changed');
                }
                return true;
            }
            if(key==='loading'){
                value ? this.startLoading() : this.finishLoading();
            }
            if(key==='height'){
                var parent = $(this.containerNode);
                parent.css('height', value+ 'px');
                this._maxSize.y = value;
                this._minSize.y = value;
                this._actualSize.y = value;
                return true;
            }
            return this.inherited(arguments);
        },
        isExpanded:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return true;
            }
            return splitter.isExpanded();
        },
        isCollapsed:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            return splitter.isCollapsed();
        },
        expand:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            splitter.expand();
            return _.invoke(this._findWidgets,'onShow');
        },
        collapse:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            splitter.collapse(splitter._pane[0].panelIndex(this) == -1 ? 1 : 0);
            return _.invoke(this._findWidgets,'onHide');
        },
        // stub
        onSaveLayout:function(e){
            this._emit('onSaveLayout',e);
        },
        onRestoreLayout:function(e){
            this._emit('onRestoreLayout',e);
        },
        // Initialize
        __init: function () {
            this.on(wcDocker.EVENT.SAVE_LAYOUT,function(data){
                data.title = this.title();
            });
            this.on(wcDocker.EVENT.RESTORE_LAYOUT,function(data){
                data.title && this.title(data.title);
            });
            var layoutClass = (this._options && this._options.layout) || 'wcLayoutTable';
            this._layout = new (this.docker().__getClass(layoutClass))(this.$container, this);
            this.$title = $('<li class="wcPanelTab">');
            this.$titleText = $('<a>' + this._title + '</a>');
            this.$title.append(this.$titleText);

            if (this._options.hasOwnProperty('title')) {
                this.title(this._options.title);
            }

            if (this._options.icon) {
                this.icon(this._options.icon);
                this._icon = this._options.icon;
            }
            if (this._options.faicon) {
                this.faicon(this._options.faicon);
            }

            if(!this.id){
                this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
            }

            utils.mixin(this,this._options.mixin);
            registry.add(this);
        },
        /**
         * Returns all dojo/dijit widgets in this node
         * @param startNode
         * @returns {_WidgetBase[]}
         * @private
         */
        _findWidgets:function(startNode){
            var result = [],
                node = startNode || this.containerNode || ( this.$container ? this.$container[0] : null);

            if(node) {
                _.each(node.children, function (child) {
                    if (child.id) {
                        var _widget = registry.byId(child.id);
                        if (_widget) {
                            result.push(_widget);
                        }
                    }
                });
            }
            this._widgets && (result = result.concat(this._widgets));
            return result;
        },

        __onShow:function(){
            _.each(this._findWidgets(), function (widget) {});
        },

        /**
         * Std API
         * @todo remove panel destruction in docker for 'removePanel'
         */
        destroy: function (removeFromDocker) {
            this.inherited(arguments);
            if(removeFromDocker!==false) {
                var _docker = this.docker();
                _docker && _docker.removePanel(this);
            }
            registry.remove(this.id);
        },
        __destroy: function () {
            _.each(this._findWidgets(),function(w){
                if(w && w.destroy && !w._destroyed){
                    w.destroy();
                }
            });
            this.inherited(arguments);
            this._destroyHandles();
            this.off();
        }
    });
});
},
'dijit/dijitb':function(){
define([
], function(){
});

},
'dstore/Cache':function(){
define([
	'dojo/_base/array',
	'dojo/when',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'./Store',
	'./Memory',
	'./QueryResults'
], function (arrayUtil, when, declare, lang, Store, Memory, QueryResults) {

	// module:
	//		dstore/Cache


	function cachingQuery(type) {
		// ensure querying creates a parallel caching store query
		return function () {
			var subCollection = this.inherited(arguments);
			var cachingCollection = this.cachingCollection || this.cachingStore;
			subCollection.cachingCollection = cachingCollection[type].apply(cachingCollection, arguments);
			subCollection.isValidFetchCache = this.canCacheQuery === true || this.canCacheQuery(type, arguments);
			return subCollection;
		};
	}

	function init (store) {
		if (!store.cachingStore) {
			store.cachingStore = new Memory();
		}

		store.cachingStore.Model = store.Model;
		store.cachingStore.idProperty = store.idProperty;
	}
	var CachePrototype = {
		cachingStore: null,
		constructor: function () {
			init(this);
		},
		canCacheQuery: function (method, args) {
			// summary:
			//		Indicates if a queried (filter, sort, etc.) collection should using caching
			return false;
		},
		isAvailableInCache: function () {
			// summary:
			//		Indicates if the collection's cachingCollection is a viable source
			//		for a fetch
			return (this.isValidFetchCache && (this.allLoaded || this.fetchRequest)) ||
					this._parent && this._parent.isAvailableInCache();
		},
		fetch: function () {
			return this._fetch(arguments);
		},
		fetchRange: function () {
			return this._fetch(arguments, true);
		},
		_fetch: function (args, isRange) {
			// if the data is available in the cache (via any parent), we use fetch from the caching store
			var cachingStore = this.cachingStore;
			var cachingCollection = this.cachingCollection || cachingStore;
			var store = this;
			var available = this.isAvailableInCache();
			if (available) {
				return new QueryResults(when(available, function () {
					// need to double check to make sure the flag hasn't been cleared
					// and we really have all data loaded
					if (store.isAvailableInCache()) {
						return isRange ?
							cachingCollection.fetchRange(args[0]) :
							cachingCollection.fetch();
					} else {
						return store.inherited(args);
					}
				}));
			}
			var results = this.fetchRequest = this.inherited(args);
			when(results, function (results) {
				var allLoaded = !isRange;
				store.fetchRequest = null;
				// store each object before calling the callback
				arrayUtil.forEach(results, function (object) {
					// store each object before calling the callback
					if (!store.isLoaded || store.isLoaded(object)) {
						cachingStore.put(object);
					} else {
						// if anything is not loaded, we can't consider them all loaded
						allLoaded = false;
					}
				});
				if (allLoaded) {
					store.allLoaded = true;
				}

				return results;
			});
			return results;
		},
		// TODO: for now, all forEach() calls delegate to fetch(), but that may be different
		// with IndexedDB, so we may need to intercept forEach as well (and hopefully not
		// double load elements.
		// isValidFetchCache: boolean
		//		This flag indicates if a previous fetch can be used as a cache for subsequent
		//		fetches (in this collection, or downstream).
		isValidFetchCache: false,
		get: function (id, directives) {
			var cachingStore = this.cachingStore;
			var masterGet = this.getInherited(arguments);
			var masterStore = this;
			// if everything is being loaded, we always wait for that to finish
			return when(this.fetchRequest, function () {
				return when(cachingStore.get(id), function (result) {
					if (result !== undefined) {
						return result;
					} else if (masterGet) {
						return when(masterGet.call(masterStore, id, directives), function (result) {
							if (result) {
								cachingStore.put(result, {id: id});
							}
							return result;
						});
					}
				});
			});
		},
		add: function (object, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				// now put result in cache (note we don't do add, because add may have
				// called put() and already added it)
				var cachedPutResult =
					cachingStore.put(object && typeof result === 'object' ? result : object, directives);
				// the result from the add should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement add
				return result || cachedPutResult;
			});
		},
		put: function (object, directives) {
			// first remove from the cache, so it is empty until we get a response from the master store
			var cachingStore = this.cachingStore;
			cachingStore.remove((directives && directives.id) || this.getIdentity(object));
			return when(this.inherited(arguments), function (result) {
				// now put result in cache
				var cachedPutResult =
					cachingStore.put(object && typeof result === 'object' ? result : object, directives);
				// the result from the put should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement put
				return result || cachedPutResult;
			});
		},
		remove: function (id, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				return when(cachingStore.remove(id, directives), function () {
					return result;
				});
			});
		},
		evict: function (id) {
			// summary:
			//		Evicts an object from the cache
			// any eviction means that we don't have everything loaded anymore
			this.allLoaded = false;
			return this.cachingStore.remove(id);
		},
		invalidate: function () {
			// summary:
			//		Invalidates this collection's cache as being a valid source of
			//		future fetches
			this.allLoaded = false;
		},
		_createSubCollection: function () {
			var subCollection = this.inherited(arguments);
			subCollection._parent = this;
			return subCollection;
		},

		sort: cachingQuery('sort'),
		filter: cachingQuery('filter'),

		_getQuerierFactory: function (type) {
			var cachingStore = this.cachingStore;
			return this.inherited(arguments) || lang.hitch(cachingStore, cachingStore._getQuerierFactory(type));
		}
	};
	var Cache = declare(null, CachePrototype);
	Cache.create = function (target, properties) {
		// create a delegate of an existing store with caching
		// functionality mixed in
		target = declare.safeMixin(lang.delegate(target), CachePrototype);
		declare.safeMixin(target, properties);
		// we need to initialize it since the constructor won't have been called
		init(target);
		return target;
	};
	return Cache;
});

},
'dojo/dom-class':function(){
define(["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

            if(!node){
                //console.error('dom class::add failed');
                return;
            }
			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
            if(!node){
                console.error('dom class remove failed');
                return;
            }
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling dojo.removeClass and dojo.addClass
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
});

},
'xide/_Popup':function(){
define([
    'dcl/dcl'
],function (dcl){

    var zIndexStart = 200;

    var Module = dcl(null,{});

    Module.nextZ = function(incr){
        zIndexStart++;
        if(incr){
            zIndexStart+=incr;
        }
        return zIndexStart;
    }

    if(typeof window !=='undefined'){
        window['__nextZ'] = Module.nextZ;
    }

    Module.setStartIndex=function(index){
        zIndexStart = index;
    }

    return Module;
});
},
'dojo/touch':function(){
define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"],
function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var hasTouch = has("touch");

	var ios4 = has("ios") < 5;
	
	var msPointer = navigator.msPointerEnabled;

	// Click generation variables
	var clicksInited, clickTracker, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, msPointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(msPointer && msPointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, msPointerType, listener);
			}
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, listener),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			}
		}
	}

	function marked(/*DOMNode*/ node){
		// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing,
		do{
			if(node.dojoClick){ return node.dojoClick; }
		}while(node = node.parentNode);
	}
	
	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy.
		
		clickTracker  = !e.target.disabled && marked(e.target); // click threshold = true, number or x/y object
		if(clickTracker){
			clickTarget = e.target;
			clickX = e.touches ? e.touches[0].pageX : e.clientX;
			clickY = e.touches ? e.touches[0].pageY : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				win.doc.addEventListener(moveType, function(e){
					clickTracker = clickTracker &&
						e.target == clickTarget &&
						Math.abs((e.touches ? e.touches[0].pageX : e.clientX) - clickX) <= clickDx &&
						Math.abs((e.touches ? e.touches[0].pageY : e.clientY) - clickY) <= clickDy;
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = e.target;
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						setTimeout(function(){
							on.emit(target, "click", {
								bubbles : true,
								cancelable : true,
								_dojo_click : true
							});
						});
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						if(!e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox")
								&& e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO"){
								 // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								 // but it is still needed for checkboxes and radio buttons, otherwise in some cases
								 // the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(hasTouch){
		if(msPointer){
			 // MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener("MSPointerDown", function(evt){
					doClicks(evt, "MSPointerMove", "MSPointerUp");
				}, true);
			});		
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
					lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});
				
					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which 
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}
				
				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
					lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", "MSPointerDown"),
		move: dualEvent("mousemove", "dojotouchmove", "MSPointerMove"),
		release: dualEvent("mouseup", "dojotouchend", "MSPointerUp"),
		cancel: dualEvent(mouse.leave, "touchcancel", hasTouch?"MSPointerCancel":null),
		over: dualEvent("mouseover", "dojotouchover", "MSPointerOver"),
		out: dualEvent("mouseout", "dojotouchout", "MSPointerOut"),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", "MSPointerOver")),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", "MSPointerOut"))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//		Also, if the dojoClick property is set to true on a DOM node, dojo/touch generates
		//		click events immediately for this node and its descendants, to avoid the
		//		delay before native browser click events, and regardless of whether evt.preventDefault()
		//		was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	 1  && (dojo.touch = touch);

	return touch;
});

},
'dojo/cache':function(){
define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'xide/container/_PaneBase':function(){
/** @module xide/container/_ContainerBase **/
define([
    "xdojo/has",
    "dcl/dcl",
    'xide/utils',
    "xide/_base/_Widget"
], function (has,dcl,utils,_Widget) {

    var Module = dcl(_Widget,{
        templateString:'<div/>',
        isContainer:true,
        declaredClass:'xide/container/_PaneBase',
        panelNode:null,
        selected:false,
        $toggleNode:null,
        $toggleButton:null,
        lazy:true,
        add:dcl.superCall(function(sup) {
            return function (mixed,options,parent,startup) {
                if(this.lazy && (mixed.allowLazy!==false && (options ? options.allowLazy!==false : true))){
                    startup = false;
                }
                return sup.apply(this, [mixed,options,parent,startup]);
            }
        }),
        addChild:function(what,mixed,startup){
            this.add(what,mixed);
            what.domNode && utils.addChild(this.containerNode,what.domNode);
            if(startup!==false && !what._started && what.startup){
                what.startup();
            }
        },
        unselect:function(){
            this.$toggleButton && this.$toggleButton.removeClass('active');
            this.$selectorNode && this.$selectorNode.removeClass('active');
            this.$containerNode && this.$containerNode.removeClass('active');
            this.selected = false;
        },
        select:function(){
            this.$toggleButton && this.$toggleButton.addClass('active');
            this.$selectorNode && this.$selectorNode.addClass('active');
            this.$containerNode && this.$containerNode.addClass('active');
            this._onShown();
            this.onSelect && this.onSelect();
        },
        destroy:function(){
            utils.destroy(this.$toggleButton[0]);
            utils.destroy(this.$containerNode[0]);
        },
        _checkWidgets:function(){},
        _onShown:function(){
            this.selected = true;
            this._startWidgets();
            this.resize();
            this.onShow();
            this.onSelect && this.onSelect();
            var thiz = this;
            setTimeout(function(){
                thiz.owner && thiz.owner.onShowTab(thiz);
            },1);
            this._emit('show',this);
        },
        _onShow:function(){
            this.selected = true;
            this.resize();
        },
        shouldResizeWidgets:function(){
            return this.selected;
        },
        _onHide:function(){
            this.selected = false;
            this.open = false;
            this.onHide();
        },
        _onHided:function(){
            this.open = false;
            this._emit('hide',{
                view:this
            });
        },
        hide:function(){
            var container = $(this.containerRoot),
                toggleNode= $(this.toggleNode);

            toggleNode.addClass('collapsed');
            toggleNode.attr('aria-expanded',false);
            container.removeClass('collapse in');
            container.addClass('collapse');
            container.attr('aria-expanded',false);
            this.open = false;
        },
        show:function(){
            var container = $(this.containerRoot),
                toggleNode = $(this.toggleNode);

            toggleNode.removeClass('collapsed');
            toggleNode.attr('aria-expanded',true);
            container.removeClass('collapse');
            container.addClass('collapse in');
            container.attr('aria-expanded',true);
            this.open = true;
        },
        getChildren:function(){
            //xmaqadd
            !this._widgets && (this._widgets = []);
            return this._widgets;
        },
        postMixInProperties:function(){
            var active = this.selected ? 'active' : '';
            this.templateString = '<div attachTo="containerNode" style="height:100%;width:100%;position:relative;" class="tab-pane ' + active + '"></div>';
        },
        __init:function(){
            var panel = this.$toggleNode;
            this.__addHandler(panel,'hidden.bs.tab','_onHided');
            this.__addHandler(panel,'hide.bs.tab','_onHide');
            this.__addHandler(panel,'shown.bs.tab','_onShown');
            this.__addHandler(panel,'show.bs.tab','_onShow');
        }
    });

    dcl.chainAfter(Module, "postMixInProperties");
    dcl.chainAfter(Module, "resize");
    dcl.chainAfter(Module, "show");

    return Module;

});
},
'xfile/views/Grid':function(){
/** @module xgrid/Base **/
define([
    "xdojo/declare",
    'xide/types',
    'xgrid/ListRenderer',
    'xfile/ThumbRenderer',
    'xgrid/TreeRenderer',
    'xgrid/Grid',
    'xgrid/MultiRenderer',
    'xfile/FileActions',
    'xfile/Statusbar',
    'xfile/views/UploadMixin',
    'xide/views/_LayoutMixin',
    'xgrid/KeyboardNavigation',
    'xgrid/Search',
    'xgrid/Selection',
    'xide/mixins/_State',
    "xide/widgets/_Widget",
    'xdojo/has!FileConsole?xfile/views/FileConsole',
    'xfile/FolderSize',
    'xide/noob'
], function (declare, types,ListRenderer, ThumbRenderer, TreeRenderer,Grid, MultiRenderer,FileActions,Statusbar,UploadMixin,_LayoutMixin,KeyboardNavigation,Search,Selection,_State,_Widget,FileConsole,FolderSize,noob) {
    
    /**
     * A grid feature
     * @class module:xgrid/GridActions
     */
    var Implementation = {

        },
        renderers = [ListRenderer,ThumbRenderer,TreeRenderer],
        multiRenderer = declare.classFactory('multiRenderer',{},renderers,MultiRenderer.Implementation);

    var GridClass = Grid.createGridClass('xfile.views.Grid', Implementation, {
            SELECTION: {
                CLASS:Selection
            },
            KEYBOARD_SELECTION: true,
            CONTEXT_MENU: types.GRID_FEATURES.CONTEXT_MENU,
            TOOLBAR: types.GRID_FEATURES.TOOLBAR,
            CLIPBOARD:types.GRID_FEATURES.CLIPBOARD,
            ACTIONS:types.GRID_FEATURES.ACTIONS,
            ITEM_ACTIONS: {
                CLASS:FileActions
            },
            STATUS_BAR: {
                CLASS:Statusbar
            },
            SPLIT:{
                CLASS:_LayoutMixin
            },
            KEYBOARD_NAVIGATION:{
                CLASS:KeyboardNavigation
            },
            SEARCH:{
                CLASS:Search
            },
            STATE:{
                CLASS:_State
            },
            UPLOAD: {
                CLASS:UploadMixin
            },
            WIDGET:{
                CLASS:_Widget
            },
            CONSOLE:{
                CLASS:FileConsole ? FileConsole : noob
            },
            SIZES:{
                CLASS:FolderSize
            }
        },
        {
            RENDERER: multiRenderer
        },
        {
            renderers: renderers,
            selectedRenderer: TreeRenderer
        }
    );
    GridClass.DEFAULT_RENDERERS = renderers;
    GridClass.DEFAULT_MULTI_RENDERER = multiRenderer;
    return GridClass;

});
},
'xbox/main':function(){
define([
    'require',
    'xide/Features'
], function (require,declare,Features) {
    require([
        'dijit/dijitb',
        'dgrid/dgrid',
        'xfile/xfile',
        'xide/xide',
        'xide/utils',
        'xide/utils/StringUtils',
        'xide/utils/ObjectUtils',
        'xlang/i18',
        'xide/Lang'
    ], function (_dijit, _dgrid,_xfile,_xide,utils,StringUtils,ObjectUtils,i18,Lang) {

        function loadMain() {
            require([
                'xide/debug',
                'xbox/XBoxCommons',
                'xbox/Managers',                 //  App Manager
                'xfile/config',                  //  XFile config,
                'xbox/Views',
                'xbox/Widgets',
                'xbox/manager/Context',
                'xbox/GUIALL',
                'dojo/_base/window',
                'dojo/domReady!'
            ], function (debug, XBoxCommons, Managers, XFileConfig, Views, Widgets, Context, GUIALL, win) {

                //pick config from global
                var xFileConfiguration = typeof(xFileConfig) !== 'undefined' ? xFileConfig : null;

                //context
                var xasContext = new Context(xFileConfiguration);

                window.sctx = xasContext;

                //main, wrap in try
                var mainFn = function () {
                    try {

                        xasContext.prepare();

                        //construct managers
                        xasContext.constructManagers();
                        //init managers
                        xasContext.initManagers();

                        //init locals!
                        //xasContext.getLocals("dijit", "common");

                        //punch it
                        xasContext.getApplication().start(xFileConfiguration);

                        utils.destroy('#loadingWrapper');


                    } catch (e) {
                        console.error('main crash : ' + e, e);
                        console.dir(e.stack);
                        //debugger;
                    }
                };
                mainFn();
            });
        }

        Lang.loadLanguage().then(function(){
            loadMain();
        });
    });

});

},
'xfile/views/FileOperationDialog':function(){
/** @module xfile/views/FileOperationDialog **/
define([
    "dcl/dcl",
    'xide/types',
    "xide/views/_Dialog"
], function (dcl, types, _Dialog) {


    var Module = dcl(_Dialog, {

        title: '',
        type: types.DIALOG_TYPE.INFO,
        size: types.DIALOG_SIZE.SIZE_SMALL,
        bodyCSS: {},
        failedText: ' Failed!',
        successText: ': Success!',
        showSpinner: true,
        spinner: '  <span class="fa-spinner fa-spin"/>',
        notificationMessage: null,
        doOk: function (dfd) {

            this.onBeforeOk && this.onBeforeOk();

            var msg = this.showMessage(),
                thiz = this;

            dfd.then(function (result) {
                thiz._onSuccess(result);
            }, function (err) {
                thiz._onError();
            });

        },
        _onSuccess: function (title, suffix, message) {

            title = title || this.title;
            message = message || this.notificationMessage;

            message && message.update({
                message: title + this.successText + (suffix ? '<br/>' + suffix : ''),
                type: 'info',
                actions: false,
                duration: 1500
            });

            this.onSuccess && this.onSuccess();
        },
        _onError: function (title, suffix, message) {

            title = title || this.title;

            message = message || this.notificationMessage;

            message && message.update({
                message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                type: 'error',
                actions: false,
                duration: 15000
            });


            this.onError && this.onError(suffix);

        },
        onOk: function () {

            var msg = this.showMessage(),
                thiz = this;
            this.doOk(this.getOkDfd());
        },
        showMessage: function (title) {

            if (this.notificationMessage) {
                return this.notificationMessage;
            }
            title = title || this.title;

            var msg = this.ctx.getNotificationManager().postMessage({
                message: title + (this.showSpinner ? this.spinner : ''),
                type: 'info',
                showCloseButton: true,
                duration: 4500
            });

            this.notificationMessage = msg;

            return msg;
        }

    });

    return Module;

});
},
'xide/views/ConsoleView':function(){
/** @module xide/views/ConsoleView **/
define([
    "dcl/dcl",
    'xide/utils',
    'xide/types',
    "xide/_base/_Widget",
    'xide/views/History',
    'xace/views/Editor',
    'xide/mixins/PersistenceMixin',
    'xide/views/_LayoutMixin'
], function (dcl, utils, types,_XWidget, History, Editor,PersistenceMixin,
             _LayoutMixin) {

    function createHandlerClass() {

        var Handler =  dcl(null, {
            owner: null,
            declaredClass:"xide/views/Console_Handler",
            onServerResponse: function (theConsole, data, addTimes) {
                /*
                 if (theConsole && data && theConsole.owner && theConsole.owner.onServerResponse) {
                 return theConsole.owner.onServerResponse(data, addTimes);
                 }
                 */
            },
            runBash: function (theConsole, value, cwd,commandNode) {
                var thiz = this,
                    ctx = thiz.ctx;
                var server = ctx.fileManager;
                var _value = server.serviceObject.base64_encode(value);
                var dfd = server.runDeferred('XShell', 'run', ['sh', _value, cwd]);
                dfd.then(function (response) {
                    if(commandNode){
                        $(commandNode).find('.consoleRunningCommand').remove();
                    }
                });
                return dfd;
            },
            runPHP: function (theConsole, value, cwd) {
                var thiz = this;
                var server = this.ctx.fileManager;
                var _value = server.serviceObject.base64_encode(value);
                server.runDeferred('XShell', 'run', ['php', _value, cwd]).then(function (response) {
                    thiz.onServerResponse(theConsole, response, false);
                });
            },
            getContext:function(){
                return utils.mixin(this,this.ctx);
            },
            print:function(what){
                var template = '<div style="margin-bottom:0px" class="widget border-top-dark">${result}</div>';
                this.printCommand('',what,template,false);
            },
            runJavascript: function (theConsole, value, context, args) {

                var _function = new Function("{" + value + "; }");
                var response = _function.call(context || this.getContext(), args);
                if (response != null) {
                    return response;
                }
                return value;
            },
            toHTML:function(msg){
            },
            onConsoleCommand: function (value,theConsole) {

                var thiz = this,
                    type = this.type;
                if (type === 'sh') {
                    var template  = '<div style="margin-bottom: 6px" class="widget border-top-dark">' +
                        '<span class="consoleRunningCommand fa-spinner fa-spin"/># ${command}<br/></div><br/>';

                    var node = this.printCommand(value,'',template,false);
                    var dstPath = null;
                    if (this.owner && this.owner.getCurrentFolder) {
                        var cwd = this.owner.getCurrentFolder();
                        if (cwd) {
                            dstPath = utils.buildPath(cwd.mount, cwd.path, false);
                        }
                    }
                    var dfd = this.runBash(theConsole, value, dstPath,node);

                    dfd.then(function(msg){

                        var isHTML = false;
                        var out = '';

                        if(msg.indexOf('<body')!=-1 || /<[a-z][\s\S]*>/i.test(msg)) {
                            isHTML = true;
                            out = msg;
                        }else{
                            out += msg.replace(/\n/g, '<br/>');
                        }

                        if(isHTML) {
                            var responseNode = $('<div class="html_response">' + out + '</div>');
                            node.append(responseNode);
                            var last = $('<div class="border-bottom-dark" >&nbsp;</div>');
                            node.parent().append(last);
                            last[0].scrollIntoViewIfNeeded();
                        }
                    });

                    return dfd;
                }

                if (type === 'php') {
                    var dstPath = null
                    if (theConsole && theConsole.isLinked()) {
                        dstPath = this.getCurrentPath();
                    }
                    return this.runPHP(theConsole, value, dstPath);
                }
                if (type === 'javascript') {
                    return this.runJavascript(theConsole, value);
                }

            },
            onConsoleEnter: function (value,theConsole) {
                return this.onConsoleCommand(value,theConsole);
            }
        });

        dcl.chainAfter(Handler,'onConsoleEnter');

        return Handler;
    }
    function createConsoleWidgetClass(){
        return dcl([_XWidget, PersistenceMixin.dcl], {
            declaredClass: "xide.views._ConsoleWidget",
            delegate: null,
            value: null,
            editNode: null,
            labelTextNode: null,
            labelNode: null,
            type: null,
            linkToggle: null,
            edit: null,
            consoleParent: null,
            isExpanded: true,
            theme: 'View/Themes/idle_fingers',
            consoleEditor: null,
            jsContext: null,
            resizeToParent:true,
            EditorClass:null,
            templateString: '<div class="" style="height: 100%;width: 100%">' +
            '<div attachTo="consoleParent" class="" style="width:inherit;height:inherit;padding: 0;margin:0;"></div></div>',
            isLinked: function () {
                if (this.linkToggle) {
                    return this.linkToggle.get('checked');
                }
                return false;
            },
            getEditor: function () {
                return this.consoleEditor;
            },
            getTextEditor:function(){
                return this.aceEditorEditor;
            },
            resize: function () {
                if (this.isExpanded) {
                    var total = $(this.domNode.parentNode).height();
                    $(this.consoleParent).css({
                        height: total +'px'
                    });
                }
                this.aceEditor && this.aceEditor.resize();
            },
            onClear:function(){
                this.delegate.$logView.html('');
            },
            maximize:function(editor){
                if(this.delegate && this.delegate.maximize){
                    return this.delegate.maximize();
                }
                return false;
            },
            expandEditor: function () {
                var thiz = this,
                    editor = thiz.getEditor(),
                    aceEditor = this.aceEditor;

                utils.resizeTo(editor, thiz.consoleParent, true, true);
            },
            createEditor: function () {
                var _thiz = this;
                var editorArgs = this.delegate.editorArgs || {};
                var editor = createEditor.apply(this,[this.consoleParent, this.value, this,utils.mixin({
                    options: this.options,
                    ctx:this.ctx,
                    resizeToParent:true
                },editorArgs),this.delegate.EditorClass]);
                this.add(editor);
                this.delegate.onCreatedEditor && this.delegate.onCreatedEditor(editor);
                editor._on('change',function(e){
                    _thiz._emit('change',e);
                });
                return editor;
            },
            onAddEditorActions:function(evt){
                evt.owner = this.aceEditor;
                this.delegate.onAddEditorActions(evt);
            },
            createWidgets: function () {
                if(this.aceEditor){
                    return;
                }
                var self = this;
                var aceEditor = this.createEditor(this.ctx);
                this.aceEditor = aceEditor;
                aceEditor._on('onAddActions',this.onAddEditorActions,self);
                aceEditor.startup();
                this.add(aceEditor, null, false);
                var editor = aceEditor.getEditor();
                if(this.delegate && this.delegate.maximize){
                    aceEditor.maximize = function() {
                        return this.delegate.maximize();
                    };
                }
                this.aceEditorEditor = aceEditor;
                this.consoleEditor = editor;
                //editor.renderer.$maxLines = 1;
                editor.renderer.setShowGutter(false);
                editor.renderer.setHighlightGutterLine(false);
                editor.$mouseHandler.$focusWaitTimout = 0;
                editor.setOptions({
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true
                });

                aceEditor.setMode(this.delegate.type);
                aceEditor.set('value', this.value);
                aceEditor.runAction(this.theme);
                aceEditor.set('value', this.value);

                $(this.expandButton).click(function (e) {
                    return self.expandEditor();
                });
                $(this.clearButton).on('click', function () {
                    if (self.delegate && self.delegate.onButton) {
                        self.delegate.onButton();
                    }
                });
                this.expandEditor();
                var session = aceEditor.editorSession;
                editor.commands.bindKeys({
                    "Ctrl-Return": function (cmdLine) {
                        if (self.isExpanded) {
                            editor.focus();

                            var selectedText = editor.getSelectedText();
                            var value = selectedText || editor.getValue();
                            self.onEnter(value);

                        } else {
                            //editor.insert("\n");
                            editor.focus();
                            self.onEnter(editor.getValue());
                        }

                    },
                    "Shift-Return": function (cmdLine) {
                        self.onClear();
                    },
                    "Esc|Shift-Esc": function (cmdLine) {
                        editor.focus();
                    },
                    "Return": function (cmdLine) {
                        var command = editor.getValue().split(/\s+/);
                        if (self.isExpanded) {
                            editor.insert("\n");
                        } else {
                            editor.focus();
                            self.onEnter(editor.getValue());
                        }
                    }
                });
                editor.commands.removeCommands(["find", "gotoline", "findall", "replace", "replaceall"]);
            },
            getValue: function () {
                return this.consoleEditor.getValue();
            },
            startup: function () {
                this.history = new History();
                this.createWidgets();
            },
            onEnter: function (val) {
                this.delegate.onConsoleEnter(val, this.isExpanded == false,this);
                this.history.push(val);
            }
        });
    }
    function createConsoleClass(){
        var _Console = dcl([_XWidget,_LayoutMixin.dcl,createHandlerClass()],{
            declaredClass:'xide.views.ConsoleView',
            templateString:'<div class="logView" style="height: 100%;overflow: auto" attachTo="logView" />',
            printTemplate:'<div style="margin-bottom: 6px" class="widget border-top-dark"># ${time} - ${command}<br/>\t ${result}</div><br/>',
            defaultPanelOptions:{
                w: '100%',
                title:false
            },
            defaultPanelType:'DefaultFixed',
            resizeToParent:true,
            onAddEditorActions:function(evt){
                var actions = evt.actions,
                    owner  = evt.owner;
                actions.remove(_.find(actions,{
                    command:'File/Save'
                }));

                actions.remove(_.find(actions,{
                    command:"File/Reload"
                }));
                var mixin = {
                    addPermission:true
                }
                actions.push(owner.createAction({
                    label: 'Send',
                    command: 'Console/Send',
                    icon: 'fa-paper-plane',
                    group: 'Console',
                    tab:'Home',
                    mixin:mixin
                }));
                actions.push(owner.createAction({
                    label: 'Clear Ouput',
                    command: 'Console/Clear',
                    icon: 'fa-remove',
                    group: 'Console',
                    tab:'Home',
                    mixin:mixin
                }));
                actions.push(owner.createAction({
                    label: 'Fullscreen',
                    command: types.ACTION.FULLSCREEN,
                    icon: types.ACTION_ICON.MAXIMIZE,
                    keycombo: 'ctrl f11',
                    group: 'View',
                    mixin:mixin
                }));

            },
            getConsoleClass:function(){ return createConsoleWidgetClass(); },
            createConsole:function(where){
                var _console = utils.addWidget(this.getConsoleClass(), {
                    style: 'width:inherit',
                    delegate: this,
                    type: this.type,
                    value: this.value,
                    ctx:this.ctx
                }, this, where, false);
                this.add(_console);
                return _console;
            },
            createWidgets:function(bottom,top){
                var _console = this.createConsole(bottom);
                _console.startup();
                this.console = _console;
            },
            getConsole:function(){
                return this.console;
            },

            getConsoleEditor:function(){
                return this.getConsole().getTextEditor();
            },

            startup:function(){
                this.createWidgets(this.getBottomPanel('Console'),this.getTop());
            },

            maxEntries:100,
            toDom:function(markup){
                var template = document.createElement('template');
                template.innerHTML = markup;
                return template.content.firstChild;
            },
            printCommand:function(command,result,template,addTime){
                var where = this.logView;
                var overlap = where.children.length - this.maxEntries;
                var self = this;
                function remove() {

                    if (overlap > 30) {
                        while (overlap > 0) {
                            where.children && where.children[0] && where.removeChild(where.children[0]);
                            overlap--;
                        }
                        overlap = where.children.length - self.maxEntries;
                    }
                }
                //overlap > 30 && window.requestAnimationFrame(remove);
                overlap && remove();
                var time = addTime!==false ? moment().format("HH:mm:ss:SSS") : "";
                var content = utils.substituteString(template || this.printTemplate,{
                    command:command,
                    result:result,
                    time:time
                });
                var node = [this.toDom(content)];
                where.appendChild(node[0]);
                delete this.__lastNode;
                this.__lastNode = node[0];
                function scroll(){
                    this.__lastNode.scrollIntoViewIfNeeded();
                }
                var _scroll = this.debounce('scroll',scroll.bind(this),800,{
                    maxWait:1000
                });
                return node;
            },
            onConsoleEnter: dcl.superCall(function(sup){
                return function(command){
                    //grab the result from the handler
                    var res = sup.call(this, command);
                    if(!res || !res.then){
                        this.printCommand(command,res);
                    }
                };
            })
        });

        return _Console;
    }

    /***
     * Default editor persistence for peferences in cookies!
     **/
    Editor = dcl([Editor, PersistenceMixin.dcl], {
        declaredClass:'xace.views.Editor',
        defaultPrefenceTheme: 'idle_fingers',
        defaultPrefenceFontSize: 14,
        getDefaultPreferences: function () {
            return {theme: this.defaultPrefenceTheme, fontSize: this.defaultPrefenceFontSize};
        },
        runAction:function(action){
            if(action.command==='Console/Clear'){
                return this.delegate.onClear();
            }
            if(this.delegate.delegate && this.delegate.delegate.runAction){
                var _result = this.delegate.delegate.runAction(action);
                if(_result){
                    return _result;
                }
            }
            if(action.command==='Console/Send'){
                var value = this.get('value');
                return this.delegate.delegate.onConsoleEnter(value);
            }
            return this.inherited(arguments);
        },
        __onAfterAction: function (action) {
            this.savePreferences({
                theme: this.get('theme').replace('ace/theme/', ''),
                fontSize: this.getEditor().getFontSize()
            });
            return this.inherited(arguments);
        },
        /**
         * Override id for pref store:
         * know factors:
         *
         * - IDE theme
         * - per bean description and context
         * - by container class string
         * - app / plugins | product / package or whatever this got into
         * -
         **/
        toPreferenceId: function (prefix) {
            prefix = prefix || ($('body').hasClass('xTheme-transparent') ? 'xTheme-transparent' : 'xTheme-white' );
            var res = (prefix || this.cookiePrefix || '') + '_xace';
            return res;
        },
        getDefaultOptions: function () {
            //take our defaults, then mix with prefs from store,
            var _super = this.inherited(arguments),
                _prefs = this.loadPreferences(null);
            (_prefs && utils.mixin(_super, _prefs) ||
                //else store defaults
            this.savePreferences(this.getDefaultPreferences()));
            return _super;
        }
    });

    function createEditor(root, value, owner, mixin,EditorMixinClass) {
        var item = {
            filePath: '',
            fileName: ''
        };
        var title = "No Title";
        value = value || '...';
        var args = {
            _permissions: [

            ],
            item: item,
            value: value,
            style: 'padding:0px;top:0 !important',
            iconClass: 'fa-code',
            options: utils.mixin(mixin, {
                filePath: item.path,
                fileName: item.name
            }),
            storeDelegate: {},
            title: title
        };
        utils.mixin(args, mixin);
        var _editorClass = Editor;
        if(EditorMixinClass){
            _editorClass = EditorMixinClass;
        }
        var editor = utils.addWidget(_editorClass, args, owner, root, false, null, null, false);
        editor.resize();
        return editor;
    }

    var Module  = createConsoleClass();
    Module.Editor = Editor;
    Module.HandlerClass = createHandlerClass();
    Module.ConsoleWidget = createConsoleWidgetClass();
    return Module;

});
},
'dojo/_base/xhr':function(){
define([
	"./kernel",
	"./sniff",
	"require",
	"../io-query",
	/*===== "./declare", =====*/
	"../dom",
	"../dom-form",
	"./Deferred",
	"./config",
	"./json",
	"./lang",
	"./array",
	"../on",
	"../aspect",
	"../request/watch",
	"../request/xhr",
	"../request/util"
], function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = [{}];

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			miArgs.push(formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			miArgs.push(args.content);
		}
		if(args.preventCache){
			miArgs.push({"dojo.preventCache": new Date().valueOf()});
		}
		ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){
			if( false ) {
				var debugData = rDfd.response.getHeader('xapp_debug_data');
				if (debugData && typeof xappServerDebug !== 'undefined') {
					xappServerDebug(debugData, rDfd, dfd);
				}
			}
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({
			url:url,
			sync:true,
			headers:{
				"X-Requested-With": null
			},
			load:function(text){
			result = text;
		}});
		return result;
	};
    dojo.getText = function(url){
        return dojo.xhrGet({
            url: url,
            sync: false,
            headers: {
                "X-Requested-With": null
            }
        });
    };

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
        getText: dojo.getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
});

},
'xide/data/Memory':function(){
define([
    "dojo/_base/declare",
	'dstore/Memory',
    'xide/data/_Base'
], function (declare, Memory,_Base) {
    return declare('xide.data.Memory',[Memory, _Base], {});
});

},
'dcl/dcl':function(){
(function(factory){
	if(typeof define != "undefined"){
		define(["./mini"], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory(require("./mini"));
	}else{
		dcl = factory(dcl);
	}
})(function(dcl){
	"use strict";

	function nop(){}

	var Advice = dcl(dcl.Super, {
		//declaredClass: "dcl.Advice",
		constructor: function(){
			this.before = this.around.before;
			this.after  = this.around.after;
			this.around = this.around.around;
		}
	});
	function advise(advice){ return dcl._makeSuper(advice, Advice); }

	function makeAOPStub(before, after, around){
		var beforeChain = before || nop,
			afterChain  = after  || nop,
			aroundChain = around || nop,
			stub = function(){
				var r, thrown;
				// running the before chain
				beforeChain.apply(this, arguments);
				// running the around chain
				try{
					r = aroundChain.apply(this, arguments);
				}catch(e){
					r = e;
					thrown = true;
				}
				// running the after chain
				afterChain.call(this, arguments, r);
				if(thrown){
					throw r;
				}
				return r;
			};
		stub.advices = {before: before, after: after, around: around};
		return stub;
	}

	function chain(id){
		return function(ctor, name){
			var meta = ctor._meta, rule;
			if(meta){
				rule = +meta.weaver[name] || 0;
				if(rule && rule != id){
					dcl._error("set chaining", name, ctor, id, rule);
				}
				meta.weaver[name] = id;
			}
		};
	}

	dcl.mix(dcl, {
		// public API
		Advice: Advice,
		advise: advise,
		// expose helper methods
		before: function(f){ return dcl.advise({before: f}); },
		after:  function(f){ return dcl.advise({after:  f}); },
		around: dcl.superCall,
		// chains
		chainBefore: chain(1),
		chainAfter:  chain(2),
		isInstanceOf: function(o, ctor){
			if(o instanceof ctor){
				return true;
			}
			var t = o.constructor._meta, i;
			if(t){
				for(t = t.bases, i = t.length - 1; i >= 0; --i){
					if(t[i] === ctor){
						return true;
					}
				}
			}
			return false;
		},
		// protected API starts with _ (don't use it!)
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around"),
				b = dcl._extractChain(bases, name, "before").reverse(),
				a = dcl._extractChain(bases, name, "after");
			f = id ? dcl._stubChainSuper(f, id == 1 ? function(f){ return dcl._stubChain(f.reverse()); } : dcl._stubChain, name) : dcl._stubSuper(f, name);
			return !b.length && !a.length ? f || function(){} : makeAOPStub(dcl._stubChain(b), dcl._stubChain(a), f);
		}
	});

	return dcl;
});

},
'xide/utils/WidgetUtils':function(){
define([
    'xide/utils',
    'xide/types',
    'xide/registry'
], function (utils,types,registry) {
    "use strict";
    utils.getParentWidget=function(start,declaredClass,max){
        //sanitize start
        start = start.containerNode || start.domNode || start;
        var i = 0,
            element = start,
            widget = null,
            _max = max || 10,
            _lastWidget = null;

        while (i < _max && !widget) {
            if (element) {
                element = element.parentNode;
                var _widgetById = registry.byId(element.id);
                var _widget = _widgetById || registry.getEnclosingWidget(element);
                _widget && (_lastWidget = _widget);
                if(_widget && declaredClass &&  _widget.declaredClass && _widget.declaredClass.indexOf(declaredClass)!=-1){
                    widget = _widget;
                }
            }
            i++;
        }
        return widget;
    };
    /**
     *
     * @param type
     * @returns {string}
     */
    utils.getWidgetType = function (type) {
        var res = "";
        var root = 'xide.widgets.';
        if (type == types.ECIType.ENUMERATION) {
            res = root  + "Select";
        }
        if (type == types.ECIType.STRING) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.ICON) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.REFERENCE) {
            res = root  + "Button";
        }

        if (type == types.ECIType.EXPRESSION) {
            res = root  + "Expression";
        }

        if (type == types.ECIType.EXPRESSION_EDITOR) {
            res = root  + "ExpressionEditor";
        }

        if (type == types.ECIType.ARGUMENT) {
            res = root  + "ArgumentsWidget";
        }

        if (type == types.ECIType.WIDGET_REFERENCE) {
            res = root  + "WidgetReference";
        }

        if (type == types.ECIType.BLOCK_REFERENCE) {
            res =root  +  "BlockPickerWidget";
        }

        if (type == types.ECIType.BLOCK_SETTINGS) {
            res = root  + "BlockSettingsWidget";
        }

        if (type == types.ECIType.DOM_PROPERTIES) {
            res = root  + "DomStyleProperties";
        }

        if (type == types.ECIType.FILE_EDITOR) {
            res = root  + "FileEditor";
        }

        return res;
    };
    return utils;
});
},
'dcl/mini':function(){
(function(factory){
	if(typeof define != "undefined"){
		define([], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		dcl = factory();
	}
})(function(){

	"use strict";

	var counter = 0, cname = "constructor", pname = "prototype", empty = {}, mix;

	var registry = {};

	function dcl(superClass, props){
		var bases = [0], proto, base, ctor, meta, connectionMap,
			output, vector, superClasses, i, j = 0, n;

		if(superClass){
			if(superClass instanceof Array){
				// mixins: C3 MRO
				connectionMap = {};
				superClasses = superClass.slice(0).reverse();
				for(i = superClasses.length - 1; i >= 0; --i){
					base = superClasses[i];
					// pre-process a base
					// 1) add a unique id
					base._uniqueId = base._uniqueId || counter++;
					// 2) build a connection map and the base list
					if((proto = base._meta)){   // intentional assignment
						for(vector = proto.bases, j = vector.length - 1; j > 0; --j){
							n = vector[j]._uniqueId;
							connectionMap[n] = (connectionMap[n] || 0) + 1;
						}
						superClasses[i] = vector.slice(0);
					}else{
						superClasses[i] = [base];
					}
				}
				// build output
				output = {};
				c: while(superClasses.length){
					for(i = 0; i < superClasses.length; ++i){
						vector = superClasses[i];
						base = vector[0];
						n = base._uniqueId;
						if(!connectionMap[n]){
							if(!output[n]){
								bases.push(base);
								output[n] = 1;
							}
							vector.shift();
							if(vector.length){
								--connectionMap[vector[0]._uniqueId];
							}else{
								superClasses.splice(i, 1);
							}
							continue c;
						}
					}
					// error
					dcl._error("cycle", props, superClasses);
				}
				// calculate a base class
				superClass = superClass[0];
				j = bases.length - ((meta = superClass._meta) && superClass === bases[bases.length - (j = meta.bases.length)] ? j : 1) - 1; // intentional assignments
			}else{
				// 1) add a unique id
				superClass._uniqueId = superClass._uniqueId || counter++;
				// 2) single inheritance
				bases = bases.concat((meta = superClass._meta) ? meta.bases : superClass);   // intentional assignment
			}
		}
		// create a base class
		proto = superClass ? dcl.delegate(superClass[pname]) : {};
		// the next line assumes that constructor is actually named "constructor", should be changed if desired
		vector = superClass && (meta = superClass._meta) ? dcl.delegate(meta.weaver) : {constructor: 2};   // intentional assignment

		// create prototype: mix in mixins and props
		for(; j > 0; --j){
			base = bases[j];
			meta = base._meta;
			dcl.mix(proto, meta && meta.ownProps || base[pname]);
			if(meta){
				for(n in (superClasses = meta.weaver)){    // intentional assignment
					vector[n] = (+vector[n] || 0) | superClasses[n];
				}
			}
		}
		for(n in props){
			if(isSuper(meta = props[n])){  // intentional assignment
				vector[n] = +vector[n] || 0;
			}else{
				proto[n] = meta;
			}
		}

		// create stubs with fake constructor
		//
		meta = {bases: bases, ownProps: props, weaver: vector, chains: {}};
		// meta information is coded like that:
		// bases: an array of super classes (bases) and mixins
		// ownProps: a bag of immediate prototype properties for the constructor
		// weaver: a bag of chain instructions (before is 1, after is 2)
		// chains: a bag of chains (ordered arrays)

		bases[0] = {_meta: meta, prototype: proto};
		buildStubs(meta, proto);
		ctor = proto[cname];

		// put in place all decorations and return a constructor
		ctor._meta  = meta;
		ctor[pname] = proto;
		//proto.constructor = ctor; // uncomment if constructor is not named "constructor"
		bases[0] = ctor;

		// each constructor may have two properties on it:
		// _meta: a meta information object as above
		// _uniqueId: a unique number, which is used to id the constructor

		var result = dcl._postprocess(ctor);    // fully prepared constructor

		if(props.declaredClass && !registry[props.declaredClass]){
			registry[props.declaredClass] = result;
		}

		return result;

	}

	// decorators

	function Super(f){ this.around = f; }
	function isSuper(f){ return f && f.spr instanceof Super; }

	// utilities

	function allKeys(o){
		var keys = [];
		for(var name in o){
			keys.push(name);
		}
		return keys;
	}

	(mix = function(a, b){
		for(var n in b){
			a[n] = b[n];
		}
	})(dcl, {
		// piblic API
		mix: mix,
		delegate: function(o){
			return Object.create(o);
		},
		allKeys: allKeys,
		Super: Super,
		superCall: function superCall(f){ return dcl._makeSuper(f); },

		// protected API starts with _ (don't use it!)

		// make a Super marker
		_makeSuper: function makeSuper(advice, S){ var f = function(){}; f.spr = new (S || Super)(advice); return f; },

		// post-processor for a constructor, can be used to add more functionality
		// or augment its behavior
		_postprocess: function(ctor){ return ctor; },   // identity, used to hang on advices

		// error function, augmented by debug.js
		_error: function(msg){ throw Error("dcl: " + msg); },

		// supercall instantiation, augmented by debug.js
		_instantiate: function(advice, previous, node){ var t = advice.spr.around(previous); t.ctr = advice.ctr; return t; },

		// the "buildStubs()" helpers, can be overwritten
		_extractChain: function(bases, name, advice){
			var i = bases.length - 1, chain = [], base, f, around = advice == "around";
			for(; base = bases[i]; --i){
				// next line contains 5 intentional assignments
				if((f = base._meta) ? (f = f.ownProps).hasOwnProperty(name) && (isSuper(f = f[name]) ? (around ? f.spr.around : (f = f.spr[advice])) : around) : around && (f = name == cname ? base : base[pname][name]) && f !== empty[name]){
					if(typeof f == "function"){
						f.ctr = base;
						chain.push(f);
					}else{
						dcl._error("wrong super", base, name);
					}
				}
			}
			return chain;
		},
		_stubChain: function(chain){ // this is "after" chain
			var l = chain.length, f;
			return !l ? 0 : l == 1 ?
				(f = chain[0], function(){
					f.apply(this, arguments);
				}) :
				function(){
					for(var i = 0; i < l; ++i){
						chain[i].apply(this, arguments);
					}
				};
		},
		_stubSuper: function(chain, name){
			var i = 0, f, p = empty[name];
			for(; f = chain[i]; ++i){
				p = isSuper(f) ? (chain[i] = dcl._instantiate(f, p, name)) : f;
			}
			return name != cname ? p : function(){ p.apply(this, arguments); };
		},
		_stubChainSuper: function(chain, stub, name){
			var i = 0, f, diff, pi = 0;
			for(; f = chain[i]; ++i){
				if(isSuper(f)){
					diff = i - pi;
					chain[i] = dcl._instantiate(f, !diff ? 0 : diff == 1 ? chain[pi] : stub(chain.slice(pi, i)), name);
					pi = i;
				}
			}
			diff = i - pi;
			return !diff ? 0 : diff == 1 && name != cname ? chain[pi] : stub(pi ? chain.slice(pi) : chain);
		},
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around");
			return (id ? dcl._stubChainSuper(f, dcl._stubChain, name) : dcl._stubSuper(f, name)) || function(){};
		}
	});

	function buildStubs(meta, proto){
		var weaver = meta.weaver, bases = meta.bases, chains = meta.chains;
		for(var name in weaver){
			proto[name] = dcl._stub(weaver[name], bases, name, chains);
		}
	}

	dcl.getObject=function(classString){
		return registry[classString];
	};

	return dcl;
});

},
'xide/utils/HTMLUtils':function(){
/** @module xide/utils/HTMLUtils **/
define([
    'xide/utils',
    'xide/types',
    'dcl/dcl',
    'xdojo/declare',
    "dojo/dom-construct",
    'dojo/has',
    'dojo/dom-class',
    "dojo/_base/window",
    'xide/lodash',
    'xide/$'
], function (utils, types, dcl,declare, domConstruct, has, domClass, win, _,$) {
    /**
     * @TODO: remove
     * #Maqetta back compat tool
     * @returns {*}
     */
    utils.getDoc = function () {
        return win.doc;
    };
    /**
     * @TODO: remove
     * Save empty a node or a widget
     * @param mixed {HTMLElement|xide/_base/_Widget || dijit/_WidgetBase}
     * @returns void
     */
    utils.empty = function (mixed) {
        //seems widget
        if (mixed.getChildren && mixed.removeChild) {
            var children = mixed.getChildren();
            _.each(children, function (widget) {
                mixed.removeChild(widget);
            });
        }
        //now remove anything non-widget
        var _el = mixed.containerNode || mixed.domNode || _.isElement(mixed) ? mixed : null;
        if (_el) {
            domConstruct.empty(_el);
        }
    };
    /**
     *
     * @TODO: remove, not needed since 3.0
     * @param startNode
     * @param mustHaveClass
     * @returns {*}
     */
    utils.findEmptyNode = function (startNode, mustHaveClass) {
        if (!startNode || startNode.children == null || startNode.children.length == null) {
            return null;
        }
        var children = startNode.children;
        if (mustHaveClass !== null) {
            children = utils.find(mustHaveClass, startNode, false);
        }
        for (var i in children) {
            var child = children[i];
            if (child.innerHTML === '') {
                return child;
            }
        }
        return null;
    };
    /**
     *
     * @param tag {string}
     * @param options {object}
     * @param where {HTMLElement}
     * @memberOf module:xide/utils
     * @returns {HTMLElement}
     */
    utils.create = function (tag, options, where) {
        var doc = win.doc;
        if (where) {
            doc = where.ownerDocument;
        }

        if (typeof tag == "string") {
            tag = doc.createElement(tag);
        }
        options && $(tag).attr(options);
        where && $(where).append(tag);
        return tag;
    };

    /**
     * Returns true when a node is child of another node
     * @param parent {HTMLElement}
     * @param child {HTMLElement}
     * @memberOf module:xide/utils
     * @returns {boolean}
     */
    utils.isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (node !== null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    /**
     * Finds and returns a widgets instance in a stack-container by name
     * @param name
     * @param container
     * @memberOf module:xide/utils
     * @returns {module:xide/layout/_Container}
     */
    utils.hasChild = function (name, container) {
        if (!!name || !container && container.getChildren) {
            return _.find(container.getChildren(), {
                title: name
            });
        }
    };
    /**
     *
     * @param proto {Module} a module
     * @param args {Object} the constructor arguments
     * @param node {HTMLElement|null}
     * @param extraBaseClasses {Module[]} additional base classes
     * @param classExtension
     * @memberOf module:xide/utils
     * @returns {Object}
     */
    utils.createInstanceSync = function (proto, args, node, extraBaseClasses, classExtension) {
        //extra bases and/or class extension, create a dynamic class and fill extra-bases
        if (extraBaseClasses || classExtension) {
            extraBaseClasses = extraBaseClasses || [];

            if (classExtension) {
                extraBaseClasses.push(declare(proto, classExtension));
            }
        }
        if (extraBaseClasses) {
            extraBaseClasses = _.isArray(extraBaseClasses) ? extraBaseClasses : [extraBaseClasses];
            extraBaseClasses.push(proto);
            extraBaseClasses.reverse();
            proto = proto.extend ? declare(extraBaseClasses, {}) : dcl(extraBaseClasses,{});
        }
        return new proto(args || {}, node || win.doc.createElement('div'));

    };
    /***
     * addWidget
     * @param widgetProto {module:xide/_base/_Widget|module:xide/widgets/_Widget}
     * @param ctrArgsIn {object|null}
     * @param delegate {*|null}
     * @param parent {HTMLElement|module:xide/_base/_Widget|module:xide/widgets/_Widget}
     * @param startup {boolean}
     * @param cssClass {string} CSS class to be added
     * @param baseClasses {null|object[]}
     * @param select {boolean} call select (ie: a tab in a container)
     * @param classExtension {object} one more mixin
     * @memberOf module:xide/utils
     * @returns {module:xide/_base/_Widget|module:xide/widgets/_Widget|null}
     */
    utils.addWidget = function (widgetProto, ctrArgsIn, delegate, parent, startup, cssClass, baseClasses, select, classExtension) {
        var ctrArgs = {
            delegate: delegate
        };
        ctrArgsIn = ctrArgsIn || {};
        utils.mixin(ctrArgs, ctrArgsIn);

        //deal with class name
        if (_.isString(widgetProto)) {
            var _widgetProto = utils.getObject(widgetProto);
            if (_widgetProto) {
                widgetProto = _widgetProto;
            }
        }

        parent = _.isString(parent) ? domConstruct.create(parent) : parent == null ? win.doc.createElement('div') : parent;
        var isDirect = ctrArgsIn.attachDirect ? ctrArgsIn.attachDirect : (widgetProto && widgetProto.prototype ? widgetProto.prototype.attachDirect : false);
        ctrArgs._parent = parent;

        var _target = utils.getNode(parent);

        //@TODO: remove
        if (parent && parent.finishLoading) {
            parent.finishLoading();
        }
        //@TODO: remove
        if (ctrArgs.attachChild && parent.addChild) {
            delete ctrArgs.attachChild;
            return parent.addChild(widgetProto, ctrArgs, startup);
        }


        //@TODO: replace
        if (parent.addWidget && ctrArgs.ignoreAddChild !== true) {
            return parent.addWidget(widgetProto, ctrArgsIn, delegate, parent, startup, cssClass, baseClasses, select, classExtension);
        }

        var widget = utils.createInstanceSync(widgetProto, ctrArgs, isDirect ? _target : null, baseClasses, classExtension);// new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        if (!widget) {
            console.error('widget creation failed! ', arguments);
            return null;
        }

        if (parent) {
            if (!isDirect) {
                utils.addChild(parent, widget, startup, select);
            } else {
                startup && widget.startup();
            }
        } else {
            return widget;
        }

        if (cssClass) {
            domClass.add(widget.domNode, cssClass);
        }

        if (parent.resize || parent.startup) {
            widget._parent = parent;
        }

        //@TODO: remove
        widget.utils = utils;
        widget.types = types;
        return widget;
    };

    /***
     * addChild is a Dojo abstraction. It tries to call addChild on the parent when the client is fitted for this case.
     * @param parent {HTMLElement|module:xide/widgets/_Widget}
     * @param child {HTMLElement|module:xide/widgets/_Widget}
     * @param startup {boolean} call startup() on the child
     * @param select {boolean} select the widget if parent has such method
     * @memberOf module:xide/utils
     */
    utils.addChild = function (parent, child, startup, select) {
        if (!parent || !child) {
            console.error('error! parent or child is invalid!');
            return;
        }
        try {
            var parentIsWidget = typeof parent.addChild === 'function';
            var _parentNode = parentIsWidget ? parent : utils.getNode(parent);
            var _childNode = parentIsWidget ? child : child.domNode || child;
            if (_parentNode && _childNode) {
                if (!parent.addChild) {
                    if (_childNode.nodeType) {
                        _parentNode.appendChild(_childNode);
                        if (startup === true && child.startup) {
                            child.startup();
                        }
                    } else {
                        logError('child is not html');
                    }
                } else {
                    var insertIndex = -1;
                    if (parent.getChildren) {
                        insertIndex = parent.getChildren().length;
                    }
                    try {
                        //@TODO: this has wrong signature in beta3
                        parent.addChild(_childNode, insertIndex, select !== null ? select : startup);
                    } catch (e) {
                        logError(e, 'add child failed for some reason!' + e);
                    }
                }
            } else if ( false ) {
                console.error("utils.addChild : invalid parameters :: parent or child domNode is null");
            }
        } catch (e) {
            logError(e, 'addWidget : crashed : ');
        }
    };
    /***
     *
     * 'templatify' creates a sort of dynamic widget which behaves just like a normal templated widget. Its
     * there for simple widget creation which goes beyond the string substitute alternative. This can
     * avoid also to carry around too many widget modules in your app.
     *
     * @param baseClass {xide/widgets/TemplatedWidgetBase|dijit/_TemplatedMixin} a base class to use, this must be
     * anything which is a dijit/_TemplatedMixin.
     *
     * @param templateString {string} template string as usual, can have all tags like  data-dojo-attach-point and so
     * forth
     *
     * @param parentNode {HTMLNode} the node where the 'dynamic widget' is being added to.

     * @param templateArguments {Object} some parameters mixed into the widget. In the example below you might use
     * {iconClass:'fa-play'} to insert the icon class 'fa-play' into the widget's template
     *
     * @param baseClasses {Object[]=} optional, a number of additional base classes you want make the 'dynamic widget'
     * to be inherited from.
     *
     * @param startup {boolean} call startup on the widget
     *
     * @returns {Widget} returns the templated widget
     *
     *
     * @example var _tpl =  "<div>" +
     "<div class='' data-dojo-type='dijit.form.DropDownButton' data-dojo-props=\"iconClass:'${!iconClass}'\" +
     "data-dojo-attach-point='wButton'>" +
     "<span></span>" +
     "<div data-dojo-attach-point='menu' data-dojo-type='dijit.Menu' style='display: none;'></div>" +
     "</div></div>";

     var widget  = this.templatify(xide/widgets/TemplatedWidgetBase,_tpl, parent , {
            iconClass:'fa-play'
        },[xide/mixins/ReloadMixin]);

     * @memberOf module:xide/utils
     * @extends xide/utils

     */
    utils.templatify = function (baseClass, templateString, parentNode, templateArguments, baseClasses, startup) {
        var widgetClassIn = baseClass || 'xide/widgets/TemplatedWidgetBase',
            widgetProto = null;
        if (baseClasses) {
            widgetProto = declare([baseClass].concat(baseClasses));
        } else {
            widgetProto = utils.getObject(widgetClassIn);
        }
        if (!widgetProto) {
            return null;
        }
        var ctrArgs = {
            templateString: templateString
        };
        utils.mixin(ctrArgs, templateArguments);
        var widget = new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        utils.addChild(parentNode, widget, startup);
        return widget;
    };
    /**
     * XIDE specific
     * @param prop
     * @param owner
     * @memberOf module:xide/utils
     * @private
     */
    utils._clearProperty = function (prop, owner) {
        var _key = null;
        if (owner) {
            _key = utils.getObjectKeyByValue(owner, prop);
        }
        if (_key) {
            owner[_key] = null;
        }
    };
    /**
     * XIDE specific destroy
     * @param view
     * @param callDestroy
     * @param owner
     * @memberOf module:xide/utils
     * @private
     */
    utils._destroyWidget = function (view, callDestroy, owner) {
        try {
            _.isString(view) && (view = $(view)[0]);
            if (view) {
                if (view.parentContainer &&
                    view.parentContainer.removeChild &&
                    view.domNode) {
                    if (view.destroy && callDestroy !== false) {
                        try {
                            view.destroy();
                        } catch (e) {
                            console.error('error destroying view');
                        }
                    }
                    view.parentContainer.removeChild(view);
                    if (owner) {
                        utils._clearProperty(view, owner);
                    }
                    return;
                }
                view.destroyRecursive && view.destroyRecursive();
                view.destroy && view._destroyed !== true && view.destroy();
                view._destroyed = true;
                if (view.domNode || view["domNode"]) {
                    if (view.domNode) {
                        domConstruct.destroy(view.domNode);
                    }
                } else {
                    var doc = view.ownerDocument;
                    // cannot use _destroyContainer.ownerDocument since this can throw an exception on IE
                    if (doc) {
                        domConstruct.destroy(view);
                    }
                }
                utils._clearProperty(view, owner);
            }

        } catch (e) {
            logError(e, 'error in destroying widget ' + e);
        }
    };
    /**
     * Destroys a widget or HTMLElement safely. When an owner
     * is specified, 'widget' will be nulled in owner
     * @param widget {Widget|HTMLElement|object}
     * @param callDestroy instruct to call 'destroy'
     * @memberOf module:xide/utils
     * @param owner {Object=}
     */
    utils.destroy = function (widget, callDestroy, owner) {
        if (widget) {
            if (_.isArray(widget)) {
                for (var i = 0; i < widget.length; i++) {
                    var obj1 = widget[i];
                    var _key = null;
                    if (owner) {
                        _key = utils.getObjectKeyByValue(owner, obj1);
                    }
                    utils._destroyWidget(obj1, callDestroy);
                    if (_key) {
                        owner[_key] = null;
                    }
                }
            } else {
                utils._destroyWidget(widget, callDestroy, owner);
            }
        }
    };

    /**
     * Get a widet's default append target, dojo specfic
     * @param target
     * @memberOf module:xide/utils
     * @returns {*}
     */
    utils.getNode = function (target) {
        if (target) {
            return target.containerNode || target.domNode || target;
        }
        return target;
    };

    /**
     * Return the total height for widgets
     * @param widgets {module:xide/widgets/_Widget|module:xide/widgets/_Widget[]}
     * @memberOf module:xide/utils
     * @returns {number}
     */
    utils.getHeight = function (widgets) {
        if (!_.isArray(widgets)) {
            widgets = [widgets];
        }
        var total = 0;
        _.each(widgets, function (w) {
            total += $(utils.getNode(w)).outerHeight();
        });
        return total;

    };
    /**
     *
     * @param source
     * @param target
     * @param height
     * @param width
     * @param force
     * @param offset
     * @memberOf module:xide/utils
     */
    utils.resizeTo = function (source, target, height, width, force, offset) {
        target = utils.getNode(target);
        source = utils.getNode(source);
        if (height === true) {
            var targetHeight = $(target).height();
            if (offset && offset.h !== null) {
                targetHeight += offset.h;
            }
            $(source).css('height', targetHeight + 'px' + (force === true ? '!important' : ''));
        }
        if (width === true) {
            var targetWidth = $(target).width();
            $(source).css('width', targetWidth + 'px' + (force === true ? '!important' : ''));
        }
    };

    return utils;
});

},
'xfile/manager/Context':function(){
define([
    'dcl/dcl',
    'xide/manager/Context',
    'xide/types'
], function (dcl, Context) {
    return dcl(Context,{
        declaredClass:"xfile.manager.Context"
    });
});
},
'xfile/types':function(){
define([
    'xide/utils',
    'xide/types',
    'xide/types/Types',
    'xaction/types'
],function(utils,types){
        /**
         * Public mime registry setter
         * @param type
         * @param map
         */
        types.registerCustomMimeIconExtension = function (type, map) {
            types['customMimeIcons'][type] = map;
        };

        var ACTION = types.ACTION;

        var DEFAULT_PERMISSIONS = [
            ACTION.EDIT,
            ACTION.COPY,
            ACTION.CLOSE,
            ACTION.MOVE,
            ACTION.RENAME,
            ACTION.DOWNLOAD,
            ACTION.RELOAD,
            ACTION.DELETE,
            ACTION.NEW_FILE,
            ACTION.NEW_DIRECTORY,
            ACTION.CLIPBOARD,
            ACTION.LAYOUT,
            ACTION.COLUMNS,
            ACTION.SELECTION,
            ACTION.PREVIEW,
            ACTION.OPEN_IN,
            ACTION.GO_UP,
            ACTION.SEARCH,
            ACTION.OPEN_IN_TAB,
            ACTION.TOOLBAR,
            ACTION.STATUSBAR,
            ACTION.UPLOAD,
            ACTION.SIZE_STATS,
            ACTION.CONSOLE,
            ACTION.HEADER,
            'File/Compress',
            'File/New',
            ACTION.CONTEXT_MENU,
            ACTION.SOURCE
        ];

        types.DEFAULT_FILE_GRID_PERMISSIONS = DEFAULT_PERMISSIONS;

        types.FIELDS = {
            SHOW_ISDIR:1602,
            SHOW_OWNER:1604,
            SHOW_MIME:1608,
            SHOW_SIZE:1616,
            SHOW_PERMISSIONS:1632,
            SHOW_TIME:1633,
            SHOW_FOLDER_SIZE:1634,
            SHOW_FOLDER_HIDDEN:1635,
            SHOW_TYPE:1636,
            SHOW_MEDIA_INFO:1637
        };

        types.FILE_PANEL_LAYOUT =
        {
            TREE:1,
            LIST:2,
            THUMB:3,
            PREVIEW:4,
            COVER:5,
            SPLIT_VERTICAL:6,
            SPLIT_HORIZONTAL:7,
            IMAGE_GRID:8
        };

        types.LAYOUT_PRESET =
        {
            DUAL:1,
            SINGLE:2,
            BROWSER:3,
            PREVIEW:4,
            GALLERY:5,
            EDITOR:6
        };

        types.PANEL_OPTIONS = {
            ALLOW_NEW_TABS:true,
            ALLOW_MULTI_TAB:false,
            ALLOW_INFO_VIEW:true,
            ALLOW_LOG_VIEW:true,
            ALLOW_CONTEXT_MENU:true,
            ALLOW_LAYOUT_SELECTOR:true,
            ALLOW_SOURCE_SELECTOR:true,
            ALLOW_COLUMN_RESIZE:true,
            ALLOW_COLUMN_REORDER:true,
            ALLOW_COLUMN_HIDE:true,
            ALLOW_ACTION_TOOLBAR:true,
            ALLOW_MAIN_MENU:true
        };

        /**
         * @TODO: remove
         * @type {{LAYOUT: number, AUTO_OPEN: boolean}}
         */
        types.FILE_PANEL_OPTIONS_LEFT={
            LAYOUT:2,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_MAIN={
            LAYOUT:3,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_RIGHT={
            LAYOUT:3,
            AUTO_OPEN:true
        };
        types.FILE_GRID_COLUMNS =
        {
            NAME:'name',
            SIZE:'size',
            MODIFIED:'modified'
        };
        types.ACTION_TOOLBAR_MODE =
        {
            SELF:'self'
        };

        utils.mixin(types.ITEM_TYPE,{
            FILE:'BTFILE'
        });

        /***
         *
         * Extend the core events with xfile specific events
         */
        /**
         * ActionVisibility
         * @enum module:xide/types/EVENTS
         * @memberOf module:xide/types
         */
        utils.mixin(types.EVENTS,{
            STORE_CHANGED:'onStoreChange',
            BEFORE_STORE_CHANGE:'onBeforeStoreChange',
            STORE_REFRESHED:'onStoreRefreshed',
            ON_FILE_STORE_READY:'onFileStoreReady',
            ON_DID_OPEN_ITEM:'onDidOpenItem',
            ON_SHOW_PANEL:'onShowPanel',
            ITEM_SELECTED:'onItemSelected',
            ERROR:'fileOperationError',
            STATUS:'fileOperationStatus',
            IMAGE_LOADED:'imageLoaded',
            IMAGE_ERROR:'imageError',
            RESIZE:'resize',
            ON_UPLOAD_BEGIN:'onUploadBegin',
            ON_UPLOAD_PROGRESS:'onUploadProgress',
            ON_UPLOAD_FINISH:'onUploadFinish',
            ON_UPLOAD_FAILED: 'onUploadFailed',
            ON_CLIPBOARD_COPY:'onClipboardCopy',
            ON_CLIPBOARD_PASTE:'onClipboardPaste',
            ON_CLIPBOARD_CUT:'onClipboardCut',
            ON_CONTEXT_MENU_OPEN:'onContextMenuOpen',
            ON_PLUGIN_LOADED:'onPluginLoaded',
            ON_PLUGIN_READY:'onPluginReady',
            ON_MAIN_VIEW_READY:'onMainViewReady',
            ON_FILE_CONTENT_CHANGED:'onFileContentChanged',
            ON_PANEL_CLOSED:'onPanelClosed',
            ON_PANEL_CREATED:'onPanelCreated',
            ON_COPY_BEGIN:'onCopyBegin',
            ON_COPY_END:'onCopyEnd',
            ON_DOWNLOAD_TO_BEGIN:'onDownloadToBegin',
            ON_DOWNLOAD_TO_END:'onDownloadToEnd',
            ON_DELETE_BEGIN:'onDeleteBegin',
            ON_DELETE_END:'onDeleteEnd',
            ON_MOVE_BEGIN:'onMoveBegin',
            ON_MOVE_END:'onMoveEnd',
            ON_COMPRESS_BEGIN:'onCompressBegin',
            ON_COMPRESS_END:'onCompressEnd',
            ON_SOURCE_MENU_OPEN:'onSourceMenuOpen',
            ON_MOUNT_DATA_READY:'onMountDataReady',
            ON_XFILE_READY:'onXFileReady',
            ON_CHANGE_PERSPECTIVE:'onChangePerspective',
            ON_FILE_PROPERTIES_RENDERED:'onFilePropertiesRendered'
        });

        /**
         * SELECTION_MODE specfies the possible selection modes for xfile grid views
         * @enum module:xide/types/SELECTION_MODE
         * @memberOf module:xide/types
         */
        types.SELECTION_MODE =
        {
            /** Single
             * @const
             * @type {string}
             */
            SINGLE:'single',
            /** Multiple
             * @const
             * @type {string}
             */
            MULTI:'multiple',
            /** Extended
             * @const
             * @type {string}
             */
            EXTENDED:'extended'
        };

        /**
         * @TODO: remove
         * OPERATION is the string representation of xfile commands
         * @enum module:xide/types/OPERATION
         * @memberOf module:xide/types
         */
        types.OPERATION=
        {

            COPY:'copy',
            MOVE:'move',
            RENAME:'rename',
            DELETE:'delete',
            OPEN:'open',
            EDIT:'edit',
            DOWNLOAD:'download',
            DOWNLOAD_TO:'downloadTo',
            INFO:'info',
            COMPRESS:'compress',
            RELOAD:'reload',
            PREVIEW:'preview',
            INSERT_IMAGE:'insertImage',
            COPY_PASTE:'copypaste',
            DND:'dnd',
            OPTIONS:'options',
            NEW_FILE:'mkfile',
            NEW_DIRECTORY:'mkdir',
            GET_CONTENT:'get',
            SET_CONTENT:'set',
            FIND:'find',
            CUSTOM:'custom',
            PERMA_LINK:'permaLink',
            ADD_MOUNT:'ADD_MOUNT',
            REMOVE_MOUNT:'REMOVE_MOUNT',
            EDIT_MOUNT:'EDIT_MOUNT',
            PERSPECTIVE:'PERSPECTIVE',
            EXTRACT:'extract'
        };

        /**
         * @TODO: remove
         * OPERATION_INT is the integer version of {xide/types/OPERATION}
         * @enum module:xide/types/OPERATION_INT
         * @memberOf module:xide/types
         */
        types.OPERATION_INT={
            NONE:0,
            EDIT:1,
            COPY:2,
            MOVE:3,
            INFO:4,
            DOWNLOAD:5,
            COMPRESS:6,
            DELETE:7,
            RENAME:8,
            DND:9,
            COPY_PASTE:10,
            OPEN:11,
            RELOAD:12,
            PREVIEW:13,
            INSERT_IMAGE:15,
            NEW_FILE:16,
            NEW_DIRECTORY:17,
            UPLOAD:18,
            READ:19,
            WRITE:20,
            PLUGINS:21,
            CUSTOM:22,
            FIND:23,
            PERMA_LINK:24,
            ADD_MOUNT:25,
            REMOVE_MOUNT:26,
            EDIT_MOUNT:27,
            PERSPECTIVE:28,      //change perspective
            CLIPBOARD_COPY:29,
            CLIPBOARD_CUT:30,
            CLIPBOARD_PASTE:31,
            EXTRACT:32
        };

    return types;
});
},
'xide/mixins/VariableMixin':function(){
/** @mixin xide/mixin/VariableMixin **/
define([
    'dcl/dcl',
    'xdojo/declare',
    'xide/utils'
], function (dcl,declare,utils) {

    var Implementation = {
        /**
         *
         * @param what
         * @param variables
         * @param delimitters
         * @returns {*}
         */
        resolve:function(what,variables,delimitters){
            variables = variables || this.resourceVariables || this.ctx.getResourceManager().getResourceVariables() || null;
            delimitters = delimitters || this.variableDelimiters || null;
            return utils.replace(what,null,variables,delimitters);
        }
    }

    /**
     * Mixin to resolve resource variables in strings.
     * Currently stub
     */
    var Module = declare("xide/mixins/VariableMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});
},
'xide/noob':function(){
define(['xdojo/declare','dcl/dcl'], function (declare,dcl) {

    var Module = declare("noob",null,{});
    Module.dcl = dcl(null,{});
    return Module;
});
},
'xace/views/_Split':function(){
define([
    'dcl/dcl'
],function (dcl){

    var _splitProto = null;
    var getSplitProto = function() {

        if(_splitProto){
            return _splitProto;
        }



        var require = ace.require;
        var oop = require("ace/lib/oop");
        var lang = require("ace/lib/lang");
        var EventEmitter = require("ace/lib/event_emitter").EventEmitter;

        var Editor = require("ace/editor").Editor;
        var Renderer = require("ace/virtual_renderer").VirtualRenderer;
        var EditSession = require("ace/edit_session").EditSession;
        var UndoManager = require("ace/undomanager").UndoManager;
        var HashHandler = require("ace/keyboard/hash_handler").HashHandler;

        var Split = function (container, theme, splits) {
            this.BELOW = 1;
            this.BESIDE = 0;

            this.$container = container;
            this.$theme = theme;
            this.$splits = 0;
            this.$editorCSS = "";
            this.$editors = [];
            this.$orientation = this.BESIDE;

            this.setSplits(splits || 1);
            this.$cEditor = this.$editors[0];


            this.on("focus", function (editor) {
                this.$cEditor = editor;
            }.bind(this));
        };

        (function () {

            oop.implement(this, EventEmitter);

            this.$createEditor = function () {
                var el = document.createElement("div");
                el.className = this.$editorCSS;
                el.style.cssText = "position: absolute; top:0px; bottom:0px";
                this.$container.appendChild(el);
                var editor = new Editor(new Renderer(el, this.$theme));


                editor.on("focus", function () {
                    this._emit("focus", editor);
                }.bind(this));

                this.$editors.push(editor);

                //var undoManager = editor.session.getUndoManager();
                editor.session.setUndoManager(new UndoManager());

                editor.setFontSize(this.$fontSize);
                return editor;
            };

            this.setSplits = function (splits) {
                var editor;
                if (splits < 1) {
                    throw "The number of splits have to be > 0!";
                }

                if(splits==1){

                }

                if (splits == this.$splits) {
                    return;
                } else if (splits > this.$splits) {
                    while (this.$splits < this.$editors.length && this.$splits < splits) {
                        editor = this.$editors[this.$splits];
                        this.$container.appendChild(editor.container);
                        editor.setFontSize(this.$fontSize);
                        this.$splits++;
                    }
                    while (this.$splits < splits) {
                        this.$createEditor();
                        this.$splits++;
                    }
                } else {
                    while (this.$splits > splits) {
                        editor = this.$editors[this.$splits - 1];
                        this.$container.removeChild(editor.container);
                        this.$splits--;
                    }
                }
                this.resize();
            };

            /**
             *
             * Returns the number of splits.
             * @returns {Number}
             **/
            this.getSplits = function () {
                return this.$splits;
            };

            /**
             * @param {Number} idx The index of the editor you want
             *
             * Returns the editor identified by the index `idx`.
             *
             **/
            this.getEditor = function (idx) {
                return this.$editors[idx];
            };

            /**
             *
             * Returns the current editor.
             * @returns {Editor}
             **/
            this.getCurrentEditor = function () {
                return this.$cEditor;
            };

            /**
             * Focuses the current editor.
             * @related Editor.focus
             **/
            this.focus = function () {
                this.$cEditor.focus();
            };

            /**
             * Blurs the current editor.
             * @related Editor.blur
             **/
            this.blur = function () {
                this.$cEditor.blur();
            };

            this.setSessionOption= function(what,value){
                this.$editors.forEach(function (editor) {

                    var session  =  editor.session;
                    if(what=='mode'){
                        session.setMode(value);
                    }

                });
            };
            /**
             *
             * @param {String} theme The name of the theme to set
             *
             * Sets a theme for each of the available editors.
             * @related Editor.setTheme
             **/
            this.setTheme = function (theme) {
                this.$editors.forEach(function (editor) {
                    editor.setTheme(theme);
                });
            };

            /**
             *
             * @param {String} keybinding
             *
             * Sets the keyboard handler for the editor.
             * @related editor.setKeyboardHandler
             **/
            this.setKeyboardHandler = function (keybinding) {
                this.$editors.forEach(function (editor) {
                    editor.setKeyboardHandler(keybinding);
                });
            };

            /**
             *
             * @param {Function} callback A callback function to execute
             * @param {String} scope The default scope for the callback
             *
             * Executes `callback` on all of the available editors.
             *
             **/
            this.forEach = function (callback, scope) {
                this.$editors.forEach(callback, scope);
            };


            this.$fontSize = "";
            /**
             * @param {Number} size The new font size
             *
             * Sets the font size, in pixels, for all the available editors.
             *
             **/
            this.setFontSize = function (size) {
                this.$fontSize = size;
                this.forEach(function (editor) {
                    editor.setFontSize(size);
                });
            };

            this.$cloneSession = function (session) {
                var s = new EditSession(session.getDocument(), session.getMode());

                var undoManager = session.getUndoManager();
                if (undoManager) {
                    var undoManagerProxy = new UndoManagerProxy(undoManager, s);
                    s.setUndoManager(undoManagerProxy);
                }

                // Overwrite the default $informUndoManager function such that new delas
                // aren't added to the undo manager from the new and the old session.
                s.$informUndoManager = lang.delayedCall(function () {
                    s.$deltas = [];
                });

                // Copy over 'settings' from the session.
                s.setTabSize(session.getTabSize());
                s.setUseSoftTabs(session.getUseSoftTabs());
                s.setOverwrite(session.getOverwrite());
                s.setBreakpoints(session.getBreakpoints());
                s.setUseWrapMode(session.getUseWrapMode());
                s.setUseWorker(session.getUseWorker());
                s.setWrapLimitRange(session.$wrapLimitRange.min,
                    session.$wrapLimitRange.max);
                s.$foldData = session.$cloneFoldData();

                return s;
            };

            /**
             *
             * @param {EditSession} session The new edit session
             * @param {Number} idx The editor's index you're interested in
             *
             * Sets a new [[EditSession `EditSession`]] for the indicated editor.
             * @related Editor.setSession
             **/
            this.setSession = function (session, idx) {
                var editor;
                if (idx == null) {
                    editor = this.$cEditor;
                } else {
                    editor = this.$editors[idx];
                }

                // Check if the session is used already by any of the editors in the
                // split. If it is, we have to clone the session as two editors using
                // the same session can cause terrible side effects (e.g. UndoQueue goes
                // wrong). This also gives the user of Split the possibility to treat
                // each session on each split editor different.
                var isUsed = this.$editors.some(function (editor) {
                    return editor.session === session;
                });

                if (isUsed) {
                    session = this.$cloneSession(session);
                }
                editor.setSession(session);

                // Return the session set on the editor. This might be a cloned one.
                return session;
            };

            /**
             *
             * Returns the orientation.
             * @returns {Number}
             **/
            this.getOrientation = function () {
                return this.$orientation;
            };

            /**
             *
             * Sets the orientation.
             * @param {Number} orientation The new orientation value
             *
             *
             **/
            this.setOrientation = function (orientation) {
                if (this.$orientation == orientation) {
                    return;
                }
                this.$orientation = orientation;
                this.resize();
            };

            /**
             * Resizes the editor.
             **/
            this.resize = function () {
                var width = this.$container.clientWidth;
                var height = this.$container.clientHeight;
                var editor;

                if (this.$orientation == this.BESIDE) {
                    var editorWidth = width / this.$splits;
                    if(this.diffGutter){
                        editorWidth -=60/this.$splits;
                    }


                    for (var i = 0; i < this.$splits; i++) {
                        editor = this.$editors[i];
                        editor.container.style.width = editorWidth + "px";
                        editor.container.style.top = "0px";
                        editor.container.style.left = i * editorWidth + "px";
                        if(i==1 && this.diffGutter){
                            editor.container.style.left = 60 +  (i * editorWidth) + "px";
                            this.diffGutter.style.left = i * editorWidth + "px";
                            /*this.diffGutter.style.height = height + "px";*/
                        }

                        //editor.container.style.height = height + "px";
                        if(!height){
                            return;
                        }
                        $(editor.container).css('height',height + "px");
                        var cNode = $(editor.container).find('.ace_content');
                        editor.resize();
                        cNode.css('height',height + "px");

                    }
                } else {
                    var editorHeight = height / this.$splits;
                    for (var i = 0; i < this.$splits; i++) {
                        editor = this.$editors[i];
                        editor.container.style.width = width + "px";
                        editor.container.style.top = i * editorHeight + "px";
                        editor.container.style.left = "0px";
                        editor.container.style.height = editorHeight + "px";
                        editor.resize();
                    }
                }
            };

        }).call(Split.prototype);


        function UndoManagerProxy(undoManager, session) {
            this.$u = undoManager;
            this.$doc = session;
        }

        (function () {
            this.execute = function (options) {
                this.$u.execute(options);
            };

            this.undo = function () {
                var selectionRange = this.$u.undo(true);
                if (selectionRange) {
                    this.$doc.selection.setSelectionRange(selectionRange);
                }
            };

            this.redo = function () {
                var selectionRange = this.$u.redo(true);
                if (selectionRange) {
                    this.$doc.selection.setSelectionRange(selectionRange);
                }
            };

            this.reset = function () {
                this.$u.reset();
            };

            this.hasUndo = function () {
                return this.$u.hasUndo();
            };

            this.hasRedo = function () {
                return this.$u.hasRedo();
            };
        }).call(UndoManagerProxy.prototype);

        _splitProto = Split;
        /*});*/
        return _splitProto;
    };
    var Module = dcl(null,{
        declaredClass:'xace/views/Split'
    });
    Module.getSplitter = getSplitProto;
    return Module;
});

},
'dojo/dnd/Manager':function(){
define([
	"../_base/array",  "../_base/declare", "../_base/lang", "../_base/window",
	"../dom-class", "../Evented", "../has", "../keys", "../on", "../topic", "../touch",
	"./common", "./autoscroll", "./Avatar"
], function(array, declare, lang, win, domClass, Evented, has, keys, on, topic, touch,
	dnd, autoscroll, Avatar){

// module:
//		dojo/dnd/Manager

var Manager = declare("dojo.dnd.Manager", [Evented], {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: has("touch") ? 0 : 16,
	OFFSET_Y: has("touch") ? -64 : 16,

	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		topic.publish("/dnd/source/over", source);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				topic.publish("/dnd/source/over", null);
			}
		}else{
			topic.publish("/dnd/source/over", null);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		// Tell autoscroll that a drag is starting
		autoscroll.autoScrollStart(win.doc);

		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		win.body().appendChild(this.avatar.node);
		topic.publish("/dnd/start", source, nodes, this.copy);

		function stopEvent(e){
			e.preventDefault();
			e.stopPropagation();
		}

		this.events = [
			on(win.doc, touch.move, lang.hitch(this, "onMouseMove")),
			on(win.doc, touch.release,   lang.hitch(this, "onMouseUp")),
			on(win.doc, "keydown",   lang.hitch(this, "onKeyDown")),
			on(win.doc, "keyup",     lang.hitch(this, "onKeyUp")),

			// cancel text selection and text dragging
			on(win.doc, "dragstart",   stopEvent),
			on(win.body(), "selectstart", stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		domClass.add(win.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		domClass.remove(win.body(), ["dojoDndCopy", "dojoDndMove"]);
		array.forEach(this.events, function(handle){ handle.remove(); });
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			autoscroll.autoScrollNodes(e);
			//autoscroll.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dnd.getCopyKeyState(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
		if(has("touch")){
			// Prevent page from scrolling so that user can drag instead.
			e.preventDefault();
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dnd.getCopyKeyState(e)));
				topic.publish("/dnd/drop/before", this.source, this.nodes, copy, this.target, e);
				topic.publish("/dnd/drop", this.source, this.nodes, copy, this.target, e);
			}else{
				topic.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},

	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case keys.ESCAPE:
					topic.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},

	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		domClass.replace(win.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dnd._manager = null;

Manager.manager = dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dnd._manager){
		dnd._manager = new Manager();
	}
	return dnd._manager;	// Object
};

// TODO: for 2.0, store _manager and manager in Manager only.   Don't access dnd or dojo.dnd.

return Manager;
});

},
'wcDocker/frame':function(){
/** @module wcFrame */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class module:wcFrame
     * The frame is a [panel]{@link module:wcPanel} container.
     * Each panel appears as a tabbed item inside a frame.
     */
    var Module = dcl(base, {
        declaredClass: 'wcFrame',
        LEFT_TAB_BUFFER: 15,
        /**
         * <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
         * @memberOf module:wcFrame
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this frame.
         * @param {module:wcSplitter|wcDocker} parent - The frames parent object.
         * @param {Boolean} isFloating - If true, the frame will be a floating window.
         */
        constructor: function (container, parent, isFloating) {
            /**
             * The container that holds the frame.
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;
            this._isFloating = isFloating;

            /**
             * The outer frame element.
             * @member {external:jQuery~Object}
             */
            this.$frame = null;
            this.$title = null;
            this.$titleBar = null;
            this.$tabBar = null;
            this.$tabScroll = null;
            this.$center = null;
            this.$tabLeft = null;
            this.$tabRight = null;
            this.$close = null;
            this.$collapse = null;
            this.$top = null;
            this.$bottom = null;
            this.$left = null;
            this.$right = null;
            this.$corner1 = null;
            this.$corner2 = null;
            this.$corner3 = null;
            this.$corner4 = null;
            this.$buttonBar = null;

            this.$shadower = null;
            this.$modalBlocker = null;

            this._titleVisible = true;
            this._canScrollTabs = false;
            this._tabOrientation = wcDocker.TAB.TOP;
            this._tabScrollPos = 0;
            this._curTab = -1;
            this._panelList = [];
            this._buttonList = [];

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._pos = {
                x: 0.5,
                y: 0.5
            };

            this._size = {
                x: 400,
                y: 400
            };

            this._lastSize = {
                x: 400,
                y: 400
            };

            this._anchorMouse = {
                x: 0,
                y: 0
            };

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Gets, or Sets the position of the frame.
         * @function module:wcFrame#pos
         * @param {Number} [x]        - If supplied, assigns a new horizontal position.
         * @param {Number} [y]        - If supplied, assigns a new vertical position.
         * @param {Boolean} [pixels]  - If true, the coordinates passed in will be treated as a pixel position rather than a percentage.
         * @returns {module:wcDocker~Coordinate} - The current position of the frame. If the pixel parameter was true, the position will be in pixels.
         */
        pos: function (x, y, pixels) {
            var width = this.$container.width();
            var height = this.$container.height();

            if (typeof x === 'undefined') {
                if (pixels) {
                    return {x: this._pos.x * width, y: this._pos.y * height};
                } else {
                    return {x: this._pos.x, y: this._pos.y};
                }
            }

            if (pixels) {
                this._pos.x = x / width;
                this._pos.y = y / height;
            } else {
                this._pos.x = x;
                this._pos.y = y;
            }
        },

        /**
         * Gets the initially desired size of the panel.
         * @function module:wcFrame#initSize
         * @returns {module:wcDocker~Size} - The initially desired size.
         */
        initSize: function () {
            var size = {
                x: -1,
                y: -1
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                if (size.x < this._panelList[i].initSize().x) {
                    size.x = this._panelList[i].initSize().x;
                }
                if (size.y < this._panelList[i].initSize().y) {
                    size.y = this._panelList[i].initSize().y;
                }
            }

            if (size.x < 0 || size.y < 0) {
                return false;
            }
            return size;
        },

        /**
         * Gets the minimum size of the frame.
         * @function module:wcFrame#minSize
         * @returns {module:wcDocker~Size} - The minimum size of the frame.
         */
        minSize: function () {
            var size = {
                x: 0,
                y: 0
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                size.x = Math.max(size.x, this._panelList[i].minSize().x);
                size.y = Math.max(size.y, this._panelList[i].minSize().y);
            }
            return size;
        },

        /**
         * Gets the maximum size of the frame.
         * @function module:wcFrame#maxSize
         * @returns {module:wcDocker~Size} - The maximum size of the frame.
         */
        maxSize: function () {
            var size = {
                x: Infinity,
                y: Infinity
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                size.x = Math.min(size.x, this._panelList[i].maxSize().x);
                size.y = Math.min(size.y, this._panelList[i].maxSize().y);
            }
            return size;
        },

        /**
         * Gets, or Sets the tab orientation for the frame. This puts the tabbed widgets visually on any side of the frame.
         * @version 3.0.0
         * @function module:wcFrame#tabOrientation
         * @param {module:wcDocker.TAB} [orientation] - Assigns the orientation of the tab items displayed.
         * @returns {module:wcDocker.TAB} - The current orientation.
         */
        tabOrientation: function (orientation) {
            if (orientation !== undefined) {
                if (this._tabOrientation !== orientation && this.docker()._canOrientTabs) {
                    this._tabOrientation = orientation;

                    this.__updateTabs();
                    this.__updateTabs();
                }
            }

            return this._tabOrientation
        },

        /**
         * Adds a given panel as a new tab item to the frame.
         * @function module:wcFrame#addPanel
         * @param {module:wcPanel} panel         - The panel to add.
         * @param {Number} [index]        - Insert index.
         */
        addPanel: function (panel, index) {
            var found = this._panelList.indexOf(panel);
            if (found !== -1) {
                this._panelList.splice(found, 1);
            }

            if (typeof index === 'undefined') {
                this._panelList.push(panel);
            } else {
                this._panelList.splice(index, 0, panel);
            }

            if (this._curTab === -1 && this._panelList.length) {
                if (!this.isCollapser()) {
                    this._curTab = 0;
                }
                this._size = this.initSize();
            }

            this.__updateTabs();
        },

        /**
         * Removes a given panel from the frame.
         * @function module:wcFrame#removePanel
         * @param {module:wcPanel} panel - The panel to remove.
         * @returns {Boolean} - True if any panels still remain after the removal.
         */
        removePanel: function (panel) {
            for (var i = 0; i < this._panelList.length; ++i) {
                if (this._panelList[i] === panel) {
                    if (this.isCollapser()) {
                        this._curTab = -1;
                    } else if (this._curTab >= i) {
                        this._curTab--;
                    }

                    // Only null out the container if it is still attached to this frame.
                    if (this._panelList[i]._parent === this) {
                        this._panelList[i].__container(null);
                        this._panelList[i]._parent = null;
                    }

                    this._panelList.splice(i, 1);
                    panel._isVisible = false;
                    break;
                }
            }

            if (this._curTab === -1) {
                if (!this.collapse() && this._panelList.length) {
                    this._curTab = 0;
                }
            }

            this.__updateTabs();
            return this._panelList.length > 0;
        },

        /**
         * Gets, or Sets the currently visible panel.
         * @function module:wcFrame#panel
         * @param {Number} [tabIndex] - If supplied, sets the current panel index.
         * @param {Boolean} [autoFocus] - If true, this tab will be focused (brought to front).
         * @returns {module:wcPanel} - The currently visible panel.
         */
        panel: function (tabIndex, autoFocus) {
            if (typeof tabIndex !== 'undefined') {
                if (this.isCollapser() && tabIndex === this._curTab) {
                    this.collapse();
                    tabIndex = -1;
                }
                if (tabIndex < this._panelList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    if (this._curTab !== tabIndex) {
                        this.collapse();
                    }
                    this._curTab = tabIndex;
                    if (tabIndex > -1) {
                        this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + tabIndex + '"]').addClass('wcPanelTabActive');
                        this.$center.children('.wcPanelTabContent[id="' + tabIndex + '"]').removeClass('wcPanelTabContentHidden');
                        this.expand();
                    }
                    this.__updateTabs(autoFocus);
                }
            }

            if (this._curTab > -1 && this._curTab < this._panelList.length) {
                return this._panelList[this._curTab];
            } else if (this.isCollapser() && this._panelList.length) {
                return this._panelList[0];
            }
            return false;
        },

        /**
         * Gets whether this frame is inside a collapser.
         * @function module:wcFrame#isCollapser
         * @returns {Boolean} - Whether this frame is inside a collapser.
         */
        isCollapser: function () {
            return (this._parent && this._parent.declaredClass === 'wcDrawer');
        },

        /**
         * Collapses the frame, if it is a collapser.
         * @function module:wcFrame#collapse
         * @param {Boolean} [instant] - If true, collapses without animating.
         */
        collapse: function (instant) {
            if (this.isCollapser()) {
                this._parent.collapse(instant);
                return true;
            }
            return false;
        },

        /**
         * Expands the frame, if it is a collapser.
         * @function module:wcFrame#expand
         */
        expand: function () {
            if (this.isCollapser()) {
                this._parent.expand();
                return true;
            }
            return false;
        },

        /**
         * Gets whether the frame is expanded, if it is a collapser.
         * @function module:wcFrame#isExpanded
         * @returns {Boolean|undefined} - The current expanded state, or undefined if it is not a collapser.
         */
        isExpanded: function () {
            if (this.isCollapser()) {
                return this._parent.isExpanded();
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$frame = $('<div class="wcFrame wcWide wcTall">');
            this.$title = $('<div class="wcFrameTitle">');
            this.$titleBar = $('<div class="wcFrameTitleBar wcFrameTopper">');
            this.$tabBar = $('<div class="wcFrameTitleBar">');
            this.$tabScroll = $('<div class="wcTabScroller">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><div class="fa fa-close"></div>X</div>');

            this.$collapse = $('<div class="wcFrameButton" title="Collapse the active panel"><div class="fa fa-download"></div>C</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');
            this.$tabButtonBar = $('<div class="wcFrameButtonBar">');

            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$tabButtonBar);
            this.$frame.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);
            this.$buttonBar.append(this.$collapse);
            this.$frame.append(this.$center);

            if (this._isFloating) {
                this.$top = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('top', '-6px').css('left', '0px').css('right', '0px');
                this.$bottom = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('bottom', '-6px').css('left', '0px').css('right', '0px');
                this.$left = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('left', '-6px').css('top', '0px').css('bottom', '0px');
                this.$right = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('right', '-6px').css('top', '0px').css('bottom', '0px');
                this.$corner1 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('top', '-6px').css('left', '-6px');
                this.$corner2 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('top', '-6px').css('right', '-6px');
                this.$corner3 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('bottom', '-6px').css('right', '-6px');
                this.$corner4 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('bottom', '-6px').css('left', '-6px');

                this.$frame.append(this.$top);
                this.$frame.append(this.$bottom);
                this.$frame.append(this.$left);
                this.$frame.append(this.$right);
                this.$frame.append(this.$corner1);
                this.$frame.append(this.$corner2);
                this.$frame.append(this.$corner3);
                this.$frame.append(this.$corner4);
            }

            this.__container(this.$container);

            if (this._isFloating) {
                this.$frame.addClass('wcFloating');
            }

            this.$center.scroll(this.__scrolled.bind(this));
        },

        // Updates the size of the frame.
        __update: function () {
            var width = this.$container.width();
            var height = this.$container.height();

            // Floating windows manage their own sizing.
            if (this._isFloating) {
                var left = (this._pos.x * width) - this._size.x / 2;
                var top = (this._pos.y * height) - this._size.y / 2;

                if (top < 0) {
                    top = 0;
                }

                if (left + this._size.x / 2 < 0) {
                    left = -this._size.x / 2;
                }

                if (left + this._size.x / 2 > width) {
                    left = width - this._size.x / 2;
                }

                if (top + parseInt(this.$center.css('top')) > height) {
                    top = height - parseInt(this.$center.css('top'));
                }

                this.$frame.css('left', left + 'px');
                this.$frame.css('top', top + 'px');
                this.$frame.css('width', this._size.x + 'px');
                this.$frame.css('height', this._size.y + 'px');
            }

            if (width !== this._lastSize.x || height !== this._lastSize.y) {
                this._lastSize.x = width;
                this._lastSize.y = height;

                this._resizeData.time = new Date();
                if (!this._resizeData.timeout) {
                    this._resizeData.timeout = true;
                    setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                }
            }
            // this.__updateTabs();
            this.__onTabChange();
        },

        __resizeEnd: function () {
            this.__updateTabs();
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
            }
        },

        // Triggers an event exclusively on the docker and none of its panels.
        // Params:
        //    eventName   The name of the event.
        //    data        A custom data parameter to pass to all handlers.
        __trigger: function (eventName, data) {
            for (var i = 0; i < this._panelList.length; ++i) {
                this._panelList[i].__trigger(eventName, data);
            }
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.type = 'wcFrame';
            data.floating = this._isFloating;
            data.isFocus = this.$frame.hasClass('wcFloatingFocus');
            data.tabOrientation = this._tabOrientation;
            data.pos = {
                x: this._pos.x,
                y: this._pos.y
            };
            data.size = {
                x: this._size.x,
                y: this._size.y
            };
            data.tab = this._curTab;
            data.panels = [];
            for (var i = 0; i < this._panelList.length; ++i) {
                data.panels.push(this._panelList[i].__save());
            }
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._isFloating = data.floating;
            this._tabOrientation = data.tabOrientation || wcDocker.TAB.TOP;
            this._pos.x = data.pos.x;
            this._pos.y = data.pos.y;
            this._size.x = data.size.x;
            this._size.y = data.size.y;
            this._curTab = data.tab;
            for (var i = 0; i < data.panels.length; ++i) {
                var panel = docker.__create(data.panels[i], this, this.$center);
                panel.__restore(data.panels[i], docker);
                this._panelList.push(panel);
            }

            this.__update();

            if (data.isFocus) {
                this.$frame.addClass('wcFloatingFocus');
            }
        },

        __updateTabs: function (autoFocus) {

            this.$tabScroll.empty();


            var getOffset = function ($item) {
                switch (this._tabOrientation) {
                    case wcDocker.TAB.BOTTOM:
                        return $item.offset().left;
                    case wcDocker.TAB.TOP:
                        return $item.offset().left;
                    case wcDocker.TAB.LEFT:
                        return $item.offset().top;
                    case wcDocker.TAB.RIGHT:
                        return $item.offset().top;
                }
            }.bind(this);

            var visibilityChanged = [];
            var tabPositions = [];
            var totalWidth = 0;
            var parentLeft = getOffset(this.$tabScroll);
            var showTabs = this._panelList.length > 1 || this._isFloating || this.isCollapser();
            var self = this;

            if (this.isCollapser()) {
                // this.$titleBar.addClass('wcNotMoveable');
                this.$tabBar.addClass('wcNotMoveable');
            } else {
                this.$titleBar.removeClass('wcNotMoveable');
                this.$tabBar.removeClass('wcNotMoveable');
            }

            this.$center.children('.wcPanelTabContent').each(function () {
                $(this).addClass('wcPanelTabContentHidden wcPanelTabUnused');
            });

            this._titleVisible = true;
            this.$title.html('');

            // Determine if the title and tabs are visible based on the panels inside.
            for (var i = 0; i < this._panelList.length; ++i) {
                var panel = this._panelList[i];

                var $tab = null;
                if (showTabs) {
                    $tab = panel.$title;
                    panel.$title.attr('id', i);
                    this.$tabScroll.append(panel.$title);
                }

                if (!panel.moveable()) {
                    this.$titleBar.addClass('wcNotMoveable');
                    this.$tabBar.addClass('wcNotMoveable');
                }

                if (!panel._titleVisible) {
                    this._titleVisible = false;
                }

                var $tabContent = this.$center.children('.wcPanelTabContent[id="' + i + '"]');
                if (!$tabContent.length) {
                    $tabContent = $('<div class="wcPanelTabContent wcPanelTabContentHidden" id="' + i + '">');
                    this.$center.append($tabContent);
                }

                panel.__container($tabContent);
                panel._parent = this;

                var isVisible = this._curTab === i;
                if (panel.isVisible() !== isVisible) {
                    visibilityChanged.push({
                        panel: panel,
                        isVisible: isVisible
                    });
                }

                $tabContent.removeClass('wcPanelTabUnused');

                if (isVisible) {
                    $tab && $tab.addClass('wcPanelTabActive active');
                    $tabContent.removeClass('wcPanelTabContentHidden');
                    this.$title.html(panel.title());
                    if (panel.$icon) {
                        var $icon = panel.$icon.clone();
                        this.$title.prepend($icon);
                    }
                }

                if ($tab) {
                    totalWidth = getOffset($tab) - parentLeft;
                    tabPositions.push(totalWidth);

                    totalWidth += $tab.outerWidth();
                }
            }

            var $topBar = this.$titleBar;
            var tabWidth = 0;
            if (this._titleVisible) {
                if (!this.$frame.parent()) {
                    this.$center.css('top', '');
                }
                switch (this._tabOrientation) {
                    case wcDocker.TAB.TOP:
                        this.$frame.prepend(this.$tabBar);
                        this.$titleBar.remove();
                        this.$tabBar.addClass('wcTabTop').removeClass('wcTabLeft wcTabRight wcTabBottom');
                        // this.$tabBar.css('margin-top', '');
                        if (showTabs) {
                            this.$title.remove();
                        } else {
                            this.$tabBar.prepend(this.$title);
                        }
                        $topBar = this.$tabBar;
                        this.$center.css('left', 0).css('right', 0).css('bottom', 0);
                        tabWidth = this.$center.width();
                        break;
                    case wcDocker.TAB.BOTTOM:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabBottom').removeClass('wcTabTop wcTabLeft wcTabRight');
                            // this.$tabBar.css('margin-top', '');

                            this.$center.css('left', 0).css('right', 0).css('bottom', titleSize);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.width();
                        break;

                    case wcDocker.TAB.LEFT:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabLeft').removeClass('wcTabTop wcTabRight wcTabBottom');
                            // this.$tabBar.css('margin-top', titleSize);

                            this.$center.css('left', titleSize).css('right', 0).css('bottom', 0);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.height();
                        break;

                    case wcDocker.TAB.RIGHT:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabRight').removeClass('wcTabTop wcTabLeft wcTabBottom');
                            // this.$tabBar.css('margin-top', titleSize);

                            this.$center.css('left', 0).css('right', titleSize).css('bottom', 0);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.height();
                        break;
                }
                if (!showTabs) {
                    this.$center.css('left', 0).css('right', 0).css('bottom', 0);
                }
            } else {
                this.$titleBar.remove();
                this.$tabBar.remove();
                this.$center.css('top', 0).css('left', 0).css('right', 0).css('bottom', 0);
            }

            // Now remove all unused panel tabs.
            this.$center.children('.wcPanelTabUnused').each(function () {
                $(this).remove();
            });

            if (this._titleVisible) {
                var buttonSize = this.__onTabChange();

                if (autoFocus) {
                    for (var i = 0; i < tabPositions.length; ++i) {
                        if (i === this._curTab) {
                            var left = tabPositions[i];
                            var right = totalWidth;
                            if (i + 1 < tabPositions.length) {
                                right = tabPositions[i + 1];
                            }

                            var scrollPos = -parseInt(this.$tabScroll.css('left'));
                            var titleWidth = tabWidth - buttonSize;

                            // If the tab is behind the current scroll position.
                            if (left < scrollPos) {
                                this._tabScrollPos = left - this.LEFT_TAB_BUFFER;
                                if (this._tabScrollPos < 0) {
                                    this._tabScrollPos = 0;
                                }
                            }
                            // If the tab is beyond the current scroll position.
                            else if (right - scrollPos > titleWidth) {
                                this._tabScrollPos = right - titleWidth + this.LEFT_TAB_BUFFER;
                            }
                            break;
                        }
                    }
                }

                this._canScrollTabs = false;
                if (totalWidth > tabWidth - buttonSize) {
                    this._canScrollTabs = this._titleVisible;
                    if (this._canScrollTabs) {
                        this.$tabButtonBar.append(this.$tabRight);
                        this.$tabButtonBar.append(this.$tabLeft);
                        buttonSize += this.$tabRight.outerWidth();
                        buttonSize += this.$tabLeft.outerWidth();
                    }

                    var scrollLimit = totalWidth - (tabWidth - buttonSize) / 2;
                    // If we are beyond our scroll limit, clamp it.
                    if (this._tabScrollPos > scrollLimit) {
                        var children = this.$tabScroll.children();
                        for (var i = 0; i < children.length; ++i) {
                            var $tab = $(children[i]);

                            totalWidth = getOffset($tab) - parentLeft;
                            if (totalWidth + $tab.outerWidth() > scrollLimit) {
                                this._tabScrollPos = totalWidth - this.LEFT_TAB_BUFFER;
                                if (this._tabScrollPos < 0) {
                                    this._tabScrollPos = 0;
                                }
                                break;
                            }
                        }
                    }
                } else {
                    this._tabScrollPos = 0;
                    this.$tabLeft.remove();
                    this.$tabRight.remove();
                }

                this.$tabScroll.stop().animate({left: -this._tabScrollPos + 'px'}, 'fast');

                // Update visibility on panels.
                for (var i = 0; i < visibilityChanged.length; ++i) {
                    visibilityChanged[i].panel.__isVisible(visibilityChanged[i].isVisible);
                }
            }
        },

        __onTabChange: function () {
            var buttonSize = 0;
            var tabButtonSize = 0;
            var panel = this.panel();
            this.$tabLeft.remove();
            this.$tabRight.remove();
            this.$close.hide();
            this.$collapse.hide();

            while (this._buttonList.length) {
                this._buttonList.pop().remove();
            }

            if (panel) {
                var scrollable = panel.scrollable();
                this.$center.toggleClass('wcScrollableX', scrollable.x);
                this.$center.toggleClass('wcScrollableY', scrollable.y);
                this.$frame.toggleClass('wcOverflowVisible', panel.overflowVisible());
                this.$center.toggleClass('wcOverflowVisible', panel.overflowVisible());

                if (!this.isCollapser() || this.isExpanded()) {
                    if (panel.closeable()) {
                        this.$close.show();
                        buttonSize += this.$close.outerWidth();
                    }

                    var docker = this.docker();
                    if (docker.isCollapseEnabled() && panel.moveable() && panel.collapsible() && !this._isFloating && !panel._isPlaceholder) {
                        if (this.isCollapser()) {
                            // Un-collapse
                            var $icon = this.$collapse.children('div');
                            $icon[0].className = 'fa fa-sign-out';
                            switch (this._parent._position) {
                                case wcDocker.DOCK.LEFT:
                                    $icon.addClass('wcCollapseLeft');
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    $icon.addClass('wcCollapseRight');
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    $icon.addClass('wcCollapseBottom');
                                    break;
                            }
                            $icon.addClass('wcCollapsed');
                            this.$collapse.show();
                            this.$collapse.attr('title', 'Dock this collapsed panel back into the main layout.');
                            buttonSize += this.$collapse.outerWidth();
                        } else {
                            var direction = wcDocker.DOCK.BOTTOM;
                            if (panel._collapseDirection === wcDocker.DOCK.LEFT ||
                                panel._collapseDirection === wcDocker.DOCK.RIGHT ||
                                panel._collapseDirection === wcDocker.DOCK.BOTTOM) {
                                // Static collapse direction.
                                direction = panel._collapseDirection;
                            } else {
                                // Determine the direction to collapse based on the frame center.
                                var $inner = docker.$container;
                                if (!$.isEmptyObject(docker._collapser) && docker._collapser.hasOwnProperty(wcDocker.DOCK.RIGHT)) {
                                    // Get the inner contents element not taken up by the collapsible drawers.
                                    $inner = docker._collapser[wcDocker.DOCK.RIGHT]._parent.$pane[0];
                                }

                                var outer = $inner.offset();
                                var bounds = this.$container.offset();
                                bounds.right = (bounds.left + this.$container.width() - outer.left) / $inner.width();
                                bounds.bottom = (bounds.top + this.$container.height() - outer.top) / $inner.height();
                                bounds.top = (bounds.top - outer.top) / $inner.height();
                                bounds.left = (bounds.left - outer.left) / $inner.width();

                                if (typeof panel._collapseDirection === 'function') {
                                    // Custom collapse handler.
                                    direction = panel._collapseDirection(bounds);
                                } else {
                                    // Default collapse calculation.
                                    if (bounds.top > 0.5 && bounds.bottom > 0.95) {
                                        direction = wcDocker.DOCK.BOTTOM;
                                    } else if (bounds.left <= 0.05) {
                                        direction = wcDocker.DOCK.LEFT;
                                    } else if (bounds.right >= 0.95) {
                                        direction = wcDocker.DOCK.RIGHT;
                                    } else if (bounds.bottom > 0.95) {
                                        direction = wcDocker.DOCK.BOTTOM;
                                    }
                                }
                            }

                            var directionLabel = '';
                            var directionClass = '';
                            switch (direction) {
                                case wcDocker.DOCK.LEFT:
                                    directionLabel = 'left side.';
                                    directionClass = 'wcCollapseLeft';
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    directionLabel = 'right side.';
                                    directionClass = 'wcCollapseRight';
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    directionLabel = 'bottom.';
                                    directionClass = 'wcCollapseBottom';
                                    break;
                            }

                            if (directionLabel) {
                                var $icon = this.$collapse.children('div');
                                $icon[0].className = 'fa fa-sign-in';
                                $icon.addClass(directionClass);
                                $icon.addClass('wcCollapsible');
                                this.$collapse.show();
                                this.$collapse.attr('title', 'Collapse this panel into the ' + directionLabel);
                                buttonSize += this.$collapse.outerWidth();
                            }
                        }
                    }

                    for (var i = 0; i < panel._buttonList.length; ++i) {
                        var buttonData = panel._buttonList[i];
                        var $button = $('<div>');
                        var buttonClass = buttonData.className;
                        $button.addClass('wcFrameButton');
                        if (buttonData.isTogglable) {
                            $button.addClass('wcFrameButtonToggler');

                            if (buttonData.isToggled) {
                                $button.addClass('wcFrameButtonToggled');
                                buttonClass = buttonData.toggleClassName || buttonClass;
                            }
                        }
                        $button.attr('title', buttonData.tip);
                        $button.data('name', buttonData.name);
                        $button.text(buttonData.text);
                        if (buttonClass) {
                            $button.prepend($('<div class="' + buttonClass + '">'));
                        }

                        this._buttonList.push($button);
                        this.$buttonBar.append($button);
                        buttonSize += $button.outerWidth();
                    }
                }

                if (this._canScrollTabs) {
                    this.$tabButtonBar.append(this.$tabRight);
                    this.$tabButtonBar.append(this.$tabLeft);

                    tabButtonSize += this.$tabRight.outerWidth() + this.$tabLeft.outerWidth();
                }

                if (this._titleVisible) {
                    this.$buttonBar.css('right', '');
                    switch (this._tabOrientation) {
                        case wcDocker.TAB.RIGHT:
                            this.$buttonBar.css('right', this.$tabBar.height());
                        case wcDocker.TAB.LEFT:
                            this.$tabBar.css('width', this.$center.height() + this.$tabBar.height());
                            break;
                        case wcDocker.TAB.TOP:
                        case wcDocker.TAB.BOTTOM:
                            this.$tabBar.css('width', this.$center.width());
                            break;
                        default:
                            break;
                    }
                }

                panel.__update();

                this.$center.scrollLeft(panel._scroll.x);
                this.$center.scrollTop(panel._scroll.y);
            }

            this.$buttonBar.css('min-width', buttonSize).css('width', buttonSize);
            this.$tabButtonBar.css('min-width', tabButtonSize).css('width', tabButtonSize);

            if (this._tabOrientation === wcDocker.TAB.TOP) {
                this.$tabButtonBar.css('right', buttonSize);
                return buttonSize + tabButtonSize;
            } else {
                this.$tabButtonBar.css('right', 0);
                return tabButtonSize;
            }
        },

        // Handles scroll notifications.
        __scrolled: function () {
            var panel = this.panel();
            panel._scroll.x = this.$center.scrollLeft();
            panel._scroll.y = this.$center.scrollTop();

            panel.__trigger(wcDocker.EVENT.SCROLLED);
        },

        // Brings the frame into focus.
        // Params:
        //    flash     Optional, if true will flash the window.
        __focus: function (flash) {
            if (flash) {
                var $flasher = $('<div class="wcFrameFlasher">');
                this.$frame.append($flasher);
                $flasher.animate({
                    opacity: 1
                }, 100)
                    .animate({
                        opacity: 0.0
                    }, 100)
                    .animate({
                        opacity: 0.6
                    }, 50)
                    .animate({
                        opacity: 0.0
                    }, 50)
                    .queue(function (next) {
                        $flasher.remove();
                        next();
                    });
            }
        },

        // Moves the panel based on mouse dragging.
        // Params:
        //    mouse     The current mouse position.
        __move: function (mouse) {
            var width = this.$container.width();
            var height = this.$container.height();

            this._pos.x = (mouse.x + this._anchorMouse.x) / width;
            this._pos.y = (mouse.y + this._anchorMouse.y) / height;
        },

        // Sets the anchor position for moving the panel.
        // Params:
        //    mouse     The current mouse position.
        __anchorMove: function (mouse) {
            var width = this.$container.width();
            var height = this.$container.height();

            this._anchorMouse.x = (this._pos.x * width) - mouse.x;
            this._anchorMouse.y = (this._pos.y * height) - mouse.y;
        },

        // Moves a tab from a given index to another index.
        // Params:
        //    fromIndex     The current tab index to move.
        //    toIndex       The new index to move to.
        // Returns:
        //    element       The new element of the moved tab.
        //    false         If an error occurred.
        __tabMove: function (fromIndex, toIndex) {
            if (fromIndex >= 0 && fromIndex < this._panelList.length &&
                toIndex >= 0 && toIndex < this._panelList.length) {
                var panel = this._panelList.splice(fromIndex, 1);
                this._panelList.splice(toIndex, 0, panel[0]);

                // Preserve the currently active tab.
                if (this._curTab === fromIndex) {
                    this._curTab = toIndex;
                }

                this.__updateTabs();

                return this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + toIndex + '"]')[0];
            }
            return false;
        },

        // Checks if the mouse is in a valid anchor position for docking a panel.
        // Params:
        //    mouse       The current mouse position.
        //    same        Whether the moving frame and this one are the same.
        //    ghost       The ghost object.
        //    canSplit    Whether the frame can be split
        //    isTopper    Whether the user is dragging the topper (top title bar).
        //    allowEdges  Whether to allow edge docking.
        __checkAnchorDrop: function (mouse, same, ghost, canSplit, isTopper, allowEdges) {
            var panel = this.panel();
            if (panel && panel.moveable()) {
                return panel.layout().__checkAnchorDrop(mouse, same && this._tabOrientation, ghost, (!this._isFloating && !this.isCollapser() && canSplit), this.$frame, panel.moveable() && panel.title(), isTopper, this.isCollapser() ? this._tabOrientation : undefined, allowEdges);
            }
            return false;
        },

        // Resizes the panel based on mouse dragging.
        // Params:
        //    edges     A list of edges being moved.
        //    mouse     The current mouse position.
        __resize: function (edges, mouse) {
            var width = this.$container.width();
            var height = this.$container.height();
            var offset = this.$container.offset();

            mouse.x -= offset.left;
            mouse.y -= offset.top;

            var minSize = this.minSize();
            var maxSize = this.maxSize();

            var pos = {
                x: (this._pos.x * width) - this._size.x / 2,
                y: (this._pos.y * height) - this._size.y / 2
            };

            for (var i = 0; i < edges.length; ++i) {
                switch (edges[i]) {
                    case 'top':
                        this._size.y += pos.y - mouse.y - 2;
                        pos.y = mouse.y + 2;
                        if (this._size.y < minSize.y) {
                            pos.y += this._size.y - minSize.y;
                            this._size.y = minSize.y;
                        }
                        if (this._size.y > maxSize.y) {
                            pos.y += this._size.y - maxSize.y;
                            this._size.y = maxSize.y;
                        }
                        break;
                    case 'bottom':
                        this._size.y = mouse.y - 4 - pos.y;
                        if (this._size.y < minSize.y) {
                            this._size.y = minSize.y;
                        }
                        if (this._size.y > maxSize.y) {
                            this._size.y = maxSize.y;
                        }
                        break;
                    case 'left':
                        this._size.x += pos.x - mouse.x - 2;
                        pos.x = mouse.x + 2;
                        if (this._size.x < minSize.x) {
                            pos.x += this._size.x - minSize.x;
                            this._size.x = minSize.x;
                        }
                        if (this._size.x > maxSize.x) {
                            pos.x += this._size.x - maxSize.x;
                            this._size.x = maxSize.x;
                        }
                        break;
                    case 'right':
                        this._size.x = mouse.x - 4 - pos.x;
                        if (this._size.x < minSize.x) {
                            this._size.x = minSize.x;
                        }
                        if (this._size.x > maxSize.x) {
                            this._size.x = maxSize.x;
                        }
                        break;
                }

                this._pos.x = (pos.x + this._size.x / 2) / width;
                this._pos.y = (pos.y + this._size.y / 2) / height;
            }
        },

        // Turn off or on a shadowing effect to signify this widget is being moved.
        // Params:
        //    enabled       Whether to enable __shadow mode.
        __shadow: function (enabled) {
            if (enabled) {
                if (!this.$shadower) {
                    this.$shadower = $('<div class="wcFrameShadower">');
                    this.$frame.append(this.$shadower);
                    this.$shadower.animate({
                        opacity: 0.5
                    }, 300);
                }
            } else {
                if (this.$shadower) {
                    var self = this;
                    this.$shadower.animate({
                        opacity: 0.0
                    }, 300)
                        .queue(function (next) {
                            self.$shadower.remove();
                            self.$shadower = null;
                            next();
                        });
                }
            }
        },

        // Retrieves the bounding rect for this frame.
        __rect: function () {
            if (this.isCollapser()) {
                return this._parent.__rect();
            }

            var offset = this.$frame.offset();
            var width = this.$frame.width();
            var height = this.$frame.height();

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            this._curTab = -1;
            for (var i = 0; i < this._panelList.length; ++i) {
                this._panelList[i].__destroy();
            }

            while (this._panelList.length) this._panelList.pop();
            if (this.$modalBlocker) {
                this.$modalBlocker.remove();
                this.$modalBlocker = null;
            }
            this.__container(null);
            this._parent = null;
        }
    });
    return Module;
});


},
'xide/views/History':function(){
/**
 * @module xide/views/History
 */
define([
    'dcl/dcl',
    'xide/utils'
], function (dcl,utils) {
    /**
     * @class module:xide/views/History
     */
    return dcl(null, {
        declaredClass: "xide.views.History",
        duplicates:false,
        _history: null,
        _index: 0,
        constructor: function (options) {
            this._history = [];
            utils.mixin(this,options);
        },

        destroy:function(){
            delete this._history;
        },
        set: function (data) {
            this._history = data;
            this._index = this.length();
        },
        pop: function () {
            this._history.pop();
            this._index = this.length();
        },
        push: function (cmd) {
            if (this._history.indexOf(cmd) == -1 || this.duplicates===true) {
                this._history.push(cmd);
                this._index = this.length();
            }
        },
        length: function () {
            if(this._history) {
                return this._history.length;
            }
        },
        getNext: function () {
            this._index += 1;
            var cmd = this._history[this._index] || "";
            this._index = Math.min(this.length(), this._index);
            return cmd;
        },
        getPrev: function () {
            this._index = Math.max(0, this._index - 1);
            return this._history[this._index];
        },
        remove:function(what){
            this._history && this._history.remove(what);
            this._index = Math.min(this.length(), this._index);
        },
        getNow: function () {
            var index = Math.max(0, this._index - 1);
            if(this._history) {
                return this._history[index];
            }
        },
        setNow: function (what) {
            if(this._history) {
                this._history.remove(what);
                this._history.push(what);
            }
        },
        indexOf:function(what){
            if(this._history) {
                return this._history.indexOf(what);
            }
            return -1;
        }
    });
});
},
'dojo/promise/Promise':function(){
define([
	"../_base/lang"
], function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
});

},
'dgrid/extensions/ColumnResizer':function(){
define([
	'dojo/_base/declare',
	'dojo/on',
	'dojo/query',
	'dojo/_base/lang',
	'dojo/dom',
	'dojo/dom-construct',
	'dojo/dom-geometry',
	'dojo/has',
	'../util/misc',
	'dojo/_base/html'
], function (declare, listen, query, lang, dom, domConstruct, geom, has, miscUtil) {

	function addRowSpan(table, span, startRow, column, id) {
		// loop through the rows of the table and add this column's id to
		// the rows' column
		for (var i = 1; i < span; i++) {
			table[startRow + i][column] = id;
		}
	}
	function subRowAssoc(subRows) {
		// Take a sub-row structure and output an object with key=>value pairs
		// The keys will be the column id's; the values will be the first-row column
		// that column's resizer should be associated with.

		var i = subRows.length,
			l = i,
			numCols = subRows[0].length,
			table = new Array(i);

		// create table-like structure in an array so it can be populated
		// with row-spans and col-spans
		while (i--) {
			table[i] = new Array(numCols);
		}

		var associations = {};

		for (i = 0; i < l; i++) {
			var row = table[i],
				subRow = subRows[i];

			// j: counter for table columns
			// js: counter for subrow structure columns
			for (var j = 0, js = 0; j < numCols; j++) {
				var cell = subRow[js], k;

				// if something already exists in the table (row-span), skip this
				// spot and go to the next
				if (typeof row[j] !== 'undefined') {
					continue;
				}
				row[j] = cell.id;

				if (cell.rowSpan && cell.rowSpan > 1) {
					addRowSpan(table, cell.rowSpan, i, j, cell.id);
				}

				// colSpans are only applicable in the second or greater rows
				// and only if the colSpan is greater than 1
				if (i > 0 && cell.colSpan && cell.colSpan > 1) {
					for (k = 1; k < cell.colSpan; k++) {
						// increment j and assign the id since this is a span
						row[++j] = cell.id;
						if (cell.rowSpan && cell.rowSpan > 1) {
							addRowSpan(table, cell.rowSpan, i, j, cell.id);
						}
					}
				}
				associations[cell.id] = subRows[0][j].id;
				js++;
			}
		}

		return associations;
	}

	function resizeColumnWidth(grid, colId, width, parentType, doResize) {
		// don't react to widths <= 0, e.g. for hidden columns
		if (width <= 0) {
			return;
		}

		var column = grid.columns[colId],
			event,
			rule;

		if (!column) {
			return;
		}

		event = {
			grid: grid,
			columnId: colId,
			width: width,
			bubbles: true,
			cancelable: true
		};

		if (parentType) {
			event.parentType = parentType;
		}

		if (!grid._resizedColumns || listen.emit(grid.headerNode, 'dgrid-columnresize', event)) {
			// Update width on column object, then convert value for CSS
			if (width === 'auto') {
				delete column.width;
			}
			else {
				column.width = width;
				width += 'px';
			}

			rule = grid._columnSizes[colId];

			if (rule) {
				// Modify existing, rather than deleting + adding
				rule.set('width', width);
			}
			else {
				// Use miscUtil function directly, since we clean these up ourselves anyway
				rule = miscUtil.addCssRule('#' + miscUtil.escapeCssIdentifier(grid.domNode.id) +
					' .dgrid-column-' + miscUtil.escapeCssIdentifier(colId, '-'),
					'width: ' + width + ';');
			}

			// keep a reference for future removal
			grid._columnSizes[colId] = rule;

			if (doResize !== false) {
				grid.resize();
			}

			return true;
		}
	}

	// Functions for shared resizer node

	var resizerNode, // DOM node for resize indicator, reused between instances
		resizableCount = 0; // Number of ColumnResizer-enabled grid instances
	var resizer = {
		// This object contains functions for manipulating the shared resizerNode
		create: function () {
			resizerNode = domConstruct.create('div', { className: 'dgrid-column-resizer' });
		},
		destroy: function () {
			domConstruct.destroy(resizerNode);
			resizerNode = null;
		},
		show: function (grid) {
			var pos = geom.position(grid.domNode, true);
			resizerNode.style.top = pos.y + 'px';
			resizerNode.style.height = pos.h + 'px';
			document.body.appendChild(resizerNode);
		},
		move: function (x) {
			resizerNode.style.left = x + 'px';
		},
		hide: function () {
			resizerNode.parentNode.removeChild(resizerNode);
		}
	};

	return declare('dgrid.ColumnResizer',null, {
		resizeNode: null,

		// minWidth: Number
		//		Minimum column width, in px.
		minWidth: 40,

		// adjustLastColumn: Boolean
		//		If true, adjusts the last column's width to "auto" at times where the
		//		browser would otherwise stretch all columns to span the grid.
		adjustLastColumn: true,

		_resizedColumns: false, // flag indicating if resizer has converted column widths to px

		buildRendering: function () {
			this.inherited(arguments);

			// Create resizerNode when first grid w/ ColumnResizer is created
			if (!resizableCount) {
				resizer.create();
			}
			resizableCount++;
		},

		destroy: function () {
			this.inherited(arguments);

			// Remove any applied column size styles since we're tracking them directly
			for (var name in this._columnSizes) {
				this._columnSizes[name].remove();
			}

			// If this is the last grid on the page with ColumnResizer, destroy the
			// shared resizerNode
			if (!--resizableCount) {
				resizer.destroy();
			}
		},

		resizeColumnWidth: function (colId, width) {
			// Summary:
			//      calls grid's styleColumn function to add a style for the column
			// colId: String
			//      column id
			// width: Integer
			//      new width of the column
			return resizeColumnWidth(this, colId, width);
		},

		configStructure: function () {
			var oldSizes = this._oldColumnSizes = lang.mixin({}, this._columnSizes), // shallow clone
				k;

			this._resizedColumns = false;
			this._columnSizes = {};

			this.inherited(arguments);

			// Remove old column styles that are no longer relevant; this is specifically
			// done *after* calling inherited so that _columnSizes will contain keys
			// for all columns in the new structure that were assigned widths.
			for (k in oldSizes) {
				if (!(k in this._columnSizes)) {
					oldSizes[k].remove();
				}
			}
			delete this._oldColumnSizes;
		},

		_configColumn: function (column) {
			this.inherited(arguments);

			var colId = column.id,
				rule;

			if ('width' in column) {
				// Update or add a style rule for the specified width
				if ((rule = this._oldColumnSizes[colId])) {
					rule.set('width', column.width + 'px');
				}
				else {
					rule = miscUtil.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) +
						' .dgrid-column-' + miscUtil.escapeCssIdentifier(colId, '-'),
						'width: ' + column.width + 'px;');
				}
				this._columnSizes[colId] = rule;
			}
		},

		renderHeader: function () {
			this.inherited(arguments);

			var grid = this;

			var assoc;
			if (this.columnSets && this.columnSets.length) {
				var csi = this.columnSets.length;
				while (csi--) {
					assoc = lang.mixin(assoc || {}, subRowAssoc(this.columnSets[csi]));
				}
			}
			else if (this.subRows && this.subRows.length > 1) {
				assoc = subRowAssoc(this.subRows);
			}

			var colNodes = query('.dgrid-cell', grid.headerNode),
				i = colNodes.length;
			while (i--) {
				var colNode = colNodes[i],
					id = colNode.columnId,
					col = grid.columns[id],
					childNodes = colNode.childNodes,
					resizeHandle;

				if (!col || col.resizable === false) {
					continue;
				}

				var headerTextNode = domConstruct.create('div', { className: 'dgrid-resize-header-container' });
				colNode.contents = headerTextNode;

				// move all the children to the header text node
				while (childNodes.length > 0) {
					headerTextNode.appendChild(childNodes[0]);
				}

				resizeHandle = domConstruct.create('div', {
					className: 'dgrid-resize-handle resizeNode-' + miscUtil.escapeCssIdentifier(id, '-')
				}, headerTextNode);
				colNode.appendChild(headerTextNode);
				resizeHandle.columnId = assoc && assoc[id] || id;
			}

			if (!grid.mouseMoveListen) {
				// establish listeners for initiating, dragging, and finishing resize
				listen(grid.headerNode,
					'.dgrid-resize-handle:mousedown' +
						(has('touch') ? ',.dgrid-resize-handle:touchstart' : ''),
					function (e) {
						grid._resizeMouseDown(e, this);
						grid.mouseMoveListen.resume();
						grid.mouseUpListen.resume();
					}
				);
				grid._listeners.push(grid.mouseMoveListen =
					listen.pausable(document,
						'mousemove' + (has('touch') ? ',touchmove' : ''),
						miscUtil.throttleDelayed(function (e) {
							grid._updateResizerPosition(e);
						})
				));
				grid._listeners.push(grid.mouseUpListen = listen.pausable(document,
					'mouseup' + (has('touch') ? ',touchend' : ''),
					function (e) {
						grid._resizeMouseUp(e);
						grid.mouseMoveListen.pause();
						grid.mouseUpListen.pause();
					}
				));
				// initially pause the move/up listeners until a drag happens
				grid.mouseMoveListen.pause();
				grid.mouseUpListen.pause();
			}
		}, // end renderHeader

		_resizeMouseDown: function (e, target) {
			// Summary:
			//      called when mouse button is pressed on the header
			// e: Object
			//      mousedown event object

			// preventDefault actually seems to be enough to prevent browser selection
			// in all but IE < 9.  setSelectable works for those.
			e.preventDefault();
			dom.setSelectable(this.domNode, false);
			this._startX = this._getResizeMouseLocation(e); //position of the target

			this._targetCell = query('.dgrid-column-' + miscUtil.escapeCssIdentifier(target.columnId, '-'),
				this.headerNode)[0];

			// Show resizerNode after initializing its x position
			this._updateResizerPosition(e);
			resizer.show(this);
		},
		_resizeMouseUp: function (e) {
			// Summary:
			//      called when mouse button is released
			// e: Object
			//      mouseup event object

			var columnSizes = this._columnSizes,
				colNodes, colWidths, gridWidth;

			if (this.adjustLastColumn) {
				// For some reason, total column width needs to be 1 less than this
				gridWidth = this.headerNode.clientWidth - 1;
			}

			//This is used to set all the column widths to a static size
			if (!this._resizedColumns) {
				colNodes = query('.dgrid-cell', this.headerNode);

				if (this.columnSets && this.columnSets.length) {
					colNodes = colNodes.filter(function (node) {
						var idx = node.columnId.split('-');
						return idx[0] === '0' && !(node.columnId in columnSizes);
					});
				}
				else if (this.subRows && this.subRows.length > 1) {
					colNodes = colNodes.filter(function (node) {
						return node.columnId.charAt(0) === '0' && !(node.columnId in columnSizes);
					});
				}

				// Get a set of sizes before we start mutating, to avoid
				// weird disproportionate measures if the grid has set
				// column widths, but no full grid width set
				colWidths = colNodes.map(function (colNode) {
					return colNode.offsetWidth;
				});

				// Set a baseline size for each column based on
				// its original measure
				colNodes.forEach(function (colNode, i) {
					resizeColumnWidth(this, colNode.columnId, colWidths[i], null, false);
				}, this);

				this._resizedColumns = true;
			}
			dom.setSelectable(this.domNode, true);


			var cell = this._targetCell,
				delta = this._getResizeMouseLocation(e) - this._startX, //final change in position of resizer
				newWidth = cell.offsetWidth + delta, //the new width after resize
				obj = this._getResizedColumnWidths(),//get current total column widths before resize
				totalWidth = obj.totalWidth,
				lastCol = obj.lastColId,
				lastColWidth = query('.dgrid-column-' + miscUtil.escapeCssIdentifier(lastCol, '-'),
					this.headerNode)[0].offsetWidth;

			if (newWidth < this.minWidth) {
				//enforce minimum widths
				newWidth = this.minWidth;
			}

			if (resizeColumnWidth(this, cell.columnId, newWidth, e.type)) {
				if (cell.columnId !== lastCol && this.adjustLastColumn) {
					if (totalWidth + delta < gridWidth) {
						//need to set last column's width to auto
						resizeColumnWidth(this, lastCol, 'auto', e.type);
					}
					else if (lastColWidth - delta <= this.minWidth) {
						//change last col width back to px, unless it is the last column itself being resized...
						resizeColumnWidth(this, lastCol, this.minWidth, e.type);
					}
				}
			}
			resizer.hide();

			// Clean up after the resize operation
			delete this._startX;
			delete this._targetCell;
		},

		_updateResizerPosition: function (e) {
			// Summary:
			//      updates position of resizer bar as mouse moves
			// e: Object
			//      mousemove event object

			if (!this._targetCell) {
				return; // Release event was already processed
			}

			var mousePos = this._getResizeMouseLocation(e),
				delta = mousePos - this._startX, //change from where user clicked to where they drag
				width = this._targetCell.offsetWidth,
				left = mousePos;
			if (width + delta < this.minWidth) {
				left = this._startX - (width - this.minWidth);
			}
			resizer.move(left);
		},

		_getResizeMouseLocation: function (e) {
			//Summary:
			//      returns position of mouse relative to the left edge
			// e: event object
			//      mouse move event object
			var posX = 0;
			if (e.pageX) {
				posX = e.pageX;
			}
			else if (e.clientX) {
				posX = e.clientX + document.body.scrollLeft +
					document.documentElement.scrollLeft;
			}
			return posX;
		},
		_getResizedColumnWidths: function () {
			//Summary:
			//      returns object containing new column width and column id
			var totalWidth = 0,
				colNodes = query(
					(this.columnSets ? '.dgrid-column-set-cell ' : '') + 'tr:first-child .dgrid-cell',
					this.headerNode);

			var i = colNodes.length;
			if (!i) {
				return {};
			}

			var lastColId = colNodes[i - 1].columnId;

			while (i--) {
				totalWidth += colNodes[i].offsetWidth;
			}
			return {totalWidth: totalWidth, lastColId: lastColId};
		}
	});
});

},
'xide/manager/NotificationManager':function(){
define([
    'dcl/dcl',
    'xide/types',
    'xide/utils',
    'xide/manager/ManagerBase',
    'xide/encoding/MD5'
],function(dcl,types,utils,ManagerBase,MD5){

    return dcl([ManagerBase],{
        declaredClass:"xide.manager.NotificationManager",
        onError:function(err){
            var mess = '';
            if(err && err&& err.error && err.error.message){
                mess = err.error.message;
            }else if(err && _.isString(err)){
                mess = err;
            }else if(err && _.isString(err.message)){
                mess = err.message;
            }
            var args = {
                message: mess,
                type:'error',
                duration: 500,
                showCloseButton: true
            };

            if(mess.indexOf('Stack trace')!==-1){
                args.message = mess.substr(0,mess.indexOf('Stack trace'));
                args.duration = 4000;
            }

            if(err.messageArgs){
                utils.mixin(args,err.messageArgs);
            }
            this.postMessage(args);
        },
        _lastMessageTime:null,
        _lastMessageHash:null,
        onStatus:function(err){
            var mess = '';

            if(err.did!=null){
                return;
            }
            err.did=true;

            if(err && err&& err.message){
                mess = err.message;
            }else if(err && _.isString(err)){
                mess = err;
            }


            if(mess=='Ok!'){
                return ;
            }
            var args = {
                message: mess,
                type:'success',
                duration: 500,
                showCloseButton: true
            };

            utils.mixin(args,err.messageArgs);

            //var timeNow = new Date().getTime();
            /*
            if (thiz.fileUpdateTimes[_path]) {
                var last = thiz.fileUpdateTimes[_path];
                var diff = timeNow - last;
                if (diff < 1000) {
                    thiz.fileUpdateTimes[_path] = timeNow;
                    return;
                }
            }



            thiz.fileUpdateTimes[_path] = timeNow;
            */

            //console.log('print ' + hash,args);

            this.postMessage(args);
        },
        postMessage:function(msg){
            var hash = MD5(JSON.stringify(msg),1);
            var self = this;

            if(this._lastMessageHash===hash){
                setTimeout(function () {
                    self._lastMessageHash=null;
                },2000);
                return;
            }
            this._lastMessageHash = hash;
            if(this._lastMessageTime){
                clearTimeout(this._lastMessageTime);
            }


            if(!this._lastMessageTime) {
                this._lastMessageTime = setTimeout(function () {
                    self._lastMessageHash = null;
                    delete self._lastMessageTime;
                    self._lastMessageTime = null;
                }, 1000);
            }
            return Messenger().post(msg);
        },
        init:function(){
            if($.globalMessenger && typeof Messenger!=='undefined') {
                this.subscribe(types.EVENTS.STATUS,this.onStatus);
                this.subscribe(types.EVENTS.ERROR,this.onError);
                var theme = 'flat';
                $.globalMessenger({
                    theme: theme,
                    extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right'
                });
                Messenger.options = {
                    theme: theme,
                    extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right'
                };
            }else{
                this.postMessage=function(){}
            }
        }
    });
});
},
'xide/model/Bean':function(){
/** @interface xide/model/Bean **/
define([
    "dojo/_base/declare",
    "xide/types",
    "xide/model/Base",
    "xide/utils"
], function (declare, types, Base, utils) {
    utils.mixin(types, {
        /**
         * ActionVisibility
         * @enum module:xide/types/ACTION_VISIBILITY
         * @memberOf module:xide/types
         */
        BEAN_FLAGS: {}
    });
    /**
     * @namespace xide/model
     * @class module:xide/model/Base
     * @interface
     * @constructor
     */
    return declare("xide/model/Bean", [Base], {
        /**
         * Mixin constructor arguments into this.
         * This could have been done in another base class but performance matters
         * @constructor
         */
        constructor: function (args) {
            utils.mixin(this, args);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public interface, keep it small and easy
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Return a human friendly name
         * @abstract
         * @returns {string|null}
         */
        getLabel: function () {
            return null;
        },
        /**
         * Return a unique ID.
         * @abstract
         * @returns {string|null}
         */
        getID: function () {
            return null;
        }
    });
});


},
'dstore/Tree':function(){
define([
	'dojo/_base/declare'
	/*=====, 'dstore/Store'=====*/
], function (declare /*=====, Store=====*/) {
	return declare(null, {
		constructor: function () {
			this.root = this;
		},

		mayHaveChildren: function (object) {
			// summary:
			//		Check if an object may have children
			// description:
			//		This method is useful for eliminating the possibility that an object may have children,
			//		allowing collection consumers to determine things like whether to render UI for child-expansion
			//		and whether a query is necessary to retrieve an object's children.
			// object:
			//		The potential parent
			// returns: boolean

			return 'hasChildren' in object ? object.hasChildren : true;
		},

		getRootCollection: function () {
			// summary:
			//		Get the collection of objects with no parents
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: null });
		},

		getChildren: function (object) {
			// summary:
			//		Get a collection of the children of the provided parent object
			// object:
			//		The parent object
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: this.getIdentity(object) });
		}
	});
});

},
'xide/mixins/EventedMixin':function(){
/** @module xide/mixins/EventedMixin **/
define([
    "dojo/_base/array",
    "dcl/dcl",
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/factory'
], function (array,dcl,declare, has, types, factory) {

    var toString = Object.prototype.toString;
    /**
     * Adds convenient functions for events to the consumer, generalizing dojo.subscribe/publish or dojo.on.
     * This mixin can be applied to anything dijit/_Widget based or custom functional classes(needs to call destroy!)
     *
     * Check online-documentation {@link http://rawgit.com/mc007/xjs/dgrid_update/src/lib/xide/out/xide/0.1.1-dev/EventedMixin.html|here}
     *
     * @class module:xide/mixins/EventedMixin
     */
    var Impl = {

        _didRegisterSubscribers:false,

        subscribers:null,
        /**
         * Subscription filter map
         * @type {Object.<string,boolean}
         */
        subscribes: {},
        /**
         * Emit filter map
         * @type {Object.<string,boolean}
         */
        emits: {},
        /**
         * Array of dojo subscribe/on handles, destroyed on this.destroy();
         * @private
         * @type {Object[]}
         */
        __events: null,
        /**
         * Add emit filter
         * @param type
         * @param data
         */
        addPublishFilter:function(type,data){
            if(type){
                if(data!=null){
                    this.emits[type]=data;
                }else if(type in this.emits){
                    delete this.emits[type];
                }
            }
        },
        /**
         * Simple filter function to block subscriptions.
         * @param key
         * @returns {boolean}
         */
        filterSubscribe: function (key) {

            if (this.subscribes) {
                return this.subscribes[key] !== false;
            }
            return true;
        },
        /**
         * Simple filter function to block publishing.
         * @param key
         * @returns {boolean}
         */
        filterPublish: function (key) {
            if (this.emits) {
                return this.emits[key] !== false;
            }
            return true;
        },
        /**
         * Subscribe to an event or multiple events. Attention, this is NOT checking for duplicates!
         *
         * @example
         *
         * // widget case with event callback delegation to 'this', code is written inside a custom widget or whatever
         * // class subclassing from this mixin:
         * // pre-requisites for dijit/dojox widgets: lang.extend(dijit.Button,EventedMixin.prototype);
         *
         * //simple example #1
         * var button = new dijit.Button({});
         * button.subscribe('click',this.onButtonClick,this);//calls this.onButtonClick with scope this
         *
         * //simple example #2
         * var button = new dijit.Button({});
         * button.subscribe('click',null,this);//calls this.click with scope this
         *
         * //multi-event example #1
         * var button = new dijit.Button({});
         * button.subscribe(['click','dblclick'],null,this);//calls this.click and this.dblclick with scope this
         *
         * // custom events (using dojo-publish/subscribe or dojo.topic)
         * // assuming you want listen to the events of dijit/layout/TabContainer or any other StackContainer. Notice,
         * // that stack-containers will publish events like this: topic.publish(this.id + "-removeChild", page);
         *
         * var tabContainerId = 'tabContainer';
         *
         * this.subscribe(tabContainerId + 'addChild',this.childAdded);//notice that the scope is set here automatically!
         *
         * //multi-event version, this will call this['tabContainerId-addChild'] and this['tabContainerId-removeChild']
         *
         * this.subscribe([tabContainerId + 'addChild',tabContainerId + 'removeChild']);
         *
         *
         *
         *
         *
         *
         * @param keys {String|String[]} : The event key(s), given as single string or an array of strings, holding all
         * event keys for publishing multiple events in one row.
         *
         * @param cb {Function} : callback, by the default the callback's scope will 'this'
         *
         * @param to {Object} : override 'this' scope to something else
         */
        subscribe: function (keys, cb, to) {
            if (!this.__events) {
                this.__events = {};
            }
            var self = this,
                events = factory.subscribe(keys, cb, to || self, self.filterSubscribe.bind(self)),
                container = self.__events;

            //replay on local tracking map
            for(var i=0, l=events.length; i<l ; i++){
                var _type = events[i].type;
                if(!container[_type]){
                    container[_type]=[];
                }
                container[_type].push(events[i]);
            }
            return events;

        },
        /**
         * Publish an event (uses dojo.publish)
         *
         * @param keys {String|String[]} : The event key, given as string or array for publishing multiple events in one row
         *
         * @param data {Object|null} : The actual event data.
         *
         * @param from {Object|null} : Send event 'as' this source. By default, its using 'this' as sender.
         *
         * @param delay {Number|null} : Send event with a delay, otherwise call now
         *
         */
        publish: function (keys, data, from, delay) {
            var self = this;
            if (delay > 0) {
                setTimeout(function () {
                    factory.publish(keys, data, from || self, self.filterPublish.bind(self));
                }.bind(self), delay);
            } else {
                factory.publish(keys, data, from || self, self.filterPublish.bind(self));
            }
        },
        /**
         * @TODO: deal with unsubscribe in _EventedMixin
         * @param key
         * @private
         */
        _destroyHandle: function (key) {},
        /**
         * Turns the lights off, kills all event handles.
         * @private
         * @returns void
         */
        _destroyHandles: function () {
            if (this.__events) {
                for(var type in this.__events){
                    array.forEach(this.__events[type], function(item){
                        if(item && item.remove){
                            item.remove();
                        }
                    });
                }
                delete this.__events;
            }
        },
        /**
         * When using subscribe, all event subscription handles are stored in this.__events.
         * This function will remove all the event handles, using this._destroyHandles()
         */
        destroy: function () {
            this._emit('destroy');
            this.inherited && this.inherited(arguments);
            this._destroyHandles();
        },
        /**
         * Adds a one time listener for the event. This listener is invoked only the
         * next time the event is fired, after which it is removed.
         *
         * @name emitter.once(event, listener)
         * @param {String} event- The event name/id to listen for
         * @param {Function} listener - The function to bind to the event
         * @api public
         *
         * ```javascript
         * db.once('unauthorized', function (req) {
         *     // this event listener will fire once, then be unbound
         * });
         * ```
         */
        once : function(type, listener) {
            var self = this;
            function wrapped() {
                self.unsubscribe(type, listener);
                return listener.apply(self, arguments);
            }
            wrapped.listener = listener;
            self._on(type, wrapped);
            return this;
        },
        /*
        __emit:function(target,type,event){
            event = event || {};
            if (typeof target.emit === 'function' && !target.nodeType) {
                return target.emit(type, event);
            }
            if (target.dispatchEvent && target.ownerDocument && target.ownerDocument.createEvent) {
                var nativeEvent = target.ownerDocument.createEvent('HTMLEvents');
                nativeEvent.initEvent(type, Boolean(event.bubbles), Boolean(event.cancelable));
                for (var key in event) {
                    if (!(key in nativeEvent)) {
                        nativeEvent[key] = event[key];
                    }
                }
                return target.dispatchEvent(nativeEvent);
            }
            throw new Error('Target must be an event emitter');
        },
        */
        /**
         * Execute each of the listeners in order with the supplied arguments.
         *
         * @name emitter.emit(event, [arg1], [arg2], [...])
         * @param {String} event - The event name/id to fire
         * @api public
         */
        _emit:function(type) {
            if (!this.__events)
                return;

            if(!this._didRegisterSubscribers && this.subscribers){
                for(var i=0;i<this.subscribers.length ; i++){
                    var subscriber = this.subscribers[i];
                    this._on(subscriber.event,subscriber.handler,subscriber.owner);
                }
                this._didRegisterSubscribers = true;
            }

            if (arguments[2] === true)
                throw new Error("Please use emit.sticky() instead of passing sticky=true for event: " + type);

            var handler = this.__events[type],
                eventArgs = arguments.length>1 ? arguments[2] : null;

            if (!handler)
                return;

            var returnValue;

            if (typeof handler == 'function') {
                switch (arguments.length) {
                    // fast cases
                    case 1:
                        return handler.call(this);
                    case 2:
                        return handler.call(this, arguments[1]);
                    case 3:
                        return handler.call(this, arguments[1], arguments[2]);
                    // slower
                    default:
                        var args = Array.prototype.slice.call(arguments, 1);
                        returnValue = handler.apply(this, args);
                }
            }

            else if (_.isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);
                var listeners = handler.slice(), temp;
                var _listener = null;
                var who = null;

                for (var i = 0, l = listeners.length; i < l; i++) {

                    _listener = listeners[i];
                    who = _listener.owner|| this;

                    args && args[0] && (args[0].owner = args[0] ? args[0].owner || who : null);

                    _listener.handler && (temp = _listener.handler.apply(who, args));
                    if (temp !== undefined) {
                        returnValue = temp;
                    }

                    args && args[0] && args[0].owner && (args[0].owner = null);


                }
            }

            //forward to global
            eventArgs && eventArgs['public']===true && this.publish(type,args);

            return returnValue;
        },
        /**
         * Remove a listener from the listener array for the specified event. Caution:
         * changes array indices in the listener array behind the listener.
         *
         * @name emitter.removeListener(event, listener)
         * @param {String} event - The event name/id to remove the listener from
         * @param {Function} listener - The listener function to remove
         * @api public
         *
         * ```javascript
         * var callback = function (init) {
         *     console.log('duality app loaded');
         * };
         * devents.on('init', callback);
         * // ...
         * devents.removeListener('init', callback);
         * ```
         */
        unsubscribe:function(type,listener){

            // does not use listeners(), so no side effect of creating __events[type]
            if (!this.__events || !this.__events[type]) return this;

            // no listener given, unsubscribe all per type
            if (('function' !== typeof listener || !listener)) {
                array.forEach(this.__events[type], dojo.unsubscribe);
                delete this.__events[type];
                this.__events[type] = [];
                return this;
            }
            var list = this.__events[type];
            if (_.isArray(list)) {
                var _remove =[];
                _.each(list,function(handle,a,b){
                    var which= handle.handler == listener ? handle.handler : handle.handler.listener == listener ? handle.handler.listener : null;
                    if(which) {
                        _remove.push(handle);
                    }
                });
                _.each(_remove,function(handler){
                    handler.remove();
                });
                if (list.length === 0) {
                    delete this.__events[type];
                }
            }else if ((this.__events[type].listener || this.__events[type]) === listener) {
                delete this.__events[type];
            }
            return this;
        },
        /**
         * Returns an array of listeners for the specified event. This array can be
         * manipulated, e.g. to remove listeners.
         *
         * @name emitter.listeners(event)
         * @param {String} events - The event name/id to return listeners for
         * @api public
         *
         * ```javascript
         * session.on('change', function (stream) {
         *     console.log('session changed');
         * });
         * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]
         * ```
         */
        listeners:function(type) {
            if (!this.__events) this.__events = {};
            if (!this.__events[type]) this.__events[type] = [];
            if (!isArray(this.__events[type])) {
                this.__events[type] = [this.__events[type]];
            }
            return this.__events[type];
        },
        /**
         *
         * @param type
         * @param handle
         * @returns {*}
         */
        addHandle:function(type,handle){
            if(!this.__events){
                this.__events = {}
            }
            if(!this.__events[type]){
                this.__events[type]=[];
            }
            handle.type = type;
            this.__events[type].push(handle);
            return handle;
        },
        /**
         * jQuery sub
         * @param element
         * @param type
         * @param selector
         * @param handler
         * @returns {{handler: *, owner: (exports|module.exports|module:xide/mixins/EventedMixin), type: *, element: (*|jQuery|HTMLElement), selector: *, remove: _handle.remove}}
         */
        __on:function(element,type,selector,handler){

            var _handler = handler;

            if(typeof selector =='function' && !handler){
                //no selector given
                handler = selector;
                selector = null;
            }

            element = element.jquery ? element : $(element);
            element.on(type,selector,handler);

            if (!this.__events) this.__events = {};
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            var eventList = this.__events[type];
            var _handle = {
                handler: _handler,
                owner: this,
                type: type,
                element:element,
                selector:selector,
                remove: function () {
                    eventList.remove(this);
                    this.element.off(this.type,this.selector,this.handler);
                }
            };
            eventList.push(_handle);
            return _handle;

        },
        /**
         * Dojo based sub
         * @param type
         * @param listener
         * @param owner
         * @returns {*}
         * @private
         */
        _on: function(type, listener,owner) {
            try {
                if (!this.__events) this.__events = {};

                if (!this.__events[type]) {
                    this.__events[type] = [];
                }

                var eventList = this.__events[type];


                if (!eventList) {
                    // Optimize the case of one listener. Don't need the extra array object.
                    this.__events[type] = listener;
                }
                else if (_.isArray(eventList)) {

                    if (eventList.indexOf(listener) != -1)
                       return console.warn("adding same listener twice", type);

                    // If we've already got an array, just append.
                    var _handle = {
                        handler: listener,
                        owner: owner || this,
                        type: type,
                        remove: function () {
                            eventList.remove(this);
                            owner && owner.__events && owner.__events[type] && owner.__events[type].remove(this);
                            this.owner = null;
                            this.handler = null;
                            delete this.type;
                        }
                    };
                    eventList.push(_handle);
                    return _handle;
                }
            }catch(e){
                logError(e);
            }
            return this;
        }
    };

    //package via declare
    var Module = declare(null, Impl);
    //static access to Impl.
    Module.Impl = Impl;
    Module.dcl = dcl(null,Impl);
    dcl.chainAfter(Module.dcl,'destroy');
    return Module;
});


},
'xide/Keyboard':function(){
/** @module xide/Keyboard **/
define([
    'xdojo/declare',
    'dcl/dcl',
    'dojo/_base/lang',
    'xide/types',
    'xide/utils/ObjectUtils'    //possibly not loaded yet
], function (declare, dcl, lang, types, utils) {

    /**
     * First things first, mixin KEYBOARD_FLAGS into core types.
     */
    utils.mixin(types, {
        /**
         * KEYBOARD_EVENT describes all possible events a subscriber can listen to.
         *
         * @enum module:xide/types/KEYBOARD_EVENT
         * @memberOf module:xide/types
         */
        KEYBOARD_EVENT: {
            /**
             * Add a custom callback for a key-up event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            UP: 'on_keyup',
            /**
             * Add a custom callback for a key-dow event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            DOWN: 'on_keydown',
            /**
             * Add a custom callback for a release event. This is similar to keyup, but will fire once
             * when ALL of the keys of a combo have been released. If you're unsure, you probably want to
             * ignore this and use UP.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            RELEASE: 'on_release'
        }
    });

    /**
     * Define a public struct for a 'keyboard - mapping
     */
    utils.mixin(types, {

        /**
         * KEYBOARD_MAPPING
         *
         * Keys accepted in human readable format as 'shift s', see the full map:
         *
         _modifier_event_mapping =
         "cmd"   : "metaKey"
         "ctrl"  : "ctrlKey"
         "shift" : "shiftKey"
         "alt"   : "altKey"

         _keycode_alternate_names =
         "escape"        : "esc"
         "control"       : "ctrl"
         "command"       : "cmd"
         "break"         : "pause"
         "windows"       : "cmd"
         "option"        : "alt"
         "caps_lock"     : "caps"
         "apostrophe"    : "\'"
         "semicolon"     : ";"
         "tilde"         : "~"
         "accent"        : "`"
         "scroll_lock"   : "scroll"
         "num_lock"      : "num"

         _keycode_shifted_keys =
         "/"     : "?"
         "."     : ">"
         ","     : "<"
         "\'"    : "\""
         ";"     : ":"
         "["     : "{"
     "]"     : "}"
         "\\"    : "|"
         "`"     : "~"
         "="     : "+"
         "-"     : "_"
         "1"     : "!"
         "2"     : "@"
         "3"     : "#"
         "4"     : "$"
         "5"     : "%"
         "6"     : "^"
         "7"     : "&"
         "8"     : "*"
         "9"     : "("
         "0"     : ")"

         _keycode_dictionary =
         0   : "\\"          # Firefox reports this keyCode when shift is held
         8   : "backspace"
         9   : "tab"
         12  : "num"
         13  : "enter"
         16  : "shift"
         17  : "ctrl"
         18  : "alt"
         19  : "pause"
         20  : "caps"
         27  : "esc"
         32  : "space"
         33  : "pageup"
         34  : "pagedown"
         35  : "end"
         36  : "home"
         37  : "left"
         38  : "up"
         39  : "right"
         40  : "down"
         44  : "print"
         45  : "insert"
         46  : "delete"
         48  : "0"
         49  : "1"
         50  : "2"
         51  : "3"
         52  : "4"
         53  : "5"
         54  : "6"
         55  : "7"
         56  : "8"
         57  : "9"
         65  : "a"
         66  : "b"
         67  : "c"
         68  : "d"
         69  : "e"
         70  : "f"
         71  : "g"
         72  : "h"
         73  : "i"
         74  : "j"
         75  : "k"
         76  : "l"
         77  : "m"
         78  : "n"
         79  : "o"
         80  : "p"
         81  : "q"
         82  : "r"
         83  : "s"
         84  : "t"
         85  : "u"
         86  : "v"
         87  : "w"
         88  : "x"
         89  : "y"
         90  : "z"
         91  : "cmd"
         92  : "cmd"
         93  : "cmd"
         96  : "num_0"
         97  : "num_1"
         98  : "num_2"
         99  : "num_3"
         100 : "num_4"
         101 : "num_5"
         102 : "num_6"
         103 : "num_7"
         104 : "num_8"
         105 : "num_9"
         106 : "num_multiply"
         107 : "num_add"
         108 : "num_enter"
         109 : "num_subtract"
         110 : "num_decimal"
         111 : "num_divide"
         112 : "f1"
         113 : "f2"
         114 : "f3"
         115 : "f4"
         116 : "f5"
         117 : "f6"
         118 : "f7"
         119 : "f8"
         120 : "f9"
         121 : "f10"
         122 : "f11"
         123 : "f12"
         124 : "print"
         144 : "num"
         145 : "scroll"
         186 : ";"
         187 : "="
         188 : ","
         189 : "-"
         190 : "."
         191 : "/"
         192 : "`"
         219 : "["
         220 : "\\"
         221 : "]"
         222 : "\'"
         223 : "`"
         224 : "cmd"
         225 : "alt"
         # Opera weirdness
         57392   : "ctrl"
         63289   : "num"
         # Firefox weirdness
         59 : ";"
         61 : "-"
         173 : "="

         *
         * @class module:xide/types/KEYBOARD_MAPPING
         * @memberOf module:xide/types
         */

        /**
         * KEYBOARD_MAPPING is defines keyboard mapping struct:
         *
         * @memberOf module:xide/types
         * @class module:xide/types/KEYBOARD_EVENT
         *
         */
        KEYBOARD_MAPPING: {
            /**
             * @param keys {string|string[]} the key sequence (see below for the right codes ).
             * This option can be either an array of strings, or a single space separated string of key names that describe
             * the keys that make up the combo.
             */
            keys: null,
            /**
             * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
             * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
             * in the params
             */
            handler: null,
            /**
             * @param scope {Object|null} the scope in which the handler(s) are excecuted.
             */
            scope: null,
            /**
             * @param target {HTMLElement|null} the element on the listerner is bound to. Null means global!
             */
            target: null,
            /**
             * @param type {string|null} the keypress combo type, can be:
             * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
             * counting_combo(keys, on_count_callback); // Registers a counting combo
             * sequence_combo(keys, callback); // Registers a sequence combo
             * register_combo(combo_dictionary); // Registers a combo from a dictionary
             */
            type: null,
            /**
             * @param mixin to override the 'keypress' libraries internal setup for a listener
             * @default {

                prevent_repeat: false,
                prevent_default: false,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: false
            */
            params: null,
            /**
             *
             * @param mouse {Object|null|true|false} filter to setup an addtional trigger constraint for keyboard
             * sequence. Example: mouse.before='mousedown' and keys ='ctrl' will fire the handler when the mouse is hold whilst
             * ctrl key is hold. default:null.
             *
             */
            mouse: {
                brefore: null,//true
                after: null//false
            },
            eventArgs: null
        }

    });

    /**
     * Global array of keypress listeners
     * @type {Object[]}
     * @private
     */
    var listeners = [];
    var byNode = {};

    /**
     * Util to extend a keyboard mapping with control functions per listener. Keyboard mappings can
     * have multiple key sequences and this will take care about stop(), listen() and destroy().
     * @param mapping
     * @param listeners
     */
    var addListenerControls = function (mapping, listeners) {
        mapping.stop = function () {
            return;
            //if(listeners && listeners.length) {
            //    _.invoke(listeners, 'stop_listening');
            //}
        };
        mapping.listen = function () {
            _.invoke(listeners, 'listen');
        };
        mapping.destroy = function () {
            mapping.stop();
            _.each(listeners, function (listener) {
                listener.destroy();
                listeners.remove(listener);
                delete byNode[listener.targetId];
            });
        };
        return mapping;
    };

    /**
     * Safe link to keypress prototype
     * @type {Listener|keypress.Listener}
     * @private
     */
    var keypressProto = window ? window['keypress'] ? window.keypress.Listener : null : null;
    if (!keypressProto) {
        console.error('you need keypress.min.js installed to use xide/Keyboard');
    }

    var Implementation = {
        /**
         * @member listener {Object[]} all keypress listener instances
         */
        _keyboardListeners: null,
        /**
         * The default setup for a listener, this is 'keypress' specific.
         *
         * @returns {{prevent_repeat: boolean, prevent_default: boolean, is_unordered: boolean, is_counting: boolean, is_exclusive: boolean, is_solitary: boolean, is_sequence: boolean}}
         */
        keyPressDefault: function () {
            return {
                prevent_repeat: false,
                prevent_default: true,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: true
            };
        },
        /**
         * Private listener creation method, accepts multiple key sequences for the same handler.
         *
         * @param keys {string|string[]} the key sequence (see below for the right codes ).
         * This option can be either an array of strings, or a single space separated string of key names that describe
         * the keys that make up the combo.
         *
         * @param params {Object|null} an additional parameter structure to override the default 'keypress' setup.
         * See this.keyPressDefault
         *
         * @param scope {Object|null} the scope in which the handler(s) are excecuted, defaults to 'this' as we are
         * a mixin.
         *
         *
         * @param type {string|null} the keypress combo type, can be:
         * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
         * counting_combo(keys, on_count_callback); // Registers a counting combo
         * sequence_combo(keys, callback); // Registers a sequence combo
         * register_combo(combo_dictionary); // Registers a combo from a dictionary
         *
         * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
         * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
         * in the params

         * @param target {HTMLElement|null} the element on the listener is bound to. Null means global!
         *
         * @param eventArgs {array|null} Event arguments passed to the handler. Defaults to keyboard event.
         *
         * @public
         */
        addKeyboardListerner: function (keys, params, type, scope, handler, target, eventArgs) {
            // prepare keypress args
            var _defaults = lang.clone(this.keyPressDefault());
            //mixin override
            utils.mixin(_defaults, params);

            // defaults
            _defaults['this'] = _defaults['this'] || scope || this;

            // use simple_combo as default
            type = type || 'simple_combo';

            //normalize to array
            keys = !_.isArray(keys) ? [keys] : keys;

            var _listeners = [],
                ignore = ['ctrl s', 'ctrl l', 'ctrl r', 'ctrl w', 'ctrl f4', 'shift f4', 'alt tab', 'ctrl tab'];

            _.each(keys, function (key_seq) {
                var targetId = target && target.id ? target.id : 'global',
                    wasCached = target ? !!byNode[targetId] : false,
                    registered = false;

                var listener = byNode[targetId];
                if(listener && listener["_seq"+key_seq]){
                    registered = true;
                }

                if(!registered) {
                    if (!listener) {
                        listener = new keypressProto(target, _defaults);
                        listener.targetId = targetId;
                    }

                    listener["_seq" + key_seq] = true;
                    listener[type](key_seq, function (e) {
                        if (e._did) {
                            return;
                        }
                        e._did = true;
                        var className = e.target.className.toLowerCase();
                        //skip input fields
                        if (e.target.tagName!=='BUTTON' && className.indexOf('input') == -1 || className.indexOf('ace_text-input') != -1) {
                            if (handler && handler.apply) {
                                handler.apply(_defaults['this'], eventArgs || [e]);
                                if (ignore.indexOf(key_seq) !== -1) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        }
                    });
                    if (byNode[targetId]) {

                    } else {
                        byNode[targetId] = listener;
                    }

                    if (!wasCached) {
                        !this._keyboardListeners && (this._keyboardListeners = []);
                        //store in local
                        this._keyboardListeners.push(listener);
                        //store in global
                        _listeners.push(listener);
                    }
                }

            }, this);

            return _listeners;
        },
        /**
         * Public interface to register a keyboard mapping
         * @param mapping {xide/types/KEYBOARD_MAPPING}
         * @returns {xide/types/KEYBOARD_MAPPING}
         */
        registerKeyboardMapping: function (mapping) {
            var listeners = this.addKeyboardListerner(mapping.keys, mapping.params, null, mapping.scope, mapping.handler, mapping.target, mapping.eventArgs);
            mapping.listeners = listeners;
            return addListenerControls(mapping, listeners);
        },
        destroy:function(){
            this.inherited && this.inherited(arguments);
            var targetId = this.id;
            var listener = byNode[targetId];
            if(listener){
                listener.destroy();
                delete byNode[targetId];
            }
        }
    };

    /**
     * Generic keyboard handler, using the external 'keypress' Javascript library
     * which handles keyboard events a bit more elegant and robust, it does allow
     * registration of keyboard - sequences as 'shift s':
     * @example
     *
     * listener.simple_combo("shift s", function() {
     *  console.log("You pressed shift and s");
     * });
     *
     * @link http://dmauro.github.io/Keypress/
     * @link https://github.com/dmauro/Keypress/blob/master/keypress.coffee#L728-864
     */
    var _Keyboard = declare("xide/Keyboard", null, Implementation);
    /**
     * Static mapping factory
     * @param keys
     * @param params
     * @param type
     * @param scope
     * @param handler
     * @param target
     * @param eventArgs
     * @memberOf module:xide/Keyboard
     * @returns {xide/types/KEYBOARD_MAPPING}
     */
    _Keyboard.createMapping = function (keys, params, type, scope, handler, target, eventArgs) {
        var mapping = utils.clone(types.KEYBOARD_MAPPING);//@TODO: bad copy, uses a ctr followed by a lang.mixin
        function getHandler(__handler) {
            return _.isString(__handler) ? lang.hitch(scope, __handler) : __handler;
        }

        mapping.keys = keys;
        mapping.params = params || {};
        mapping.type = type;
        mapping.scope = scope;
        mapping.handler = getHandler(handler);
        mapping.target = target;
        mapping.eventArgs = eventArgs;
        mapping.setHandler = function (event, handler) {
            mapping.params[event] = getHandler(handler);
            return mapping;
        };
        return mapping;

    };

    _Keyboard.defaultMapping = function (keys, handler, params, node, who, args) {
        return _Keyboard.createMapping(keys, params, null, who, handler, node, args);
    };

    _Keyboard.dcl = dcl(null, Implementation);
    _Keyboard.byNode = byNode;
    _Keyboard.listeners = listeners;
    return _Keyboard;
});
},
'xgrid/Layout':function(){
/** @module xgrid/Layout **/
define([
    "xdojo/declare",
    'xide/utils',
    'xide/widgets/TemplatedWidgetBase',
    'xide/registry',
    'xide/$'
], function (declare, utils, TemplatedWidgetBase, registry,$) {
    var template = '<div tabindex="-1" attachTo="template" class="grid-template" style="width: 100%;height: 100%;overflow: hidden;position: relative;padding: 0px;margin: 0px">'+
        '<div tabindex="-1" attachTo="header" class="grid-header row" style="width: 100%;height: auto"></div>'+
        '<div tabindex="0" attachTo="grid" class="grid-body row"></div>'+
        '<div attachTo="footer" class="grid-footer" style="position: absolute;bottom: 0px;width: 100%"></div>'+
    '</div>';
    /**
     *
     * @class module:xgrid/Layout
     */
    var Implementation = {
        template: null,
        attachDirect: true,
        destroy: function () {
            //important,remove us from our temp. template.
            this.template && this.template.remove(this) && utils.destroy(this.template,true,this);
            this.inherited(arguments);
        },
        getTemplateNode: function () {
            return this.template.domNode;
        },
        getHeaderNode: function () {
            return this.template.header;
        },
        getBodyNode: function () {
            return this.template.grid;
        },
        getFooterNode: function () {
            return this.template.footer;
        },
        resize: function () {
            this.inherited(arguments);
            var thiz = this,
                mainNode = thiz.template  ? thiz.template.domNode : this.domNode,
                isRerooted = false;

            if(this.__masterPanel){
                mainNode = this.__masterPanel.containerNode;
                isRerooted= true;
            }
            var totalHeight = $(mainNode).height();
            var template = thiz.template;
            if(!template){
                return;
            }
            var $header =$(template.header);
            var topHeight = $header ? $header.height() : 0;
            var _toolbarHeight = this._toolbar ? this._toolbar._height : 0;
            if(_toolbarHeight>0 && topHeight===0){
                topHeight +=_toolbarHeight;
            }
            if(_toolbarHeight && $header){
                $header.css('height','auto');
            }
            var footerHeight = template.footer ? $(template.footer).height() : 0;
            var finalHeight = totalHeight - topHeight - (footerHeight);

            if (finalHeight > 50) {
                $(template.grid).height(finalHeight + 'px');
                isRerooted && $(template.domNode).width($(mainNode).width());
            } else {
                $(template.grid).height('inherited');
            }


        },
        buildRendering: function () {
            if (this.template) {
                return;
            }
            this._domNode = this.domNode;
            var templated = utils.addWidget(TemplatedWidgetBase, {
                templateString: template,
                declaredClass: 'xgrid/_BaseParent_' + this.declaredClass
            }, null, this.domNode, true);

            $(templated.domNode).attr('tabIndex', -1);

            this.template = templated;
            this.header = templated.header;
            this.footer = templated.footer;
            this.gridBody = templated.grid;
            this.domNode = templated.grid;
            this.id = this.template.id;
            this.domNode.id = this.id;
            templated.domNode.id = this.id;
            registry._hash[this.id] = this;
            templated.add(this);
            return this.inherited(arguments);
        }
    };

    //package via declare
    var _class = declare('xgrid.Layout', null, Implementation);
    _class.Implementation = Implementation;
    return _class;
});

},
'dgrid/Selection':function(){
define([
	'dojo/_base/declare',
	'dojo/dom-class',
	'dojo/on',
	'dojo/has',
	'dojo/aspect',
	'./List',
	'dgrid/util/touch',
	'dojo/query',
	'dojo/_base/sniff',
	'dojo/dom'
], function (declare, domClass, on, has, aspect, List, touchUtil) {

	has.add('dom-comparedocumentposition', function (global, doc, element) {
		return !!element.compareDocumentPosition;
	});

	// Add a feature test for the onselectstart event, which offers a more
	// graceful fallback solution than node.unselectable.
	has.add('dom-selectstart', typeof document.onselectstart !== 'undefined');

	var ctrlEquiv = has('mac') ? 'metaKey' : 'ctrlKey',
		hasUserSelect = has('css-user-select'),
		hasPointer = has('pointer'),
		hasMSPointer = hasPointer && hasPointer.slice(0, 2) === 'MS',
		downType = hasPointer ? hasPointer + (hasMSPointer ? 'Down' : 'down') : 'mousedown',
		upType = hasPointer ? hasPointer + (hasMSPointer ? 'Up' : 'up') : 'mouseup';

	if (hasUserSelect === 'WebkitUserSelect' && typeof document.documentElement.style.msUserSelect !== 'undefined') {
		// Edge defines both webkit and ms prefixes, rendering feature detects as brittle as UA sniffs...
		hasUserSelect = false;
	}

	function makeUnselectable(node, unselectable) {
		// Utility function used in fallback path for recursively setting unselectable
		var value = node.unselectable = unselectable ? 'on' : '',
			elements = node.getElementsByTagName('*'),
			i = elements.length;

		while (--i) {
			if (elements[i].tagName === 'INPUT' || elements[i].tagName === 'TEXTAREA') {
				continue; // Don't prevent text selection in text input fields.
			}
			elements[i].unselectable = value;
		}
	}

	function setSelectable(grid, selectable) {
		// Alternative version of dojo/dom.setSelectable based on feature detection.

		// For FF < 21, use -moz-none, which will respect -moz-user-select: text on
		// child elements (e.g. form inputs).  In FF 21, none behaves the same.
		// See https://developer.mozilla.org/en-US/docs/CSS/user-select
		var node = grid.bodyNode,
			value = selectable ? 'text' : has('ff') < 21 ? '-moz-none' : 'none';

		// In IE10+, -ms-user-select: none will block selection from starting within the
		// element, but will not block an existing selection from entering the element.
		// When using a modifier key, IE will select text inside of the element as well
		// as outside of the element, because it thinks the selection started outside.
		// Therefore, fall back to other means of blocking selection for IE10+.
		// Newer versions of Dojo do not even report msUserSelect (see https://github.com/dojo/dojo/commit/7ae2a43).
		if (hasUserSelect && hasUserSelect !== 'msUserSelect') {
			node.style[hasUserSelect] = value;
		}
		else if (has('dom-selectstart')) {
			// For browsers that don't support user-select but support selectstart (IE<10),
			// we can hook up an event handler as necessary.  Since selectstart bubbles,
			// it will handle any child elements as well.
			// Note, however, that both this and the unselectable fallback below are
			// incapable of preventing text selection from outside the targeted node.
			if (!selectable && !grid._selectstartHandle) {
				grid._selectstartHandle = on(node, 'selectstart', function (evt) {
					var tag = evt.target && evt.target.tagName;

					// Prevent selection except where a text input field is involved.
					if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
						evt.preventDefault();
					}
				});
			}
			else if (selectable && grid._selectstartHandle) {
				grid._selectstartHandle.remove();
				delete grid._selectstartHandle;
			}
		}
		else {
			// For browsers that don't support either user-select or selectstart (Opera),
			// we need to resort to setting the unselectable attribute on all nodes
			// involved.  Since this doesn't automatically apply to child nodes, we also
			// need to re-apply it whenever rows are rendered.
			makeUnselectable(node, !selectable);
			if (!selectable && !grid._unselectableHandle) {
				grid._unselectableHandle = aspect.after(grid, 'renderRow', function (row) {
					makeUnselectable(row, true);
					return row;
				});
			}
			else if (selectable && grid._unselectableHandle) {
				grid._unselectableHandle.remove();
				delete grid._unselectableHandle;
			}
		}
	}

	return declare(null, {
		// summary:
		//		Add selection capabilities to a grid. The grid will have a selection property and
		//		fire "dgrid-select" and "dgrid-deselect" events.

		// selectionDelegate: String
		//		Selector to delegate to as target of selection events.
		selectionDelegate: '.dgrid-row',

		// selectionEvents: String|Function
		//		Event (or comma-delimited events, or extension event) to listen on
		//		to trigger select logic.
		selectionEvents: downType + ',' + upType + ',dgrid-cellfocusin',

		// selectionTouchEvents: String|Function
		//		Event (or comma-delimited events, or extension event) to listen on
		//		in addition to selectionEvents for touch devices.
		selectionTouchEvents: has('touch') ? touchUtil.tap : null,

		// deselectOnRefresh: Boolean
		//		If true, the selection object will be cleared when refresh is called.
		deselectOnRefresh: true,

		// allowSelectAll: Boolean
		//		If true, allow ctrl/cmd+A to select all rows.
		//		Also consulted by the selector plugin for showing select-all checkbox.
		allowSelectAll: false,

		// selection:
		//		An object where the property names correspond to
		//		object ids and values are true or false depending on whether an item is selected
		selection: {},

		// selectionMode: String
		//		The selection mode to use, can be "none", "multiple", "single", or "extended".
		selectionMode: 'extended',

		// allowTextSelection: Boolean
		//		Whether to still allow text within cells to be selected.  The default
		//		behavior is to allow text selection only when selectionMode is none;
		//		setting this property to either true or false will explicitly set the
		//		behavior regardless of selectionMode.
		allowTextSelection: undefined,

		// _selectionTargetType: String
		//		Indicates the property added to emitted events for selected targets;
		//		overridden in CellSelection
		_selectionTargetType: 'rows',

		create: function () {
			this.selection = {};
			return this.inherited(arguments);
		},
		postCreate: function () {
			this.inherited(arguments);

			this._initSelectionEvents();

			// Force selectionMode setter to run
			var selectionMode = this.selectionMode;
			this.selectionMode = '';
			this._setSelectionMode(selectionMode);
		},

		destroy: function () {
			this.inherited(arguments);

			// Remove any extra handles added by Selection.
			if (this._selectstartHandle) {
				this._selectstartHandle.remove();
			}
			if (this._unselectableHandle) {
				this._unselectableHandle.remove();
			}
			if (this._removeDeselectSignals) {
				this._removeDeselectSignals();
			}
		},

		_setSelectionMode: function (mode) {
			// summary:
			//		Updates selectionMode, resetting necessary variables.

			if (mode === this.selectionMode) {
				return;
			}

			// Start selection fresh when switching mode.
			this.clearSelection();

			this.selectionMode = mode;

			// Compute name of selection handler for this mode once
			// (in the form of _fooSelectionHandler)
			this._selectionHandlerName = '_' + mode + 'SelectionHandler';

			// Also re-run allowTextSelection setter in case it is in automatic mode.
			this._setAllowTextSelection(this.allowTextSelection);
		},

		_setAllowTextSelection: function (allow) {
			if (typeof allow !== 'undefined') {
				setSelectable(this, allow);
			}
			else {
				setSelectable(this, this.selectionMode === 'none');
			}
			this.allowTextSelection = allow;
		},

		_handleSelect: function (event, target) {
			// Don't run if selection mode doesn't have a handler (incl. "none"), target can't be selected,
			// or if coming from a dgrid-cellfocusin from a mousedown
			if (!this[this._selectionHandlerName] || !this.allowSelect(this.row(target)) ||
					(event.type === 'dgrid-cellfocusin' && event.parentType === 'mousedown') ||
					(event.type === upType && target !== this._waitForMouseUp)) {
				return;
			}
			this._waitForMouseUp = null;
			this._selectionTriggerEvent = event;

			// Don't call select handler for ctrl+navigation
			if (!event.keyCode || !event.ctrlKey || event.keyCode === 32) {
				// If clicking a selected item, wait for mouseup so that drag n' drop
				// is possible without losing our selection
				if (!event.shiftKey && event.type === downType && this.isSelected(target)) {
					this._waitForMouseUp = target;
				}
				else {
					this[this._selectionHandlerName](event, target);
				}
			}
			this._selectionTriggerEvent = null;
		},

		_singleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "single" mode, where only one target may be
			//		selected at a time.

			var ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv];
			if (this._lastSelected === target) {
				// Allow ctrl to toggle selection, even within single select mode.
				this.select(target, null, !ctrlKey || !this.isSelected(target));
			}
			else {
				this.clearSelection();
				this.select(target);
				this._lastSelected = target;
			}
		},

		_multipleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "multiple" mode, where shift can be held to
			//		select ranges, ctrl/cmd can be held to toggle, and clicks/keystrokes
			//		without modifier keys will add to the current selection.

			var lastRow = this._lastSelected,
				ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv],
				value;

			if (!event.shiftKey) {
				// Toggle if ctrl is held; otherwise select
				value = ctrlKey ? null : true;
				lastRow = null;
			}

			this.select(target, lastRow, value,null,event.type.indexOf('mouse')!==-1 ? 'mouse' : event.type);

			if (!lastRow) {
				// Update reference for potential subsequent shift+select
				// (current row was already selected above)
				this._lastSelected = target;
			}
		},

		_extendedSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "extended" mode, which is like multiple mode
			//		except that clicks/keystrokes without modifier keys will clear
			//		the previous selection.

			// Clear selection first for right-clicks outside selection and non-ctrl-clicks;
			// otherwise, extended mode logic is identical to multiple mode
			if (event.button === 2 ? !this.isSelected(target) :
					!(event.keyCode ? event.ctrlKey : event[ctrlEquiv])) {
				this.clearSelection(null, true);
			}
			this._multipleSelectionHandler(event, target);
		},

		_toggleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "toggle" mode which simply toggles the selection
			//		of the given target.  Primarily useful for touch input.

			this.select(target, null, null);
		},

		_initSelectionEvents: function () {
			// summary:
			//		Performs first-time hookup of event handlers containing logic
			//		required for selection to operate.

			var grid = this,
				contentNode = this.contentNode,
				selector = this.selectionDelegate;

			this._selectionEventQueues = {
				deselect: [],
				select: []
			};

			if (has('touch') && !has('pointer') && this.selectionTouchEvents) {
				// Listen for taps, and also for mouse/keyboard, making sure not
				// to trigger both for the same interaction
				on(contentNode, touchUtil.selector(selector, this.selectionTouchEvents), function (evt) {
					grid._handleSelect(evt, this);
					grid._ignoreMouseSelect = this;
				});
				on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
					if (grid._ignoreMouseSelect !== this) {
						grid._handleSelect(event, this);
					}
					else if (event.type === upType) {
						grid._ignoreMouseSelect = null;
					}
				});
			}
			else {
				// Listen for mouse/keyboard actions that should cause selections
				on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
					grid._handleSelect(event, this);
				});
			}

			// Also hook up spacebar (for ctrl+space)
			if (this.addKeyHandler) {
				this.addKeyHandler(32, function (event) {
					grid._handleSelect(event, event.target);
				});
			}

			// If allowSelectAll is true, bind ctrl/cmd+A to (de)select all rows,
			// unless the event was received from an editor component.
			// (Handler further checks against _allowSelectAll, which may be updated
			// if selectionMode is changed post-init.)
			if (this.allowSelectAll) {
				this.on('keydown', function (event) {
					if (event[ctrlEquiv] && event.keyCode === 65 &&
							!/\bdgrid-input\b/.test(event.target.className)) {
						event.preventDefault();
						grid[grid.allSelected ? 'clearSelection' : 'selectAll']();
					}
				});
			}

			// Update aspects if there is a collection change
			if (this._setCollection) {
				aspect.before(this, '_setCollection', function (collection) {
					grid._updateDeselectionAspect(collection);
				});
			}
			this._updateDeselectionAspect();
		},

		_updateDeselectionAspect: function (collection) {
			// summary:
			//		Hooks up logic to handle deselection of removed items.
			//		Aspects to a trackable collection's notify method if applicable,
			//		or to the list/grid's removeRow method otherwise.

			var self = this,
				signals;

			function ifSelected(rowArg, methodName,why) {
				// Calls a method if the row corresponding to the object is selected.
				var row = self.row(rowArg),
					selection = row && self.selection[row.id];
				// Is the row currently in the selection list.
				if (selection) {
					self[methodName](row,null,true,null,why);
				}
			}

			// Remove anything previously configured
			if (this._removeDeselectSignals) {
				this._removeDeselectSignals();
			}

			if (collection && collection.track && this._observeCollection) {
				signals = [
					aspect.before(this, '_observeCollection', function (collection) {
						signals.push(
							collection.on('delete', function (event) {
								if (typeof event.index === 'undefined') {
									// Call deselect on the row if the object is being removed.  This allows the
									// deselect event to reference the row element while it still exists in the DOM.
									ifSelected(event.id, 'deselect');
								}
							})
						);
					}),
					aspect.after(this, '_observeCollection', function (collection) {
						signals.push(
							collection.on('update', function (event) {
								if (typeof event.index !== 'undefined') {
									// When List updates an item, the row element is removed and a new one inserted.
									// If at this point the object is still in grid.selection,
									// then call select on the row so the element's CSS is updated.
									ifSelected(collection.getIdentity(event.target), 'select','update');
								}
							})
						);
					}, true)
				];
			}
			else {
				signals = [
					aspect.before(this, 'removeRow', function (rowElement, preserveDom) {
						var row;
						if (!preserveDom) {
							row = this.row(rowElement);
							// if it is a real row removal for a selected item, deselect it
							if (row && (row.id in this.selection)) {
								this.deselect(row);
							}
						}
					})
				];
			}

			this._removeDeselectSignals = function () {
				for (var i = signals.length; i--;) {
					signals[i].remove();
				}
				signals = [];
			};
		},

		allowSelect: function () {
			// summary:
			//		A method that can be overriden to determine whether or not a row (or
			//		cell) can be selected. By default, all rows (or cells) are selectable.
			// target: Object
			//		Row object (for Selection) or Cell object (for CellSelection) for the
			//		row/cell in question
			return true;
		},

		_fireSelectionEvent: function (type) {
			// summary:
			//		Fires an event for the accumulated rows once a selection
			//		operation is finished (whether singular or for a range)

			var queue = this._selectionEventQueues[type],
				triggerEvent = this._selectionTriggerEvent,
				eventObject;

			eventObject = {
				bubbles: true,
				grid: this
			};
			if (triggerEvent) {
				eventObject.parentType = triggerEvent.type;
			}
			eventObject[this._selectionTargetType] = queue;

			// Clear the queue so that the next round of (de)selections starts anew
			this._selectionEventQueues[type] = [];

			on.emit(this.contentNode, 'dgrid-' + type, eventObject);
		},

		_fireSelectionEvents: function () {
			var queues = this._selectionEventQueues,
				type;

			for (type in queues) {
				if (queues[type].length) {
					this._fireSelectionEvent(type);
				}
			}
		},

		_select: function (row, toRow, value) {
			// summary:
			//		Contains logic for determining whether to select targets, but
			//		does not emit events.  Called from select, deselect, selectAll,
			//		and clearSelection.

			var selection,
				previousValue,
				element,
				toElement,
				direction;

			if (typeof value === 'undefined') {
				// default to true
				value = true;
			}
			if (!row.element) {
				row = this.row(row);
			}

			// Check whether we're allowed to select the given row before proceeding.
			// If a deselect operation is being performed, this check is skipped,
			// to avoid errors when changing column definitions, and since disabled
			// rows shouldn't ever be selected anyway.
			if (value === false || this.allowSelect(row)) {
				selection = this.selection;
				previousValue = !!selection[row.id];
				if (value === null) {
					// indicates a toggle
					value = !previousValue;
				}
				element = row.element;
				if (!value && !this.allSelected) {
					delete this.selection[row.id];
				}
				else {
					selection[row.id] = value;
				}
				if (element) {
					// add or remove classes as appropriate
					if (value) {
						domClass.add(element, 'dgrid-selected' +
							(this.addUiClasses ? ' ui-state-active' : ''));
					}
					else {
						domClass.remove(element, 'dgrid-selected ui-state-active');
					}
				}
				if (value !== previousValue && element) {
					// add to the queue of row events
					this._selectionEventQueues[(value ? '' : 'de') + 'select'].push(row);
				}

				if (toRow) {
					if (!toRow.element) {
						toRow = this.row(toRow);
					}

					if (!toRow) {
						this._lastSelected = element;
						console.warn('The selection range has been reset because the ' +
							'beginning of the selection is no longer in the DOM. ' +
							'If you are using OnDemandList, you may wish to increase ' +
							'farOffRemoval to avoid this, but note that keeping more nodes ' +
							'in the DOM may impact performance.');
						return;
					}

					toElement = toRow.element;
					if (toElement) {
						direction = this._determineSelectionDirection(element, toElement);
						if (!direction) {
							// The original element was actually replaced
							toElement = document.getElementById(toElement.id);
							direction = this._determineSelectionDirection(element, toElement);
						}
						while (row.element !== toElement && (row = this[direction](row))) {
							this._select(row, null, value);
						}
					}
				}
			}
		},

		// Implement _determineSelectionDirection differently based on whether the
		// browser supports element.compareDocumentPosition; use sourceIndex for IE<9
		_determineSelectionDirection: has('dom-comparedocumentposition') ? function (from, to) {
			var result = to.compareDocumentPosition(from);
			if (result & 1) {
				return false; // Out of document
			}
			return result === 2 ? 'down' : 'up';
		} : function (from, to) {
			if (to.sourceIndex < 1) {
				return false; // Out of document
			}
			return to.sourceIndex > from.sourceIndex ? 'down' : 'up';
		},

		select: function (row, toRow, value) {
			// summary:
			//		Selects or deselects the given row or range of rows.
			// row: Mixed
			//		Row object (or something that can resolve to one) to (de)select
			// toRow: Mixed
			//		If specified, the inclusive range between row and toRow will
			//		be (de)selected
			// value: Boolean|Null
			//		Whether to select (true/default), deselect (false), or toggle
			//		(null) the row

			this._select(row, toRow, value);
			this._fireSelectionEvents();
		},
		deselect: function (row, toRow) {
			// summary:
			//		Deselects the given row or range of rows.
			// row: Mixed
			//		Row object (or something that can resolve to one) to deselect
			// toRow: Mixed
			//		If specified, the inclusive range between row and toRow will
			//		be deselected

			this.select(row, toRow, false);
		},

		clearSelection: function (exceptId, dontResetLastSelected) {
			// summary:
			//		Deselects any currently-selected items.
			// exceptId: Mixed?
			//		If specified, the given id will not be deselected.

			this.allSelected = false;
			for (var id in this.selection) {
				if (exceptId !== id) {
					this._select(id, null, false);
				}
			}
			if (!dontResetLastSelected) {
				this._lastSelected = null;
			}
			this._fireSelectionEvents();
		},
		selectAll: function () {
			this.allSelected = true;
			this.selection = {}; // we do this to clear out pages from previous sorts
			for (var i in this._rowIdToObject) {
				var row = this.row(this._rowIdToObject[i]);
				this._select(row.id, null, true);
			}
			this._fireSelectionEvents();
		},

		isSelected: function (object) {
			// summary:
			//		Returns true if the indicated row is selected.

			if (typeof object === 'undefined' || object === null) {
				return false;
			}
			if (!object.element) {
				object = this.row(object);
			}
/*
            if (typeof object === 'undefined' || object === null) {
                return false;
            }*/


			// First check whether the given row is indicated in the selection hash;
			// failing that, check if allSelected is true (testing against the
			// allowSelect method if possible)
			return (object.id in this.selection) ? !!this.selection[object.id] :
				this.allSelected && (!object.data || this.allowSelect(object));
		},

		refresh: function () {
			if (this.deselectOnRefresh) {
				this.clearSelection();
			}
			this._lastSelected = null;
			return this.inherited(arguments);
		},

		renderArray: function () {
			var rows = this.inherited(arguments),
				selection = this.selection,
				i,
				row,
				selected;

			for (i = 0; i < rows.length; i++) {
				row = this.row(rows[i]);
				selected = row.id in selection ? selection[row.id] : this.allSelected;
				if (selected) {
					this.select(row, null, selected,null,'renderArray');
				}
			}
			this._fireSelectionEvents();
			return rows;
		}
	});
});

},
'wcDocker/layout':function(){
/** @module wcLayout */
define([
    "dcl/dcl",
    "wcDocker/types"
], function (dcl, wcDocker) {

    /**
     * @class
     * The base class for all panel layouts. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} contain these to organize their contents.
     */
    var Module = dcl(null, {
        declaredClass: 'wcLayout',

        /**
         * @memberOf module:wcLayout
         * <b><i>PRIVATE</i> - <u>This should never be constructed directly by the user</u></b>
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this layout.
         * @param {wcLayout|wcSplitter|wcDocker} parent - The layout's parent object.
         */
        constructor: function (container, parent) {
            /**
             * The outer container element of the panel.
             *
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;

            /**
             * The table DOM element for the layout.
             *
             * @member {external:jQuery~Object}
             */
            this.$elem = null;

            this.__init();
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, appending it to the main element.
         * @function module:wcLayout#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         */
        addItem: function (item) {
            // Should be implemented by a sub-class.
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayout#clear
         */
        clear: function () {
            // Should be implemented by a sub-class.
        },

        /**
         * Retrieves the main element.
         * @function module:wcLayout#scene
         * @returns {external:jQuery~Object} - The div item that makes this layout scene.
         */
        scene: function () {
            return this.$elem;
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            // Should be implemented by a sub-class.
        },

        // Updates the size of the layout.
        __update: function () {
            // Should be implemented by a sub-class.
        },

        // Checks if the mouse is in a valid anchor position for nesting another widget.
        // Params:
        //    mouse                 The current mouse position.
        //    same                  Whether we are hovering over the same panel that is being moved.
        //    ghost                 An instance to the ghost object.
        //    canSplit              Whether the original panel can be split.
        //    $elem                 The container element for the target panel.
        //    title                 Whether the panel has a title bar visible.
        //    isTopper              Whether the item being dragged is the top title bar, as apposed to dragging a side or bottom tab/bar.
        //    forceTabOrientation   Force a specific tab orientation.
        //    allowEdges            Whether to allow edge docking.
        __checkAnchorDrop: function (mouse, same, ghost, canSplit, $elem, title, isTopper, forceTabOrientation, allowEdges) {
            var docker = this._parent.docker();
            var width = $elem.outerWidth();
            var height = $elem.outerHeight();
            var offset = $elem.offset();
            var titleSize = $elem.find('.wcFrameTitleBar').height();
            if (!title) {
                titleSize = 0;
            }

            function __getAnchorSizes(value, w, h) {
                if (typeof value === 'number' || (typeof value === 'string' && value.indexOf('px', value.length - 2) !== -1)) {
                    // Pixel sizing.
                    value = parseInt(value);
                    return {
                        x: value,
                        y: value
                    };
                } else if (typeof value === 'string' && value.indexOf('%', value.length - 1) !== -1) {
                    value = parseInt(value) / 100;
                    // Percentage sizing.
                    return {
                        x: w * value,
                        y: h * value
                    };
                } else {
                    // Invalid value.
                    return {x: 0, y: 0};
                }
            }

            var edgeAnchor = __getAnchorSizes(docker._options.edgeAnchorSize, docker.$container.outerWidth(), docker.$container.outerHeight());
            var panelAnchor = __getAnchorSizes(docker._options.panelAnchorSize, width, height);

            // If the target panel has a title, hovering over it (on all sides) will cause stacking
            // and also change the orientation of the tabs (if enabled).
            if (title) {
                // Top title bar
                if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.TOP) &&
                    mouse.y >= offset.top && mouse.y <= offset.top + titleSize &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {

                    // Stacking with top orientation.
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: titleSize - 2,
                        loc: wcDocker.DOCK.STACKED,
                        tab: wcDocker.TAB.TOP,
                        item: this,
                        self: same === wcDocker.TAB.TOP || (isTopper && same)
                    });
                    return true;
                }
                // Any other tab orientation is only valid if tab orientation is enabled.
                else if (docker._canOrientTabs) {
                    // Bottom bar
                    if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.BOTTOM) &&
                        mouse.y >= offset.top + height - titleSize && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left && mouse.x <= offset.left + width) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left - 2,
                            y: offset.top + height - titleSize - 2,
                            w: width,
                            h: titleSize,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.BOTTOM,
                            item: this,
                            self: same === wcDocker.TAB.BOTTOM
                        });
                        return true;
                    }
                    // Left bar
                    else if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.LEFT) &&
                        mouse.y >= offset.top && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left && mouse.x <= offset.left + titleSize) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left - 2,
                            y: offset.top - 2,
                            w: titleSize - 2,
                            h: height,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.LEFT,
                            item: this,
                            self: same === wcDocker.TAB.LEFT
                        });
                        return true;
                    }
                    // Right bar
                    else if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.RIGHT) &&
                        mouse.y >= offset.top && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left + width - titleSize && mouse.x <= offset.left + width) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left + width - titleSize - 2,
                            y: offset.top - 2,
                            w: titleSize,
                            h: height,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.RIGHT,
                            item: this,
                            self: same === wcDocker.TAB.RIGHT
                        });
                        return true;
                    }
                }
            }

            // Test for edge anchoring.
            if (allowEdges && ghost._outer && ghost._inner) {
                var outerWidth = ghost._outer.$container.outerWidth();
                var outerHeight = ghost._outer.$container.outerHeight();
                var outerOffset = ghost._outer.$container.offset();

                // Left edge
                if (mouse.y >= outerOffset.top && mouse.y <= outerOffset.top + outerHeight &&
                    mouse.x >= outerOffset.left + titleSize && mouse.x <= outerOffset.left + titleSize + edgeAnchor.x) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth / 3,
                        h: outerHeight,
                        loc: wcDocker.DOCK.LEFT,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Right edge
                else if (mouse.y >= outerOffset.top && mouse.y <= outerOffset.top + outerHeight &&
                    mouse.x >= outerOffset.left + outerWidth - edgeAnchor.x - titleSize && mouse.x <= outerOffset.left + outerWidth - titleSize) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left + outerWidth - (outerWidth / 3) - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth / 3,
                        h: outerHeight,
                        loc: wcDocker.DOCK.RIGHT,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Top edge
                else if (mouse.y >= outerOffset.top + titleSize && mouse.y <= outerOffset.top + titleSize + edgeAnchor.y &&
                    mouse.x >= outerOffset.left && mouse.x <= outerOffset.left + outerWidth) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth,
                        h: outerHeight / 3,
                        loc: wcDocker.DOCK.TOP,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Bottom edge
                else if (mouse.y >= outerOffset.top + outerHeight - titleSize - edgeAnchor.y && mouse.y <= outerOffset.top + outerHeight - titleSize &&
                    mouse.x >= outerOffset.left && mouse.x <= outerOffset.left + outerWidth) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top + outerHeight - (outerHeight / 3) - 2,
                        w: outerWidth,
                        h: outerHeight / 3,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
            }

            if (!canSplit) {
                return false;
            }

            // Check for placeholder.
            if (this._parent && this._parent.instanceOf('wcPanel') && this._parent._isPlaceholder) {
                ghost.anchor(mouse, {
                    x: offset.left - 2,
                    y: offset.top - 2,
                    w: width,
                    h: height,
                    loc: wcDocker.DOCK.TOP,
                    item: this,
                    self: false
                });
                return true;
            }

            if (width < height) {
                // Top docking.
                if (mouse.y >= offset.top && mouse.y <= offset.top + titleSize + panelAnchor.y &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.TOP,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Bottom side docking.
                if (mouse.y >= offset.top + height - panelAnchor.y - titleSize && mouse.y <= offset.top + height &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top + (height - height * 0.5) - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }

            // Left side docking
            if (mouse.y >= offset.top && mouse.y <= offset.top + height) {
                if (mouse.x >= offset.left && mouse.x <= offset.left + panelAnchor.x + titleSize) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width * 0.5,
                        h: height,
                        loc: wcDocker.DOCK.LEFT,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Right side docking
                if (mouse.x >= offset.left + width - panelAnchor.x - titleSize && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left + width * 0.5 - 2,
                        y: offset.top - 2,
                        w: width * 0.5,
                        h: height,
                        loc: wcDocker.DOCK.RIGHT,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }

            if (width >= height) {
                // Top docking.
                if (mouse.y >= offset.top && mouse.y <= offset.top + panelAnchor.y + titleSize &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.TOP,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Bottom side docking.
                if (mouse.y >= offset.top + height - panelAnchor.y - titleSize && mouse.y <= offset.top + height &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top + (height - height * 0.5) - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }
            return false;
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$elem);
            } else {
                this.$elem.remove();
            }
            return this.$container;
        },

        // Destroys the layout.
        __destroy: function () {
            this.__container(null);
            this._parent = null;
            this.clear();

            this.$elem.remove();
            this.$elem = null;
        }
    });

    return Module;
});


},
'xide/manager/ManagerBase':function(){
/** @module xide/manager/ManagerBase **/
define([
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'xide/utils',
    "dojo/_base/xhr",
    "dojo/_base/kernel"
], function (dcl,EventedMixin,Base,utils,xhr,dojo) {
    /**
     * @class module:xide/manager/ManagerBase
     * @augments module:dojo/Stateful
     * @augments module:xide/mixins/EventedMixin
     * @interface
     */
    var Module =dcl([Base.dcl,EventedMixin.dcl],{
        declaredClass:"xide.manager.ManagerBase",
        /**
         * @type module:xide/manager/ContextBase
         * @member ctx A pointer to a xide context
         */
        ctx: null,
        init: function () {
            this.initReload && this.initReload();
        },
        /**
         *
         * @param title
         * @param scope
         * @param parent
         * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        _getText: function (url,options) {
            var result;
            options = utils.mixin({
                url: url,
                sync: true,
                handleAs: 'text',
                load: function (text) {
                    result = text;
                }
            },options);

            var def = xhr.get(options);
            if(!options.sync){
                return def;
            }
            return '' + result + '';
        },
        /**
         * Return context
         * @returns {module:xcf/manager/Context}
         */
        getContext:function(){
            return this.ctx;
        }
    });

    dcl.chainAfter(Module,'init');
    return Module;
});
},
'dojo/_base/window':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: this["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

 1  && lang.mixin(dojo, ret);

return ret;

});

},
'xide/factory/Objects':function(){
define([
    'dcl/dcl',
    'xide/utils',
    'xide/factory',
    'xdojo/declare'
], function (dcl,utils, factory, declare) {
    /***
     * Convinience object factory via dojo/declare
     * @param classNameOrPrototype
     * @param ctrArgs
     * @param baseClasses
     * @returns {*}
     */
    factory.createInstance = function (classNameOrPrototype, ctrArgs, baseClasses) {
        var ctrArgsFinal = {};
        utils.mixin(ctrArgsFinal, ctrArgs);
        //prepare object prototype, try dojo and then abort
        var objectProtoType = classNameOrPrototype;
        if (_.isString(classNameOrPrototype)) {
            var proto = dojo.getObject(objectProtoType) || dcl.getObject(objectProtoType);
            if (proto) {
                objectProtoType = proto;
            } else {
                console.error('no such class : ' + classNameOrPrototype);
                return null;
            }
        }

        baseClasses && ( objectProtoType = declare(baseClasses, objectProtoType.prototype));

        if(!ctrArgsFinal.id){
            var className = objectProtoType.declaredClass || 'no_class_';
            ctrArgsFinal.id = className.replace(/\//g, "_") + utils.createUUID();
        }

        var instance = new objectProtoType(ctrArgsFinal);

        //@TODO: trash
        instance && ( instance.ctrArgs = ctrArgsFinal);

        return instance;
    };
    return factory;
});
},
'dojo/_base/json':function(){
define(["./kernel", "../json"], function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
});

},
'xide/manager/RPCService':function(){
define([
    'dojo/_base/declare',
    'dojo/_base/kernel',
    'dojo/_base/lang',
    'xide/rpc/Service',
    'xide/rpc/JsonRPC',
    'dojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xide/encoding/SHA1'
], function (declare,dojo,lang, Service, JsonRPC, has, Deferred,utils,types,EventedMixin,SHA1) {
    /**
     * Provides tools to deal with 'persistence' (open files, editors, ..etc to be restored). It also acts as interface.
     * @class module:xide/manager/RPCService
     * @extends module:xide/mixins/EventedMixin
     *
     **/
    return declare("xide.manager.RPCService", [Service,EventedMixin], {
        extraArgs: null,
        signatureField: 'sig',
        signatureToken: null,
        correctTarget: true,
        sync: false,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            var struct = {
                error: err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },
        prepareCall: function () {
            var params = {};
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;

                    this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred();
            options = options || this.defaultOptions;

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this,
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data) {
                deferred.resolve(data);
            };

            var promise = service[serviceClass][method](args);
            promise.then(function (res) {

                //the server has some messages for us
                if (options.checkMessages) {
                    if (res && res.error && res.error.code == 3) {
                        thiz.onMessages(res.error);
                    }
                }

                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (res && res.error && res.error && res.error.code != 0) {
                        thiz.onError(res.error);
                        deferred.reject(res.error);
                        return;
                    }
                }

                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }


                //final delivery
                resolve(res);


            }, function (err) {
                thiz.onError(err);
            });

            return deferred;
        },
        getParameterMap: function (serviceClass, serviceClassMethod) {

            var services = this._smd.services;
            var smd = services[serviceClass + '.' + serviceClassMethod];
            if (smd && smd.parameters) {
                return smd.parameters;
            }
            return [];
        },
        _getRequest: function (method, args) {
            var smd = this._smd;
            var envDef = Service.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || method.params || []).concat(smd.parameters || []);

            if (envDef.namedParams) {
                // the serializer is expecting named params
                if ((args.length == 1) && lang.isObject(args[0])) {
                    // looks like we have what we want
                    args = args[0];
                } else {
                    // they provided ordered, must convert
                    var data = {};
                    var params = method.parameters || method.params;
                    for (var i = 0; i < params.length; i++) {
                        if (typeof args[i] != "undefined" || !params[i].optional) {
                            data[params[i].name] = args[i];
                        }
                    }
                    args = data;
                }
                if (method.strictParameters || smd.strictParameters) {
                    //remove any properties that were not defined
                    for (i in args) {
                        var found = false;
                        for (var j = 0; j < parameters.length; j++) {
                            if (parameters[i].name == i) {
                                found = true;
                            }
                        }
                        if (!found) {
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for (i = 0; i < parameters.length; i++) {
                    var param = parameters[i];
                    if (!param.optional && param.name && args != null && !args[param.name]) {
                        if (param["default"]) {
                            args[param.name] = param["default"];
                        } else if (!(param.name in args)) {
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            } else if (parameters && parameters[0] && parameters[0].name && (args.length == 1) && dojo.isObject(args[0])) {
                // looks like named params, we will convert
                if (envDef.namedParams === false) {
                    // the serializer is expecting ordered params, must be ordered
                    args = Service.toOrdered(parameters, args);
                } else {
                    // named is ok
                    args = args[0];
                }
            }

            if (lang.isObject(this._options)) {
                args = dojo.mixin(args, this._options);
            }

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: this.sync,//dojox.rpc._sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || Service.getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function (method) {
            var args = [];
            var i;
            if (arguments.length == 2 && lang.isArray(arguments[1])) {
                args = arguments[1];
            } else {
                for (i = 1; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            var request = this._getRequest(method, args);
            if (this.correctTarget) {
                request.target = this._smd.target;
            }


            if (this.extraArgs) {
                var index = 0;
                for (var key in this.extraArgs) {

                    request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                    request.target += key + '=' + this.extraArgs[key];
                }
            }
            if (this.signatureToken) {
                request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                var signature = SHA1._hmac(request.data, this.signatureToken, 1);

                /*                  var aParams = {
                 "service": serviceClass + ".get",
                 "path":path,
                 "callback":"asdf",
                 "raw":"html",
                 "attachment":"0",
                 "send":"1",
                 "user":this.config.RPC_PARAMS.rpcUserValue
                 };

                 var pStr  =  dojo.toJson(aParams);
                 var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);

                 console.error('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature);
                 */
                //var pStr  =  dojo.toJson(request.data);

                var signature = SHA1._hmac(request.data, this.signatureToken, 1);
                //console.error('sign ' + request.data + ' with ' +  this.signatureToken + ' to ' + signature);
                request.target += this.signatureField + '=' + signature;
            }

            var deferred = Service.transportRegistry.match(request.transport).fire(request);
            deferred.addBoth(function (results) {
                return request._envDef.deserialize.call(this, results);
            });
            return deferred;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {

            var _service = this,
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.hasMethod(method,serviceClass) && omit === true) {
                debugger;
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },


        /************************************************
         *
         * @param data
         * @returns {*}
         */
        base64_encode: function (data) {
            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        callMethodEx: function (serviceClass, method, args, readyCB, errorCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */

            var thiz = this;
            if (!this[serviceClass] || this[serviceClass][method] == null) {
                if (omitError === true && errorCB) {
                    errorCB({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method + ' in class' + serviceClass]
                    });
                }
                return null;
            }

            /***
             * Build signature
             */
            var params = {};


            /**
             * Mixin mandatory fields
             */
            if (this.config && this.config.RPC_PARAMS) {
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.extraArgs = params;
                this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            }


            this[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }

                if (res && res.error && res.error && res.error.code != 0 && errorCB) {
                    errorCB(res.error);
                    return;
                }
                if (omitError == true) {

                }

            }, function (err) {
                errorCB(err);
            });
        },
        callMethod: function (serviceClass, method, args, readyCB, errorCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            try {
                var thiz = this;
                if (this[serviceClass][method] == null) {
                    if (omitError === true && errorCB) {
                        debugger;
                        errorCB({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                this[serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        console.dir(e);

                    }
                    if (res && res.error && res.error && res.error.code == 1 && errorCB) {
                        errorCB(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        //thiz.publish(types.EVENTS.STATUS,struct ,this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });
            } catch (e) {
                console.error('crash! ' + e);
            }
        }

    });
});
},
'xfile/views/FilePreview':function(){
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    "dojo/cache",
    "dojo/Deferred",
    "dijit/registry",
    "xide/editor/Default",
    "xaction/DefaultActions"
], function (dcl, types,
             utils, EventedMixin,
             _Widget, cache, Deferred, registry, Default, DefaultActions) {

    var plugins = [
        /**
         * Images preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var mimes = ['image/jpeg', 'image/png', 'image/gif'],
                preview = ql.preview;

            // what kind of images we can display
            $.each(navigator.mimeTypes, function (i, o) {
                var mime = o.type;

                if (mime.indexOf('image/') === 0 && $.inArray(mime, mimes)) {
                    mimes.push(mime);
                }
            });

            preview.bind('update', function (e) {
                var file = e.file,
                    img;
                if (!ql.opened()) {
                    return;
                }

                if ($.inArray(file.mime, mimes) !== -1) {
                    // this is our file - stop event propagation
                    e.stopImmediatePropagation();
                    var params = null;
                    if (ql.resizeToPreview) {
                        params = {
                            width: preview.width()
                        }
                    }
                    img = $('<img/>')
                        .hide()
                        .appendTo(preview)
                        .load(function () {
                            // timeout - because of strange safari bug -
                            // sometimes cant get image height 0_o
                            setTimeout(function () {
                                var prop = (img.width() / img.height()).toFixed(2);
                                preview.bind('changesize', function () {
                                    var pw = parseInt(preview.width()),
                                        ph = parseInt(preview.height()),
                                        w, h;

                                    if (prop < (pw / ph).toFixed(2)) {
                                        h = ph;
                                        w = Math.floor(h * prop);
                                    } else {
                                        w = pw;
                                        h = Math.floor(w / prop);
                                    }
                                    img.width(w).height(h).css('margin-top', h < ph ? Math.floor((ph - h) / 2) : 0);

                                }).trigger('changesize');

                                // hide info/icon
                                ql.hideinfo();
                                //show image
                                img.fadeIn(100);

                            }, 1)
                        });
                    img.attr('src', ql.fm.url(file, null, params));
                }
            });
        },

        /**
         * HTML preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var mimes = ['text/html', 'application/xhtml+xml'],
                preview = ql.preview,
                fm = ql.fm;
            preview.bind('update', function (e) {
                var file = e.file, jqxhr;

                if (!ql.opened()) {
                    return;
                }

                if ($.inArray(file.mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    var ctx = ql.ctx;
                    var fm = ctx.getFileManager();
                    fm.getContent(file.mount, file.path, function (content) {
                        ql.hideinfo();
                        doc = $('<iframe class="elfinder-quicklook-preview-html"/>').appendTo(preview)[0].contentWindow.document;
                        doc.open();
                        doc.write(content);
                        doc.close();
                    });
                }
            })
        },

        /**
         * Texts preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                preview = ql.preview;


            var mimes = [
                'application/x-empty',
                'application/javascript',
                'application/xhtml+xml',
                'audio/x-mp3-playlist',
                'application/x-web-config',
                'application/docbook+xml',
                'application/x-php',
                'application/x-perl',
                'application/x-awk',
                'application/x-config',
                'application/x-csh',
                'application/xml',
                'application/x-empty',
                'text/html',
                'text/x-c',
                'text/x-php',
                'text/plain',
                'text/x-c++',
                'text/x-lisp'
            ];

            preview.bind('update', function (e) {
                var file = e.file,
                    mime = file.mime,
                    jqxhr;

                if (!ql.opened()) {
                    return;
                }
                if (mime.indexOf('text/') === 0 || $.inArray(mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    if (ql.useAce) {
                        ql.hideinfo();
                        var _node = $('<div class="elfinder-quicklook-preview-text-wrapper"></div>');

                        _node.appendTo(preview);

                        var editor = ql._editor,
                            wasCached = editor;

                        if (editor) {

                        } else {
                            editor = Default.Implementation.open(file, _node[0], ql.editorOptions, false, ql);
                            ql._editor = editor;
                            //add to _widgets
                            ql.add(editor, null, false);

                            if (DefaultActions.hasAction(ql.editorOptions.permissions, types.ACTION.TOOLBAR)) {
                                var toolbar = editor.getToolbar();
                                if (toolbar) {
                                    $(toolbar.domNode).addClass('bg-opaque');
                                }
                            }
                        }
                        if (wasCached) {
                            _node.append(editor.domNode);
                            editor.set('item', file);
                        }

                        preview.bind('changesize', function () {
                            var pw = parseInt(preview.width()),
                                ph = parseInt(preview.height());
                            utils.resizeTo(editor.domNode, preview[0], true, true);
                            editor.resize();
                        });
                    }
                }
            });
        },
        /**
         * PDF preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                mime = 'application/pdf',
                preview = ql.preview,
                active = false;

            active = false;
            var isActive = false;
            if (isActive) {
                active = true;
            } else {
                $.each(navigator.plugins, function (i, plugins) {
                    $.each(plugins, function (i, plugin) {
                        if (plugin.type == mime) {
                            return !(active = true);
                        }
                    });
                });
            }
            active && preview.bind('update', function (e) {
                var file = e.file, node;
                if (!ql.opened()) {
                    return;
                }

                if (file.mime == mime) {
                    e.stopImmediatePropagation();
                    preview.one('change', function () {
                        node.unbind('load').remove();
                    });

                    node = $('<iframe class="elfinder-quicklook-preview-pdf"/>')
                        .hide()
                        .appendTo(preview)
                        .load(function () {
                            ql.hideinfo();
                            node.show();
                        })
                        .attr('src', ql.fm.url(file));
                }
            })
        },

        /**
         * Flash preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                mime = 'application/x-shockwave-flash',
                preview = ql.preview,
                active = false;

            $.each(navigator.plugins, function (i, plugins) {
                $.each(plugins, function (i, plugin) {
                    if (plugin.type == mime) {
                        return !(active = true);
                    }
                });
            });

            active && preview.bind('update', function (e) {
                var file = e.file,
                    node;
                if (!ql.opened()) {
                    return;
                }
                if (file.mime == mime) {
                    e.stopImmediatePropagation();
                    ql.hideinfo();
                    preview.append((node = $('<embed class="elfinder-quicklook-preview-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" src="' + fm.url(file) + '" quality="high" type="application/x-shockwave-flash" />')));
                }
            });
        },
        /**
         * HTML5 audio preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var preview = ql.preview,
                autoplay = !!ql.options['autoplay'],
                mimes = {
                    'audio/mpeg': 'mp3',
                    'audio/mpeg3': 'mp3',
                    'audio/mp3': 'mp3',
                    'audio/x-mpeg3': 'mp3',
                    'audio/x-mp3': 'mp3',
                    'audio/x-wav': 'wav',
                    'audio/wav': 'wav',
                    'audio/x-m4a': 'm4a',
                    'audio/aac': 'm4a',
                    'audio/mp4': 'm4a',
                    'audio/x-mp4': 'm4a',
                    'audio/ogg': 'ogg'
                },
                node;

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    type = mimes[file.mime];

                if (ql.support.audio[type]) {
                    e.stopImmediatePropagation();

                    node = $('<audio class="elfinder-quicklook-preview-audio" controls preload="auto" autobuffer><source src="' + ql.fm.url(file) + '" /></audio>')
                        .appendTo(preview);
                    autoplay && node[0].play();
                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node[0].pause();
                    node.remove();
                    node = null;
                }
            });
        },

        /**
         * HTML5 video preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {

            var preview = ql.preview,
                autoplay = !!ql.options['autoplay'],
                mimes = {
                    'video/mp4': 'mp4',
                    'video/x-m4v': 'mp4',
                    'video/ogg': 'ogg',
                    'application/ogg': 'ogg',
                    'video/webm': 'webm'
                },
                node;

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    type = mimes[file.mime];

                if (ql.support.video[type]) {
                    e.stopImmediatePropagation();

                    ql.hideinfo();
                    node = $('<video class="elfinder-quicklook-preview-video" controls preload="auto" autobuffer><source src="' + ql.fm.url(file) + '" /></video>').appendTo(preview);
                    autoplay && node[0].play();

                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node[0].pause();
                    node.remove();
                    node = null;
                }
            });
        },
        /**
         * Audio/video preview plugin using browser plugins
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var preview = ql.preview,
                mimes = [],
                node;

            if (!ql.opened()) {
                return;
            }

            $.each(navigator.plugins, function (i, plugins) {
                $.each(plugins, function (i, plugin) {
                    (plugin.type.indexOf('audio/') === 0 || plugin.type.indexOf('video/') === 0) && mimes.push(plugin.type);
                });
            });

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    mime = file.mime,
                    video;
                if ($.inArray(file.mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    (video = mime.indexOf('video/') === 0) && ql.hideinfo();
                    node = $('<embed src="' + ql.fm.url(file) + '" type="' + mime + '" class="elfinder-quicklook-preview-' + (video ? 'video' : 'audio') + '"/>')
                        .appendTo(preview);
                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node.remove();
                    node = null;
                }
            });
        }
    ];
    /**
     * window closed state
     *
     * @type Number
     **/
    var closed = 0,
        /**
         * window opened state
         *
         * @type Number
         **/
        opened = 2,
        /**
         * window animated state
         *
         * @type Number
         **/
        animated = 1;

    var previewClass = dcl([_Widget.dcl, EventedMixin.dcl], {

        resizeToPreview: true,
        useAce: true,
        registerEditors: false,
        editorPermissions: [],
        container: null,
        destroy: function () {
            this.window.empty();
            utils.destroy(this.window[0]);
            this.inherited(arguments);
        },
        /**
         * Init command.
         * Add default plugins and init other plugins
         *
         * @return Object
         **/
        init: function () {

            this.options = {
                autoplay: true,
                jplayer: "extensions/jplayer",
                ui: 'button'
            };
            var o = this.options,
                self = this,
                win = this.window,
                preview = this.preview,
                container = this.container,
                i, p;

            width = o.width > 0 ? parseInt(o.width) : 450;
            height = o.height > 0 ? parseInt(o.height) : 300;
            if (!container) {
                win.appendTo('body').zIndex(20);
            }
            // close window on escape
            $(document).keydown(function (e) {
                e.keyCode == 27 && self.opened() && win.trigger('close')
            });

            if (!container && $.fn.resizable) {
                win.resizable({
                    handles: 'se',
                    minWidth: 350,
                    minHeight: 120,
                    resize: function () {
                        // use another event to avoid recursion in fullscreen mode
                        // may be there is clever solution, but i cant find it :(
                        preview.trigger('changesize');
                    }
                });
            }
            $.each(plugins || [], function (i, plugin) {
                if (typeof(plugin) == 'function') {
                    new plugin(self)
                }
            });

            preview.bind('update', function () {
                self.info.show();
            });
        },
        buildRenderingEmbedded: function () {


            var self = this,
                navicon = this.navicon,
                container = this.container ? $(this.container) : null,
                title = $('<div class="elfinder-quicklook-title" style="display: none">' + self.title + '</div>'),
                icon = $('<div/>'),
                info = $('<div class="elfinder-quicklook-info"/>');//.hide(),


            self.openDfd = new Deferred();

            self.fsicon = $('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrows-alt"/>')
                .mousedown(function (e) {
                    var win = self.window,
                        full = win.is('.' + self.fullscreen),
                        scroll = "scroll.elfinder-finder",
                        $window = $(window);

                    e.stopPropagation();

                    if (full) {
                        win.css(win.data('position')).unbind('mousemove');
                        $window.unbind(scroll).trigger(self.resize).unbind(self.resize);
                        self.navbar.unbind('mouseenter').unbind('mousemove');
                    } else {

                        win.data('position', {
                            left: win.css('left'),
                            top: win.css('top'),
                            width: win.width(),
                            height: win.height()
                        }).css({
                            width: '100%',
                            height: '100%'
                        });

                        $(window).bind(scroll, function () {
                                win.css({
                                    left: parseInt($(window).scrollLeft()) + 'px',
                                    top: parseInt($(window).scrollTop()) + 'px'
                                })
                            })
                            .bind(self.resize, function (e) {
                                self.preview.trigger('changesize');
                            })
                            .trigger(scroll)
                            .trigger(self.resize);

                        win.bind('mousemove', function (e) {
                                self.navbar.stop(true, true).show().delay(3000).fadeOut('slow');
                            })
                            .mousemove();

                        self.navbar.mouseenter(function () {
                                self.navbar.stop(true, true).show();
                            })
                            .mousemove(function (e) {
                                e.stopPropagation();
                            });
                    }

                    self.navbar.attr('style', '').draggable(full ? 'destroy' : {});
                    win.toggleClass(self.fullscreen);
                    $(this).toggleClass(navicon + '-fullscreen-off');
                    if (!parent) {
                        parent = $('.xapp');
                    }
                    //$.fn.resizable && parent.add(win).resizable(full ? 'enable' : 'disable').removeClass('ui-state-disabled');
                    //$.fn.resizable && parent.resizable(full ? 'enable' : 'disable').removeClass('ui-state-disabled');
                });


            //navicon = 'fa-angle'

            /*
             self.navbar = $('<div class="elfinder-quicklook-navbar"/>')
             .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-left"/>').mousedown(function () {
             self.navtrigger(37);
             }))
             .append(self.fsicon)
             .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-right"/>').mousedown(function () {
             self.navtrigger(39);
             }))
             .append('<div class="elfinder-quicklook-navbar-separator"/>')
             .append($('<div class="' + navicon + ' ' + navicon + '-close"/>').mousedown(function () {
             self.window.trigger('close');
             }));

             */

            self.navbar = $('<div class="" style="display: none;"/>');

            self.preview = $('<div class="elfinder-quicklook-preview ui-helper-clearfix"/>')
            // clean info/icon
                .bind('change', function (e) {
                    self.info.attr('style', '').hide();
                    icon.removeAttr('class').attr('style', '');
                    info.html('');

                })
                // update info/icon
                .bind('update', function (e) {
                    var fm = self.fm,
                        preview = self.preview,
                        file = e.file,
                        tpl = '<div class="elfinder-quicklook-info-data">{value}</div>',
                        tmb;

                    if (file) {
                        !file.read && e.stopImmediatePropagation();
                        //self.window.data('hash', file.path);
                        self.preview.unbind('changesize').trigger('change').children().remove();
                        self.info.delay(100).fadeIn(10);

                    } else {
                        e.stopImmediatePropagation();
                    }
                });


            self.info = $('<div class="elfinder-quicklook-info-wrapper"/>')
                .append(icon)
                .append(info);


            self.window = $('<div id="' + self.id + '" class="ui-helper-reset ui-widget elfinder-quicklook widget bg-opaque" style=""/>')
                .click(function (e) {
                    e.stopPropagation();
                })
                .append(self.preview)
                .append(self.info.hide())
                .bind('open', function (e) {

                    self._open = true;

                    var win = self.window,
                        file = self.value,
                        node = self.node;

                    if (self.closed()) {
                        self.update(1, self.value);
                        self.navbar.attr('style', '');
                        self.state = animated;
                        node && node.trigger('scrolltoview');
                        win.css(self.closedCss(node))
                            .show()
                            .animate(self.openedCss(), 550, function () {
                                self.state = opened;
                                self.update(2, self.value);
                                self.openDfd.resolve();
                            });
                    }
                })
                .bind('close', function (e) {

                    var win = self.window,
                        preview = self.preview.trigger('change'),
                        file = self.value,
                        node = {},
                        close = function () {
                            self._open = false;
                            self.state = closed;
                            win.hide();
                            preview.children().remove();
                            self.update(0, self.value);

                        };

                    if (self.opened()) {
                        state = animated;
                        win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                        node.length
                            ? win.animate(self.closedCss(node), 500, close)
                            : close();
                    }
                });


            if (container) {
                console.error('container!');
                container.append(self.window);
            }

            var support = this.supportTest;
            self.support = {

                audio: {
                    ogg: support('audio/ogg; codecs="vorbis"'),
                    mp3: support('audio/mpeg;'),
                    wav: support('audio/wav; codecs="1"'),
                    m4a: support('audio/x-m4a;') || support('audio/aac;')
                },
                video: {
                    ogg: support('video/ogg; codecs="theora"'),
                    webm: support('video/webm; codecs="vp8, vorbis"'),
                    mp4: support('video/mp4; codecs="avc1.42E01E"') || support('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')
                }
            };


        },
        buildRendering: function () {

            var self = this,
                navicon = this.navicon,
                container = this.container ? $(this.container) : null,
                title = $('<div class="elfinder-quicklook-title">' + self.title + '</div>'),
                icon = $('<div/>'),
                info = $('<div class="elfinder-quicklook-info"/>');//.hide(),


            self.openDfd = new Deferred();

            self.fsicon = $('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrows-alt"/>')
                .mousedown(function (e) {
                    var win = self.window,
                        full = win.is('.' + self.fullscreen),
                        scroll = "scroll.elfinder-finder",
                        $window = $(window);

                    e.stopPropagation();

                    if (full) {
                        win.css(win.data('position')).unbind('mousemove');
                        $window.unbind(scroll).trigger(self.resize).unbind(self.resize);
                        self.navbar.unbind('mouseenter').unbind('mousemove');
                    } else {

                        win.data('position', {
                            left: win.css('left'),
                            top: win.css('top'),
                            width: win.width(),
                            height: win.height()
                        }).css({
                            width: '100%',
                            height: '100%'
                        });

                        $(window).bind(scroll, function () {
                                win.css({
                                    left: parseInt($(window).scrollLeft()) + 'px',
                                    top: parseInt($(window).scrollTop()) + 'px'
                                })
                            })
                            .bind(self.resize, function (e) {
                                self.preview.trigger('changesize');
                            })
                            .trigger(scroll)
                            .trigger(self.resize);

                        win.bind('mousemove', function (e) {
                                self.navbar.stop(true, true).show().delay(3000).fadeOut('slow');
                            })
                            .mousemove();

                        self.navbar.mouseenter(function () {
                                self.navbar.stop(true, true).show();
                            })
                            .mousemove(function (e) {
                                e.stopPropagation();
                            });
                    }

                    self.navbar.attr('style', '').draggable(full ? 'destroy' : {});
                    win.toggleClass(self.fullscreen);
                    $(this).toggleClass(navicon + '-fullscreen-off');
                    if (!parent) {
                        parent = $('.xapp');
                    }
                    //$.fn.resizable && parent.add(win).resizable(full ? 'enable' : 'disable').removeClass('ui-state-disabled');
                    //$.fn.resizable && parent.resizable(full ? 'enable' : 'disable').removeClass('ui-state-disabled');
                });


            //navicon = 'fa-angle'

            self.navbar = $('<div class="elfinder-quicklook-navbar"/>')
                .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-left"/>').mousedown(function () {
                    self.navtrigger(37);
                }))
                .append(self.fsicon)
                .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-right"/>').mousedown(function () {
                    self.navtrigger(39);
                }))
                .append('<div class="elfinder-quicklook-navbar-separator"/>')
                .append($('<div class="' + navicon + ' ' + navicon + '-close"/>').mousedown(function () {
                    self.window.trigger('close');
                }));


            self.preview = $('<div class="elfinder-quicklook-preview ui-helper-clearfix"/>')
            // clean info/icon
                .bind('change', function (e) {
                    self.info.attr('style', '').hide();
                    icon.removeAttr('class').attr('style', '');
                    info.html('');

                })
                // update info/icon
                .bind('update', function (e) {
                    var fm = self.fm,
                        preview = self.preview,
                        file = e.file,
                        tpl = '<div class="elfinder-quicklook-info-data">{value}</div>',
                        tmb;

                    if (file) {
                        !file.read && e.stopImmediatePropagation();
                        //self.window.data('hash', file.path);
                        self.preview.unbind('changesize').trigger('change').children().remove();
                        self.info.delay(100).fadeIn(10);

                    } else {
                        e.stopImmediatePropagation();
                    }
                });

            self.info = $('<div class="elfinder-quicklook-info-wrapper"/>')
                .append(icon)
                .append(info);


            self.window = $('<div id="' + self.id + '" class="ui-helper-reset ui-widget elfinder-quicklook widget bg-opaque" style="position:absolute"/>')
                .click(function (e) {
                    e.stopPropagation();
                })
                .append(
                    $('<div class="elfinder-quicklook-titlebar"/>')
                        .append(title)
                        .append($('<span class="fa-close" style="margin-left: 4px; color: white; font-size: 16px; text-align: center; position: absolute; left: 0px; top: 2px;"/>').mousedown(function (e) {
                                e.stopPropagation();
                                self.window.trigger('close');
                            }
                            )
                        )
                )
                .append(self.preview.add(self.navbar))
                .append(self.info.hide())
                .draggable({handle: 'div.elfinder-quicklook-titlebar'})
                .bind('open', function (e) {

                    self._open = true;

                    var win = self.window,
                        file = self.value,
                        node = self.node;

                    if (self.closed()) {
                        self.update(1, self.value);
                        self.navbar.attr('style', '');
                        self.state = animated;
                        node.trigger('scrolltoview');
                        win.css(self.closedCss(node))
                            .show()
                            .animate(self.openedCss(), 550, function () {
                                self.state = opened;
                                self.update(2, self.value);
                                self.openDfd.resolve();
                            });
                    }
                })
                .bind('close', function (e) {

                    var win = self.window,
                        preview = self.preview.trigger('change'),
                        file = self.value,
                        node = {},
                        close = function () {
                            self._open = false;
                            self.state = closed;
                            win.hide();
                            preview.children().remove();
                            self.update(0, self.value);

                        };

                    if (self.opened()) {
                        state = animated;
                        win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                        node.length
                            ? win.animate(self.closedCss(node), 500, close)
                            : close();
                    }
                });


            if (container) {
                console.error('container!');
                container.append(self.window);
            }

            var support = this.supportTest;
            self.support = {

                audio: {
                    ogg: support('audio/ogg; codecs="vorbis"'),
                    mp3: support('audio/mpeg;'),
                    wav: support('audio/wav; codecs="1"'),
                    m4a: support('audio/x-m4a;') || support('audio/aac;')
                },
                video: {
                    ogg: support('video/ogg; codecs="theora"'),
                    webm: support('video/webm; codecs="vp8, vorbis"'),
                    mp4: support('video/mp4; codecs="avc1.42E01E"') || support('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')
                }
            };


        },
        constructor: function (args) {
            utils.mixin(this, args);
        },
        editorOptions: {
            permissions: [
                types.ACTION.TOOLBAR,
                types.ACTION.RELOAD,
                'Editor/Settings',
                'View/Increase Font Size',
                'View/Decrease Font Size',
                'View/Themes',
                'File/Search'
            ]
        },
        title: 'Preview',
        /**
         * Opened window width (from config)
         *
         * @type Number
         **/
        width: 450,
        /**
         * Opened window height (from config)
         *
         * @type Number
         **/
        height: 300,
        fm: null,
        /**
         * window state
         *
         * @type Number
         **/
        state: 0,
        /**
         * navbar icon class
         *
         * @type Number
         **/
        navicon: 'elfinder-quicklook-navbar-icon',
        /**
         * navbar "fullscreen" icon class
         *
         * @type Number
         **/
        fullscreen: 'elfinder-quicklook-fullscreen',
        /**
         * elFinder node
         *
         * @type jQuery
         **/
        parent: null,
        /**
         * elFinder current directory node
         *
         * @type jQuery
         **/

        cwd: null,
        resize: "resize.elfinder-finder",
        /**
         * This command cannot be disable by backend
         *
         * @type Boolean
         **/
        alwaysEnabled: true,
        /**
         * Selected file
         *
         * @type Object
         **/
        value: null,
        handlers: {
            // save selected file
            select: function () {
                this.update(void(0), this.fm.selectedFiles()[0]);
            },
            error: function () {
                self.window.is(':visible') && self.window.data('hash', '').trigger('close');
            },
            'searchshow searchhide': function () {
                this.opened() && this.window.trigger('close');
            }
        },
        shortcuts: [
            {
                pattern: 'space'
            }
        ],
        /**
         * Triger keydown/keypress event with left/right arrow key code
         *
         * @param  Number  left/right arrow key code
         * @return void
         **/
        navtrigger: function (code) {
            $(document).trigger($.Event('keydown', {
                keyCode: code,
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false
            }));
        },
        /**
         * Return css for closed window
         *
         * @param  jQuery  file node in cwd
         * @return void
         **/
        closedCss: function (node) {
            return {
                opacity: 0,
                width: 20,//node.width(),
                height: 20,
                top: node ? node.offset().top + 'px' : 0,
                left: node ? node.offset().left + 'px' : 0
            }
        },
        /**
         * Return css for opened window
         *
         * @return void
         **/
        openedCss: function () {

            var container = this.container ? $(this.container) : null,
                win = container || $(window);

            var w = container ? "100%" : Math.min(this.width, win.   width() - 10);
            var h = container ? "100%" : Math.min(this.height, win.height() - 80);
            return {
                opacity: 1,
                width: w,
                height: h,
                top: parseInt((win.height() - h - 60) / 2 + win.scrollTop()),
                left: parseInt((win.width() - w) / 2 + win.scrollLeft())
            }
        },
        supportTest: function (codec) {
            var media = document.createElement(codec.substr(0, codec.indexOf('/'))),
                value = false;

            try {
                value = media.canPlayType && media.canPlayType(codec);
            } catch (e) {

            }

            return value && value !== '' && value != 'no';
        },
        changeView: function (item) {
            if (this.currentView) {
                utils.destroy(this.currentView);
                if (this.currentView.destroy) {
                    this.currentView.destroy();
                }
            }
        },
        update: function (state) {
            this._open = state;
            this._emit('changeState', state);
            if (state == animated && this.onAnimate) {
                this.onAnimate();
            }
            if (state == opened && this.onOpened) {
                this.onOpened();
            }
            if (state == closed && this.onClosed) {
                this.onClosed();
            }
        },
        /**
         * Return true if quickLoock window is visible and not animated
         *
         * @return Boolean
         **/
        closed: function () {
            return this.state == closed;
        },
        /**
         * Return true if quickLoock window is hidden
         *
         * @return Boolean
         **/
        opened: function () {
            return this.state == opened;
        },
        /**
         * Attach listener to events
         * To bind to multiply events at once, separate events names by space
         *
         * @param  String  event(s) name(s)
         * @param  Object  event handler
         * @return elFinder
         */
        bind: function (event, callback) {
            var i;
            if (typeof(callback) == 'function') {
                event = ('' + event).toLowerCase().split(/\s+/);

                for (i = 0; i < event.length; i++) {
                    if (listeners[event[i]] === void(0)) {
                        listeners[event[i]] = [];
                    }
                    listeners[event[i]].push(callback);
                }
            }
            return this;
        },
        one: function (event, callback) {
            var self = this,
                h = $.proxy(callback, function (event) {
                    setTimeout(function () {
                        self.unbind(event.type, h);
                    }, 3);
                    return callback.apply(this, arguments);
                });
            return this.bind(event, h);
        },
        open: function (e) {
            var self = this,
                win = self.window,
                file = self.value,
                node = self.node;
            self._open = true;
            self.openDfd = new Deferred();
            if (self.closed()) {

                self.navbar.attr('style', '');
                self._open = true;
                self.state = animated;
                node && node.trigger('scrolltoview');
                win.css(self.closedCss(node))
                    .show()
                    .animate(self.openedCss(), 550, function () {
                        self.state = opened;
                        self.update(1, self.value);
                        self.openDfd.resolve();
                    });
            } else {
                self.openDfd.resolve();
            }
            return self.openDfd;
        },
        close: function (e) {
            this._open = false;
            var self = this,
                win = self.window,
                preview = self.preview.trigger('change'),
                file = self.value,
                node = self.node,
                close = function () {
                    self.state = closed;
                    win.hide();
                    preview.children().remove();
                    self.update(0, self.value);
                    self.closeDfd && self.closeDfd.resolve();
                };

            if (self.opened()) {
                self.state = animated;
                win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                node && node.length
                    ? win.animate(self.closedCss(node), 500, close)
                    : close();
            }


            return self.closeDfd;
        },
        getstate: function () {
            return this.state == opened ? 1 : 0;
        },

        exec: function () {
            this.window.trigger(this.opened() ? 'close' : 'open');
        },
        hideinfo: function () {
            this.info.stop(true).hide();
        }
    });

    var filePreviewClass = dcl(previewClass, {
        destroy: function () {
            this.close();
            this.preview.trigger($.Event('update', {file: null}));
            this.inherited(arguments);
            utils.destroy(this._editor);
            utils.destroy(this.preview);
            utils.destroy(this.window);

        },
        onOpened: function () {
            var self = this;
            self.fm = {
                url: function (what, cache, params) {
                    return self.delegate.getImageUrl(what, cache, params);
                }
            }
            self.preview.trigger($.Event('update', {file: self.item}));
        },
        onClosed: function () {
        },
        onAnimate: function () {
        }
    });

    var editorClass = dcl(filePreviewClass, {
        resize: function () {
            this.preview.trigger('changesize');
        },
        constructor: function (args) {
            this.parent = $(args._parent.containerNode);
            this.container = args._parent.containerNode;
            this.resizeToParent = true;
            this.delegate = args.ctx.getFileManager();
            this.item = args.item;
        },
        openItem: function (item) {
            this.id = utils.createUUID();
            registry.add(this);
            this.item = item || this.item;
            this.buildRenderingEmbedded();
            this.init();
            this.exec();
            this.window.css({
                height: '100%',
                width: '100%'
            });
            this._parent.add(this, null, false);
            this.preview.trigger($.Event('update', {file: this.item}));
            this._parent.resize();
            this.resize();
        }
    });

    filePreviewClass.EditorClass = editorClass;
    return filePreviewClass;

});
},
'xbox/Widgets':function(){
define([
    'xide/widgets/TemplatedWidgetBase',
    'xide/widgets/FileWidget'
], function (){});


},
'dojo/json':function(){
define(["./has"], function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
});

},
'xide/data/_Base':function(){
define([
    "dojo/_base/declare",
    'dstore/Memory',
    'dstore/Tree',
    'dstore/QueryResults',
    'xide/mixins/EventedMixin',
    'xide/encoding/MD5',
    'xdojo/has',
    'xide/lodash',
    'dojo/when',
    'dojo/Deferred'
], function (declare, Memory, Tree, QueryResults,EventedMixin,MD5,has,lodash,when,Deferred) {
    return declare("xide/data/_Base",EventedMixin, {
        __all:null,
        allowCache:true,
        _find:function (query) {
            var result = lodash.filter(this.data,query);
            if(lodash.isArray(result)){
                return result;
            }else if(lodash.isObject(result)){
                return [result];
            }
            return [];
        },
        _query:function(query){
            var dfd = new Deferred();
            var collection = this.filter(query);
            when(collection.fetch(), function (data) {
                dfd.resolve(data);
            });
            return dfd;
        },
        constructor: function () {
            var store = this;
            if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {

                this.queryEngine = function (query, options) {
                    options = options || {};

                    var filterQuerierFactory = store._getQuerierFactory('filter');
                    var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

                    var sortQuerierFactory = store._getQuerierFactory('sort');
                    var sort = passthrough;
                    if (sortQuerierFactory) {
                        sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
                            return {
                                property: criteria.attribute,
                                descending: criteria.descending
                            };
                        }));
                    }

                    var range = passthrough;
                    if (!isNaN(options.start) || !isNaN(options.count)) {
                        range = function (data) {
                            var start = options.start || 0,
                                count = options.count || Infinity;

                            var results = data.slice(start, start + count);
                            results.total = data.length;
                            return results;
                        };
                    }

                    return function (data) {
                        return range(sort(filter(data)));
                    };
                };
            }
            var objectStore = this;
            // we call notify on events to mimic the old dojo/store/Trackable
            store.on('add,update,delete', function (event) {
                var type = event.type;
                var target = event.target;
                objectStore.notify(
                    (type === 'add' || type === 'update') ? target : undefined,
                    (type === 'delete' || type === 'update') ?
                        ('id' in event ? event.id : store.getIdentity(target)) : undefined);
            });
        },
        destroy:function(){
            this._emit('destroy',this);
            delete this._queryCache;
            this._queryCache=null;
        },
        notify: function () {
        },
        refreshItem:function(item){
            this.emit('update', {
                target: item
            });
        },
        _queryCache:null,
        query: function (query, options,allowCache) {

            //no query, return all


            if(lodash.isEmpty(query)){
                return _.map(this.data,function(item){
                    return this.getSync(item[this.idProperty]);
                },this);
            }else if(!_.some(query,function (value) { return value == null})){
                //no empty props in query, return lodash.filter
                //return this._find(query);
            }


            var hash = query ? MD5(JSON.stringify(query),1) : null;
            if( false ) {
                if (hash && ! 0  && allowCache !== false) {
                    !this._queryCache && (this._queryCache = {});
                    if (this._queryCache[hash]) {
                        return this._queryCache[hash];
                    }
                }
            }
            /*
            if(!query && !options && allowCache!==false && this.allowCache){
                return this.data;
            }*/

            // summary:
            //		Queries the store for objects. This does not alter the store, but returns a
            //		set of data from the store.
            // query: String|Object|Function
            //		The query to use for retrieving objects from the store.
            // options: dstore/api/Store.QueryOptions
            //		The optional arguments to apply to the resultset.
            // returns: dstore/api/Store.QueryResults
            //		The results of the query, extended with iterative methods.
            //
            // example:
            //		Given the following store:
            //
            //	...find all items where "prime" is true:
            //
            //	|	store.query({ prime: true }).forEach(function(object){
            //	|		// handle each object
            //	|	});
            options = options || {};
            query = query || {};

            var results = this.filter(query);
            var queryResults;

            // Apply sorting
            var sort = options.sort;
            if (sort) {
                if (Object.prototype.toString.call(sort) === '[object Array]') {
                    var sortOptions;
                    while ((sortOptions = sort.pop())) {
                        results = results.sort(sortOptions.attribute, sortOptions.descending);
                    }
                } else {
                    results = results.sort(sort);
                }
            }

            var tracked;
            var _track = false;
            if (_track && results.track && !results.tracking) {
                // if it is trackable, always track, so that observe can
                // work properly.
                results = results.track();
                tracked = true;
            }
            if ('start' in options) {
                // Apply a range
                var start = options.start || 0;
                // object stores support sync results, so try that if available
                queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
                    start: start,
                    end: options.count ? (start + options.count) : Infinity
                });
                queryResults.total = queryResults.totalLength;
            }
            queryResults = queryResults || new QueryResults(results[results.fetchSync ? 'fetchSync' : 'fetch']());
            queryResults.observe = function (callback, includeObjectUpdates) {
                // translate observe to event listeners
                function convertUndefined(value) {
                    if (value === undefined && tracked) {
                        return -1;
                    }
                    return value;
                }

                var addHandle = results.on('add', function (event) {
                    callback(event.target, -1, convertUndefined(event.index));
                });
                var updateHandle = results.on('update', function (event) {
                    if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
                        callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
                    }
                });
                var removeHandle = results.on('delete', function (event) {
                    callback(event.target, convertUndefined(event.previousIndex), -1);
                });
                var handle = {
                    remove: function () {
                        addHandle.remove();
                        updateHandle.remove();
                        removeHandle.remove();
                    }
                };
                handle.cancel = handle.remove;
                return handle;
            };
            if(! false  && hash && ! 0  && allowCache!==false){
                this._queryCache[hash]=queryResults;
            }
            return queryResults;
        }
    });
});
},
'dojo/dnd/Selector':function(){
define([
	"../_base/array", "../_base/declare", "../_base/kernel", "../_base/lang",
	"../dom", "../dom-construct", "../mouse", "../_base/NodeList", "../on", "../touch", "./common", "./Container"
], function(array, declare, kernel, lang, dom, domConstruct, mouse, NodeList, on, touch, dnd, Container){

// module:
//		dojo/dnd/Selector

/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
var __SelectorArgs = declare([Container.__ContainerArgs], {
	// singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	// autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

var Selector = declare("dojo.dnd.Selector", Container, {
	// summary:
	//		a Selector object, which knows how to select its children

	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: __SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			on(this.node, touch.press, lang.hitch(this, "onMouseDown")),
			on(this.node, touch.release, lang.hitch(this, "onMouseUp"))
		);
	},

	// object attributes (for markup)
	singular: false,	// is singular property

	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new NodeList();
		var e = dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dom.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dom.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dom.byId(i);
			this.delItem(i);
			domConstruct.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo/dnd/Container.forInItems()` for details
		o = o || kernel.global;
		var s = this.selection, e = dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map

		Selector.superclass.sync.call(this);

		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}

		// fix the selection
		var t = [], e = dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		array.forEach(t, function(i){
			delete this.selection[i];
		}, this);

		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo/dnd/Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dnd.getCopyKeyState(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(mouse.isLeft(e)){
				// Accept the left button and stop the event.   Stopping the event prevents text selection while
				// dragging.   However, don't stop the event on mobile because that prevents a click event,
				// and also prevents scroll (see #15838).
				// For IE we don't stop event when multiple buttons are pressed.
				e.stopPropagation();
				e.preventDefault();
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dnd.getCopyKeyState(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0, node;
					for(; i < c.length; ++i){
						node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dnd.getCopyKeyState(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dnd.getCopyKeyState(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onMouseUp: function(/*===== e =====*/){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(/*===== e =====*/){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = on(this.node, touch.move, lang.hitch(this, "onMouseMove"));
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		if(this.onmousemoveEvent){
			this.onmousemoveEvent.remove();
			delete this.onmousemoveEvent;
		}
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dom.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

return Selector;

});

},
'xide/widgets/ContextMenu':function(){
define([
    'dcl/dcl',
    'xide/types',
    'xlang/i18',
    "xide/widgets/_Widget",
    'xide/_base/_Widget',
    "xide/mixins/ActionMixin",
    'xaction/ActionContext',
    "xide/widgets/_MenuMixin4",
    "xide/model/Path",
    "xide/_Popup",
    "xide/$",
    "xide/lodash",
    "xide/widgets/_MenuKeyboard"
], function (dcl,types,i18,_Widget,_XWidget,ActionMixin, ActionContext, MenuMixinClass,Path,_Popup,$,_,_MenuKeyboard) {

    var ActionRendererClass = dcl(null, {
        renderTopLevel: function (name, where) {
            where = where || $(this.getRootContainer());
            var item = $('<li class="dropdown">' +
                '<a href="#" class="dropdown-toggle" data-toggle="dropdown">' + i18.localize(name) + '<b class="caret"></b></a>' +
                '</li>');
            where.append(item);
            return item;

        },
        getRootContainer: function () {
            return this.navBar;
        }
    });
    var _debugTree =false;
    var _debugMenuData = false;
    var _debugOldMenuData = false;

    var KeyboardControl = _MenuKeyboard;

    var ContextMenu = dcl([_Widget.dcl, ActionContext.dcl, ActionMixin.dcl, ActionRendererClass,MenuMixinClass,_XWidget.StoreMixin], {
        target: null,
        openTarget:null,
        visibility: types.ACTION_VISIBILITY.CONTEXT_MENU,
        correctSubMenu:true,
        limitTo:null,
        declaredClass:'xide.widgets.ContextMenu',
        menuData:null,
        addContext: function (selector, data) {
            this.menuData = data;
            var id,
                $menu,
                self = this,
                target = this.openTarget ? (this.openTarget) : $(self.target);

            if (typeof data.id !== 'undefined' && typeof data.data !== 'undefined') {
                id = data.id;
                $menu = $('body').find('#dropdown-' + id)[0];
                if (typeof $menu === 'undefined') {
                    $menu = self.buildMenu(data.data, id);
                    selector.append($menu);
                }
            } else {
                var d = new Date();
                id = d.getTime();
                $menu = self.buildMenu(data, id);
                selector.append($menu);
            }

            var options = this.getDefaultOptions();

            this.keyboardController = new KeyboardControl();
            this.keyboardController.setup(this);

            function mouseEnterHandlerSubs(e){
                var navigationData = this.keyboardController.toNavigationData($(e.target),this.getRootContainer());
                if(!navigationData) {
                    return;
                }
                this.keyboardController.clear(navigationData.parent);
                this.menu.focus();
                navigationData.element.focus();
                this.menu.data('currentTarget',navigationData.element);

            }
            function setupContainer($container){
                self.__on($container, 'mouseenter', 'LI', mouseEnterHandlerSubs.bind(self));
            }

            function constextMenuHandler(e) {
                if(self.limitTo){
                    var $target = $(e.target);
                    $target = $target.parent();
                    if(!$target.hasClass(self.limitTo)){
                        return;
                    }
                }
                self.openEvent = e;
                self.isOpen = true;
                this.lastFocused = document.activeElement;
                self.onOpen(e);
                e.preventDefault();
                e.stopPropagation();
                $('.dropdown-context:not(.dropdown-context-sub)').hide();

                var $dd = $('#dropdown-' + id);
                $dd.css('zIndex',_Popup.nextZ(1));
                if(!$dd.data('init')){
                    $dd.data('init',true);
                    setupContainer($dd);
                    self.keyboardController.initContainer($dd);
                }

                if (typeof options.above == 'boolean' && options.above) {
                    $dd.css({
                        top: e.pageY - 20 - $('#dropdown-' + id).height(),
                        left: e.pageX - 13
                    }).fadeIn(options.fadeSpeed);

                } else if (typeof options.above == 'string' && options.above == 'auto') {
                    $dd.removeClass('dropdown-context-up');
                    var autoH = $dd.height() + 0;
                    if ((e.pageY + autoH) > $('html').height()) {
                        var top = e.pageY - 20 - autoH;
                        if(top < 0){
                            top = 20;
                        }
                        $dd.css({
                            top: top + 20,
                            left: e.pageX - 13
                        }).fadeIn(options.fadeSpeed);

                    } else {
                        $dd.css({
                            top: e.pageY - 10,
                            left: e.pageX - 13
                        }).fadeIn(options.fadeSpeed);
                    }
                }

                if (typeof options.left == 'boolean' && options.left) {
                    $dd.addClass('dropdown-context-left').css({
                        left: e.pageX - $dd.width()
                    }).fadeIn(options.fadeSpeed);
                } else if (typeof options.left == 'string' && options.left == 'auto') {
                    $dd.removeClass('dropdown-context-left');
                    var autoL = $dd.width() - 12;
                    if ((e.pageX + autoL) > $('html').width()) {
                        $dd.addClass('dropdown-context-left').css({
                            left: e.pageX - $dd.width() + 13
                        });
                    }
                }
                this.keyboardController.activate($(this.keyboardController.children($dd)[0]),$dd);
            }
            this.__on(target, 'contextmenu', null,constextMenuHandler.bind(this));

            this.__on($menu,'keydown',function(e){
                if(e.keyCode==27){
                    var navData = this.keyboardController.toNavigationData($(e.target),this.getRootContainer());
                    navData && navData.element && this.keyboardController.close(navData.element);
                    $(this.lastFocused).focus();
                }
            }.bind(this));

            return $menu;
        },
        onRootAction:function(){
            return null;
        },
        buildMenu:function (data, id, subMenu,update) {
            var subClass = (subMenu) ? ' dropdown-context-sub' : ' scrollable-menu ',
                menuString = '<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>',
                $menu = update ? (this._rootMenu || $(menuString)) : $(menuString);

            if(!subMenu){
                this._rootMenu = $menu;
                this._rootMenu.addClass('contextMenu')
            }
            $menu.data('data', data);
            return this.buildMenuItems($menu, data, id, subMenu);
        },
        onActionAdded:function(actions){
            this.setActionStore(this.getActionStore(), this,false,true,actions);
        },
        clearAction : function(action){
            var self = this;
            if(action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        onActionRemoved:function(evt){
            this.clearAction(evt.target);
        },
        removeCustomActions:function(){
            var oldStore = this.store;
            if(!oldStore){
                console.warn('removeCustomActions : have no store');
                return;
            }
            var oldActions = oldStore._find({
                custom:true
            });
            var menuData=this.menuData;
            _.each(oldActions,function(action){
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData,{
                    command:action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        setActionStore: function (store, owner,subscribe,update,itemActions) {
            if(!update){
                this._clear();
                this.addActionStore(store);
            }

            var self = this,
                visibility = self.visibility,
                rootContainer = $(self.getRootContainer());
            var tree = update ? self.lastTree : self.buildActionTree(store,owner);

            var allActions = tree.allActions,
                rootActions = tree.rootActions,
                allActionPaths = tree.allActionPaths,
                oldMenuData = self.menuData;

            this.store = store;

            var data = [];


            if(subscribe!==false) {
                if(!this['_handleAdded_' + store.id]) {
                    this.addHandle('added', store._on('onActionsAdded', function (actions) {
                        self.onActionAdded(actions);
                    }));

                    this.addHandle('delete', store.on('delete', function (evt) {
                        self.onActionRemoved(evt);
                    }));
                    this['_handleAdded_' + store.id]=true;
                }
            }

            if(!update) {
                _.each(tree.root, function (menuActions, level) {

                    var root = self.onRootAction(level, rootContainer),
                        lastGroup = '',
                        lastHeader = {
                            header: ''
                        },
                        groupedActions = menuActions.grouped;

                    _.each(menuActions, function (command) {
                        var action = self.getAction(command, store),
                            isDynamicAction = false;

                        if (!action) {
                            isDynamicAction = true;
                            action = self.createAction(command);
                        }
                        if (action) {
                            var renderData = self.getActionData(action);
                            var icon = renderData.icon,
                                label = renderData.label,
                                visibility = renderData.visibility,
                                group = renderData.group;

                            if(visibility.widget){
                                return;
                            }
                            if (!isDynamicAction && group && groupedActions[group] && groupedActions[group].length >= 1) {
                                if (lastGroup !== group) {
                                    var name = groupedActions[group].length >= 2 ? i18.localize(group) : "";
                                    lastHeader = {header: name};
                                    data.push(lastHeader);
                                    lastGroup = group;
                                }
                            }
                            var item = self.toMenuItem(action, owner, label, icon, visibility || {},true);
                            data.push(item);
                            visibility.widget = item;
                            self.addReference(action, item);
                            function parseChildren(command, parent) {
                                var childPaths = new Path(command).getChildren(allActionPaths, false),
                                    isContainer = childPaths.length > 0,
                                    childActions = isContainer ? self.toActions(childPaths, store) : null;
                                if (childActions) {
                                    var subs = [];
                                    _.each(childActions, function (child) {
                                        var _renderData = self.getActionData(child);
                                        var _item = self.toMenuItem(child, owner, _renderData.label, _renderData.icon, _renderData.visibility,true);
                                        self.addReference(child, _item);
                                        subs.push(_item);

                                        var _childPaths = new Path(child.command).getChildren(allActionPaths, false),
                                            _isContainer = _childPaths.length > 0;
                                        if (_isContainer) {
                                            parseChildren(child.command, _item);
                                        }
                                    });
                                    parent.subMenu = subs;
                                }
                            }

                            parseChildren(command, item);
                        }
                    });
                });
                self.attach($('body'), data);
                self.onDidRenderActions(store, owner);
            }else{

                if(itemActions || !_.isEmpty(itemActions)) {
                    _.each(itemActions, function (newAction) {
                        if (newAction) {
                            var action = self.getAction(newAction.command);
                            if (action) {

                                var renderData = self.getActionData(action),
                                    icon = renderData.icon,
                                    label = renderData.label,
                                    aVisibility = renderData.visibility,
                                    group = renderData.group,
                                    item = self.toMenuItem(action, owner, label, icon, aVisibility || {},null,false);

                                aVisibility.widget = item;

                                self.addReference(newAction, item);

                                var parentCommand = action.getParentCommand();
                                var parent = self._findParentData(oldMenuData,parentCommand);
                                if(parent && parent.subMenu){
                                    parent.lazy = true;
                                    parent.subMenu.push(item);
                                }else{
                                    oldMenuData.splice(0, 0, item);
                                }
                            } else {
                                console.error('cant find action ' + newAction.command);
                            }
                        }
                    });

                    self.buildMenu(oldMenuData, self.id,null,update);
                }
            }
        }
    });
    return ContextMenu;
});
},
'xide/mixins/_State':function(){
/** @module xide/mixins/_State**/
define([
    "xdojo/declare"
], function (declare) {
    /**
     * Generic state implementation
     * @class module:xide/mixins/_State
     */
    return declare("xide/mixins/_State",null, {
        getState:function(){
            return this.inherited(arguments) || {};
        },
        setState:function(state){
            return this.inherited(arguments);
        }
    });
});
},
'xlang/i18':function(){
define(['xdojo/declare','xide/utils/ObjectUtils','dcl/dcl'], function (declare,utils,dcl) {

    var defaultLang= {
        language: 'English',
        direction: 'ltr',
        dateFormat: 'M d, Y h:i A', // Mar 13, 2012 05:27 PM
        fancyDateFormat: '$1 h:i A', // will produce smth like: Today 12:25 PM
        messages: {

            /********************************** errors **********************************/
            'error': 'Error',
            'errUnknown': 'Unknown error.',
            'errUnknownCmd': 'Unknown command.',
            'errJqui': 'Invalid jQuery UI configuration. Selectable, draggable and droppable components must be included.',
            'errNode': 'elFinder requires DOM Element to be created.',
            'errURL': 'Invalid elFinder configuration! URL option is not set.',
            'errAccess': 'Access denied.',
            'errConnect': 'Unable to connect to backend.',
            'errAbort': 'Connection aborted.',
            'errTimeout': 'Connection timeout.',
            'errNotFound': 'Backend not found.',
            'errResponse': 'Invalid backend response.',
            'errConf': 'Invalid backend configuration.',
            'errJSON': 'PHP JSON module not installed.',
            'errNoVolumes': 'Readable volumes not available.',
            'errCmdParams': 'Invalid parameters for command "$1".',
            'errDataNotJSON': 'Data is not JSON.',
            'errDataEmpty': 'Data is empty.',
            'errCmdReq': 'Backend request requires command name.',
            'errOpen': 'Unable to open "$1".',
            'errNotFolder': 'Object is not a folder.',
            'errNotFile': 'Object is not a file.',
            'errRead': 'Unable to read "$1".',
            'errWrite': 'Unable to write into "$1".',
            'errPerm': 'Permission denied.',
            'errLocked': '"$1" is locked and can not be renamed, moved or removed.',
            'errExists': 'File named "$1" already exists.',
            'errInvName': 'Invalid file name.',
            'errFolderNotFound': 'Folder not found.',
            'errFileNotFound': 'File not found.',
            'errTrgFolderNotFound': 'Target folder "$1" not found.',
            'errPopup': 'Browser prevented opening popup window. To open file enable it in browser options.',
            'errMkdir': 'Unable to create folder "$1".',
            'errMkfile': 'Unable to create file "$1".',
            'errRename': 'Unable to rename "$1".',
            'errCopyFrom': 'Copying files from volume "$1" not allowed.',
            'errCopyTo': 'Copying files to volume "$1" not allowed.',
            'errUpload': 'Upload error.',  // old name - errUploadCommon
            'errUploadFile': 'Unable to upload "$1".', // old name - errUpload
            'errUploadNoFiles': 'No files found for upload.',
            'errUploadTotalSize': 'Data exceeds the maximum allowed size.', // old name - errMaxSize
            'errUploadFileSize': 'File exceeds maximum allowed size.', //  old name - errFileMaxSize
            'errUploadMime': 'File type not allowed.',
            'errUploadTransfer': '"$1" transfer error.',
            'errNotReplace': 'Object "$1" already exists at this location and can not be replaced by object with another type.', // new
            'errReplace': 'Unable to replace "$1".',
            'errSave': 'Unable to save "$1".',
            'errCopy': 'Unable to copy "$1".',
            'errMove': 'Unable to move "$1".',
            'errCopyInItself': 'Unable to copy "$1" into itself.',
            'errRm': 'Unable to remove "$1".',
            'errRmSrc': 'Unable remove source file(s).',
            'errExtract': 'Unable to extract files from "$1".',
            'errArchive': 'Unable to create archive.',
            'errArcType': 'Unsupported archive type.',
            'errNoArchive': 'File is not archive or has unsupported archive type.',
            'errCmdNoSupport': 'Backend does not support this command.',
            'errReplByChild': 'The folder $1 cant be replaced by an item it contains.',
            'errArcSymlinks': 'For security reason denied to unpack archives contains symlinks or files with not allowed names.', // edited 24.06.2012
            'errArcMaxSize': 'Archive files exceeds maximum allowed size.',
            'errResize': 'Unable to resize "$1".',
            'errResizeDegree': 'Invalid rotate degree.',  // added 7.3.2013
            'errResizeRotate': 'Image dose not rotated.',  // added 7.3.2013
            'errResizeSize': 'Invalid image size.',  // added 7.3.2013
            'errResizeNoChange': 'Image size not changed.',  // added 7.3.2013
            'errUsupportType': 'Unsupported file type.',
            'errNotUTF8Content': 'File "$1" is not in UTF-8 and cannot be edited.',  // added 9.11.2011
            'errNetMount': 'Unable to mount "$1".', // added 17.04.2012
            'errNetMountNoDriver': 'Unsupported protocol.',     // added 17.04.2012
            'errNetMountFailed': 'Mount failed.',         // added 17.04.2012
            'errNetMountHostReq': 'Host required.', // added 18.04.2012
            'errSessionExpires': 'Your session has expired due to inactivity.',
            'errCreatingTempDir': 'Unable to create temporary directory: "$1"',
            'errFtpDownloadFile': 'Unable to download file from FTP: "$1"',
            'errFtpUploadFile': 'Unable to upload file to FTP: "$1"',
            'errFtpMkdir': 'Unable to create remote directory on FTP: "$1"',
            'errArchiveExec': 'Error while archiving files: "$1"',
            'errExtractExec': 'Error while extracting files: "$1"',

            /******************************* commands names ********************************/
            'cmdarchive': 'Create archive',
            'cmdback': 'Back',
            'cmdcopy': 'Copy',
            'cmdcut': 'Cut',
            'cmddownload': 'Download',
            'cmdduplicate': 'Duplicate',
            'cmdedit': 'Edit file',
            'cmdextract': 'Extract files from archive',
            'cmdforward': 'Forward',
            'cmdgetfile': 'Select files',
            'cmdhelp': 'About this software',
            'cmdhome': 'Home',
            'cmdinfo': 'Get info',
            'cmdmkdir': 'New folder',
            'cmdmkfile': 'New text file',
            'cmdopen': 'Open',
            'cmdpaste': 'Paste',
            'cmdquicklook': 'Preview',
            'cmdreload': 'Reload',
            'cmdrename': 'Rename',
            'cmdrm': 'Delete',
            'cmdsearch': 'Find files',
            'cmdup': 'Go to parent directory',
            'cmdupload': 'Upload files',
            'cmdview': 'View',
            'cmdresize': 'Resize & Rotate',
            'cmdsort': 'Sort',
            'cmdnetmount': 'Mount network volume', // added 18.04.2012

            /*********************************** buttons ***********************************/
            'btnClose': 'Close',
            'btnSave': 'Save',
            'btnRm': 'Remove',
            'btnApply': 'Apply',
            'btnCancel': 'Cancel',
            'btnNo': 'No',
            'btnYes': 'Yes',
            'btnMount': 'Mount',  // added 18.04.2012

            /******************************** notifications ********************************/
            'ntfopen': 'Open folder',
            'ntffile': 'Open file',
            'ntfreload': 'Reload folder content',
            'ntfmkdir': 'Creating directory',
            'ntfmkfile': 'Creating files',
            'ntfrm': 'Delete files',
            'ntfcopy': 'Copy files',
            'ntfmove': 'Move files',
            'ntfprepare': 'Prepare to copy files',
            'ntfrename': 'Rename files',
            'ntfupload': 'Uploading files',
            'ntfdownload': 'Downloading files',
            'ntfsave': 'Save files',
            'ntfarchive': 'Creating archive',
            'ntfextract': 'Extracting files from archive',
            'ntfsearch': 'Searching files',
            'ntfresize': 'Resizing images',
            'ntfsmth': 'Doing something',
            'ntfloadimg': 'Loading image',
            'ntfnetmount': 'Mounting network volume', // added 18.04.2012
            'ntfdim': 'Acquiring image dimension', // added 20.05.2013

            /************************************ dates **********************************/
            'dateUnknown': 'unknown',
            'Today': 'Today',
            'Yesterday': 'Yesterday',
            'msJan': 'Jan',
            'msFeb': 'Feb',
            'msMar': 'Mar',
            'msApr': 'Apr',
            'msMay': 'May',
            'msJun': 'Jun',
            'msJul': 'Jul',
            'msAug': 'Aug',
            'msSep': 'Sep',
            'msOct': 'Oct',
            'msNov': 'Nov',
            'msDec': 'Dec',
            'January': 'January',
            'February': 'February',
            'March': 'March',
            'April': 'April',
            'May': 'May',
            'June': 'June',
            'July': 'July',
            'August': 'August',
            'September': 'September',
            'October': 'October',
            'November': 'November',
            'December': 'December',
            'Sunday': 'Sunday',
            'Monday': 'Monday',
            'Tuesday': 'Tuesday',
            'Wednesday': 'Wednesday',
            'Thursday': 'Thursday',
            'Friday': 'Friday',
            'Saturday': 'Saturday',
            'Sun': 'Sun',
            'Mon': 'Mon',
            'Tue': 'Tue',
            'Wed': 'Wed',
            'Thu': 'Thu',
            'Fri': 'Fri',
            'Sat': 'Sat',

            /******************************** sort variants ********************************/
            'sortname': 'by name',
            'sortkind': 'by kind',
            'sortsize': 'by size',
            'sortdate': 'by date',
            'sortFoldersFirst': 'Folders first',

            /********************************** messages **********************************/
            'moveup':'Move Up',
            'movedown':'Move Down',
            'moveleft':'Move Left',
            'moveright':'Move Right',

            'edit':'Edit',
            'confirmReq': 'Confirmation required',
            'confirmRm': 'Are you sure you want to remove files?<br/>This cannot be undone!',
            'confirmRepl': 'Replace old file with new one?',
            'apllyAll': 'Apply to all',
            'name': 'Name',
            'size': 'Size',
            'perms': 'Permissions',
            'modify': 'Modified',
            'kind': 'Kind',
            'read': 'read',
            'write': 'write',
            'noaccess': 'no access',
            'and': 'and',
            'unknown': 'unknown',
            'selectall': 'Select all files',
            'selectfiles': 'Select file(s)',
            'selectffile': 'Select first file',
            'selectlfile': 'Select last file',
            'viewlist': 'List view',
            'viewicons': 'Icons view',
            'places': 'Places',
            'calc': 'Calculate',
            'path': 'Path',
            'aliasfor': 'Alias for',
            'locked': 'Locked',
            'dim': 'Dimensions',
            'files': 'Files',
            'folders': 'Folders',
            'items': 'Items',
            'yes': 'yes',
            'no': 'no',
            'link': 'Link',
            'searcresult': 'Search results',
            'selected': 'selected items',
            'about': 'About',
            'shortcuts': 'Shortcuts',
            'help': 'Help',
            'webfm': 'Web file manager',
            'ver': 'Version',
            'protocolver': 'protocol version',
            'homepage': 'Project home',
            'docs': 'Documentation',
            'github': 'Fork us on Github',
            'twitter': 'Follow us on twitter',
            'facebook': 'Join us on facebook',
            'team': 'Team',
            'chiefdev': 'chief developer',
            'developer': 'developer',
            'contributor': 'contributor',
            'maintainer': 'maintainer',
            'translator': 'translator',
            'icons': 'Icons',
            'dontforget': 'and don\'t forget to take your towel',
            'shortcutsof': 'Shortcuts disabled',
            'dropFiles': 'Drop files here',
            'or': 'or',
            'selectForUpload': 'Select files to upload',
            'moveFiles': 'Move files',
            'copyFiles': 'Copy files',
            'rmFromPlaces': 'Remove from places',
            'aspectRatio': 'Aspect ratio',
            'scale': 'Scale',
            'width': 'Width',
            'height': 'Height',
            'resize': 'Resize',
            'crop': 'Crop',
            'rotate': 'Rotate',
            'rotate-cw': 'Rotate 90 degrees CW',
            'rotate-ccw': 'Rotate 90 degrees CCW',
            'degree': '',
            'netMountDialogTitle': 'Mount network volume', // added 18.04.2012
            'protocol': 'Protocol', // added 18.04.2012
            'host': 'Host', // added 18.04.2012
            'port': 'Port', // added 18.04.2012
            'user': 'User', // added 18.04.2012
            'pass': 'Password', // added 18.04.2012
            'confirmUnmount'      : 'Are you unmount $1?',  // from v2.1 added 30.04.2012
            'dropFilesBrowser': 'Drop or Paste files from browser', // from v2.1 added 30.05.2012
            'dropPasteFiles'  : 'Drop or Paste files and URLs here', // from v2.1 added 07.04.2014
            'encoding'        : 'Encoding', // from v2.1 added 19.12.2014
            'locale'          : 'Locale',   // from v2.1 added 19.12.2014
            'searchTarget'    : 'Target: $1',                // from v2.1 added 22.5.2015
            'searchMime'      : 'Search by input MIME Type', // from v2.1 added 22.5.2015
            'owner'           : 'Owner', // from v2.1 added 20.6.2015
            'group'           : 'Group', // from v2.1 added 20.6.2015
            'other'           : 'Other', // from v2.1 added 20.6.2015
            'execute'         : 'Execute', // from v2.1 added 20.6.2015
            'perm'            : 'Permission', // from v2.1 added 20.6.2015
            'mode'            : 'Mode', // from v2.1 added 20.6.2015

            /********************************** mimetypes **********************************/
            'kindUnknown': 'Unknown',
            'kindFolder': 'Folder',
            'kindAlias': 'Alias',
            'kindAliasBroken': 'Broken alias',
            // applications
            'kindApp': 'Application',
            'kindPostscript': 'Postscript document',
            'kindMsOffice': 'Microsoft Office document',
            'kindMsWord': 'Microsoft Word document',
            'kindMsExcel': 'Microsoft Excel document',
            'kindMsPP': 'Microsoft Powerpoint presentation',
            'kindOO': 'Open Office document',
            'kindAppFlash': 'Flash application',
            'kindPDF': 'Portable Document Format (PDF)',
            'kindTorrent': 'Bittorrent file',
            'kind7z': '7z archive',
            'kindTAR': 'TAR archive',
            'kindGZIP': 'GZIP archive',
            'kindBZIP': 'BZIP archive',
            'kindXZ': 'XZ archive',
            'kindZIP': 'ZIP archive',
            'kindRAR': 'RAR archive',
            'kindJAR': 'Java JAR file',
            'kindTTF': 'True Type font',
            'kindOTF': 'Open Type font',
            'kindRPM': 'RPM package',
            // texts
            'kindText': 'Text document',
            'kindTextPlain': 'Plain text',
            'kindPHP': 'PHP source',
            'kindCSS': 'Cascading style sheet',
            'kindHTML': 'HTML document',
            'kindJS': 'Javascript source',
            'kindRTF': 'Rich Text Format',
            'kindC': 'C source',
            'kindCHeader': 'C header source',
            'kindCPP': 'C++ source',
            'kindCPPHeader': 'C++ header source',
            'kindShell': 'Unix shell script',
            'kindPython': 'Python source',
            'kindJava': 'Java source',
            'kindRuby': 'Ruby source',
            'kindPerl': 'Perl script',
            'kindSQL': 'SQL source',
            'kindXML': 'XML document',
            'kindAWK': 'AWK source',
            'kindCSV': 'Comma separated values',
            'kindDOCBOOK': 'Docbook XML document',
            // images
            'kindImage': 'Image',
            'kindBMP': 'BMP image',
            'kindJPEG': 'JPEG image',
            'kindGIF': 'GIF Image',
            'kindPNG': 'PNG Image',
            'kindTIFF': 'TIFF image',
            'kindTGA': 'TGA image',
            'kindPSD': 'Adobe Photoshop image',
            'kindXBITMAP': 'X bitmap image',
            'kindPXM': 'Pixelmator image',
            // media
            'kindAudio': 'Audio media',
            'kindAudioMPEG': 'MPEG audio',
            'kindAudioMPEG4': 'MPEG-4 audio',
            'kindAudioMIDI': 'MIDI audio',
            'kindAudioOGG': 'Ogg Vorbis audio',
            'kindAudioWAV': 'WAV audio',
            'AudioPlaylist': 'MP3 playlist',
            'kindVideo': 'Video media',
            'kindVideoDV': 'DV movie',
            'kindVideoMPEG': 'MPEG movie',
            'kindVideoMPEG4': 'MPEG-4 movie',
            'kindVideoAVI': 'AVI movie',
            'kindVideoMOV': 'Quick Time movie',
            'kindVideoWM': 'Windows Media movie',
            'kindVideoFlash': 'Flash movie',
            'kindVideoMKV': 'Matroska movie',
            'kindVideoOGG': 'Ogg movie'
        }
    };

    var mappings = {
        cmdpreview:'cmdquicklook',
        cmddelete:'cmdrm',
        'cmdnew_folder':'cmdmkdir',
        'cmdnew_file':'cmdmkfile',
        'create_archive':'cmdarchive',
        'select_all':'selectall',
        'go_up':'cmdback',
        'source':'places',
        'select':'selectfiles',
        'modified':'modify',
        'list':'viewlist',
        'thumb':'viewicons',
        'type':'kind',
        'move':'moveFiles'
        /*'view':'cmdview'*/
    };

    var messages = defaultLang.messages;

    var debug = false;

    function _lookupKey(prefix,_key,capitalize){

        var key = prefix + (capitalize ==true ? utils.capitalize(_key) : _key),
            mappingKey = mappings[key];

        return messages[mappingKey||key];

    }

    var dates = {
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            monthsShort: ['msJan', 'msFeb', 'msMar', 'msApr', 'msMay', 'msJun', 'msJul', 'msAug', 'msSep', 'msOct', 'msNov', 'msDec'],

            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    };

    function localize(str){



        str = str || '';

        if(str ==='Invert selection '){
            //debugger;
        }

        var segments = str.replace(/\s+/g, "_").split('/'),
            last = segments[segments.length-1],
            strLow = last.toLocaleLowerCase();



        // try in messages.cmd***
        var cmdValue = _lookupKey('cmd',strLow);

        // try in messages.err***
        var errValue = _lookupKey('err',strLow,true);

        // try in messages.but***
        var btnValue = _lookupKey('btn',strLow,true);

        // try in messages.but***
        var directValue = _lookupKey('',strLow);

        // try in messages.but***
        var directValueUp = _lookupKey('',strLow,true);

        // try in messages.but***
        var directValueRaw = _lookupKey('',str,false);

        var res = directValue || directValueUp || directValueRaw || cmdValue || btnValue || errValue;

        if(res){
            return res.replace('$1','');
        }


        if(str.indexOf(' ')!==-1 && str.indexOf('%%')==-1) {
            res = "";
            var parts = str.split(' ');
            _.each(parts, function (part) {
                res += " " + localize(part);
            });
            return res.trim();
        }

        str = str.replace('%%','');

        debug && console.log('localize ' + str + ' to ' + res + ' with = ' + strLow);

        return str;

    }

    function formatDate(ts){

        var utc = '';
        var date = new Date();

        this.getHours    = 'get'+utc+'Hours';
        this.getMinutes  = 'get'+utc+'Minutes';
        this.getSeconds  = 'get'+utc+'Seconds';
        this.getDate     = 'get'+utc+'Date';
        this.getDay      = 'get'+utc+'Day';
        this.getMonth    = 'get'+utc+'Month';
        this.getFullYear = 'get'+utc+'FullYear';
        this.today = (new Date(date.getFullYear(), date.getMonth(), date.getDate())).getTime()/1000;
        this.yesterday = this.today - 86400;

        var self = this,
            format, output, d, dw, m, y, h, g, i, s;


        var messages = Module.translations.messages;


        if (ts > 0) {

            date = new Date(ts*1000);

            h  = date[self.getHours]();
            g  = h > 12 ? h - 12 : h;
            i  = date[self.getMinutes]();
            s  = date[self.getSeconds]();
            d  = date[self.getDate]();
            dw = date[self.getDay]();
            m  = date[self.getMonth]() + 1;
            y  = date[self.getFullYear]();

            format = ts >= self.yesterday
                ? Module.translations.fancyDateFormat
                : Module.translations.dateFormat;

            output = format.replace(/[a-z]/gi, function(val) {
                switch (val) {
                    case 'd': return d > 9 ? d : '0'+d;
                    case 'j': return d;
                    case 'D': return Module.localize(dates.daysShort[dw]);
                    case 'l': return Module.localize(dates.days[dw]);
                    case 'm': return m > 9 ? m : '0'+m;
                    case 'n': return m;
                    case 'M': return Module.localize(dates.monthsShort[m-1]);
                    case 'F': return Module.localize(dates.months[m-1]);
                    case 'Y': return y;
                    case 'y': return (''+y).substr(2);
                    case 'H': return h > 9 ? h : '0'+h;
                    case 'G': return h;
                    case 'g': return g;
                    case 'h': return g > 9 ? g : '0'+g;
                    case 'a': return h > 12 ? 'pm' : 'am';
                    case 'A': return h > 12 ? 'PM' : 'AM';
                    case 'i': return i > 9 ? i : '0'+i;
                    case 's': return s > 9 ? s : '0'+s;
                }
                return val;
            });

            return ts >= self.yesterday
                ? output.replace('$1', Module.localize(ts >= self.today ? 'Today' : 'Yesterday'))
                : output;

        } /*else if (file && file.date) {
            return file.date.replace(/([a-z]+)\s/i, function(a1, a2) { return self.i18n(a2)+' '; });
        }
*/
        return Module.localize('dateUnknown');
    }

    var Implementation = {
        translations:defaultLang,
        localize:localize
    };




    function setLanguage(langModule){
        var translations = langModule.translations;
        defaultLang.language = translations.language;
        defaultLang.direction = translations.direction;
        defaultLang.dateFormat = translations.dateFormat;
        defaultLang.fancyDateFormat = translations.fancyDateFormat;
        utils.mixin(defaultLang.messages,translations.messages);
    }



    var Module = declare('xlang.i18',null,Implementation);

    Module.dcl = dcl(null,Implementation);
    Module.Implementation = Implementation;
    Module.setLanguage = setLanguage;
    Module.mappings = mappings;
    Module.localize = localize;
    Module.translations = defaultLang;
    Module.addMapping = function(_mappings){
        utils.mixin(mappings,_mappings);
    };
    Module.formatDate = formatDate;

    return Module;

});
},
'xfile/data/Store':function(){
/**
 * @module xfile/data/FileStore
 **/
define([
    "dojo/_base/declare",
    "dojo/_base/lang",
    'dojo/Deferred',
    "xide/mixins/ReloadMixin",
    "xide/manager/ServerActionBase",
    'dstore/Cache',
    'dstore/QueryResults',
    'xide/types',
    'xide/utils',
    'dojo/when',
    'xide/data/TreeMemory',
    'dstore/Trackable',
    'xide/data/ObservableStore',
    'xfile/model/File',
    'xide/lodash'
], function (declare, lang, Deferred, ReloadMixin, ServerActionBase, Cache, QueryResults, types, utils, when, TreeMemory, Trackable, ObservableStore, File,_) {
    var _debug = false;
    /**
     * Constants
     * @type {string}
     */
    var C_ITEM_EXPANDED = "_EX";      // Attribute indicating if a directory item is fully expanded.
    /**
     *
     * A store based on dstore/Memory and additional dstore mixins, used for all xfile grids.
     *
     * ###General
     *
     * - This store is only fetching file listings from the server! Any other file operation is done in
     * by file manager. However, this store is the central database for all files.
     *
     *
     * ###Common features and remarks
     *
     * - works with for multiple grid instances: lists/thumb or tree grids
     * - caches all directory listings, use _loadPath(path,force=true) to drop the cache
     * - all server methods return dojo/Deferred handles
     * - loads path segments recursivly, ie: getItem('./path/subPath/anotherSub');
     *
     * ### Server related
     * #### Requests

     * This part is done in the {link:xide/manager/ServerActionBase} ServerActionBase mixin, wrapped in here as
     * '_request'. This will take care about the possible transports : JSON-RPC-2.0 with a Dojo-SMD envelope or JSONP.
     * Both requests will be signed upon its payload, using this.config.RPC_PARAMETERS(server controlled), if required.
     * At the time of writing, this library has been developed for a PHP and Java-Struts which both support Dojo - SMD.
     * However, you may adjust to REST based environments yourself. Also, when using the
     * supplied XPHP - JSON-RPC-2.0-SMD implementation you can make use of 'batch-requests' to avoid further requests.
     *
     * #### Responses
     *
     * The response arrives here parsed already, no need to do anything but adding it to the store.
     *
     * @class module:xfile/data/FileStore
     * @augments module:xide/manager/ServerActionBase
     * @augments module:dgrid/Memory
     * @augments module:dgrid/Tree
     * @augments module:dgrid/Cache
     * @augments module:xide/mixins/ReloadMixin
     */
    function Implementation() {
        return {
            addDot: true,
            /**
             * 'recursive' will tell the server to run the directory listing recursive for server method 'ls'
             * @type {boolean}
             */
            recursive:false,
            rootSegment: ".",
            Model: File,
            /**
             * @member idProperty {string} sets the unique identifier for store items is set to the 'path' of a file.
             * @public
             */
            idProperty: "path",
            parentField: 'parent',
            /**
             * @member mount {string} sets the 'mount' prefix for a VFS. This is needed to simplify the work
             * with paths and needs to be handled separated. By default any request expects full paths as:
             * - root/_my_path
             * - root://_my_path/even_deeper
             * - dropbox/_my_folder
             *
             * This property is is being used to complete a full file path automatically in the request so that only the
             * actual inner path needs to be specified in all methods.
             * By default xfile supports multiple stores in the same application.
             * Each store is created upon mount + store options hash.
             * @public
             */
            mount: 'path',
            /**
             * @member options{Object[]} specifies the store options. The store options are tied to the server. As the store
             * is only relavant for enumerating files through a server method, there are only a couple of options needed:
             *
             * <b>options.fields</b> {int} A enumeration bitmask which specifies the fields to be added for a file or
             * directory node. This is described in link:xfile/types/Types#Fields and again, this is being processed by
             * the server.
             *
             * options.includeList {string} a comma separated list of allowed file extensions, this has priority the
             * exclusion mask.
             *
             * options.excludeList {string} a comma separated list of excluded file extensions
             *
             * This options are set through xfile/manager/Context#defaultStoreOptions which might be overriden
             * through the server controlled xFileConfiguration.mixins global header script tag.
             *
             * @example {
                "fields": 1663,
                "includeList": "*",
                "excludeList": "*"
            }
             * @public
             */
            options: {
                fields: 1663,
                includeList: "*",
                excludeList: "*"    // XPHP actually sets this to ".svn,.git,.idea" which are compatible to PHP's 'glob'
            },
            /**
             * @member serviceUrl {string} the path to the service entry point. There are 2 modes this end-point must
             * provide:
             * - a Dojo compatible SMD
             * - post/get requests with parameters. Currently JSONP & JSON-RPC-1/2.0 is supported.
             *
             * You can set also static SMD (see xide/manager/ServerActionBase) to bypass the SMD output. However,
             * this is being set usually by a server side mixin (in HTML header tag) on the fly!
             * @default null
             * @public
             */
            serviceUrl: null,
            /**
             * @member serviceClass {string} is the server class to be called. By default, this store creates a
             * JSON-RPC-2.0 post request where the methods looks like "XApp_Directory_Service.ls". Other formats are
             * supported in XPHP as well and support also composer autoloaders. If this is a singleton, you can also call
             * this.serviceObject.SERVER_CLASS.SERVER_METHOD(args) through here!
             * @public
             *
             */
            serviceClass: null,
            /**
             * @member singleton {boolean} Sets the ServerActionBase as 'Singleton' at the time of the construction. If there
             * is any other ServerActionBase subclass with the same service url, this will avoid additional requests to
             * fetch a SMD, furthermore, you can call other methods on the server through this here
             * as well: this.serviceObject.SERVER_CLASS.SERVER_METHOD(args)
             * @default true
             * @public
             */
            singleton: true,
            /////////////////////////////////////////////////////////////////////////////
            //
            //  dstore/Tree implementation
            //
            /////////////////////////////////////////////////////////////////////////////
            queryAccessors: true,
            autoEmitEvents: false, // this is handled by the methods themselves
            /*
             * test
             * @param object
             * @returns {boolean}
             */
            mayHaveChildren: function (object) {
                // summary:
                //		Check if an object may have children
                // description:
                //		This method is useful for eliminating the possibility that an object may have children,
                //		allowing collection consumers to determine things like whether to render UI for child-expansion
                //		and whether a query is necessary to retrieve an object's children.
                // object:
                //		The potential parent
                // returns: boolean
                if (object.mayHaveChildren == false) {
                    return false;
                }
                return object.directory === true;
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Private part, might be trashed
            //
            /////////////////////////////////////////////////////////////////////////////
            _lastFilter: null,
            _lastFilterDef: null,
            _lastFilterItem: null,
            _initiated: {
                value: false
            },
            id: null,
            _state: {
                initiated: false,
                filter: null,
                filterDef: null
            },
            isInitiated: function () {
                return this._state.initiated;
            },
            setInitiated: function (initiated) {
                this._state.initiated = initiated;
            },
            _extraSortProperties: {
                name: {
                    ignoreCase: true
                }
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Sorting
            //
            /////////////////////////////////////////////////////////////////////////////

            constructor: function () {
                this.id = utils.createUUID();
            },
            onSorted: function (sorted, data) {
                if (sorted.length == 1 && sorted[0].property === 'name') {
                    var upperCaseFirst = true,
                        directoriesFirst = true,
                        descending = sorted[0].descending;

                    if (directoriesFirst) {
                        function _sort(item) {
                            return upperCaseFirst ? item.name : item.name.toLowerCase();
                        }
                        var grouped = _.groupBy(data, function (item) {
                            return item.directory === true;
                        }, this);

                        data = _.sortBy(grouped['true'], _sort);
                        data = data.concat(_.sortBy(grouped['false'], _sort));
                        if (descending) {
                            data.reverse();
                        }
                    }
                }
                var _back = _.find(data, {
                    name: '..'
                });
                if (_back) {
                    data.remove(_back);
                    data.unshift(_back);
                }

                data = this.onAfterSort(data);

                return data;
            },
            onAfterSort: function (data) {
                var micromatch = this.micromatch;
                if (typeof mm !== 'undefined' && micromatch && data && data[0]) {
                    var what = data[0].realPath ? 'realPath' : 'path';
                    what = 'name';
                    var _items = _.pluck(data, what);
                    var matching = mm(_items, micromatch);
                    data = data.filter(function (item) {
                        if (matching.indexOf(item[what]) === -1) {
                            return null;
                        }
                        return item;
                    });
                    if(this._onAfterSort){
                        data = this._onAfterSort(data);
                    }
                }
                return data;
            },
            /**
             * Overrides dstore method to add support for case in-sensitive sorting. This requires
             * ignoreCase: true in a this.sort(..) call, ie:
             *
             *  return [{property: 'name', descending: false, ignoreCase: true}]
             *
             * this will involve this._extraSortProperties and is being called by this.getDefaultSort().
             *
             * @param sorted
             * @returns {Function}
             * @private
             */
            _createSortQuerier: function (sorted) {
                var thiz = this;
                return function (data) {
                    data = data.slice();
                    data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
                        for (var i = 0; i < sorted.length; i++) {
                            var comparison;
                            if (typeof sorted[i] == 'function') {
                                comparison = sorted[i](a, b);
                            } else {
                                var property = sorted[i].property;
                                if (thiz._extraSortProperties[property]) {
                                    utils.mixin(sorted[i], thiz._extraSortProperties[property]);
                                }
                                var descending = sorted[i].descending;
                                var aValue = a.get ? a.get(property) : a[property];
                                var bValue = b.get ? b.get(property) : b[property];
                                var ignoreCase = !!sorted[i].ignoreCase;
                                aValue != null && (aValue = aValue.valueOf());
                                bValue != null && (bValue = bValue.valueOf());

                                if (ignoreCase) {
                                    aValue.toUpperCase && ( aValue = aValue.toUpperCase() );
                                    bValue.toUpperCase && ( bValue = bValue.toUpperCase() );
                                }
                                comparison = aValue === bValue ? 0 : (!!descending === (aValue === null || aValue > bValue) ? -1 : 1);
                            }
                            if (comparison !== 0) {
                                return comparison;
                            }
                        }
                        return 0;
                    });
                    return thiz.onSorted(sorted, data);
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Public API section
            //
            /////////////////////////////////////////////////////////////////////////////
            _getItem: function (path, allowNonLoaded) {
                //try instant and return when loaded
                var item = this.getSync(path) || this.getSync('./' + path);
                if (item && (this.isItemLoaded(item) || allowNonLoaded == true)) {
                    return item;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Returns a promise or a store item. This works recursively for any path and
             * results in one request per path segment or a single request when batch-requests
             * are enabled on the server.

             * @param path {string} a unique path, ie: ./ | . | ./myFolder | ./myFolder/and_deeper. If the item isn't
             * fully loaded yet, it just returns the item, if you enable 'load' and does the full load.
             * @param load {boolean} load the item if not already
             * @param options {object|null} request options
             *
             * @returns {Object|Deferred|null}
             */
            getItem: function (path, load,options) {
                if (load == false) {
                    return this._getItem(path);

                } else if (load == true) {
                    //at this point we have to load recursively
                    var parts = path.split('/'),
                        thiz = this,
                        partsToLoad = [],
                        item = thiz.getSync(path);

                    if (!item) {
                        item = thiz.getSync(path.replace('./', ''));
                    }
                    if (item && this.isItemLoaded(item)) {
                        return item;
                    }

                    //new head promise for all underlying this.getItem calls
                    var deferred = new Deferred();
                    var _loadNext = function () {
                        //no additional lodash or array stuff please, keep it simple
                        var isFinish = !_.find(partsToLoad, {loaded: false});
                        if (isFinish) {
                            deferred.resolve(thiz.getItem(path, false));
                        } else {
                            for (var i = 0; i < partsToLoad.length; i++) {
                                if (!partsToLoad[i].loaded) {
                                    var _item = thiz.getSync(partsToLoad[i].path);
                                    if (_item) {
                                        if (_item.directory === true && thiz.isItemLoaded(_item)) {
                                            partsToLoad[i].loaded = true;
                                            continue;
                                        } else if (_item.directory == null) {
                                            deferred.resolve(_item);
                                            break;
                                        }
                                    }
                                    thiz._loadPath(partsToLoad[i].path,false,options).then(function (items) {
                                        partsToLoad[i].loaded = true;
                                        _loadNext();
                                    }, function (err) {
                                        var _i = Math.abs(Math.min(0, i - 1));
                                        var nextPart = partsToLoad[_i];
                                        var parts = partsToLoad;
                                        if (!nextPart) {
                                            _i = partsToLoad.length - 1;
                                            nextPart = partsToLoad[_i];
                                        }
                                        var _item = thiz.getItem(nextPart.path);
                                        when(thiz.getItem(partsToLoad[_i].path, false), function (_item) {
                                            deferred.resolve(_item, partsToLoad[_i].path);
                                        });
                                    });
                                    break;
                                }
                            }
                        }
                    };

                    //prepare process array
                    var itemStr = '.';
                    for (var i = 0; i < parts.length; i++) {
                        if (parts[i] == '.') {
                            continue;
                        }
                        if (parts.length > 0) {
                            itemStr += '/';
                        }
                        itemStr += parts[i];
                        partsToLoad.push({path: itemStr, loaded: false});
                    }
                    //fire
                    _loadNext();
                    return deferred;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Return the root item, is actually private
             * @TODO: root item unclear
             * @returns {{path: string, name: string, mount: *, directory: boolean, virtual: boolean, _S: (xfile|data|FileStore), getPath: Function}}
             */
            getRootItem: function () {
                return {
                    _EX: true,
                    path: '.',
                    name: '.',
                    mount: this.mount,
                    directory: true,
                    virtual: true,
                    _S: this,
                    getPath: function () {
                        return this.path;
                    }
                };
            },
            /**
             * back compat, trash
             */
            getItemByPath: function () {
                //console.log('FILESTORE::getItemByPath',arguments);
            },
            /*
             * */
            getParents: function () {
                return null;
            },
            /**
             * Return parent object in sync mode, default to root item
             * @TODO fix root problem
             * @param mixed {string|object}
             */
            getParent: function (mixed) {
                if (!mixed) {
                    return null;
                }
                var item = mixed,
                    result = null;

                if (lang.isString(item)) {
                    item = this.getSync(mixed);
                }

                if (item && item.parent) {
                    result = this.getSync(item.parent);
                }
                return result || this.getRootItem();
            },
            /**
             * Return 'loaded' state
             * @param item
             * @returns {boolean}
             */
            isItemLoaded: function (item) {
                return item && (!item.directory || this._isLoaded(item));
            },
            /**
             * Wrap loadItem
             * @TODO yeah, what?
             * @param item
             * @param force
             * @returns {*}
             */
            loadItem: function (item, force) {
                return this._loadItem(item, force);
            },
            /**
             * Fix an incoming item for our needs, adds the _S(this) attribute and
             * a function to safely return a its path since there are items with fake paths as: './myPath_back_'
             * @param item
             * @private
             */
            _parse: function (item) {
                item._S = this;

                if (!_.isEmpty(item.children)) {

                    _.each(item.children, function (_item) {
                        _item.parent = item.path;
                        this._parse(_item);
                    }, this);

                    item._EX = true;
                    item.children = this.addItems(item.children);
                }
                item.getPath = function () {
                    return this.path;
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  True store impl.
            //
            /////////////////////////////////////////////////////////////////////////////
            /**
             * Here to load an item forcefully (reload/refresh)
             * @param path
             * @param force
             * @param options {object|null}
             * @returns {*}
             * @private
             */
            _loadPath: function (path,force,options) {
                var thiz = this;
                var result = this._request(path,options);
                result.then(function (items) {
                        var _item = thiz._getItem(path, true);
                        if (_item) {
                            if (force) {
                                if (!_.isEmpty(_item.children)) {
                                    thiz.removeItems(_item.children);
                                }
                            }
                            _item._EX = true;
                            thiz.addItems(items, force);
                            _item.children = items;
                            return items;
                        } else {
                            if(options && options.onError) {
                                options.onError('Error Requesting path on server : '+path);
                            }else{
                                throw new Error('cant get item at ' + path);
                            }
                        }
                    }.bind(this),
                    function (err) {
                        console.error('error in load');
                    });

                return result;

            },
            /**
             * Creates an object, throws an error if the object already exists.
             * @param object {Object} The object to store.
             * @param options {Object} Additional metadata for storing the data.  Includes an 'id' property if a specific
             * id is to be used. dstore/Store.PutDirectives?
             * @returns {Number|Object}
             */
            addSync: function (object, options) {
                (options = options || {}).overwrite = false;
                // call put with overwrite being false
                return this.putSync(object, options);
            },
            /**
             * @TODO: what?
             * @param item
             * @param force
             * @returns {Deferred}
             * @private
             */
            _loadItem: function (item, force) {
                var deferred = new Deferred(),
                    thiz = this;
                if (!item) {
                    deferred.reject('need item');
                    return deferred;
                }
                if (force) {
                    //special case on root
                    if (item.path === '.') {
                        thiz.setInitiated(false);
                        thiz.fetchRange().then(function (items) {
                            deferred.resolve({
                                store: thiz,
                                items: items,
                                item: item
                            });
                        });
                    } else {
                        this._loadPath(item.path, true).then(function (items) {
                            deferred.resolve(item);
                        }, function (err) {
                            console.error('error occured whilst loading items');
                            deferred.reject(err);
                        });
                    }
                }
                return deferred;
            },
            _normalize: function (response) {
                if (response && response.items) {
                    return response.items[0];
                }
                return [];
            },
            _isLoaded: function (item) {
                return item && item[C_ITEM_EXPANDED] === true;
            },
            fetch: function () {

            },
            put: function () {

            },
            add: function (item) {
                var _item = this.getSync(item.path);
                if (!_item){
                    _item = this.addSync(item);
                    _item._S = this;
                    _item.getPath = function () {
                        return this.path;
                    };
                }
                return _item;
            },
            removeItems: function (items) {
                _.each(items, function (item) {
                    if (this.getSync(item.path)) {
                        this.removeSync(item.path);
                    }
                }, this);
            },
            addItems: function (items) {
                var result = [];
                _.each(items, function (item) {
                    var storeItem = this.getSync(item.path);
                    if (storeItem) {
                        this.removeSync(item.path);
                    }
                    result.push(this.add(item));
                }, this);
                return result;
            },
            open: function (item) {
                var thiz = this;
                if (!this._isLoaded(item)) {
                    item.isLoading = true;
                    return thiz._request(item.path).then(function (items) {
                        item.isLoading = false;
                        item._EX = true;
                        thiz.addItems(items);
                        item.children = items;
                        return items;
                    });
                } else {
                    var deferred = new Deferred();
                    thiz.resetQueryLog();
                    deferred.resolve(item.children);
                    return deferred;
                }
            },
            getDefaultSort: function () {
                return [{property: 'name', descending: false, ignoreCase: true}];
            },
            filter: function (data) {
                if (data.parent) {
                    this._state.path = data.parent;
                }
                var item = this.getSync(data.parent);
                if (item) {
                    if (!this.isItemLoaded(item)) {
                        item.isLoading = true;
                        this._state.filterDef = this._loadPath(item.path);
                        this._state.filterDef.then(function(){
                            item.isLoading = false;
                        })
                    } else {
                        /*
                        if(item.children) {
                            var total = new Deferred();
                            total.resolve(item.children);
                            this._state.filterDef = total;
                            this._state.filter = data;
                        }
                        */
                        this._state.filterDef = null;
                    }
                }
                delete this._state.filter;
                this._state.filter = data;
                return this.inherited(arguments);
            },
            _request: function (path,options) {
                var collection = this;
                return this.runDeferred(null, 'ls', {
                        path: path,
                        mount: this.mount,
                        options: this.options,
                        recursive:this.recursive
                    },
                    utils.mixin({checkErrors: false,displayError: true},options)).then(function (response) {
                    var results = collection._normalize(response);
                    collection._parse(results);
                    // support items in the results
                    results = results.children || results;
                    return results;
                }, function (e) {
                    if(options && options.displayError===false){
                        return;
                    }
                    logError(e,'error in FileStore : ' + this.mount + ' :' + e);
                });
            },
            fetchRangeSync: function () {
                var data = this.fetchSync();
                var total = new Deferred();
                total.resolve(data.length);
                return new QueryResults(data, {
                    totalLength: total
                });
            },
            reset: function () {
                this._state.filter = null;
                this._state.filterDef = null;
                this.resetQueryLog();
            },
            resetQueryLog: function () {
                this.queryLog = [];
            },
            fetchRange: function () {
                // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
                // so we need to extend this as well.
                var results = this._fetchRange();
                return new QueryResults(results.then(function (data) {
                    return data;
                }), {
                    totalLength: results.then(function (data) {
                        return data.length;
                    })
                });
            },
            initRoot: function () {
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (!this.isInitiated()) {
                    return thiz._request(_path).then(function (data) {
                        if (!thiz.isInitiated()) {
                            _.each(data, thiz._parse,thiz);
                            thiz.setData(data);
                            thiz.setInitiated(true);
                            thiz.emit('loaded');
                        }
                        return thiz.fetchRangeSync(arguments);
                    }.bind(this));
                }
                var dfd = new Deferred();
                dfd.resolve();
                return dfd;
            },
            _fetchRange: function () {
                //special case for trees
                if (this._state.filter) {
                    var def = this._state.filterDef;
                    if (def) {
                        def.then(function (items) {
                            this.reset();
                            if (def && def.resolve) {
                                def.resolve(items);
                            }
                        }.bind(this));
                        return def;
                    }
                }
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (this.isInitiated()) {
                    var _def = thiz.fetchRangeSync(arguments);
                    var resultsDeferred = new Deferred();
                    var totalDeferred = new Deferred();
                    resultsDeferred.resolve(_def);
                    totalDeferred.resolve(_def.length);
                    thiz.emit('loaded');
                    return new QueryResults(resultsDeferred, {
                        totalLength: _def.totalLength
                    });
                }
                return thiz._request(_path).then(function (data) {
                    if (!thiz.isInitiated()) {
                        _.each(data, thiz._parse,thiz);
                        thiz.setData(data);
                        thiz.setInitiated(true);
                        thiz.emit('loaded');
                    }
                    return thiz.fetchRangeSync(arguments);
                }.bind(this));
            },
            getDefaultCollection: function (path) {
                var _sort = this.getDefaultSort();
                if (!path) {
                    return this.sort(_sort);
                } else {
                    return this.filter({
                        parent: path
                    }).sort(_sort);
                }
            }
        };
    }
    var Module = declare("xfile/data/Store", [TreeMemory, Cache, Trackable, ObservableStore, ServerActionBase.declare, ReloadMixin], Implementation());
    Module.Implementation = Implementation;
    return Module;
});
},
'xide/widgets/WidgetBase':function(){
define([
    'dcl/dcl',
    'dojo/_base/connect',
    "dojo/dom-class",
    "xide/widgets/TemplatedWidgetBase",
    "xide/utils",
    "xide/factory",
    "xide/types",
    "dojo/dom-construct"

], function (dcl,connect, domClass, TemplatedWidgetBase, utils, factory, types, domConstruct) {

    var Module = dcl([TemplatedWidgetBase], {
        declaredClass:"xide.widgets.WidgetBase",
        cssClass: '',
        _currentPlatform: null,
        data: null,
        model: null,
        widgets: null,
        delegate: null,
        helpNodes: null,
        navigationView: null,
        currentWidget: null,
        currentDataItem: null,
        didLoad: false,
        isSubWidget: false,
        title: "NoTitle",
        value: "Unset",
        minHeight: "60px;",
        previewNode: null,
        button0: null,
        valueNode: null,
        button1: null,
        toolBarRoot: null,
        toolBar: null,
        button2: null,
        button3: null,
        wButton2: null,
        wButton3: null,
        nativeWidget: null,
        isInherited: false,
        expander: null,
        expanderButton: null,
        expanderOpen: false,
        expanderPane: null,
        lastHeight: null,
        hasPlatform: false,
        titleNode: null,
        storeDelegate: null,
        extensionRoot: null,
        extensionTag: 'td',
        extensionClass: 'extension',
        _didSendReady: false,
        styles: null,
        active: true,
        vertical: false,
        titleColumn: null,
        templateString: "<div class='widgetContainer widgetBorder widgetTable widget' style=''>" +
        "<table border='0' cellpadding='5px' width='100%'>" +
        "<tbody align='left'>" +
        "<tr attachTo='extensionRoot' valign='middle' style='height:90%'>" +
        "<td attachTo='titleColumn' width='15%' class='widgetTitle'><b><span attachTo='titleNode'>${!title}</span></b></td>" +
        "<td valign='middle' class='widgetValue' attachTo='valueNode' width='100px'>${!value}</td>" +
        "<td class='extension' attachTo='previewNode'></td>" +
        "<td class='extension' attachTo='button0'></td>" +
        "<td class='extension' attachTo='button1'></td>" +
        "</tr>" +
        "</tbody>" +
        "</table>" +
        "<div attachTo='expander' style='width:100%;'></div>" +
        "<div attachTo='last'></div>" +
        "</div>",
        changed: false,
        setActive: function (active) {
            this.active = false;
            if (this.userData) {
                this.userData._active = active;
            }
        },
        setStoreDelegate: function (delegate) {
            this.storeDelegate = delegate;
        },
        getExtensionRoot: function () {
            return this.extensionRoot;
        },
        getFreeExtensionSlot: function (startNode) {
            var root = startNode || this.getExtensionRoot();
            if (!root) {
                return null;
            }

            var node = utils.findEmptyNode(root, '.extension');

            if (!node) {
                node = domConstruct.create(this.extensionTag, {
                    className: this.extensionClass
                }, root);
            }

            return node;

        },
        getCurrentPlatform: function () {
            return this._currentPlatform;
        },
        getRootId: function () {
            return this.id;
        },
        save: function () {

            this.publish(types.EVENTS.ON_CI_UPDATE, {
                owner: this.delegate || this.owner,
                ci: this.userData,
                newValue: this.getValue(),
                storeItem: this.storeItem
            });

        },
        /***
         * Widget base protocol to be implemented by each subclass
         * @param value
         */
        setValue: function (value, dataSource, dataRef, title) {
            var oldValue = utils.getCIValueByField(this.userData, "value");
            this.userData = utils.setCIValueByField(this.userData, "value", value);
            if (this.skipSave == true) {
                this.skipSave = false;
                return;
            }

            var eventArgs = {
                owner: this.delegate || this.owner,
                ci: this.userData,
                newValue: value,
                oldValue: oldValue,
                storeItem: this.storeItem
            };


            this.publish(types.EVENTS.ON_CI_UPDATE, eventArgs);


            this._emit('valueChanged', eventArgs);


        },

        /**
         *
         * @param platform
         * @param field
         * @returns {*}
         */
        getValue: function (platform, field) {
            return utils.getCIValueByField(this.userData, field || "value");

        },
        clearValue: function () {

        },
        empty: function () {


        },
        buildToolbar: function () {


        },
        fillTemplate: function () {

            var thiz = this;
            if (this.nativeWidget) {
                this.valueNode.innerHTML = "";
                this.valueNode.appendChild(this.nativeWidget.domNode);
            }
        },
        addClearButton: function () {

            if (this.wButton1) {
                return;
            }

            var thiz = this;
            var anchor = dojo.doc.createElement('DIV', {});
            this.wButton1 = new dijit.form.ToggleButton({
                role: "button",
                showLabel: false,
                checked: true,
                iconClass: "widgetDeleteButton",
                style: "padding-left:0px;"
            }, anchor);

            this.button1.appendChild(this.wButton1.domNode);

            connect.connect(this.wButton1, "onClick", function (item) {
                thiz.clearValue();
                if (thiz.setThumbnail) {
                    thiz.setThumbnail("");
                }
            });
        },
        startup: function () {

            if (this.value == null) {
                this.value = "Unset";
            }

            if (this._started) {
                return;
            }

            var res = this.inherited(arguments);

            if (this.userData && this.userData.inherited && this.userData.inherited == true) {
                this.isInherited = true;
                domClass.remove(this.domNode, "widgetContainer");
                this.buildToolbar();
                domClass.add(this.domNode, "widgetContainerAlternate");

            }
            if (this.userData.toolTip) {
                this.initToolTip(this.userData.toolTip);
            }

            if (this.nativeWidget && this.setupNativeWidgetHandler) {
                this.setupNativeWidgetHandler();
            }
            this.updateTitleNode(this.title);

            if (this.showLabel == false) {
                utils.destroy(this.titleColumn);
            }
            return res;
        },
        connectEditBox: function (editBox, onChanged) {

            var thiz = this;

            function cb(value){
                if (onChanged) {
                    onChanged(value);
                }
                var _valueNow = utils.toString(thiz.userData['value']);

                if (value === _valueNow) {
                    return;
                }
                thiz.userData.changed = true;
                thiz.userData.active = true;
                if (thiz.serialize) {
                    value = thiz.serialize();
                }
                utils.setCIValueByField(thiz.userData, "value", value);

                factory.publish(types.EVENTS.ON_CI_UPDATE, {
                    owner: thiz.delegate || thiz.owner,
                    ci: thiz.userData,
                    newValue: value,
                    storeItem: thiz.storeItem
                }, thiz);
            }

            if(editBox._on){
                editBox._on('change',cb);
            }else {
                connect.connect(editBox, "onChange", cb);
            }

        },
        onReady: function () {

            if (!this._didSendReady) {

                factory.publish(types.EVENTS.ON_WIDGET_READY, {
                    ci: this.userData,
                    widget: this,
                    storeItem: this.storeItem,
                    owner: this.owner
                });
                this._didSendReady = true;
            }

            if (this.userData && this.userData.vertical === true) {
                domClass.add(this.domNode, 'vertical');
            }

            var _class = _.last(this.declaredClass.split('.'));
            $(this.domNode).addClass(_class);
        },
        onDidRenderWidgets:function(view,widgets){

        },
        onAttached:function(view){}
    });

    dcl.chainAfter(Module,"destroy");
    
    return Module;
});

},
'xace/base_handler':function(){
/**
 * This module is used as a base class for language handlers.
 * It provides properties, helper functions, and functions that
 * can be overridden by language handlers to implement
 * language services such as code completion.
 *
 * See {@link language} for an example plugin.
 *
 * @class language.base_handler
 */
define(function(require, exports, module) {

    module.exports = {

        /**
         * Indicates the handler handles editors, the immediate window,
         * and anything else.
         */
        HANDLES_ANY: 0,

        /**
         * Indicates the handler only handles editors, not the immediate window.
         */
        HANDLES_EDITOR: 1,

        /**
         * Indicates the handler only handles the immediate window, not editors.
         */
        HANDLES_IMMEDIATE: 2,

        /**
         * Indicates the handler only handles the immediate window, not editors.
         */
        HANDLES_EDITOR_AND_IMMEDIATE: 3,

        /**
         * The language this worker is currently operating on.
         * @type {String}
         */
        language: null,

        /**
         * The path of the file this worker is currently operating on.
         * @type {String}
         */
        path: null,

        /**
         * The current workspace directory.
         * @type {String}
         */
        workspaceDir: null,

        /**
         * The current document this worker is operating on.
         *
         * @type {Document}
         */
        doc: null,

        // UTILITIES

        /**
         * Utility function, used to determine whether a certain feature is enabled
         * in the user's preferences.
         *
         * Should not be overridden by inheritors.
         *
         * @deprecated Use worker_util#isFeatureEnabled instead
         *
         * @param {String} name  The name of the feature, e.g. "unusedFunctionArgs"
         * @return {Boolean}
         */
        isFeatureEnabled: function(name) {
            /*global disabledFeatures*/
            return !disabledFeatures[name];
        },

        /**
         * Utility function, used to determine the identifier regex for the
         * current language, by invoking {@link #getIdentifierRegex} on its handlers.
         *
         * Should not be overridden by inheritors.
         *
         * @deprecated Use worker_util#getIdentifierRegex instead
         *
         * @return {RegExp}
         */
        $getIdentifierRegex: function() {
            return null;
        },

        /**
         * Utility function, used to retrigger completion,
         * in case new information was collected and should
         * be displayed, and assuming the popup is still open.
         *
         * Should not be overridden by inheritors.
         *
         * @deprecated Use worker_util#completeUpdate instead
         *
         * @param {Object} pos   The position to retrigger this update
         * @param {String} line  The line that this update was triggered for
         */
        completeUpdate: function(pos) {
            throw new Error("Use worker_util.completeUpdate instead()"); // implemented by worker.completeUpdate
        },

        // OVERRIDABLE ACCESORS

        /**
         * Returns whether this language handler should be enabled for the given
         * file.
         *
         * Must be overridden by inheritors.
         *
         * @param {String} language   to check the handler against
         * @return {Boolean}
         */
        handlesLanguage: function(language) {
            throw new Error("base_handler.handlesLanguage() is not overridden");
        },

        /**
         * Returns whether this language handler should be used in a
         * particular kind of editor.
         *
         * May be overridden by inheritors; returns {@link #HANDLES_EDITOR}
         * by default.
         *
         * @return {Number} One of {@link #HANDLES_EDITOR},
         *                  {@link #HANDLES_IMMEDIATE}, or
         *                  {@link #HANDLES_EDITOR_AND_IMMEDIATE}, or
         *                  {@link #HANDLES_ANY}.
         */
        handlesEditor: function() {
            return this.HANDLES_EDITOR;
        },

        /**
         * Returns the maximum file size this language handler supports.
         * Should return Infinity if size does not matter.
         * Default is 10.000 lines of 80 characters.
         *
         * May be overridden by inheritors.
         *
         * @return {Number}
         */
        getMaxFileSizeSupported: function() {
            // Moderately conservative default (well, still 800K)
            return 10 * 1000 * 80;
        },

        /**
         * Determine if the language component supports parsing.
         * Assumed to be true if at least one hander for the language reports true.
         *
         * Should be overridden by inheritors.
         *
         * @return {Boolean}
         */
        isParsingSupported: function() {
            return false;
        },

        /**
         * Returns a regular expression for identifiers in the handler's language.
         * If not specified, /[A-Za-z0-9$_]/ is used.
         *
         * Note: to indicate dollars are allowed at the start of identifiers
         * (like with php $variables), include '$$'' in the regex, e.g.
         * /[A-Z0-9$$_]/.
         *
         * Should be overridden by inheritors that implement code completion.
         *
         * @return RegExp
         */
        getIdentifierRegex: function() {
            return null;
        },

        /**
         * Returns a regular expression used to trigger code completion.
         * If a non-null value is returned, it is assumed continous completion
         * is supported for this language.
         *
         * As an example, Java-like languages might want to use: /^\.$/
         *
         * Should be overridden by inheritors that implement code completion.
         * Default implementation returns null.
         *
         * @return RegExp
         */
        getCompletionRegex: function() {
            return null;
        },

        /**
         * Returns a regular expression used to trigger a tooltip.
         * Normally, tooltips after a scheduled analysis has been completed.
         * To avoid delays, this function can be used to trigger
         * analysis & tooltip fetching early.
         *
         * Should be overridden by inheritors that implement tooltips.
         * Default implementation returns null.
         *
         * @return RegExp
         */
        getTooltipRegex: function() {
            return null;
        },

        // PARSING AND ABSTRACT SYNTAX CALLBACKS

        /**
         * Parses the given document.
         *
         * Should be overridden by inheritors that implement parsing
         * (which is, like all features here, optional).
         *
         * @param value {String}   the source the document to analyze
         * @return {Object}        an abstract syntax tree (of any type), or null if not implemented
         */
        parse: function(value, callback) {
            callback();
        },

        /**
         * Finds a tree node at a certain row and column,
         * e.g. using the findNode(pos) function of treehugger.
         *
         * Should be overridden by inheritors that implement parsing.
         *
         * @param {Object} ast                An abstract syntax tree object from {@link #parse}
         * @param {Object} pos                The position of the node to look up
         * @param {Number} pos.row            The position's row
         * @param {Number} pos.column         The position's column
         * @param {Function} callback         The callback for the result
         * @param {Object} [callback.result]  The found node
         */
        findNode: function(ast, pos, callback) {
            callback();
        },

        /**
         * Returns the  a tree node at a certain row and col,
         * e.g. using the node.getPos() function of treehugger.
         *
         * Should be overridden by inheritors that implement parsing.
         *
         * @param {Object} node                The node to look up
         * @param {Function} callback          The callback for the result
         * @param {Object} [callback.result]   The resulting position
         * @param {Number} callback.result.sl  The starting line
         * @param {Number} callback.result.el  The ending line
         * @param {Number} callback.result.sc  The starting column
         * @param {Number} callback.result.ec  The ending column
         */
        getPos: function(node, callback) {
            callback();
        },

        // OTHER CALLBACKS

        /**
         * Initialize this language handler.
         *
         * May be overridden by inheritors.
         *
         * @param callback            The callback; must be called
         */
        init: function(callback) {
            callback();
        },

        /**
         * Invoked when the document has been updated (possibly after a certain delay)
         *
         * May be overridden by inheritors.
         *
         * @param {Document} doc  The current document
         * @param {Function} callback            The callback; must be called
         */
        onUpdate: function(doc, callback) {
            callback();
        },

        /**
         * Invoked when a new document has been opened.
         *
         * May be overridden by inheritors.
         *
         * @param {String} path        The path of the newly opened document
         * @param {String} doc         The Document object representing the source
         * @param {String} oldPath     The path of the document that was active before
         * @param {Function} callback  The callback; must be called
         */
        onDocumentOpen: function(path, doc, oldPath, callback) {
            callback();
        },

        /**
         * Invoked when a document is closed in the IDE.
         *
         * May be overridden by inheritors.
         *
         * @param {String} path the path of the file
         * @param {Function} callback  The callback; must be called
         */
        onDocumentClose: function(path, callback) {
            callback();
        },

        /**
         * Invoked when the cursor has been moved.
         *
         * May be overridden by inheritors that immediately act upon cursor moves.
         *
         * See {@link #tooltip} and {@link #highlightOccurrences}
         * for handler functions that are invoked after the cursor has been moved,
         * the document has been analyzed, and feedback is requested.
         *
         * @param {Document} doc                      Document object representing the source
         * @param {Object} fullAst                    The entire AST of the current file (if parsed already, otherwise null)
         * @param {Object} cursorPos                  The current cursor position
         * @param {Number} cursorPos.row              The current cursor's row
         * @param {Number} cursorPos.column           The current cursor's column
         * @param {Object} currentNode                The AST node the cursor is currently at (if parsed alreadty, and if any)
         * @param {Function} callback                 The callback; must be called
         * @paran {Object} callback.result            An optional result. Supports the same result objects as
         *                                            {@link #tooltip} and {@link #highlightOccurrences}
         */
        onCursorMove: function(doc, fullAst, cursorPos, currentNode, callback) {
            callback();
        },

        /**
         * Invoked when the cursor has been moved inside to a different AST node.
         * Gets a tooltip to display when the cursor is moved to a particular location.
         *
         * Should be overridden by inheritors that implement tooltips.
         *
         * @param {Document} doc                               Document object representing the source
         * @param {Object} fullAst                             The entire AST of the current file (if any)
         * @param {Object} cursorPos                           The current cursor position
         * @param {Number} cursorPos.row                       The current cursor's row
         * @param {Number} cursorPos.column                    The current cursor's column
         * @param {Object} currentNode                         The AST node the cursor is currently at (if any)
         * @param {Function} callback                          The callback; must be called
         * @param {Object} callback.result                     The function's result
         * @param {Object|String} callback.result.hint         An object or HTML string with the tooltip to display
         * @param {Object[]} [callback.result.signatures]      One or more function signatures to show
         * @param {String} callback.result.signatures.name     Function name
         * @param {String} [callback.result.signatures.doc]    Function documentation
         * @param {Object[]} callback.result.signatures.parameters
         *                                                     Function parameters
         * @param {String} callback.result.signatures.parameters.name
         *                                                     Parameter name
         * @param {String} [callback.result.signatures.parameters.type]
         *                                                     Parameter type
         * @param {String} [callback.result.signatures.parameters.doc]
         *                                                     Parameter documentation
         * @param {String} [callback.result.signatures.returnType]
         *                                                     The function return type
         * @param {Object} callback.result.pos                 The position range for which this tooltip is valid
         * @param {Number} callback.result.pos.sl              The starting line
         * @param {Number} callback.result.pos.el              The ending line
         * @param {Number} callback.result.pos.sc              The starting column
         * @param {Number} callback.result.pos.ec              The ending column
         * @param {Object} [callback.result.displayPos]        The position to display this tooltip
         * @param {Number} [callback.result.displayPos.row]    The display position's row
         * @param {Number} [callback.result.displayPos.column] The display position's column
         */
        tooltip: function(doc, fullAst, cursorPos, currentNode, callback) {
            callback();
        },

        /**
         * Gets the instances to highlight when the cursor is moved to a particular location.
         *
         * Should be overridden by inheritors that implement occurrence highlighting.
         *
         * @param {Document} doc                           Document object representing the source
         * @param {Object} fullAst                         The entire AST of the current file (if any)
         * @param {Object} cursorPos                       The current cursor position
         * @param {Number} cursorPos.row                   The current cursor's row
         * @param {Number} cursorPos.column                The current cursor's column
         * @param {Object} currentNode                     The AST node the cursor is currently at (if any)
         * @param {Function} callback                      The callback; must be called
         * @param {Object} callback.result                 The function's result
         * @param {Object[]} [callback.result.markers]     The occurrences to highlight
         * @param {Object} callback.result.markers.pos     The marker's position
         * @param {Number} callback.result.markers.pos.sl  The starting line
         * @param {Number} callback.result.markers.pos.el  The ending line
         * @param {Number} callback.result.markers.pos.sc  The starting column
         * @param {Number} callback.result.markers.pos.ec  The ending column
         * @param {Boolean} callback.result.isGeneric      Indicates this is generic highlighting and should be deferred
         * @param {"occurrence_other"|"occurrence_main"} callback.result.markers.type
         *                                                 The type of occurrence: the main one, or any other one.
         */
        highlightOccurrences: function(doc, fullAst, cursorPos, currentNode, callback) {
            callback();
        },

        /**
         * Determines what refactorings to enable when the cursor is moved to a particular location.
         *
         * Should be overridden by inheritors that implement refactorings.
         *
         * @param {Document} doc                 Document object representing the source
         * @param {Object} fullAst               The entire AST of the current file (if any)
         * @param {Object} cursorPos             The current cursor position
         * @param {Number} cursorPos.row         The current cursor's row
         * @param {Number} cursorPos.column      The current cursor's column
         * @param {Object} currentNode           The AST node the cursor is currently at (if any)
         * @param {Function} callback            The callback; must be called
         * @param {Object} callback.result       The function's result
         * @param {String[]} callback.result.refactorings
         *                                       The refactorings to enable, such as "rename"
         * @param {String[]} [callback.result.isGeneric]
         *                                       Whether is a generic answer and should be deferred
         */
        getRefactorings: function(doc, fullAst, cursorPos, currentNode, callback) {
            callback();
        },

        /**
         * Constructs an outline.
         *
         * Example outline object:
         *
         *     {
     *          icon: 'method',
     *          name: "fooMethod",
     *          pos: this.getPos(),
     *          displayPos: { sl: 15, sc: 20 },
     *          items: [ ...items nested under this method... ],
     *          isUnordered: true
     *     }
         *
         * Should be overridden by inheritors that implement an outline.
         *
         * @param {Document} doc                           The Document object representing the source
         * @param {Object} fullAst                         The entire AST of the current file (if any)
         * @param {Function} callback                      The callback; must be called
         * @param {Object} callback.result                 The function's result, a JSON outline structure or null if not supported
         * @param {"event"|"method"|"method2"|"package"|"property"|"property2"|"unknown"|"unknown2"} callback.result.icon
         *                                                 The icon to display for the first outline item
         * @param {String} callback.result.name            The name to display for the first outline item
         * @param {Object} callback.result.pos             The item's range, e.g. the full visible range of a method
         * @param {Number} callback.result.pos.sl          The item's starting row
         * @param {Number} [callback.result.pos.el]        The item's ending row
         * @param {Number} [callback.result.pos.sc]        The item's starting column
         * @param {Number} [callback.result.pos.ec]        The item's ending column
         * @param {Object} [callback.result.displayPos]    The item's position of the text to select when it's picked from the outline
         * @param {Number} callback.result.displayPos.sl   The item's starting row
         * @param {Number} [callback.result.displayPos.el] The item's ending row
         * @param {Number} [callback.result.displayPos.sc] The item's starting column
         * @param {Number} [callback.result.displayPos.ec] The item's ending column
         * @param {Object[]} callback.result.items         Any items nested under the curent item.
         * @param {Boolean} [callback.result.isGeneric]    Indicates that this is a generic, language-independent outline
         * @param {Boolean} [callback.result.isUnordered]  Indicates the outline is not ordered by appearance of the items,
         *                                                 but that they're e.g. grouped as methods, properties, etc.
         */
        outline: function(doc, fullAst, callback) {
            callback();
        },

        /**
         * Constructs a hierarchy.
         *
         * Should be overridden by inheritors that implement a type hierarchy.
         *
         * Not supported right now.
         *
         * @param {Document} doc             The Document object representing the source
         * @param {Object} cursorPos         The current cursor position
         * @param {Number} cursorPos.row     The current cursor's row
         * @param {Number} cursorPos.column  The current cursor's column
         * @param {Function} callback        The callback; must be called
         * @param {Object} callback.result   A JSON hierarchy structure or null if not supported
         */
        hierarchy: function(doc, cursorPos, callback) {
            callback();
        },

        /**
         * Performs code completion for the user based on the current cursor position.
         *
         * Should be overridden by inheritors that implement code completion.
         *
         * Example completion result:
         * {
     *    name        : "foo()",
     *    replaceText : "foo()",
     *    icon        : "method",
     *    meta        : "FooClass",
     *    doc         : "The foo() method",
     *    docHead     : "FooClass.foo",
     *    priority    : 1
     *  };
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Object} fullAst               The entire AST of the current file (if any)
         * @param {Object} pos                   The current cursor position
         * @param {Number} pos.row               The current cursor's row
         * @param {Number} pos.column            The current cursor's column
         * @param {Object} currentNode           The AST node the cursor is currently at (if any)
         * @param {Function} callback            The callback; must be called
         * @param {Object} callback.result       The function's result, an array of completion matches
         * @param {String} callback.result.name  The full name to show in the completion popup
         * @param {String} [callback.result.id]  The short name that identifies this completion
         * @param {String} callback.result.replaceText
         *                                       The text to replace the selection with
         * @param {"event"|"method"|"method2"|"package"|"property"|"property2"|"unknown"|"unknown2"}
         *        [callback.result.icon]
         *                                       The icon to use
         * @param {String} callback.result.meta  Additional information to show
         * @param {String} callback.result.doc   Documentation to display
         * @param {String} callback.result.docHead
         *                                       Documentation heading to display
         * @param {Number} callback.result.priority
         *                                       Priority of this completion suggestion
         * @param {Boolean} callback.result.isGeneric
         *                                       Indicates that this is a generic, language-independent
         *                                       suggestion
         * @param {Boolean} callback.result.isContextual
         *                                       Indicates that this is a contextual completion,
         *                                       and that any generic completions should not be shown
         */
        complete: function(doc, fullAst, pos, currentNode, callback) {
            callback();
        },

        /**
         * Analyzes an AST or file and annotates it as desired.
         *
         * Example of an annotation to return:
         *
         *     {
     *         pos: { sl: 1, el: 1, sc: 4, ec: 5 },
     *         type: "warning",
     *         message: "Assigning to undeclared variable."
     *     }
         *
         * Should be overridden by inheritors that implement analysis.
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Object} fullAst               The entire AST of the current file (if any)
         * @param {Function} callback            The callback; must be called
         * @param {Object} callback.result       The function's result, an array of error and warning markers
         * @param {Boolean} [minimalAnalysis]    Fast, minimal analysis is requested, e.g.
         *                                       for code completion or tooltips.
         */
        analyze: function(value, fullAst, callback, minimalAnalysis) {
            callback();
        },

        /**
         * Gets all positions to select for a rename refactoring.
         *
         * Example result, renaming a 3-character identfier
         * on line 10 that also occurs on line 11 and 12:
         *
         *     {
     *         length: 3,
     *         pos: {
     *             row: 10,
     *             column: 5
     *         },
     *         others: [
     *             { row: 11, column: 5 },
     *             { row: 12, column: 5 }
     *         ]
     *     }
         *
         * Must be overridden by inheritors that implement rename refactoring.
         *
         * @param {Document} doc                          The Document object representing the source
         * @param {Object} ast                            The entire AST of the current file (if any)
         * @param {Object} pos                            The current cursor position
         * @param {Number} pos.row                        The current cursor's row
         * @param {Number} pos.column                     The current cursor's column
         * @param {Object} currentNode                    The AST node the cursor is currently at (if any)
         * @param {Function} callback                     The callback; must be called
         * @param {Object} callback.result                The function's result (see function description).
         * @param {Boolean} callback.result.isGeneric     Indicates this is a generic refactoring and should be deferred.
         * @param {Boolean} callback.result.length        The lenght of the rename identifier
         * @param {Object} callback.result.pos            The position of the current identifier
         * @param {Number} callback.result.pos.row        The row of the current identifier
         * @param {Number} callback.result.pos.column     The column of the current identifier
         * @param {Object[]} callback.result.others       The positions of other identifiers to be renamed
         * @param {Number} callback.result.others.row     The row of another identifier to be renamed
         * @param {Number} callback.result.others.column  The column of another identifier to be renamed
         */
        getRenamePositions: function(doc, ast, pos, currentNode, callback) {
            callback();
        },

        /**
         * Invoked when refactoring is started.
         *
         * May be overridden by inheritors that implement rename refactoring.
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Function} callback            The callback; must be called
         */
        onRenameBegin: function(doc, callback) {
            callback();
        },

        /**
         * Confirms that a rename refactoring is valid, before committing it.
         *
         * May be overridden by inheritors that implement rename refactoring.
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Object} oldId                 The old identifier was being renamed
         * @param {Number} oldId.row             The row of the identifier that was being renamed
         * @param {Number} oldId.column          The column of the identifier that was being renamed
         * @param {String} oldId.value           The value of the identifier that was being renamed
         * @param {String} newName               The new name of the element after refactoring
         * @param {Boolean} isGeneric            True if this was a refactoring marked with 'isGeneric' (see {@link #getRenamePositions})
         * @param {Function} callback            The callback; must be called
         * @param {String} callback.err          Null if the refactoring can be committed, or an error message if refactoring failed
         */
        commitRename: function(doc, oldName, newName, isGeneric, callback) {
            callback();
        },

        /**
         * Invoked when a refactor request is cancelled
         *
         * May be overridden by inheritors that implement rename refactoring.
         *
         * @param {Function} callback            The callback; must be called
         */
        onRenameCancel: function(callback) {
            callback();
        },

        /**
         * Performs code formatting.
         *
         * Should be overridden by inheritors that implement code formatting.
         *
         * @param {Document} doc the Document object representing the source
         * @param {Function} callback            The callback; must be called
         * @param {Object} callback.result       The function's result
         * @return a string value representing the new source code after formatting or null if not supported
         */
        codeFormat: function(doc, callback) {
            callback();
        },

        /**
         * Performs jumping to a definition.
         *
         * Should be overridden by inheritors that implement jump to definition.
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Object} fullAst               The entire AST of the current file (if any)
         * @param {Object} pos                   The current cursor position
         * @param {Number} pos.row               The current cursor's row
         * @param {Number} pos.column            The current cursor's column
         * @param {Function} callback            The callback; must be called
         * @param {Object[]} callback.results    The results
         * @param {String} [callback.results.path]
         *                                       The result path
         * @param {Number} [callback.results.row]
         *                                       The result row
         * @param {Number} [callback.results.column]
         *                                       The result column
         * @param {"event"|"method"|"method2"|"package"|"property"|"property2"|"unknown"|"unknown2"} [callback.results.icon]
         *                                       The icon to display (in case of multiple results)
         * @param {Boolean} [callback.results.isGeneric]
         *                                       Indicates that this is a generic, language-independent
         *                                       suggestion (that should be deferred)
         */
        jumpToDefinition: function(doc, fullAst, pos, currentNode, callback) {
            callback();
        },

        /**
         * Gets marker resolutions for quick fixes.
         *
         * Must be overridden by inheritors that implement quick fixes.
         *
         * See {@link #hasResolution}.
         *
         * @param {Document} doc                        The Document object representing the source
         * @param {Object} fullAst                      The entire AST of the current file (if any)
         * @param {Object} markers                      The markers to get resolutions for
         * @param {Function} callback                   The callback; must be called
         * @param {Object} callback.result              The function's result
         * @return {language.MarkerResolution[]} Resulting resolutions.
         */
        getResolutions: function(doc, fullAst, markers, callback) {
            callback();
        },

        /**
         * Determines if there are marker resolutions for quick fixes.
         *
         * Must be overridden by inheritors that implement quick fixes.
         *
         * @param {Document} doc                 The Document object representing the source
         * @param {Object} fullAst               The entire AST of the current file (if any)
         * @param {Function} callback            The callback; must be called
         * @param {Boolean} callback.result      There is at least one resolution
         */
        hasResolution: function(doc, fullAst, marker, callback) {
            callback();
        },

        /**
         * Given the cursor position and the parsed node at that position,
         * gets the string to send to the debugger for live inspect hovering.
         *
         * Should be overridden by inheritors that implement a debugger
         * with live inspect. If not implemented, the string value based on
         * currentNode's position is used.
         *
         * @param {Document} doc                    The Document object representing the source
         * @param {Object} fullAst                  The entire AST of the current file (if any)
         * @param {Object} pos                      The current cursor position
         * @param {Number} pos.row                  The current cursor's row
         * @param {Number} pos.column               The current cursor's column
         * @param {Function} callback               The callback; must be called
         * @param {Object} callback.result          The resulting expression
         * @param {String} callback.result.value    The string representation of the expression to inspect
         * @param {Object} callback.result.pos      The expression's position
         * @param {Number} callback.result.pos.sl   The expression's starting row
         * @param {Number} callback.result.pos.el   The expression's ending row
         * @param {Number} callback.result.pos.sc   The expression's starting column
         * @param {Number} callback.result.pos.ec   The expression's ending column
         */
        getInspectExpression: function(doc, fullAst, pos, currentNode, callback) {
            callback();
        }
    };

// Mark all abstract/builtin methods for later optimization
    for (f in module.exports) {
        if (typeof module.exports[f] === "function")
            module.exports[f].base_handler = true;
    }

});

},
'dgrid/OnDemandGrid':function(){
define([
	'dojo/_base/declare',
	'./Grid',
	'./OnDemandList'
], function (declare, Grid, OnDemandList) {
	return declare([ Grid, OnDemandList ], {});
});
},
'xide/data/TreeMemory':function(){
/** @module xide/data/TreeMemory **/
define([
    "dojo/_base/declare",
    'xide/data/Memory',
    'dstore/Tree',
    'dojo/Deferred',
    'dstore/QueryResults'
], function (declare, Memory, Tree, Deferred, QueryResults) {

    /**
     * 
     */
    return declare('xide.data.TreeMemory', [Memory, Tree], {
        _state: {
            filter: null
        },
        parentField: 'parentId',
        reset: function () {
            this._state.filter = null;
            this.resetQueryLog();
        },
        resetQueryLog: function () {
            this.queryLog = [];
        },
        fetchRange: function () {
            // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
            // so we need to extend this as well.
            var results = this._fetchRange(arguments);
            return new QueryResults(results.then(function (data) {
                return data;
            }), {
                totalLength: results.then(function (data) {
                    return data.length;
                })
            });
        },
        filter: function (data) {
            var _res = this.inherited(arguments);
            this._state.filter = data;
            return _res;
        },
        _fetchRange: function (kwArgs) {
            var deferred = new Deferred();
            var _res = this.fetchRangeSync(kwArgs);
            var thiz = this;
            if (this._state.filter) {
                //the parent query
                if (this._state && this._state.filter && this._state.filter['parent']) {

                    var _item = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        var _query = {};
                        if (this.getChildrenSync) {
                            _res = this.getChildrenSync(_item);
                        } else {
                            _query[this.parentField] = _item[this.idProperty];
                            _res = this.root.query(_query);
                        }
                    }
                }

                //the group query
                if (this._state && this._state.filter && this._state.filter['group']) {
                    var _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res = _item.items;
                    }
                }
            }
            deferred.resolve(_res);
            return deferred;
        },
        children: function (parent) {
            var filter = {};
            var all = this.root.data, out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj[this.parentField] == parent[this.idProperty]) {
                    out.push(obj);
                }
            }
            return all;
        },
        mayHaveChildren: function (parent) {
            if (parent._mayHaveChildren === false) {
                return false;
            }
            return true;
        }
    });
});

},
'xbox/XBoxCommons':function(){
define([
    'dojo/_base/declare',
    'xide/utils',
    'xide/types',
    'xide/types/Types',
    'xaction/types',
    'xide/utils/StringUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/CIUtils',
    'xide/utils/StoreUtils',
    'xide/utils/WidgetUtils',
    'xide/utils/ObjectUtils',
    'xide/factory/Objects',
    'xide/factory/Events',
    'xfile/types',
    'xfile/config',
    'xfile/factory/Store'
],function(declare){
    Array.prototype.remove= function(){
        var what, a= arguments, L= a.length, ax;
        while(L && this.length){
            what= a[--L];
            if(this.indexOf==null){
                return;
            }
            while((ax= this.indexOf(what))!= -1){
                this.splice(ax, 1);
            }
        }
        return this;
    };
    return  declare("xbox.XBoxCommons", null,{});
});
},
'xide/manager/ContextBase':function(){
/** module:xide/manager/ContextBase **/
define([
    'dcl/dcl',
    'xide/factory',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'dojo/_base/kernel',
    'dojo/_base/lang'
], function (dcl,factory, types,utils,EventedMixin,dojo,lang) {
    var _debug = false;
    /**
     * @class module:xide/manager/ContextBase
     * @extends module:xide/mixins/EventedMixin
     */
    var Module = dcl(EventedMixin.dcl,{
        declaredClass:"xide.manager.ContextBase",
        language: "en",
        managers: [],
        mixins: null,
        /**
         *
         * @param module {string}
         * @returns {*|Object|null}
         */
        getModule:function(module){
            return lang.getObject(utils.replaceAll('/', '.', module)) || lang.getObject(module) || (dcl.getObject ? dcl.getObject(module) || dcl.getObject(utils.replaceAll('/', '.', module)) : null);
        },
        /***
         * createManager creates and instances and tracks it in a local array.
         * @param clz : class name or prototype
         * @param config {object|null}: explicit config, otherwise its using local config
         * @param ctrArgs {object|null}: extra constructor arguments
         * @returns {module:xide/manager/ManagerBase} : instance of the manager
         */
        createManager: function (clz, config, ctrArgs) {
            try {
                if (!this.managers) {
                    this.managers = [];
                }
                //1. prepare constructor arguments
                var ctrArgsFinal = {
                    ctx: this,
                    config: config || this.config
                };
                utils.mixin(ctrArgsFinal, ctrArgs);
                if (_.isString(clz) && this.namespace) {
                    var _clz = null;
                    if (clz.indexOf('.') == -1) {
                        _clz = this.namespace + clz;
                    } else {
                        _clz = '' + clz;
                    }
                    //test this really exists, if not fallback to default namespace
                    if (!dojo.getObject(_clz) || !dcl.getObject(_clz)) {
                        _debug && console.log('creating manager instance : ' + _clz + ' doesnt exists!' + ' Using default! ');
                        clz = this.defaultNamespace + clz;
                    } else {
                        clz = _clz;
                    }
                    _debug && console.log('creating manager instance : ' + clz);
                } else if (_.isObject(clz)) {
                    _debug &&  console.log('creating manager instance : ' + (clz.declaredClass || clz.prototype.declaredClass));
                }

                //2. create instance
                var mgr = factory.createInstance(clz, ctrArgsFinal);
                if (!mgr) {
                    _debug && console.error('creating manager instance failed : ' + clz);
                    return;
                }

                //3. track instance
                this.managers.push(mgr);

                //4. tell everybody
                factory.publish(types.EVENTS.ON_CREATED_MANAGER, {
                    instance: mgr,
                    className: clz,
                    ctx: this,
                    config: config || this.config
                });
                return mgr;
            } catch (e) {
                console.error('error creating manager ' + e, arguments);
            }
        },
        constructManagers: function () {},
        initManagers: function () {},
        /***
         * Monkey patch prototypes
         * @param mixins
         */
        doMixins: function (mixins) {
            this.mixins = mixins || this.mixins;
            for (var i = 0; i < mixins.length; i++) {
                var mixin = mixins[i];
                var obj = dojo.getObject(mixin.declaredClass) || dcl.getObject(mixin.declaredClass);
                if (mixin.declaredClass === this.declaredClass) {
                    obj = this;
                }
                if (obj) {
                    utils.mixin(obj.prototype, mixin.mixin);
                } else {
                    _debug && console.error('couldnt apply mixin to : ' + mixin.declaredClass);
                }
            }
        }
    });
    dcl.chainAfter(Module,'constructManagers');
    dcl.chainAfter(Module,'initManagers');
    return Module;
});
},
'dojo/Deferred':function(){
/** module:dojo/Deferred **/
define([
	"./has",
	"./_base/lang",
	"./errors/CancelError",
	"./promise/Promise",
	"./promise/instrumentation"
], function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				typeof logError !=='undefined' ? logError(error): console.error('error! ',error);
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};
    /**
     * @class module:dojo/Deferred
     * @param canceler {function}
     * @constructor
     */
	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if( 1  && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if( 1  && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
});

},
'dgrid/Grid':function(){
define([
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/has',
	'./List',
	'./util/misc',
	'dojo/_base/sniff'
], function (declare, lang, domConstruct, domClass, listen, has, List, miscUtil) {
	function appendIfNode(parent, subNode) {
		if (subNode && subNode.nodeType) {
			parent.appendChild(subNode);
		}
	}

	function replaceInvalidChars(str) {
		// Replaces invalid characters for a CSS identifier with hyphen,
		// as dgrid does for field names / column IDs when adding classes.
		return miscUtil.escapeCssIdentifier(str, '-');
	}

	var Grid = declare(List, {
		columns: null,

		// hasNeutralSort: Boolean
		//		Determines behavior of toggling sort on the same column.
		//		If false, sort toggles between ascending and descending and cannot be
		//		reset to neutral without sorting another column.
		//		If true, sort toggles between ascending, descending, and neutral.
		hasNeutralSort: false,

		// cellNavigation: Boolean
		//		This indicates that focus is at the cell level. This may be set to false to cause
		//		focus to be at the row level, which is useful if you want only want row-level
		//		navigation.
		cellNavigation: true,

		tabableHeader: true,
		showHeader: true,
		column: function (target) {
			// summary:
			//		Get the column object by node, or event, or a columnId
			if (typeof target !== 'object') {
				return this.columns[target];
			}
			else {
				return this.cell(target).column;
			}
		},
		listType: 'grid',
		cell: function (target, columnId) {
			// summary:
			//		Get the cell object by node, or event, id, plus a columnId

			if (target.column && target.element) {
				return target;
			}

			if (target.target && target.target.nodeType) {
				// event
				target = target.target;
			}
			var element;
			if (target.nodeType) {
				do {
					if (this._rowIdToObject[target.id]) {
						break;
					}
					var colId = target.columnId;
					if (colId) {
						columnId = colId;
						element = target;
						break;
					}
					target = target.parentNode;
				} while (target && target !== this.domNode);
			}
			if (!element && typeof columnId !== 'undefined') {
				var row = this.row(target),
					rowElement = row && row.element;
				if (rowElement) {
					var elements = rowElement.getElementsByTagName('td');
					for (var i = 0; i < elements.length; i++) {
						if (elements[i].columnId === columnId) {
							element = elements[i];
							break;
						}
					}
				}
			}
			if (target != null) {
				return {
					row: row || this.row(target),
					column: columnId && this.column(columnId),
					element: element
				};
			}
		},

		createRowCells: function (tag, createCell, subRows, item, options) {
			// summary:
			//		Generates the grid for each row (used by renderHeader and and renderRow)
			var row = domConstruct.create('table', {
					className: 'dgrid-row-table',
					role: 'presentation'
				}),
				// IE < 9 needs an explicit tbody; other browsers do not
				tbody = (has('ie') < 9) ? domConstruct.create('tbody', null, row) : row,
				tr,
				si, sl, i, l, // iterators
				subRow, column, id, extraClasses, className,
				cell, colSpan, rowSpan; // used inside loops

			// Allow specification of custom/specific subRows, falling back to
			// those defined on the instance.
			subRows = subRows || this.subRows;

			for (si = 0, sl = subRows.length; si < sl; si++) {
				subRow = subRows[si];
				// for single-subrow cases in modern browsers, TR can be skipped
				// http://jsperf.com/table-without-trs
				tr = domConstruct.create('tr', null, tbody);
				if (subRow.className) {
					tr.className = subRow.className;
				}

				for (i = 0, l = subRow.length; i < l; i++) {
					// iterate through the columns
					column = subRow[i];
					id = column.id;

					extraClasses = column.field ?
						' field-' + replaceInvalidChars(column.field) :
						'';
					className = typeof column.className === 'function' ?
						column.className(item) : column.className;
					if (className) {
						extraClasses += ' ' + className;
					}

					cell = domConstruct.create(tag, {
						className: 'dgrid-cell' +
							(id ? ' dgrid-column-' + replaceInvalidChars(id) : '') + extraClasses,
						role: tag === 'th' ? 'columnheader' : 'gridcell'
					});
					cell.columnId = id;
					colSpan = column.colSpan;
					if (colSpan) {
						cell.colSpan = colSpan;
					}
					rowSpan = column.rowSpan;
					if (rowSpan) {
						cell.rowSpan = rowSpan;
					}
					createCell(cell, column, item, options);
					// add the td to the tr at the end for better performance
					tr.appendChild(cell);
				}
			}
			return row;
		},

		_createBodyRowCell: function (cellElement, column, item, options) {
			var cellData = item;

			// Support get function or field property (similar to DataGrid)
			if (column.get) {
				cellData = column.get(item);
			}
			else if ('field' in column && column.field !== '_item') {
				cellData = item[column.field];
			}

			if (column.renderCell) {
				// A column can provide a renderCell method to do its own DOM manipulation,
				// event handling, etc.
				appendIfNode(cellElement, column.renderCell(item, cellData, cellElement, options));
			}
			else {
				this._defaultRenderCell.call(column, item, cellData, cellElement, options);
			}
		},

		_createHeaderRowCell: function (cellElement, column) {
			var contentNode = column.headerNode = cellElement;
			var field = column.field;
			if (field) {
				cellElement.field = field;
			}
			// allow for custom header content manipulation
			if (column.renderHeaderCell) {
				appendIfNode(contentNode, column.renderHeaderCell(contentNode));
			}
			else if ('label' in column || column.field) {
				contentNode.appendChild(document.createTextNode(
					'label' in column ? column.label : column.field));
			}
			if (column.sortable !== false && field && field !== '_item') {
				cellElement.sortable = true;
				cellElement.className += ' dgrid-sortable';
			}
		},

		left: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			return this.cell(this._move(cell, -(steps || 1), 'dgrid-cell'));
		},
		right: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			return this.cell(this._move(cell, steps || 1, 'dgrid-cell'));
		},

		_defaultRenderCell: function (object, value, td) {
			// summary:
			//		Default renderCell implementation.
			//		NOTE: Called in context of column definition object.
			// object: Object
			//		The data item for the row currently being rendered
			// value: Mixed
			//		The value of the field applicable to the current cell
			// td: DOMNode
			//		The cell element representing the current item/field
			// options: Object?
			//		Any additional options passed through from renderRow

			if (this.formatter) {
				// Support formatter, with or without formatterScope
				var formatter = this.formatter,
					formatterScope = this.grid.formatterScope;
				td.innerHTML = typeof formatter === 'string' && formatterScope ?
					formatterScope[formatter](value, object) : this.formatter(value, object);
			}
			else if (value != null) {
				td.appendChild(document.createTextNode(value));
			}
		},

		renderRow: function (item, options) {
			var row = this.createRowCells('td', lang.hitch(this, '_createBodyRowCell'),
				options && options.subRows, item, options);

			// row gets a wrapper div for a couple reasons:
			// 1. So that one can set a fixed height on rows (heights can't be set on <table>'s AFAICT)
			// 2. So that outline style can be set on a row when it is focused,
			// and Safari's outline style is broken on <table>
			var div = domConstruct.create('div', { role: 'row' });
			div.appendChild(row);
			return div;
		},

		renderHeader: function () {
			// summary:
			//		Setup the headers for the grid
			var grid = this,
				headerNode = this.headerNode;

			headerNode.setAttribute('role', 'row');

			// clear out existing header in case we're resetting
			domConstruct.empty(headerNode);

			var row = this.createRowCells('th', lang.hitch(this, '_createHeaderRowCell'),
				this.subRows && this.subRows.headerRows);
			this._rowIdToObject[row.id = this.id + '-header'] = this.columns;
			headerNode.appendChild(row);

			// If the columns are sortable, re-sort on clicks.
			// Use a separate listener property to be managed by renderHeader in case
			// of subsequent calls.
			if (this._sortListener) {
				this._sortListener.remove();
			}
			this._sortListener = listen(row, 'click,keydown', function (event) {
				// respond to click, space keypress, or enter keypress
				if (event.type === 'click' || event.keyCode === 32 ||
						(!has('opera') && event.keyCode === 13)) {
					var target = event.target;
					var field;
					var sort;
					var newSort;
					var eventObj;

					do {
						if (target.sortable) {
							field = target.field || target.columnId;
							sort = grid.sort[0];
							if (!grid.hasNeutralSort || !sort || sort.property !== field || !sort.descending) {
								// If the user toggled the same column as the active sort,
								// reverse sort direction
								newSort = [{
									property: field,
									descending: sort && sort.property === field &&
										!sort.descending
								}];
							}
							else {
								// If the grid allows neutral sort and user toggled an already-descending column,
								// clear sort entirely
								newSort = [];
							}

							// Emit an event with the new sort
							eventObj = {
								bubbles: true,
								cancelable: true,
								grid: grid,
								parentType: event.type,
								sort: newSort
							};

							if (listen.emit(event.target, 'dgrid-sort', eventObj)) {
								// Stash node subject to DOM manipulations,
								// to be referenced then removed by sort()
								grid._sortNode = target;
								grid.set('sort', newSort);
							}

							break;
						}
					} while ((target = target.parentNode) && target !== headerNode);
				}
			});
		},

		resize: function () {
			// extension of List.resize to allow accounting for
			// column sizes larger than actual grid area
			if(!this.headerNode){
				return;
			}
			var headerTableNode = this.headerNode.firstChild,
				contentNode = this.contentNode,
				width;

			this.inherited(arguments);

			// Force contentNode width to match up with header width.
			contentNode.style.width = ''; // reset first
			if (contentNode && headerTableNode) {
				if ((width = headerTableNode.offsetWidth) > contentNode.offsetWidth) {
					// update size of content node if necessary (to match size of rows)
					// (if headerTableNode can't be found, there isn't much we can do)
					contentNode.style.width = width + 'px';
				}
			}
		},

		destroy: function () {
			// Run _destroyColumns first to perform any column plugin tear-down logic.
			this._destroyColumns();
			if (this._sortListener) {
				this._sortListener.remove();
			}

			this.inherited(arguments);
		},

		_setSort: function () {
			// summary:
			//		Extension of List.js sort to update sort arrow in UI

			// Normalize sort first via inherited logic, then update the sort arrow
			this.inherited(arguments);
			this.updateSortArrow(this.sort);
		},

		_findSortArrowParent: function (field) {
			// summary:
			//		Method responsible for finding cell that sort arrow should be
			//		added under.  Called by updateSortArrow; separated for extensibility.

			var columns = this.columns;
			for (var i in columns) {
				var column = columns[i];
				if (column.field === field) {
					return column.headerNode;
				}
			}
		},

		updateSortArrow: function (sort, updateSort) {
			// summary:
			//		Method responsible for updating the placement of the arrow in the
			//		appropriate header cell.  Typically this should not be called (call
			//		set("sort", ...) when actually updating sort programmatically), but
			//		this method may be used by code which is customizing sort (e.g.
			//		by reacting to the dgrid-sort event, canceling it, then
			//		performing logic and calling this manually).
			// sort: Array
			//		Standard sort parameter - array of object(s) containing property name
			//		and optional descending flag
			// updateSort: Boolean?
			//		If true, will update this.sort based on the passed sort array
			//		(i.e. to keep it in sync when custom logic is otherwise preventing
			//		it from being updated); defaults to false

			// Clean up UI from any previous sort
			if (this._lastSortedArrow) {
				// Remove the sort classes from the parent node
				domClass.remove(this._lastSortedArrow.parentNode, 'dgrid-sort-up dgrid-sort-down');
				// Destroy the lastSortedArrow node
				domConstruct.destroy(this._lastSortedArrow);
				delete this._lastSortedArrow;
			}

			if (updateSort) {
				this.sort = sort;
			}
			if (!sort[0]) {
				return; // Nothing to do if no sort is specified
			}

			var prop = sort[0].property,
				desc = sort[0].descending,
				// if invoked from header click, target is stashed in _sortNode
				target = this._sortNode || this._findSortArrowParent(prop),
				arrowNode;

			delete this._sortNode;

			// Skip this logic if field being sorted isn't actually displayed
			if (target) {
				target = target.contents || target;
				// Place sort arrow under clicked node, and add up/down sort class
				arrowNode = this._lastSortedArrow = domConstruct.create('div', {
					className: 'dgrid-sort-arrow ui-icon',
					innerHTML: '&nbsp;',
					role: 'presentation'
				}, target, 'first');
				domClass.add(target, 'dgrid-sort-' + (desc ? 'down' : 'up'));
				// Call resize in case relocation of sort arrow caused any height changes
				this.resize();
			}
		},

		styleColumn: function (colId, css) {
			// summary:
			//		Dynamically creates a stylesheet rule to alter a column's style.

			return this.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) +
				' .dgrid-column-' + replaceInvalidChars(colId), css);
		},

		/*=====
		_configColumn: function (column, rowColumns, prefix) {
			// summary:
			//		Method called when normalizing base configuration of a single
			//		column.  Can be used as an extension point for behavior requiring
			//		access to columns when a new configuration is applied.
		},=====*/

		_configColumns: function (prefix, rowColumns) {
			// configure the current column
			var subRow = [],
				isArray = rowColumns instanceof Array;

			function configColumn(column, columnId) {
				if (typeof column === 'string') {
					rowColumns[columnId] = column = { label: column };
				}
				if (!isArray && !column.field) {
					column.field = columnId;
				}
				columnId = column.id = column.id || (isNaN(columnId) ? columnId : (prefix + columnId));
				// allow further base configuration in subclasses
				if (this._configColumn) {
					this._configColumn(column, rowColumns, prefix);
					// Allow the subclasses to modify the column id.
					columnId = column.id;
				}
				if (isArray) {
					this.columns[columnId] = column;
				}

				// add grid reference to each column object for potential use by plugins
				column.grid = this;
				subRow.push(column); // make sure it can be iterated on
			}

			miscUtil.each(rowColumns, configColumn, this);
			return isArray ? rowColumns : subRow;
		},

		_destroyColumns: function () {
			// summary:
			//		Extension point for column-related cleanup.  This is called
			//		immediately before configuring a new column structure,
			//		and when the grid is destroyed.

			// First remove rows (since they'll be refreshed after we're done),
			// so that anything temporarily extending removeRow can run.
			// (cleanup will end up running again, but with nothing to iterate.)
			this.cleanup();
		},

		configStructure: function () {
			// configure the columns and subRows
			var subRows = this.subRows,
				columns = this._columns = this.columns;

			// Reset this.columns unless it was already passed in as an object
			this.columns = !columns || columns instanceof Array ? {} : columns;

			if (subRows) {
				// Process subrows, which will in turn populate the this.columns object
				for (var i = 0; i < subRows.length; i++) {
					subRows[i] = this._configColumns(i + '-', subRows[i]);
				}
			}
			else {
				this.subRows = [this._configColumns('', columns)];
			}
		},

		_getColumns: function () {
			// _columns preserves what was passed to set("columns"), but if subRows
			// was set instead, columns contains the "object-ified" version, which
			// was always accessible in the past, so maintain that accessibility going
			// forward.
			return this._columns || this.columns;
		},
		_setColumns: function (columns) {
			this._destroyColumns();
			// reset instance variables
			this.subRows = null;
			this.columns = columns;
			// re-run logic
			this._updateColumns();
		},

		_setSubRows: function (subrows) {
			this._destroyColumns();
			this.subRows = subrows;
			this._updateColumns();
		},

		_updateColumns: function () {
			// summary:
			//		Called when columns, subRows, or columnSets are reset

			this.configStructure();
			this.renderHeader();

			this.refresh();
			// re-render last collection if present
			this._lastCollection && this.renderArray(this._lastCollection);

			// After re-rendering the header, re-apply the sort arrow if needed.
			if (this._started) {
				if (this.sort.length) {
					this._lastSortedArrow = null;
					this.updateSortArrow(this.sort);
				} else {
					// Only call resize directly if we didn't call updateSortArrow,
					// since that calls resize itself when it updates.
					this.resize();
				}
			}
		}
	});

	Grid.appendIfNode = appendIfNode;

	return Grid;
});

},
'dgrid/util/misc':function(){
define([
	'dojo/has'
], function (has) {
	// summary:
	//		This module defines miscellaneous utility methods for purposes of
	//		adding styles, and throttling/debouncing function calls.

	has.add('dom-contains', function (global, doc, element) {
		return !!element.contains; // not supported by FF < 9
	});

	// establish an extra stylesheet which addCssRule calls will use,
	// plus an array to track actual indices in stylesheet for removal
	var extraRules = [],
		extraSheet,
		removeMethod,
		rulesProperty,
		invalidCssChars = /([^A-Za-z0-9_\u00A0-\uFFFF-])/g;

	function removeRule(index) {
		// Function called by the remove method on objects returned by addCssRule.
		var realIndex = extraRules[index],
			i, l;
		if (realIndex === undefined) {
			return; // already removed
		}

		// remove rule indicated in internal array at index
		extraSheet[removeMethod](realIndex);

		// Clear internal array item representing rule that was just deleted.
		// NOTE: we do NOT splice, since the point of this array is specifically
		// to negotiate the splicing that occurs in the stylesheet itself!
		extraRules[index] = undefined;

		// Then update array items as necessary to downshift remaining rule indices.
		// Can start at index + 1, since array is sparse but strictly increasing.
		for (i = index + 1, l = extraRules.length; i < l; i++) {
			if (extraRules[i] > realIndex) {
				extraRules[i]--;
			}
		}
	}

	var util = {
		// Throttle/debounce functions


		defaultDelay: 15,
		throttle: function (cb, context, delay) {
			// summary:
			//		Returns a function which calls the given callback at most once per
			//		delay milliseconds.  (Inspired by plugd)
			var ran = false;
			delay = delay || util.defaultDelay;
			return function () {
				if (ran) {
					return;
				}
				ran = true;
				cb.apply(context, arguments);
				setTimeout(function () {
					ran = false;
				}, delay);
			};
		},
		throttleDelayed: function (cb, context, delay) {
			// summary:
			//		Like throttle, except that the callback runs after the delay,
			//		rather than before it.
			var ran = false;
			delay = delay || util.defaultDelay;
			return function () {
				if (ran) {
					return;
				}
				ran = true;
				var a = arguments;
				setTimeout(function () {
					ran = false;
					cb.apply(context, a);
				}, delay);
			};
		},
		debounce: function (cb, context, delay) {
			// summary:
			//		Returns a function which calls the given callback only after a
			//		certain time has passed without successive calls.  (Inspired by plugd)
			var timer;
			delay = delay || util.defaultDelay;
			return function () {
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}
				var a = arguments;
				timer = setTimeout(function () {
					cb.apply(context, a);
				}, delay);
			};
		},

		// Iterative functions

		each: function (arrayOrObject, callback, context) {
			// summary:
			//		Given an array or object, iterates through its keys.
			//		Does not use hasOwnProperty (since even Dojo does not
			//		consistently use it), but will iterate using a for or for-in
			//		loop as appropriate.

			var i, len;

			if (!arrayOrObject) {
				return;
			}

			if (typeof arrayOrObject.length === 'number') {
				for (i = 0, len = arrayOrObject.length; i < len; i++) {
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}
			else {
				for (i in arrayOrObject) {
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}
		},

		// DOM-related functions

		contains: function (parent, node) {
			// summary:
			//		Checks to see if an element is contained in another element.

			if (has('dom-contains')) {
				return parent.contains(node);
			}
			else {
				return parent.compareDocumentPosition(node) & /* DOCUMENT_POSITION_CONTAINS */ 8;
			}
		},

		// CSS-related functions

		addCssRule: function (selector, css) {
			// summary:
			//		Dynamically adds a style rule to the document.  Returns an object
			//		with a remove method which can be called to later remove the rule.

			if (!extraSheet) {
				// First time, create an extra stylesheet for adding rules
				extraSheet = document.createElement('style');
				document.getElementsByTagName('head')[0].appendChild(extraSheet);
				// Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
				extraSheet = extraSheet.sheet || extraSheet.styleSheet;
				// Store name of method used to remove rules (`removeRule` for IE < 9)
				removeMethod = extraSheet.deleteRule ? 'deleteRule' : 'removeRule';
				// Store name of property used to access rules (`rules` for IE < 9)
				rulesProperty = extraSheet.cssRules ? 'cssRules' : 'rules';
			}

			var index = extraRules.length;
			extraRules[index] = (extraSheet.cssRules || extraSheet.rules).length;
			extraSheet.addRule ?
				extraSheet.addRule(selector, css) :
				extraSheet.insertRule(selector + '{' + css + '}', extraRules[index]);

			return {
				get: function (prop) {
					return extraSheet[rulesProperty][extraRules[index]].style[prop];
				},
				set: function (prop, value) {
					if (typeof extraRules[index] !== 'undefined') {
						extraSheet[rulesProperty][extraRules[index]].style[prop] = value;
					}
				},
				remove: function () {
					removeRule(index);
				}
				
			};
		},

		escapeCssIdentifier: function (id, replace) {
			// summary:
			//		Escapes normally-invalid characters in a CSS identifier (such as . or :);
			//		see http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
			// id: String
			//		CSS identifier (e.g. tag name, class, or id) to be escaped
			// replace: String?
			//		If specified, indicates that invalid characters should be
			//		replaced by the given string rather than being escaped

			return typeof id === 'string' ? id.replace(invalidCssChars, replace || '\\$1') : id;
		}
	};
	return util;
});
},
'dojo/dom':function(){
define(["./sniff", "./_base/window"],
		function(has, win){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	dom.isDescendant = function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
		// summary:
		//		Returns true if node is a descendant of ancestor
		// node: DOMNode|String
		//		string id or node reference to test
		// ancestor: DOMNode|String
		//		string id or node reference of potential parent to test against
		//
		// example:
		//		Test is node id="bar" is a descendant of node id="foo"
		//	|	require(["dojo/dom"], function(dom){
		//	|		if(dom.isDescendant("bar", "foo")){ ... }
		//	|	});

		try{
			node = dom.byId(node);
			ancestor = dom.byId(ancestor);
			while(node){
				if(node == ancestor){
					return true; // Boolean
				}
				node = node.parentNode;
			}
		}catch(e){ /* squelch, return false */ }
		return false; // Boolean
	};


	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }
		
		var style = element.style;
		var prefixes = ["Khtml", "O", "ms", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
});

},
'dojo/window':function(){
define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") < 9 && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera")) && ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
						if(elPos.x < 0 || !isIE || isIE >= 9){ elPos.x = 0; } // older IE can have values > 0
						if(elPos.y < 0 || !isIE || isIE >= 9){ elPos.y = 0; }
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
						old = el.scrollLeft;
						el.scrollLeft += s;
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						el.scrollTop += s;
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	 1  && lang.setObject("dojo.window", window);

	return window;
});

},
'xgrid/Defaults':function(){
/** @module xgrid/Defaults **/
define([
    'xdojo/declare'
], function (declare) {
    /**
     * xGrid defaults
     * */
    return declare('xgrid/Defaults', null, {
        minRowsPerPage: 100,
        keepScrollPosition: true,
        rowsPerPage: 30,
        deselectOnRefresh: false,
        cellNavigation: false,
        _skipFirstRender: false,
        loadingMessage: null,
        preload: null,
        childSelector: ".dgrid-row",
        addUiClasses: false,
        noDataMessage: '<span class="textWarning">No data....</span>',
        showExtraSpace:true
    });
});

},
'dojo/_base/lang':function(){
define(["./kernel", "../has", "../sniff"], function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			var p, i = 0, dojoGlobal = dojo.global;
			if(!context){
				if(!parts.length){
					return dojoGlobal;
				}else{
					p = parts[i++];
					try{
						context = dojo.scopeMap[p] && dojo.scopeMap[p][1];
					}catch(e){}
					context = context || (p in dojoGlobal ? dojoGlobal[p] : (create ? dojoGlobal[p] = {} : undefined));
				}
			}
			while(context && (p = parts[i++])){
				context = (p in context ? context[p] : (create ? context[p] = {} : undefined));
			}
			return context; // mixed
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
                if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: function(it){
			// summary:
			//		Return true if it is an Array.
			//		Does not work on Arrays created in other windows.
			// it: anything
			//		Item to test.
			return it && (it instanceof Array || typeof it == "array"); // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return it && it !== undefined && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the a given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r.push(lang.clone(src[i]));
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	 1  && lang.mixin(dojo, lang);

	return lang;
});


},
'xfile/model/File':function(){
/** @module xfile/model/File **/
define([
    "xdojo/declare",
    "xide/data/Model",
    "xide/utils",
    "xide/types"
], function (declare, Model, utils, types) {
    /**
     * @class module:xfile/model/File
     */
    return declare('xfile.model.File', [Model], {
        getFolder: function () {
            var path = this.getPath();
            if (this.directory) {
                return path;
            }
            return utils.pathinfo(path, types.PATH_PARTS.ALL).dirname;
        },
        getChildren: function () {
            return this.children;
        },
        getParent: function () {
            //current folder:
            var store = this.getStore() || this._S;
            return store.getParent(this);
        },
        getStore: function () {
            return this._store || this._S;
        }
    });
});

},
'xide/registry':function(){
/** module:xide/registry **/
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
    "xdojo/has"
], function(array, win, has){
	/**
	 * @TODOS:
	 * - add namespaces
	 * - remove window
	 * - augment consumer API
	 * - use std array
	 * - add framework constraint
	 * - move dom api out of here
	 * - define widget.id better
	 * - add search by class
     */
	var _widgetTypeCtr = {}, hash = {};
	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,
		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
                if( false ) {
                    this.remove(widget.id);
                    this.add(widget);
                }else{
                    throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
                }
			}
			hash[widget.id] = widget;
			this.length++;
		},
		/**
		 * Remove a widget from the registry. Does not destroy the widget; simply
		 * removes the reference.
		 * @param id
         */
		remove: function(id){
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},
		/**
		 *
		 * @param id {String|Widget}
		 * @returns {String|Widget}
         */
		byId: function( id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},
		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		/**
		 * Convert registry into a true Array
		 * @example:
		 *	Work with the widget .domNodes in a real Array
		 *	array.map(registry.toArray(), function(w){ return w.domNode; });
		 * @returns {obj[]}
         */
		toArray: function(){
			return _.values(_.mapKeys(hash, function(value, key) { value.id = key; return value; }));
		},
		/**
		 * Generates a unique id for a given widgetType
		 * @param widgetType {string}
		 * @returns {string}
         */
		getUniqueId: function(widgetType){
			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return id;
		},
		/**
		 * Search subtree under root returning widgets found.
		 * Doesn't search for nested widgets (ie, widgets inside other widgets).
		 * @param root {HTMLElement} Node to search under.
		 * @param skipNode {HTMLElement} If specified, don't search beneath this node (usually containerNode).
         * @returns {Array}
         */
		findWidgets: function(root, skipNode){
			var outAry = [];
			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}
			getChildrenHelper(root);
			return outAry;
		},
		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			// Destroy all the widgets, top down
			_.each(registry.findWidgets(win.body()),function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},
		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};
	return registry;
});

},
'xgrid/Search':function(){
/** @module xgrid/Search **/
define([
    'xdojo/declare',
    'xide/widgets/_Search',
    'dojo/on',
    'xide/Keyboard',
    'xide/types'
], function (declare,Search,on,Keyboard,types) {
    /**
     * @class module:xGrid/Search
     * */
    return declare('xgrid/Search', null,{
        _searchText:null,
        _search:null,
        runAction:function(action){
            if(action && action.command==types.ACTION.SEARCH){
                if(this._search) {
                    if(this._search.isHidden()) {
                        this._search.show('', false);
                    }else{
                        this._search.hide();
                    }
                }
            }
            return this.inherited(arguments);
        },
        buildRendering: function () {

            this.inherited(arguments);

            var grid = this,
                node = grid.domNode.parentNode,
                search = new Search({});

            search.find = function(){
                grid._searchText = this.searchInput.value;
                grid.set("collection", grid.collection);
            };
            search.showSearchBox(node);
            search.show('',false);
            search.hide();

            this._search = search;
            on(search.searchInput,'keydown',function(e){
                if(e.code ==='Escape'){
                    search.hide();
                    grid.focus();
                }
            });

            var mapping = Keyboard.defaultMapping(['ctrl f'], function(){
                search.show('',false);
            }, types.KEYBOARD_PROFILE.DEFAULT, grid.domNode, grid,null);

            this.registerKeyboardMapping(mapping);
            this._on('onAddActions',function(evt){
                var actions = evt.actions,
                    permissions = evt.permissions;
                    action = types.ACTION.SEARCH;

                if(!evt.store.getSync(action)) {
                    var _action = grid.createAction('Search', action, types.ACTION_ICON.SEARCH, ['ctrl f'], 'Home', 'File', 'item|view', null, null, null, null, null, permissions, node, grid);
                    if (!_action) {
                        return;
                    }
                    actions.push(_action);
                }
            });
        },
        _setCollection: function (collection) {
            var res = this.inherited(arguments);
            var value = this._searchText;
            var renderedCollection = this._renderedCollection;
            if (renderedCollection && value) {
                var rootFilter = new renderedCollection.Filter();
                var re = new RegExp(value, "i");
                var columns = this.columns;
                var matchFilters = [];
                for (var p in columns) {
                    if (columns.hasOwnProperty(p)) {

                        var what = columns[p].searchText || columns[p].field;

                        matchFilters.push(rootFilter.match(what, re));
                    }
                }
                var combined = rootFilter.or.apply(rootFilter, matchFilters);
                this._renderedCollection = renderedCollection.filter(combined);
                this.refresh();
            }
            return res;
        }
    });
});

},
'dojo/sniff':function(){
define(["./has"], function(has){
	// module:
	//		dojo/sniff

	/*=====
	 return function(){
	 // summary:
	 //		This module sets has() flags based on the current browser.
	 //		It returns the has() function.
	 };
	 =====*/

	if( 1 ){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
			&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
			&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
		&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
		&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
			&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
				&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
});

},
'xide/widgets/FileWidget':function(){
define([
    'dcl/dcl',
    "dojo/_base/declare",
    "dojo/_base/lang",
    "xide/widgets/WidgetBase",
    "xide/widgets/EditBox",
    'xide/factory',
    'xide/utils',
    'xfile/FileActions',
    "xfile/views/FileGridLight",
    "dojo/Deferred"
], function (dcl,declare, lang, WidgetBase, EditBox,factory, utils,FileActions,FileGridLight,Deferred) {
    return dcl([WidgetBase], {
        declaredClass:"xide.widgets.FileWidget",
        oriPath: null,
        minHeight: "54px;",
        value: "",
        options: null,
        dialogTitle: 'Select Script',
        editBox:null,
        templateString: "<div class='widgetContainer widgetBorder widgetTable widget' style=''>" +
        "<table border='0' cellpadding='5px' width='100%' >" +
        "<tbody>" +
        "<tr attachTo='extensionRoot'>" +
        "<td width='15%' class='widgetTitle'><span><b>${!title}</b><span></td>" +
        "<td width='80px' class='widgetValue2' valign='middle' attachTo='previewNode'></td>" +
        "<td class='extension' width='25px' attachTo='button0'></td>" +
        "<td class='extension' width='25px' attachTo='button1'></td>" +
        "<td class='extension' width='25px' attachTo='button2'></td>" +
        "</tr>" +
        "</tbody>" +
        "</table>" +
        "<div attachTo='expander' onclick='' style='width:100%;'></div>" +
        "<div attachTo='last'></div>" +
        "</div>",
        filePathValidator: function (value, constraints) {
            return true;
        },
        onFileSelected: function (dlg, item) {
            if (item) {

                var acceptFiles = utils.toBoolean(this.userData['acceptFiles']);
                var acceptFolders = utils.toBoolean(this.userData['acceptFolders']);
                var encodeFilePath = utils.toBoolean(this.userData['encodeFilePath']);
                var buildFullPath = utils.toBoolean(this.userData['buildFullPath']);
                var isDirectory = item.directory === true;

                if (isDirectory && !acceptFolders) {
                    return;
                } else if (!isDirectory && !acceptFiles) {
                    return;
                }
                this.userData.changed = true;
                this.userData.active = true;


                var _newPath = buildFullPath ? utils.buildPath(item.mount, item.path, encodeFilePath) : item.path;
                this.editBox.set('value', _newPath);
                this.value = _newPath;
                this.setValue(_newPath);

            }
        },
        getOptions: function () {
            var ctx = this.ctx || window['xFileContext'];
            var _defaultOptions = {
                title: this.dialogTitle,
                owner: ctx,
                dst: {
                    name: 'Select',
                    path: '.'
                },
                src: '.',
                ctx: ctx
            };
            var options = this.options || ctx.defaultOptions;
            if (options) {
                _defaultOptions = utils.mixin(_defaultOptions, options);
                console.dir(options);
            } else {
                console.error('have no options');
            }

            //there are file picker options in the CI?
            var userOptions = this.userData ? this.userData.filePickerOptions : {};
            if (userOptions) {
                _defaultOptions = utils.mixin(_defaultOptions, userOptions);
            }

            //we actually need a new store with different options
            if (_defaultOptions.store && _defaultOptions.defaultStoreName) {

                if (!userOptions || !userOptions.defaultStoreOptions) {
                    _defaultOptions.defaultStoreOptions = {
                        "fields": 1663,
                        "includeList": "*",
                        "excludeList": "*"
                    };
                }
                //get a new store
                _defaultOptions.store = ctx.getStore(_defaultOptions.defaultStoreName, _defaultOptions.defaultStoreOptions);

            }else if(userOptions.defaultStoreOptions){
                _defaultOptions.store = ctx.getStore(_defaultOptions.defaultStoreName, userOptions.defaultStoreOptions);
            }

            return _defaultOptions;
        },
        onSelect: function () {
            var self = this;

            utils.destroy(this.picker);

            if(this._onSelect){
                var _dlgDfd =this._onSelect(this);
                if(_dlgDfd.then){
                    _dlgDfd.then(function(val){
                        self.editBox.set('value',val);
                        self.setValue(val);
                    });
                }
                return _dlgDfd;
            }

            var thiz = this;
            var defaultOptions = this.getOptions();
            try {
                function done(item,selection,picker){
                    var firstItem = item;
                    var val = firstItem.realPath || firstItem.path;
                    self.editBox.set('value',val);
                    self.setValue(val);
                }
                var dfd = new Deferred();

                FileActions.createFilePicker(this,"",done,'Select File',null,defaultOptions,dfd,FileGridLight);


                //this.picker = picker;
                //this.add(picker);

            } catch (e) {
                console.error('file widget crash : ' + e);
                logError(e);
            }
        },

        set:function(what,value){
            if(this.editBox && what==='value'){
                this.editBox.set(what,value);
            }
            return this.inherited(arguments);
        },
        postMixInProperties: function () {

            if(this.userData && this.userData.widget && this.userData.widget.title){
                this.title=this.userData.widget.title;
            }

            if ((this.userData && this.userData.vertical === true) || this.vertical === true) {

                this.templateString = "<div class='widgetContainer widgetBorder widgetTable' style=''>" +
                    "<table border='0' cellpadding='5px' width='100%' >" +
                    "<tbody>" +
                    "<tr attachTo='extensionRoot'>" +
                    "<td width='100%' class='widgetTitle'><span><b>${!title}</b><span></td>" +
                    "</tr>" +
                    "<tr attachTo='extensionRoot'>" +
                    "<td width='100px' class='widgetValue2' valign='middle' attachTo='previewNode'></td>" +
                    "<td class='extension' width='25px' attachTo='button0'></td>" +
                    "<td class='extension' width='25px' attachTo='button1'></td>" +
                    "<td class='extension' width='25px' attachTo='button2'></td>" +
                    "</tr>" +
                    "</tbody>" +
                    "</table>" +
                    "<div attachTo='expander' onclick='' style='width:100%;'></div>" +
                    "<div attachTo='last'></div>" +
                    "</div>"
            }

            return this.inherited(arguments);
        },
        fillTemplate: function () {
            var value = utils.toString(this.userData['value']),
                self = this;

            var editBox = utils.addWidget(EditBox,{
                userData:this.userData,
                title:''
            },null,this.previewNode,true);

            this.editBox = editBox;
            editBox._on('change',function (val) {
                self.setValue(val);
            })

            var btn = factory.createSimpleButton('', 'fa-folder', 'btn-default', {
                style: ''
            });
            $(btn).click(function(){
                self.onSelect();
            })
            $(this.button0).append(btn);

            this.add(editBox);

        },
        startup: function () {

            this.inherited(arguments);
            this.fillTemplate();
            this.onReady();
        }
    });
});
},
'xbox/Imports/DojoRPCImports':function(){
define([
    'dojo/_base/declare',
    'dojo/_base/xhr' // dojo.xhrGet
    //'dojox/rpc/Service',
    //'dojox/data/ServiceStore',
    //'dojo/rpc/JsonService',
    //'dojox/rpc/JsonRPC'
],function(declare)
{
    return declare("xbox.DojoRPCImports", null,{});
});
},
'xide/widgets/EditBox':function(){
define([
    'dcl/dcl',
    "dojo/dom-construct",
    "xide/widgets/WidgetBase",
    "xide/utils"
], function (dcl,domConstruct,WidgetBase, utils) {

    return dcl(WidgetBase, {
        declaredClass:'xide.widgets.EditBox',
        value: "unset",
        _lastValue: null,
        instant:false,
        widgetChanged: function (value) {
            this.changed = true;
            if (this.userData) {
                this.userData.changed = true;
            }
            if (this.nativeWidget) {
                var _value = this.nativeWidget.val();
                this.setValue(_value);
                this.value = _value;
            }
        },
        __onChanged:function(value){
            var thiz = this,
                nativeWidget = this.nativeWidget;
            if(thiz.validator){
                var validated  = thiz.validator(value,nativeWidget);
                if (validated) {
                    this.userData.invalid=false;
                    nativeWidget.removeClass('text-danger');
                    nativeWidget.addClass('text-success');
                }else{
                    nativeWidget.removeClass('text-success');
                    nativeWidget.addClass('text-danger');
                    this.userData.invalid=true;
                }
            }
            if (thiz._lastValue !== null && thiz._lastValue === value) {
                return;
            }
            thiz._lastValue = value;
            thiz.widgetChanged(this.nativeWidget);
            thiz._emit('change',value);
        },
        setupNativeWidgetHandler: function () {

            var nativeWidget = this.nativeWidget;

            if (nativeWidget) {

                var thiz = this;

                this.addHandle("change",this.__on(this.nativeWidget,'change',null,function (value) {
                    thiz.__onChanged(nativeWidget.val());
                }));
                /*
                this.addHandle("change", this.nativeWidget.on("change", function (value) {
                    thiz.__onChanged(nativeWidget.val());
                }));
                */

                if(this.instant){
                    nativeWidget.on('keyup change', function() {
                        thiz.__onChanged(nativeWidget.val());
                    });
                }

                /*
                this.nativeWidget.change(function (e) {
                    console.log('edit changed'+e);
                });
                */
                this.addHandle("blur", this.nativeWidget.on("blur", function () {
                    thiz.setActive(false);
                }));
                this.addHandle("focus", this.nativeWidget.on("focus", function () {
                    thiz.setActive(true);
                }));
            }
        },
        set:function(what,value,updateOnly) {

            if(updateOnly===true){
                this.updateOnly = true;
            }
            if (what === 'value' && this.nativeWidget){
                this.nativeWidget.val(value);
            }


            return this.inherited(arguments);
        },
        get:function(what) {
            if (what === 'value' && this.nativeWidget){
                return this.nativeWidget.val();
            }
        },
        startup: function () {
            this.valueNode.innerHTML = "";
            var value = this.userData.value;
            var input = domConstruct.create('input',{
                "class":"form-control input-transparent",
                type:"text",
                value:value
            });
            this.nativeWidget = $(input);
            if(!this.title || this.title===''){
                utils.destroy(this.titleColumn);
            }
            this.valueNode.appendChild(input);
            this.setupNativeWidgetHandler();
            this.nativeWidget.trigger('change');
            this.onReady();
        }

    });
});
},
'dijit/registry':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
    "dojo/has",
	"xide/registry",
	"./main"	// dijit._scopeName
], function(array, win, has, registry,dijit){
	return registry;

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
                if( false ) {
                    console.error('already registered ' + widget.id + ' calss ' + widget.declaredClass);
                    this.remove(widget.id);
                    this.add(widget);
                }else{
                    throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
                }
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});


		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'xace/formatters':function(){
define([
    'xace/lib_jsbeautify'
    ], function (jsbeautify) {


    function formatCode(editor, mode){
        if (this.disabled === true)
            return;

        var ace = editor;
        var sel = ace.selection;
        var session = ace.session;
        var range = sel.getRange();

        /*
        session.diffAndReplace = function(range, text) {
            var doc = this.doc;
            var start = doc.positionToIndex(range.start);
            var oldText = doc.getTextRange(range);
            merge.patchAce(oldText, text, doc, {
                offset: start,
                method: "quick"
            });
            var dl = text.replace(/\r\n|\r|\n/g, doc.getNewLineCharacter()).length;
            return doc.indexToPosition(start + dl);
        };*/

        // Load up current settings data
        /*
         var options = {
         space_before_conditional: settings.getBool("user/format/jsbeautify/@space_before_conditional"),
         keep_array_indentation: settings.getBool("user/format/jsbeautify/@keeparrayindentation"),
         preserve_newlines: settings.getBool("user/format/jsbeautify/@preserveempty"),
         unescape_strings: settings.getBool("user/format/jsbeautify/@unescape_strings"),
         jslint_happy: settings.getBool("user/format/jsbeautify/@jslinthappy"),
         brace_style: settings.get("user/format/jsbeautify/@braces")
         };
         */

        var options = {
            space_before_conditional: true,
            keep_array_indentation: false,
            preserve_newlines: true,
            unescape_strings: true,
            jslint_happy: false,
            brace_style: "end-expand"
        };
        var useSoftTabs = true;
        if (useSoftTabs) {
            options.indent_char = " ";
            options.indent_size = session.getTabSize();
        } else {
            options.indent_char = "\t";
            options.indent_size = 1;
        }

        var line = session.getLine(range.start.row);
        var indent = line.match(/^\s*/)[0];
        var trim = false;

        if (range.start.column < indent.length)
            range.start.column = 0;
        else
            trim = true;

        var value = session.getTextRange(range);
        if(value.length==0){
            value = session.getValue();
        }
        var type = null;

        if (mode == "javascript" || mode == "json") {
            type = "js";
        } else if (mode == "css" || mode == "less"){
            type = "css";
        } else if (/^\s*<!?\w/.test(value)) {
            type = "html";
        } else if (mode == "xml") {
            type = "html";
        } else if (mode == "html") {
            if (/[^<]+?{[\s\-\w]+:[^}]+;/.test(value))
                type = "css";
            else if (/<\w+[ \/>]/.test(value))
                type = "html";
            else
                type = "js";
        } else if (mode == "handlebars") {
            options.indent_handlebars = true;
            type = "html";
        }


        try {
            value = jsbeautify[type + "_beautify"](value, options);
            if (trim)
                value = value.replace(/^/gm, indent).trim();
            if (range.end.column === 0)
                value += "\n" + indent;
        }
        catch (e) {
            return false;
        }

        //var end = session.diffAndReplace(range, value);

        //sel.setSelectionRange(Range.fromPoints(range.start, end));

        return value;
    }

    return {
        format:formatCode,
        modes : {
            "javascript" : "Javascript (JS Beautify)",
            "html"       : "HTML (JS Beautify)",
            "css"        : "CSS (JS Beautify)",
            "less"       : "Less (JS Beautify)",
            "xml"        : "XML (JS Beautify)",
            "json"       : "JSON (JS Beautify)",
            "handlebars" : "Handlebars (JS Beautify)"
        }
    }
});
},
'xide/factory/Widgets':function(){
define([
    "dojo/dom-construct",
    'xide/factory',
    'xide/types',
    'xide/utils',
    'dojo/Deferred',
    "dojo/promise/all",
    'dojo/when',
    'xide/widgets/WidgetBase',
    'xide/widgets/NativeWidget',
    'xlang/i18',
    'xide/widgets/EditBox',
    "xide/$",
    "xide/lodash"
], function (domConstruct, factory, types, utils, Deferred, all, when, WidgetBase, NativeWidget, i18, EditBox,$,_) {
    var _defaultWidgetModule = WidgetBase;

    /**
     *
     * @param checked
     * @param name
     * @param label
     * @param attachTo
     * @returns {string}
     */
    factory.radioButtonString = function (checked, name, label, attachTo) {
        var id = name + "_" + utils.createUUID();
        var element = "";
        element += '<div class="radio radio-info">';
        element += '<input attachTo="' + attachTo + '" name="' + name + '" id="' + id + '" type="radio" ' + (checked == true ? 'checked' : '') + '/>';
        element += '<label for="' + id + '">';
        element += label;
        element += '</label>';
        element += '</div>';
        return element;
    };
    /**
     * Renders a CIS inline
     * @param CIS
     * @param where
     * @param owner
     * @returns {*}
     */
    factory.renderCIS = function (CIS, where, owner) {

        var widgetsHead = factory.createWidgetsFromArray(CIS, owner, null, false);
        var result = [];
        var dfd = new Deferred();

        when(widgetsHead, function (widgets) {
            if (widgets) {
                for (var i = 0; i < widgets.length; i++) {
                    var widget = widgets[i];
                    widget.delegate = owner;
                    where.appendChild(widget.domNode);
                    if (where && where.lazy === true) {
                        widget._startOnShow = true;
                    } else {
                        widget.startup();
                    }
                    widget._on('valueChanged', function (evt) {
                        owner.onValueChanged(evt);
                    });

                    owner._emit('widget', {
                        widget: widget,
                        ci: widget.userData
                    })
                    result.push(widget);
                    widget.userData.view = owner;
                    widget.onAttached && widget.onAttached(where);
                    if (owner && owner.add && owner.add(widget, null, false)) {
                    } else {
                        console.error('view has no add', owner);
                        owner.add(widget, null, false);
                    }
                }
                dfd.resolve(result);
            }
        });
        return dfd;
    }

    /**
     *
     * @param type
     * @param options
     * @param dstField
     * @param typeMap
     * @returns {*}
     */
    factory.resolveWidget = function (type, options, dstField, typeMap) {
        var _debug = false;
        var _debugSuccess = false;
        _debug && console.error('resolve type : ' + type);

        //check in local type map, then global map
        var _customType = typeMap ? typeMap[type] : types.resolveType(type);
        if (_customType) {
            type = _customType;
        }

        options = options || {
                undef: false,
                reload: false
            };

        var _defaultModule = options.defaultModule;

        dstField = dstField || {}
        var mid = _.isString(type) ? utils.replaceAll('.', '/', type) : null;
        var _re = require,
            _errorHandle = null,
            deferred = new Deferred();

        if (_.isObject(type)) {
            dstField.result = type;
            deferred.resolve(type);

            return deferred;
        }

        if (options.reload) {
            try {
                require.undef(mid);
            } catch (e) {

            }
        }

        try {

            var _object = _re(mid);
            if (_object) {
                if (_.isObject(_object)) {

                    _debugSuccess && console.error('have module ' + mid, _object);
                    dstField.result = _.isEmpty(_object) ? _defaultModule : _object;
                    deferred.resolve(_object);
                    return deferred;
                }
            }
        } catch (e) {
            _debug && console.error('quick touch failed', e);
        }


        function handleError(error) {
            _debug && console.log(error.src, error.id);
            _debug && console.error('require error ' + mid, error);
            _errorHandle.remove();
            if (options.undef && _re.undef(mid)) {
            } else {
                _defaultModule && define(mid, _defaultModule);
            }
            dstField.result = _defaultModule;
            deferred.resolve(_defaultModule || type);
            return deferred;
        }

        _errorHandle = require.on("error", handleError);
        _debug && console.error('----require ----- ' + mid);
        //try loader
        _re([
            mid
        ], function (module) {
            if (module === 'not-a-module') {
                _errorHandle.remove();
                dstField.result = _defaultModule;
                deferred.resolve(_defaultModule || type);
            } else {
                _debugSuccess && console.error('re success', module);
                _errorHandle.remove();
                dstField.result = module;
                deferred.resolve(module)
            }
        });
        return deferred;
    }
    /**
     *
     * @param label
     * @param icon
     * @param btnClass
     * @param mixin
     * @param where
     * @returns {button}
     */
    factory.createSimpleButton = function (label, icon, btnClass, mixin, where) {
        var btn = domConstruct.create('button', utils.mixin({
            type: 'button',
            innerHTML: icon ? ('<i style="margin-right:4px" class="' + icon + '"></i>' + label) : '' + label,
            "class": "btn " + btnClass || ''
        }, mixin || {}), where);

        return btn;
    };
    /**
     *
     * @param json
     * @param onChangeHandler
     * @param storeItem
     * @param ci
     * @returns {*}
     */
    factory.createDijit = function (json, onChangeHandler, storeItem, ci) {
        if (json.type == null) {
            console.warn("type is missing for : " + json.title);
            return null;
        }
        var _ctrArgs = {
            delegate: onChangeHandler,
            intermediateChanges: ci.intermediateChanges != null ? ci.intermediateChanges : true,
            vertical: ci.vertical != null ? ci.vertical : false,
            userData: ci
        };
        utils.mixin(_ctrArgs, ci.widget);
        var type = json.type;
        if (json.nativeType) {
            json.props.intermediateChanges = true;
            type = json.nativeType;
        }

        var cls = json.result;
        if (!cls) {
            throw new Error("cannot find your widget type :" + type);
        }

        var myDijit = null;
        //ci provides additional widget properties, mix them into the constructor arguments
        utils.mixin(json.props, ci.widget);
        utils.mixin(_ctrArgs, {
            title: json.title,
            vertical: json.vertical
        });

        try {
            myDijit = new cls(utils.mixin(_ctrArgs, json.props), json.node);
        } catch (e) {
            console.error('constructing dijit widget failed : ' + e.message + ' for ' + type, json.props);
            return null;
        }
        var resultWidget = myDijit;
        var changeWidget = myDijit;
        if (resultWidget.nativeWidget) {
            changeWidget = null;
        }
        return resultWidget;
    };

    /**
     * private  : do not use
     * @param data
     * @param value
     * @return {*}
     */
    factory.__createWidgetData = function (data, value) {
        var res = {
            type: "",
            nativeType: null,
            props: {
                options: data.options || []
            },
            title: "NoTitle",
            node: null,
            autocomplete: true,
            vertical: data.vertical != null ? data.vertical : false
        };
        res.type = utils.getWidgetType(data.type);
        var name = utils.toString(data.name);
        var _title = utils.toString(data.title);

        var namespace = 'xide.widgets.';
        //special sanity check regarding DS-CIs
        if (utils.isValidString(_title) && _title.length > 0 && _title[0].length > 0) {
            name = _title;
        }
        // is enum
        if (data.type == types.ECIType.ENUMERATION) {
            if (!data.options) {
                var options = types.resolveEnumeration(data.enumType);
                if (options && options.length > 0) {
                    res.props.options = options;
                }
            }
            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = "xide.widgets.SelectWidget";
            res.nativeType = "xide.form.Select";
            res.autocomplete = true;
        }

        if (data.widget) {
            if (data.widget['class']) {
                res.nativeType = data.widget['class'];
            }
        }

        if (data.type == types.ECIType.STRING) {
            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = "xide.widgets.EditBox";
            res.props.title = name;
        }

        if (data.type == types.ECIType.JSON_DATA) {
            res.props.valueStr = data.value;
            res.type = "xide.widgets.JSONEditorWidget";
            res.props.newEntryTemplate =
            {
                isRoot: true,
                id: "root",
                schema: "{}"
            };
            res.props.initialTemplate = [];
            res.props.aceEditorOptions = {
                region: "center",
                value: '',
                style: "margin: 0; padding: 0; overflow: auto;position:relative;height:100%;width:100%;",
                theme: "twilight",
                mode: "json",
                readOnly: false,
                tabSize: 8,
                softTabs: true,
                wordWrap: false,
                printMargin: 120,
                showPrintMargin: true,
                highlightActiveLine: true,
                fontSize: '12px',
                showGutter: true
            }
        }

        if (data.type == types.ECIType.BOOL) {
            res.props['checked'] = utils.toBoolean(data.value);
            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = namespace + "NativeWidget";
            res.nativeType = "CheckBox";
        }

        if (data.type == types.ECIType.IMAGE) {
            res.props.value = data.value;
            res.type = namespace + "ImageWidget";
            if (name == "BACKGROUND") {
                name = "Background";
            }
        }

        if (data.type == types.ECIType.FILE) {
            res.props.value = data.value;
            res.type = namespace + "FileWidget";
        }

        if (data.type == types.ECIType.SCRIPT) {
            res.props.value = data.value;
            res.type = "ScriptWidget";
        }

        if (data.type == types.ECIType.RICHTEXT) {
            res.props.value = data.value;
            res.type = namespace + "RichTextWidget";
        }

        if (data.type == types.ECIType.ICON) {
            res.props.value = data.value;
            res.type = namespace + "IconPicker";
        }

        if (data.type == types.ECIType.REFERENCE) {
            res.props.disabled = !data.enabled;
            res.props.innerHTML = "Select";
        }

        if (res.type === null || res.type == '') {
            var _type = types.resolveWidgetMapping(data.type);
            if (_type) {
                res.type = _type;
            }
        }
        res.title = name;
        return res;
    };
    factory.createWidgetData = function (data, value) {

        var res = {
            type: "",
            nativeType: null,
            props: {
                options: data.options || []
            },
            title: "NoTitle",
            node: null,
            autocomplete: true,
            vertical: data.vertical != null ? data.vertical : false
        };
        res.type = utils.getWidgetType(data.type) || data.type;

        if (res.type) {
            var _type = types.resolveWidgetMapping(data.type);
            if (_type) {
                res.type = _type;
            }
        }

        var name = utils.toString(data.name);
        var _title = utils.toString(data.title);

        var namespace = 'xide.widgets.';

        //special sanity check regarding DS-CIs
        if (utils.isValidString(_title) && _title.length > 0 && _title[0].length > 0) {
            name = _title;
        }

        // is enum
        if (data.type == types.ECIType.ENUMERATION) {
            if (!data.options) {
                var options = types.resolveEnumeration(data.enumType);
                if (options && options.length > 0) {
                    res.props.options = options;
                }
            }

            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = "xide.form.Select";
            res.nativeType = "xide.form.Select";
            res.autocomplete = true;
        }

        if (data.widget) {
            if (data.widget['class']) {
                res.nativeType = data.widget['class'];
            }
        }

        if (data.type == types.ECIType.STRING) {

            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = namespace + "EditBox";
            res.props.title = name;
        }
        if (data.type == types.ECIType.JSON_DATA) {
            res.props.valueStr = data.value;
            res.type = "xide.widgets.JSONEditorWidget";
            res.props.newEntryTemplate =
            {
                isRoot: true,
                id: "root",
                schema: "{}"
            };

            res.props.initialTemplate = [];
            res.props.aceEditorOptions = {
                region: "center",
                value: '',
                style: "margin: 0; padding: 0; overflow: auto;position:relative;height:100%;width:100%;",
                theme: "twilight",
                mode: "json",
                readOnly: false,
                tabSize: 8,
                softTabs: true,
                wordWrap: false,
                printMargin: 120,
                showPrintMargin: true,
                highlightActiveLine: true,
                fontSize: '12px',
                showGutter: true
            }
        }

        if (data.type == types.ECIType.BOOL) {
            res.props['checked'] = utils.toBoolean(data.value);
            res.props.value = data.value;
            res.props.prevValue = data.value;
            res.type = NativeWidget;//"xide.widgets.NativeWidget";
            res.props.type = "CheckBox";
        }

        if (data.type == types.ECIType.IMAGE) {
            res.props.value = data.value;
            res.type = namespace + "ImageWidget";
            if (name == "BACKGROUND") {
                name = "Background";
            }
        }

        if (data.type == types.ECIType.FILE) {
            res.props.value = data.value;
            res.type = namespace + "FileWidget";
        }

        if (data.type == types.ECIType.FLAGS) {


            res.props.value = data.value;
            res.props.data = data.data;
            res.type = namespace + "FlagsWidget";
            res.props.title = name;
        }

        if (data.type == types.ECIType.SCRIPT) {
            res.props.value = data.value;
            res.type = namespace + "ScriptWidget";
        }

        if (data.type == types.ECIType.RICHTEXT) {
            res.props.value = data.value;
            res.type = namespace + "RichTextWidget";
        }

        if (data.type == types.ECIType.ICON) {
            res.props.value = data.value;
            res.type = namespace + "IconPicker";
        }

        if (data.type == types.ECIType.REFERENCE) {
            res.props.disabled = !data.enabled;
            res.props.innerHTML = "Select";
        }

        if (res.type === null || res.type == '') {
            var _type = types.resolveWidgetMapping(data.type);
            if (_type) {
                res.type = _type;
            }
        }
        res.title = name;
        return res;
    };

    /**
     *
     * @param cis
     * @returns {*}
     */
    factory.checkForCustomTypes = function (cis) {
        var addedCIS = [];
        var removedCIs = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            var ciType = utils.toInt(ci.type);
            if (ciType > types.ECIType.END) {//type is higher than core types, try to resolve it
                var resolved = types.resolveType(ciType);
                if (resolved) {
                    utils.mixin(addedCIS, resolved);
                    removedCIs.push(ci);
                }
            }
        }
        if (addedCIS.length > 0) {
            cis = cis.concat(addedCIS);
        }
        if (removedCIs) {
            for (var i in removedCIs) {
                cis.remove(removedCIs[i]);
            }
        }
        return cis;
    };
    /**
     *
     * @param data
     * @param changeHandler
     * @param storeItem
     * @param showInvisible
     * @param typeMap
     * @returns {*}
     */
    factory.createWidgetsFromArray = function (data, changeHandler, storeItem, showInvisible, typeMap, sort) {
        if (data == null){
            return null;
        }
        var res = [],
            dfd = new Deferred();
        data = factory.checkForCustomTypes(data);
        var _widgetMeta = [];
        var options = {
            defaultModule: _defaultWidgetModule
        }
        for (var i = 0; i < data.length; i++) {
            var inDef = data[i];
            if (!inDef) {
                continue;
            }
            if (showInvisible == false && utils.toBoolean(inDef.visible) == false) {
                continue;
            }
            var wData = factory.createWidgetData(inDef, inDef.value);
            if (!wData) {
                continue;
            }

            if (!wData.type) {
                continue;
            }

            wData.module = factory.resolveWidget(wData.type, options, wData, typeMap);
            wData.CI = inDef;
            _widgetMeta.push(wData);
        }
        var _promises = _.pluck(_widgetMeta, 'module');
        function complete(widgetData) {
            for (var i = 0; i < widgetData.length; i++) {
                var wData = widgetData[i];
                var CI = wData.CI;
                var widget = factory.createDijit(wData, changeHandler, storeItem, CI);
                if (!widget) {
                    console.error('have no widget', wData);
                    continue;
                }

                widget["userData"] = CI;
                widget["owner"] = changeHandler;
                widget["storeItem"] = storeItem;
                if (sort) {
                    widget["order"] = i;
                } else {
                    inDef.order = inDef.order || i;
                }
                inDef['_widget'] = widget;

                //tell everybody
                factory.publish(types.EVENTS.ON_CREATED_WIDGET, {
                    ci: inDef,
                    widget: widget,
                    storeItem: storeItem,
                    owner: changeHandler
                });


                if (widget.nativeWidget) {
                    widget.nativeWidget["userData"] = inDef;
                    widget.nativeWidget["storeItem"] = storeItem;
                }

                res.push(widget);
            }

            if (sort) {
                res.sort(function (a, b) {
                    var orderA = utils.toInt(a.userData.order);
                    var orderB = utils.toInt(b.userData.order);
                    return orderA - orderB;
                });
            }

            dfd.resolve(res);
        }
        all(_promises).then(function (args) {
            complete(_widgetMeta);
        });
        return dfd;
    };
    /**
     * Creates a button !
     * @param dstNode
     * @param iconClass
     * @param style
     * @param label
     * @param onClickCB
     * @param delegate
     * @return {HTMElement}
     */
    factory.createButton = function (dstNode, iconClass, buttonClass, style, label, onClickCB, delegate) {
        var button = factory.createSimpleButton(label, iconClass, buttonClass, {}, dstNode);
        if (onClickCB) {
            $(button).on('click', function (e) {
                onClickCB.apply(delegate, [e]);
            });
        }
        return button;
    };
    /**
     *
     * @param dstNode
     * @param style
     * @param labelText
     * @param value
     * @param validator
     * @param delegate
     * @param invalidMessage
     * @param missingMessage
     * @param toolTipPosition
     */
    factory.createValidationTextBox = function (dstNode, style, labelText, value, validator, delegate, invalidMessage, missingMessage, toolTipPosition) {
        var parent = utils.getDoc().createElement('DIV');
        var editBox = new EditBox({
            title: labelText,
            value: value,
            delegate: delegate,
            userData: {
                value: value
            }
        }, parent);
        dstNode.appendChild(editBox.domNode);
        editBox.startup();
        return editBox;
    };

    /**
     *
     * @param dstNode
     * @param style
     * @param labelText
     * @param value
     * @param checked
     * @param id
     * @returns {*}
     */
    factory.createCheckBox = function (dstNode, labelText, value, checked, id, title) {
        var element = '';
        title = title || labelText;
        //checkbox-circle
        element += '<div class="checkbox checkbox-success " title="' + title + '">';
        element += '<input id="' + id + '" type="checkbox" ' + (checked == true ? 'checked' : '') + '>';
        element += '<label for="' + id + '">';
        element += i18.localize(labelText) + '</label>';
        element += '</div>';
        var result = $(element);

        var checkBox = result.find('INPUT');
        $(dstNode).append(result);
        return checkBox;
    };
    factory.createRadioButton = function (dstNode, style, labelText, value, onClickCB, delegate, checked, toolTipText, className) {

    };
    return factory;
});
},
'xaction/types':function(){
define([
    'xide/types',
    'dojo/_base/lang'
],function(types,lang){

    lang.mixin(types.EVENTS,{
        ON_ACTION_CHANGE_CONTEXT: 'onChangeActionContext',
        ON_ACTION_CONTEXT_CHANGED: 'onActionContextChanged',
        REGISTER_ACTION: 'registerAction',
        SET_ITEM_ACTIONS: 'onSetItemsActions',
        ON_CLIPBOARD_COPY: 'onClipboardCopy',
        ON_CLIPBOARD_PASTE: 'onClipboardPaste',
        ON_CLIPBOARD_CUT: 'onClipboardCut',
        ON_RENDER_ACTIONS: 'onRenderActions',
        ON_DID_ACTION:'onDidAction',
        ON_AFTER_ACTION:'onAfterAction'
    });

    /**
     * Enumeration to define an Action command
     * @enum {string} module:xide/types/Action
     * @memberOf module:xide/types
     */
    types.ACTION =
    {
        LAYOUT: 'View/Layout',
        COLUMNS: 'View/Columns',
        SELECTION: 'File/Select',
        CLIPBOARD: 'Edit/Clipboard',
        UNDO: 'Edit/Undo',
        REDO: 'Edit/Redo',
        CLIPBOARD_COPY: 'Edit/Clipboard/Copy',
        CLIPBOARD_PASTE: 'Edit/Clipboard/Paste',
        CLIPBOARD_CUT: 'Edit/Clipboard/Cut',
        COPY: 'File/Copy',
        MOVE: 'File/Move',
        RENAME: 'File/Rename',
        DELETE: 'File/Delete',
        OPEN: 'File/Open',
        EDIT: 'File/Edit',
        SAVE: 'File/Save',
        SEARCH: 'File/Search',
        TOOLBAR: 'View/Show/Toolbar',
        STATUSBAR: 'View/Show/Statusbar',
        BREADCRUMB: 'View/Show/Breadcrumb',
        HEADER: 'View/Show/Header',
        DOWNLOAD: 'File/Download',
        DOWNLOAD_TO: 'File/downloadTo',
        INFO: 'File/Info',
        COMPRESS: 'File/Compress',
        RELOAD: 'File/Reload',
        UPLOAD: 'File/Upload',
        PREVIEW: 'File/Preview',
        OPEN_IN: 'File/Open In',
        INSERT_IMAGE: 'insertImage',
        COPY_PASTE: 'copypaste',
        DND: 'dnd',
        OPTIONS: 'options',
        NEW_FILE: 'File/New/New File',
        NEW_DIRECTORY: 'File/New/New Folder',
        GET_CONTENT: 'get',
        SET_CONTENT: 'set',
        FIND: 'File/Find',
        CUSTOM: 'custom',
        PERMA_LINK: 'permaLink',
        ADD_MOUNT: 'ADD_MOUNT',
        REMOVE_MOUNT: 'REMOVE_MOUNT',
        EDIT_MOUNT: 'EDIT_MOUNT',
        PERSPECTIVE: 'PERSPECTIVE',
        RUN: 'File/Run',
        GO_UP: 'Navigation/Go Up',
        STOP: 'File/Stop',
        CLOSE: 'View/Close',
        FULLSCREEN: 'View/Fullscreen',
        OPEN_IN_TAB: 'File/OpenInNewTab',
        SOURCE: 'Navigation/Source',
        RIBBON: 'View/Show/Ribbon',
        MAIN_MENU: 'View/Show/MainMenu',
        NAVIGATION: 'View/Show/Navigation',
        BASH_CONSOLE: 'File/Console/Bash',
        JS_CONSOLE: 'File/Console/JS',
        PHP_CONSOLE: 'File/Console/PHP',
        CONSOLE: 'File/Console/PHP',
        SIZE_STATS: 'View/Show/SizeStats',
        WELCOME: 'Window/Welcome',
        CONTEXT_MENU:'File/ContextMenu'
    };

    types.ACTION_TYPE = {
        MULTI_TOGGLE: 'multiToggle',
        SINGLE_TOGGLE: 'singleToggle'
    };

    types.ACTION_ICON =
    {
        CLIPBOARD_COPY: 'fa-copy',
        CLIPBOARD_PASTE: 'fa-paste',
        UPLOAD: 'fa-upload',
        RENAME: 'el-icon-edit',
        DELETE: 'text-danger fa-remove',
        RELOAD: 'fa-refresh',
        EDIT: 'fa-pencil',
        SAVE: 'fa-floppy-o',
        SEARCH: 'fa-search',
        NEW_DIRECTORY: 'fa-magic',
        NEW_FILE: 'fa-magic',
        RUN: 'text-success el-icon-play',
        COMPRESS: 'fa-file-archive-o',
        EXTRACT: 'fa-folder-open',
        DOWNLOAD: 'fa-download',
        GO_UP: 'fa-level-up',
        TOOLBAR: 'fa-bars',
        STATUSBAR: 'fa-terminal',
        PREVIEW: 'fa-eye',
        MAXIMIZE: 'fa-arrows-alt',
        UNDO: 'fa-undo',
        REDO: 'fa-repeat'

    };

    return types;
});
},
'wcDocker/tabframe':function(){
/** @module wcTabFrame */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class
     * A tab widget container, usable inside a panel to break up multiple elements into separate tabbed pages.
     */
    var Module = dcl(base, {
        declaredClass: 'wcTabFrame',

        LEFT_TAB_BUFFER: 15,

        /**
         * @memberOf module:wcTabFrame
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this layout.
         * @param {module:wcPanel} parent - The parent panel object for this widget.
         */
        constructor: function(container, parent) {
            /**
             * The outer container element of the widget.
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;

            this.$frame = null;
            this.$tabBar = null;
            this.$tabScroll = null;
            this.$center = null;
            this.$tabLeft = null;
            this.$tabRight = null;
            this.$close = null;

            this._tabOrientation = wcDocker.TAB.TOP;
            this._canScrollTabs = false;
            this._tabScrollPos = 0;
            this._curTab = -1;
            this._layoutList = [];
            this._moveable = true;

            this._boundEvents = [];

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Manually update the contents of this tab frame.
         * @function module:wcTabFrame#update
         */
        update: function () {
            var scrollTop = this.$center.scrollTop();
            this.__updateTabs();
            this.$center.scrollTop(scrollTop);
        },

        /**
         * Destroys the widget.
         * @function module:wcTabFrame#destroy
         */
        destroy: function () {
            this.__destroy();
        },

        /**
         * Gets the total number of tabs in this frame.
         * @version 3.0.0
         * @function module:wcTabFrame#tabCount
         * @returns {Number}
         */
        tabCount: function () {
            return this._layoutList.length;
        },

        /**
         * Gets, or Sets the tab orientation for the frame. This puts the tabbed widgets visually on any side of the tab frame.
         * @version 3.0.0
         * @function module:wcTabFrame#tabOrientation
         * @param {module:wcDocker.TAB} [orientation] - Assigns the orientation of the tab items displayed.
         * @returns {module:wcDocker.TAB} - The current orientation.
         */
        tabOrientation: function (orientation) {
            if (orientation !== undefined) {
                if (this._tabOrientation !== orientation && this.docker()._canOrientTabs) {
                    this._tabOrientation = orientation;

                    this.__updateTabs();
                    this.__updateTabs();
                }
            }

            return this._tabOrientation
        },

        /**
         * Adds a new tabbed page into the widget.
         * @function module:wcTabFrame#addTab
         * @param {String} name - The name of the new tab page.
         * @param {Number} [index] - If supplied and above -1, will insert the new tab page at the given tab index, otherwise the new tab is appended to the end.
         * @param {module:wcDocker.LAYOUT} [layout] - If supplied, will set the type of layout to use for this tab.
         * @returns {module:wcLayoutSimple|wcLayoutTable} - The layout of the newly created tab page.
         */
        addTab: function (name, index, layout) {
            var layoutClass = layout || 'wcLayoutTable';
            var newLayout = new (this.docker().__getClass(layoutClass))('.wcDockerTransition', this._parent);
            newLayout.name = name;
            newLayout._scrollable = {
                x: true,
                y: true
            };
            newLayout._scroll = {
                x: 0,
                y: 0
            };
            newLayout._closeable = false;
            newLayout._overflowVisible = false;

            if (typeof index === 'undefined' || index <= -1) {
                this._layoutList.push(newLayout);
            } else {
                this._layoutList.splice(index, 0, newLayout);
            }

            if (this._curTab === -1 && this._layoutList.length) {
                this._curTab = 0;
            }

            this.__updateTabs();

            return newLayout;
        },

        /**
         * Removes a tab page from the widget.
         * @function module:wcTabFrame#removeTab
         * @param {Number} index - The tab page index to remove.
         * @returns {Boolean} - Success or failure.
         */
        removeTab: function (index) {
            if (index > -1 && index < this._layoutList.length) {
                var name = this._layoutList[index].name;
                this._layoutList[index].__destroy();
                this._layoutList.splice(index, 1);

                if (this._curTab >= index) {
                    this._curTab--;

                    if (this._curTab < 0) {
                        this._curTab = 0;
                    }
                }

                this.__updateTabs();
                this._parent.__trigger(wcDocker.EVENT.CUSTOM_TAB_CLOSED, {obj: this, name: name, index: index});
                return true;
            }
            return false;
        },

        /**
         * Gets, or Sets the currently visible tab page.
         * @function module:wcTabFrame#tab
         * @param {Number} [index] - If supplied, sets the current tab page index.
         * @param {Boolean} [scrollTo] - If true, will auto scroll the tab bar until the selected tab is visible.
         * @returns {Number} - The index of the currently visible tab page.
         */
        tab: function (index, scrollTo) {
            if (typeof index !== 'undefined') {
                if (index > -1 && index < this._layoutList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    this._curTab = index;
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + index + '"]').addClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + index + '"]').removeClass('wcPanelTabContentHidden');
                    this.__updateTabs(scrollTo);

                    var name = this._layoutList[this._curTab].name;
                    this._parent.__trigger(wcDocker.EVENT.CUSTOM_TAB_CHANGED, {obj: this, name: name, index: index});
                }
            }

            return this._curTab;
        },

        /**
         * Retrieves the layout for a given tab page.
         * @function module:wcTabFrame#layout
         * @param {Number} index - The tab page index to retrieve.
         * @returns {module:wcLayoutSimple|wcLayoutTable|Boolean} - The layout of the found tab page, or false.
         */
        layout: function (index) {
            if (index > -1 && index < this._layoutList.length) {
                return this._layoutList[index];
            }
            return false;
        },

        /**
         * Moves a tab page from a given index to another index.
         * @function module:wcTabFrame#moveTab
         * @param {Number} fromIndex - The current tab page index to move from.
         * @param {Number} toIndex - The new tab page index to move to.
         * @returns {external:jQuery~Object} - The new element of the moved tab, or false if an error occurred.
         */
        moveTab: function (fromIndex, toIndex) {
            if (fromIndex >= 0 && fromIndex < this._layoutList.length &&
                toIndex >= 0 && toIndex < this._layoutList.length) {
                var panel = this._layoutList.splice(fromIndex, 1);
                this._layoutList.splice(toIndex, 0, panel[0]);

                // Preserve the currently active tab.
                if (this._curTab === fromIndex) {
                    this._curTab = toIndex;
                }

                this.__updateTabs();

                return this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + toIndex + '"]')[0];
            }
            return false;
        },

        /**
         * Gets, or Sets whether the tabs can be reordered by the user.
         * @function module:wcTabFrame#moveable
         * @param {Boolean} [moveable] - If supplied, assigns whether tab pages can be reordered.
         * @returns {Boolean} - Whether tab pages are currently moveable.
         */
        moveable: function (moveable) {
            if (typeof moveable !== 'undefined') {
                this._moveable = moveable;
            }
            return this._moveable;
        },

        /**
         * Gets, or Sets whether a tab can be closed (removed) by the user.
         * @function module:wcTabFrame#closeable
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [closeable] - If supplied, assigns whether the tab page can be closed.
         * @returns {Boolean} - Whether the tab page can be closed.
         */
        closeable: function (index, closeable) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (typeof closeable !== 'undefined') {
                    layout._closeable = closeable;
                }

                return layout._closeable;
            }
            return false;
        },

        /**
         * Gets, or Sets whether a tab page area is scrollable.
         * @function module:wcTabFrame#scrollable
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [x] - If supplied, assigns whether the tab page is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the tab page is scrollable in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scrollable status of the tab page.
         */
        scrollable: function (index, x, y) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                var changed = false;
                if (typeof x !== 'undefined') {
                    layout._scrollable.x = x;
                    changed = true;
                }
                if (typeof y !== 'undefined') {
                    layout._scrollable.y = y;
                    changed = true;
                }

                if (changed) {
                    this.__onTabChange();
                }

                return {
                    x: layout._scrollable.x,
                    y: layout._scrollable.y
                };
            }
            return false;
        },

        /**
         * Gets, or Sets whether overflow on a tab area is visible.<br>
         * Use this if a child element within this panel is intended to 'popup' and be visible outside of its parent area.
         * @function module:wcTabFrame#overflowVisible
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [visible] - If supplied, assigns whether overflow is visible.
         * @returns {Boolean} - The current overflow visiblity status of the tab page.
         */
        overflowVisible: function (index, visible) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (typeof overflow !== 'undefined') {
                    layout._overflowVisible = overflow;
                    this.__onTabChange();
                }
                return layout._overflowVisible;
            }
            return false;
        },

        /**
         * Gets, or Sets whether the tab frame should fit to its contents.
         * @version 3.0.0
         * @function module:wcTabFrame#fitContents
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [x] - If supplied, assigns whether the tab page is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the tab page is scrollable in the vertical direction.
         * @returns {module:wcDocker~FitContents} - The current scrollable status of the tab page.
         */
        fitContents: function (index, x, y) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.hasOwnProperty('_fitContents')) {
                    layout._fitContents = {
                        x: false,
                        y: false
                    };
                }

                var changed = false;
                if (typeof x !== 'undefined') {
                    layout._fitContents.x = x;
                    changed = true;
                }
                if (typeof y !== 'undefined') {
                    layout._fitContents.y = y;
                    changed = true;
                }

                if (changed) {
                    this.__onTabChange();
                }

                return {
                    x: layout._fitContents.x,
                    y: layout._fitContents.y
                };
            }
            return false;
        },

        /**
         * Sets the icon for a tab item.
         * @function module:wcTabFrame#icon
         * @param {Number} index - The index of the tab item.
         * @param {String} icon - A CSS class name that represents the icon.
         */
        icon: function (index, icon) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.$icon) {
                    layout.$icon = $('<div>');
                }

                layout.$icon.removeClass();
                layout.$icon.addClass('wcTabIcon ' + icon);
            }
        },

        /**
         * Sets the icon for a tab item using the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
         * @function module:wcTabFrame#faicon
         * @param {Number} index - The index of the tab item.
         * @param {String} icon - A [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} icon name (without the 'fa fa-' prefix).
         */
        faicon: function (index, icon) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.$icon) {
                    layout.$icon = $('<div>');
                }

                layout.$icon.removeClass();
                layout.$icon.addClass('fa fa-fw fa-' + icon);
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$frame = $('<div class="wcCustomTab wcWide wcTall">');
            this.$tabBar = $('<div class="wcFrameTitleBar wcCustomTabTitle wcWide">');
            this.$tabScroll = $('<div class="wcTabScroller">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><span class="fa fa-close"></span>X</div>');

            //this.$maximize = $('<div class="wcFrameButton" title="Close the currently active panel tab"><span class="fa fa-expand"></span>X</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');


            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);

            //this.$buttonBar.append(this.$maximize);

            this.$frame.append(this.$center);
            this.$frame.append(this.$tabBar);

            this.__container(this.$container);

            this._boundEvents.push({event: wcDocker.EVENT.UPDATED, handler: this.update.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.CLOSED, handler: this.destroy.bind(this)});

            for (var i = 0; i < this._boundEvents.length; ++i) {
                this._parent.on(this._boundEvents[i].event, this._boundEvents[i].handler);
            }

            var docker = this.docker();
            if (docker) {
                docker._tabList.push(this);
            }
        },

        __updateTabs: function (scrollTo) {

            //this.$tabScroll.empty();

            var getOffset = function ($item) {
                switch (this._tabOrientation) {
                    case wcDocker.TAB.BOTTOM:
                        return $item.offset().left;
                    case wcDocker.TAB.TOP:
                        return $item.offset().left;
                    case wcDocker.TAB.LEFT:
                        return $item.offset().top;
                    case wcDocker.TAB.RIGHT:
                        return $item.offset().top;
                }
            }.bind(this);

            var tabPositions = [];
            var totalWidth = 0;
            var parentLeft = getOffset(this.$tabScroll);
            var self = this;

            this.$center.children('.wcPanelTabContent').each(function () {
                $(this).addClass('wcPanelTabContentHidden wcPanelTabUnused');
            });

            for (var i = 0; i < this._layoutList.length; ++i) {
                var $tab = $('<div id="' + i + '" class="wcPanelTab"><div>' + this._layoutList[i].name + '</div></div>');
                if (this._moveable) {
                    $tab.addClass('wcCustomTabMoveable');
                }
                this.$tabScroll.append($tab);
                if (this._layoutList[i].$icon) {
                    $tab.find('div').prepend(this._layoutList[i].$icon);
                }

                var $tabContent = this.$center.children('.wcPanelTabContent[id="' + i + '"]');
                if (!$tabContent.length) {
                    $tabContent = $('<div class="wcPanelTabContent wcPanelTabContentHidden" id="' + i + '">');
                    this.$center.append($tabContent);
                }

                this._layoutList[i].__container($tabContent);
                this._layoutList[i]._parent = this;

                var isVisible = this._curTab === i;

                $tabContent.removeClass('wcPanelTabUnused');

                if (isVisible) {
                    $tab.addClass('wcPanelTabActive');
                    $tabContent.removeClass('wcPanelTabContentHidden');
                }

                totalWidth = getOffset($tab) - parentLeft;
                tabPositions.push(totalWidth);

                totalWidth += $tab.outerWidth();
            }

            var tabWidth = 0;
            var titleSize = this.$tabBar.height();
            switch (this._tabOrientation) {
                case wcDocker.TAB.TOP:
                    this.$tabBar.addClass('wcTabTop').removeClass('wcTabLeft wcTabRight wcTabBottom');
                    this.$center.css('top', titleSize).css('left', 0).css('right', 0).css('bottom', 0);
                    tabWidth = this.$center.width();
                    break;
                case wcDocker.TAB.BOTTOM:
                    this.$tabBar.addClass('wcTabBottom').removeClass('wcTabTop wcTabLeft wcTabRight');
                    this.$center.css('top', 0).css('left', 0).css('right', 0).css('bottom', titleSize);
                    tabWidth = this.$center.width();
                    break;

                case wcDocker.TAB.LEFT:
                    this.$tabBar.addClass('wcTabLeft').removeClass('wcTabTop wcTabRight wcTabBottom');
                    this.$center.css('top', 0).css('left', titleSize).css('right', 0).css('bottom', 0);
                    tabWidth = this.$center.height();
                    break;

                case wcDocker.TAB.RIGHT:
                    this.$tabBar.addClass('wcTabRight').removeClass('wcTabTop wcTabLeft wcTabBottom');
                    this.$center.css('top', 0).css('left', 0).css('right', titleSize).css('bottom', 0);
                    tabWidth = this.$center.height();
                    break;
            }

            // Now remove all unused panel tabs.
            this.$center.children('.wcPanelTabUnused').each(function () {
                $(this).remove();
            });

            var buttonSize = this.__onTabChange();

            if (scrollTo) {
                for (var i = 0; i < tabPositions.length; ++i) {
                    if (i === this._curTab) {
                        var left = tabPositions[i];
                        var right = totalWidth;
                        if (i + 1 < tabPositions.length) {
                            right = tabPositions[i + 1];
                        }

                        var scrollPos = -parseInt(this.$tabScroll.css('left'));
                        var titleWidth = tabWidth - buttonSize;

                        // If the tab is behind the current scroll position.
                        if (left < scrollPos) {
                            this._tabScrollPos = left - this.LEFT_TAB_BUFFER;
                            if (this._tabScrollPos < 0) {
                                this._tabScrollPos = 0;
                            }
                        }
                        // If the tab is beyond the current scroll position.
                        else if (right - scrollPos > titleWidth) {
                            this._tabScrollPos = right - titleWidth + this.LEFT_TAB_BUFFER;
                        }
                        break;
                    }
                }
            }

            this._canScrollTabs = false;
            if (totalWidth > tabWidth - buttonSize) {
                this._canScrollTabs = true;
                this.$buttonBar.append(this.$tabRight);
                this.$buttonBar.append(this.$tabLeft);
                buttonSize += this.$tabRight.outerWidth();
                buttonSize += this.$tabLeft.outerWidth();

                var scrollLimit = totalWidth - (tabWidth - buttonSize) / 2;
                // If we are beyond our scroll limit, clamp it.
                if (this._tabScrollPos > scrollLimit) {
                    var children = this.$tabScroll.children();
                    for (var i = 0; i < children.length; ++i) {
                        var $tab = $(children[i]);

                        totalWidth = getOffset($tab) - parentLeft;
                        if (totalWidth + $tab.outerWidth() > scrollLimit) {
                            this._tabScrollPos = totalWidth - this.LEFT_TAB_BUFFER;
                            if (this._tabScrollPos < 0) {
                                this._tabScrollPos = 0;
                            }
                            break;
                        }
                    }
                }
            } else {
                this._tabScrollPos = 0;
                this.$tabLeft.remove();
                this.$tabRight.remove();
            }

            this.$tabScroll.stop().animate({left: -this._tabScrollPos + 'px'}, 'fast');
        },

        __onTabChange: function () {
            var buttonSize = 0;
            var layout = this.layout(this._curTab);
            if (layout) {
                this.$center.toggleClass('wcScrollableX', layout._scrollable.x);
                this.$center.toggleClass('wcScrollableY', layout._scrollable.y);
                this.$center.toggleClass('wcOverflowVisible', layout._overflowVisible);

                this.$tabLeft.remove();
                this.$tabRight.remove();

                if (layout._closeable) {
                    this.$close.show();
                    buttonSize += this.$close.outerWidth();
                } else {
                    this.$close.hide();
                }

                if (this._canScrollTabs) {
                    this.$tabBar.append(this.$tabRight);
                    this.$tabBar.append(this.$tabLeft);

                    buttonSize += this.$tabRight.outerWidth() + this.$tabLeft.outerWidth();
                }

                var fit = this.fitContents(this._curTab);
                if (fit.x) {
                    var w = layout.scene().outerWidth();
                    if (this._tabOrientation === wcDocker.TAB.LEFT || this._tabOrientation === wcDocker.TAB.RIGHT) {
                        w += this.$tabScroll.height();
                    }
                    this.$container.css('width', w);
                } else {
                    this.$container.css('width', '');
                }

                if (fit.y) {
                    var h = layout.scene().outerHeight();
                    if (this._tabOrientation === wcDocker.TAB.TOP || this._tabOrientation === wcDocker.TAB.BOTTOM) {
                        h += this.$tabScroll.height();
                    }
                    this.$container.css('height', h);
                } else {
                    this.$container.css('height', '');
                }

                switch (this._tabOrientation) {
                    case wcDocker.TAB.RIGHT:
                    case wcDocker.TAB.LEFT:
                        this.$tabBar.css('width', this.$center.height() || '100%');
                        break;
                    case wcDocker.TAB.TOP:
                    case wcDocker.TAB.BOTTOM:
                        this.$tabBar.css('width', this.$center.width() || '100%');
                    default:
                        break;
                }

                this.$center.scrollLeft(layout._scroll.x);
                this.$center.scrollTop(layout._scroll.y);
            }

            this.$buttonBar.css('min-width', buttonSize).css('width', buttonSize);
            return buttonSize;
        },

        // Handles scroll notifications.
        __scrolled: function () {
            var layout = this.layout(this._curTab);
            layout._scroll.x = this.$center.scrollLeft();
            layout._scroll.y = this.$center.scrollTop();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            var docker = this.docker();
            if (docker) {
                var index = docker._tabList.indexOf(this);
                if (index > -1) {
                    docker._tabList.splice(index, 1);
                }
            }

            // Remove all registered events.
            while (this._boundEvents.length) {
                this._parent.off(this._boundEvents[0].event, this._boundEvents[0].handler);
                this._boundEvents.shift();
            }

            this._curTab = -1;
            for (var i = 0; i < this._layoutList.length; ++i) {
                this._layoutList[i].__destroy();
            }

            while (this._layoutList.length) this._layoutList.pop();
            this.__container(null);
            this._parent = null;
        }
    });

    // window['wcTabFrame'] = Module;

    return Module;
});

},
'dojo/io-query':function(){
define(["dojo/_base/lang"], function(lang){

// module:
//		dojo/io-query

var backstop = {};

return {
// summary:
//		This module defines query string processing functions.

	objectToQuery: function objectToQuery(/*Object*/ map){
		// summary:
        //		takes a name/value mapping object and returns a string representing
        //		a URL-encoded version of that object.
        // example:
        //		this object:
        //
        //	|	{
        //	|		blah: "blah",
        //	|		multi: [
        //	|			"thud",
        //	|			"thonk"
        //	|		]
        //	|	};
        //
        //		yields the following query string:
        //
        //	|	"blah=blah&multi=thud&multi=thonk"

        // FIXME: need to implement encodeAscii!!
        var enc = encodeURIComponent, pairs = [];
        for(var name in map){
            var value = map[name];
            if(value != backstop[name]){
                var assign = enc(name) + "=";
                if(lang.isArray(value)){
                    for(var i = 0, l = value.length; i < l; ++i){
                        pairs.push(assign + enc(value[i]));
                    }
                }else{
                    pairs.push(assign + enc(value));
                }
            }
        }
        return pairs.join("&"); // String
    },

	queryToObject: function queryToObject(/*String*/ str){
        // summary:
        //		Create an object representing a de-serialized query section of a
        //		URL. Query keys with multiple values are returned in an array.
        //
        // example:
        //		This string:
        //
        //	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
        //
        //		results in this object structure:
        //
        //	|		{
        //	|			foo: [ "bar", "baz" ],
        //	|			thinger: " spaces =blah",
        //	|			zonk: "blarg"
        //	|		}
        //
        //		Note that spaces and other urlencoded entities are correctly
        //		handled.

        // FIXME: should we grab the URL string if we're not passed one?
        var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
        for(var i = 0, l = qp.length, item; i < l; ++i){
            item = qp[i];
            if(item.length){
                var s = item.indexOf("=");
                if(s < 0){
                    name = dec(item);
                    val = "";
                }else{
                    name = dec(item.slice(0, s));
                    val  = dec(item.slice(s + 1));
                }
                if(typeof ret[name] == "string"){ // inline'd type check
                    ret[name] = [ret[name]];
                }

                if(lang.isArray(ret[name])){
                    ret[name].push(val);
                }else{
                    ret[name] = val;
                }
            }
        }
        return ret; // Object
    }
};
});
},
'xgrid/GridLite':function(){
/** @module xgrid/Grid **/
define([
    'dojo/_base/declare',
    'xide/types',
    './Base'
],function (declare,types,Base) {
    /**
     *
     * Please read {@link module:xgrid/types}
     *
     * @class module:xgrid/Grid
     * @augments module:xgrid/Base
     */
    var grid = declare('xgrid/Grid',Base,{});

    grid.createGridClass = Base.createGridClass;

    //track defaults on module
    grid.classFactory = Base.classFactory;
    grid.DEFAULT_GRID_FEATURES = types.DEFAULT_GRID_FEATURES;
    grid.DEFAULT_GRID_BASES = Base.DEFAULT_GRID_BASES;
    grid.DEFAULT_GRID_OPTIONS = types.DEFAULT_GRID_OPTIONS;
    grid.DEFAULT_GRID_OPTION_KEYS = types.DEFAULT_GRID_OPTION_KEYS;

    return grid;
});
},
'xbox/manager/Context':function(){
define([
    "dcl/dcl",
    'xfile/manager/Context',
    'xbox/manager/Application',
    'xide/manager/ResourceManager'
], function (dcl,Context,Application,ResourceManager) {

    return dcl(Context,{
        declaredClass:"xfile.manager.Context",
        constructManagers:function() {
            this.application = this.createManager(Application,null);
            this.resourceManager = this.createManager(ResourceManager,null);
        },
        initManagers:function() {
            this.resourceManager.init();
        }
    });
});
},
'xgrid/ContextMenu':function(){
/** module:xgrid/ContextMenu **/
define([
    'dojo/_base/declare',
    'xide/utils',
    'xide/widgets/ContextMenu',
    'xide/types'
], function (declare, utils, ContextMenu, types) {
    return declare("xgrid.ContextMenu", null, {
        contextMenu: null,
        getContextMenu: function () {
            return this.contextMenu;
        },
        _createContextMenu: function () {
            var _ctorArgs = this.contextMenuArgs || {};
            var mixin = {
                owner: this,
                delegate: this,
                _actionFilter: {
                    quick: true
                }
            };

            utils.mixin(_ctorArgs, mixin);
            var node = this.contentNode;
            var contextMenu = new ContextMenu(_ctorArgs, node);
            contextMenu.openTarget = node;
            contextMenu.init({preventDoubleContext: false});
            contextMenu._registerActionEmitter(this);
            this.contextMenu = contextMenu;
            if (this.add) {
                this.add(contextMenu);
            } else {
                console.error('have no add!');
            }
        },
        startup: function () {
            if (this._started) {
                return;
            }
            this.inherited(arguments);
            if (this.hasPermission(types.ACTION.CONTEXT_MENU)) {
                this._createContextMenu();
            }
        }
    });
});
},
'xide/Template':function(){
/** @module xideve/Template **/
define([
    "dojo/_base/declare",       //@TODO: move to DCL
    "xide/model/Component",     //make it a plugin since some data points to additional resources to be loaded first
    "xide/model/Bean",          //make this a bean so the user can edit this
    "xide/mixins/VariableMixin" //some settings may require resolved against user IDE variables
], function (declare, Component, Bean, VariableMixin) {


    var _REG_EX_REQUIRE =
        // a regular expression to identify a require
        /\brequire\s*\(\s*\[\s*([\s\S]*?)\s*\]\s*\)/,
        // a regular expression to identify a module id
        _REG_EX_MID = /[\w.\/]+/g;

    /**
     * Simple entity to collect data for a 'Document' template. This must be serializable and incorporate the
     * xide-component (plugin) interface.

     * @class module:xideve/Template
     * @extends module:xide/model/Components
     * @implements module:xide/model/Bean
     **/
    var Template = declare('xide/Template', [Component, Bean, VariableMixin], {
        /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Data & properties
        //
        /**
         * IDE Context
         * @type {xide/manager/Context}
         */
        ctx:null,
        /**
         *  A class sting (AMD/Require-JS compatible)
         * @type {string[]}
         */
        contextClass: null,
        /**
         * The require-js baseUrl, that gets filled by the component loader, client or server side.
         * @type {string[]}
         * @default null
         */
        baseUrl: null,
        /**
         * Minimum requires
         * @type {string[]}
         */
        requires: [],
        /**
         * When the document is being loaded (not parsed yet), then this array of require-js modules
         * will be loaded before onLoad gets fired. This can be used to add debugging or user/project
         * space modules
         * @default empty
         */
        postRequires: [],
        /**
         * If the document type has any theme tech, this is the default theme to be loaded
         * @type {string}
         */
        defaultTheme: null,
        /**
         * Set of require-js mappings when the document is being switched to mobile output
         * @type {object}
         */
        mobileMap: {},
        /**
         * Capabilities describes what the tech provides, that might be dynamic and is
         * essentially a flag/enum to object/properties map
         * @type {xideve/types/Capabilities}
         */
        capabilities: {},
        /**
         * An error handler
         * @TODO: error mixin?
         */
        errorHandler: null,

        /**
         * A debug handler
         * @TODO: login mixin?
         */
        debugHandler: null,
        /**
         * A delegate to resolve resources in IDE mode.
         * @type {xide/manager/ResourceManager}
         */
        resourceDelegate: null,
        /**
         * A delegate to resolve resources variables, run-time and IDE mode.
         * @type {xide/mixin/VariableMixin}
         */
        variableDelegate: null,
        /**
         * When user opens a simple HTML fragment file, inject the document with this config and make it
         * into a full application
         */
        requireMinimumConfig: {},

        /**
         * Shared objects from IDE to app. This is an array of strings to instances which goes into
         * the document's 'global'
         * @type {Object[]}
         */
        sharedObjects: [],
        /**
         * Server side mixins into the prototypes.
         * @type {Object[]}
         */
        mixins: [],
        /**
         * New file template
         * @type {string} A require-text path to a text resource, containing the template for a new file
         * @default empty
         */
        newFileTemplate: '',
        /**
         * Body styling
         */
        bodyStyle:'',
        /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Bean protocol implementation
        //
        beanType: 'Document Template',
        /**
         * Stub
         * @returns {Array}
         */
        getDependencies:function(){
            return [];
        }
    });
    // @TODO: statics ?
    return Template;
});


},
'xbox/Views':function(){
define([
    "dgrid/OnDemandGrid",
    "dgrid/Selection",
    "dgrid/extensions/ColumnResizer"
], function(){});


},
'wcDocker/iframe':function(){
/** @module wcIFrame */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {
    /**
     * @class module:wcIFrame
     * The wcIFrame widget makes it easier to include an iFrame element into your panel.
     * Because an iFrame's contents is cleared whenever it is moved in the DOM heirarchy
     * (and changing a panels docking position causes DOM movement), special care must
     * be taken when using them.<br><br>
     *
     * This will create an iFrame element and place it in a static (non-changing) DOM
     * location. It will then sync its size and position to match the container area of
     * this wcIFrame widget. It works rather well, but has its limitations. Since the
     * iFrame is essentially on top of the window, it can not be only partially hidden.
     * If the wcIFrame container is partially hidden outside the bounds of the panel,
     * the iFrame will not be hidden.
     * {@tutorial 3.0-widgets}
     */
    var Module = dcl(base, {
        declaredClass: 'wcIFrame',
        /**
         * @memberOf module:wcIFrame
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this layout.
         * @param {module:wcPanel} parent - The iframes's parent panel.
         */
        constructor: function (container, panel) {
            this._panel = panel;
            this._layout = panel.layout();

            this.$container = $(container);
            this.$frame = null;
            this.$focus = null;
            /**
             * The iFrame element.
             * @member {external:jQuery~Object}
             */
            this.$iFrame = null;

            this._window = null;
            this._isDocking = false;
            this._isHovering = false;

            this._boundEvents = [];

            this._onLoadFuncs = [];
            this._onClosedFuncs = [];
            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Opens a given URL address into the iFrame.
         * @function module:wcIFrame#openURL
         * @param {String} url - The full, or relative, path to the page.
         */
        openURL: function (url) {
            this.__clearFrame();

            //this.$iFrame = $('<iframe>iFrames not supported on your device!</iframe>');

            var thiz = this;

            var bindStr = '?';
            if (url.indexOf('?') != -1) {
                bindStr = '&';
            }
            url += bindStr + 'xdmTarget=' + encodeURIComponent('' + window.location.href);
            this.scriptFrame = new easyXDM.Socket({
                remote: url,
                container: this.$container[0],
                props: {
                    style: {
                        width: '100%',
                        height: '100%'
                    }
                },
                onload: function () {
                    console.error('on load');
                },
                onReady: function () {
                },
                onMessage: function (message, origin) {
                    thiz.onMessage(message);
                }
            });
            this.$iFrame = $(this.$container[0].firstChild);
            this.$frame.prepend(this.$iFrame);
            this.__onMoved();
            this._window = this.$iFrame[0].contentWindow || this.$iFrame[0];
            this.__updateFrame();
            this.$iFrame[0].focus();
            this.$iFrame.hover(this.__onHoverEnter.bind(this), this.__onHoverExit.bind(this));

            var self = this;
            this.$iFrame.load(function () {
                for (var i = 0; i < self._onLoadFuncs.length; ++i) {
                    self._onLoadFuncs[i]();
                }
                self._onLoadFuncs = [];
                self.$iFrame.contents().click(function (e) {
                    $('body').trigger('click', e);
                });
                self.$iFrame.contents().keydown(function (e) {
                    $(document).trigger('keydown', e);
                })
                self.$iFrame.contents().keyup(function (e) {
                    $(document).trigger('keyup', e);
                })
            });
        },

        /**
         * Populates the iFrame with the given HTML source code using the document to write data.
         * @function module:wcIFrame#openHTML
         * @param {String} html - The HTML source code.
         */
        openHTML: function (html) {
            this.__clearFrame();
            this.$iFrame = $('<iframe>iFrames not supported on your device!</iframe>');
            this.$frame.prepend(this.$iFrame);
            this.__onMoved();
            this._window = this.$iFrame[0].contentWindow || this.$iFrame[0];
            this.__updateFrame();

            // Write the frame source.
            this._window.document.open();
            this._window.document.write(html);
            this._window.document.close();
            this.$iFrame[0].focus();
            this.$iFrame.hover(this.__onHoverEnter.bind(this), this.__onHoverExit.bind(this));
            var self = this;
            this.$iFrame.load(function () {
                for (var i = 0; i < self._onLoadFuncs.length; ++i) {
                    self._onLoadFuncs[i]();
                }
                self._onLoadFuncs = [];
            });
        },

        /**
         * Populates the iFrame with the given HTML source code using the srcdoc attribute.
         * @version 3.0.0
         * @function module:wcIFrame#openSRC
         * @param {String} html - The HTML source code.
         */
        openSRC: function (html) {
            this.__clearFrame();

            this.$iFrame = $('<iframe>iFrames not supported on your device!</iframe>');
            this.$frame.prepend(this.$iFrame);

            this.__onMoved();
            this._window = this.$iFrame[0].contentWindow || this.$iFrame[0];
            this.__updateFrame();

            // Write the frame source.
            this.$iFrame[0].srcdoc = html;
            this.$iFrame[0].focus();
            this.$iFrame.hover(this.__onHoverEnter.bind(this), this.__onHoverExit.bind(this));

            var self = this;
            this.$iFrame.load(function () {
                for (var i = 0; i < self._onLoadFuncs.length; ++i) {
                    self._onLoadFuncs[i]();
                }
                self._onLoadFuncs = [];
            });
        },

        /**
         * Registers an event handler when the contents of this iFrame has loaded.
         * @function module:wcIFrame#onLoaded
         * @param {Function} onLoadedFunc - A function to call when the iFrame has loaded.
         */
        onLoaded: function (onLoadedFunc) {
            this._onLoadFuncs.push(onLoadedFunc);
        },

        /**
         * Registers an event handler when the iFrame has been closed.
         * @function module:wcIFrame#onClosed
         * @param {Function} onClosedFunc - A function to call when the iFrame has closed.
         */
        onClosed: function (onClosedFunc) {
            this._onClosedFuncs.push(onClosedFunc);
        },

        /**
         * Allows the iFrame to be visible when the panel is visible.
         * @function module:wcIFrame#show
         */
        show: function () {
            if (this.$frame) {
                this.$frame.removeClass('wcIFrameHidden');
            }
        },

        /**
         * Forces the iFrame to be hidden, regardless of whether the panel is visible.
         * @function module:wcIFrame#hide
         */
        hide: function () {
            if (this.$frame) {
                this.$frame.addClass('wcIFrameHidden');
            }
        },

        /**
         * Retrieves the window object from the iFrame element.
         * @function module:wcIFrame#window
         * @returns {Object} - The window object.
         */
        window: function () {
            return this._window;
        },

        /**
         * Destroys the iFrame element and clears all references.<br>
         * <b>Note:</b> This is automatically called when the owner panel is destroyed.
         * @function module:wcIFrame#destroy
         */
        destroy: function () {
            // Remove all registered events.
            while (this._boundEvents.length) {
                this._panel.off(this._boundEvents[0].event, this._boundEvents[0].handler);
                this._boundEvents.shift();
            }

            this.__clearFrame();
            this._panel = null;
            this._layout = null;
            this.$container = null;
            this.$frame.remove();
            this.$frame = null;
            this.$focus = null;
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Private Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        __init: function () {
            this.$frame = $('<div class="wcIFrame">');
            this.$focus = $('<div class="wcIFrameFocus">');
            this._panel.docker().$container.append(this.$frame);
            this.$frame.append(this.$focus);

            this._boundEvents.push({
                event: wcDocker.EVENT.VISIBILITY_CHANGED,
                handler: this.__onVisibilityChanged.bind(this)
            });
            this._boundEvents.push({event: wcDocker.EVENT.BEGIN_DOCK, handler: this.__onBeginDock.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.END_DOCK, handler: this.__onEndDock.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.MOVE_STARTED, handler: this.__onMoveStarted.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.RESIZE_STARTED, handler: this.__onMoveStarted.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.MOVE_ENDED, handler: this.__onMoveFinished.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.RESIZE_ENDED, handler: this.__onMoveFinished.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.MOVED, handler: this.__onMoved.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.RESIZED, handler: this.__onMoved.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.ATTACHED, handler: this.__onAttached.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.DETACHED, handler: this.__updateFrame.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.GAIN_FOCUS, handler: this.__updateFrame.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.LOST_FOCUS, handler: this.__updateFrame.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.PERSISTENT_OPENED, handler: this.__updateFrame.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.PERSISTENT_CLOSED, handler: this.__updateFrame.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.CLOSED, handler: this.__onClosed.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.ORDER_CHANGED, handler: this.__onOrderChanged.bind(this)});

            for (var i = 0; i < this._boundEvents.length; ++i) {
                this._panel.on(this._boundEvents[i].event, this._boundEvents[i].handler);
            }

            $(window).blur(this.__onBlur.bind(this));
        },

        __clearFrame: function () {
            if (this.$iFrame) {
                for (var i = 0; i < this._onClosedFuncs.length; ++i) {
                    this._onClosedFuncs[i]();
                }
                this._onClosedFuncs = [];
                this.$iFrame[0].srcdoc = '';
                this.$iFrame.remove();
                this.$iFrame = null;
                this._window = null;
            }
        },

        __updateFrame: function () {
            if (this.$frame && this._panel) {
                var floating = this._panel.isFloating();
                this.$frame.toggleClass('wcIFrameFloating', floating);
                if (floating) {
                    this.$frame.toggleClass('wcIFrameFloatingFocus', focus);
                } else {
                    this.$frame.removeClass('wcIFrameFloatingFocus');
                }
                this.$frame.toggleClass('wcIFramePanelHidden', !this._panel.isVisible());
                if (this._panel && this._panel._parent && this._panel._parent.instanceOf('wcFrame')) {
                    this.$frame.toggleClass('wcDrawer', this._panel._parent.isCollapser());
                }
            }
        },

        __focusFix: function () {
            // Fixes a bug where the frame stops responding to mouse wheel after
            // it has been assigned and unassigned pointer-events: none in css.
            this.$frame.css('left', parseInt(this.$frame.css('left')) + 1);
            this.$frame.css('left', parseInt(this.$frame.css('left')) - 1);
        },

        __onHoverEnter: function () {
            this._isHovering = true;
        },

        __onHoverExit: function () {
            this._isHovering = false;
        },

        __onBlur: function () {
            if (this._isHovering) {
                this.__onFocus();
            }
        },

        __onFocus: function () {
            if (this._panel) {
                this.docker(this._panel).__focus(this._panel._parent);
            }
        },

        __onVisibilityChanged: function () {
            this.__updateFrame();
            if (this._panel.isVisible()) {
                this.__onMoved();
            }
        },

        __onBeginDock: function () {
            if (this.$frame) {
                this._isDocking = true;
                this.$frame.addClass('wcIFrameMoving');
            }
        },

        __onEndDock: function () {
            if (this.$frame) {
                this._isDocking = false;
                this.$frame.removeClass('wcIFrameMoving');
                this.__focusFix();
            }
        },

        __onAttached: function () {
            this.$frame.css('z-index', '');
            this.__updateFrame();
        },

        __onMoveStarted: function () {
            if (this.$frame && !this._isDocking) {
                this.$frame.addClass('wcIFrameMoving');
            }
        },

        __onMoveFinished: function () {
            if (this.$frame && !this._isDocking) {
                this.$frame.removeClass('wcIFrameMoving');
                this.__focusFix();
            }
        },
        __onMoved: function () {
            if (this.$frame && this._panel) {
                // Size, position, and show the frame once the move is finished.
                var docker = this.docker(this._panel);//in base
                if (docker) {
                    var dockerPos = docker.$container.offset();
                    var pos = this.$container.offset();
                    var width = this.$container.width();
                    var height = this.$container.height();

                    this.$frame.css('top', pos.top - dockerPos.top);
                    this.$frame.css('left', pos.left - dockerPos.left);
                    this.$frame.css('width', width);
                    this.$frame.css('height', height);
                } else {
                    console.error('have no docker');
                }
            }
        },
        __onOrderChanged: function (layer) {
            this.$frame.css('z-index', layer + 1);
        },
        __onClosed: function () {
            this.destroy();
        }
    });
    return Module;

});

},
'xfile/Breadcrumb':function(){
/** @module xfile/Breadcrumb **/
define([
    "dcl/dcl",
    'xide/widgets/TemplatedWidgetBase',
    'xide/model/Path',
    'xide/_base/_Widget'
], function (dcl,TemplatedWidgetBase,Path,_Widget) {

    return dcl(_Widget,{
        templateString:"<ul attachTo='root' style='-webkit-app-region:drag' class='breadcrumb'></ul>",
        grid:null,
        destroy:function(){
            this.clear();
            this.grid = null;
        },
        setSource:function(src){

            /*
            if(!src || (!src.getBreadcrumbPath || !src.collection)){
                return;
            }
            */

            if(this.grid==src){
                return;
            }

            this.grid = src;
            var collection = src.collection
            this.clear();

            var customPath = src.getBreadcrumbPath ? src.getBreadcrumbPath():null;
            if(customPath===false){
                return;
            }
            if(customPath){
                this.setPath(customPath.root, null, customPath, null);
            }else if(collection && src.getCurrentFolder){

                var store = collection,
                    cwdItem = src.getCurrentFolder(),
                    cwd = cwdItem ? cwdItem.path : '';

                this.setPath('.', store.getRootItem(), cwd, store);
            }

        },
        setPath : function(rootLabel,rootItem,path,store,_init){

            this.clear();
            rootItem && rootLabel && this.addSegment(rootLabel, true, rootItem);
            var _path = new Path(path);
            var segs = _path.getSegments();
            var _last = _init || '.';
            _.each(segs, function (seg) {
                var segPath = _last + '/' + seg;
                this.addSegment(seg, true, store ? store.getSync(segPath) : null);
                _last = segPath;
            },this);
        },
        /**
         * Event delegation
         * @param label
         * @param e
         * @param el
         */
        onClick:function(label,e,el){
            this._emit('click',{
                element:el,
                event:e,
                label:label,
                data:el.data
            });
        },
        /**
         * Add a new breadcrumb item
         * @param label
         * @param active
         * @param data
         * @returns {*|jQuery|HTMLElement}
         */
        addSegment:function(label,active,data){

            if(data && this.has(data)){
                return null;
            }

            var _class = active ? 'active' : '',
                self = this,
                el = $("<li class='" +_class + "'><a href='#'>" + label + "</a></li>");

            //clear active state of all previous elements
            _.each(this.all(),function(e){
                e.el.removeClass('active');
            });

            $(this.domNode).append(el);

            if(data) {
                el.on('click', function (e) {
                    self.grid && self.grid.openFolder(data);
                });
                el[0].data = data;
            }

            return el;
        },
        /**
         * Remove last breadcrumb item
         */
        pop:function(){
            this.last().remove();
        },
        /**
         * Return last breadcrumb item
         * @returns {*|jQuery}
         */
        last:function(){
            return $(this.root).children().last();
        },
        /**
         * Returns true when data is found
         * @param data
         * @returns {boolean}
         */
        has:function(data){

            var all = this.all();
            for (var i = 0; i < all.length; i++) {
                if(all[i].data.path === data.path){
                    return true;
                }
            }
            return false;
        },
        /**
         * Return all breadcrumb items
         * @returns {Array}
         */
        all:function(){

            var result = [];

            _.each(this.$root.children(),function(el){
                result.push({
                    el:$(el),
                    label:el.outerText,
                    data:el.data
                })
            });

            return result;

        },
        clear:function(){

            var all = this.all();
            while(all.length){
                var item =all[all.length-1];
                item.el.remove();
                item.data = null;
                all.remove(item);
            }
        },
        /**
         * Removes all breadcrumb items from back to beginning, until data.path matches
         * @param data
         */
        unwind:function(data){
            var rev = this.all().reverse();
            _.each(rev,function(e){
                if(e.data && e.data.path !== (data && data.path) && e.data.path!=='.'){
                    this.pop();
                }
            },this);
        },
        startup:function(){

            this._on('click',function(e){

                var data = e.element[0].data,
                    grid = this.grid;

                if(data) {
                    this.unwind(data);
                    grid && grid.openFolder(data);
                }

            }.bind(this));
        }
    });
});
},
'dojo/dom-geometry':function(){
define(["./sniff", "./_base/window","./dom", "./dom-style"],
	function(has, win, dom, style){
		// module:
		//		dojo/dom-geometry

		// the result object
		var geom = {
			// summary:
			//		This module defines the core dojo DOM geometry API.
		};

		// Box functions will assume this model.
		// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
		// Can be set to change behavior of box setters.

		// can be either:
		//	"border-box"
		//	"content-box" (default)
		geom.boxModel = "content-box";

		// We punt per-node box mode testing completely.
		// If anybody cares, we can provide an additional (optional) unit
		// that overrides existing code to include per-node box sensitivity.

		// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
		// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
		// IIRC, earlier versions of Opera did in fact use border-box.
		// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

		if(has("ie") /*|| has("opera")*/){
			// client code may have to adjust if compatMode varies across iframes
			geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
		}

		geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with special values specifically useful for node
			//		fitting.
			// description:
			//		Returns an object with `w`, `h`, `l`, `t` properties:
			//	|		l/t/r/b = left/top/right/bottom padding (respectively)
			//	|		w = the total of the left and right padding
			//	|		h = the total of the top and bottom padding
			//		If 'node' has position, l/t forms the origin for child nodes.
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		var none = "none";

		geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object with properties useful for noting the border
			//		dimensions.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right border
			//		- h = the sum of the top and bottom border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
				l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
				t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
				r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
				b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with properties useful for box fitting with
			//		regards to padding.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right padding and border
			//		- h = the sum of the top and bottom padding and border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node),
				p = geom.getPadExtents(node, s),
				b = geom.getBorderExtents(node, s);
			return {
				l: p.l + b.l,
				t: p.t + b.t,
				r: p.r + b.r,
				b: p.b + b.b,
				w: p.w + b.w,
				h: p.h + b.h
			};
		};

		geom.getMarginExtents = function getMarginExtents(node, computedStyle){
			// summary:
			//		returns object with properties useful for box fitting with
			//		regards to box margins (i.e., the outer-box).
			//
			//		- l/t = marginLeft, marginTop, respectively
			//		- w = total width, margin inclusive
			//		- h = total height, margin inclusive
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		// Box getters work in any box context because offsetWidth/clientWidth
		// are invariant wrt box context
		//
		// They do *not* work for display: inline objects that have padding styles
		// because the user agent ignores padding (it's bogus styling in any case)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.

		// Although it would be easier to read, there are not separate versions of
		// _getMarginBox for each browser because:
		// 1. the branching is not expensive
		// 2. factoring the shared code wastes cycles (function call overhead)
		// 3. duplicating the shared code wastes bytes

		geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width, height, left and top
			//		positions of the node's margin box.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			if(!node){
				console.error('have no node');
				return {
					l:0,
					t:0,
					w:0,
					h:0
				};
			}
			var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
				l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
			if(has("mozilla")){
				// Mozilla:
				// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
				// by the parent's border.
				// We don't want to compute the parent's style, so instead we examine node's
				// computed left/top which is more stable.
				var sl = parseFloat(s.left), st = parseFloat(s.top);
				if(!isNaN(sl) && !isNaN(st)){
					l = sl;
					t = st;
				}else{
					// If child's computed left/top are not parseable as a number (e.g. "auto"), we
					// have no choice but to examine the parent's computed style.
					if(p && p.style){
						pcs = style.getComputedStyle(p);
						if(pcs.overflow != "visible"){
							l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
							t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
						}
					}
				}
			}else if(has("opera") || (has("ie") == 8 && !has("quirks"))){
				// On Opera and IE 8, offsetLeft/Top includes the parent's border
				if(p){
					pcs = style.getComputedStyle(p);
					l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
					t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
				}
			}
			return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
		};

		geom.getContentBox = function getContentBox(node, computedStyle){
			// summary:
			//		Returns an object that encodes the width, height, left and top
			//		positions of the node's content box, irrespective of the
			//		current box model.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			// clientWidth/Height are important since the automatically account for scrollbars
			// fallback to offsetWidth/Height for special cases (see #3378)
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
				pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
			if(!w){
				w = node.offsetWidth;
				h = node.offsetHeight;
			}else{
				h = node.clientHeight;
				be.w = be.h = 0;
			}
			// On Opera, offsetLeft includes the parent's border
			if(has("opera")){
				pe.l += be.l;
				pe.t += be.t;
			}
			return {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};
		};

		// Box setters depend on box context because interpretation of width/height styles
		// vary wrt box context.
		//
		// The value of boxModel is used to determine box context.
		// boxModel can be set directly to change behavior.
		//
		// Beware of display: inline objects that have padding styles
		// because the user agent ignores padding (it's a bogus setup anyway)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.
		//
		// Elements other than DIV may have special quirks, like built-in
		// margins or padding, or values not detectable via computedStyle.
		// In particular, margins on TABLE do not seems to appear
		// at all in computedStyle on Mozilla.

		function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
			// summary:
			//		sets width/height/left/top in the current (native) box-model
			//		dimensions. Uses the unit passed in u.
			// node:
			//		DOM Node reference. Id string not supported for performance
			//		reasons.
			// l:
			//		left offset from parent.
			// t:
			//		top offset from parent.
			// w:
			//		width in current box model.
			// h:
			//		width in current box model.
			// u:
			//		unit measure to use for other measures. Defaults to "px".
			u = u || "px";
			var s = node.style;
			if(!isNaN(l)){
				s.left = l + u;
			}
			if(!isNaN(t)){
				s.top = t + u;
			}
			if(w >= 0){
				s.width = w + u;
			}
			if(h >= 0){
				s.height = h + u;
			}
		}

		function isButtonTag(/*DomNode*/ node){
			// summary:
			//		True if the node is BUTTON or INPUT.type="button".
			return node.tagName.toLowerCase() == "button" ||
				node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
		}

		function usesBorderBox(/*DomNode*/ node){
			// summary:
			//		True if the node uses border-box layout.

			// We could test the computed style of node to see if a particular box
			// has been specified, but there are details and we choose not to bother.

			// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
			// If you have assigned a different box to either one via CSS then
			// box functions will break.

			return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
		}

		geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		Sets the size of the node's contents, irrespective of margins,
			//		padding, or borders.
			// node: DOMNode
			// box: Object
			//		hash with optional "w", and "h" properties for "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var w = box.w, h = box.h;
			if(usesBorderBox(node)){
				var pb = geom.getPadBorderExtents(node, computedStyle);
				if(w >= 0){
					w += pb.w;
				}
				if(h >= 0){
					h += pb.h;
				}
			}
			setBox(node, NaN, NaN, w, h);
		};

		var nilExtents = {l: 0, t: 0, w: 0, h: 0};

		geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		sets the size of the node's margin box and placement
			//		(left/top), irrespective of box model. Think of it as a
			//		passthrough to setBox that handles box-model vagaries for
			//		you.
			// node: DOMNode
			// box: Object
			//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			if(!node){
				console.error('have no node');
				return;
			}
			var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
				// Some elements have special padding, margin, and box-model settings.
				// To use box functions you may need to set padding, margin explicitly.
				// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
				pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
				mb = geom.getMarginExtents(node, s);
			if(has("webkit")){
				// on Safari (3.1.2), button nodes with no explicit size have a default margin
				// setting an explicit size eliminates the margin.
				// We have to swizzle the width to get correct margin reading.
				if(isButtonTag(node)){
					var ns = node.style;
					if(w >= 0 && !ns.width){
						ns.width = "4px";
					}
					if(h >= 0 && !ns.height){
						ns.height = "4px";
					}
				}
			}
			if(w >= 0){
				w = Math.max(w - pb.w - mb.w, 0);
			}
			if(h >= 0){
				h = Math.max(h - pb.h - mb.h, 0);
			}
			setBox(node, box.l, box.t, w, h);
		};

		// =============================
		// Positioning
		// =============================

		geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
			// summary:
			//		Returns true if the current language is left-to-right, and false otherwise.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Boolean

			doc = doc || win.doc;
			return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
		};

		geom.docScroll = function docScroll(/*Document?*/ doc){
			// summary:
			//		Returns an object with {node, x, y} with corresponding offsets.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Object

			doc = doc || win.doc;
			var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
			return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
			{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
		};

		geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
			// summary:
			//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
			return {
				x: 0,
				y: 0
			};
		};

		geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
			// summary:
			//		In RTL direction, scrollLeft should be a negative value, but IE
			//		returns a positive one. All codes using documentElement.scrollLeft
			//		must call this function to fix this error, otherwise the position
			//		will offset to right when there is a horizontal scrollbar.
			// scrollLeft: Number
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Number

			// In RTL direction, scrollLeft should be a negative value, but IE
			// returns a positive one. All codes using documentElement.scrollLeft
			// must call this function to fix this error, otherwise the position
			// will offset to right when there is a horizontal scrollbar.

			doc = doc || win.doc;
			var ie = has("ie");
			if(ie && !geom.isBodyLtr(doc)){
				var qk = has("quirks"),
					de = qk ? win.body(doc) : doc.documentElement,
					pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
				if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
					scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
				}
				return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
			}
			return scrollLeft; // Integer
		};

		geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
			// summary:
			//		Gets the position and size of the passed element relative to
			//		the viewport (if includeScroll==false), or relative to the
			//		document root (if includeScroll==true).
			//
			// description:
			//		Returns an object of the form:
			//		`{ x: 100, y: 300, w: 20, h: 15 }`.
			//		If includeScroll==true, the x and y values will include any
			//		document offsets that may affect the position relative to the
			//		viewport.
			//		Uses the border-box model (inclusive of border and padding but
			//		not margin).  Does not act as a setter.
			// node: DOMNode|String
			// includeScroll: Boolean?
			// returns: Object

			node = dom.byId(node);
			var	db = win.body(node.ownerDocument),
				ret = node.getBoundingClientRect();
			ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

			if(has("ie") < 9){
				// fixes the position in IE, quirks mode
				ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
				ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
			}

			// account for document scrolling
			// if offsetParent is used, ret value already includes scroll position
			// so we may have to actually remove that value if !includeScroll
			if(includeScroll){
				var scroll = geom.docScroll(node.ownerDocument);
				ret.x += scroll.x;
				ret.y += scroll.y;
			}

			return ret; // Object
		};

		// random "private" functions wildly used throughout the toolkit

		geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width and height of
			//		the node's margin box
			// node: DOMNode|String
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
			var size = node.getBoundingClientRect();
			return {
				w: (size.right - size.left) + me.w,
				h: (size.bottom - size.top) + me.h
			};
		};

		geom.normalizeEvent = function(event){
			// summary:
			//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
			//		offsetX, offsetY, layerX, and layerX properties
			// event: Object
			if(!("layerX" in event)){
				event.layerX = event.offsetX;
				event.layerY = event.offsetY;
			}

			if(!("pageX" in event)){
				// FIXME: scroll position query is duped from dojo/_base/html to
				// avoid dependency on that entire module. Now that HTML is in
				// Base, we should convert back to something similar there.
				var se = event.target;
				var doc = (se && se.ownerDocument) || document;
				// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
				// here rather than document.body
				var docBody = has("quirks") ? doc.body : doc.documentElement;
				event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
				event.pageY = event.clientY + (docBody.scrollTop || 0);
			}
		};

		// TODO: evaluate separate getters/setters for position and sizes?

		return geom;
	});

},
'dojo/date/stamp':function(){
define(["../_base/lang", "../_base/array"], function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
});

},
'dojo/dnd/Container':function(){
define([
	"../_base/array",
	"../_base/declare",
	"../_base/kernel",
	"../_base/lang",
	"../_base/window",
	"../dom",
	"../dom-class",
	"../dom-construct",
	"../Evented",
	"../has",
	"../on",
	"../query",
	"../touch",
	"./common"
], function(
	array, declare, kernel, lang, win,
	dom, domClass, domConstruct, Evented, has, on, query, touch, dnd){

// module:
//		dojo/dnd/Container

/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/



var Container = declare("dojo.dnd.Container", Evented, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers

	// object attributes (for markup)
	skipForm: false,
	// allowNested: Boolean
	//		Indicates whether to allow dnd item nodes to be nested within other elements.
	//		By default this is false, indicating that only direct children of the container can
	//		be draggable dnd item nodes
	allowNested: false,
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,

	// map: Hash<String, Container.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo/dnd/Container.Item itself.
	map: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: Container.__ContainerArgs
		//		a dictionary of parameters
		this.node = dom.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dom.byId(params.dropParent);

		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		domClass.add(this.node, "dojoDndContainer");

		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			on(this.node, touch.over, lang.hitch(this, "onMouseOver")),
			on(this.node, touch.out,  lang.hitch(this, "onMouseOut")),
			// cancel text selection and text dragging
			on(this.node, "dragstart",   lang.hitch(this, "onSelectStart")),
			on(this.node, "selectstart", lang.hitch(this, "onSelectStart"))
		];
	},

	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},

	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// Container.Item
	},
	setItem: function(/*String*/ key, /*Container.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || kernel.global;
		var m = this.map, e = dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},

	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return query((this.allowNested ? "" : "> ") + ".dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		var i, t;
		if(anchor){
			for(i = 0; i < data.length; ++i){
				t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				anchor.parentNode.insertBefore(t.node, anchor);
			}
		}else{
			for(i = 0; i < data.length; ++i){
				t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		array.forEach(this.events, function(handle){ handle.remove(); });
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node, Ctor){
		params._skipStartup = true;
		return new Ctor(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map

		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover or touch, to mark that element as the current element
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dnd.isFormElement(e)){
			e.stopPropagation();
			e.preventDefault();
		}
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//domClass.replace(this.node, prefix + newState, prefix + this[state]);
		domClass.replace(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		domClass.add(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		domClass.remove(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if((parent == this.parent || this.allowNested) && domClass.contains(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*Container.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!lang.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dnd.getUniqueId(); }
		domClass.add(t.node, "dojoDndItem");
		return t;
	}
});

dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dnd._createSpan; }
	return function(text){	// Function
		return domConstruct.create(tag, {innerHTML: text});	// Node
	};
};

dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = domConstruct.create("tr");
	domConstruct.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return domConstruct.create("span", {innerHTML: text});	// Node
};

// dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dnd._createTrTd :
			dnd._createNode(dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && lang.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

/*=====
Container.__ContainerArgs = declare([], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

Container.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.

	this.type = type;
	this.data = data;
};
=====*/

return Container;
});

},
'xide/Features':function(){
define([
    'xdojo/has'
],function(has){
    var features = [
        'debug',
        'plugins',
        'log',
        'ribbons',
        'xideve',
        'files',
        'xnode',
        'xfile',
        'xace',
        'drivers',
        'debugWidgets',
        'consoleError'

    ];

    var hiddenFeatures = [
        'admin'
    ];
    
    if( 1 ) {

        _.each(features, function (feature) {
            has.add(feature, function (global, document, anElement) {
                if (location.href.indexOf(feature + '=false') !== -1) {
                    return false;
                } else {
                    return true;
                }
            }, true, true);
        });

        _.each(hiddenFeatures, function (feature) {
            has.add(feature, function (global, document, anElement) {
                if (location.href.indexOf(feature) !== -1) {
                    return true;
                } else {
                    return false;
                }
            }, true, true);
        });

        has.add("phone", function (global, document, anElement) {
            return (/iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(navigator.userAgent.toLowerCase())) || location.href.indexOf('forcePhone=true')!=-1;
        });

        has.add("mobile", function (global, document, anElement) {
            return (/iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(navigator.userAgent.toLowerCase()));
        });
    }
});
},
'dojo/request/handlers':function(){
define([
	'../json',
	'../_base/kernel',
	'../_base/array',
	'../has',
	'../selector/_loader' // only included for has() qsa tests
], function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];

		handleXML = function(response){
			var result = response.data;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(response.text, 'application/xml');
			}

			if(!result || !result.documentElement){
				var text = response.text;
				array.some(dp, function(p){
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
					}catch(e){ return false; }
					return true;
				});
			}

			return result;
		};
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
});

},
'dijit/place':function(){
define([
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

},
'dgrid/util/touch':function(){
define([
	'dojo/on'
	//'dojo/query'
], function (on, query) {
	// This module exposes useful functions for working with touch devices.

	var util = {
		// Overridable defaults related to extension events defined below.
		tapRadius: 10,
		dbltapTime: 250,

		selector: function (selector, eventType, children) {
			// summary:
			//		Reimplementation of on.selector, taking an iOS quirk into account
			return function (target, listener) {
				var bubble = eventType.bubble;
				if (bubble) {
					// the event type doesn't naturally bubble, but has a bubbling form, use that
					eventType = bubble;
				}
				else if (children !== false) {
					// for normal bubbling events we default to allowing children of the selector
					children = true;
				}
				return on(target, eventType, function (event) {
					var eventTarget = event.target;

					// iOS tends to report the text node an event was fired on, rather than
					// the top-level element; this may end up causing errors in selector engines
					if (eventTarget.nodeType === 3) {
						eventTarget = eventTarget.parentNode;
					}

					// there is a selector, so make sure it matches
					while (!query.matches(eventTarget, selector, target)) {
						//debugger;
						if (eventTarget === target || !children || !(eventTarget = eventTarget.parentNode)) {
							return;
						}
					}
					return listener.call(eventTarget, event);
				});
			};
		},

		countCurrentTouches: function (evt, node) {
			// summary:
			//		Given a touch event and a DOM node, counts how many current touches
			//		presently lie within that node.  Useful in cases where an accurate
			//		count is needed but tracking changedTouches won't suffice because
			//		other handlers stop events from bubbling high enough.

			if (!('touches' in evt)) {
				// Not a touch event (perhaps called from a mouse event on a
				// platform supporting touch events)
				return -1;
			}

			var i, numTouches, touch;
			for (i = 0, numTouches = 0; (touch = evt.touches[i]); ++i) {
				if (node.contains(touch.target)) {
					++numTouches;
				}
			}
			return numTouches;
		}
	};

	function handleTapStart(target, listener, evt, prevent) {
		// Common function for handling tap detection.
		// The passed listener will only be fired when and if a touchend is fired
		// which confirms the overall gesture resembled a tap.

		if (evt.targetTouches.length > 1) {
			return; // ignore multitouch
		}

		var start = evt.changedTouches[0],
			startX = start.screenX,
			startY = start.screenY;

		prevent && evt.preventDefault();

		var endListener = on(target, 'touchend', function (evt) {
			var end = evt.changedTouches[0];
			if (!evt.targetTouches.length) {
				// only call listener if this really seems like a tap
				if (Math.abs(end.screenX - startX) < util.tapRadius &&
						Math.abs(end.screenY - startY) < util.tapRadius) {
					prevent && evt.preventDefault();
					listener.call(this, evt);
				}
				endListener.remove();
			}
		});
	}

	function tap(target, listener) {
		// Function usable by dojo/on as a synthetic tap event.
		return on(target, 'touchstart', function (evt) {
			handleTapStart(target, listener, evt);
		});
	}

	function dbltap(target, listener) {
		// Function usable by dojo/on as a synthetic double-tap event.
		var first, timeout;

		return on(target, 'touchstart', function (evt) {
			if (!first) {
				// first potential tap: detect as usual, but with specific logic
				handleTapStart(target, function (evt) {
					first = evt.changedTouches[0];
					timeout = setTimeout(function () {
						first = timeout = null;
					}, util.dbltapTime);
				}, evt);
			}
			else {
				handleTapStart(target, function (evt) {
					// bail out if first was cleared between 2nd touchstart and touchend
					if (!first) {
						return;
					}
					var second = evt.changedTouches[0];
					// only call listener if both taps occurred near the same place
					if (Math.abs(second.screenX - first.screenX) < util.tapRadius &&
							Math.abs(second.screenY - first.screenY) < util.tapRadius) {
						timeout && clearTimeout(timeout);
						first = timeout = null;
						listener.call(this, evt);
					}
				}, evt, true);
			}
		});
	}

	util.tap = tap;
	util.dbltap = dbltap;

	return util;
});
},
'xgrid/KeyboardNavigation':function(){
define([
	"xdojo/declare", // declare
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // hitch
	"dojo/on",
	"xide/utils"
], function(declare, keys, lang, on, utils){

	//@TODO: port hitch
	var hitch = lang.hitch;
	//@TODO: port utils.find
	var find = utils.find;
	
	return declare('xgrid/KeyboardNavigation',null, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: ".dgrid-row",
		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: function reference
			// delay: Optional number (defaults to 0)
			// tags:
			//		protected.
			var timer = setTimeout(hitch(this,
					function(){
						timer = null;
						if(!this._destroyed){
							hitch(this, fcn)();
						}
					}),
				delay || 0
			);
			return {
				remove:	function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		},
		buildRendering:function(){
			this.inherited(arguments);
			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			//domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.UP_ARROW] = hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string" ? this.childSelector : hitch(this, "childSelector"),
				node = this.domNode;

			this.__on(node, "keypress",null,hitch(this, "_onContainerKeypress"));
			this.__on(node, "keydown",null,hitch(this, "_onContainerKeydown"));
		},
		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		___focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},
		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.deselectAll();
				this.select([this.row(item).data],null,true,{
					focus:true,
					delay:10,
					append:true
				})
			}
		},
		getSearchableText:function(data){
			return data.message || data.name  || '';
		},
		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			var element = item;
			if(item && !item.data){
				var row= this.row(item);
				if(row){
					item['data']=row.data;
				}
			}

			//var text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "";
			var text = item ? item.data ? this.getSearchableText(item.data) : '' : '';
			if(text) {
				text = text.toLowerCase();
				//try starts with first:
				var currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();
				var res = (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default

				var contains = text.replace(/^\s+/, '').indexOf(searchString.toLowerCase())!=-1;
				if(res==0 && searchString.length>1 && contains){
					return 1;
				}
				return res;
			}
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			if((evt.target && evt.target.className.indexOf('input') != -1)){
				return;
			}

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop _HasDropDown from processing the SPACE as well
				evt.preventDefault(); // stop default actions like page scrolling on SPACE, but also keypress unfortunately
				on.emit(this.domNode, "keypress", {
					charCode: keys.SPACE,
					cancelable: true,
					bubbles: true
				});
			}
		},

		_onContainerKeypress: function(evt){
			if(this.editing){
				return;
			}
			if((evt.target && evt.target.className.indexOf('input') != -1)){
				return;
			}
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			if(evt.charCode < 32){
				// Avoid duplicate events on firefox (this is an arrow key that will be handled by keydown handler)
				return;
			}

			if(evt.ctrlKey || evt.altKey){
				return;
			}

			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';

					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChildNode ||this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					var idx=0;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				}),
				keyChar = String.fromCharCode(evt.charCode).toLowerCase();


			evt.preventDefault();
			evt.stopPropagation();
			search();

			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){
						break;
					}
				}else{
					if(child && child.node){
						var innerNode = utils.find('.dgrid-cell',child.node,true);
						if(innerNode){
							child=innerNode;
						}
					}
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue){
					return child;
				}
			}while(child != wrappedValue);
		},

		_getFirst: function(){
			var innerNode = utils.find('.dgrid-row', this.domNode,true);
			if(innerNode){
				var innerNode0 = utils.find('.dgrid-cell', innerNode,true);
				if(innerNode0){
					return innerNode0;
				}
			}
			return innerNode;
		},

		_getLast: function(){
			var innerNode = utils.find('.dgrid-row', this.domNode,false);
			if(innerNode){
				var innerNode0 = utils.find('.dgrid-cell', innerNode,true);
				if(innerNode0){
					return innerNode0;
				}
			}
			return null;
		},
		_getPrev: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			if(child){
				var w= this.up(child,1,true);
				if(w){
					var data = null;
					if(w.data){
						data= w.data;
					}

					if(w.element){
						w= w.element;
					}
					var innerNode = utils.find('.dgrid-cell', w,true);
					if(innerNode){
						if(!innerNode.data){
							innerNode['data']=data;
						}
						return innerNode;
					}
					return w;
				}
			}
		},
		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			if(child){
				var w= this.down(child,1,true);
				if(w){
					if(w.element){
						w= w.element;
					}
					var innerNode = utils.find('.dgrid-cell', w,true);
					if(innerNode){
						return innerNode;
					}
					return w;
				}
			}
		}
	});
});

},
'xide/manager/ServerActionBase':function(){
/** @module xide/manager/ServerActionBase */
define([
    'dcl/dcl',
    'dojo/_base/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/manager/RPCService',
    'xide/manager/ManagerBase',
    'xide/types',
    'xide/utils'
], function (dcl,declare, has, Deferred, RPCService, ManagerBase, types, utils) {
    var Singleton = null;
    /**
     * Class dealing with JSON-RPC-2, used by most xide managers
     * @class module:xide.manager.ServerActionBase
     * @augments {module:xide/manager/ManagerBase}
     */
    var Implementation = {
        declaredClass:"xide.manager.ServerActionBase",
        serviceObject: null,
        serviceUrl: null,
        singleton: true,
        serviceClass: null,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        base64_encode: function (data) {

            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var self = this;
            if(this.serviceObject.__init){

                if(this.serviceObject.__init.isResolved()){
                    return self._runDeferred(serviceClassIn,method,args,options);
                }
                var dfd = new Deferred();
                this.serviceObject.__init.then(function(){
                    self._runDeferred(serviceClassIn,method,args,options).then(function(){
                       dfd.resolve(arguments);
                    });
                });
                return dfd;
            }
            return self._runDeferred(serviceClassIn,method,args,options);
        },
        /**
         * Public main entry, all others below are deprecated
         * @param serviceClassIn
         * @param method
         * @param args
         * @param options
         * @returns {Deferred}
         */
        _runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred(),
                promise;
            options = options || this.defaultOptions;
            //check we the RPC method is in the SMD
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this.getService(),
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data,error) {
                var dfd = deferred;
                if(options.returnProm){
                    dfd = promise;
                }
                dfd._data = data;
                if(error) {
                    if(options.onError){
                        return options.onError(error);
                    }
                }
                dfd.resolve(data);
            };

            promise = service[serviceClass][method](args);
            promise.then(function (res) {
                res = res || {};
                var error = res.error || {};
                //the server has some messages for us
                if (options.checkMessages) {
                    if (error && error.code == 3) {
                        thiz.onMessages(error);
                    }
                }
                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (error.code == 1) {
                        options.displayError && thiz.onError(error,serviceClass + '::' + method);
                        deferred.reject(error);
                        return;
                    }
                }else{
                    if (error.code == 1 && options.displayError) {
                        thiz.onError(error,serviceClass + '::' + method);
                    }
                    if (error && error.code !== 0) {
                        resolve(res,error);
                        return;
                    }
                }
                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }
                resolve(res);
            }, function (err) {
                thiz.onError(err);
            });

            if(options.returnProm){
                return promise;
            }
            return deferred;
        },
        getService: function () {
            return this.serviceObject;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {
            var _service = this.getService(),
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        findServiceUrl: function (declaredClass) {
            var config = window['xFileConfig'];
            if (config && config.mixins) {
                for (var i = 0; i < config.mixins.length; i++) {
                    var obj = config.mixins[i];
                    if (obj.declaredClass === declaredClass && obj.mixin && obj.mixin.serviceUrl) {
                        return decodeURIComponent(obj.mixin.serviceUrl);
                    }
                }
            }
            return null;
        },
        init: function () {
            this.check();
        },
        _initService: function () {
            var thiz = this;
            if(! 1 ){
                return false;
            }
            try {
                var obj = Singleton;
                if (this.singleton) {
                    if (obj && obj.serviceObject) {
                        this.serviceObject = obj.serviceObject;
                        return;
                    }
                    if(!this.options){
                        this.options = {};
                    }
                    this.options.singleton = this.singleton;
                }
                if (!this.serviceObject) {



                    if (!this.serviceUrl) {
                        console.error('have no service url : ' + this.declaredClass);
                        return;
                    }
                    var url = decodeURIComponent(this.serviceUrl);
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl),this.options);
                    this.serviceObject.runDeferred = function(){
                        return thiz.runDeferred.apply(thiz,arguments);
                    };

                    this.serviceObject.sync = this.sync;

                    if (this.singleton) {
                        obj.serviceObject = this.serviceObject;
                    }
                    if(this.config){
                        obj.serviceObject.config = this.config;
                    }
                }
            } catch (e) {
                console.error('error in rpc service creation : ' + e);
                logError(e);
            }
        },
        check: function () {
            if (!this.serviceObject) {
                this._initService();
            }
        },
        onError: function (err,suffix) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            if(suffix){
                err.message = suffix +  ' -> ' + err.message;
            }
            this.publish(types.EVENTS.ERROR, {
                error:err
            }, this);
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.getService()) {
                return false;
            }
            if (!this.hasMethod(method,serviceClass) && omit === true) {
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },
        prepareCall: function () {
            var params = {};
            //Mixin mandatory fields
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.serviceObject.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                    this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        callMethodEx: function (serviceClassIn, method, args, readyCB, omitError) {
            serviceClassIn = serviceClassIn || this.serviceClass;
            if (!serviceClassIn) {
                console.error('have no service class! ' + this.declaredClass,this);
            }
            //init smd
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            var thiz = this;
            return this.serviceObject[this.getServiceClass(serviceClassIn)][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClassIn);
                    logError(e,'server method failed '+e);

                }
                //rpc batch results
                if (res && res.error && res.error.code == 3) {
                    thiz.onMessages(res.error);
                }

                if (res && res.error && res.error && res.error.code != 0) {
                    thiz.onError(res.error);
                    return;
                }
                if (omitError == true) {
                    thiz.publish(types.EVENTS.STATUS, {message: 'Ok!'}, this);
                }

            }, function (err) {
                thiz.onError(err);
            });
        },
        callMethodEx2: function (serverClassIn, method, args, readyCB, omitError) {
            this.check();
            //check this method exists
            if (!this.checkCall(serverClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            return this.serviceObject[this.getServiceClass(serverClassIn)][method](args);
        },
        callMethod: function (method, args, readyCB, omitError) {
            args = args || [[]];
            var serviceClass = this.serviceClass;
            try {
                var thiz = this;
                //method not listed in SMD
                if (this.serviceObject[serviceClass][method] == null) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                this.serviceObject[this.serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e,"Error calling RPC method");
                    }
                    //rpc batch call
                    if (res && res.error && res.error.code == 3) {
                        this.onMessages(res.error);
                    }
                    if (res && res.error && res.error && res.error.code == 1) {
                        this.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        this.publish(types.EVENTS.STATUS, struct, this);
                    }
                }.bind(this), function (err) {
                    this.onError(err);
                }.bind(this));
            } catch (e) {
                thiz.onError(e);
                logError(e,"Error calling RPC method");
            }
        }
    };

    var Module = dcl(ManagerBase, Implementation);
    Module.declare = declare(null,Implementation);
    Singleton = Module;
    return Module;
});
},
'xide/manager/Router':function(){
/** module:xide/manager/Router **/
define(['xide/utils'], function (utils) {
    /**
     * @param {Object} object
     * @param {Function} callback
     * @param {Object} [ctx]
     * @returns {Object}
     */
    var map = function (object, callback, ctx) {
        var copy = {};
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                copy[key] = callback.call(ctx, object[key], key, object);
            }
        }
        return copy;
    };

    /**
     * merges objects
     * @returns {{}}
     */
    var merge = function () {
        var result = {};
        Array.prototype.forEach.call(arguments, function (o) {
            for (var key in o) {
                if (o.hasOwnProperty(key)) {
                    result[key] = o[key];
                }
            }
        });
        return result;
    };

    /**
     * @param {*} o
     * @returns {*}
     */
    var clone = function (o) {
        if (Array.isArray(o)) {
            return o.map(clone);
        }
        if (o instanceof RegExp || [
                'string',
                'number',
                'boolean',
                'object'
            ].indexOf(typeof o) > -1 || o == null) {
            return o;
        }
        return map(o, clone);
    };

    /**
     * @typedef {Object} module:xide/interface/RouteDefinition
     * @property {String} id
     * @property {String} path
     * @property {String} [host]
     * @property {String} [prefix]
     * @property {Object.<String|Number>} [defaults]
     * @property {Object.<String>} [requirements]
     * @property {Array.<String>} [methods]
     * @property {Array.<String>} [schemes]
     * @property {module:xide/interface/Route} delegate
     */

    /**
     * @typedef {Object} RoutesDefinition
     * @property {String} [prefix]
     * @property {Array.<RouteDefinition|RoutesDefinition>} routes
     */

    /**
     * @typedef {Object} RouteDefinitionParsed
     * @property {String} id
     * @property {RegExp} pattern
     * @property {String} path
     * @property {Array.<String>} parameters
     * @property {RegExp} hostPattern
     * @property {String} host
     * @property {Array.<String>} hostParameters
     * @property {Object.<RegExp>} requirements
     * @property {Object.<String>} defaults
     * @property {Array.<String>} methods
     * @property {Array.<String>} schemes
     * @property {{RouteDefinition}} definition
     */

    /**
     * @typedef {Object} Route
     * @property {String} id
     * @property {RouteDefinition} definition
     * @property {Object.<String>} [parameters]
     */

    /**
     * @class module:xide/manager/Router
     * @param {Object} options
     * @param {Array.<RouteDefinition|RoutesDefinition>} options.routes
     * @param {Array.<String>} [options.defaultMethods=['GET', 'POST', 'PUT', 'DELETE']]
     * @param {Array.<String>} [options.defaultSchemes=['http', 'https']]
     * @param {Object} [options.symbols]
     * @param {String} [options.symbols.defaultParameterRequirement='[^\\/.]*']
     * @param {String} [options.symbols.parametersDelimiters='\.|\/']
     * @param {String} [options.symbols.parameterStart='\{']
     * @param {String} [options.symbols.parameterMatcher='.*?']
     * @param {String} [options.symbols.parameterEnd='\}']
     */
    var RouterBase = function (options) {
        var symbols = options.symbols || {},
            paramsDelimiters = symbols.parametersDelimiters || '\\.|\\/',
            paramStart = symbols.parameterStart || '\\{',
            paramMatcher = symbols.parameterMatcher || '.*?',
            paramEnd = symbols.parameterEnd || '\\}';

        /**
         * @const {{regexp: RegExp, parameters: Array}}
         * @private
         */
        this._NO_HOST = {
            regexp: /.*/,
            parameters: []
        };

        /**
         * @type {string}
         * @private
         */
        this._defaultParameterRequirement = symbols.defaultParameterRequirement || '[^\\/.]*';

        /**
         * @type {RegExp}
         * @private
         */
        this._paramsReplaceRegExp = new RegExp('(' + paramsDelimiters + ')?' + paramStart +
            '(' + paramMatcher + ')' + paramEnd, 'g');

        /**
         * @type {Array.<String>}
         * @private
         */
        this._defaultMethods = options.defaultMethods || ['GET', 'POST', 'PUT', 'DELETE'];

        /**
         * @type {Array.<String>}
         * @private
         */
        this._defaultSchemes = options.defaultSchemes || ['http', 'https'];

        /**
         * @type {Array.<RouteDefinition>}
         * @private
         */
        this._routesDefinitions = this._unifyRoutes(options.routes);

        /**
         * @type {Array.<RouteDefinitionParsed>}
         * @private
         */
        this._routes = this._parseRoutes(this._routesDefinitions);

        /**
         * @type {Object.<RouteDefinitionParsed>}
         * @private
         */
        this._routeIdToParsedDefinitionMap = {};
    };

    /**
     * @param {Array.<RouteDefinition|RoutesDefinition>} routes
     * @param {RouteDefinition} [parentRoute]
     * @returns {Array.<RouteDefinition>}
     * @private
     */
    RouterBase.prototype._unifyRoutes = function (routes, parentRoute) {
        var unifiedRoutes = [];
        routes.forEach(function (route) {
            unifiedRoutes = unifiedRoutes.concat(this._unifyRoute(route, parentRoute));
        }, this);
        return unifiedRoutes;
    };

    /**
     * @param {RouteDefinition|RoutesDefinition} route
     * @param {RouteDefinition} [parentRoute]
     * @returns {RouteDefinition|Array.<RouteDefinition>}
     * @private
     */
    RouterBase.prototype._unifyRoute = function (route, parentRoute) {
        parentRoute = parentRoute || {};
        route.defaults = map(merge(parentRoute.defaults, route.defaults), function (prop) {
            return String(prop);
        });
        route.requirements = merge(parentRoute.requirements, route.requirements);
        if (parentRoute.prefix) {
            route.path = parentRoute.prefix + route.path;
            route.prefix = route.prefix ? parentRoute.prefix + route.prefix : parentRoute.prefix;
        }
        route.host = route.host || parentRoute.host;
        route.methods = route.methods || parentRoute.methods || this._defaultMethods;
        route.schemes = route.schemes || parentRoute.schemes || this._defaultSchemes;
        for (var key in parentRoute) {
            if (parentRoute.hasOwnProperty(key) && key !== 'routes' && !route[key]) {
                route[key] = parentRoute[key];
            }
        }
        return route.routes ? this._unifyRoutes(route.routes, route) : route;
    };

    /**
     * @param {Array.<RouteDefinition|RoutesDefinition>} routes
     * @returns {Array.<RouteDefinitionParsed>}
     * @private
     */
    RouterBase.prototype._parseRoutes = function (routes) {
        return routes.map(this._parseRoute, this);
    };

    /**
     * @param {RouteDefinition} route
     * @param {Number} i
     * @returns {RouteDefinitionParsed}
     * @private
     */
    RouterBase.prototype._parseRoute = function (route, i) {
        var defaults = route.defaults,
            requirements = route.requirements,
            path = route.path,
            host = route.host,
            parsedHost = host ? this._parsePath(host, requirements, defaults) : this._NO_HOST,
            parsedPath = this._parsePath(path, requirements, defaults);
        return {
            id: route.id,
            pattern: parsedPath.regexp,
            path: path,
            parameters: parsedPath.parameters,
            hostPattern: parsedHost.regexp,
            host: host,
            hostParameters: parsedHost.parameters,
            requirements: map(requirements, function (prop) {
                return new RegExp('^' + prop + '$');
            }),
            defaults: defaults,
            methods: route.methods,
            schemes: route.schemes,
            definition: this._routesDefinitions[i]
        };
    };

    /**
     * @param {String} path
     * @param {Object} [requirements]
     * @param {Object} [defaults]
     * @returns {{regexp: RegExp, parameters: Array.<String>}}
     * @private
     */
    RouterBase.prototype._parsePath = function (path, requirements, defaults) {
        var parameters = [],
            defaultParameterRequirement = this._defaultParameterRequirement,
            regexp = new RegExp('^' +
                path
                    .replace(/([\/\.\|])/g, '\\$1')
                    .replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
                        var optional = parameterName in defaults;
                        parameters.push(parameterName);
                        return (delimiter || '') + (optional && delimiter ? '?' : '') +
                            '(' + (requirements[parameterName] ? requirements[parameterName] : defaultParameterRequirement) + ')' +
                            (optional ? '?' : '');
                    }) +
                '$');
        return {
            regexp: regexp,
            parameters: parameters
        };
    };

    /**
     * @param {{path: String, method: String, host: String|undefined, scheme: String|undefined}} request
     * @returns {?Route}
     * @public
     */
    RouterBase.prototype.match = function (request) {
        var routes = this._routes,
            route,
            pathParts = request.path.split('?'),
            path = pathParts[0],
            query = pathParts[1] ? this._parseQuery(pathParts[1]) : null,
            execPathResult,
            execHostResult,
            isMethodValid,
            isSchemeValid;

        request.method = 'GET';

        for (var i = 0, l = routes.length; i < l; i++) {
            route = routes[i];
            execPathResult = route.pattern.exec(path);
            if (!execPathResult) {
                continue;
            }
            execHostResult = route.hostPattern.exec(request.host);
            if (!execHostResult) {
                continue;
            }
            isMethodValid = route.methods.indexOf(request.method) > -1;
            if (!isMethodValid) {
                continue;
            }
            isSchemeValid = !request.scheme || route.schemes.indexOf(request.scheme) > -1;
            if (isSchemeValid) {
                execPathResult.shift();
                execHostResult.shift();
                return {
                    id: route.id,
                    parameters: this._retrieveParameters(route, execPathResult, execHostResult, query),
                    definition: clone(this._routesDefinitions[i])
                };
            }
        }
        return null;
    };

    /**
     * @param {String} query
     * @returns {{}}
     * @protected
     */
    RouterBase.prototype._parseQuery = function (query) {
        var obj = {};

        if (typeof query !== 'string' || query.length === 0) {
            return obj;
        }

        var regexp = /\+/g;
        query = query.split('&');

        var len = query.length;

        for (var i = 0; i < len; ++i) {
            var x = query[i].replace(regexp, '%20'),
                idx = x.indexOf('='),
                kstr, vstr, k, v;

            if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
            } else {
                kstr = x;
                vstr = '';
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!obj.hasOwnProperty(k)) {
                obj[k] = v;
            } else if (Array.isArray(obj[k])) {
                obj[k].push(v);
            } else {
                obj[k] = [obj[k], v];
            }
        }

        return obj;
    };

    /**
     * @param {RouteDefinitionParsed} route
     * @param {Array.<String>} parsedParameters
     * @param {Array.<String>} parsedHostParameters
     * @param {Object.<String>} [query={}]
     * @returns {Object.<String>}
     * @private
     */
    RouterBase.prototype._retrieveParameters = function (route, parsedParameters, parsedHostParameters, query) {
        var parameters = query || {};
        for (var key in route.defaults) {
            if (route.defaults.hasOwnProperty(key)) {
                parameters[key] = route.defaults[key];
            }
        }
        this._extendParameters(parsedParameters, route.parameters, parameters);
        this._extendParameters(parsedHostParameters, route.hostParameters, parameters);
        return parameters;
    };

    /**
     * @param {Array.<String>} input parameters values
     * @param {Array.<String>} names parameters names
     * @param {Object.<String>} output parameters names: parameters values
     * @private
     */
    RouterBase.prototype._extendParameters = function (input, names, output) {
        for (var i = 0, l = names.length; i < l; i++) {
            if (input[i] === undefined) {
                break;
            }
            output[names[i]] = decodeURIComponent(input[i]);
        }
    };

    /**
     * @param {String} id
     * @param {Object.<String>} [params]
     * @returns {String}
     * @throws Error if required parameter is not given
     * @throws Error if parameter value is not suits requirements
     * @throws Error if route is not defined
     * @throws URIError
     * @public
     */
    RouterBase.prototype.generate = function (id, params) {
        var routes = this._routes,
            route;
        for (var i = 0, l = routes.length; i < l; i++) {
            route = routes[i];
            if (route.id === id) {
                return this._generate(route, merge({}, params));
            }
        }
        throw new Error('No such route: ' + id);
    };

    /**
     * @param {RouteDefinitionParsed} route
     * @param {Object.<String>} [params]
     * @returns {String}
     * @throws Error if required parameter is not given
     * @throws Error if parameter value is not suits requirements
     * @private
     */
    RouterBase.prototype._generate = function (route, params) {
        var path = route.path,
            generatedPath,
            host = route.host,
            generatedHost,
            defaults = route.defaults,
            requirements = route.requirements,
            _this = this;
        generatedPath = path.replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
            delimiter = delimiter || '';
            var optional = parameterName in defaults,
                exists = params && parameterName in params;
            if (exists) {
                return _this._getParameterValue(parameterName, params, requirements, delimiter);
            } else if (!optional) {
                _this._throwParameterNeededError(parameterName, route.id);
            }

            var hasFilledParams = false;
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    if (route.parameters.indexOf(key) > -1) {
                        hasFilledParams = true;
                        break;
                    }
                }
            }

            return hasFilledParams ? delimiter + defaults[parameterName] : '';
        });

        if (host) {
            generatedHost = host.replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
                var optional = parameterName in defaults,
                    exists = params && parameterName in params;
                delimiter = delimiter || '';
                if (exists) {
                    return _this._getParameterValue(parameterName, params, requirements, delimiter);
                } else if (optional) {
                    return delimiter + defaults[parameterName];
                } else {
                    _this._throwParameterNeededError(parameterName, route.id);
                }
            });
        }

        var query = this._generateQuery(params);

        if (query) {
            generatedPath += '?' + query;
        }

        return generatedHost ? route.schemes[0] + '://' + generatedHost + generatedPath : generatedPath;
    };

    /**
     * @param {Object.<String>} params
     * @returns {String}
     * @protected
     */
    RouterBase.prototype._generateQuery = function (params) {
        var query = '';
        for (var key in params) {
            if (params.hasOwnProperty(key)) {
                query += (query.length ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
            }
        }
        return query;
    };

    /**
     * @param {String} parameterName
     * @param {Object.<String>} params
     * @param {Object.<RegExp>} requirements
     * @param {String} delimiter
     * @returns {String}
     * @throws Error if parameter value is invalid
     * @private
     */
    RouterBase.prototype._getParameterValue = function (parameterName, params, requirements, delimiter) {
        var value = params[parameterName];
        delete params[parameterName];
        if (requirements[parameterName] && !requirements[parameterName].test(value)) {
            throw new Error('Parameter "' + parameterName + '" has bad value "' + value + '", not suitable for path generation');
        }
        return delimiter + encodeURIComponent(value);
    };

    /**
     * @param {String} parameterName
     * @param {String} routeId
     * @private
     */
    RouterBase.prototype._throwParameterNeededError = function (parameterName, routeId) {
        throw new Error('Parameter "' + parameterName + '" is needed for route "' + routeId + '" generation');
    };

    /**
     * @param {String} routeId
     * @returns {?RouteDefinitionParsed}
     * @public
     * @throws if route is not defined
     */
    RouterBase.prototype.getRouteInfo = function (routeId) {
        if (!this._routeIdToParsedDefinitionMap[routeId]) {
            for (var i = 0, l = this._routes.length; i < l; i++) {
                if (this._routes[i].id === routeId) {
                    this._routeIdToParsedDefinitionMap[routeId] = this._routes[i];
                    break;
                }
            }
        }

        if (!this._routeIdToParsedDefinitionMap[routeId]) {
            throw new Error('No such route: ' + routeId);
        }

        return clone(this._routeIdToParsedDefinitionMap[routeId]);
    };

    return RouterBase;
});
},
'xide/mixins/PersistenceMixin':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    "xide/utils",
    "dojo/cookie"
], function (dcl, declare, utils, cookie) {

    /**
     * Provides tools to deal with 'persistence' (open files, editors, ..etc to be restored). It also acts as interface.
     * @class module:xide/mixins/PersistenceMixin
     *
     **/
    var Implementation = {
        /***
         * soft override for getPreferencePersistence to allow using
         * another storage
         */
        persistenceFunction: null,
        /**
         * delete preferences in store
         */
        clearPreferences: function () {
            this.savePreferences(null, null, true);
        },
        /**
         * must be implemented
         */
        getDefaultPreferences: function () {
            return {};
        },
        /**
         * deserialize data with provider
         */
        deserializePreference: function (val) {
            return utils.getJson(val);
        },
        /**
         * serialize data with provider
         */
        serializePreference: function (val, safe) {
            try {
                return safe === true ? utils.stringify(val) : JSON.stringify(val);
            } catch (e) {
                logError(e, 'error serializing preference object');
            }
            return false;
        },
        /**
         * get a unique id for the store.
         *
         * @param prefix {string}
         **/
        toPreferenceId: function (prefix) {
            return (prefix || this.cookiePrefix || '') + '_ace';
        },
        /**
         * Return a function for persistence.apply(id,val)
         *
         * @param id {string} a unique id for the store.
         * @param val {string|null} the data. null when used for loading
         * @param provider {function|null} a default
         **/
        getPreferencePersistence: function (id, val, provider) {
            return this.persistenceFunction || provider || cookie;
        },
        /**
         * Load prefs by id (defaults to ::toPreferenceId)
         *
         * @param defaults {object|null} default data.
         * @param id {string|null} a unique id for the store.
         **/
        loadPreferences: function (defaults, id) {
            var _id = id || this.toPreferenceId(),
                persistence = this.getPreferencePersistence(),
                settings = null;
            try {
                settings = this.deserializePreference(persistence.apply(this, [_id]));
            } catch (e) {
                logError(e, 'error loading preferences, loading defaults');
                return this.getDefaultPreferences() || defaults;
            }
            return settings || defaults;
        },
        /**
         * Save prefs per id (defaults to ::toPreferenceId)
         *
         * @param prefs {object|} the data.
         * @param object {object|null} provide another context for the persistence function
         * @param clear {Boolean} dont use defaults = means it clears the store
         **/
        savePreferences: function (_prefs, object, clear, id) {
            var _id = id || this.toPreferenceId(),
                settings = _prefs || clear !== true ? _prefs : this.getDefaultPreferences(),
                persistence = this.getPreferencePersistence();

            return persistence.apply(object || this, [_id, this.serializePreference(settings),{
                expires:100
            }]);
        }
    }

    var Module = declare('xide.mixins.PreferenceMixin', null, Implementation);
    Module.dcl = dcl(null, Implementation);

    return Module;
});

},
'xace/complete_util':function(){
/**
 * Completion utilities for language workers.
 * 
 * Import using
 * 
 *     require("plugins/c9.ide.language/complete_util")
 * 
 * @class language.complete_util
 */
define(function(require, exports, module) {

var ID_REGEX = /[a-zA-Z_0-9\$]/;
var REQUIRE_ID_REGEX = /(?!["'])./;
var staticPrefix = "../static/lib";

function retrievePrecedingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset-1; i >= 0 && line; i--) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

function retrieveFollowingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset; line && i < line.length; i++) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.join("");
}

function prefixBinarySearch(items, prefix) {
    var startIndex = 0;
    var stopIndex = items.length - 1;
    var middle = Math.floor((stopIndex + startIndex) / 2);
    
    while (stopIndex > startIndex && middle >= 0 && items[middle].indexOf(prefix) !== 0) {
        if (prefix < items[middle]) {
            stopIndex = middle - 1;
        }
        else if (prefix > items[middle]) {
            startIndex = middle + 1;
        }
        middle = Math.floor((stopIndex + startIndex) / 2);
    }
    
    // Look back to make sure we haven't skipped any
    while (middle > 0 && items[middle-1].indexOf(prefix) === 0)
        middle--;
    return middle >= 0 ? middle : 0; // ensure we're not returning a negative index
}

function findCompletions(prefix, allIdentifiers) {
    allIdentifiers.sort();
    var startIdx = prefixBinarySearch(allIdentifiers, prefix);
    var matches = [];
    for (var i = startIdx; i < allIdentifiers.length && allIdentifiers[i].indexOf(prefix) === 0; i++)
        matches.push(allIdentifiers[i]);
    return matches;
}

function fetchText(path) {
    var xhr = new XMLHttpRequest();
    var _url = staticPrefix + "/" + path;
    console.error('fetch text : ' + _url);
    xhr.open('GET', _url, false);
    try {
        xhr.send();
    }
    // Likely we got a cross-script error (equivalent with a 404 in our cloud setup)
    catch (e) {
        return false;
    }
    if (xhr.status === 200 || xhr.responseText) // when loading from file:// status is always 0
        return xhr.responseText;
    else
        return false;
}

function setStaticPrefix(url) {
    //console.error('setStaticPrefix : ' + url);
    staticPrefix = url;
}

/**
 * Determine if code completion results triggered for oldLine/oldPos
 * would still be applicable for newLine/newPos
 * (assuming you would filter them for things that no longer apply).
 */
function canCompleteForChangedLine(oldLine, newLine, oldPos, newPos, identifierRegex) {
    if (oldPos.row !== newPos.row)
        return false;
        
    if (newLine.indexOf(oldLine) !== 0)
        return false;
        
    var oldPrefix = retrievePrecedingIdentifier(oldLine, oldPos.column, identifierRegex);
    var newPrefix = retrievePrecedingIdentifier(newLine, newPos.column, identifierRegex);
    return newLine.substr(0, newLine.length - newPrefix.length) === oldLine.substr(0, oldLine.length - oldPrefix.length);
}

function precededByIdentifier(line, column, postfix, ace) {
    var id = retrievePrecedingIdentifier(line, column);
    if (postfix) id += postfix;
    return id !== "" && !(id[0] >= '0' && id[0] <= '9') 
        && (inCompletableCodeContext(line, column, id, ace) 
        || isRequireJSCall(line, column, id, ace));
}

function isRequireJSCall(line, column, identifier, ace, noQuote) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return false;
    var id = identifier == null ? retrievePrecedingIdentifier(line, column, REQUIRE_ID_REGEX) : identifier;
    var LENGTH = 'require("'.length - (noQuote ? 1 : 0);
    var start = column - id.length - LENGTH;
    var substr = line.substr(start, LENGTH) + (noQuote ? '"' : '');

    return start >= 0 && substr.match(/require\(["']/)
        || line.substr(start + 1, LENGTH).match(/require\(["']/);
}

/**
 * Ensure that code completion is not triggered in comments and such.
 * Right now this only returns false when in a JavaScript regular expression.
 */
function inCompletableCodeContext(line, column, id, ace) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return true;
    var isJavaScript = true;
    var inMode = null;
    for (var i = 0; i < column; i++) {
        if (line[i] === '"' && !inMode)
            inMode = '"';
        else if (line[i] === '"' && inMode === '"' && line[i-1] !== "\\")
            inMode = null;
        else if (line[i] === "'" && !inMode)
            inMode = "'";
        else if (line[i] === "'" && inMode === "'" && line[i-1] !== "\\")
            inMode = null;
        else if (line[i] === "/" && line[i+1] === "/") {
            inMode = '//';
            i++;
        }
        else if (line[i] === "/" && line[i+1] === "*" && !inMode) {
            if (line.substr(i + 2, 6) === "global")
                continue;
            inMode = '/*';
            i++;
        }
        else if (line[i] === "*" && line[i+1] === "/" && inMode === "/*") {
            inMode = null;
            i++;
        }
        else if (line[i] === "/" && !inMode && isJavaScript)
            inMode = "/";
        else if (line[i] === "/" && inMode === "/" && line[i-1] !== "\\")
            inMode = null;
    }
    return inMode != "/";
}

/**
 * @ignore
 * @return {Boolean}
 */
exports.precededByIdentifier = precededByIdentifier;

/**
 * @ignore
 */
exports.isRequireJSCall = isRequireJSCall;

/**
 * @internal Use {@link worker_util#getPrecedingIdentifier() instead.
 */
exports.retrievePrecedingIdentifier = retrievePrecedingIdentifier;

/**
 * @internal Use {@link worker_util#getFollowingIdentifier() instead. 
 */
exports.retrieveFollowingIdentifier = retrieveFollowingIdentifier;

/**
 * @ignore
 */
exports.findCompletions = findCompletions;

/**
 * @ignore
 */
exports.fetchText = fetchText;

/**
 * @ignore
 */
exports.setStaticPrefix = setStaticPrefix;

/**
 * @ignore
 */
exports.DEFAULT_ID_REGEX = ID_REGEX;

/**
 * @ignore
 */
exports.canCompleteForChangedLine = canCompleteForChangedLine;
});
},
'dojo/promise/tracer':function(){
define([
	"../_base/lang",
	"./Promise",
	"../Evented"
], function(lang, Promise, Evented){
	"use strict";

	// module:
	//		dojo/promise/tracer

	/*=====
	return {
		// summary:
		//		Trace promise fulfillment.
		// description:
		//		Trace promise fulfillment. Calling `.trace()` or `.traceError()` on a
		//		promise enables tracing. Will emit `resolved`, `rejected` or `progress`
		//		events.

		on: function(type, listener){
			// summary:
			//		Subscribe to traces.
			// description:
			//		See `dojo/Evented#on()`.
			// type: String
			//		`resolved`, `rejected`, or `progress`
			// listener: Function
			//		The listener is passed the traced value and any arguments
			//		that were used with the `.trace()` call.
		}
	};
	=====*/

	var evented = new Evented;
	var emit = evented.emit;
	evented.emit = null;
	// Emit events asynchronously since they should not change the promise state.
	function emitAsync(args){
		setTimeout(function(){
			emit.apply(evented, args);
		}, 0);
	}

	Promise.prototype.trace = function(){
		// summary:
		//		Trace the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `trace()` is called on.

		var args = lang._toArray(arguments);
		this.then(
			function(value){ emitAsync(["resolved", value].concat(args)); },
			function(error){ emitAsync(["rejected", error].concat(args)); },
			function(update){ emitAsync(["progress", update].concat(args)); }
		);
		return this;
	};

	Promise.prototype.traceRejected = function(){
		// summary:
		//		Trace rejection of the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `traceRejected()` is called on.

		var args = lang._toArray(arguments);
		this.otherwise(function(error){
			emitAsync(["rejected", error].concat(args));
		});
		return this;
	};

	return evented;
});

},
'xfile/views/GridLight':function(){
/** @module xgrid/Base **/
define([
    "xdojo/declare",
    'xide/types',
    'xgrid/ListRenderer',
    'xfile/ThumbRenderer',
    'xgrid/TreeRenderer',
    'xgrid/GridLite',
    'xgrid/MultiRenderer',
    'xfile/FileActions',
    'xide/views/_LayoutMixin',
    'xgrid/KeyboardNavigation',
    'xgrid/Selection',
    'xide/mixins/_State',
    "xide/widgets/_Widget"
], function (declare, types,ListRenderer, ThumbRenderer, TreeRenderer,Grid, MultiRenderer,FileActions,_LayoutMixin,KeyboardNavigation,Selection,_State,_Widget) {
    
    /**
     * A grid feature
     * @class module:xgrid/GridActions
     */
    var Implementation = {

        },
        renderers = [ListRenderer,ThumbRenderer,TreeRenderer],
        multiRenderer = declare.classFactory('multiRenderer',{},renderers,MultiRenderer.Implementation);

    var GridClass = Grid.createGridClass('xfile.views.GridLight', Implementation, {
            SELECTION: {
                CLASS:Selection
            },
            KEYBOARD_SELECTION: true,
            COLUMN_HIDER: true,
            COLUMN_REORDER: false,
            CONTEXT_MENU: types.GRID_FEATURES.CONTEXT_MENU,
            CLIPBOARD:types.GRID_FEATURES.CLIPBOARD,
            ACTIONS:types.GRID_FEATURES.ACTIONS,
            ITEM_ACTIONS: {
                CLASS:FileActions
            },
            SPLIT:{
                CLASS:_LayoutMixin
            },
            KEYBOARD_NAVIGATION:{
                CLASS:KeyboardNavigation
            },
            STATE:{
                CLASS:_State
            },
            WIDGET:{
                CLASS:_Widget
            }

        },
        {
            RENDERER: multiRenderer
        },
        {
            renderers: renderers,
            selectedRenderer: TreeRenderer
        }
    );
    GridClass.DEFAULT_RENDERERS = renderers;
    GridClass.DEFAULT_MULTI_RENDERER = multiRenderer;
    return GridClass;

});
},
'xide/views/_Panel':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    'dojo/Deferred',
    'xide/_Popup',
    'xide/registry'
], function (dcl, types, utils,EventedMixin,_Widget,Deferred,_Popup,registry) {

    var Module = dcl([_Widget.dcl,EventedMixin.dcl],{
        containerClass:'',
        type: types.DIALOG_TYPE.WARNING,
        size: types.DIALOG_SIZE.SIZE_WIDE,
        titleBarClass:'',
        panel:null,
        bodyCSS:null,
        startDfd:null,
        _ready:false,
        title:'No Title',
        /**
         * jsPanelOptions
         * @link http://beta.jspanel.de/api/#defaults
         * @type {object}
         */
        options:null,
        getDefaultOptions:function(mixin){
            var self = this;
            var options = {
                "contentSize": {
                    width: '600px',
                    height: '500px'
                },
                footerToolbar:[
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-danger btn-sm",
                        btntext:  " Cancel",
                        callback: function( event ){
                            event.data.close();
                            self.onCancel();
                        }
                    },
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-primary btn-sm",
                        btntext:  " Ok",
                        callback: function( event ){
                            self.onOk();
                            event.data.close();
                        }
                    }
                ]
            };
            utils.mixin(options,mixin);
            return options;
        },
        getInstance:function(args){
            if(this.panel){
                return this.panel;
            }
            _Popup.nextZ(3);
            var self = this;
            this.panel = $.jsPanel(utils.mixin({
                zi:_Popup.nextZ(),
                position: {
                    left: 200,
                    top: 100
                },
                title: self.title || 'jsPanel theme info',
                theme: self.theme || 'bootstrap-default',
                onmaximized:function(){
                    self.resize();
                },
                onnormalized:function(){
                    self.resize();
                },
                onbeforeclose:function(){
                    self.destroy(false);
                },
                callback: function (panel) {

                    self.domNode = this.content[0];

                    var thiz = this;

                    self.onshown(this,this.content[0]).then(function(){

                        thiz.content.addClass(self.containerClass);
                        thiz.content.css('tabIndex',1);
                        thiz.header.addClass(self.type);
                        thiz.footer.addClass('modal-footer');
                        var newZ = _Popup.nextZ();
                        panel.css("z-index", newZ);
                        panel.attr('tabIndex',1);
                        panel.keyup(function (event) {
                            if(event.which === 27){
                                self.destroy(true);
                            }
                        });
                        panel.focus();
                    });
                }
            },args));
            this.panel.on("resize",function(){
                self.resize();
            });
            return this.panel;
        },
        onshown:function(panelInstance,content){
            var self = this,
                head = new Deferred();

            if(this.onShow){
                var result = this.onShow(panelInstance,content,this);
                function ready(what){
                    self.startDfd.resolve(what);
                    self._ready = true;
                    self.resize();
                    head.resolve(what);
                }
                if(result && result.then){
                    result.then(ready);
                }else if(_.isArray(result)){
                    _.each(result,function(widget){
                        self.add(widget,null,false);
                    });
                    ready(result);
                }
            }
            return head;
        },
        onReady:function(){
            var self = this;
            setTimeout(function(){
                self._ready = true;
            },100);
        },
        destroy:function(destroyPanel){
            try {
                destroyPanel !== false && this.panel && this.panel.close();
                registry.remove(this.panel.id);
                //destroy
                if(this.headDfd){
                    this.headDfd.resolve(false);
                }
            }catch(e){
                logError(e,'panel close');
            }
        },
        show:function(options){
            var self=this;
            this.headDfd = new Deferred();
            if(!this.startDfd){
                this.startDfd = new Deferred();
                this.startDfd.then(function(){
                    self.onReady();
                });
            }

            this.panel = this.getInstance(options || this.options);
            //this.panel.id = this.panel[0].id;
            //registry.add(this.panel);
            return this.headDfd;
        },
        constructor:function(args){
            args = args || {};
            this.options = args.options || this.options || this.getDefaultOptions();
            utils.mixin(this,args);
        },
        onOk:function(){
            this.headDfd.resolve(true);
        },
        onCancel:function(){
            this.headDfd.resolve(false);
        }
    });


    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");

    return Module;

});
},
'xdocker/Docker2':function(){
/** @module xDocker/Docker2 */
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'wcDocker/docker',
    'xdocker/Panel2',
    'xdocker/Frame2',
    'xdocker/Splitter2',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'wcDocker/types',
    'wcDocker/base',
    'xaction/ActionProvider',
    'xide/widgets/_Widget',
    'xide/widgets/ContextMenu',
    'require'
], function (dcl,types,utils,wcDocker,Panel2,Frame2,Splitter2,EventedMixin,registry,dTypes,base,ActionProvider,_CWidget,ContextMenu,require) {
    /**
     * @class module:xDocker/Docker2
     * @extends module:wcDocker/docker
     */
    var Module = dcl([wcDocker,base,ActionProvider.dcl,_CWidget.dcl,EventedMixin.dcl],{
        isResizing:false,
        _last:null,
        _lastResize:null,
        _needResize:false,
        _lastResizeTimer:null,
        _declaredClass:'xdocker.Docker2',
        __eventHandles:[],
        contextMenu:null,
        contextMenuEventTarget:null,
        contextMenuPanelId:null,
        setupActions:function(_mixin){
            this.__on(this._root.$container,'contextmenu', '.wcPanelTab', function(e){
                self.contextMenuEventTarget  = e.target;
                self.contextMenuPanelId = e.target.parentNode ?  e.target.parentNode.id : null;
            });

            var self = this,
                //default action mixin
                mixin = {
                    addPermission: true
                },
                defaultProps = {
                    group:'Misc',
                    tab:'View',
                    mixin:_mixin || mixin
                },
                _actions = [],
                action = function(label,command,icon){
                    return self.createAction(_.extend({
                        label:label,
                        command:command,
                        icon:icon
                    },defaultProps));
                },
                actions = this.addActions([
                    action('Close','View/Close','fa-close'),
                    action('Close others','View/Close Others','fa-close'),
                    action('Close all in group','View/Close all group','fa-close'),
                    action('Split Horizontal','View/Split Horizontal','fa-columns'),
                    action('Split Vertical','View/Split Vertical','fa-columns')]
                ),
                node = this._root.$container[0],
                contextMenu = new ContextMenu({
                    owner:this,
                    delegate:this,
                    limitTo:'wcPanelTab',
                    openTarget:node
                },node);

            contextMenu.init({preventDoubleContext: false});
            contextMenu.setActionEmitter(this,types.EVENTS.ON_VIEW_SHOW,this);
            this.contextMenu = contextMenu;
            this.add(contextMenu,null,false);

            return actions;
        },
        runAction:function(action,type,event){

            var DOCKER_TYPES = types.DOCKER,
                _panel = this.contextMenuEventTarget ? this.__panel(this.contextMenuEventTarget) : null,
                self = this,
                frame = _panel ? _panel.getFrame(): null,
                panels = frame ? frame.panels() : null;

            if(action.command ==='View/Close') {
                if (_panel) {
                    this.removePanel(_panel);
                }
            }

            if(action.command ==='View/Close all group' && _panel) {
                if(frame){
                    var toRemove = [];
                    _.each(panels,function(panel){
                        if(panel && panel._moveable && panel._closeable){
                            toRemove.push(panel);
                        }
                    });
                    _.each(toRemove,function(panel){
                        self.removePanel(panel);
                    })
                }

            }
            if(action.command ==='View/Close Others' && _panel) {
                frame && _.each(panels,function(panel){
                        if(panel && panel!=_panel  && panel._moveable && panel._closeable){
                            self.removePanel(panel);
                        }
                    });

                _panel.select();
            }

            function split(direction){
                var otherPanel = _panel.next(-1) || _panel.next(1);
                if(otherPanel && _panel !=otherPanel){

                    self.movePanel(otherPanel,direction == DOCKER_TYPES.ORIENTATION.HORIZONTAL ?
                        DOCKER_TYPES.DOCK.BOTTOM : DOCKER_TYPES.DOCK.RIGHT,_panel,direction);

                    var splitter = otherPanel.getSplitter();
                    splitter && splitter.pos(0.5);
                }
            }

            if(action.command ==='View/Split Horizontal' && _panel) {
                split(DOCKER_TYPES.ORIENTATION.HORIZONTAL);
            }
            if(action.command ==='View/Split Vertical' && _panel) {
                split(DOCKER_TYPES.ORIENTATION.VERTICAL);
            }
        },
        __panel:function(el){

            var panels = this.getPanels();
            var frame = null,
                self = this;

            _.each(this._frameList,function(_frame){
                if($.contains(_frame.$container[0],el)){
                    frame = _frame;
                }
            });

            var id = self.contextMenuPanelId;
            this.contextMenuEventTarget = null;
            this.contextMenuPanelId = null;
            if(frame && id!==null){
                var _panel = frame.panel(id);
                if(_panel){
                    return _panel;
                }
            }
        },
        /**********************************************************************/
        allPanels:function(){
            var result = [];
            _.each(this._frameList,function(frame){
                _.each(frame._panelList,function(panel){
                    result.push(panel);
                });
            });
            return result;
        },
        destroy:function(){
            registry.remove(this.id);
            this.__destroy();
        },
        /**
         * Collect wcDocker's body event handles
         * @param element {HTMLElement}
         * @param type {string} event type
         * @param selector {string|null|function}
         * @param handler {function|null}
         * @private
         */
        __on:function(element,type,selector,handler){

            if(typeof selector =='function' && !handler){
                //no selector given, swap arg[3] with arg[2]
                handler = selector;
                selector = null;
            }

            element.on(type,selector,handler);

            this.__eventHandles.push({
                element:element,
                type:type,
                selector:selector,
                handler:handler
            });
        },
        __destroy:function(){
            var self = this;
            //docker handles
            _.each(self.__eventHandles,function(handle){
                handle && handle.element && handle.element.off(handle.type,handle.selector,handle.handler);
                self.__eventHandles.remove(handle);
            });

            //xide handles
            _.each(self._events,function(handles,type){
                _.each(handles,function(handler){
                    self.off(type,handler);
                });
            });

            self.clear();
            delete self._events;
            delete self.__eventHandles;
            self._updateId && clearTimeout(self._updateId);
        },
        resize: function (force,noob,why) {
            if(why==='deselected'){
                return;
            }
            var self = this;
            function _resize(){
                if(self.$container) {
                    var h = self.$container.height();
                    var w = self.$container.width();
                    if(h<110 || w<110){
                        return;
                    }
                }
                self._dirty = true;
                self._root && self._root.__update(true);
                _.invoke(self._floatingList,'__update');
            }
            return this.debounce('resize',_resize.bind(this),100,null);
        },
        /**
         * Helper
         * @returns {xdocker/Panel[]}
         */
        getPanels:function(){
            var result = [];
            _.each(this._frameList,function(frame){
                _.each(frame._panelList,function(panel){
                    result.push(panel);
                });
            });
            return result;
        },
        /**
         * Returns a default panel
         * @returns {xdocker/Panel}
         */
        getDefaultPanel:function(){
            return _.find(this.getPanels(),{
                isDefault:true
            });
        },
        /**
         * Std API
         * @todo convert to addChild
         * @param mixed {string|object}
         * @param options {object}
         * @param options.title {string|null}
         * @param options.tabOrientation {string|null}
         * @param options.location {string|null}
         * @param options.select {boolean}
         * @param options.target {object}
         * @returns {*}
         */
        addTab: function (mixed, options) {

            var panel = null,
                thiz = this;

            options = options || {};
            mixed = mixed || 'DefaultTab';

            /**
             * Complete options to default
             * @param options
             */
            function completeOptions(options) {

                if (!('tabOrientation' in options)) {
                    options.tabOrientation = types.DOCKER.TAB.TOP
                }

                if (!('location' in options)) {
                    options.location = types.DOCKER.DOCK.STACKED;
                }

                if (!('target' in options)) {
                    options.target = thiz.getDefaultPanel();
                }

                if (!('select' in options)) {
                    options.select = true;
                }

                if (!('title' in options)) {
                    options.title = ' ';
                }
            }
            completeOptions(options);

            if (_.isString(mixed)) {
                panel = this.addPanel(mixed, options.location, options.target, options);
            } else if (_.isObject(mixed)) {
                panel = mixed;
            }
            function applyOptions(who, what) {
                for (var option in what) {
                    if (_.isFunction(who[option])) {
                        who[option](what[option]);
                    }
                }
            }
            applyOptions(panel, options);
            if (options.select === true) {
                panel.select();
            }
            return panel;
        }
    });
    /**
     * Registration of a panel type
     * @todo typos & API
     * @static
     * @param label
     * @param iconClass
     * @param closable
     * @param collapsible
     * @param movable
     * @param onCreate
     * @returns {{faicon: *, closeable: *, title: *, onCreate: Function}}
     */
    Module.defaultPaneType = function (label, iconClass, closable, collapsible, moveable, onCreate,isPrivate) {

        return {
            isPrivate: isPrivate!==null ? isPrivate : false,
            faicon: iconClass,
            closeable: closable,
            title: label,
            moveable:moveable,
            onCreate: function (panel, options) {

                var docker = panel.docker();

                utils.mixin(panel._options,options);

                panel.on(wcDocker.EVENT.ATTACHED,function(){
                    docker._emit(wcDocker.EVENT.ATTACHED,panel);
                });

                panel.on(wcDocker.EVENT.DETACHED,function(){
                    docker._emit(wcDocker.EVENT.DETACHED,panel);
                });

                panel.on(wcDocker.EVENT.CLOSED,function(){
                    docker._emit(wcDocker.EVENT.CLOSED,panel);
                });

                if (closable !== null) {
                    panel.closeable(closable);
                }

                if (collapsible !== null && panel.collapsible) {
                    panel.collapsible(collapsible);
                }

                if (moveable !== null) {
                    panel.moveable(moveable);
                }

                if (options) {
                    panel.title(options.title);
                    if (options.closeable) {
                        panel.closeable(options.closeable);
                    }
                }

                var parent = $('<div style="height: 100%;width: 100%;overflow: hidden;" class="panelParent"/>');
                panel.layout().addItem(parent).stretch('100%', '100%');
                panel.containerNode = parent[0];
                utils.mixin(panel,options.mixin);

                function resize(panel,parent,why){
                    var extraH = 0;

                    var resizeToChildren = panel.resizeToChildren;
                    panel.onResize && panel.onResize();
                    if(resizeToChildren){
                        var totalHeight = utils.getHeight(panel._findWidgets()),
                            panelParent = panel._parent.$container;

                        extraH = panelParent.outerHeight() - panelParent.height();
                        if(extraH){
                            totalHeight+=extraH;
                        }
                        parent.css('width', panel._actualSize.x + 'px');
                        panel.set('height',totalHeight);

                    }else {
                        parent.css('height', panel._actualSize.y + 'px');
                        parent.css('width', panel._actualSize.x + 'px');
                        //transfer size and resize on widgets
                        _.each(panel.containerNode.children, function (child) {
                            if (child.id) {

                                var _widget = registry.byId(child.id);
                                var doResize = true;
                                if (_widget && _widget.resizeToParent === false) {
                                    doResize = false;
                                }

                                if (doResize) {
                                    //update
                                    $(child).css('height', panel._actualSize.y - extraH + 'px');
                                    $(child).css('width', panel._actualSize.x + 'px');
                                }
                                if (_widget) {
                                    _widget.resize && _widget.resize(null, null, why);
                                } else {
                                    console.warn('cant get widget : ' + child.id);
                                }
                            }
                        });
                    }
                }


                function select(selected,reason){
                    //console.log(reason + ' : select ' +panel.title() +' selected:'+ selected + ' visible:' + panel.isVisible() + ' p#selected:' + panel.selected + ' __isVisible'+panel.isVisible());

                    if(panel.selected && selected){
                        return true;
                    }
                    panel.selected = selected;
                    selected && (docker._lastSelected = panel);
                    resize(panel,parent,selected ?  'selected' : 'deselected');

                    var apiMethod = selected ? 'onShow'  : 'onHide';
                    panel[apiMethod] && panel[apiMethod]();




                    //tell widgets
                    _.each(panel._findWidgets(), function (widget) {
                        if(!widget){
                            return;
                        }
                        if(selected){
                            if(!widget._started){
                                widget.startup && widget.startup();
                            }
                        }
                        //call std API
                        if (widget[apiMethod]) {
                            widget[apiMethod]();
                        }
                        //forward
                        if (widget._emit) {
                            widget._emit(selected ? types.EVENTS.ON_VIEW_SHOW :types.EVENTS.ON_VIEW_HIDE , widget);
                        }

                        //forward
                        if (widget.setFocused) {
                            widget.setFocused(selected);
                        }
                    });
                }

                panel.on(types.DOCKER.EVENT.VISIBILITY_CHANGED, function (visible) {
                    panel.silent!==true && select(visible,'vis changed');
                });
                panel._on(types.DOCKER.EVENT.SELECT, function (what) {
                    panel.silent!==true && select(true,'select');

                });

                panel._on(types.DOCKER.EVENT.MOVE_STARTED, function () {
                    docker.trigger(types.DOCKER.EVENT.MOVE_STARTED,panel);
                });

                panel._on(types.DOCKER.EVENT.MOVE_ENDED, function () {
                    docker.trigger(types.DOCKER.EVENT.MOVE_ENDED,panel);
                });

                panel.on(types.DOCKER.EVENT.SAVE_LAYOUT, function (customData) {


                    panel.onSaveLayout({
                        data:customData,
                        panel:panel
                    });

                    if(!customData.widgets){
                        customData.widgets = [];
                    }

                    _.each(panel._findWidgets(),function(w){
                        if(!w){
                            console.warn('SAVE_LAYOUT : invalid widget');
                            return;
                        }
                        w._emit && w._emit(types.EVENTS.SAVE_LAYOUT,{
                            panel:panel,
                            data:customData
                        });
                        w.onSaveLayout && w.onSaveLayout({
                            data:customData,
                            owner:panel
                        })
                    });
                });
                panel.on(types.DOCKER.EVENT.RESTORE_LAYOUT, function (customData) {
                    
                    var eventData = {
                        data:customData,
                        panel:panel
                    };
                    panel.onRestoreLayout(eventData);
                    //console.log('restore layout');
                    //docker.trigger('restorePanel',eventData);
                });

                panel.on(types.DOCKER.EVENT.RESIZE_STARTED, function () {
                    panel.onResizeBegin(arguments);
                    docker.trigger(types.DOCKER.EVENT.BEGIN_RESIZE,panel);
                });
                panel.on(types.DOCKER.EVENT.RESIZE_ENDED, function () {
                    panel.onResizeEnd(arguments);
                    resize(panel,parent);
                    docker.trigger(types.DOCKER.EVENT.END_RESIZE,panel);
                });
                panel.on(types.DOCKER.EVENT.RESIZED, function () {
                    resize(panel,parent);
                });
                utils.mixin(panel,options.mixin);

                if (onCreate) {
                    onCreate(panel);
                }
            }
        }
    };
    /**
     * Register default panel types on docker
     * @static
     * @param docker
     */
    Module.registerDefaultTypes = function(docker){
        docker.registerPanelType('DefaultFixed',Module.defaultPaneType('','',false,false,true,null,true));
        docker.registerPanelType('DefaultTab',Module.defaultPaneType('','',true,false,true,null,true));
        docker.registerPanelType('Collapsible',Module.defaultPaneType('','',false,true,true,null,true));
    };

    /**
     * Creates a default docker
     * @static
     * @param container
     * @param options
     */
    Module.createDefault=function(container,options){
        require({cacheBust: null});
        options = options || {};

        //get or create new docker variant
        var _class = Module;
        options.extension && ( _class = dcl([Module,options.extension],{}));
        var docker = new _class($(container),utils.mixin({
            allowCollapse: true,
            responseRate: 100,
            allowContextMenu: false,
            themePath: require.toUrl('xdocker') + '/Themes/',
            theme: 'transparent2',
            wcPanelClass:Panel2,
            wcFrameClass:Frame2,
            wcSplitterClass:Splitter2
        },options || {}));

        Module.registerDefaultTypes(docker);

        function hideFrames(hide){
            var frame = $('#xIFrames');
            frame.css('display', hide ? 'none' : 'block');
            frame.children().css('display',hide ? 'none' : 'block');
        }

        docker.on(wcDocker.EVENT.BEGIN_DOCK,_.partial(hideFrames,true));
        docker.on(wcDocker.EVENT.END_DOCK,_.partial(hideFrames,false));
        docker.on(wcDocker.EVENT.RESIZE_STARTED,_.partial(hideFrames,true));
        docker.on(wcDocker.EVENT.RESIZED,_.partial(hideFrames,false));
        if(!docker.id){
            docker.id = registry.getUniqueId(docker._declaredClass.replace(/\./g, "_"));
            docker.$container.attr('id',docker.id);
        }
        registry.add(docker);
        return docker;
    };
    return Module;
});
},
'xaction/Toolbar':function(){
/** @module xaction/Toolbar **/
define([
    'dcl/dcl',
    "xdojo/declare",
    'xide/utils',
    'xide/types',
    'xide/widgets/ActionToolbar',
    'xide/widgets/_Widget'
], function (dcl, declare, utils, types, ActionToolbar, _Widget) {
    /**
     * An action oriented Toolbar
     * @class module:xaction/Toolbar
     */
    var Implementation = {
        _toolbar: null,
        toolbarInitiallyHidden: false,
        toolbarArgs:null,
        runAction: function (action) {
            if (action.command === types.ACTION.TOOLBAR) {
                this.showToolbar(this._toolbar == null, null, null, this);
            }
            return this.inherited(arguments);
        },
        getToolbar: function () {
            return this._toolbar;
        },
        showToolbar: function (show, toolbarClass, where, emitter) {
            !show && (show = this._toolbar == null);
            if (!this._toolbar) {
                
                var toolbar = this.add(toolbarClass || ActionToolbar, utils.mixin({
                    style: 'height:auto;width:100%'
                },this.toolbarArgs), where || this.header, true);

                //limit toolbar with to our header for now
                utils.resizeTo(toolbar,this.header,false,true);

                toolbar.addActionEmitter(emitter || this);
                toolbar.setActionEmitter(emitter || this);
                //now stretch header to toolbar
                utils.resizeTo(this.header,toolbar,true,false);

                this._toolbar = toolbar;
            }
            if (!show && this._toolbar) {
                utils.destroy(this._toolbar, true, this);
            }
            this.resize();
        },
        startup: function () {
            var TOOLBAR = types.ACTION.TOOLBAR,
                hasToolbar = _.contains(this.permissions, TOOLBAR);
            hasToolbar && this.showToolbar(hasToolbar, null, null, this);

            var self = this,
                node = self.domNode.parentNode;
            this._on('onAddActions', function (evt) {
                //be careful, it could be here already
                !evt.store.getSync(TOOLBAR) && evt.actions.push(self.createAction('Toolbar', TOOLBAR, types.ACTION_ICON.TOOLBAR, ['ctrl b'], 'View', 'Show', 'item|view', null, null, null, null, null, evt.permissions, node, self));
            });
        }
    };

    //package via declare
    var _class = declare('xaction/Toolbar', _Widget, Implementation);
    _class.Implementation = Implementation;
    _class.dcl = dcl([_Widget.dcl], Implementation);
    return _class;
});
},
'xide/$':function(){
/** @module xide/$ **/
define([],function(){
    /**
     * temp. wanna be shim for jQuery
     */
    if(typeof $ !=="undefined"){
        return $;
    }
});

},
'xgrid/TreeRenderer':function(){
/** @module xgrid/TreeRenderer **/
define([
    "xdojo/declare",
    './Renderer',
    'dgrid/Tree',
    "dojo/keys",
    "xide/utils",
    "dojo/on"
], function (declare,Renderer,Tree,keys,utils,on) {


    function KEYBOARD_HANDLER(evt){

        this.onTreeKey(evt);
        var thiz = this;
        if(thiz.isThumbGrid){
            return;
        }
        if(evt.keyCode==keys.LEFT_ARROW ||evt.keyCode==keys.RIGHT_ARROW || evt.keyCode==keys.HOME || evt.keyCode==keys.END){
        }else{
            return;
        }
        var target = evt.target;
        if(target){
            if(
                target.className.indexOf('InputInner') != -1 ||
                target.className.indexOf('input') != -1 ||
                evt.target.type ==='text'
            )
                return;
        }

        var row = this.row(evt);
        if(!row || !row.data){
            return;
        }
        var data = row.data,
            isExpanded = this._isExpanded(data),
            store = this.collection,
            storeItem = store.getSync(data[store.idProperty]);

        //old back compat: var children = data.getChildren ? data.getChildren() :  storeItem && storeItem.children ? null : store.children ? store.children(storeItem) : null;
        var children = data.getChildren ? data.getChildren() :  storeItem && storeItem.children ? storeItem.children : null;

        //xideve hack
        var wasStoreBased = false;
        if(children==null && store.getChildrenSync && storeItem){
            children = store.getChildrenSync(storeItem);
            if(children && children.length) {
                wasStoreBased = true;
            }else{
                children = null;
            }
        }

        var isFolder = storeItem ? (storeItem.isDir || storeItem.directory) : false;
        if(!isFolder && wasStoreBased && children){
            isFolder = true;
        }
        //xideve hack end


        var firstChild = children ? children[0] : false,
            focused = this._focusedNode,
            last = focused ? this.down(focused, children ? children.length : 0, true) :null,
            loaded = ( storeItem._EX === true || storeItem._EX == null ),
            selection = this.getSelection ? this.getSelection () : [storeItem],
            down = this.down(focused, -1, true),
            up = this.down(focused, 1, true),
            defaultSelectArgs = {
                focus: true,
                append: false,
                delay: 1
            };

        if(firstChild && firstChild._reference){
            var _b = store.getSync(firstChild._reference);
            if(_b){
                firstChild = _b;
            }
        }
        if(evt.keyCode==keys.END) {
            if(isExpanded && isFolder && last && last.element !==focused){
                this.select(last, null, true, defaultSelectArgs);
                return;
            }
        }

        function expand(what,expand){
            _.each(what, function (item) {
                var _row  = thiz.row(item);
                if(_row && _row.element) {
                    thiz.expand(_row, expand, true);
                }
            });
        }

        if(evt.keyCode==keys.LEFT_ARROW){
            evt.preventDefault();
            if (data[store.parentField]){
                var item = row.data;
                if (!isExpanded) {
                    var parent = store.getSync(item[store.parentField]);
                    var parentRow = parent ? this.row(parent) : null;
                    //we select the parent only if its rendered at all
                    if (parent && parentRow.element ) {
                        return this.select([parent], null, true, defaultSelectArgs);
                    }else{
                        if(down) {
                            return this.select(down, null, true, defaultSelectArgs);
                        }else {
                            on.emit(this.contentNode, "keydown", {keyCode: 36, force: true});
                        }
                    }
                }
            }
            if (row) {
                if(isExpanded) {
                    expand(selection,false);
                }else{
                    this.select(down, null, true, defaultSelectArgs);
                }
            }
        }

        if(evt.keyCode==keys.RIGHT_ARROW){
            evt.preventDefault();
            // empty folder:
            if(isFolder && loaded && isExpanded && !firstChild){
                //go to next
                if(up) {
                    return this.select(up, null, true, defaultSelectArgs);
                }
            }

            if(loaded && isExpanded){
                firstChild && this.select([firstChild], null, true, defaultSelectArgs);
            }else{
                //has children or not loaded yet
                if(firstChild || !loaded || isFolder) {
                    expand(selection,true);
                }else{
                    //case on an cell without no children: select
                    up && this.select(up, null, true, defaultSelectArgs);
                }
            }
        }
    }
    /**
     *
     * @class module:xgrid/TreeRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        _getLabel:function(){ return "Tree"; },
        _getIcon:function(){ return "fa-tree"; },
        deactivateRenderer:function(renderer){},
        activateRenderer:function(){
            this._showHeader(true);
        },
        __getParent:function(item){
            if(item && item.getParent){
                var _parent = item.getParent();
                if(_parent){
                    var row = this.row(_parent);
                    if(row.element){
                        return this.__getParent(_parent);
                    }else{
                        return _parent || item;
                    }
                }
            }
            return item;
        },
        /**
         * @TODO: move to xfile
         */
        getCurrentFolder:function(){
            return this.__getParent(this.getRows()[0]);
        },
        _isExpanded: function (item) {
            return !!this._expanded[this.row(item).id];
        },
        onTreeKey:function(){
            this.inherited(arguments);
        },
        startup:function(){
            if(this._started){
                return;
            }
            var res = this.inherited(arguments);
            this.on("keydown",KEYBOARD_HANDLER.bind(this));
            return res;
        }
    };

    //package via declare
    var Module = declare('xgrid.TreeRenderer',[Renderer,Tree],Implementation);
    Module.Implementation = Implementation;
    Module.KEYBOARD_HANDLER = KEYBOARD_HANDLER;
    return Module;
});
},
'xfile/FileActions':function(){
/** module:xfile/FileActions **/
define([
    'dcl/dcl',
    'xdojo/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/factory',
    'xide/model/Path',
    'xaction/DefaultActions',
    'xide/editor/Registry',
    'xide/editor/Default',
    'dojo/aspect',
    'xfile/views/FileOperationDialog',
    'xfile/views/FilePreview',
    'xide/views/_CIDialog',
    "xide/views/_Dialog",
    "xide/views/_PanelDialog",
    'xfile/views/FilePicker'
], function (dcl, declare, has,Deferred, utils, types, factory, Path, DefaultActions, Registry, Default, aspect, FileOperationDialog, FilePreview, _CIDialog, _Dialog, _PanelDialog,FilePicker) {

    var ACTION = types.ACTION;
    var _debug = false;
    var Module = null;

    function defaultCopyOptions() {
        /***
         * gather options
         */
        var result = {
                includes: ['*', '.*'],
                excludes: [],
                mode: 1501
            },
            flags = 4;

        switch (flags) {

            case 1 << 2:
            {
                result.mode = 1502;//all
                break;
            }
            case 1 << 4:
            {
                result.mode = 1501;//none
                break;
            }
            case 1 << 8:
            {
                result.mode = 1504;//newer
                break;
            }
            case 1 << 16:
            {
                result.mode = 1503;//size
                break;
            }
        }

        return result;
    }

    /**
     *
     * @param owner
     * @param inValue
     * @param callback
     * @param title
     * @param permissions
     * @param pickerOptions
     * @param dfd
     * @param Module
     * @returns {*}
     */
    function createFilePicker(owner,inValue,callback,title,permissions,pickerOptions,dfd,Module){
        var dlg = new _PanelDialog({
            size: types.DIALOG_SIZE.SIZE_NORMAL,
            bodyCSS: {
                'height': 'auto',
                'min-height': '500px',
                'padding': '8px',
                'margin-right': '16px'
            },
            picker: null,
            title:title,
            onOk: function () {
                var selected = this.picker._selection;
                if (selected && selected[0]) {
                    callback(selected[0]);
                    dfd && dfd.resolve(selected[0],selected,this.picker);
                }
            },
            onShow:function(panel,contentNode){
                var picker = utils.addWidget(FilePicker,utils.mixin({
                    ctx: owner.ctx,
                    owner: owner,
                    selection: inValue || './AA/xfile_last/data/su.jpg',
                    resizeToParent: true,
                    storeOptionsMixin: {
                        "includeList": "*,.*",
                        "excludeList": ""
                    },
                    Module: Module,
                    permissions: permissions||utils.clone(types.DEFAULT_FILE_GRID_PERMISSIONS)
                },pickerOptions),this,contentNode,true);

                this.picker = picker;
                this.add(picker);
                this.startDfd.resolve();
                return [this.picker];

            }
        });
        dlg.show();
        return dfd;
    }
    
    function openFilePicker(dlg, fileWidget) {

        var inValue = fileWidget.userData.value || './AA/xfile_last/data/su.jpg';
        var dfd = new Deferred(),
            self = this;

        var result = new _PanelDialog({
            size: types.DIALOG_SIZE.SIZE_NORMAL,
            bodyCSS: {
                'height': 'auto',
                'min-height': '500px',
                'padding': '8px',
                'margin-right': '16px'
            },
            picker: null,
            title:fileWidget.title,
            onOk: function () {
                var selected = this.picker._selection;
                if (selected && selected[0]) {
                    fileWidget.set('value', selected[0].path);
                    dfd.resolve(selected[0].path);
                    result.value = selected[0].path;
                }

            },
            onShow:function(panel,contentNode){
                var picker = utils.addWidget(FilePicker,{
                    ctx: self.ctx,
                    owner: self,
                    selection: inValue || './AA/xfile_last/data/su.jpg',
                    resizeToParent: true,
                    mount:self.collection.mount,
                    storeOptionsMixin: {
                        "includeList": "*,.*",
                        "excludeList": ""
                    },
                    Module: self.Module,
                    permissions: utils.clone(self.Module.DEFAULT_PERMISSIONS)
                },this,contentNode,true);

                this.picker = picker;
                this.add(picker,null,false);
                this.startDfd.resolve();
                return [this.picker];

            }
        });
        result.show();
        return dfd;

    }

    /**
     * XFile actions
     * @class module:xfile/FileActions
     * @augments module:xfile/views/FileGrid
     */
    var Implementation = {
        /**
         * mkdir version:
         *
         *    1. open dialog with input box (value = currentItem)
         *
         * @TODO : remove leaks
         */
        touch: function () {
            var dfd = new Deferred();
            try {
                var self = this,
                    currentItem = this.getSelectedItem(),
                    currentFolder = this.getCurrentFolder(),
                    startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                    collection = this.collection;

                var CIS = {
                        inputs: [
                            utils.createCI('Name', 13, startValue, {
                                widget: {
                                    instant: true,
                                    validator: function (value) {
                                        if(currentFolder) {
                                            return collection.getSync(currentFolder.path + '/' + value) == null &&
                                                value.length > 0;
                                        }else{
                                            return true;
                                        }
                                    }
                                }
                            })
                        ]
                    },
                    defaultDfdArgs = {
                        select: currentItem,
                        focus: true,
                        append: false
                    };

                var dlg = new _CIDialog({
                    cis: CIS,
                    title: 'Create new File',
                    ctx: this.ctx,
                    size: types.DIALOG_SIZE.SIZE_SMALL,
                    bodyCSS: {
                        'height': 'auto',
                        'min-height': '80px'

                    },
                    _onError: function (title, suffix, message) {
                        title = title || this.title;
                        message = message || this.notificationMessage;
                        message && message.update({
                            message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                            type: 'error',
                            actions: false,
                            duration: 15000
                        });
                        this.onError && this.onError(suffix);
                    },
                    onCancel: function () {
                        dfd.resolve();
                    },
                    onOk: function () {
                        var val = this.getField('name');
                        if (val == null) {
                            dfd.resolve(defaultDfdArgs);
                            return;
                        }
                        var currentFolder = self.getCurrentFolder() || {path:'.'},
                            newFolder = currentFolder.path + '/' + val;

                        var fileDfd = self.ctx.getFileManager().mkfile(collection.mount, newFolder, {
                            checkErrors: true,
                            returnProm: false
                        });

                        // call server::mkdir, then reload, then resolve dfd with new newFolder as selection
                        fileDfd.then(function (data) {
                            self.runAction(ACTION.RELOAD).then(function () {
                                collection.getSync(newFolder) && dfd.resolve({
                                    select: newFolder,
                                    append: false,
                                    focus: true
                                });
                            });
                        }, function (e) {
                            dfd.resolve(defaultDfdArgs);
                            logError(e, 'error creating directory');
                        });
                    }
                });
                dlg.show();
            } catch (e) {
                logError(e, 'error creating dialog');
            }
            return dfd;

        },
        newTabArgs: null,
        openInOS:function(item){
            var thiz = this,
                ctx = thiz.ctx,
                resourceManager = ctx.getResourceManager(),
                vfsConfig = resourceManager.getVariable('VFS_CONFIG') || {};

            var mount = item.mount.replace('/','');
            if(!vfsConfig[mount]){
                console.error('open in os failed: have no VFS config for ' + mount);
                return;
            }

            var _require = window['eRequire'];
            if(!_require){
                console.error('have no electron');
            }


            var os = _require('os');
            var shell = _require('electron').shell;
            var path = _require("path");

            mount = vfsConfig[mount];
            mount = utils.replaceAll(' ','',mount);

            var itemPath = item.path.replace('./','/');
            itemPath = utils.replaceAll('/',path.sep,itemPath);
            var realPath = path.resolve(mount + path.sep + itemPath);
            realPath = utils.replaceAll(' ','',realPath);
            if(os.platform()!=='win32') {
                shell.openItem(realPath);
            }else{
                shell.openItem('file:///' + realPath);
            }

            console.log('open in system ' + mount +':'+ itemPath + ' = ' + realPath,vfsConfig);

        },
        getFileActions: function (permissions) {
            permissions = permissions || this.permissions;
            var result = [],
                ACTION = types.ACTION,
                ACTION_ICON = types.ACTION_ICON,
                VISIBILITY = types.ACTION_VISIBILITY,
                thiz = this,
                ctx = thiz.ctx,
                container = thiz.domNode,
                resourceManager = ctx.getResourceManager(),
                vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') : {},//possibly resourceManager not there in some builds
                actionStore = thiz.getActionStore();

            ///////////////////////////////////////////////////
            //
            //  misc
            //
            ///////////////////////////////////////////////////
            result.push(thiz.createAction({
                label: 'Go up',
                command: ACTION.GO_UP,
                icon: ACTION_ICON.GO_UP,
                tab: 'Home',
                group: 'Navigation',
                keycombo: ['backspace'],
                mixin:{
                    quick:true
                }
            }));

            result.push(thiz.createAction({
                label: 'Copy',
                command: ACTION.COPY,
                icon: 'fa-paste',
                tab: 'Home',
                group: 'Organize',
                keycombo: ['f5'],
                shouldDisable: function () {
                    return thiz.getSelectedItem() == null;
                }
            }));

            result.push(thiz.createAction({
                label: 'Close',
                command: ACTION.CLOSE,
                icon: 'fa-close',
                tab: 'View',
                group: 'Organize',
                keycombo: ['ctrl 0']
            }));

            result.push(thiz.createAction({
                label: 'Move',
                command: ACTION.MOVE,
                icon: 'fa-long-arrow-right',
                tab: 'Home',
                group: 'Organize',
                keycombo: ['f6'],
                shouldDisable: function () {
                    return thiz.getSelectedItem() == null;
                }
            }));

            if( (location.href.indexOf('electron=true') || has('electronx') && has('electron')) && vfsConfig){
                /*
                return;
                result.push(thiz.createAction({
                    label: 'Open with System',
                    command: 'File/OpenInOS',
                    icon: 'fa-share',
                    tab: 'Home',
                    group: 'Open',
                    keycombo: ['shift f4'],
                    mixin: {
                        addPermission: true
                    },
                    shouldDisable: function () {
                        var item = thiz.getSelectedItem();
                        if(!item){
                            return;
                        }
                        return false;
                    }
                }));
                */
            }

            result.push(this.createAction('Open In New Tab', 'File/OpenInNewTab', 'fa-share', ['alt enter'], 'Home', 'Open', 'item', null, null, {quick:true}, null, function () {
                    var item = thiz.getSelectedItem();
                    if (item && item.isDir) {
                        return false;
                    }
                    return true;
                }, permissions, container, thiz
            ));


            if (ctx && ctx.getMountManager && DefaultActions.hasAction(permissions, ACTION.SOURCE)) {
                permissions.push(ACTION.SOURCE);
                var mountManager = ctx.getMountManager(),
                    mountData = mountManager.getMounts(),
                    i = 0;

                if (mountData && mountData.length > 0) {
                    var currentValue = thiz.collection.mount;
                    result.push(this.createAction({
                        label: 'Source',
                        command: ACTION.SOURCE,
                        icon: 'fa-hdd-o',
                        keyCombo: ['ctrl f1'],
                        tab: 'Home',
                        group: 'Navigation',
                        mixin:{
                            data:mountData,
                            addPermission:true,
                            quick:true
                        },
                        onCreate:function(action){
                            action.set('value',currentValue);
                        }
                    }));

                    function createSourceAction(item) {
                        var label = item.label;
                        permissions.push(ACTION.SOURCE + '/' + label);
                        var _sourceAction = thiz.createAction({
                            label: label,
                            command: ACTION.SOURCE + '/' + label,
                            icon: 'fa-hdd-o',
                            keyCombo: ['alt f' + i],
                            tab: 'Home',
                            group: 'Navigation',
                            mixin:{
                                data:mountData,
                                item: item,
                                closeOnClick:false,
                                quick:true
                            },
                            onCreate:function(action){
                                action.set('value',item.name);
                                action._oldIcon = this.icon;
                                action.actionType = types.ACTION_TYPE.SINGLE_TOGGLE;
                            }
                        });
                        result.push(_sourceAction);
                        i++;
                    }
                    _.each(mountData, createSourceAction);
                }
            }

            return result.concat(this.getEditorActions(permissions));
        },
        rename: function (item) {
            var dfd = new Deferred();
            var self = this,
                currentItem = item || this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).basename : '',
                collection = this.collection,
                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            var CIS = {
                inputs: [
                    utils.createCI('name', types.ECIType.STRING, startValue, {
                        widget: {
                            instant: true,
                            title: 'New Name',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            };
            var dlg = new _CIDialog({
                cis: CIS,
                title: 'Rename',
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                bodyCSS: {
                    'height': 'auto',
                    'min-height': '80px',
                    'width':'100%',
                     'min-width':'400px'
                },
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {
                    var val = this.getField('name');
                    if (val == null) {
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }
                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().rename(currentItem.mount, currentItem.path, val, {
                            checkErrors: true,
                            returnProm: false
                        });

                    fileDfd.then(function (data) {

                        self.runAction(ACTION.RELOAD).then(function () {
                            defaultDfdArgs.select = currentFolder.path + '/' + val;
                            dfd.resolve(defaultDfdArgs);
                        });

                    }, function (e) {
                        logError(e, '__error renaming file!');
                        dfd.resolve(defaultDfdArgs);
                    });
                }
            });
            dlg.show();

            return dfd;

        },
        move: function (items) {

            var dfd = new Deferred();
            var self = this,
                currentItem = this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                collection = this.collection,

                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            //file selected
            if (!currentItem.directory) {
                var _parent = currentItem.getParent();
                if (_parent) {
                    currentItem = _parent;
                    startValue = currentItem ? currentItem.path : './';
                }
            }
            var fileWidgetValue = currentItem.path;
            var CIS = {
                inputs: [
                    utils.createCI('Name', types.ECIType.FILE, fileWidgetValue, {
                        widget: {
                            instant: true,
                            title: 'Target',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            }

            var dlg = new _CIDialog({
                cis: CIS,
                title: self.localize('Move'),
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {

                    var val = this.getField('name');

                    if (val == null) {
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }

                    var serverArgs = self._buildServerSelection(selection);
                    var dstPathItem = self.collection.getSync(val);
                    var dstPath = dstPathItem ? utils.normalizePath(dstPathItem.mount + '/' + dstPathItem.path) : '';

                    if (dstPathItem) {
                        serverArgs.dstPath = dstPath;
                    }

                    var options = defaultCopyOptions();
                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().moveItem(serverArgs.selection, serverArgs.dstPath, options.includes, options.excludes, options.mode, {
                            checkErrors: true,
                            returnProm: false
                        });

                    fileDfd.then(function (data) {
                        self.runAction(ACTION.RELOAD).then(function () {
                            dfd.resolve(defaultDfdArgs);
                        });

                    }, function (e) {
                        logError(e, '__error creating file!');
                        dfd.resolve(defaultDfdArgs);
                    })
                }
            });
            dlg._on('widget', function (e) {
                e.widget._onSelect = function (w) {
                    return openFilePicker.apply(self, [dlg, w]);
                }
            });
            dlg.show();
            return dfd;
        },
        copy: function (items) {

            var dfd = new Deferred();
            var self = this,
                currentItem = this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                collection = this.collection,
                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            //file selected
            if (!currentItem.directory) {
                var _parent = currentItem.getParent();
                if (_parent) {
                    currentItem = _parent;
                    startValue = currentItem ? currentItem.path : './';
                }
            }
            var fileWidgetValue = currentItem.path;
            var CIS = {
                inputs: [
                    utils.createCI('Name', types.ECIType.FILE, fileWidgetValue, {
                        widget: {
                            instant: true,
                            title: 'Target',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            }
            var dlgClass = dcl([FileOperationDialog, _CIDialog], {});
            var dlg = new dlgClass({
                cis: CIS,
                title: self.localize('Copy'),
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                bodyCSS: {
                    'height': 'auto',
                    'min-height': '80px',
                    'width':'100%',
                    'min-width':'400px'
                },
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {

                    var val= this.getField('name');
                    if(val==null){
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }
                    var msg = this.showMessage(),
                        thiz = this,
                        serverArgs = self._buildServerSelection(selection),
                        dstPathItem  = self.collection.getSync(val),
                        dstPath = dstPathItem ? utils.normalizePath(dstPathItem.mount + '/' + dstPathItem.path) : '';

                    if(dstPathItem) {
                        serverArgs.dstPath = dstPath;
                    }else{
                        serverArgs.dstPath = utils.normalizePath(currentItem.mount + '/' + val);
                    }

                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().copyItem(serverArgs.selection,serverArgs.dstPath,defaultCopyOptions(),{
                            checkErrors:true,
                            returnProm:false
                        });

                    fileDfd.then(function (result) {
                        thiz._onSuccess(result);
                    }, function (err) {
                        thiz._onError();
                    });

                    fileDfd.then(function(data){
                        self.runAction(ACTION.RELOAD).then(function(){
                            dfd.resolve(defaultDfdArgs);
                        });

                    },function(e){
                        logError(e,'__error creating file!');
                        dfd.resolve(defaultDfdArgs);
                    })
                }
            });
            dlg._on('widget', function (e) {
                e.widget._onSelect = function (w) {
                    return openFilePicker.apply(self, [dlg, w]);
                };
            });
            dlg.show();
            return dfd;


        },
        clipboardPaste: function () {
            var dfd = new Deferred();
            var isCut = this.currentCutSelection,
                items = isCut ? this.currentCutSelection : this.currentCopySelection,
                serverParams = this._buildServerSelection(items),
                serverFunction = isCut ? 'moveItem' : 'copyItem',
                self = this,
                defaultDfdArgs = {
                    select: items,
                    focus: true,
                    append: false
                };
            if (!items) {
                dfd.resolve();
                return dfd;
            }
            var options = defaultCopyOptions();
            self.ctx.getFileManager()[serverFunction](serverParams.selection, serverParams.dstPath, {
                include: options.includes,
                exclude: options.excludes,
                mode: options.mode
            }).then(function (data) {
                self.runAction(types.ACTION.RELOAD).then(function () {
                    dfd.resolve(defaultDfdArgs);
                });
            }, function (err) {
                dfd.resolve(defaultDfdArgs);
            }, function (progress) {
                dfd.resolve(defaultDfdArgs);
            });
            return dfd;
        },
        /**
         * mkdir version:
         *
         *    1. open dialog with input box (value = currentItem)
         *
         * @TODO : remove leaks
         */
        mkdir: function () {

            var dfd = new Deferred();
            try {
                var self = this,
                    currentItem = this.getSelectedItem(),
                    currentFolder = this.getCurrentFolder(),
                    startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                    collection = this.collection;

                var CIS = {
                        inputs: [
                            utils.createCI('Name', 13, startValue, {
                                widget: {
                                    instant: true,
                                    validator: function (value) {
                                        if(currentFolder) {
                                            return collection.getSync(currentFolder.path + '/' + value) == null &&
                                                value.length > 0;
                                        }else{
                                            return true;
                                        }
                                    }
                                }
                            })
                        ]
                    },
                    defaultDfdArgs = {
                        select: currentItem,
                        focus: true,
                        append: false
                    };

                var dlg = new _CIDialog({
                    cis: CIS,
                    title: 'Create new Directory',
                    ctx: this.ctx,
                    size: types.DIALOG_SIZE.SIZE_NORMAL,
                    bodyCSS: {
                        'height': 'auto',
                        'min-height': '80px',
                        'width':'100%',
                        'min-width':'400px'
                    },
                    _onError: function (title, suffix, message) {
                        title = title || this.title;
                        message = message || this.notificationMessage;
                        message && message.update({
                            message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                            type: 'error',
                            actions: false,
                            duration: 15000
                        });
                        this.onError && this.onError(suffix);
                    },
                    onCancel: function () {
                        dfd.resolve();
                    },
                    onOk: function () {

                        var val = this.getField('name');
                        if (val == null) {
                            dfd.resolve(defaultDfdArgs);
                            return;
                        }

                        var currentFolder = self.getCurrentFolder() || {path:'.'},
                            newFolder = currentFolder.path + '/' + val;

                        var fileDfd = self.ctx.getFileManager().mkdir(collection.mount, newFolder, {
                            checkErrors: true,
                            returnProm: false
                        });

                        // call server::mkdir, then reload, then resolve dfd with new newFolder as selection
                        fileDfd.then(function (data) {
                            self.runAction(ACTION.RELOAD).then(function () {
                                collection.getSync(newFolder) && dfd.resolve({
                                    select: newFolder,
                                    append: false,
                                    focus: true
                                });
                            });
                        }, function (e) {
                            dfd.resolve(defaultDfdArgs);
                            logError(e, 'error creating directory');
                        })
                    }
                });

                dlg.show();

            } catch (e) {
                logError(e, 'error creating dialog');
            }
            return dfd;

        },
        _buildServerSelection: function (items, dst) {

            !dst && (dst = this.getCurrentFolder());

            //normalize
            if (dst && !dst.directory) {
                dst = dst.getParent();
            }

            if (!_.isArray(items)) {
                items = [items];
            }

            //basics
            var selection = [],
                store = items[0].getStore(),
                dstPath = dst ? utils.normalizePath(dst.mount + '/' + dst.path) : '';

            //build selection
            _.each(items, function (item) {
                var _storeItem = store.getSync(item.path);
                if (_storeItem) {
                    selection.push(utils.normalizePath(item.mount + '/' + item.path));
                }
            });


            //compose output
            return {
                selection: selection,
                store: items[0]._S,
                dstPath: '/' + dstPath + '/',
                firstItem: items[0],
                parent: dst
            }
        },
        openPreview: function (item, parent) {

            var row = this.row(item);

            var el = row.element,
                self = this,
                dfd = new Deferred();

            if (this._preview) {
                this._preview.item = item;
                var _dfd = this._preview.open().then(function () {
                    self._preview.preview.trigger($.Event('update', {file: item}));
                });

                return _dfd;
            }


            var _prev = new FilePreview({
                node: $(el),
                item: item,
                delegate: this.ctx.getFileManager(),
                parent: $(el),
                ctx: self.ctx,
                container: parent ? parent.containerNode : null
            });

            parent ? _prev.buildRenderingEmbedded() : _prev.buildRendering();
            _prev.init();
            _prev.exec();
            this._preview = _prev;
            this._preview.handler = this;
            self._on('selectionChanged', function (e) {
                var _item = self.getSelectedItem();
                if (_item) {

                    _prev.item = _item;
                    _prev.preview.trigger($.Event('update', {file: _item}));
                }
            });

            this.add(_prev, null, false);
            _prev._emit('changeState', function (state) {
                if (state === 0) {
                    dfd.resolve({
                        select: item,
                        focus: true,
                        append: false
                    });
                }
            });

            return dfd;

        },
        deleteSelection: function (selection) {
            selection = selection || this.getSelection();
            var dfd = new Deferred(),
                _next = this.getNext(selection[0], null, true),
                _prev = this.getPrevious(selection[0], null, true),

                next = _next || _prev,
                serverParams = this._buildServerSelection(selection),
                dlgClass = FileOperationDialog,
                title = 'Delete ' + serverParams.selection.length + ' ' + 'items',
                thiz = this;

            var dlg = new dlgClass({
                ctx: thiz.ctx,
                notificationMessage: null,
                title: title,
                type: types.DIALOG_TYPE.DANGER,
                onBeforeOk: function () {

                },
                getOkDfd: function () {
                    var thiz = this;
                    return this.ctx.getFileManager().deleteItems(serverParams.selection, {
                        hints: [1]
                    }, {
                        checkErrors: false,
                        returnProm: false,
                        onError: function (err) {
                            thiz._onError(null, err.message);
                        }
                    });
                },
                onCancel: function () {
                    dfd.resolve({
                        select: selection,
                        focus: true,
                        append: false
                    });
                },
                onSuccess: function () {
                    thiz.runAction(types.ACTION.RELOAD).then(function () {
                        dfd.resolve({
                            select: next,
                            focus: true,
                            append: false
                        });
                    });
                }
            });
            dlg.show();
            return dfd;
        },
        /**
         *
         * @param item {module:xfile/model/File}
         */
        goUp: function (item) {
            item = this._history.getNow();
            _debug && console.log('go up ' + item);
            item = _.isString(item) ? this.collection.getSync(item) : item;
            var dfd = new Deferred(),
                self = this;
            var history = this.getHistory();
            var prev = history.getNow();


            if (!item) {
                var rows = this.getRows();
                if (rows[0] && rows[0]._S) {
                    var _parent = rows[0]._S.getParent(rows[0]);
                    if (_parent) {
                        _parent = _parent._S.getParent(_parent);
                        if (_parent) {
                            item = _parent;
                        }
                    }
                }
            }

            if (item) {
                //current folder:
                var _parent = item._S.getParent(item);
                if (_parent) {
                    var _dfd = this.openFolder(_parent, true, false);
                    _dfd && _dfd.then && _dfd.then(function () {
                        if (prev) {
                            //history.pop();
                            var select = self.collection.getSync(prev);
                            if (select) {
                                dfd.resolve({
                                    select: select,
                                    focus: true,
                                    delay: 1
                                });
                            } else {

                                console.warn('cant find back item ' + prev);
                            }
                        } else {
                            console.warn('cant find back item ' + prev + ' ' + item.path);
                        }
                    });
                }
            } else {
                if (prev) {
                    var select = this.collection.getSync(prev);
                    if (select) {
                        this.select([select], null, true, {
                            focus: true,
                            delay: 1
                        });
                    }
                } else {
                    var rows = this.getRows();
                    if (rows[0] && rows[0]._S) {
                        var _parent = rows[0]._S.getParent(rows[0]);
                        if (_parent) {
                            _parent = _parent._S.getParent(_parent);
                            if (_parent) {
                                this.openFolder(_parent, true);
                            }
                        }
                    }
                }
            }
            return dfd;
        },
        reload: function (item) {
            var dfd = new Deferred(),
                selection = this.getSelection();

            item = item || this.getRows()[0];

            //item could be a non-store item:
            var cwd = /*item.getParent ? item.getParent() : */this.getCurrentFolder() || {path:'.'},
                self = this;

            if(cwd.isBack){
                cwd = this.collection.getSync(cwd.rPath);
            }
            var expanded = false;
            if (this.isExpanded && this.expand && item) {
                expanded = this._isExpanded(item);
                if (expanded) {
                    this.expand(item, null, false);
                }
            }
            self.collection.resetQueryLog();
            this.collection.loadItem(cwd, true).then(function (what) {

                if (cwd === '.') {
                    self.collection.resetQueryLog();
                }

                self.refresh().then(function () {
                    var _dfd = self.openItem(cwd, false, false);
                    if (_dfd && _dfd.then) {
                        _dfd.then(function () {
                            dfd.resolve({
                                select: selection,
                                append: false,
                                focus: true,
                                delay: 1
                            });
                            return;
                        });
                    }
                    self.deselectAll();
                    dfd.resolve({
                        select: selection,
                        append: false,
                        focus: true,
                        delay: 2
                    });
                });
            });

            return dfd;
        },
        /**
         * Opens folder
         * @param item {module:xfile.model.File}
         * @param isBack
         */
        toHistory: function (item) {
            var FolderPath = item.getFolder ? new Path(item.getFolder()) : new Path('.');
            var segs = FolderPath.getSegments();
            var addDot = this.collection.addDot;
            var root = this.collection.rootSegment;
            //var _last = addDot ? '.' : "";
            var _last = root;
            if(segs && segs[0]==='.'){
                segs[0] = root;
            }
            var out = [];

            _.each(segs, function (seg) {
                var segPath = seg!==_last ? _last + (_last.endsWith("/") ? "" : "/" ) + seg : seg;
                out.push(segPath);
                _last = segPath;
            });

            return out;

        },
        openFolder: function (item, isBack, select) {
            var cwd = this.getCurrentFolder(),
                store = this.collection,
                history = this.getHistory(),
                now = history.getNow(),
                prev = history.getNow(),
                self = this;

            if (_.isString(item)) {
                item = store.getSync(item);
            } else {
                item = store.getSync(item.path) || item;
            }

            if (!item) {
                console.warn('openFolder: no item! set to root:');
                item = store.getRootItem();
            }

            _debug && console.log('open folder ' + item.path + ' cwd : ' + this.getCurrentFolder().path);
            var _hItems = self.toHistory(item);

            _debug && console.log('history:\n' + _hItems.join('\n'));
            history.set(_hItems);
            if (!item) {
                return this.setQueryEx(store.getRootItem());
            }

            if (cwd && item && isBack && cwd.path === item.path || !item) {

                return;
            }

            this.deselectAll();
            var row = this.row(item),
                node = row ? row.element : null,
                loaded = item._S.isItemLoaded(item),
                iconNode;
            if (!loaded) {
                var _els = $(node).find("span.fa");
                if (_els && _els[0]) {
                    iconNode = $(_els[0]);
                }
                if (iconNode) {
                    iconNode.removeClass('fa fa-folder');
                    iconNode.addClass('fa-spinner fa-spin');

                }
            }

            var head = new Deferred();

            this._emit('openFolder', {
                item: item,
                back: isBack
            });

            var dfd = this.setQueryEx(item, null);
            dfd && dfd.then(function () {
                //remove spinner
                if (iconNode) {
                    iconNode.addClass('fa fa-folder');
                    iconNode.removeClass('fa-spinner fa-spin');
                }
                head.resolve({
                    select: select !== false ? ( isBack ? item : self.getRows()[0]) : null,
                    focus: true,
                    append: false,
                    delay: 1
                });
                self._emit('openedFolder', {
                    item: item,
                    back: isBack
                });
            });

            return head;
        },
        changeSource: function (mountData, silent) {

            var dfd = new Deferred(),
                thiz = this,
                ctx = thiz.ctx || ctx,
                fileManager = ctx.getFileManager(),
                store = factory.createFileStore(mountData.name, null, fileManager.config,null,ctx),
                oldStore = this.collection,
                sourceAction = this.getAction(ACTION.SOURCE),
                label = mountData.label || mountData.name,
                mountAction = this.getAction(ACTION.SOURCE + '/' + label);

            oldStore.destroy();

            silent !== true && this._emit('changeSource', mountData);
            this.set('loading', true);
            this.set('collection', store.getDefaultCollection());
            sourceAction.set('value',mountData.name);
            thiz.set('title','Files ('+mountData.label+')');
            var sourceActions = sourceAction.getChildren();
            _.each(sourceActions, function (child) {
                child.set('icon', child._oldIcon);
            });

            sourceAction.set('label',label);
            mountAction && mountAction.set('icon','fa-spinner fa-spin');
            this.refresh().then(function () {
                thiz.set('loading', false);
                mountAction && mountAction.set('icon','fa-check');
                silent !== true && thiz._emit('changedSource', mountData);
                thiz.select([0], null, true, {
                    append: false,
                    focus: true
                }).then(function () {
                    dfd.resolve();
                });
            });
            return dfd;

        },
        openInNewTab: function (item) {
            var thiz = this,
                ctx = thiz.ctx,
                wManager = ctx.getWindowManager(),
                dfd = new Deferred(),
                tab = null;

            if (_.isFunction(this.newTarget)) {
                tab = this.newTarget({
                    title: item.name,
                    icon: 'fa-folder',
                    target:thiz._parent,
                    location:null,
                    tabOrientation:null
                });

            } else {
                tab = wManager.createTab(item.name, 'fa-folder', this.newTarget || this);
            }

            var _store = this.collection;
            if(!item.isDir){
                item = this.getCurrentFolder();
            }

            var store = factory.createFileStore(_store.mount,_store.options,_store.config,null,ctx);
            var args = utils.mixin({
                    showToolbar: this.showToolbar,
                    collection: store,
                    selectedRenderer: this.selectedRenderer,
                    showHeader: this.showHeader,
                    newTarget: this.newTarget,
                    style: this.style,
                    options: utils.clone(this.options),
                    permissions: this.permissions,
                    _columns: this._columns,
                    attachDirect: true,
                    registerEditors: this.registerEditors
                }, this.newTabArgs || {}),

                grid = utils.addWidget(this.getClass(), args, null, tab, false);

            dfd.resolve();
            grid.set('loading',true);

            store.initRoot().then(function(d){
                var _dfd = store.getItem(item.path,true);
                _dfd && _dfd.then(function(){
                    //return;
                    grid.startup();
                    grid.refresh().then(function () {
                        grid.openItem(item).then(function(){
                            grid.focus();
                            grid.select([0], null, true, {
                                focus: true,
                                append: false,
                                delay:1
                            });
                            grid.set('loading',false);
                        });
                        wManager.registerView(grid, true);
                    });
                });
            });
            return dfd;
        },
        openItem: function (item, isBack, select) {
            if (!item) {
                var _rows = this.getRows();
                if (_rows[0] && _rows[0].isBack) {
                    item = _rows[0];
                }
            }

            if (item && item.isBack) {
                item._S = null;
                return this.goUp();
            }

            item = _.isString(item) ? this.collection.getSync(item) : item;
            if (!item) {
                return;
            }
            if (item.directory === true) {
                return this.openFolder(item, isBack, select);
            } else {
                var editors = Registry.getEditors(item);
                var defaultEditor = _.find(editors, function (editor) {
                    return editor.isDefault === true;
                });
                if (defaultEditor) {
                    return defaultEditor.onEdit(item, this);
                }
                return this.ctx.getWindowManager().openItem(item, this.newTarget || this, {
                    register: true
                });

            }
        },
        getSelectedItem: function () {
            return this.getSelection()[0];
        },
        openDefaultEditor: function (item) {
            return Default.Implementation.open(item);
        },
        close:function(){
            var panel = this._parent;
            if(panel){
                var docker  = panel.docker();
                if(docker){
                    this.onAfterAction = null;
                    docker.removePanel(panel);
                }
            }
            return false;
        },
        compress:function(items){
            items = items || this.getSelection();
            var thiz = this;
            var serverParams = this._buildServerSelection(items);
            if (serverParams && serverParams.store && serverParams.selection){
                thiz.ctx.getFileManager().compressItem(serverParams.firstItem.mount,serverParams.selection,'zip').then(function (args) {
                    thiz.reload();
                });
            }

        },
        runAction: function (action, _item) {
            _.isString(action) && (action = this.getAction(action));
            if (!action || !action.command) {
                console.warn('invalid action');
                return;
            }
            var ACTION_TYPE = types.ACTION,
                item = this.getSelectedItem() || _item,
                sel = this.getSelection();

            if (action.command.indexOf(ACTION.SOURCE) != -1) {
                return this.changeSource(action.item);
            }
            switch (action.command) {

                case 'File/Compress':
                {
                    return this.compress(sel);
                }
                case ACTION_TYPE.PREVIEW:
                {
                    return this.openPreview(item);
                }
                case 'File/OpenInNewTab':
                {
                    return this.openInNewTab(item || this.collection.getRootItem());
                }
                case ACTION_TYPE.EDIT:
                {
                    return this.openItem(item);
                }
                case ACTION_TYPE.NEW_FILE:
                {
                    return this.touch(item);
                }
                case ACTION_TYPE.NEW_DIRECTORY:
                {
                    return this.mkdir(item);
                }
                case ACTION_TYPE.RELOAD:
                {
                    return this.reload(item);
                }
                case ACTION_TYPE.RENAME:
                {
                    return this.rename(item);
                }
                case ACTION_TYPE.GO_UP:
                {
                    return this.goUp(null);
                }
                case ACTION_TYPE.COPY:
                {
                    return this.copy(null);
                }
                case ACTION_TYPE.MOVE:
                {
                    return this.move(null);
                }
                case ACTION_TYPE.DELETE:
                {
                    return this.deleteSelection(null);
                }
                case ACTION_TYPE.OPEN_IN + '/Default Editor':
                {
                    return this.openDefaultEditor(item);
                }
                case ACTION_TYPE.DOWNLOAD:
                {
                    return this.ctx.getFileManager().download(item);
                }
                case ACTION_TYPE.CLOSE:
                {
                    return this.close();
                }
                case 'File/OpenInOS':
                {
                    return this.openInOS(item);
                }
            }

            if (action.command.indexOf(ACTION_TYPE.OPEN_IN + '/') != -1) {
                return action.editor.onEdit(item);
            }

            return this.inherited(arguments);
        },

        getEditorActions: function (permissions) {
                permissions = permissions || this.permissions;
                var result = [],
                    ACTION = types.ACTION,
                    ACTION_ICON = types.ACTION_ICON,
                    VISIBILITY = types.ACTION_VISIBILITY,
                    thiz = this,
                    ctx = thiz.ctx,
                    container = thiz.domNode,
                    actionStore = thiz.getActionStore(),
                    openInAction = null,
                    openInActionModel = null,
                    dirty = false,
                    selHandle = null;

                function getItem() {
                    return thiz.getSelection()[0];
                }

                function selHandler(event){

                    var selection = event.selection;
                    if(!selection || !selection[0] ){
                        return;
                    }
                    var item = selection[0];
                    var permissions = this.permissions;
                    var ACTION = types.ACTION,
                        ACTION_ICON = types.ACTION_ICON,
                        VISIBILITY = types.ACTION_VISIBILITY,
                        thiz = this,
                        container = thiz.domNode,
                        actionStore = thiz.getActionStore(),
                        contextMenu = this.getContextMenu ? this.getContextMenu() : null;

                    function _wireEditor(editor, action) {
                        action.handler = function () {
                            editor.onEdit(thiz.getSelection()[0]);
                        };
                    }
                    function getEditorActions(item){
                        var editors = Registry.getEditors(item) || [],
                            result = [];

                        for (var i = 0; i < editors.length; i++) {
                            var editor = editors[i];
                            if(editor.name ==='Default Editor'){
                                continue;
                            }
                            var editorAction = thiz.createAction(editor.name, ACTION.OPEN_IN + '/' + editor.name, editor.iconClass, null, 'Home', 'Open', 'item', null,
                                function () {
                                },
                                {
                                    addPermission: true,
                                    tab: 'Home',
                                    editor:editor,
                                    custom:true,
                                    quick:true
                                }, null, null, permissions, container, thiz
                            );
                            _wireEditor(editor, editorAction);
                            result.push(editorAction);
                        }
                        return result;
                    }
                    if (event.why == 'deselect') {
                        return;
                    }
                    var action = actionStore.getSync(types.ACTION.OPEN_IN);
                    var editorActions = thiz.addActions(getEditorActions(item));

                    if(this._lastEditorActions){
                        _.each(this._lastEditorActions,function(action){
                            actionStore.removeSync(action.command);
                        });
                        delete this._lastEditorActions;
                    }

                    contextMenu && contextMenu.removeCustomActions();

                    if(editorActions.length>0) {
                        var newStoredActions = this.addActions(editorActions);
                        actionStore._emit('onActionsAdded', newStoredActions);
                        this._lastEditorActions = newStoredActions;
                    }else{

                    }
                }

                if (!this._selHandle) {
                    this._selHandle = this._on('selectionChanged',function(evt){
                        selHandler.apply(thiz,[evt]);
                    });
                }
                openInAction = this.createAction('Open In', ACTION.OPEN_IN, ACTION_ICON.EDIT, null, 'Home', 'Open', 'item',
                    null,
                    function () {
                    },
                    {
                        addPermission: true,
                        tab: 'Home',
                        quick:true
                    }, null, DefaultActions.shouldDisableDefaultFileOnly, permissions, container, thiz
                );

                result.push(openInAction);
                var e = thiz.createAction('Default Editor', ACTION.OPEN_IN + '/Default Editor', 'fa-code', null, 'Home', 'Open', 'item', null,
                    function () {
                    },
                    {
                        addPermission: true,
                        tab: 'Home',
                        forceSubs: true,
                        quick:true

                    }, null, null, permissions, container, thiz
                );
                result.push(e);
                return result;
            }
    };

    //package via declare
    var _class = declare('xfile.FileActions', null, Implementation);
    _class.Implementation = Implementation;
    
    _class.createFilePicker = createFilePicker;
    
    return _class;

});
},
'xbox/manager/Application':function(){
define([
    "dcl/dcl",
    'xdojo/has',
    'xide/manager/Application',
    'require',
    'xide/types',
    'xide/utils',
    'xbox/views/MainView',
    'xide/editor/Default'
], function (dcl,has,Application,require,types,utils,MainView,Default) {
    /**
     * @class xbox.manager.Application
     * @extends module:xide/manager/Application
     */
    return dcl(Application, {
        declaredClass:"xbox.manager.Application",
        onXFileReady:function(config,gridClass){

            Default.Implementation.ctx=this.ctx;

            var _require = require,
                thiz = this,
                mainView = thiz.mainView,
                container = mainView.layoutLeft,
                windowManager = this.ctx.getWindowManager(),
                breadcrumb = mainView && mainView.getBreadcrumb ? mainView.getBreadcrumb() : null,
                ctx = thiz.ctx;


            var newTarget= mainView.layoutCenter;


            if(mainView.getNewDefaultTab){

                newTarget = function(args){
                    return mainView.getNewDefaultTab(args);
                }
            }
            if(breadcrumb) {

                this.subscribe(types.EVENTS.ON_OPEN_VIEW, function (e) {
                    var view = e.view;
                    if(view instanceof gridClass) {

                        view.addHandle('click',view.on('click',function(){
                            breadcrumb.setSource(view);
                        }));
                        breadcrumb.setSource(view);
                        var srcStore = view.collection;
                        function _onChangeFolder(store,item,grid){
                            if(breadcrumb.grid!=grid){
                                breadcrumb.setSource(grid);
                            }
                            breadcrumb.clear();
                            breadcrumb.setPath('.',srcStore.getRootItem(),item.getPath(),store);
                        }

                        view._on('openFolder', function (evt) {
                            _onChangeFolder(srcStore,evt.item,view);
                        });
                    }
                });
            }



            _require(['xfile/factory/Store','xfile/types',
                'xfile/views/Grid',
                'xfile/views/FileGrid',
                'xfile/views/FilePreview',
                'xfile/ThumbRenderer'
            ],function(factory,types,Grid,FileGrid,FilePreview,ThumbRenderer){

                ctx.registerEditorExtension('Preview', 'mp4|ma4|mov|html|pdf|avi|mp3|mkv|ogg|png|jpg', 'fa-play', this, true, null, FilePreview.EditorClass, {
                    updateOnSelection: false,
                    leftLayoutContainer: newTarget,
                    ctx: ctx
                });

                var store = factory.createFileStore('root',null,config);
                try {

                    var grid = new FileGrid({
                        //selectedRenderer:ThumbRenderer,
                        newTabArgs:{
                            showHeader:true
                        },
                        style:'height:100%',
                        newTarget: newTarget,
                        collection: store.getDefaultCollection(),
                        showHeader: false,
                        ctx:thiz.ctx,
                        _columns: {
                            "Name": true,
                            "Path": false,
                            "Size": false,
                            "Modified": false,
                            "Owner":false
                        }

                    },container.containerNode);

                    grid.startup();

                    grid.showStatusbar(false);

                    windowManager.registerView(grid,true);

                    if(breadcrumb){

                        breadcrumb.setSource(grid);

                        var srcStore = grid.collection;


                        function _onChangeFolder(store, item, grid) {
                            if (breadcrumb.grid != grid) {
                                breadcrumb.setSource(grid);
                            }
                            breadcrumb.clear();
                            breadcrumb.setPath('.', srcStore.getRootItem(), item.getPath(), store);
                        }

                        grid._on('openedFolder', function (evt) {
                            console.error('opened folder!!');
                            _onChangeFolder(srcStore, evt.item, grid);
                        });
                    }

                    if(has('phone')){
                        setTimeout(function(){
                            grid.showToolbar(true);
                            //grid.resize();
                        },1500);

                    };

                }catch(e){
                    logError(e,'onXFileReady');
                }
            });

        },
        createMainView:function(rootSelector){
            this.container = $(rootSelector  || '#root')[0];
            this.mainView = utils.addWidget(MainView,{
                ctx: this.ctx,
                config: this.config,
                persistent: false,
                windowManager:this.ctx.getWindowManager(),
                container:this.container
            },null,this.container,true);

            this.ctx.mainView = this.mainView;
        },
        start:function(showGUI,rootSelector){
            this.createMainView(rootSelector);
            this.doComponents();
        }
    });
});
},
'xide/views/CIView':function(){
define([
    "dcl/dcl",
    'xide/views/CIViewMixin',
    'xide/_base/_Widget'
], function (dcl,CIViewMixin,_Widget) {
    return dcl([_Widget, CIViewMixin.dcl], {
        templateString:'<div class="CIView"></div>',
        data: null,
        widgets: null,
        delegate: null,
        helpNodes: null,
        store: null,
        groups: null,
        groupContainer: null,
        cssClass: 'CIView',
        options: null,
        tabContainerStyle: null,
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (a.name && b.name && groupMap[a.name] != null && groupMap[b.name] != null) {
                    var orderA = groupMap[a.name];
                    var orderB = groupMap[b.name];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        getElements: function (data, group) {
            var res = [];

            for (var i = 0; i < data.length; i++) {
                var obj = data[i];
                if (obj.group === group) {
                    res.push(obj);
                }
            }
            return res;
        },
        startup: function () {
            if (this.cis) {
                this.startDfd = this.initWithCIS(this.cis);
            }
        }
    });
});
},
'xide/manager/Context_UI':function(){
/** module:xide/manager/Context_UI **/
define([
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/has',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'require',
    'xide/manager/PluginManager',
    'xide/manager/WindowManager',
    'xide/manager/NotificationManager',
    'xide/manager/SettingsManager',
    'xide/editor/Registry',
    'xaction/ActionProvider',
    'xide/lodash',
    'xide/manager/Router'
], function (dcl, Deferred, has, types, utils, EventedMixin, _require, PluginManager,WindowManager, NotificationManager, SettingsManager, Registry, ActionProvider, _,Router) {


    ! 1  &&  false && has.add('xlog', function () {
        return true;
    }, true);

    var isServer =  0 ,
        isBrowser =  1 ;
    /**
     * @class module:xide/manager/Context_UI
     * @extends module:xide/manager/ContextBase
     * @extends module:xaction/ActionProvider
     * @extends module:xide/mixins/EventedMixin
     * @extends module:xide/editor/Registry
     *
     */
    var Module = dcl([EventedMixin.dcl, ActionProvider.dcl, Registry], {
        declaredClass: "xide.manager.Context_UI",
        widgetManager: null,
        settingsManager: null,
        trackingManager: null,
        mainView: null,
        routes:null,
        /**
         * @type {module:xide/manager/Router}
         */
        router:null,
        /**
         *
         * @returns {module:xide/manager/Router}
         */
        getRouter:function(){
            return this.router;
        },

        /**
         *
         * @returns {null|module:xide/manager/WindowManager}
         */
        getWindowManager: function () {
            return this.windowManager;
        },
        /**
         *
         * @returns {null|module:xideve/manager/WindowManager}
         */
        getWidgetManager: function () {
            return this.widgetManager;
        },
        getNotificationManager: function () {
            return this.notificationManager;
        },
        getSettingsManager: function () {
            return this.settingsManager;
        },
        getTrackingManager: function () {
            return this.trackingManager;
        },
        getMainView: function () {
            return this.mainView;
        },
        /**
         * Run global actions here
         * @param action {string|module:xaction/ActionModel}
         * @returns {module:dojo/Deferred}
         */
        runAction: function (action) {
            action = this.getAction(action);
            var actionDfd = this.inherited(arguments),
                who = this;
            if (actionDfd == null && action.handler) {
                actionDfd = action.handler.apply(who, [action]);
            }
            return actionDfd;
        },
        /***********************************************************************/
        /*
         * Editors
         */
        /**
         * Create editor
         * @param ctrArgs {object} ctor args
         * @param item {module:xfile/model/File}
         * @param editorOverrides
         * @param where {HTMLElement|module:xide/widgets/_Widget}
         * @param owner {*|null}
         * @returns {module:dojo/Deferred}
         */
        createEditor: function (ctrArgs, item, editorOverrides, where, owner) {

            var dfd = new Deferred(),
                registerInWindowManager = owner && owner.registerEditors === true ? true : true;

            if (_.isArray(item)) {
                item = item[0];
            }

            var thiz = this,
                title = item && item.name ? item.name : (utils.pathinfo(item.path, 'PATHINFO_FILENAME') + '.' + utils.pathinfo(item.path, 'PATHINFO_EXTENSION')),
                ctx = this,
                mainView = ctx.mainView,
                docker = mainView.getDocker(),
                ctrArgsFinal = {
                    ctx: ctx,
                    config: this.config,
                    item: item,
                    title: title,
                    closeable: true,
                    closable: true
                };
            utils.mixin(ctrArgsFinal, ctrArgs);
            if (_.isString(ctrArgs.editorClass)) {
                //test this really exists
                if (!this.getModule(ctrArgs.editorClass)) {
                    return null;
                }
            }

            if (ctrArgs.runFunctionOnly === true) {
                ctrArgs.editorClass.apply(this, [item]);
                dfd.resolve(null);
                return dfd;
            }

            where = where || mainView.layoutCenter;

            var root = docker.addTab(null, {
                title: title,
                target: where ? where._parent : null,
                icon: 'fa-code'
            });

            ctrArgsFinal._parent = root;

            //- tell everybody
            thiz.publish(types.EVENTS.ON_CREATE_EDITOR_BEGIN, {
                args: ctrArgsFinal,
                item: item
            }, this);


            root.set('loading', true);
            var editor = utils.addWidget(ctrArgs.editorClass, ctrArgsFinal, thiz, root, true, null, null, null, editorOverrides);

            //- tell everybody
            thiz.publish(types.EVENTS.ON_CREATE_EDITOR_END, {
                args: ctrArgsFinal,
                item: item,
                editor: editor
            }, this);

            //- use openItem if possible
            if (editor.openItem) {
                var _dfd = editor.openItem(item);
                dfd.resolve(editor);
                if (registerInWindowManager) {
                    this.getWindowManager().registerView(editor, false);
                }
            }
            //-resize if possible
            root.resize && root.resize();

            if (dfd.then) {
                dfd.then(function () {
                    root.set('loading', false);
                })
            }
            return dfd;
        },
        /**
         *
         * @param name
         * @param extensions
         * @param iconClass
         * @param owner {module:xide/model/Component|*|null}
         * @param isDefault
         * @param onEdit
         * @param editorClass
         * @param editorArgs
         */
        registerEditorExtension: function (name, extensions, iconClass, owner, isDefault, onEdit, editorClass, editorArgs) {
            iconClass = iconClass || 'el-icon-brush';
            var thiz = this,
                _editorArgs = {
                    name: name,
                    extensions: extensions,
                    onEdit: onEdit,
                    iconClass: iconClass,
                    owner: this,
                    isDefault: isDefault != null ? isDefault : false,
                    editorClass: editorClass
                };

            if (editorArgs) {
                _editorArgs = utils.mixin(_editorArgs, editorArgs);
            }
            if (!onEdit) {
                _editorArgs.onEdit = function (item, _owner, overrides) {
                    //some components may have an additional bootstrap in top of 'run':
                    if (owner && owner.onCreateEditor) {
                        var dfd = new Deferred();
                        owner.onCreateEditor().then(function () {
                            var editor = thiz.createEditor(_editorArgs, item, overrides, null, _owner);
                            dfd.resolve(editor);
                        });
                        return dfd;
                    }

                    return thiz.createEditor(_editorArgs, item, overrides, null, _owner);
                }
            }

            if (_.isString(extensions) && extensions.indexOf(',') == -1) {
                types.registerCustomMimeIconExtension(extensions, iconClass);
            }
            Registry.onRegisterEditor(_editorArgs);
            this.publish(types.EVENTS.REGISTER_EDITOR, _editorArgs);
        },
        /***********************************************************************/
        /*
         * Global event handlers
         */
        /***********************************************************************/
        /*
         * STD - API
         */
        initManagers: function () {

            if (this.settingsManager) {
                this.settingsManager.init();
            }

            if (this.storeDelegate) {
                this.storeDelegate.appService = this.settingsManager;
            }

            if (this.settingsManager) {
                this.settingsManager.serviceObject = this.serviceObject;
                this.settingsManager.ctx = this;
                this.settingsManager.config = this.config;
                this.settingsManager.init();

            }
            if (this.storeDelegate) {
                this.storeDelegate.serviceObject = this.serviceObject;
            }


            if (has('plugins') && typeof xappPluginResources != 'undefined' && this.pluginManager) {
                this.pluginsLoading = this.pluginManager.loadPlugins(xappPluginResources);
            }

            if (this.notificationManager) {
                this.notificationManager.init();
                this.notificationManager.postMessage({
                    message: 'Loading application, please wait!',
                    duration: 1000,
                    showCloseButton: true
                });
            }
            this.application && this.application.init();
            this.windowManager && this.windowManager.init();
            var self = this;
            this.registerEditorExtension('Browser', 'php|html|mp4|doc|xls|pdf|zip|tar|iso|avi|gz|mp3|mkv|ogg|png|jpg|cfhtml', 'fa-play-circle-o', this, false, null, function (item) {
                window.open(self.getFileManager().getImageUrl(item));
            }, {
                ctx: this.ctx,
                registerView: false,
                runFunctionOnly: true,
                isDefault: false
            });

        },
        registerRoute:function(config){
            if(!this.routes){
                this.routes = [];
            }
            this.routes.push(config);
        },
        ready:function(){
            this.router = new Router({routes:this.routes});
        },
        constructManagers: function () {
            this.pluginManager = this.createManager(PluginManager);
            this.windowManager = this.createManager(WindowManager);
            this.notificationManager = this.createManager(NotificationManager);
            this.settingsManager = this.createManager(SettingsManager);
        }
    });

    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');
    dcl.chainAfter(Module, 'ready');

    return Module;
});
},
'wcDocker/drawer':function(){
/** @module wcDrawer */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/frame",
    "wcDocker/base"
], function (dcl, wcDocker, wcFrame, base) {
    /**
     * A docker container for carrying its own arrangement of docked panels as a slide out drawer.
     * @class module:wcDrawer
     * A collapsable container for carrying panels.<br>
     *
     * @version 3.0.0
     * @description <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
     */
    var Module = dcl(base,{
        declaredClass: 'wcDrawer',
        /**
         * @memberOf module:wcDrawer
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this drawer.
         * @param {wcSplitter|wcDocker} parent - The drawer's parent object.
         * @param {module:wcDocker.DOCK} position - A docking position to place this drawer.
         */
        constructor:function (container, parent, position) {
            this.$container = $(container);
            this.$frame = null;
            this._position = position;
            this._parent = parent;
            this._frame = null;
            this._closeSize = 0;
            this._expanded = false;
            this._sliding = false;
            this._orientation = (this._position === wcDocker.DOCK.LEFT || this._position === wcDocker.DOCK.RIGHT) ? wcDocker.ORIENTATION.HORIZONTAL : wcDocker.ORIENTATION.VERTICAL;
            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Collapses the drawer to its respective side wall.
         * @function module:wcDrawer#collapse
         */
        collapse: function (instant) {
            if (this._expanded) {
                // Collapse happens before the tab is de-selected, so record the
                // current size and assign it to the current panel.
                var panel = this._frame.panel();
                if (panel) {
                    var size = this._parent.pos();
                    if (this._position !== wcDocker.DOCK.LEFT) {
                        size = 1.0 - size;
                    }

                    var max;
                    if (this._position === wcDocker.DOCK.BOTTOM) {
                        max = this.docker().$container.height();
                        panel._size.y = size * max;
                    } else {
                        max = this.docker().$container.width();
                        panel._size.x = size * max;
                    }
                }

                this._expanded = false;
                if (instant) {
                    switch (this._position) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            this._parent.pos(0);
                            break;
                        case wcDocker.DOCK.RIGHT:
                        case wcDocker.DOCK.BOTTOM:
                            this._parent.pos(1);
                            break;
                    }
                } else {
                    this._sliding = true;

                    var self = this;
                    var fin = function () {
                        self._sliding = false;
                        self._parent.__update();
                    };

                    switch (this._position) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            this._parent.animPos(0, fin);
                            break;
                        case wcDocker.DOCK.RIGHT:
                        case wcDocker.DOCK.BOTTOM:
                            this._parent.animPos(1, fin);
                            break;
                    }
                }
            }
        },

        /**
         * Expands the drawer.
         * @function module:wcDrawer#expand
         */
        expand: function () {
            if (!this._expanded) {
                this._expanded = true;
                this._sliding = true;

                var panel = this._frame.panel();
                if (panel) {
                    // Determine the size to expand the drawer based on the size of the panel.
                    var size, max;
                    if (this._position === wcDocker.DOCK.BOTTOM) {
                        size = panel._size.y;
                        max = this.docker().$container.height();
                    } else {
                        size = panel._size.x;
                        max = this.docker().$container.width();
                    }

                    if (this._position !== wcDocker.DOCK.LEFT) {
                        size = max - size;
                    }

                    size = size / max;
                    var self = this;
                    this._parent.animPos(size, function () {
                        self._sliding = false;
                        self._parent.__update();
                    });
                }
            }
        },

        /**
         * Gets whether the drawer is expanded.
         * @function module:wcDrawer#isExpanded
         * @returns {Boolean} - The current expanded state.
         */
        isExpanded: function () {
            return this._expanded;
        },

        /**
         * The minimum size constraint for the drawer area.
         * @function module:wcDrawer#minSize
         * @returns {module:wcDocker~Size} - The minimum size.
         */
        minSize: function () {
            if (this._expanded) {
                if (this._root && typeof this._root.minSize === 'function') {
                    return this._root.minSize();
                } else {
                    return {x: 100, y: 50};
                }
            }
            this.__adjustCollapsedSize();
            return {x: this._closeSize, y: this._closeSize};
        },

        /**
         * The maximum size constraint for the drawer area.
         * @function module:wcDrawer#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var isHorizontal = (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) ? true : false;
            if (this._expanded || this._sliding) {
                if (this._root && typeof this._root.maxSize === 'function') {
                    return {
                        x: (isHorizontal ? this._root.maxSize().x : Infinity),
                        y: (!isHorizontal ? this._root.maxSize().y : Infinity)
                    };
                } else {
                    return {x: Infinity, y: Infinity};
                }
            }
            this.__adjustCollapsedSize();
            return {
                x: (isHorizontal ? this._closeSize : Infinity),
                y: (!isHorizontal ? this._closeSize : Infinity)
            };
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        __init: function () {
            this.$frame = $('<div class="wcCollapserFrame">');
            this.__container(this.$container);

            this._frame = new (this.docker().__getClass('wcFrame'))(this.$frame, this, false);
            this._frame.tabOrientation(this._position);
        },

        // Updates the size of the collapser.
        __update: function (opt_dontMove) {
            this.__adjustCollapsedSize();
            this._frame.__update();
        },

        // Adjusts the size of the collapser when it is closed.
        __adjustCollapsedSize: function () {
            if (this._frame._panelList.length) {
                this._closeSize = this._frame.$tabBar.outerHeight();
                this._parent.$bar.removeClass('wcSplitterHidden');
            } else {
                this._closeSize = 0;
                this._parent.$bar.addClass('wcSplitterHidden');
            }
        },

        // Retrieves the bounding rect for this collapser.
        __rect: function () {
            var offset = this.$frame.offset();
            var width = this.$frame.width();
            var height = this.$frame.height();

            var panel = this._frame.panel();
            if (panel) {
                // Determine the size to expand the drawer based on the size of the panel.
                if (this._position === wcDocker.DOCK.BOTTOM) {
                    height = panel._size.y;
                    width = width / 3;
                } else {
                    width = panel._size.x;
                    height = height / 3;
                }
            }

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {

            var data = {};
            data.closeSize = this._closeSize;
            data.frame = this._frame.__save();
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._closeSize = data.closeSize;
            this._frame.__restore(data.frame, docker);
            this.__adjustCollapsedSize();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            if (this._frame) {
                this._frame.__destroy();
                this._frame = null;
            }

            this.__container(null);
            this._parent = null;
        }
    });

    return Module;
});
},
'xgrid/MultiRenderer':function(){
/** @module xgrid/MultiRenderer **/
define([
    "xdojo/declare",
    'xide/types',
    'xgrid/Renderer',
    'dojo/_base/kernel'
], function (declare, types, Renderer,dojo) {
    /**
     * @class module:xgrid/MultiRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        renderers: null,
        selectedRenderer: null,
        lastRenderer: null,
        rendererActionRootCommand: 'View/Layout',
        runAction:function(action){
            action = this.getAction(action);
            if(action.command.indexOf(this.rendererActionRootCommand)!==-1){
                var parentAction = action.getParent ?  action.getParent() : null;
                action._originEvent = 'change';
                this.setRenderer(action.value);
                if(parentAction) {
                    parentAction.set('icon', action.get('icon'));
                    var rendererActions = parentAction.getChildren();
                    _.each(rendererActions, function (child) {
                        child._oldIcon && child.set('icon', child._oldIcon);
                    });
                }
                action.set && action.set('icon', 'fa-check');
                return true;
            }
            return this.inherited(arguments);
        },
        /**
         * Impl. set state
         * @param state
         * @returns {object|null}
         */
        setState:function(state){
            var renderer = state.selectedRenderer ? dojo.getObject(state.selectedRenderer) : null;
            if(renderer){
                this.setRenderer(renderer);
                this.set('collection',this.collection.getDefaultCollection());

            }
            return this.inherited(arguments);
        },
        /**
         * Impl. get state
         * @param state
         * @returns {object}
         */
        getState:function(state){
            state = this.inherited(arguments) || {};
            if(this.selectedRenderer) {
                state.selectedRenderer = this.getSelectedRenderer.declaredClass;
            }
            return state;
        },
        getRendererActions: function (_renderers, actions) {
            var root = this.rendererActionRootCommand,
                thiz = this,
                renderActions = [],
                renderers = _renderers || this.getRenderers(),
                VISIBILITY = types.ACTION_VISIBILITY,
                index = 1;

            actions = actions || [];

            //root
            renderActions.push(this.createAction({
                label: 'Layout',
                command: root,
                icon: 'fa-laptop',
                tab: 'View',
                group: 'Layout',
                mixin:{
                    closeOnClick:false
                },
                onCreate:function(action){
                    action.set('value',thiz.selectedRenderer);
                    action.
                    setVisibility(VISIBILITY.ACTION_TOOLBAR, false).
                    setVisibility(VISIBILITY.RIBBON,{expand:true});
                }
            }));
            /**
             *
             * @param col
             * @private
             */
            function createEntry(label, icon, Renderer) {
                var selected = Renderer == thiz.selectedRenderer;
                /*
                var mapping = {
                    "change":{
                        //action to widget mapping
                        input:ActionValueWidget.createTriggerSetting('value','checked',function(event,value,mapping){
                            //return this.actionValue;
                            return value;
                        }),

                        //widget to action mapping
                        output:utils.mixin(ActionValueWidget.createTriggerSetting('checked','value',function(){
                            return this.actionValue;
                        }),{
                            ignore:function(event,value){
                                return value === false;
                            }
                        })
                    }
                };
                */

                /*
                var widgetArgs = {
                    actionValue:Renderer,
                    mapping:mapping,
                    checked: selected,
                    label:label
                };
                */

                var keycombo = 'shift f' + index;
                index++;

                var _renderer = Renderer;
                var _action = null;
                var ACTION = null;

                _action = thiz.createAction({
                    label: label,
                    command: root + '/' + label,
                    icon: icon,
                    tab: 'View',
                    group: 'Layout',
                    mixin:{
                        value:Renderer,
                        addPermission:true,
                        closeOnClick:false
                    },
                    keycombo:[keycombo],
                    onCreate:function(action){
                        action._oldIcon = icon;
                        action.actionType = types.ACTION_TYPE.SINGLE_TOGGLE;
                        action.set('value',Renderer);
                        /*
                        var _visibilityMixin = {
                            widgetArgs: {
                                actionValue:Renderer,
                                mapping:mapping,
                                group: thiz.id+'_renderer_all',
                                checked: selected,
                                label:label,
                                iconClass: null,
                                title:'test'
                            }
                        };
                        action.setVisibility(types.ACTION_VISIBILITY_ALL,_visibilityMixin);
                        */

                    }
                });
                renderActions.push(_action);
                return renderActions;
            }

            _.each(renderers,function (Renderer) {
                var impl = Renderer.Implementation || Renderer.prototype;
                if (impl._getLabel) {
                    createEntry(impl._getLabel(), impl._getIcon(), Renderer);
                }
            });
            return renderActions;
        },
        getSelectedRenderer:function(){
            return this.selectedRenderer.prototype;
        },
        startup: function () {
            var thiz = this;
            this._on('onAddGridActions', function (evt) {
                var renderActions = thiz.getRendererActions(thiz.getRenderers(), evt.actions);
                renderActions.forEach(function (action) {
                    evt.actions.push(action);
                });
            });
            this.inherited(arguments);
            //add new root class
            this.selectedRenderer && $(this.domNode).addClass(this.getSelectedRenderer()._getLabel());
        },
        getRenderers: function () {
            return this.renderers;
        },
        setRenderer: function (renderer,_focus) {
            //track focus and selection
            var self = this,
                selection = self.getSelection(),
                focused = self.getFocused(),
                selected = self.getSelectedRenderer();

            var args = {
                'new': renderer,
                'old': self.selectedRenderer
            };
            var node$ = $(this.domNode);
            //remove renderer root css class
            node$.removeClass(selected._getLabel());
            //call renderer API
            selected.deactivateRenderer.apply(this, args);

            //tell everyone
            this._emit('onChangeRenderer', args);

            //update locals
            this.lastRenderer = this.selectedRenderer;
            this.selectedRenderer = renderer;

            //?
            this.selectedRendererClass = renderer.prototype.declaredClass;

            //add new root class
            node$.addClass(renderer.prototype._getLabel());

            //call  API
            renderer.prototype.activateRenderer.apply(this, args);

            //reset store
            this.collection.reset();

            //refresh, then restore sel/focus
            var refresh = this.refresh();

            refresh && refresh.then && refresh.then(function(){
                self._emit('onChangedRenderer', args);
            });
            return refresh;
        }
    };


    /**
     * Forward custom renderer method
     * @param who
     * @param method
     */
    function forward(who,method){
        Implementation[method]=function(){
            var parent = this.getSelectedRenderer();
            if (parent[method]) {
                return parent[method].apply(this, arguments);
            }
            return this.inherited(arguments);
        };
    }

    //@TODO: this should be all public methods in dgrid/List ?
    _.each(['row','removeRow','renderRow','insertRow','activateRenderer','deactivateRenderer'],function(method){
        forward(Implementation,method);
    });


    //package via declare
    var _class = declare('xgrid.MultiRenderer', null, Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'xdocker/Splitter2':function(){
define([
    "dcl/dcl",
    'wcDocker/splitter',
    'xide/mixins/EventedMixin'
], function (dcl,wcSplitter,EventedMixin) {



    /**
     * Function to set a wcFrame's tab bar elements
     * @param frame
     * @param hide
     */
    function hideFrameTabBar(frame,hide){
        _.invoke(frame.$tabBar, frame.$buttonBar,'css',['display',hide ===true ? 'none' : 'inherit']);
    }
    /**
     * Function to preserve a wcFrame's most important properties before collapse:
     *  - minSize
     *  - pos
     *  - all child panel's minSize
     *  - all child panel's titles
     *
     * @param frame
     * @param hide
     */
    function setFramePropsMin(frame,hide){

        frame._saveProp('minSize',[0,0]);
        frame._saveProp('pos');
        frame._saveProp('showTitlebar',[]);//call with undefined

        hide!==false && hideFrameTabBar(frame,hide);

        frame._panelList && _.each(frame._panelList,function(panel){
            //save title & min size
            panel._saveProp('minSize',[0,0]);
            panel._saveProp('title');
        });
        hide && frame.showTitlebar && frame.showTitlebar(false);
    }
    /**
     * Function to restore wcFrame properties: minSize, title, showTitlebar
     * @param frame
     */
    function restoreFrameProps(frame){
        hideFrameTabBar(frame,false);
        _.each(frame._panelList,function(panel){
            var ms = panel._restoreProp('minSize',false);
            ms && panel.minSize(ms.x, ms.y);
            panel._restoreProp('title');
        });
        frame._restoreProp('showTitlebar');
    }

    /**
     * Extend splitter for evented and collapse functions
     */
    return dcl([wcSplitter,EventedMixin.dcl], {
        _lastCollapsed:null,
        _isCollapsed:false,
        // Updates the size of the splitter.
        isExpanded:function(){
            return this._lastCollapsed ==null;
        },
        isCollapsed:function(){
            return this._lastCollapsed !=null;
        },
        collapse:function(side,pos){
            this._isCollapsed = true;
            this._saveProp('pos');
            setFramePropsMin(this._pane[0],side==0);
            setFramePropsMin(this._pane[1],side==1);
            this._lastCollapsed = side;
            this.pos( pos!=null ? pos : 1);
        },
        expand:function(){
            this._isCollapsed = false;
            restoreFrameProps(this._pane[0]);
            this._restoreProp('pos');
            restoreFrameProps(this._pane[1]);
            this._lastCollapsed = null;
        }
    });
});
},
'xide/popup':function(){
/** @module xide/popup **/
define([
    "dojo/dom-geometry", // domGeometry.isBodyLtr
    "dojo/dom-style", // domStyle.set
    "dojo/_base/lang", // lang.hitch
    "dijit/place",
    "xide/$",
    "dcl/dcl"
], function (domGeometry, domStyle,lang,place,$,dcl) {
    /**
     * jQuery port of dijit/popup and deals with native HTML elements only.
     * @class module:xide/popup
     */
    var instance = null;
    var Module = dcl(null, {
        // _stack: dijit/_WidgetBase[]
        //		Stack of currently popped up widgets.
        //		(someone opened _stack[0], and then it opened _stack[1], etc.)
        _stack: [],
        // _beginZIndex: Number
        //		Z-index of the first popup.   (If first popup opens other
        //		popups they get a higher z-index.)
        _beginZIndex: 1000,
        _idGen: 1,
        _repositionAll: function(){
            // summary:
            //		If screen has been scrolled, reposition all the popups in the stack.
            //		Then set timer to check again later.

            if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
                var oldPos = this._firstAroundPosition,
                    newPos = domGeometry.position(this._firstAroundNode, true),
                    dx = newPos.x - oldPos.x,
                    dy = newPos.y - oldPos.y;

                if(dx || dy){
                    this._firstAroundPosition = newPos;
                    for(var i = 0; i < this._stack.length; i++){
                        var style = this._stack[i].wrapper.style;
                        style.top = (parseFloat(style.top) + dy) + "px";
                        if(style.right == "auto"){
                            style.left = (parseFloat(style.left) + dx) + "px";
                        }else{
                            style.right = (parseFloat(style.right) - dx) + "px";
                        }
                    }
                }

                this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
            }
        },
        /**
         * Initialization for widgets that will be used as popups.
         * Puts widget inside a wrapper DIV (if not already in one),and returns pointer to that wrapper DIV.
         * @param node
         * @returns {HTMLElement}
         * @private
         */
        _createWrapper: function(node,args){
            var wrapper = $(node).data('_popupWrapper');
            var owner = $(node).data('owner');
            if(!wrapper){
                var $wrapper = $("<div class='xPopup' style='display:none' role='region'></div>" );
                $('body').append(wrapper);
                $wrapper.append($(node));
                wrapper = $wrapper[0];
                var s = node.style;
                s.display = "";
                s.visibility = "";
                s.position = "";
                s.top = "0px";
                if(owner){
                    if(owner._on){
                        owner._on('destroy',function(e){
                            $wrapper.remove();
                        });
                    }
                }
                $(node).data('_popupWrapper',wrapper);
            }
            return wrapper;
        },
        /**
         * Moves the popup widget off-screen.
         * Do not use this method to hide popups when not in use, because
         * that will create an accessibility issue: the offscreen popup is
         * still in the tabbing order.
         * @param node {HTMLElement}
         * @returns {*}
         */
        moveOffScreen: function(node,args){
            // Create wrapper if not already there
            var wrapper = this._createWrapper(node,args);
            // Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
            var ltr = true,
                style = {
                    visibility: "hidden",
                    top: "-9999px",
                    display: ""
                };
            style[ltr ? "left" : "right"] = "-9999px";
            style[ltr ? "right" : "left"] = "auto";
            $(wrapper).css(style);
            return wrapper;
        },
        /**
         * Hide this popup widget (until it is ready to be shown).
         * Initialization for widgets that will be used as popups.
         * Also puts widget inside a wrapper DIV (if not already in one)
         * If popup widget needs to layout it should
         * do so when it is made visible, and popup._onShow() is called.
         * @param widget {HTMLElement}
         */
        hide: function(widget,args){
            // Create wrapper if not already there
            var wrapper = this._createWrapper(widget,args);
            $(wrapper).css({
                display: "none",
                height: "auto",			// Open() may have limited the height to fit in the viewport,
                overflowY: "visible",	// and set overflowY to "auto".
                border: ""			// Open() may have moved border from popup to wrapper.
            });
            // Open() may have moved border from popup to wrapper.  Move it back.
            var node = widget;
            if("_originalStyle" in node){
                node.style.cssText = node._originalStyle;
            }
        },
        getTopPopup: function(){
            // summary:
            //		Compute the closest ancestor popup that's *not* a child of another popup.
            //		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
            var stack = this._stack;
            for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
                /* do nothing, just trying to get right value for pi */
            }
            return stack[pi];
        },
        /**
         * Popup the widget at the specified position
         * example:
         *   opening at the mouse position
         *      popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
         *
         * example:
         *  opening the widget as a dropdown
         *      popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
         *
         *  Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
         *  (fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
         * @param args
         * @returns {*}
         */
        open: function(args){
            // summary:
            //		Popup the widget at the specified position
            //

            var last = null;



            var isLTR = true;
            var self = this,
                stack = this._stack,
                widget = args.popup,
                node = args.popup,
                orient = args.orient || ["below", "below-alt", "above", "above-alt"],
                ltr = args.parent ? args.parent.isLeftToRight() : isLTR,
                around = args.around,
                owner = $(node).data('owner'),
                extraClass = args.extraClass || "",
                id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

            // If we are opening a new popup that isn't a child of a currently opened popup, then
            // close currently opened popup(s).   This should happen automatically when the old popups
            // gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
            while(stack.length && (!args.parent || $.contains(args.parent.domNode,stack[stack.length - 1].widget.domNode))){
                this.close(stack[stack.length - 1].widget);
            }

            // Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
            // off screen) so we can do sizing calculations.
            var wrapper = this.moveOffScreen(widget,args);
            //console.error('popup open s',$(owner.delegate.domNode).zIndex());
            //console.log('owner',owner);

            var $wrapper = $(wrapper);

            // Limit height to space available in viewport either above or below aroundNode (whichever side has more
            // room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
            // dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
            var maxHeight, popupSize = domGeometry.position(node);
            if("maxHeight" in args && args.maxHeight != -1){
                maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
            }else{
                var viewport = {
                    t:0,
                    l:0,
                    h:$(window).height(),
                    w:$(window).width()
                };
                var aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
                maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
            }
            //maxHeight = 300;
            if(popupSize.h > maxHeight){
                // Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
                // and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
                var cs = domStyle.getComputedStyle(node),
                    borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;

                $wrapper.css({
                    'overflow-y': "scroll",
                    height: maxHeight + "px",
                    border: borderStyle	// so scrollbar is inside border
                });
                node._originalStyle = node.style.cssText;
                node.style.border = "none";
            }

            $wrapper.attr({
                id: id,
                "class": "xPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
                dijitPopupParent: args.parent ? args.parent.id : ""
            });
            $wrapper.css('z-index',this._beginZIndex + stack.length);
            if(stack.length === 0 && around){
                // First element on stack. Save position of aroundNode and setup listener for changes to that position.
                this._firstAroundNode = around;
                //this._firstAroundPosition = domGeometry.position(around, true);
                var offset = $(around).offset();
                this._firstAroundPosition = {
                    w:$(around).width(),
                    h:$(around).height(),
                    x:offset.left,
                    y:offset.top
                };
                //this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
                this._aroundMoveListener = setTimeout(function(){
                    self._repositionAll();
                }, 50);
            }

            // position the wrapper node and make it visible
            var layoutFunc = null ; //widget.orient ? lang.hitch(widget, "orient") : null;
            var best = around ?
                place.around(wrapper, around, orient, ltr, layoutFunc) :
                place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
                    layoutFunc);

            wrapper.style.visibility = "visible";
            node.style.visibility = "visible";	// counteract effects from _HasDropDown


            var handlers = [];
            $(wrapper).on('keydown',function(evt){
                if(evt.keyCode == 27 && args.onCancel){//esape
                    evt.stopPropagation();
                    evt.preventDefault();
                    args.onCancel();
                }else if(evt.keyCode == 9){//tab
                    evt.stopPropagation();
                    evt.preventDefault();
                    var topPopup = self.getTopPopup();
                    if(topPopup && topPopup.onCancel){
                        topPopup.onCancel();
                    }
                }
            });
            // watch for cancel/execute events on the popup and notify the caller
            // (for a menu, "execute" means clicking an item)
            if(widget.onCancel && args.onCancel){
                handlers.push(widget.on("cancel", args.onCancel));
            }

            $(node).css('display','block');
            /*
             handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
             var topPopup = this.getTopPopup();
             if(topPopup && topPopup.onExecute){
             topPopup.onExecute();
             }
             })));
             */
            stack.push({
                widget: widget,
                wrapper: wrapper,
                parent: args.parent,
                onExecute: args.onExecute,
                onCancel: args.onCancel,
                onClose: args.onClose,
                handlers: handlers
            });
            if(widget.onOpen){
                // TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
                widget.onOpen(best);
            }
            $(wrapper).addClass(extraClass);

            //console.log('owner '+highZ(owner.delegate.domNode,10) + ' = ' + usedZ,last);

            return best;
        },

        close: function(/*Widget?*/ popup){
            // summary:
            //		Close specified popup and any popups that it parented.
            //		If no popup is specified, closes all popups.


            var stack = this._stack;
            // Basically work backwards from the top of the stack closing popups
            // until we hit the specified popup, but IIRC there was some issue where closing
            // a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
            // closing C might close B indirectly and then the while() condition will run where stack==[A]...
            // so the while condition is constructed defensively.
            while((popup && _.some(stack, function(elem){
                return elem.widget == popup;
            })) ||

            (!popup && stack.length)){
                var top = stack.pop(),
                    widget = top.widget,
                    onClose = top.onClose;

                if(widget.onClose){
                    widget.onClose();
                }

                var h;

                while(h = top.handlers.pop()){
                    h.remove();
                }

                // Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
                if(widget && widget){
                    this.hide(widget);
                }
                if(onClose){
                    onClose();
                }
            }

            $(popup).css('display','none');

            if(stack.length === 0 && this._aroundMoveListener){
                clearTimeout(this._aroundMoveListener);
                this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
            }
        }
    });
    instance  = new Module();
    return instance;
});
},
'xgrid/Base':function(){
/** @module xgrid/Base **/
define([
    "xdojo/declare",
    'xide/types',
    'xgrid/types',
    'xide/utils/ObjectUtils',   //possibly not loaded yet
    'xide/utils',
    'dgrid/OnDemandGrid',
    'xgrid/Defaults',
    'xgrid/Layout',
    'xgrid/Focus',
    'xgrid/ListRenderer',
    'xgrid/ThumbRenderer',
    'xgrid/TreeRenderer',
    'dgrid/util/misc'

], function (declare,types,
             xTypes,ObjectUtils,utils,
             OnDemandGrid,Defaults,Layout,Focus,
             ListRenderer,ThumbRenderer,TreeRenderer,
             miscUtil){

    var BASE_CLASSES = ['EVENTED','GRID','EDITOR','RENDERER','DEFAULTS','LAYOUT','FOCUS','i18'];
    var DEFAULT_GRID_FEATURES = types.DEFAULT_GRID_FEATURES;
    var GRID_BASES = types.GRID_BASES;
    var DEFAULT_GRID_OPTIONS = types.DEFAULT_GRID_OPTIONS;

    /**
     * Short hand version of declare.classFactory for our base grid
     * @param name
     * @param bases
     * @param extraClasses
     * @param implementation
     * @private
     * @returns {*}
     */
    function classFactory(name, bases, extraClasses,implementation) {
        return declare.classFactory(name, bases, extraClasses, implementation,GRID_BASES);
    }
    /**
     * Default implementation
     * @class module:xgrid/Base
     * @extends module:dgrid/List
     * @extends module:xide/mixins/EventedMixin
     */
    var Implementation = {
        _isHighlighting:false,
        _featureMap:{},
        isRendered:function(item){
            item = this._normalize(item);
            var collection = this.collection;
            if(item){
                var itemData = item.data;
                var idProp = collection['idProperty'];
                var nodes = this.getRows(true);
                if(nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        var row = this.row(node);
                        if (row && row.data && row.data && itemData && row.data[idProp] === itemData[idProp]) {
                            return true;
                        }
                    }
                }

            }
            return false;
        },
        /**
         * highlightRow in dgrid/List leaks and is anyway not needed.
         */
        highlightRow:function(){},
        getParent:function(){
            return this._parent;
        },
        get:function(what){
            var parent = this.getParent();
            if(what==='iconClass') {
                //docker:
                if (parent && parent.icon) {
                    return parent.icon();
                }
            }
            return this.inherited(arguments);
        },
        set:function(what,value){
            var parent = this.getParent();
            if(what==='iconClass'){
                var _set = parent.set;
                if(_set) {
                    _set.apply(parent, [what, value]);
                }else if(parent && parent.icon){
                    parent.icon(value);
                    return true;
                }
            }
            if(what==='title' && value && parent){
                var _set = parent.set;
                if(_set){
                    _set.apply(parent,[what,value]);
                }else if(parent && parent.title){
                    parent.title(value);
                }
            }
            if(what==='loading' && parent){

                if(parent){
                    //docker:
                    if(parent.startLoading) {
                        var icon = parent._options.icon;
                        if (value === true) {
                            parent.startLoading('', 0.5);
                            parent.icon('fa-spinner fa-spin');
                        } else {
                            parent.finishLoading();
                            parent.icon(icon);
                        }
                        return true;
                    }else if(parent.set){
                        parent.set('loading',value);
                    }
                }
            }
            return this.inherited(arguments);
        },
        runAction:function(action){
            if(action.command==types.ACTION.HEADER){
                this._setShowHeader(!this.showHeader);
            }
            return this.inherited(arguments);
        },
        highlight:function(highlight){
            var node = $(this.domNode.parentNode);
            if(highlight){
                if(this._isHighlighting){
                    return;
                }
                this._isHighlighting = true;
                node.addClass('highlight');
            }else{

                this._isHighlighting=false;
                node.removeClass('highlight');
            }
        },
        getState:function(state) {
            state = this.inherited(arguments) || {};
            state.showHeader = this.showHeader;
            return state;
        },
        postMixInProperties: function () {
            var state = this.state;
            if (state) {
                this.showHeader = state.showHeader;
            }
            return this.inherited(arguments);
        },
        renderArray:function(array){
            this._lastData = array;
            return this.inherited(arguments);
        },
        getData:function(){
            return this._lastData;
        },
        refreshItem:function(item,silent){
            if (silent) {
                this._muteSelectionEvents = true;
            }
            this.collection.emit('update', {
                target: item
            });
            if (silent) {
                this._muteSelectionEvents = false;
            }
        },
        onShow:function(){
            this._emit(types.EVENTS.ON_VIEW_SHOW,this);
            return this.inherited(arguments);
        },
        isActive:function(testNode){
            return utils.isDescendant(this.domNode,testNode || document.activeElement);
        },
        _showHeader:function(show){
            $(this.domNode).find('.dgrid-header').each(function(i,el){
                $(el).css('display',show ? '' : 'none' );
            });

            $(this.domNode).find('.dgrid-scroller').each(function(i,el){
                $(el).css('margin-top',show ? 26 : 0 );
            });

        },
        destroy:function(){
            this._emit('destroy',this);
            return this.inherited(arguments);
        },
        hasFeature:function(name){
            return _contains(['name'],_.keys(this._featureMap));
        },
        /**
         * Return current row's elements or data
         * @param domNodes {boolean} return dom instead of data. Default false.
         * @param filterFunction
         * @returns {*}
         */
        getRows:function(domNodes,filterFunction){
            var result = [],
                self = this;
            var nodes = $(self.domNode).find('.dgrid-row');
            _.each(nodes,function(node){
                var _row = self.row(node);
                if(_row && _row.element){
                    result.push(_row[domNodes ? 'element' : 'data']);
                }
            });
            if (filterFunction) {
                return result.filter(filterFunction);
            }
            return result;
        },
        startup:function(){
            var result = this.inherited(arguments);
            if(this.columns) {
                _.each(this.columns,function(column){
                    if (column.width) {
                        this.styleColumn(parseInt(column.id), 'width:' + column.width);
                    }
                },this);
            }

            var self = this;
            this.showExtraSpace && this.on('dgrid-refresh-complete',function(){
                var rows = self.getRows();
                if(!rows.length){
                    return;
                }
                var _extra = $(self.contentNode).find('.dgrid-extra');
                if(!_extra.length){
                    _extra = $('<div class="dgrid-extra" style="width:100%;height:80px"></div>');
                    $(self.contentNode).append(_extra);
                    _extra.on('click',function(){
                        self.deselectAll();
                    });
                    _extra.on('contextmenu',function(){
                        self.deselectAll();
                    })
                }
            });

            return result;
        }
    };
    /**
     * Create root class with declare and default implementation
     */
    var _default = declare('xgrid.Default', null, Implementation);

    /**
     * 2-dim array search
     * @param left {string[]}
     * @param keys {string[]}
     * @returns {boolean}
     * @private
     */
    function _contains(left, keys) {
        return keys.some(function (v) {
            return left.indexOf(v) >= 0;
        });
    }

    /**
     * Find default keys in a feature struct and recompse user feature
     * @param feature {object} feature struct
     * @param defaultFeature {object}
     * @returns {object} recomposed feature
     */
    function getFeature(feature, defaultFeature) {
        //is new feature, return the mix of default props and customized version
        if (_contains(['CLASS','CLASSES','IMPLEMENTATION'],_.keys(feature))) {
            return utils.mixin(utils.cloneKeys(defaultFeature),feature);
        }
        return defaultFeature;
    }

    /**
     * Grid class factory
     * @param name {string} A name for the class created
     * @param baseClass {object} the actual implementation (default root class, declared above)
     * @param features {object} the feature map override
     * @param bases {object} the base grid classes map override
     * @param args {object} root class override
     * @param _defaultBases {object}
     * @memberOf module:xgrid/Base
     * @returns {module:xgrid/Base}
     */
    function createGridClass(name, baseClass, features, gridClasses, args,_defaultBases) {
        var _isNewBaseClass = false;
        baseClass = baseClass || _default;
        //simple case, no base class and no features
        if (!baseClass && !features) {
            return _default;
        }
        if (baseClass) {
            _isNewBaseClass = _contains(BASE_CLASSES,_.keys(gridClasses));
            var defaultBases = utils.cloneKeys(_defaultBases || GRID_BASES);
            if (_isNewBaseClass) {
                utils.mixin(defaultBases, gridClasses);
                //remove empty
                defaultBases = _.pick(defaultBases, _.identity);
            }
            //recompose base class
            baseClass = classFactory(name, defaultBases, [_default], baseClass);
        }

        var newFeatures = [],
            featureMap = {};

        //case: base class and features
        if (baseClass && features) {
            var _defaultFeatures = utils.cloneKeys(DEFAULT_GRID_FEATURES);
            utils.mixin(_defaultFeatures, features);

            for (var featureName in _defaultFeatures) {
                var feature = _defaultFeatures[featureName];
                if (!_defaultFeatures[featureName]) {
                    continue;
                }
                var newFeature = null;
                if (feature === true) {
                    //is a base feature
                    newFeature = DEFAULT_GRID_FEATURES[featureName];
                } else if (DEFAULT_GRID_FEATURES[featureName]) {
                    //is new/extra feature
                    newFeature = getFeature(feature, DEFAULT_GRID_FEATURES[featureName]);
                } else {
                    //go on
                    newFeature = feature;
                }
                if (newFeature) {
                    var featureClass = classFactory(featureName, newFeature['CLASSES'] || [], [newFeature['CLASS']], newFeature['IMPLEMENTATION']);
                    newFeatures.push(featureClass);
                    featureMap[featureName]=featureClass;
                }
            }
            //recompose
            if (newFeatures.length > 0) {
                baseClass = classFactory(name, [baseClass], newFeatures, args);
            }
            //complete
            baseClass.prototype._featureMap = featureMap;
        }
        return baseClass;
    }


    var Module = createGridClass('xgrid/Base',{
            options: utils.clone(DEFAULT_GRID_OPTIONS)
        },
        //features
        {
            SELECTION: true,
            KEYBOARD_SELECTION: true,
            PAGINATION: false,
            COLUMN_HIDER: false
        },
        //bases, no modification
        null,
        {

        });

    Module.createGridClass = createGridClass;

    //track defaults on module
    Module.classFactory = classFactory;
    Module.DEFAULT_GRID_FEATURES = DEFAULT_GRID_FEATURES;
    Module.DEFAULT_GRID_BASES = GRID_BASES;
    Module.DEFAULT_GRID_OPTIONS = DEFAULT_GRID_OPTIONS;
    Module.DEFAULT_GRID_OPTION_KEYS = types.DEFAULT_GRID_OPTION_KEYS;

    return Module;

});
},
'xide/views/_LayoutMixin':function(){
/** module:xide/views/_LayoutMixin **/
define([
    "xdojo/declare",
    "dcl/dcl",
    "xide/types",
    'xdocker/Docker2',
    "xide/utils",
    "xide/layout/_TabContainer"
], function (declare,dcl,types,Docker,utils,_TabContainer) {
    /**
     * @class module:xide/views/_LayoutMixin
     */
    var Implementation = {
        _docker:null,
        _parent:null,
        __right:null,
        __bottom:null,
        __masterPanel:null,
        __bottomTabContainer:null,
        defaultPanelOptions:null,
        defaultPanelType:'DefaultFixed',
        reparent:true,
        getTop:function(){
          return this._parent;
        },
        resize:function(){
            if(this._docker){
                this._docker.resize();
            }
            if(this.inherited) {
                return this.inherited(arguments);
            }
        },
        getDockerTargetNode:function(){
            return null;
        },
        /**
         * @param container {HTMLElement|module:xide/widgets/_Widget}
         * @returns {module:xdocker/Docker2}
         */
        getDocker:function(container){
            var thiz = this;
            if(!this._docker){
                var _node = this._domNode || this.domNode;
                var _dst = this.getDockerTargetNode() || container || _node.parentNode;
                thiz._docker = Docker.createDefault(_dst);
                thiz._oldParent = thiz._parent;
                var defaultOptions  = this.defaultPanelOptions || {
                        w: '100%',
                        title:false
                    };

                var parent = thiz._docker.addPanel(this.defaultPanelType, types.DOCKER.TOP, null,defaultOptions);
                this.reparent && dojo.place(_node,parent.containerNode);
                this.reparent && thiz._docker.$container.css('top',0);
                thiz._parent = parent;
                thiz.__masterPanel = parent;
                !defaultOptions.title && parent._parent.showTitlebar(false);
                _node.id = this.id;
                thiz.add(thiz._docker);
            }
            return thiz._docker;
        },
        getPanelSplitPosition:function(type){
            if(type == types.DOCKER.DOCK.RIGHT && this.__right){
                var splitter = this.__right.getSplitter();
                if(splitter){
                    return splitter.pos();
                }
            }
            return false;
        },
        setPanelSplitPosition:function(type,position){
            var right = this.__right;
            if(type == types.DOCKER.DOCK.RIGHT && right){
                var splitter = right.getSplitter();
                if(position==1) {
                    splitter._isToggledMin = true;
                    splitter._isToggledMax = true;
                }else if(position<1 && position >0){
                    splitter._isToggledMin = false;
                    splitter._isToggledMax = false;
                }
                splitter.pos(position);
            }
        },
        openRight:function(open){
            var thiz = this,
                rightSplitPosition=thiz.getPanelSplitPosition(types.DOCKER.DOCK.RIGHT);
            if(!open && rightSplitPosition<1){
                //panel is open: close it
                thiz.setPanelSplitPosition(types.DOCKER.DOCK.RIGHT,1);
            }else if(open && rightSplitPosition==1){
                //closed, open it and show properties
                thiz.setPanelSplitPosition(types.DOCKER.DOCK.RIGHT,0.6);
            }
        },
        _getRight:function(){
            return this.__right;
        },
        _getBottom:function(){
            return this.__bottom;
        },
        getBottomTabContainer:function(create){
            if(this.__bottomTabContainer){
                return this.__bottomTabContainer;
            }else if(create!==false){
                this. __bottomTabContainer = utils.addWidget(_TabContainer, {
                    direction: 'below'
                }, null,this.getBottomPanel(false, 0.2), true);

            }
            return this.__bottomTabContainer;
        },
        _addPanel:function(props,location,title,startPosition,type,target){
            var docker = this.getDocker();
            var panel = docker.addPanel(type || 'DefaultFixed', location , target ===false ? null : (target || this._parent), props || {
                w: '30%',
                h:'30%',
                title:title||false
            });
            if(!title) {
                panel._parent.showTitlebar(false);
            }
            if(startPosition){
                var splitter = panel.getSplitter();
                if(startPosition==1 || startPosition==0) {
                    splitter.pos(startPosition);
                }else {
                    splitter.pos(0.6);
                }
            }
            return panel;
        },
        getBottomPanel:function(title,startPosition,type,mixin,target){
            if(this.__bottom || this._getBottom()){
                return this.__bottom || this._getBottom();
            }
            var create = true;
            if(create!==false) {
                this.__bottom = this._addPanel(utils.mixin({
                    w: '30%',
                    title: title || '  '
                },mixin), types.DOCKER.DOCK.BOTTOM, title,startPosition,type,target);
            }
            return this.__bottom;
        },
        getRightPanel:function(title,startPosition,type,props){
            if(this.__right || this._getRight()){
                return this.__right || this._getRight();
            }
            props = utils.mixin({
                w: '30%',
                title:title || '  '
            },props);
            var panel = this._addPanel(props,types.DOCKER.DOCK.RIGHT,title,null,type,props.target);
            this.__right = panel;
            return panel;
        }
    };
    //package via declare
    var _class = declare("xide/views/_LayoutMixin",null,Implementation);
    _class.Implementation = Implementation;
    _class.dcl = dcl(null,Implementation);
    return _class;
});

},
'xide/layout/_TabContainer':function(){
/** @module xide/layout/_TabContainer **/
define([
    "dcl/dcl",
    'xide/utils',
    "xide/_base/_Widget",
    "xide/container/_PaneBase"
], function (dcl,utils,_Widget,_PaneBase) {


    var TabPaneClass = dcl(_PaneBase,{
        declaredClass:'xide/layout/_TabPane',
        postMixInProperties:function(){
            var active = this.selected ? 'active' : '';
            this.templateString = '<div attachTo="containerNode" style="height:inherit;width:inherit;position:relative;" class="tab-pane ' + active + '"></div>';
        },
        __init:function(){
            var panel = this.$toggleNode;
            this.__addHandler(panel,'hidden.bs.tab','_onHided');
            this.__addHandler(panel,'hide.bs.tab','_onHide');
            this.__addHandler(panel,'shown.bs.tab','_onShown');
            this.__addHandler(panel,'show.bs.tab','_onShow');
        }
    });

    var TabContainer = dcl(_Widget,{
        declaredClass:'xide/layout/_TabContainer',
        tabClass:TabPaneClass,
        tabs:null,
        tabBar:null,
        tabContentNode:null,
        padding:'0px',
        containerCSSClass:'',
        direction:'above',
        navBarClass:'',
        startup:function(){
            if(this._started){
                return;
            }
        },
        templateString:'<div class="${!containerCSSClass} tabbable tabs-${!direction}" style="height: inherit;" attachTo="containerNode">' +
        '<ul attachTo="tabBar" class="nav nav-tabs" role="tablist" />' +
        '<div attachTo="tabContentNode" style="width: inherit; height: 100%;" class="tab-content"/>' +
        '</div>',
        getTab:function(name){
            return _.find(this._widgets,{
                title:name
            });
        },
        _unselectAll:function(){
            _.each(this._widgets,function(tab){
                tab.unselect();
            });
        },
        onShowTab:function(tab){
            if(this._parent && this._parent.resize){
                //this._parent.resize();
            }
            //this.resize();
            this._emit('selectChild',tab);
        },
        getSelected:function(){
            for (var i = 0; i < this.tabs.length; i++) {
                var obj = this.tabs[i];
                if(obj.pane.selected){
                    return obj.pane;
                }
            }
        },
        selectChild:function(mixed){
            var tab = mixed;
            if(mixed!==null) {
                if (_.isString(mixed)) {
                    tab = this.getTab(mixed);
                }else if(_.isNumber(mixed)){
                    tab = this._widgets[0];
                }
                if (tab && tab.select) {
                    this._unselectAll();
                    tab.select();
                }
            }
            return tab;
        },
        addWidget:function(widgetProto, ctrArgsIn, delegate, parent, startup, cssClass,baseClasses,select,classExtension){
            var target = parent;
            if(widgetProto.isContainer){
            }else{
                target = this._createTab(this.tabClass,{
                    title:ctrArgsIn.title,
                    icon:ctrArgsIn.icon,
                    selected:ctrArgsIn.selected,
                    ignoreAddChild:true
                });
            }
            return target;
        },
        resize:function(){
            if(this.tabBar){
                switch (this.direction){
                    case 'left':
                    case 'right':{
                        this.$tabContentNode.css('width', '');
                        break;
                    }
                    case 'above':
                    case 'below':{
                        if(this.$containerNode && this.resizeContainer!==false) {
                            var _total = this.$containerNode.height();
                            var _toolbar = this.$tabBar.height();
                            this.$tabContentNode.css('height', _total - _toolbar);
                        }
                        break;
                    }
                }
            }

            _.each(this._widgets,function(w){
               w.resize();
            });
        },
        _createTab:function(tabClass,options){
            !this.tabs && (this.tabs = []);
            var active = this.tabs.length == 0 ? 'active' : '',
                icon = options.icon || '',
                title = options.title || '',
                selected = options.selected!=null ? options.selected : this.tabs.length ==0;

            var pane = utils.addWidget(tabClass || this.tabClass,{
                title:title,
                icon:icon,
                selected:selected,
                owner:this
            },null,this.tabContentNode,true);

            var tabId = pane.id,
                iconStr = icon ? ' ' +icon : '',
                toggleNodeStr =
                    '<li class="' +active + '">' +
                    '<a href="#'+tabId +'" data-toggle="tab"><span class="' +iconStr  +'"/> ' + title +'</a></li>',
                tabButton = $(toggleNodeStr);

            $(this.tabBar).append(tabButton);


            pane.$toggleNode  = tabButton.find('a[data-toggle="tab"]');
            pane.$selectorNode  = tabButton.find('li');
            pane.$toggleButton  = tabButton;
            pane.__init();
            this.tabs.push({
                id:tabId,
                pane: pane,
                button:tabButton[0]
            });
            this.add(pane,null,false);
            return pane;
        },
        removeChild:function(tab,selectNew){
            tab = _.isString(tab) ? this.getTab(tab) : tab;
            if(!tab){
                console.error('invalid child !');
                return;
            }
            //@TODO: no no no:
            tab.destroy();
            if(!this._widgets){
                this._widgets=[];
            }
            this._widgets.remove(tab);
            if(selectNew!==false) {
                var newTab = this._widgets[this._widgets.length - 1];
                if (newTab) {
                    this.resize();
                    this.selectChild(newTab);
                }
            }
        },
        empty:function(){
            while(this._widgets.length){
                this.removeChild(this._widgets[0],false);
            }
        },
        postMixInProperties:function(){
            if(this.direction==='below'){
                this.templateString = '<div class="${!containerCSSClass} tabbable tabs-${!direction}" style="height: inherit;" attachTo="containerNode">' +
                    '<div attachTo="tabContentNode" style="width: inherit; padding:${!padding}; height: 100%;" class="tab-content"/>' +
                    '<ul attachTo="tabBar" class="nav nav-tabs" role="tablist" />' +
                    '</div>';
            }
        },

        createTab:function(title,icon,selected,tabClass,mixin){
            return this._createTab(tabClass,utils.mixin({
                icon:icon,
                selected:selected,
                title:title
            },mixin));
        }
    });

    TabContainer.tabClass = TabPaneClass;
    dcl.chainAfter(TabContainer, "postMixInProperties");
    dcl.chainAfter(TabContainer, "resize");

    dcl.chainAfter(TabContainer, "destroy");

    return TabContainer;

});
},
'dojo/errors/RequestError':function(){
define(['./create'], function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
});

},
'xdojo/has':function(){
define([
    'dojo/has'
], function (has) {
    return has;
});
},
'dojo/_base/declare':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor = new Function, counter = 0, cname = "constructor";

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args == "string"){
			name = args;
			args = a;
			a = f;
		}
		f = 0;

		caller = args.callee;
		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args){
		if(typeof name == "string"){
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2){
		var f = this.getInherited(args, a1);
		if(f){ return f.apply(this, a2 || a1 || args); }
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

	function createSubclass(mixins, props){
		return declare([this].concat(mixins), props || {});
	}

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				ctor = new Function;
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},
		
		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
});

},
'dojo/request/xhr':function(){
define([
	'../errors/RequestError',
	'./watch',
	'./handlers',
	'./util',
	'../has'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && !document.addEventListener && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData === 'function';
	});

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;
		response.text = _xhr.responseText;

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		if(!error){
			try{
				handlers(response);
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(util.checkStatus(_xhr.status)){
			this.resolve(response);
		}else{
			error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);

			this.reject(error);
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(evt){
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				}
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onProgress, false);

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			has('native-formdata') && options && options.data && options.data instanceof FormData
		);
		url = response.url;
		options = response.options;

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response);
		}

		var data = options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			var headers = options.headers,
				contentType = 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
});

},
'dojo/domReady':function(){
define(['./has'], function(has){
	var global = (function () { return this; })(),
		doc = document,
		readyStates = { 'loaded': 1, 'complete': 1 },
		fixReadyState = typeof doc.readyState != "string",
		ready = !!readyStates[doc.readyState],
		readyQ = [],
		recursiveGuard;

	function domReady(callback){
		// summary:
		//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
		readyQ.push(callback);
		if(ready){ processQ(); }
	}
	domReady.load = function(id, req, load){
		domReady(load);
	};

	// Export queue so that ready() can check if it's empty or not.
	domReady._Q = readyQ;
	domReady._onQEmpty = function(){
		// summary:
		//		Private method overridden by dojo/ready, to notify when everything in the
		//		domReady queue has been processed.  Do not use directly.
		//		Will be removed in 2.0, along with domReady._Q.
	};

	// For FF <= 3.5
	if(fixReadyState){ doc.readyState = "loading"; }

	function processQ(){
		// Calls all functions in the queue in order, unless processQ() is already running, in which case just return

		if(recursiveGuard){ return; }
		recursiveGuard = true;

		while(readyQ.length){
			try{
				(readyQ.shift())(doc);
			}catch(err){
				console.log("Error on domReady callback: " + err);
			}
		}

		recursiveGuard = false;

		// Notification for dojo/ready.  Remove for 2.0.
		// Note that this could add more tasks to the ready queue.
		domReady._onQEmpty();
	}

	if(!ready){
		var tests = [],
			detectReady = function(evt){
				evt = evt || global.event;
				if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }

				// For FF <= 3.5
				if(fixReadyState){ doc.readyState = "complete"; }

				ready = 1;
				processQ();
			},
			on = function(node, event){
				node.addEventListener(event, detectReady, false);
				readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
			};

		if(!has("dom-addeventlistener")){
			on = function(node, event){
				event = "on" + event;
				node.attachEvent(event, detectReady);
				readyQ.push(function(){ node.detachEvent(event, detectReady); });
			};

			var div = doc.createElement("div");
			try{
				if(div.doScroll && global.frameElement === null){
					// the doScroll test is only useful if we're in the top-most frame
					tests.push(function(){
						// Derived with permission from Diego Perini's IEContentLoaded
						// http://javascript.nwbox.com/IEContentLoaded/
						try{
							div.doScroll("left");
							return 1;
						}catch(e){}
					});
				}
			}catch(e){}
		}

		on(doc, "DOMContentLoaded");
		on(global, "load");

		if("onreadystatechange" in doc){
			on(doc, "readystatechange");
		}else if(!fixReadyState){
			// if the ready state property exists and there's
			// no readystatechange event, poll for the state
			// to change
			tests.push(function(){
				return readyStates[doc.readyState];
			});
		}

		if(tests.length){
			var poller = function(){
				if(ready){ return; }
				var i = tests.length;
				while(i--){
					if(tests[i]()){
						detectReady("poller");
						return;
					}
				}
				setTimeout(poller, 30);
			};
			poller();
		}
	}

	return domReady;
});

},
'dstore/QueryMethod':function(){
define([], function () {
	/*=====
	var __QueryMethodArgs = {
		// type: String
		//		The type of the query. This identifies the query's type in the query log
		//		and the name of the corresponding query engine method.
		// normalizeArguments: Function?
		//		A function that normalizes arguments for consumption by a query engine
		// applyQuery: Function?
		//		A function that takes the query's new subcollection and the query's log entry
		//		and applies it to the new subcollection. This is useful for collections that need
		//		to both declare and implement new query methods.
		// querierFactory: Function?
		//		A factory function that provides a default querier implementation to use when
		//		a collection does not define its own querier factory method for this query type.
	};
	=====*/
	return function QueryMethod(/*__QueryMethodArgs*/ kwArgs) {
		// summary:
		//		The constructor for a dstore collection query method
		// description:
		//		This is the constructor for a collection query method. It encapsulates the following:
		//		* Creating a new subcollection for the query results
		//		* Logging the query in the collection's `queryLog`
		//		* Normalizing query arguments
		//		* Applying the query engine
		// kwArgs:
		//		The properties that define the query method
		// returns: Function
		//		Returns a function that takes query arguments and returns a new collection with
		//		the query associated with it.

		var type = kwArgs.type,
			normalizeArguments = kwArgs.normalizeArguments,
			applyQuery = kwArgs.applyQuery,
			defaultQuerierFactory = kwArgs.querierFactory;

		return function () {
			// summary:
			//		A query method whose arguments are determined by the query type
			// returns: dstore/Collection
			//		A collection representing the query results

			var originalArguments = Array.prototype.slice.call(arguments),
				normalizedArguments = normalizeArguments
					? normalizeArguments.apply(this, originalArguments)
					: originalArguments,
				logEntry = {
					type: type,
					arguments: originalArguments,
					normalizedArguments: normalizedArguments
				},
				querierFactory = this._getQuerierFactory(type) || defaultQuerierFactory;

			if (querierFactory) {
				// Call the query factory in store context to support things like
				// mapping a filter query's string argument to a custom filter method on the collection
				logEntry.querier = querierFactory.apply(this, normalizedArguments);
			}

			var newCollection = this._createSubCollection({
				queryLog: this.queryLog.concat(logEntry)
			});

			return applyQuery ? applyQuery.call(this, newCollection, logEntry) : newCollection;
		};
	};
});

},
'dojo/text':function(){
define(["./_base/kernel", "require", "./has", "./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if( 1 ){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}else if(require.cache && requireCacheUrl.replace('src/lib','src') in require.cache){
			    //support pre-build layers in full debug config
                text = require.cache[requireCacheUrl.replace('src/lib','src')];
            }else if(require.cache && requireCacheUrl.replace('src/build','src') in require.cache){
                //support layers in full release config
                text = require.cache[requireCacheUrl.replace('src/build','src')];
            }
			if(text===notFound){
			    if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});


},
'xide/widgets/Ribbon':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/_base/_Widget',
    "xide/mixins/ActionMixin",
    'xide/action/ActionContext',
    "xide/model/Path",
    'xlang/i18',
    "xide/widgets/_MenuMixin4",
    "xide/layout/_TabContainer",
    "xide/$",
    'xide/popup'
], function (dcl,types,utils,_XWidget,ActionMixin,ActionContext,
             Path,
             i18,_MenuMixin4,_TabContainer,$,popup
){



    //http://localhost/projects/x4mm/Code/xapp/xcf/?debug=true&run=run-release-debug&protocols=false&drivers=false&plugins=false&xblox=debug&files=false&dijit=debug&xdocker=debug&xfile=debug&davinci=debug&dgrid=debug&xgrid=debug&xace=debug&xaction=debug&xfile=debug&xideve=debug&davinci=debug&dijit=debug&app=xide&xideve=false&devices=false
    var ACTION = types.ACTION;

    //action renderer class
    var ContainerClass = dcl([_XWidget,ActionContext.dcl,ActionMixin.dcl],{
        templateString:'<div class="mainMenu ribbonToolbar" style="min-height: 160px"></div>',
        /**
         * @type {module:xide/layout/_TabContainer}
         */
        tabContainer:null,
        startup:function(){
            //this.tabContainer = this.add(utils.addWidget(_TabContainer,{},this,this,true));
        },
        /**
         * @returns {module:xide/layout/_TabContainer}
         */
        getRootContainer:function(){
            if(!this.tabContainer){
                this.tabContainer = this.add(utils.addWidget(_TabContainer,{},this,this,true));
            }
            return this.tabContainer;
        }
    });
    var ActionRendererClass = dcl(null,{
        renderTopLevel:function(name,where){
            var root = this.getRootContainer();
            var tab= root.getTab('name');
            var node = null;
            if(name==='window'){
                console.error('--xxx');
            }
            if(!tab){
                tab = root.createTab(name);
                node = $(utils.getNode(tab));
                node.addClass('nav navbar-nav ribbon_tabbar');
            }
            return node;
        },
        /**
         *
         * @param item
         * @param data
         * @param $menu
         * @param action
         * @param owner
         * @param label
         * @param icon
         * @param visibility
         * @param showKeyCombo
         * @param lazy
         */
        renderItem:function(item,data,$menu,action, owner, label, icon, visibility, showKeyCombo, lazy){
            var self = this;
            var labelLocalized = self.localize(label);
            var actionType = visibility.actionType || action.actionType;
            var parentAction = action.getParent ? action.getParent() : null;
            var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
            var keyComboString = ' \n';
            var element = null;
            if (action.keyboardMappings && showKeyCombo !== false) {
                var mappings = action.keyboardMappings;
                var keyCombos = mappings[0].keys;
                if (keyCombos && keyCombos.length) {
                    keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                }
            }

            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                element = '<li class="" >';
                var id = action._store.id + '_' + action.command + '_' + self.id;
                var checked = action.get('value');
                //checkbox-circle
                element += '<div class="action-checkbox checkbox checkbox-success ">';
                element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                element += '<label for="' + id + '">';
                element += self.localize(data.text);
                element += '</label>';
                element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                element += '</div>';

                $menu.addClass('noclose');
                var result = $(element);
                var checkBox = result.find('INPUT');
                checkBox.on('change', function (e) {
                    action._originReference = data;
                    action._originEvent = e;
                    action.set('value', checkBox[0].checked);
                    action._originReference = null;
                });
                self.setVisibilityField(action, 'widget', data);
                return result;
            }
            closeOnClick === false && $menu.addClass('noclose');
            if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                var value = action.value || action.get('value');
                var parentValue = parentAction.get('value');
                if (value == parentValue) {
                    icon = 'fa fa-check';
                }
            }



            var title = data.text || labelLocalized || self.localize(action.title);
            //default:
            //element = '<li><a title="' + title + ' ' + keyComboString + '">';
            element = '<li class="ribbon_3rows_button" title="' + title + ' ' + keyComboString + '">';
            var _icon = data.icon || icon;
            //icon
            if (typeof _icon !== 'undefined') {
                //already html string
                if (/<[a-z][\s\S]*>/i.test(_icon)) {
                    element += _icon;
                } else {
                    element += '<span style="" class="icon ' + _icon + '"/> ';
                }
            }
            element +='<a class="">';
            element += data.text;
            //element += '<span style="max-width:100px" class="text-muted pull-right ellipsis keyboardShortCut">' + (showKeyCombo ? keyComboString : "") + '</span></a></li>';
            element += '</a></li>';
            self.setVisibilityField(action, 'widget', data);
            return $(element);
        },
        onRootAction:function(level,container){
            return this.renderTopLevel(level,container);
        }
    });

    var MainMenu = dcl([ContainerClass,ActionRendererClass,_MenuMixin4,_XWidget.StoreMixin],{
        target:null,
        visibility: types.ACTION_VISIBILITY.RIBBON,
        attachToGlobal:false,
        _tmpActions:null,
        collapseSmallGroups:3,
        containerClass: 'ribbon_dropdown',
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });
            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            this.__on(root, 'mouseenter', '.dropdown-submenu', function (e) {
                try {
                    var _root = $(e.currentTarget);
                    var $sub = _root.find('.dropdown-context-sub:first');
                    var didPopup = false;
                    if ($sub.length === 0) {
                        $sub = _root.data('sub');
                        if($sub){
                            didPopup = true;
                        }else {
                            return;
                        }
                    }
                    var data = $sub.data('data');
                    var level = data ? data[0].level : 0;
                    var isFirst = level ===1;
                    if (self.menu) {
                        if (!$.contains(self.menu[0], _root[0])) {
                            return;
                        }
                    }



                    var _disabled = _root.hasClass('disabled');
                    if (_disabled) {
                        $sub.css('display', 'none');
                        return;
                    } else {
                        $sub.css('display', 'block');
                    }


                    var doClose = true;
                    if(isFirst) {
                        $sub.css('display', 'initial');
                        $sub.css('position', 'initial');
                        function close() {
                            var _wrapper = $sub.data('_popupWrapper');
                            popup.close({
                                domNode: $sub[0],
                                _popupWrapper: _wrapper
                            });
                        }

                        if (!didPopup) {
                            _root.data('sub', $sub);
                            $sub.data('owner', self);
                            $sub.on('mouseleave', function () {
                                doClose && close();
                            });
                            _root.on('mouseleave', function () {
                            });
                        }

                        popup.open({
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            extraClass: 'ActionRibbonToolbar',
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                doClose && close();
                            },
                            onClose: function () {
                                //console.log('close');
                                //domAttr.set(self._popupStateNode, "popupActive", false);
                                //domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                                //self._set("_opened", false);	// use set() because _CssStateMixin is watching
                            }
                        });
                        return;
                    }else{
                        if(!$sub.data('didSetup')){
                            $sub.data('didSetup',true);
                            _root.on('mouseleave',function(){
                                doClose && $sub.css('display','');
                            });
                        }
                    }
                    //reset top
                    $sub.css({
                        top: 0
                    });

                    var autoH = $sub.height() + 0;
                    var totalH = $('html').height();
                    var pos = $sub.offset();
                    var overlapYDown = totalH - (pos.top + autoH);
                    if ((pos.top + autoH) > totalH) {
                        $sub.css({
                            top: overlapYDown - 30
                        }).fadeIn(options.fadeSpeed);
                    }
                    ////////////////////////////////////////////////////////////
                    var subWidth = $sub.width(),
                        subLeft = $sub.offset().left,
                        collision = (subWidth + subLeft) > window.innerWidth;

                    if (collision) {
                        $sub.addClass('drop-left');
                    }
                } catch (e) {
                    logError(e);
                }
            });
        },
        addContext:function(selector,data){
            var id,
                $menu,
                self = this;
            if (typeof data.id !== 'undefined' && typeof data.data !== 'undefined') {
                id = data.id;
                $menu = $('body').find('#dropdown-' + id)[0];
                if (typeof $menu === 'undefined') {
                    $menu = self.buildMenu(data.data, id);
                    selector.append($menu);
                }
            } else {
                var d = new Date();

                id = d.getTime();
                $menu = self.buildMenu(data, id);
                selector.append($menu);
            }

            return $menu;
        },
        _did:false,
        setActionStore:function(store,owner){
            this._clear();
            if(this.tabContainer){
                utils.destroy(this.tabContainer,true,this);
                this.getRootContainer();
            }
            this._tmpActions = [];
            this.store = store;
            this.addActionStore(store);
            var self = this,
                visibility = self.visibility,
                rootContainer = $(self.getRootContainer()),
                tree = self.buildActionTree(store,owner),
                allActions = tree.allActions,
                rootActions = tree.rootActions,
                allActionPaths = tree.allActionPaths;

            var groupBlocks = [];

            function createGroupContainer(where,name){
                var block = $('<div class="ribbon_block_base">');
                where.append(block);
                var blockItems = $('<div class="ribbon_block_items"/>');
                block.append(blockItems);
                var blockLabel = $('<div class="ribbon_block_label_fixed">' + name +  '</div>');
                block.append(blockLabel);
                var result = {
                    root:block,
                    items:blockItems,
                    label:blockLabel,
                    count:0
                };
                groupBlocks.push(result);
                return result;
            }

            var lastGroup = '';
            var lastTarget = root;
            var last3BlockRows = null;
            var blockTarget = null;

            var lastGroupContainer = null;

            //track all actions per level
            var stats = [];
            _.each(tree.root, function (menuActions,level) {
                stats.push({
                    name:level,
                    size:menuActions.length
                });
            });

            _.each(tree.root, function (menuActions,level) {

                var root = self.onRootAction(level,rootContainer);
                lastGroup = null;
                lastTarget = root;

                // final menu data
                var data = [];
                var groupedActions = menuActions.grouped;

                var isNewBlock = false;
                var blockCounter = 0;

                //temp group string of the last rendered action's group
                for (var i = 0; i < menuActions.length; i++) {
                    var command = menuActions[i];
                    var action = self.getAction(command,store);
                    var isDynamicAction = false;
                    var lastHeader = null;
                    isNewBlock = false;
                    if (!action) {
                        isDynamicAction = true;
                        action = self.createAction(command);
                        self._tmpActions.push(action);
                        self.setVisibilityField(action,'widget',{
                            widget:root,
                            destroy:function(){
                                this.widget.remove();
                            }
                        });
                    }
                    if(action){
                        var renderData = self.getActionData(action);
                        var icon = renderData.icon,
                            label = renderData.label,
                            visibility = renderData.visibility,
                            group = renderData.group;

                        if (!isDynamicAction && group && groupedActions[group]) {// && groupedActions[group].length >= 2
                            if(lastGroup!==group){
                                lastHeader = {header: i18.localize(group)};
                                lastGroup = group;
                                lastGroupContainer = createGroupContainer(root,group);
                                lastTarget = lastGroupContainer.items;
                            }
                        }

                        if(lastGroupContainer.count > 4){
                            lastGroupContainer.target = null;
                            lastGroupContainer.count = 0;
                        }


                        var target = lastGroupContainer.target;

                        if(!target){
                            target = $('<div class="dhxrb_3rows_block"/>');
                            lastTarget.append(target);
                            lastGroupContainer.target = target;
                        }

                        lastGroupContainer.count++;

                        var item = self.toMenuItem(action, owner, label, icon, visibility || {},false);
                        item.level = 0;
                        data.push(item);
                        visibility.widget = item;
                        self.addReference(action,item);

                        //blockCounter++;


                        var childPaths = new Path(command).getChildren(allActionPaths,false),
                            isContainer = childPaths.length> 0;

                        function parseChildren(_command, parent) {
                            var childPaths = new Path(_command).getChildren(allActionPaths, false),
                                isContainer = childPaths.length > 0,
                                childActions = isContainer ? self.toActions(childPaths, store) : null;
                            if (childActions) {
                                var subs = [];
                                _.each(childActions, function (child) {
                                    var _renderData = self.getActionData(child);
                                    var _item = self.toMenuItem(child, owner, _renderData.label, _renderData.icon, _renderData.visibility,false);
                                    var parentLevel = parent.level || 0;
                                    _item.level = parentLevel + 1;
                                    self.addReference(child, _item);
                                    subs.push(_item);
                                    var _childPaths = new Path(child.command).getChildren(allActionPaths, false),
                                        _isContainer = _childPaths.length > 0;
                                    if (_isContainer) {
                                        parseChildren(child.command, _item);
                                    }
                                });
                                parent.subMenu = subs;
                            }
                        }

                        parseChildren(command, item);
                        self.buildMenuItems(target, [item], "-" + new Date().getTime());
                    }
                }
            });
            self.onDidRenderActions(store,owner);

            //size all tab groups to the last know largest height
            var largest = 0;
            _.each(groupBlocks,function(group){
                var height = group.root.height();
                if(height > largest){
                    largest = height;
                }
            });
            largest = largest + 'px';
            _.each(groupBlocks,function(group){
                group.root.css('height',largest);
            });

        },
        startup:function(){
            this.init({preventDoubleContext: false});
        }
    });
    return MainMenu;

});


},
'xide/widgets/_Widget':function(){
/** @module xide/widgets/_Widget **/
define([
    'xdojo/declare',
    'dcl/dcl',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'xlang/i18'
], function (declare,dcl,utils,EventedMixin,registry,i18) {
    
    var forwardMethods = ['resize'];

    function _resize(what){
        try {
            if (typeof what['resize'] === "function" && what._started) {
                what['resize'].apply(what,arguments);
            }else{
                console.warn('widget has no resize or is not started yet ' + what.declaredClass,[what,what.resize]);
            }
        }catch(e){
            logError(e,'error resizing sub widget ' + what.id + ' class:'+what.declaredClass);
        }
    }

    function forward(method,args){
        _.each(this._widgets,function(what){
            if (what && typeof what[method] === "function") {
                what[method].apply(what,args);
            }
        },this);
    }

    function set(prop,value){
        _.each(this._widgets,function(what){
            if (what && what[prop]) {
                what[prop] = value;
            }
        },this);
    }


    /**
     * @class module:xide/widgets/_Widget
     */
    var Implementation = {
        _widgets:null,
        __eventHandles:null,
        _isResizing:false,
        cssClass:'',
        /**
         * @type {module:xide/manager/ContextBase}
         */
        ctx:null,
        /**
         *
         * @returns {module:xide/manager/ContextBase}
         */
        getContext:function(){
            return this.ctx;
        },
        onResizeBegin:function(){
            this._isResizing=true;
            _.each(this._widgets,function(what){
                what && (what._isResizing=true);
            },this);
        },
        onResizeEnd:function(){
            this._isResizing=false;
            _.each(this._widgets,function(what){
                what && (what._isResizing=false);
            },this);
        },
        _toWidget:function(element){
            if(element && element.id){
                var widget = registry.byId(element.id);
                if(widget){
                    return widget;
                }
            }
            return null;
        },
        parentByClass :function(className,max){
            var i = 0,
                element = this.domNode,
                widget = null;
            max = max || 20;
            while (!widget && i < max && element) {
                if (element) {
                    var _widget = this._toWidget(element);
                    if(_widget && _widget.declaredClass){
                        if(_widget.declaredClass === className){
                            widget = _widget;
                        }
                    }
                    element = element.parentNode;
                }
                i++;
            }
            return widget;
        },
        _startWidgets:function(){
            var result = false;
            if(this._widgets) {
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    if (w && !w._started && w.startup) {
                        w.startup();
                        w._started = true;
                        result = true;
                        w._emit('startup');
                    }
                }
            }
            return result;
        },
        _createForward:function(method){
            var self = this;
            if(!this[method]){
                this[method] = function(){
                    for (var i = 0; i < self._widgets.length; i++) {
                        var w = self._widgets[i];
                        w[method] && w[method]();
                    }
                };
            }
        },
        onShow:function(){
            if(this._widgets){
                this._startWidgets();
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    if(w && w!==this) {
                        w._showing=true;
                        w.open = true;
                        w.onShow && w.onShow();
                        w._emit && w._emit('show',{});

                    }
                }
            }
        },
        onHide:function(){
            if(this._widgets){
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    
                    if(!w){
                        console.warn('invalid widget');
                    }else {
                        if(w!==this){
                            w._showing = false;
                            w.open = false;
                            w.onHide && w.onHide();
                            try{
                                w._emit && w._emit('hide',{});
                            }catch(e){
                                logError(e,'error emitting on-hide');
                            }

                        }
                    }
                }
            }
        },
        _getChildren:function(){
            return this._widgets;
        },
        debounce:function(methodName,_function,delay,options,now){
            return utils.debounce(this,methodName,_function,delay,options,now);
        },
        __addHandler:function(element,type,handler){
            if(!element){
                return;
            }
            handler = _.isString(handler) ? this[handler] ? this[handler] : null : handler;
            var self = this;

            if(typeof handler ==='function'){
                return this.__on(element,type,null,function(){
                    handler.apply(self,arguments);
                });
            }
            return false;
        },
        _shouldResizeWidgets:function(){
            return true;
        },
        resize:function(){
            var _args = arguments;
            
            this.inherited && this.inherited(_args);
            
            if(this.shouldResizeWidgets && this.shouldResizeWidgets()===false){
                return;
            }
            //if(this._isResizing ===true){return;}
            if(this._widgets){
                for (var i = 0; i < this._widgets.length; i++) {
                    var what = this._widgets[i];
                    if (what) {
                        what.resizeToParent && utils.resizeTo(what, this, true, true);
                        if (what && typeof what['resize'] === "function" && what._started) {
                            what['resize'].apply(what, _args);
                        }
                    }
                }
            }
        },
        destroy:function(){
            this.inherited && this.inherited(arguments);
            var _widgets = this._widgets;
            if (_widgets) {
                for (var i = 0; i < _widgets.length; i++) {
                    var widget = _widgets[i];
                    if (widget && widget != this && widget._destroyed !== true) {
                        utils.destroy(widget);
                    }
                }
                delete this._widgets;
                this._widgets = null;
            }
            if(this.domNode) {
                registry.remove(this.domNode.id);
                utils.destroy(this.domNode);
            }
            this._destroyed = true;
        },
        onAdded:function(){
        },
        /**
         *
         * @param mixed
         * @param options
         * @param parent
         * @param startup
         * @param select
         * @param extension
         * @returns {*}
         */
        add:function(mixed,options,parent,startup,select,extension){
            if(mixed==this){
                return mixed;
            }
            !this._widgets && (this._widgets = []);

            var widgets = this._widgets;
            if(_.isNumber(options)){
                options = null;
            }
            if(options!==null && !_.isObject(options)){
                options ={};
            }
            var result = null;

            _.isEmpty(options) && (options=null);

            var _parent = parent || ( parent!==false ? this.containerNode || this.domNode : null);

            //case 1: instance or object
            if((mixed && !options && !parent) || (!options && !parent && !startup && !select && !extension)){
                widgets.indexOf(mixed)==-1 && (widgets.push(mixed));
                return mixed;

            //case 2: proto
            }else if(mixed && options){
                result = utils.addWidget(mixed,options,this,_parent,startup,null,null,select,extension);
                widgets.push(result);
            }
            return result;
        },
        remove:function(mixed){
            this._widgets && this._widgets.remove(mixed);
        },
        buildRendering:function() {
            this.inherited && this.inherited(arguments);
            var node = utils.getNode(this);
            node && this.cssClass && $(node).addClass(this.cssClass);
            node && this.style && $(node).attr('style',this.style);
        }
    };

    var _Widget = dcl([EventedMixin.dcl,i18.dcl],Implementation);
    var Module = declare('xide/widgets/_Widget',i18,Implementation);
    Module.Implmentation = Implementation;
    Module.dcl = _Widget;
    dcl.chainAfter(_Widget,'destroy');
    dcl.chainAfter(_Widget,'onResizeBegin');
    dcl.chainAfter(_Widget,'onResizeEnd');
    return Module;
});

},
'xide/views/_Console':function(){
/** @module xide/view/_Console **/
define([
    "dcl/dcl",
    'xide/utils',
    'xide/types',
    "dojo/_base/lang", // lang.getObject
    "xide/_base/_Widget"
], function (dcl, utils,types,lang, _Widget) {
    
    
  var Module = dcl([_Widget], {
      declaredClass:'xide/views/_Console',
      templateString: '<div attachTo="containerNode" class="widget" style="height: 100%;width: 100%;">' +
      '<div attachTo="logView" style="height:50%;overflow: auto"></div></div>',
      value: "return 2;",
      resizeToParent: true,
      serverClass: 'XShell',
      consoleClass:null,
      server: null,
      showProgress: false,
      jsContext: null,
      onButton: function () {
          var dst = this.getLoggingContainer();
          if (dst) {
              dojo.empty(dst);
          }
      },
      onConsoleExpanded: function () {
          this._resizeLogView();
      },
      _resizeLogView: function () {
          if (this.console) {
              var total = this.$containerNode.height();
              var consoleH = $(this.console.domNode).height();
              $(this.logView).height(total - consoleH + 'px');
          }
      },
      resize:function(){
          utils.resizeTo(this,this._parent);
          this._resizeLogView();
          return this.inherited(arguments);
      },
      _scrollToEnd: function () {
          var thiz = this;
          setTimeout(function(){
              var container = thiz.getLoggingContainer();
              container.lastChild.scrollIntoViewIfNeeded();
          },10);
          return;
      },
      onServerResponse: function (data, addTimes) {

          var container = this.getLoggingContainer();
          container.children.length > 100 && dojo.empty(container);
          this._resizeLogView();
          var node = this.log(data, addTimes);
          this._scrollToEnd();

          return node;

      },
      getLoggingContainer: function () {
          return this.logView;
      },
      onEnter: function (value, print) {

          if (this.showProgress) {
              this.progressItem = this.createLogItem(value, this.getLoggingContainer());
          }
          var _resolved = '';

          if (this.delegate.onConsoleEnter) {
              _resolved = this.delegate.onConsoleEnter({
                  view: this,
                  console: this.console
              }, value, print);
          }


          if (this.showLastInput) {
              var dst = this.getLoggingContainer();

              print !== false && dst.appendChild(dojo.create("div", {
                  innerHTML: '# ' + (_resolved || value),
                  className: 'widget'
              }));

          }
      },
      getServer: function () {
          return this.server || ctx.fileManager;
      },
      _toString: function (str, addTimes) {
          if (addTimes !== false) {
              return this.addTime(str);
          } else {
              return str;
          }
      },
      addTime: function (str) {
          return moment().format("HH:mm:ss:SSS") + ' ::   ' + str + '';
      },
      onMaximized: function (maximized) {

          this.resize();
          this.publish(types.EVENTS.RESIZE, null, 1500);


      },
      maximize:function(){

          var node = this.domNode,
              $node = $(node),
              thiz = this;

          if (!this._isMaximized) {

              this._isMaximized = true;
              var vp = $(this.domNode.ownerDocument);
              var root = $('body')[0];
              var container = utils.create('div', {
                  className: 'ACEContainer bg-opaque',
                  style: 'z-index:300;height:100%;width:100%'
              });

              this._maximizeContainer = container;


              root.appendChild(container);

              $(node).addClass('AceEditorPaneFullScreen');

              $(node).css('width', vp.width());
              $(node).css('height', vp.height());
              this.resize();


              this._lastParent = node.parentNode;
              container.appendChild(node);


              $(container).addClass('bg-opaque');

              $(container).css('width', vp.width());
              $(container).css('height', vp.height());



              $(container).css({
                  position: "absolute",
                  left: "0px",
                  top: "0px",
                  border: 'none medium',
                  width: '100%',
                  height: '100%'
              });





          } else {
              this._isMaximized = false;
              $node.removeClass('AceEditorPaneFullScreen');
              this._lastParent.appendChild(node);
              utils.destroy(this._maximizeContainer);
          }
          this.onMaximized(this._isMaximized);
          return true;
      },
      log: function (msg, addTimes) {

          utils.destroy(this.progressItem);

          var out = '';
          if (_.isString(msg)) {
              out += msg.replace(/\n/g, '<br/>');
          } else if (_.isObject(msg) || _.isArray(msg)) {
              out += JSON.stringify(msg, null, true);
          } else if (_.isNumber(msg)) {
              out += msg + '';
          };

          var dst = this.getLoggingContainer();
          var items = out.split('<br/>');
          var last = null;
          var thiz = this;

          for (var i = 0; i < items.length; i++) {
              var _class = 'logEntry' + (this.lastIndex % 2 === 1 ? 'row-odd' : 'row-even');

              var item = items[i];
              if(!item || !item.length){
                  continue;
              }

              last = dst.appendChild(dojo.create("div", {
                  className: _class,
                  innerHTML: this._toString(items[i], addTimes)

              }));

              this.lastIndex++;
          }

          if (last) {
              last.scrollIntoViewIfNeeded();
          }
      },
      startup: function () {
          this.createWidgets();
      },
      createWidgets: function () {

          this.console = utils.addWidget(this.consoleClass, {
              style: 'width:inherit',
              delegate: this,
              type: this.type,
              owner: this,
              className: 'consoleWidget',
              value: this.value,
              ctx:this.ctx
          }, this, this.containerNode, true);

          this.console.startup();
          this.add(this.console, null, false);
      }
  });
  return Module;
});
},
'xide/encoding/MD5':function(){
define(["./_base"], function(base) {

/*	A port of Paul Johnstone's MD5 implementation
 *	http://pajhome.org.uk/crypt/md5/index.html
 *
 *	Copyright (C) Paul Johnston 1999 - 2002.
 *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * 	Distributed under the BSD License
 *
 *	Dojo port by Tom Trenka
 */

	var chrsz=8;

	//	MD5 rounds functions
	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function C(q,a,b,x,s,t){ return base.addWords(R(base.addWords(base.addWords(a, q), base.addWords(x, t)), s), b); }
	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }

	//	the core MD5 rounds method
	function core(x,len){
		x[len>>5]|=0x80<<((len)%32);
		x[(((len+64)>>>9)<<4)+14]=len;
		var a= 1732584193;
		var b=-271733879;
		var c=-1732584194;
		var d= 271733878;
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;

			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
			c=FF(c,d,a,b,x[i+10],17,-42063);
			b=FF(b,c,d,a,x[i+11],22,-1990404162);
			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
			d=FF(d,a,b,c,x[i+13],12,-40341101);
			c=FF(c,d,a,b,x[i+14],17,-1502002290);
			b=FF(b,c,d,a,x[i+15],22, 1236535329);

			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
			c=GG(c,d,a,b,x[i+11],14, 643717713);
			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
			d=GG(d,a,b,c,x[i+10],9 , 38016083);
			c=GG(c,d,a,b,x[i+15],14,-660478335);
			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
			b=GG(b,c,d,a,x[i+12],20,-1926607734);

			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
			c=HH(c,d,a,b,x[i+11],16, 1839030562);
			b=HH(b,c,d,a,x[i+14],23,-35309556);
			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
			b=HH(b,c,d,a,x[i+10],23,-1094730640);
			a=HH(a,b,c,d,x[i+13],4 , 681279174);
			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
			d=HH(d,a,b,c,x[i+12],11,-421815835);
			c=HH(c,d,a,b,x[i+15],16, 530742520);
			b=HH(b,c,d,a,x[i+ 2],23,-995338651);

			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
			c=II(c,d,a,b,x[i+14],15,-1416354905);
			b=II(b,c,d,a,x[i+ 5],21,-57434055);
			a=II(a,b,c,d,x[i+12],6 , 1700485571);
			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
			c=II(c,d,a,b,x[i+10],15,-1051523);
			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
			d=II(d,a,b,c,x[i+15],10,-30611744);
			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
			b=II(b,c,d,a,x[i+13],21, 1309151649);
			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
			d=II(d,a,b,c,x[i+11],10,-1120210379);
			c=II(c,d,a,b,x[i+ 2],15, 718787259);
			b=II(b,c,d,a,x[i+ 9],21,-343485551);

			a=base.addWords(a, olda);
			b=base.addWords(b, oldb);
			c=base.addWords(c, oldc);
			d=base.addWords(d, oldd);
		}
		return [a,b,c,d];
	}

	function hmac(data, key){
		var wa=base.stringToWord(key);
		if(wa.length>16){
			wa=core(wa, key.length*chrsz);
		}
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(base.stringToWord(data)), 512+data.length*chrsz);
		return core(r.concat(h), 640);
	}

	//	public function
	base.MD5=function(/* string */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=core(base.stringToWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.MD5._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	return base.MD5;
});

},
'xide/types':function(){
define([
    "dcl/dcl"
],function(dcl){
    return new dcl(null,{
        declaredClass:"xide/types"
    });
});
},
'xide/factory':function(){
define([
    'dcl/dcl'
],function(dcl){
    return new dcl(null,{
        declaredClass:'xide/factory'
    });
});
},
'dojo/dnd/Source':function(){
define([
	"../_base/array", "../_base/declare", "../_base/kernel", "../_base/lang",
	"../dom-class", "../dom-geometry", "../mouse", "../ready", "../topic",
	"./common", "./Selector", "./Manager"
], function(array, declare, kernel, lang, domClass, domGeom, mouse, ready, topic,
			dnd, Selector, Manager){

// module:
//		dojo/dnd/Source

/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
var __SourceArgs = {
	// summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	// isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	// accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	// autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	// copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	// delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	// horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	// selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	// selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	// withHandles: Boolean?
	//		allows dragging only by handles, false by default
	// generateText: Boolean?
	//		generate text node for drag and drop, true by default
};
=====*/

// For back-compat, remove in 2.0.
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dojo/dnd/AutoSource", "dojo/dnd/Target"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

var Source = declare("dojo.dnd.Source", Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target

	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,

	constructor: function(/*DOMNode|String*/ node, /*__SourceArgs?*/ params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo/dnd/Source` instance
		lang.mixin(this, lang.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			domClass.add(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			domClass.add(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			domClass.add(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			topic.subscribe("/dnd/source/over", lang.hitch(this, "onDndSourceOver")),
			topic.subscribe("/dnd/start",  lang.hitch(this, "onDndStart")),
			topic.subscribe("/dnd/drop",   lang.hitch(this, "onDndDrop")),
			topic.subscribe("/dnd/cancel", lang.hitch(this, "onDndCancel"))
		];
	},

	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself

		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == Manager.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		Source.superclass.destroy.call(this);
		array.forEach(this.topics, function(t){t.remove();});
		this.targetAnchor = null;
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		Source.superclass.onMouseMove.call(this, e);
		var m = Manager.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dnd.getCopyKeyState(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = domGeom.position(this.current, true);
				}
				if(this.horizontal){
					// In LTR mode, the left part of the object means "before", but in RTL mode it means "after".
					before = (e.pageX - this.targetBox.x < this.targetBox.w / 2) == domGeom.isBodyLtr(this.current.ownerDocument);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			Source.superclass.onMouseUp.call(this, e);
		}
	},

	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this !== source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = Manager.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			Manager.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},

	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node /*=====, hint =====*/){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node /*=====, hint =====*/){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node/*=====, hint =====*/){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node /*=====, hint =====*/){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		Source.superclass.onOverEvent.call(this);
		Manager.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		Source.superclass.onOutEvent.call(this);
		Manager.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event

		// accept only the left mouse button, or the left finger
		if(e.type != "touchstart" && !mouse.isLeft(e)){ return false; }

		if(!this.withHandles){ return true; }

		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(domClass.contains(node, "dojoDndHandle")){ return true; }
			if(domClass.contains(node, "dojoDndItem") || domClass.contains(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

return Source;

});

},
'xfile/factory/Store':function(){
define([
    'xide/types',
    'xide/factory',
    'xide/utils',
    'xfile/data/Store'
], function (types, factory,utils,Store){
    /**
     *
     * @param mount
     * @param options
     * @param config
     * @param optionsMixin
     * @param ctx
     * @param args
     * @returns {*}
     */
    factory.createFileStore = function (mount,options,config,optionsMixin,ctx,args){
        var storeClass = Store;
        options = options || {
            fields:
            types.FIELDS.SHOW_ISDIR |
            types.FIELDS.SHOW_OWNER |
            types.FIELDS.SHOW_SIZE |
            //types.FIELDS.SHOW_FOLDER_SIZE |
            types.FIELDS.SHOW_MIME |
            types.FIELDS.SHOW_PERMISSIONS |
            types.FIELDS.SHOW_TIME |
            types.FIELDS.SHOW_MEDIA_INFO
        };

        utils.mixin(options,optionsMixin);
        var store = new storeClass(utils.mixin({
            data:[],
            ctx:ctx,
            config:config,
            url:config.FILE_SERVICE,
            serviceUrl:config.serviceUrl,
            serviceClass:config.FILES_STORE_SERVICE_CLASS,
            mount:mount,
            options:options
        },args));
        store._state = {
            initiated:false,
            filter:null,
            filterDef:null
        };
        store.reset();
        store.setData([]);
        store.init();
        ctx && ctx.getFileManager().addStore(store);
        return store;
    };
    return factory;

});
},
'dgrid/TouchScroll':function(){
// FIXME:
// * fully make use of transitions in glide routines

define([
	'dojo/_base/declare',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'./util/touch',
	'./util/has-css3'
], function (declare, domConstruct, domClass, on, touchUtil, has) {
	var calcTimerRes = 50, // ms between drag velocity measurements
		glideTimerRes = 30, // ms between glide animation ticks
		current = {}, // records info for widget(s) currently being scrolled
		previous = {}, // records info for widget(s) that were mid-scroll when someone decided to scroll again
		glideThreshold = 1, // speed (in px) below which to stop glide - TODO: remove
		scrollbarAdjustment = 8, // number of px to adjust scrollbar dimension calculations
		// RegExps for parsing relevant x/y from translate and matrix values:
		translateRx = /^translate(?:3d)?\((-?\d+)(?:\.\d*)?(?:px)?, (-?\d+)/,
		matrixRx = /^matrix\(1, 0, 0, 1, (-?\d+)(?:\.\d*)?(?:px)?, (-?\d+)/,
		// store has-features we need, for computing property/function names:
		hasTransitions = has('css-transitions'),
		hasTransitionEnd = has('transitionend'),
		hasTransforms = has('css-transforms'),
		hasTransforms3d = has('css-transforms3d'),
		// and declare vars to store info on the properties/functions we'll need
		cssPrefix, transitionPrefix, transformProp, translatePrefix, translateSuffix;

	if (hasTransforms3d) {
		translatePrefix = 'translate3d(';
		translateSuffix = ',0)';
	}
	else if (hasTransforms) {
		translatePrefix = 'translate(';
		translateSuffix = ')';
	}

	if (!hasTransitions || !translatePrefix) {
		console.warn('CSS3 features unavailable for touch scroll effects.');
		return function () {};
	}

	// figure out strings for use later in events
	transformProp = hasTransforms3d || hasTransforms;
	transformProp = transformProp === true ? 'transform' : transformProp + 'Transform';
	transitionPrefix = hasTransitions === true ? 'transition' :
		hasTransitions + 'Transition';
	cssPrefix = hasTransforms === true ? '' :
		'-' + hasTransforms.toLowerCase() + '-';

	function showScrollbars(widget, curr) {
		// Handles displaying of X/Y scrollbars as appropriate when a touchstart
		// occurs.

		var node = widget.touchNode,
			parentNode = node.parentNode,
			adjustedParentWidth = parentNode.offsetWidth - scrollbarAdjustment,
			adjustedParentHeight = parentNode.offsetHeight - scrollbarAdjustment,
			// Also populate scroll/offset properties on curr for reuse,
			// to avoid having to repeatedly hit the DOM.
			scrollWidth = curr.scrollWidth = node.scrollWidth,
			scrollHeight = curr.scrollHeight = node.scrollHeight,
			parentWidth = curr.parentWidth = parentNode.offsetWidth,
			parentHeight = curr.parentHeight = parentNode.offsetHeight,
			scrollbarNode;

		if (scrollWidth > parentWidth) {
			if (!widget._scrollbarXNode) {
				scrollbarNode = domConstruct.create('div', { className: 'touchscroll-x' }, parentNode);
			}
			scrollbarNode = widget._scrollbarXNode =
				widget._scrollbarXNode || domConstruct.create('div', { className: 'touchscroll-bar' }, scrollbarNode);
			scrollbarNode.style.width =
				adjustedParentWidth * adjustedParentWidth / scrollWidth + 'px';
			scrollbarNode.style.left = node.offsetLeft + 'px';
			domClass.add(parentNode, 'touchscroll-scrollable-x');
			curr.scrollableX = true;
		}
		else {
			domClass.remove(parentNode, 'touchscroll-scrollable-x');
		}
		if (scrollHeight > parentHeight) {
			if (!widget._scrollbarYNode) {
				scrollbarNode = domConstruct.create('div', { className: 'touchscroll-y' }, parentNode);
			}
			scrollbarNode = widget._scrollbarYNode =
				widget._scrollbarYNode || domConstruct.create('div', { className: 'touchscroll-bar' }, scrollbarNode);
			scrollbarNode.style.height =
				adjustedParentHeight * adjustedParentHeight / scrollHeight + 'px';
			scrollbarNode.style.top = node.offsetTop + 'px';
			domClass.add(parentNode, 'touchscroll-scrollable-y');
			curr.scrollableY = true;
		}
		else {
			domClass.remove(parentNode, 'touchscroll-scrollable-y');
		}
		domClass.remove(parentNode, 'touchscroll-fadeout');
	}

	function scroll(widget, options) {
		// Handles updating of scroll position (from touchmove or glide).
		var node = widget.touchNode,
			curr = current[widget.id],
			pos, hasX, hasY, x, y;

		if (typeof options !== 'object') {
			// Allow x, y to be passed directly w/o extra object creation.
			// (e.g. from ontouchmove)
			x = options;
			y = arguments[2];
			options = arguments[3];
			hasX = hasY = true;
		}
		else {
			hasX = 'x' in options;
			hasY = 'y' in options;

			// If either x or y weren't specified, pass through the current value.
			if (!hasX || !hasY) {
				pos = widget.getScrollPosition();
			}
			x = hasX ? options.x : pos.x;
			y = hasY ? options.y : pos.y;
		}

		// Update transform on touchNode
		node.style[transformProp] =
			translatePrefix + -x + 'px,' + -y + 'px' + translateSuffix;

		// Update scrollbar positions
		if (curr && hasX && widget._scrollbarXNode) {
			widget._scrollbarXNode.style[transformProp] = translatePrefix +
				(x * curr.parentWidth / curr.scrollWidth) + 'px,0' + translateSuffix;
		}
		if (curr && hasY && widget._scrollbarYNode) {
			widget._scrollbarYNode.style[transformProp] = translatePrefix + '0,' +
				(y * curr.parentHeight / curr.scrollHeight) + 'px' + translateSuffix;
		}

		// Emit a scroll event that can be captured by handlers, passing along
		// scroll information in the event itself (since we already have the info,
		// and it'd be difficult to get from the node).
		on.emit(widget.touchNode.parentNode, 'scroll', {
			scrollLeft: x,
			scrollTop: y
		});
	}

	function getScrollStyle(widget) {
		// Returns match object for current scroll position based on transform.
		if (current[widget.id]) {
			// Mid-transition: determine current X/Y from computed values.
			return matrixRx.exec(window.getComputedStyle(widget.touchNode)[transformProp]);
		}
		// Otherwise, determine current X/Y from applied style.
		return translateRx.exec(widget.touchNode.style[transformProp]);
	}

	function resetEffects(options) {
		// Function to cut glide/bounce short, called in context of an object
		// from the current hash; attached only when a glide or bounce occurs.
		// Called on touchstart, when touch scrolling is canceled, when
		// momentum/bounce finishes, and by scrollTo on instances (in case it's
		// called directly during a glide/bounce).

		var widget = this.widget,
			nodes = [this.node, widget._scrollbarXNode, widget._scrollbarYNode],
			i = nodes.length;

		// Clear glide timer.
		if (this.timer) {
			clearTimeout(this.timer);
			this.timer = null;
		}

		// Clear transition handlers, as we're about to cut it short.
		if (this.transitionHandler) {
			// Unhook any existing transitionend handler, since we'll be
			// canceling the transition.
			this.transitionHandler.remove();
		}

		// Clear transition duration on main node and scrollbars.
		while (i--) {
			if (nodes[i]) { nodes[i].style[transitionPrefix + 'Duration'] = '0'; }
		}

		// Fade out scrollbars unless indicated otherwise (e.g. re-touch).
		if (!options || !options.preserveScrollbars) {
			domClass.add(this.node.parentNode, 'touchscroll-fadeout');
		}

		// Remove this method so it can't be called again.
		delete this.resetEffects;
	}

	// functions for handling touch events on node to be scrolled

	function ontouchstart(evt) {
		var widget = evt.widget,
			node = widget.touchNode,
			id = widget.id,
			posX = 0,
			posY = 0,
			touch, match, curr;

		// Check touches count (which hasn't counted this event yet);
		// ignore touch events on inappropriate number of contact points.
		if (touchUtil.countCurrentTouches(evt, node) !== widget.touchesToScroll) {
			return;
		}

		match = getScrollStyle(widget);
		if (match) {
			posX = +match[1];
			posY = +match[2];
		}
		if ((curr = current[id])) {
			// stop any active glide or bounce, since it's been re-touched
			if (curr.resetEffects) {
				curr.resetEffects({ preserveScrollbars: true });
			}

			node.style[transformProp] =
				translatePrefix + posX + 'px,' + posY + 'px' + translateSuffix;

			previous[id] = curr;
		}

		touch = evt.targetTouches[0];
		curr = current[id] = {
			widget: widget,
			node: node,
			// Subtract touch coords now, then add back later, so that translation
			// goes further negative when moving upwards.
			startX: posX - touch.pageX,
			startY: posY - touch.pageY,
			// Initialize lastX/Y, in case of a fast flick (< 1 full calc cycle).
			lastX: posX,
			lastY: posY,
			// Also store original pageX/Y for threshold check.
			pageX: touch.pageX,
			pageY: touch.pageY,
			tickFunc: function () { calcTick(id); }
		};
		curr.timer = setTimeout(curr.tickFunc, calcTimerRes);
	}
	function ontouchmove(evt) {
		var widget = evt.widget,
			id = widget.id,
			touchesToScroll = widget.touchesToScroll,
			curr = current[id],
			activeTouches, targetTouches, touch, nx, ny, minX, minY, i;

		// Ignore touchmove events with inappropriate number of contact points.
		if (!curr || (activeTouches = touchUtil.countCurrentTouches(evt, widget.touchNode)) !== touchesToScroll) {
			// Also cancel touch scrolling if there are too many contact points.
			if (activeTouches > touchesToScroll) {
				widget.cancelTouchScroll();
			}
			return;
		}

		targetTouches = evt.targetTouches;
		touch = targetTouches[0];

		// Show touch scrollbars on first sign of drag.
		if (!curr.scrollbarsShown) {
			if (previous[id] || (
					Math.abs(touch.pageX - curr.pageX) > widget.scrollThreshold ||
					Math.abs(touch.pageY - curr.pageY) > widget.scrollThreshold)) {
				showScrollbars(widget, curr);
				curr.scrollbarsShown = true;

				// Add flag to involved touches to provide indication to other handlers.
				for (i = targetTouches.length; i--;) {
					targetTouches[i].touchScrolled = true;
				}
			}
		}

		if (curr.scrollbarsShown && (curr.scrollableX || curr.scrollableY)) {
			// If area can be scrolled, prevent default behavior and perform scroll.
			evt.preventDefault();

			nx = curr.scrollableX ? curr.startX + touch.pageX : 0;
			ny = curr.scrollableY ? curr.startY + touch.pageY : 0;

			minX = curr.scrollableX ? -(curr.scrollWidth - curr.parentWidth) : 0;
			minY = curr.scrollableY ? -(curr.scrollHeight - curr.parentHeight) : 0;

			// If dragged beyond edge, halve the distance between.
			if (nx > 0) {
				nx = nx / 2;
			}
			else if (nx < minX) {
				nx = minX - (minX - nx) / 2;
			}
			if (ny > 0) {
				ny = ny / 2;
			}
			else if (ny < minY) {
				ny = minY - (minY - ny) / 2;
			}

			scroll(widget, -nx, -ny); // call scroll with positive coordinates
		}
	}
	function ontouchend(evt) {
		var widget = evt.widget,
			id = widget.id,
			curr = current[id];

		if (!curr || touchUtil.countCurrentTouches(evt, widget.touchNode) !== widget.touchesToScroll - 1) {
			return;
		}
		startGlide(id);
	}

	// glide-related functions

	function calcTick(id) {
		// Calculates current speed of touch drag
		var curr = current[id],
			node, match, x, y;

		if (!curr) { return; } // no currently-scrolling widget; abort

		node = curr.node;
		match = translateRx.exec(node.style[transformProp]);

		if (match) {
			x = +match[1];
			y = +match[2];

			// If previous reference point already exists, calculate velocity
			curr.velX = x - curr.lastX;
			curr.velY = y - curr.lastY;

			// set previous reference point for future iteration or calculation
			curr.lastX = x;
			curr.lastY = y;
		} else {
			curr.lastX = curr.lastY = 0;
		}
		curr.timer = setTimeout(curr.tickFunc, calcTimerRes);
	}

	function bounce(id, lastX, lastY) {
		// Function called when a scroll ends, to handle rubber-banding beyond edges.
		var curr = current[id],
			widget = curr.widget,
			node = curr.node,
			scrollbarNode,
			x = curr.scrollableX ?
				Math.max(Math.min(0, lastX), -(curr.scrollWidth - curr.parentWidth)) :
				lastX,
			y = curr.scrollableY ?
				Math.max(Math.min(0, lastY), -(curr.scrollHeight - curr.parentHeight)) :
				lastY;

		function end() {
			// Performs reset operations upon end of scroll process.

			// Since transitions have run, delete transitionHandler up-front
			// (since it auto-removed itself anyway), then let
			// resetEffects do the rest of its usual job.
			delete curr.transitionHandler;
			curr.resetEffects();
			delete current[id];
		}

		// Timeout will have been cleared before bounce call, so remove timer.
		delete curr.timer;

		if (x !== lastX || y !== lastY) {
			curr.transitionHandler = on.once(node, hasTransitionEnd, end);
			node.style[transitionPrefix + 'Duration'] = widget.bounceDuration + 'ms';
			node.style[transformProp] =
				translatePrefix + x + 'px,' + y + 'px' + translateSuffix;

			// Also handle transitions for scrollbars.
			if (x !== lastX && curr.scrollableX) {
				scrollbarNode = curr.widget._scrollbarXNode;
				scrollbarNode.style[transitionPrefix + 'Duration'] =
					widget.bounceDuration + 'ms';
				if (lastX > x) {
					// Further left; bounce back right
					scrollbarNode.style[transformProp] =
						translatePrefix + '0,0' + translateSuffix;
				}
				else {
					// Further right; bounce back left
					scrollbarNode.style[transformProp] =
						translatePrefix +
						(scrollbarNode.parentNode.offsetWidth - scrollbarNode.offsetWidth) +
						'px,0' + translateSuffix;
				}
			}
			if (y !== lastY && curr.scrollableY) {
				scrollbarNode = curr.widget._scrollbarYNode;
				scrollbarNode.style[transitionPrefix + 'Duration'] =
					widget.bounceDuration + 'ms';
				if (lastY > y) {
					// Above top; bounce back down
					scrollbarNode.style[transformProp] =
						translatePrefix + '0,0' + translateSuffix;
				}
				else {
					// Below bottom; bounce back up
					scrollbarNode.style[transformProp] =
						translatePrefix + '0,' +
						(scrollbarNode.parentNode.offsetHeight - scrollbarNode.offsetHeight) +
						'px' + translateSuffix;
				}
			}
		}
		else {
			end(); // no rubber-banding necessary; just reset
		}
	}

	function startGlide(id) {
		// starts glide operation when drag ends
		var curr = current[id],
			prev = previous[id],
			match, posX, posY,
			INERTIA_ACCELERATION = 1.15;

		delete previous[id];

		if (curr.timer) { clearTimeout(curr.timer); }

		// Enable usage of resetEffects during glide or bounce.
		curr.resetEffects = resetEffects;

		// calculate velocity based on time and displacement since last tick
		match = translateRx.exec(curr.node.style[transformProp]);
		if (match) {
			posX = +match[1];
			posY = +match[2];
		} else {
			posX = posY = 0;
		}

		// If there is no glide to perform (no exit velocity), or if we are
		// beyond boundaries on all applicable edges, immediately bounce back.
		if ((!curr.velX && !curr.velY) ||
				((posX >= 0 || posX <= -(curr.scrollWidth - curr.parentWidth)) &&
				(posY >= 0 || posY <= -(curr.scrollHeight - curr.parentHeight)))) {
			bounce(id, posX, posY);
			return;
		}

		function sameSign(a, b) {
			return ((a.velX <= 0 && b.velX <= 0) || (a.velX >= 0 && b.velX >= 0)) &&
					((a.velY <= 0 && b.velY <= 0) || (a.velY >= 0 && b.velY >= 0));
		}

		if (prev && (prev.velX || prev.velY) && sameSign(curr, prev)) {
			curr.velX = (curr.velX + prev.velX) * INERTIA_ACCELERATION;
			curr.velY = (curr.velY + prev.velY) * INERTIA_ACCELERATION;
		}

		// update lastX/Y with current position, for glide calculations
		curr.lastX = posX;
		curr.lastY = posY;
		curr.calcFunc = function () { calcGlide(id); };
		curr.timer = setTimeout(curr.calcFunc, glideTimerRes);
	}
	function calcGlide(id) {
		// performs glide and decelerates according to widget's glideDecel method
		var curr = current[id],
			node, parentNode, widget, i,
			nx, ny, nvx, nvy, // old/new coords and new velocities
			BOUNCE_DECELERATION_AMOUNT = 6;

		if (!curr) { return; }

		node = curr.node;
		parentNode = node.parentNode;
		widget = curr.widget;
		nvx = widget.glideDecel(curr.velX);
		nvy = widget.glideDecel(curr.velY);

		if (Math.abs(nvx) >= glideThreshold || Math.abs(nvy) >= glideThreshold) {
			// still above stop threshold; update transformation
			nx = curr.lastX + nvx;
			ny = curr.lastY + nvy;

			// If glide has traveled beyond any edges, institute rubber-band effect
			// by further decelerating.
			if (nx > 0 || nx < -(curr.scrollWidth - curr.parentWidth)) {
				for (i = BOUNCE_DECELERATION_AMOUNT; i--;) {
					nvx = widget.glideDecel(nvx);
				}
			}
			if (ny > 0 || ny < -(curr.scrollHeight - curr.parentHeight)) {
				for (i = BOUNCE_DECELERATION_AMOUNT; i--;) {
					nvy = widget.glideDecel(nvy);
				}
			}

			// still scrollable; update offsets/velocities and schedule next tick
			scroll(widget, -nx, -ny); // call scroll with positive coordinates
			// update information
			curr.lastX = nx;
			curr.lastY = ny;
			curr.velX = nvx;
			curr.velY = nvy;
			curr.timer = setTimeout(curr.calcFunc, glideTimerRes);
		}
		else {
			bounce(id, curr.lastX, curr.lastY);
		}
	}

	return declare(null, {
		// touchesToScroll: Number
		//		Number of touches to require on the component's touch target node
		//		in order to trigger scrolling behavior.
		touchesToScroll: 1,

		// touchNode: DOMNode?
		//		Node upon which scroll behavior will be based; transformations will be
		//		applied to this node, and events and some DOM/styles will be applied
		//		to its *parent*.  If not specified, defaults to containerNode.
		touchNode: null,

		// scrollThreshold: Number
		//		Minimum number of pixels to wait for user to scroll (in any direction)
		//		before initiating scroll.
		scrollThreshold: 10,

		// bounceDuration: Number
		//		Number of milliseconds which "rubber-banding" transitions
		//		(i.e. bouncing back from beyond edges) should take.
		bounceDuration: 300,

		postCreate: function () {
			this._initTouch();
			this.inherited(arguments);
		},

		_initTouch: function () {
			var node = this.touchNode = this.touchNode || this.containerNode,
				widget = this,
				parentNode;

			if (!node || !node.parentNode) {
				// Bail out if we have no touchNode or containerNode, or if we don't
				// seem to have a parent node to work with.
				console.warn('TouchScroll requires a nested node upon which to operate.');
				return;
			}

			parentNode = node.parentNode;

			// Set overflow to hidden in order to prevent any native scroll logic.
			parentNode.style.overflow = 'hidden';

			node.style[transitionPrefix + 'Property'] = cssPrefix + 'transform';
			node.style[transitionPrefix + 'TimingFunction'] =
				'cubic-bezier(0.33, 0.66, 0.66, 1)';

			function cancelTouchScroll() {
				widget.cancelTouchScroll();
			}

			function wrapHandler(func) {
				return function (evt) {
					evt.widget = widget;
					evt.cancelTouchScroll = cancelTouchScroll;
					func.call(this, evt);
				};
			}

			this._touchScrollListeners = [
				on(parentNode, 'touchstart', wrapHandler(ontouchstart)),
				on(parentNode, 'touchmove', wrapHandler(ontouchmove)),
				on(parentNode, 'touchend,touchcancel', wrapHandler(ontouchend))
			];
		},

		destroy: function () {
			var i = this._touchScrollListeners.length;
			while (i--) {
				this._touchScrollListeners[i].remove();
			}
			delete current[this.id];

			this.inherited(arguments);
		},

		scrollTo: function (options) {
			// summary:
			//      Scrolls the widget to a specific position.
			// options: Object
			//		Object containing target x and/or y position to scroll to
			//		(if unspecified, scroll in that direction will be preserved).
			//		Also supports the following other options:
			//		* preserveMomentum: if true, will not reset any active
			//			momentum or bounce on the widget

			var curr = current[this.id],
				touchNode = this.touchNode,
				parentNode = touchNode.parentNode;

			if (!options.preserveMomentum && curr && curr.resetEffects) {
				// Stop any glide or bounce occurring before scrolling.
				curr.resetEffects();
			}

			// Constrain coordinates within scrollable boundaries.
			if (options.x) {
				options.x = Math.max(0, Math.min(options.x,
					touchNode.scrollWidth - parentNode.offsetWidth));
			}
			if (options.y) {
				options.y = Math.max(0, Math.min(options.y,
					touchNode.scrollHeight - parentNode.offsetHeight));
			}

			scroll(this, options);
		},

		getScrollPosition: function () {
			// summary:
			//      Determines current translation from computed style
			//      (if mid-transition), or applied style.
			var match = getScrollStyle(this);
			return match ? { x: -match[1], y: -match[2] } : { x: 0, y: 0 };
		},

		cancelTouchScroll: function () {
			// summary:
			//		Removes any existing scroll information for this component from the
			//		current map, effectively canceling any TouchScroll behavior for
			//		that particular touch gesture.

			var curr = current[this.id];
			if (!curr) { return; }

			if (curr.resetEffects) { curr.resetEffects(); }
			else {
				if (curr.timer) { clearTimeout(curr.timer); }
				domClass.add(curr.node.parentNode, 'touchscroll-fadeout');
			}

			delete current[this.id];
		},

		glideDecel: function (n) {
			// summary:
			//		Deceleration algorithm. Given a number representing velocity,
			//		returns a new velocity to impose for the next "tick".
			//		(Don't forget that velocity can be positive or negative!)
			return n * 0.9; // Number
		}
	});
});

},
'dojo/errors/RequestTimeoutError':function(){
define(['./create', './RequestError'], function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
});

},
'wcDocker/layoutsimple':function(){
/** @module wcLayoutSimple */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/layout"
], function (dcl, wcDocker, wcLayout) {

    /**
     * @class
     * A simple layout for containing elements in a panel. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} can optionally contain these instead of the default {@link wcLayoutTable}.
     */
    var Module = dcl(wcLayout, {
        declaredClass: 'wcLayoutSimple',

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, appending it to the main element.
         * @function module:wcLayoutSimple#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         */
        addItem: function (item) {
            this.$elem.append(item);
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayoutSimple#clear
         */
        clear: function () {
            this.$elem.remove();
            this.$elem = null;
            this.__init();
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$elem = $('<div class="wcLayout wcWide wcTall"></div>');
            this.__container(this.$container);
        },

        // Updates the size of the layout.
        __update: function () {
        }
    });

    return Module;
});


},
'dojo/NodeList-dom':function(){
define(["./_base/kernel", "./query", "./_base/array", "./_base/lang", "./dom-class", "./dom-construct", "./dom-geometry", "./dom-attr", "./dom-style"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle){

	// module:
	//		dojo/NodeList-dom.js

	/*=====
	 return function(){
		 // summary:
		 //		Adds DOM related methods to NodeList, and returns NodeList constructor.
	 };
	 =====*/

	var magicGuard = function(a){
		// summary:
		//		the guard function for dojo/dom-attr() and dojo/dom-style()
		return a.length == 1 && (typeof a[0] == "string"); // inline'd type check
	};

	var orphan = function(node){
		// summary:
		//		function to orphan nodes
		var p = node.parentNode;
		if(p){
			p.removeChild(node);
		}
	};
	// FIXME: should we move orphan() to dojo/_base/html?

	var NodeList = query.NodeList,
		awc = NodeList._adaptWithCondition,
		aafe = NodeList._adaptAsForEach,
		aam = NodeList._adaptAsMap;

	function getSet(module){
		return function(node, name, value){
			if(arguments.length == 2){
				return module[typeof name == "string" ? "get" : "set"](node, name);
			}
			// setter
			return module.set(node, name, value);
		};
	}

	lang.extend(NodeList, {
		_normalize: function(/*String||Element||Object||NodeList*/content, /*DOMNode?*/refNode){
			// summary:
			//		normalizes data to an array of items to insert.
			// description:
			//		If content is an object, it can have special properties "template" and
			//		"parse". If "template" is defined, then the template value is run through
			//		dojo/string.substitute (if dojo/string.substitute() has been required elsewhere),
			//		or if templateFunc is a function on the content, that function will be used to
			//		transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
			//		If content.parse is true, then it is remembered for later, for when the content
			//		nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
			//		(if dojo/parser has been required elsewhere).

			//Wanted to just use a DocumentFragment, but for the array/NodeList
			//case that meant using cloneNode, but we may not want that.
			//Cloning should only happen if the node operations span
			//multiple refNodes. Also, need a real array, not a NodeList from the
			//DOM since the node movements could change those NodeLists.

			var parse = content.parse === true;

			//Do we have an object that needs to be run through a template?
			if(typeof content.template == "string"){
				var templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);
				content = templateFunc ? templateFunc(content.template, content) : content;
			}

			var type = (typeof content);
			if(type == "string" || type == "number"){
				content = domCtr.toDom(content, (refNode && refNode.ownerDocument));
				if(content.nodeType == 11){
					//DocumentFragment. It cannot handle cloneNode calls, so pull out the children.
					content = lang._toArray(content.childNodes);
				}else{
					content = [content];
				}
			}else if(!lang.isArrayLike(content)){
				content = [content];
			}else if(!lang.isArray(content)){
				//To get to this point, content is array-like, but
				//not an array, which likely means a DOM NodeList. Convert it now.
				content = lang._toArray(content);
			}

			//Pass around the parse info
			if(parse){
				content._runParse = true;
			}
			return content; //Array
		},

		_cloneNode: function(/*DOMNode*/ node){
			// summary:
			//		private utility to clone a node. Not very interesting in the vanilla
			//		dojo/NodeList case, but delegates could do interesting things like
			//		clone event handlers if that is derivable from the node.
			return node.cloneNode(true);
		},

		_place: function(/*Array*/ary, /*DOMNode*/refNode, /*String*/position, /*Boolean*/useClone){
			// summary:
			//		private utility to handle placing an array of nodes relative to another node.
			// description:
			//		Allows for cloning the nodes in the array, and for
			//		optionally parsing widgets, if ary._runParse is true.

			//Avoid a disallowed operation if trying to do an innerHTML on a non-element node.
			if(refNode.nodeType != 1 && position == "only"){
				return;
			}
			var rNode = refNode, tempNode;

			//Always cycle backwards in case the array is really a
			//DOM NodeList and the DOM operations take it out of the live collection.
			var length = ary.length;
			for(var i = length - 1; i >= 0; i--){
				var node = (useClone ? this._cloneNode(ary[i]) : ary[i]);

				//If need widget parsing, use a temp node, instead of waiting after inserting into
				//real DOM because we need to start widget parsing at one node up from current node,
				//which could cause some already parsed widgets to be parsed again.
				if(ary._runParse && dojo.parser && dojo.parser.parse){
					if(!tempNode){
						tempNode = rNode.ownerDocument.createElement("div");
					}
					tempNode.appendChild(node);
					dojo.parser.parse(tempNode);
					node = tempNode.firstChild;
					while(tempNode.firstChild){
						tempNode.removeChild(tempNode.firstChild);
					}
				}

				if(i == length - 1){
					domCtr.place(node, rNode, position);
				}else{
					rNode.parentNode.insertBefore(node, rNode);
				}
				rNode = node;
			}
		},


		position: aam(domGeom.position),
		/*=====
		position: function(){
			// summary:
			//		Returns border-box objects (x/y/w/h) of all elements in a node list
			//		as an Array (*not* a NodeList). Acts like `dojo/dom-geometry-position`, though
			//		assumes the node passed is each node in this list.

			return dojo.map(this, dojo.position); // Array
		},
		=====*/

		attr: awc(getSet(domAttr), magicGuard),
		/*=====
		attr: function(property, value){
			// summary:
			//		gets or sets the DOM attribute for every element in the
			//		NodeList. See also `dojo/dom-attr`
			// property: String
			//		the attribute to get/set
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of attribute values
			//		If a value is passed, the return is this NodeList
			// example:
			//		Make all nodes with a particular class focusable:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query(".focusable").attr("tabIndex", -1);
			//	|	});
			// example:
			//		Disable a group of buttons:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query("button.group").attr("disabled", true);
			//	|	});
			// example:
			//		innerHTML can be assigned or retrieved as well:
			//	|	// get the innerHTML (as an array) for each list item
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		var ih = query("li.replaceable").attr("innerHTML");
			//	|	});
			return; // dojo/NodeList|Array
		},
		=====*/

		style: awc(getSet(domStyle), magicGuard),
		/*=====
		style: function(property, value){
			// summary:
			//		gets or sets the CSS property for every element in the NodeList
			// property: String
			//		the CSS property to get/set, in JavaScript notation
			//		("lineHieght" instead of "line-height")
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of strings.
			//		If a value is passed, the return is this NodeList
			return; // dojo/NodeList
			return; // Array
		},
		=====*/

		addClass: aafe(domCls.add),
		/*=====
		addClass: function(className){
			// summary:
			//		adds the specified class to every node in the list
			// className: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		},
		=====*/

		removeClass: aafe(domCls.remove),
		/*=====
		removeClass: function(className){
			// summary:
			//		removes the specified class from every node in the list
			// className: String|Array?
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			// returns:
			//		this list
			return; // dojo/NodeList
		},
		=====*/

		toggleClass: aafe(domCls.toggle),
		/*=====
		toggleClass: function(className, condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			// condition: Boolean?
			//		If passed, true means to add the class, false means to remove.
			// className: String
			//		the CSS class to add
			return; // dojo/NodeList
		},
		=====*/

		replaceClass: aafe(domCls.replace),
		/*=====
		replaceClass: function(addClassStr, removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling `removeClass()` and `addClass()`
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		 },
		 =====*/

		empty: aafe(domCtr.empty),
		/*=====
		empty: function(){
			// summary:
			//		clears all content from each node in the list. Effectively
			//		equivalent to removing all child nodes from every item in
			//		the list.
			return this.forEach("item.innerHTML='';"); // dojo/NodeList
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		=====*/

		removeAttr: aafe(domAttr.remove),
		/*=====
		 removeAttr: function(name){
			// summary:
			//		Removes an attribute from each node in the list.
			// name: String
			//		the name of the attribute to remove
			return;		// dojo/NodeList
		},
		=====*/

		marginBox: aam(domGeom.getMarginBox),
		/*=====
		marginBox: function(){
			// summary:
			//		Returns margin-box size of nodes
		 	return; // dojo/NodeList
		 },
		 =====*/

		// FIXME: connectPublisher()? connectRunOnce()?

		/*
		destroy: function(){
			// summary:
			//		destroys every item in the list.
			this.forEach(d.destroy);
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		*/

		place: function(/*String||Node*/ queryOrNode, /*String*/ position){
			// summary:
			//		places elements of this node list relative to the first element matched
			//		by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
			// queryOrNode:
			//		may be a string representing any valid CSS3 selector or a DOM node.
			//		In the selector case, only the first matching element will be used
			//		for relative positioning.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			var item = query(queryOrNode)[0];
			return this.forEach(function(node){ domCtr.place(node, item, position); }); // dojo/NodeList
		},

		orphan: function(/*String?*/ filter){
			// summary:
			//		removes elements in this list that match the filter
			//		from their parents and returns them as a new NodeList.
			// filter:
			//		CSS selector like ".foo" or "div > span"
			// returns:
			//		NodeList containing the orphaned elements
			return (filter ? query._filterResult(this, filter) : this).forEach(orphan); // dojo/NodeList
		},

		adopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){
			// summary:
			//		places any/all elements in queryOrListOrNode at a
			//		position relative to the first element in this list.
			//		Returns a dojo/NodeList of the adopted elements.
			// queryOrListOrNode:
			//		a DOM node or a query string or a query result.
			//		Represents the nodes to be adopted relative to the
			//		first element of this NodeList.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			return query(queryOrListOrNode).place(this[0], position)._stash(this);	// dojo/NodeList
		},

		// FIXME: do we need this?
		query: function(/*String*/ queryStr){
			// summary:
			//		Returns a new list whose members match the passed query,
			//		assuming elements of the current NodeList as the root for
			//		each search.
			// example:
			//		assume a DOM created by this markup:
			//	|	<div id="foo">
			//	|		<p>
			//	|			bacon is tasty, <span>dontcha think?</span>
			//	|		</p>
			//	|	</div>
			//	|	<div id="bar">
			//	|		<p>great comedians may not be funny <span>in person</span></p>
			//	|	</div>
			//		If we are presented with the following definition for a NodeList:
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		var l = new NodeList(dom.byId("foo"), dom.byId("bar"));
			//		it's possible to find all span elements under paragraphs
			//		contained by these elements with this sub-query:
			//	|		var spans = l.query("p span");
			//	|	});

			// FIXME: probably slow
			if(!queryStr){ return this; }
			var ret = new NodeList;
			this.map(function(node){
				// FIXME: why would we ever get undefined here?
				query(queryStr, node).forEach(function(subNode){
					if(subNode !== undefined){
						ret.push(subNode);
					}
				});
			});
			return ret._stash(this);	// dojo/NodeList
		},

		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in dojo.filter:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter(function(item){
			//	|			// highlight every paragraph
			//	|			return (item.nodeName == "p");
			//	|		}).style("backgroundColor", "yellow");
			//	|	});
			// example:
			//	the same filtering using a CSS selector
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter("p").styles("backgroundColor", "yellow");
			//	|	});
			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},

		/*
		// FIXME: should this be "copyTo" and include parenting info?
		clone: function(){
			// summary:
			//		creates node clones of each element of this list
			//		and returns a new list containing the clones
		},
		*/

		addContent: function(/*String||DomNode||Object||dojo/NodeList*/ content, /*String||Integer?*/ position){
			// summary:
			//		add a node, NodeList or some HTML as a string to every item in the
			//		list.  Returns the original list.
			// description:
			//		a copy of the HTML content is added to each item in the
			//		list, with an optional position argument. If no position
			//		argument is provided, the content is appended to the end of
			//		each item.
			// content:
			//		DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
			//		NodeList, the content will be cloned if the current NodeList has more than one
			//		element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
			//		it should be an object with at "template" String property that has the HTML string
			//		to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
			//		will be used on the "template" to generate the final HTML string. Other allowed
			//		properties on the object are: "parse" if the HTML
			//		string should be parsed for widgets (dojo.require("dojo.parser") to get that
			//		option to work), and "templateFunc" if a template function besides dojo.string.substitute
			//		should be used to transform the "template".
			// position:
			//		can be one of:
			//
			//		-	"last"||"end" (default)
			//		-	"first||"start"
			//		-	"before"
			//		-	"after"
			//		-	"replace" (replaces nodes in this NodeList with new content)
			//		-	"only" (removes other children of the nodes so new content is the only child)
			//
			//		or an offset in the childNodes property
			// example:
			//		appends content to the end if the position is omitted
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("h3 > p").addContent("hey there!");
			//	|	});
			// example:
			//		add something to the front of each element that has a
			//		"thinger" property:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("[thinger]").addContent("...", "first");
			//	|	});
			// example:
			//		adds a header before each element of the list
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query(".note").addContent("<h4>NOTE:</h4>", "before");
			//	|	});
			// example:
			//		add a clone of a DOM node to the end of every element in
			//		the list, removing it from its existing parent.
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		query(".note").addContent(dom.byId("foo"));
			//	|	});
			// example:
			//		Append nodes from a templatized string.
			//	|	require(["dojo/string", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, query){
			//	|		query(".note").addContent({
			//	|			template: '<b>${id}: </b><span>${name}</span>',
			//	|			id: "user332",
			//	|			name: "Mr. Anderson"
			//	|		});
			//	|	});
			// example:
			//		Append nodes from a templatized string that also has widgets parsed.
			//	|	require(["dojo/string", "dojo/parser", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, parser, query){
			//	|		var notes = query(".note").addContent({
			//	|			template: '<button dojoType="dijit/form/Button">${text}</button>',
			//	|			parse: true,
			//	|			text: "Send"
			//	|		});
			//	|	});
			content = this._normalize(content, this[0]);
			for(var i = 0, node; (node = this[i]); i++){
				if(content.length){
					this._place(content, node, position, i > 0);
				}else{
					// if it is an empty array, we empty the target node
					domCtr.empty(node);
				}
			}
			return this; // dojo/NodeList
		}
	});

	return NodeList;
});

},
'xide/mixins/ResourceMixin':function(){
/** @mixin xide/mixin/ResourceMixin **/
define([
    'xdojo/declare',
    'xide/utils',
    'dojo/Deferred'
], function (declare, utils,Deferred) {

    var win = window,
        doc = win.document,
        domWaiters = [],
        queue = [], // waiters for the "head ready" event
        handlers = {}, // user functions waiting for events
        assets = {}, // loadable items in various states
        isAsync = "async" in doc.createElement("script") || "MozAppearance" in doc.documentElement.style || win.opera,
        isHeadReady,
        isDomReady,

        /*** public API ***/
        headVar = win.head_conf && win.head_conf.head || "head",

        api = win[headVar] = (win[headVar] || function () {
            // so wtf does this do ?
            //console.log("setup empty");
            api.ready.apply(null, arguments);
        }),

    // states
        PRELOADING = 1,
        PRELOADED = 2,
        LOADING = 3,
        LOADED = 4;

    //#region PRIVATE functions

    //#region Helper functions
    function noop() {
        // does nothing
    }

    function each(arr, callback) {
        if (!arr) {
            return;
        }

        // arguments special type
        if (typeof arr === "object") {
            arr = [].slice.call(arr);
        }

        // do the job
        for (var i = 0, l = arr.length; i < l; i++) {
            callback.call(arr, arr[i], i);
        }
    }

    /* A must read: http://bonsaiden.github.com/JavaScript-Garden
     ************************************************************/
    function is(type, obj) {
        var clas = Object.prototype.toString.call(obj).slice(8, -1);
        return obj !== undefined && obj !== null && clas === type;
    }

    function isFunction(item) {
        return is("Function", item);
    }

    function isArray(item) {
        return is("Array", item);
    }

    function toLabel(url) {
        ///<summary>Converts a url to a file label</summary>
        var items = url.split("/"),
            name = items[items.length - 1],
            i = name.indexOf("?");

        return i !== -1 ? name.substring(0, i) : name;
    }

    // INFO: this look like a "im triggering callbacks all over the place, but only wanna run it one time function" ..should try to make everything work without it if possible
    // INFO: Even better. Look into promises/defered's like jQuery is doing
    function one(callback) {
        ///<summary>Execute a callback only once</summary>
        callback = callback || noop;

        if (callback._done) {
            return;
        }

        callback();
        callback._done = 1;
    }

    //#endregion

    function conditional(test, success, failure, callback) {
        ///<summary>
        /// INFO: use cases:
        ///    head.test(condition, null       , "file.NOk" , callback);
        ///    head.test(condition, "fileOk.js", null       , callback);
        ///    head.test(condition, "fileOk.js", "file.NOk" , callback);
        ///    head.test(condition, "fileOk.js", ["file.NOk", "file.NOk"], callback);
        ///    head.test({
        ///               test    : condition,
        ///               success : [{ label1: "file1Ok.js"  }, { label2: "file2Ok.js" }],
        ///               failure : [{ label1: "file1NOk.js" }, { label2: "file2NOk.js" }],
        ///               callback: callback
        ///    );
        ///    head.test({
        ///               test    : condition,
        ///               success : ["file1Ok.js" , "file2Ok.js"],
        ///               failure : ["file1NOk.js", "file2NOk.js"],
        ///               callback: callback
        ///    );
        ///</summary>
        var obj = (typeof test === "object") ? test : {
            test: test,
            success: !!success ? isArray(success) ? success : [success] : false,
            failure: !!failure ? isArray(failure) ? failure : [failure] : false,
            callback: callback || noop
        };

        // Test Passed ?
        var passed = !!obj.test;

        // Do we have a success case
        if (passed && !!obj.success) {
            obj.success.push(obj.callback);
            api.load.apply(null, obj.success);
        }
        // Do we have a fail case
        else if (!passed && !!obj.failure) {
            obj.failure.push(obj.callback);
            api.load.apply(null, obj.failure);
        }
        else {
            callback();
        }

        return api;
    }

    function getAsset(item) {

        ///<summary>
        /// Assets are in the form of
        /// {
        ///     name : label,
        ///     url  : url,
        ///     state: state
        /// }
        ///</summary>
        var asset = {};

        if (typeof item === "object") {
            for (var label in item) {
                if (!!item[label]) {
                    asset = {
                        name: label,
                        url: item[label]
                    };
                }
            }
        }
        else {
            asset = {
                name: toLabel(item),
                url: item
            };
        }

        // is the item already existant
        var existing = assets[asset.name];
        if (existing && existing.url === asset.url) {
            return existing;
        }

        assets[asset.name] = asset;
        return asset;
    }

    function allLoaded(items) {
        items = items || assets;

        for (var name in items) {
            if (items.hasOwnProperty(name) && items[name].state !== LOADED) {
                return false;
            }
        }

        return true;
    }

    function onPreload(asset) {
        asset.state = PRELOADED;

        each(asset.onpreload, function (afterPreload) {
            afterPreload.call();
        });
    }

    function preLoad(asset, callback) {
        if (asset.state === undefined) {

            asset.state = PRELOADING;
            asset.onpreload = [];

            loadAsset({url: asset.url, type: "cache"}, function () {
                onPreload(asset);
            });
        }
    }

    function apiLoadHack() {
        /// <summary>preload with text/cache hack
        ///
        /// head.load("http://domain.com/file.js","http://domain.com/file.js", callBack)
        /// head.load(["http://domain.com/file.js","http://domain.com/file.js"], callBack)
        /// head.load({ label1: "http://domain.com/file.js" }, { label2: "http://domain.com/file.js" }, callBack)
        /// head.load([{ label1: "http://domain.com/file.js" }, { label2: "http://domain.com/file.js" }], callBack)
        /// </summary>

        var args = arguments,
            rest = [].slice.call(args, 1),
            next = rest[0];

        // wait for a while. immediate execution causes some browsers to ignore caching
        if (!isHeadReady) {
            queue.push(function () {
                api.load.apply(null, args);
            });

            return api;
        }

        // multiple arguments
        if (!!next) {
            /* Preload with text/cache hack (not good!)
             * http://blog.getify.com/on-script-loaders/
             * http://www.nczonline.net/blog/2010/12/21/thoughts-on-script-loaders/
             * If caching is not configured correctly on the server, then items could load twice !
             *************************************************************************************/
            each(rest, function (item) {
                // item is not a callback or empty string
                if (!isFunction(item) && !!item) {
                    preLoad(getAsset(item));
                }
            });

            // execute
            load(getAsset(args[0]), isFunction(next) ? next : function () {
                api.load.apply(null, rest);
            });
        }
        else {
            // single item
            load(getAsset(args[0]));
        }

        return api;
    }

    function apiLoadAsync() {
        ///<summary>
        /// simply load and let browser take care of ordering
        ///
        ///    head.load("http://domain.com/file.js","http://domain.com/file.js", callBack)
        /// head.load(["http://domain.com/file.js","http://domain.com/file.js"], callBack)
        ///    head.load({ label1: "http://domain.com/file.js" }, { label2: "http://domain.com/file.js" }, callBack)
        /// head.load([{ label1: "http://domain.com/file.js" }, { label2: "http://domain.com/file.js" }], callBack)
        ///</summary>
        var args = arguments,
            callback = args[args.length - 1],
            items = {};

        if (!isFunction(callback)) {
            callback = null;
        }

        // if array, repush as args
        if (isArray(args[0])) {
            args[0].push(callback);
            api.load.apply(null, args[0]);

            return api;
        }

        // JRH 262#issuecomment-26288601
        // First populate the items array.
        // When allLoaded is called, all items will be populated.
        // Issue when lazy loaded, the callback can execute early.
        each(args, function (item, i) {
            if (item !== callback) {
                item = getAsset(item);
                items[item.name] = item;
            }
        });

        each(args, function (item, i) {
            if (item !== callback) {
                item = getAsset(item);

                load(item, function () {
                    if (allLoaded(items)) {
                        one(callback);
                    }
                });
            }
        });

        return api;
    }

    function load(asset, callback) {

        ///<summary>Used with normal loading logic</summary>
        callback = callback || noop;

        if (asset.state === LOADED) {
            callback();
            return;
        }

        // INFO: why would we trigger a ready event when its not really loaded yet ?
        if (asset.state === LOADING) {
            api.ready(asset.name, callback);
            return;
        }

        if (asset.state === PRELOADING) {
            asset.onpreload.push(function () {
                load(asset, callback);
            });
            return;
        }
        asset.state = LOADING;

        loadAsset(asset, function () {
            asset.state = LOADED;

            callback();

            // handlers for this asset
            each(handlers[asset.name], function (fn) {
                one(fn);
            });

            // dom is ready & no assets are queued for loading
            // INFO: shouldn't we be doing the same test above ?
            if (isDomReady && allLoaded()) {
                each(handlers.ALL, function (fn) {
                    one(fn);
                });
            }
        });
    }

    /* Parts inspired from: https://github.com/cujojs/curl
     ******************************************************/
    function loadAsset(asset, callback) {

        var dfd = new Deferred();

        callback = callback || noop;

        function error(event) {
            event = event || win.event;

            // release event listeners
            ele.onload = ele.onreadystatechange = ele.onerror = null;

            // do callback
            callback();

            dfd.reject({
                asset:asset,
                error:event
            });

            // need some more detailed error handling here
        }

        function process(event) {
            event = event || win.event;

            // IE 7/8 (2 events on 1st load)
            // 1) event.type = readystatechange, s.readyState = loading
            // 2) event.type = readystatechange, s.readyState = loaded

            // IE 7/8 (1 event on reload)
            // 1) event.type = readystatechange, s.readyState = complete

            // event.type === 'readystatechange' && /loaded|complete/.test(s.readyState)

            // IE 9 (3 events on 1st load)
            // 1) event.type = readystatechange, s.readyState = loading
            // 2) event.type = readystatechange, s.readyState = loaded
            // 3) event.type = load            , s.readyState = loaded

            // IE 9 (2 events on reload)
            // 1) event.type = readystatechange, s.readyState = complete
            // 2) event.type = load            , s.readyState = complete

            // event.type === 'load'             && /loaded|complete/.test(s.readyState)
            // event.type === 'readystatechange' && /loaded|complete/.test(s.readyState)

            // IE 10 (3 events on 1st load)
            // 1) event.type = readystatechange, s.readyState = loading
            // 2) event.type = load            , s.readyState = complete
            // 3) event.type = readystatechange, s.readyState = loaded

            // IE 10 (3 events on reload)
            // 1) event.type = readystatechange, s.readyState = loaded
            // 2) event.type = load            , s.readyState = complete
            // 3) event.type = readystatechange, s.readyState = complete

            // event.type === 'load'             && /loaded|complete/.test(s.readyState)
            // event.type === 'readystatechange' && /complete/.test(s.readyState)

            // Other Browsers (1 event on 1st load)
            // 1) event.type = load, s.readyState = undefined

            // Other Browsers (1 event on reload)
            // 1) event.type = load, s.readyState = undefined

            // event.type == 'load' && s.readyState = undefined

            // !doc.documentMode is for IE6/7, IE8+ have documentMode
            if (event.type === "load" || (/loaded|complete/.test(ele.readyState) && (!doc.documentMode || doc.documentMode < 9))) {
                // release event listeners
                ele.onload = ele.onreadystatechange = ele.onerror = null;

                // do callback
                callback();

                dfd.resolve({
                    asset:asset,
                    node:ele
                })
            }

            // emulates error on browsers that don't create an exception
            // INFO: timeout not clearing ..why ?
            //asset.timeout = win.setTimeout(function () {
            //    error({ type: "timeout" });
            //}, 3000);
        }

        var ele;
        if (/\.css[^\.]*$/.test(asset.url)) {
            ele = doc.createElement("link");
            ele.type = "text/" + (asset.type || "css");
            ele.rel = "stylesheet";
            ele.href = asset.url;

            // https://github.com/headjs/headjs/pull/240
            //if (ele.onload !== null) {   // to support browsers which dont have an onload event on link tags
            //    var img = document.createElement('img');
            //    img.onerror = function() {
            //        process({ "type": "load" });
            //    };
            //    img.src = asset.url;
            //}

        }
        else {
            ele = doc.createElement("script");
            ele.type = "text/" + (asset.type || "javascript");
            ele.src = asset.url;
        }

        ele.onload = ele.onreadystatechange = process;
        ele.onerror = error;

        /* Good read, but doesn't give much hope !
         * http://blog.getify.com/on-script-loaders/
         * http://www.nczonline.net/blog/2010/12/21/thoughts-on-script-loaders/
         * https://hacks.mozilla.org/2009/06/defer/
         */

        // ASYNC: load in parallel and execute as soon as possible
        ele.async = false;
        // DEFER: load in parallel but maintain execution order
        ele.defer = false;

        // use insertBefore to keep IE from throwing Operation Aborted (thx Bryan Forbes!)
        var head = doc.head || doc.getElementsByTagName("head")[0];
        // but insert at end of head, because otherwise if it is a stylesheet, it will not override values
        head.insertBefore(ele, head.lastChild);

        return dfd;


    }

    /* Parts inspired from: https://github.com/jrburke/requirejs
     ************************************************************/
    function init() {

        var items = doc.getElementsByTagName("script");

        // look for a script with a data-head-init attribute
        for (var i = 0, l = items.length; i < l; i++) {
            var dataMain = items[i].getAttribute("data-headjs-load");
            if (!!dataMain) {
                api.load(dataMain);
                return;
            }
        }
    }

    function ready(key, callback) {
        ///<summary>
        /// INFO: use cases:
        ///    head.ready(callBack);
        ///    head.ready(document , callBack);
        ///    head.ready("file.js", callBack);
        ///    head.ready("label"  , callBack);
        ///    head.ready(["label1", "label2"], callback);
        ///</summary>

        // DOM ready check: head.ready(document, function() { });
        if (key === doc) {
            if (isDomReady) {
                one(callback);
            }
            else {
                domWaiters.push(callback);
            }

            return api;
        }

        // shift arguments
        if (isFunction(key)) {
            callback = key;
            key = "ALL"; // holds all callbacks that where added without labels: ready(callBack)
        }

        // queue all items from key and return. The callback will be executed if all items from key are already loaded.
        if (isArray(key)) {
            var items = {};

            each(key, function (item) {
                items[item] = assets[item];
                api.ready(item, function () {
                    if (allLoaded(items)) {
                        one(callback);
                    }
                });
            });

            return api;
        }

        // make sure arguments are sane
        if (typeof key !== "string" || !isFunction(callback)) {
            return api;
        }

        // this can also be called when we trigger events based on filenames & labels
        var asset = assets[key];

        // item already loaded --> execute and return
        if (asset && asset.state === LOADED || key === "ALL" && allLoaded() && isDomReady) {
            one(callback);
            return api;
        }

        var arr = handlers[key];
        if (!arr) {
            arr = handlers[key] = [callback];
        }
        else {
            arr.push(callback);
        }

        return api;
    }

    /* Mix of stuff from jQuery & IEContentLoaded
     * http://dev.w3.org/html5/spec/the-end.html#the-end
     ***************************************************/
    function domReady() {
        // Make sure body exists, at least, in case IE gets a little overzealous (jQuery ticket #5443).
        if (!doc.body) {
            // let's not get nasty by setting a timeout too small.. (loop mania guaranteed if assets are queued)
            win.clearTimeout(api.readyTimeout);
            api.readyTimeout = win.setTimeout(domReady, 50);
            return;
        }

        if (!isDomReady) {
            isDomReady = true;

            init();
            each(domWaiters, function (fn) {
                one(fn);
            });
        }
    }

    function domContentLoaded() {
        // W3C
        if (doc.addEventListener) {
            doc.removeEventListener("DOMContentLoaded", domContentLoaded, false);
            domReady();
        }

        // IE
        else if (doc.readyState === "complete") {
            // we're here because readyState === "complete" in oldIE
            // which is good enough for us to call the dom ready!
            doc.detachEvent("onreadystatechange", domContentLoaded);
            domReady();
        }
    }



    // Catch cases where ready() is called after the browser event has already occurred.
    // we once tried to use readyState "interactive" here, but it caused issues like the one
    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    if (doc.readyState === "complete") {
       // domReady();
    }

    // W3C
    else if (doc.addEventListener) {

        //doc.addEventListener("DOMContentLoaded", domContentLoaded, false);

        // A fallback to window.onload, that will always work
        //win.addEventListener("load", domReady, false);
    }

    // IE
    else {

        /*
        // Ensure firing before onload, maybe late but safe also for iframes
        doc.attachEvent("onreadystatechange", domContentLoaded);

        // A fallback to window.onload, that will always work
        win.attachEvent("onload", domReady);

        // If IE and not a frame
        // continually check to see if the document is ready
        var top = false;

        try {
            top = !win.frameElement && doc.documentElement;
        } catch (e) {
        }

        if (top && top.doScroll) {
            (function doScrollCheck() {
                if (!isDomReady) {
                    try {
                        // Use the trick by Diego Perini
                        // http://javascript.nwbox.com/IEContentLoaded/
                        top.doScroll("left");
                    } catch (error) {
                        // let's not get nasty by setting a timeout too small.. (loop mania guaranteed if assets are queued)
                        win.clearTimeout(api.readyTimeout);
                        api.readyTimeout = win.setTimeout(doScrollCheck, 50);
                        return;
                    }

                    // and execute any waiting functions
                    domReady();
                }
            }());
        }
        */
    }



    api.load = api.js = isAsync ? apiLoadAsync : apiLoadHack;
    api.test = conditional;
    api.ready = ready;


    /**
     * Mixin to load resources
     * Currently stub
     */
    return declare("xide/mixins/ResourceMixin", null,{

        loadResource:function(url){


            var dfd = loadAsset({
                name:url,
                url:url
            }).then(function(info){
                console.log('got asset ' , info)
            },function(err){
                console.error('error loading asset ' ,err);
            });

            return dfd;
        }
    });
});
},
'wcDocker/types':function(){
define(["xide/types","xide/utils"], function (types,utils) {

    //stub
    var wcDocker = {};

    /**
     * Enumerated Docking positions.
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {String} module:wcDocker.DOCK
     */
    wcDocker.DOCK = {
        /** A floating panel that blocks input until closed */
        MODAL: 'modal',
        /** A floating panel */
        FLOAT: 'float',
        /** Docks to the top of a target or window */
        TOP: 'top',
        /** Docks to the left of a target or window */
        LEFT: 'left',
        /** Docks to the right of a target or window */
        RIGHT: 'right',
        /** Docks to the bottom of a target or window */
        BOTTOM: 'bottom',
        /** Docks as another tabbed item along with the target */
        STACKED: 'stacked'
    };

    /**
     * Enumerated Layout wcDocker.
     * @memberOf module:wcDocker
     * @version 3.0.0
     * @enum {String} module:wcDocker.LAYOUT
     */
    wcDocker.LAYOUT = {
        /** Contains a single div item without management using a {@link module:wcLayoutSimple}, it is up to you to populate it however you wish. */
        SIMPLE: 'wcLayoutSimple',
        /** Manages a table grid layout using {@link module:wcLayoutTable}, this is the default layout used if none is specified. **/
        TABLE: 'wcLayoutTable'
    };

    /**
     * Enumerated Internal events
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {String} module:wcDocker.EVENT
     */
    wcDocker.EVENT = {
        /** When the panel is initialized */
        INIT: 'panelInit',
        /** When all panels have finished loading */
        LOADED: 'dockerLoaded',
        /** When the panel is updated */
        UPDATED: 'panelUpdated',
        /**
         * When the panel has changed its visibility<br>
         * This event is called with the current visibility state as the first parameter.
         */
        VISIBILITY_CHANGED: 'panelVisibilityChanged',
        /** When the user begins moving any panel from its current docked position */
        BEGIN_DOCK: 'panelBeginDock',
        /** When the user finishes moving or docking a panel */
        END_DOCK: 'panelEndDock',
        /** When the user brings any panel within a tabbed frame into focus */
        GAIN_FOCUS: 'panelGainFocus',
        /** When the user leaves focus on any panel within a tabbed frame */
        LOST_FOCUS: 'panelLostFocus',
        /** When the panel is about to be closed, but before it closes. If any event handler returns a falsey value, the close action will be canceled. */
        CLOSING: 'panelClosing',
        /** When the panel is being closed */
        CLOSED: 'panelClosed',
        /** When a persistent panel is being hidden */
        PERSISTENT_CLOSED: 'panelPersistentClosed',
        /** When a persistent panel is being shown */
        PERSISTENT_OPENED: 'panelPersistentOpened',
        /** When a custom button is clicked, See [wcPanel.addButton]{@link module:wcPanel~addButton} */
        BUTTON: 'panelButton',
        /** When the panel has moved from floating to a docked position */
        ATTACHED: 'panelAttached',
        /** When the panel has moved from a docked position to floating */
        DETACHED: 'panelDetached',
        /**
         * When the user has started moving the panel (top-left coordinates changed)<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVE_STARTED: 'panelMoveStarted',
        /**
         * When the user has finished moving the panel<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVE_ENDED: 'panelMoveEnded',
        /**
         * When the top-left coordinates of the panel has changed<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVED: 'panelMoved',
        /**
         * When the user has started resizing the panel (width or height changed)<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZE_STARTED: 'panelResizeStarted',
        /**
         * When the user has finished resizing the panel<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZE_ENDED: 'panelResizeEnded',
        /**
         * When the panels width or height has changed<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZED: 'panelResized',
        /** This only happens with floating windows when the order of the windows have changed. */
        ORDER_CHANGED: 'panelOrderChanged',
        /** When the contents of the panel has been scrolled */
        SCROLLED: 'panelScrolled',
        /** When the layout is being saved, See [wcDocker.save]{@link module:wcDocker#save} */
        SAVE_LAYOUT: 'layoutSave',
        /** When the layout is being restored, See [wcDocker.restore]{@link module:wcDocker#restore} */
        RESTORE_LAYOUT: 'layoutRestore',
        /** When the current tab on a custom tab widget associated with this panel has changed, See {@link module:wcTabFrame} */
        CUSTOM_TAB_CHANGED: 'customTabChanged',
        /** When a tab has been closed on a custom tab widget associated with this panel, See {@link module:wcTabFrame} */
        CUSTOM_TAB_CLOSED: 'customTabClosed',
        BEGIN_FLOAT_RESIZE: 'beginFloatResize',
        END_FLOAT_RESIZE: 'endFloatResize',
        BEGIN_RESIZE:"beginResize",
        END_RESIZE:"endResize"
    };

    /**
     * The name of the placeholder panel.
     * @private
     * @memberOf module:wcDocker
     * @constant {String} module:wcDocker.PANEL_PLACEHOLDER
     */
    wcDocker.PANEL_PLACEHOLDER = '__wcDockerPlaceholderPanel';

    /**
     * Used when [adding]{@link module:wcDocker#addPanel} or [moving]{@link module:wcDocker#movePanel} a panel to designate the target location as collapsed.<br>
     * Must be used with [docking]{@link module:wcDocker.DOCK} positions LEFT, RIGHT, or BOTTOM only.
     * @memberOf module:wcDocker
     * @constant {String} module:wcDocker.COLLAPSED
     */
    wcDocker.COLLAPSED = '__wcDockerCollapsedPanel';

    /**
     * Used for the splitter bar orientation.
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {Boolean} module:wcDocker.ORIENTATION
     */
    wcDocker.ORIENTATION = {
        /** Top and Bottom panes */
        VERTICAL: false,
        /** Left and Right panes */
        HORIZONTAL: true
    };
    /**
     * Used to determine the position of tabbed widgets for stacked panels.<br>
     * <b>Note:</b> Not supported on IE8 or below.
     * @version 3.0.0
     * @enum {String} module:wcDocker.TAB
     * @memberOf module:wcDocker
     */
    wcDocker.TAB = {
        /** The default, puts tabs at the top of the frame */
        TOP: 'top',
        /** Puts tabs on the left side of the frame */
        LEFT: 'left',
        /** Puts tabs on the right side of the frame */
        RIGHT: 'right',
        /** Puts tabs on the bottom of the frame */
        BOTTOM: 'bottom'
    };

    if(!types.DOCKER){
        types.DOCKER=wcDocker;
    }

    return wcDocker;

});
},
'dojo/cookie':function(){
define(["./_base/kernel", "./regexp"], function(dojo, regexp){

// module:
//		dojo/cookie

/*=====
var __cookieProps = {
	// expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	// path: String?
	//		The path to use for the cookie.
	// domain: String?
	//		The domain to use for the cookie.
	// secure: Boolean?
	//		Whether to only send the cookie on secure connections
};
=====*/


dojo.cookie = function(/*String*/name, /*String?*/ value, /*__cookieProps?*/ props){
	// summary:
	//		Get or set a cookie.
	// description:
	//		If one argument is passed, returns the value of the cookie
	//		For two or more arguments, acts as a setter.
	// name:
	//		Name of the cookie
	// value:
	//		Value for the cookie
	// props:
	//		Properties for the cookie
	// example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		cookie("configObj", json.stringify(config, {expires: 5 }));
	//	|	});
	//
	// example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		config = json.parse(cookie("configObj"));
	//	|	});
	//
	// example:
	//		delete a cookie:
	//	|	require(["dojo/cookie"], function(cookie){
	//	|		cookie("configObj", null, {expires: -1});
	//	|	});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	// summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'wcDocker/layouttable':function(){
/** @module wcLayoutTable */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/layout"
], function (dcl, wcDocker, wcLayout) {

    /**
     * @class module:wcLayoutTable
     * A gridded layout for arranging elements. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} contain these by default to handle their contents.
     */
    var Module = dcl(wcLayout, {
        declaredClass: 'wcLayoutTable',

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, expanding the grid size if necessary.
         * @function module:wcLayoutTable#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         * @param {Number} [x=0] - The horizontal grid position to place the element.
         * @param {Number} [y=0] - The vertical grid position to place the element.
         * @param {Number} [w=1] - The number of horizontal cells this item will take within the grid.
         * @param {Number} [h=1] - The number of vertical cells this item will take within the grid.
         * @returns {module:wcLayoutTable~tableItem|Boolean} The table data element of the cell that contains the item, or false if there was a problem.
         */
        addItem: function (item, x, y, w, h) {
            if (typeof x === 'undefined' || x < 0) {
                x = 0;
            }
            if (typeof y === 'undefined' || y < 0) {
                y = 0;
            }
            if (typeof w === 'undefined' || w <= 0) {
                w = 1;
            }
            if (typeof h === 'undefined' || h <= 0) {
                h = 1;
            }

            this.__resizeGrid(x + w - 1, y + h - 1);
            if (w > 1 || h > 1) {
                if (!this.__mergeGrid(x, y, w, h)) {
                    return false;
                }
            }

            this._grid[y][x].$el.append($(item));
            return this.item(x, y);
        },

        /**
         * Retrieves the table item at a given grid position, if it exists.
         * Note, if an item spans multiple cells, only the top-left most
         * cell will actually contain the table item.
         * @function module:wcLayoutTable#item
         * @param {Number} x - The horizontal grid position.
         * @param {Number} y - The vertical grid position.
         * @returns {module:wcLayoutTable~tableItem|Boolean} - The table item, or false if none was found.
         */
        item: function (x, y) {
            if (y >= this._grid.length) {
                return false;
            }

            if (x >= this._grid[y].length) {
                return false;
            }

            // Some cells are a merging of multiple cells. If this cell is
            // part of a merge for another cell, use that cell instead.
            // if (this._grid[y][x].x < 0 || this._grid[y][x].y < 0) {
            //   var grid = this._grid[y][x];
            //   x -= grid.x;
            //   y -= grid.y;
            // }

            var self = this;
            /**
             * The table item is an object that represents one cell in the layout table, it contains
             * convenient methods for cell alteration and supports chaining. Its purpose is
             * to remove the need to alter &lt;tr&gt; and &lt;td&gt; elements of the table directly.
             * @version 3.0.0
             * @example myPanel.addItem(domNode).css('text-align', 'right').css('border', '1px solid black').stretch('100%', '100%');
             * @typedef module:wcLayoutTable#tableItem
             * @property {jQuery~Object} $ - If you truely need the table cell [jQuery object]{@link jQuery~Object}, here it is.
             * @property {module:wcLayoutTable~tableItem_css} css - Wrapper to alter [jQuery's css]{@link http://api.jquery.com/css/} function.
             * @property {module:wcLayoutTable~tableItem_stretch} stretch - More reliable method for setting the table item width/height values.
             */
            var myItem = {
                $: self._grid[y][x].$el,

                /**
                 * <small><i>This function is found in {@link module:wcLayoutTable~tableItem}.</small></i><br>
                 * A wrapper for [jQuery's css]{@link http://api.jquery.com/css/} function.
                 * <b>Note:</b> It is recommended that you use [stretch]{@link wcLayoutTable~stretch} if you intend to alter width or height styles.
                 * @version 3.0.0
                 * @function module:wcLayoutTable#tableItem_css
                 * @param {String} style - The style attribute to alter.
                 * @param {String} [value] - The value of the attribute. If omitted, the current value of the attribute is returned instead of the [tableItem]{@link module:wcLayoutTable~tableItem} instance.
                 * @returns {module:wcLayoutTable~tableItem|String} - Self, for chaining, unless the value parameter was omitted.
                 */
                css: function (style, value) {
                    if (self._grid[y][x].$el) {
                        if (value === undefined) {
                            return self._grid[y][x].$el.css(style);
                        }

                        self._grid[y][x].$el.css(style, value);
                    }
                    return myItem;
                },

                /**
                 * <small><i>This function is found in {@link module:wcLayoutTable~tableItem}.</small></i><br>
                 * Sets the stretch amount for the current table item. This is more reliable than
                 * assigning width and height style attributes directly on the table item.
                 * @version 3.0.0
                 * @function module:wcLayoutTable#tableItem_stretch
                 * @param {Number|String} [sx] - The horizontal stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
                 * @param {Number|String} [sy] - The vertical stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
                 * @returns {module:wcLayoutTable~tableItem} - Self, for chaining.
                 */
                stretch: function (width, height) {
                    self.itemStretch(x, y, width, height);
                    return myItem;
                }
            };
            return myItem;
        },

        /**
         * Sets the stretch amount for a given table item. This is more reliable than
         * assigning width and height style attributes directly on the table item.
         * @version 3.0.0
         * @function module:wcLayoutTable#itemStretch
         * @param {Number} x - The horizontal grid position.
         * @param {Number} y - The vertical grid position.
         * @param {Number|String} [sx] - The horizontal stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [sy] - The vertical stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {Boolean} - Success or failure. A failure generally means your grid position was a merged grid cell.
         */
        itemStretch: function (x, y, sx, sy) {
            var wasBatched = this._batchProcess;

            this._batchProcess = true;
            this.__resizeGrid(x, y);

            var grid = this._grid[y][x];
            if (grid.x < 0 || grid.y < 0) {
                return false;
            }

            if (sx !== undefined) {
                grid.sx = sx;
            }
            if (sy !== undefined) {
                grid.sy = sy;
            }

            this._batchProcess = wasBatched;
            if (!wasBatched) {
                this.__resizeGrid(0, 0);
            }

            return true;
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayoutTable#clear
         */
        clear: function () {
            var showGrid = this.showGrid();
            var spacing = this.gridSpacing();
            var alternate = this.gridAlternate();

            this.$elem.remove();
            this.__init();

            this.showGrid(showGrid);
            this.gridSpacing(spacing);
            this.gridAlternate(alternate);

            this._grid = [];
        },

        /**
         * Begins a batch operation.  Basically it refrains from constructing
         * the layout grid, which causes a reflow, on each item added.  Instead,
         * The grid is only generated at the end once [wcLayoutTable.finishBatch]{@link wcLayoutTable#finishBatch} is called.
         * @function module:wcLayoutTable#startBatch
         */
        startBatch: function () {
            this._batchProcess = true;
        },

        /**
         * Ends a batch operation.
         * @See module:wcLayoutTable#startBatch
         * @function module:wcLayoutTable#finishBatch
         */
        finishBatch: function () {
            this._batchProcess = false;
            this.__resizeGrid(0, 0);
        },

        /**
         * Gets, or Sets whether the layout grid cells should draw an outline.
         * @function module:wcLayoutTable#showGrid
         * @param {Boolean} [enabled] - If supplied, will set the grid cell border visibility.
         * @returns {Boolean} - The current visibility state of the grid cells.
         */
        showGrid: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this.$elem.toggleClass('wcLayoutGrid', enabled);
            }

            return this.$elem.hasClass('wcLayoutGrid');
        },

        /**
         * Gets, or Sets the spacing between cell borders.
         * @function module:wcLayoutTable#gridSpacing
         * @param {Number} [size] - If supplied, sets the pixel size of the spacing between cells.
         * @returns {Number} - The current cell spacing in pixels.
         */
        gridSpacing: function (size) {
            if (typeof size !== 'undefined') {
                this.$elem.css('border-spacing', size + 'px');
            }

            return parseInt(this.$elem.css('border-spacing'));
        },

        /**
         * Gets, or Sets whether the table rows alternate in color based on the theme.
         * @function module:wcLayoutTable#gridAlternate
         * @params {Boolean} [enabled] - If supplied, will set whether the grid alternates in color.
         * @returns {Boolean} - Whether the grid alternates in color.
         */
        gridAlternate: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this.$elem.toggleClass('wcLayoutGridAlternate', enabled);
            }

            return this.$elem.hasClass('wcLayoutGridAlternate');
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$elem = $('<table class="wcLayout wcWide wcTall"></table>');
            this.$elem.append($('<tbody></tbody>'));
            this._grid = [];
            this.__container(this.$container);
        },

        // Updates the size of the layout.
        __update: function () {
        },

        // Resizes the grid to fit a given position.
        // Params:
        //    width     The width to expand to.
        //    height    The height to expand to.
        __resizeGrid: function (width, height) {
            for (var y = 0; y <= height; ++y) {
                if (this._grid.length <= y) {
                    var row = [];
                    row.$row = $('<tr>');
                    this._grid.push(row);
                }

                for (var x = 0; x <= width; ++x) {
                    if (this._grid[y].length <= x) {
                        this._grid[y].push({
                            $el: $('<td>'),
                            x: 0,
                            y: 0,
                            sx: '',
                            sy: ''
                        });
                    }
                }
            }

            if (!this._batchProcess) {
                var $oldBody = this.$elem.find('tbody');
                $('.wcDockerTransition').append($oldBody);

                var $newBody = $('<tbody>');
                for (var y = 0; y < this._grid.length; ++y) {
                    var $row = null;

                    for (var x = 0; x < this._grid[y].length; ++x) {
                        var item = this._grid[y][x];
                        if (item.$el) {
                            if (!$row) {
                                $row = this._grid[y].$row;
                                $newBody.append($row);
                            }

                            item.$el.css('width', item.sx);
                            item.$el.css('height', item.sy);
                            $row.append(item.$el);
                        }
                    }
                }

                this.$elem.append($newBody);
                $oldBody.remove();
            }
        },

        // Merges cells in the layout.
        // Params:
        //    x, y      Cell position to begin merge.
        //    w, h      The width and height to merge.
        // Returns:
        //    true      Cells were merged succesfully.
        //    false     Merge failed, either because the grid position was out of bounds
        //              or some of the cells were already merged.
        __mergeGrid: function (x, y, w, h) {
            // Make sure each cell to be merged is not already merged somewhere else.
            for (var yy = 0; yy < h; ++yy) {
                for (var xx = 0; xx < w; ++xx) {
                    var item = this._grid[y + yy][x + xx];
                    if (!item.$el || item.x !== 0 || item.y !== 0) {
                        return false;
                    }
                }
            }

            // Now merge the cells here.
            var item = this._grid[y][x];
            if (w > 1) {
                item.$el.attr('colspan', '' + w);
                item.x = w - 1;
            }
            if (h > 1) {
                item.$el.attr('rowspan', '' + h);
                item.y = h - 1;
            }

            for (var yy = 0; yy < h; ++yy) {
                for (var xx = 0; xx < w; ++xx) {
                    if (yy !== 0 || xx !== 0) {
                        var item = this._grid[y + yy][x + xx];
                        item.$el.remove();
                        item.$el = null;
                        item.x = -xx;
                        item.y = -yy;
                    }
                }
            }
            return true;
        }
    });

    return Module;
});

},
'xfile/manager/FileManagerActions':function(){
define([
    'dcl/dcl',
    'xide/types',
    'xide/utils'
], function (dcl, types, utils) {
    /**
     * @class xfile.manager.FileManager
     * @augments module:xfile.manager.FileManager
     */
    return dcl(null, {
        declaredClass: "xfile/manager/FileManagerActions",
        /**
         * Publish a file's operations progress event
         * @param event
         * @param terminator
         * @param items
         * @param failed
         * @param extra
         * @private
         */
        _publishProgress: function (event, terminator, items, failed, extra) {
            var _args = {
                terminatorItem: terminator,
                failed: failed,
                items: items || terminator
            };
            utils.mixin(_args, extra);
            this.publish(event, _args, this);
        },
        /**
         *
         * @param operation
         * @param args
         * @param terminator
         * @param items
         * @returns {*}
         */
        doOperation: function (operation, args, terminator, items, extra, dfdOptions) {
            var thiz = this,
                operationCapitalized = operation.substring(0, 1).toUpperCase() + operation.substring(1),
                beginEvent = 'on' + operationCapitalized + 'Begin', //will evaluate for operation 'delete' to 'onDeleteBegin'
                endEvent = 'on' + operationCapitalized + 'End';

            thiz._publishProgress(beginEvent, terminator, items, false, extra);

            var rpcPromise = this.runDeferred(null, operation, args, dfdOptions).then(function () {
                thiz._publishProgress(endEvent, terminator, items, false, extra);
            }, function (err) {
                thiz._publishProgress(endEvent, terminator, items, true, extra);
            });
            return rpcPromise;
        },
        deleteItems: function (selection, options, dfdOptions) {
            return this.doOperation(types.OPERATION.DELETE, [selection, options, true], selection, selection, null, dfdOptions);
        },
        copyItem: function (selection, dst, options, dfdOptions) {
            return this.doOperation(types.OPERATION.COPY, [selection, dst, options, false], selection, selection, {dst: dst}, dfdOptions);
        },
        mkdir: function (mount, path, dfdOptions) {
            return this.doOperation(types.OPERATION.NEW_DIRECTORY, [mount, path], path, null, null, dfdOptions);
        },
        mkfile: function (mount, path, content) {
            return this.doOperation(types.OPERATION.NEW_FILE, [mount, path], path);
        },
        rename: function (mount, src, dst) {
            return this.doOperation(types.OPERATION.RENAME, [mount, src, dst], src);
        },
        moveItem: function (src, dst, include, exclude, mode, dfdOptions) {
            return this.doOperation(types.OPERATION.MOVE, [src, dst, include, exclude, mode], src, null, null, dfdOptions);
        },
        compressItem: function (mount, src, type, readyCB) {
            return this.doOperation(types.OPERATION.COMPRESS, [mount, src, type], src);
        },
        extractItem: function (mount, src, type) {
            return this.doOperation(types.OPERATION.EXTRACT, [mount, src], src);
        }
    });
});
},
'xide/rpc/JsonRPC':function(){
define([
	"./Service",
    "dojo/errors/RequestError",
	"xide/utils/StringUtils"
], function(Service, RequestError,utils){
	function jsonRpcEnvelope(version){
		return {
			serialize: function(smd, method, data, options){
				//not converted to json it self. This  will be done, if
				//appropriate, at the transport level
	
				var d = {
					id: this._requestId++,
					method: method.name,
					params: data
				};
				if(version){
					d.jsonrpc = version;
				}
				return {
					data: JSON.stringify(d),
					handleAs:'json',
					contentType: 'application/json',
					transport:"POST"
				};
			},
			deserialize: function(obj){
				if ('Error' == obj.name // old xhr
					|| obj instanceof RequestError // new xhr
				){
					obj = utils.fromJson(obj.responseText);
				}
				if(obj.error) {
					var e = new Error(obj.error.message || obj.error);
					e._rpcErrorObject = obj.error;
					return e;
				}
				return obj.result;
			}
		};
	}
    Service.envelopeRegistry.register(
		"JSON-RPC-1.0",
		function(str){
			return str == "JSON-RPC-1.0";
		},
		utils.mixin({namedParams:false}, jsonRpcEnvelope()) // 1.0 will only work with ordered params
	);
    Service.envelopeRegistry.register(
		"JSON-RPC-2.0",
		function(str){
			return str == "JSON-RPC-2.0";
		},
        utils.mixin({namedParams:true }, jsonRpcEnvelope("2.0")) // 2.0 supports named params
	);

});

},
'dojo/_base/NodeList':function(){
define(["./kernel", "../query", "./array", "./html", "../NodeList-dom"], function(dojo, query, array){
	// module:
	//		dojo/_base/NodeList

	/*=====
	return {
		// summary:
		//		This module extends dojo/NodeList with the legacy connect(), coords(),
		//		blur(), focus(), change(), click(), error(), keydown(), keypress(),
		//		keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
		//		mouseout(), mouseover(), mouseup(), and submit() methods.
	};
	=====*/
 
	var NodeList = query.NodeList,
		nlp = NodeList.prototype;

	nlp.connect = NodeList._adaptAsForEach(function(){
		// don't bind early to dojo.connect since we no longer explicitly depend on it
		return dojo.connect.apply(this, arguments);
	});
	/*=====
	nlp.connect = function(methodName, objOrFunc, funcName){
		// summary:
		//		Attach event handlers to every item of the NodeList. Uses dojo.connect()
		//		so event properties are normalized.
		//
		//		Application must manually require() "dojo/_base/connect" before using this method.
		// methodName: String
		//		the name of the method to attach to. For DOM events, this should be
		//		the lower-case name of the event
		// objOrFunc: Object|Function|String
		//		if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
		//		reference a function or be the name of the function in the global
		//		namespace to attach. If 3 arguments are provided
		//		(methodName, objOrFunc, funcName), objOrFunc must be the scope to
		//		locate the bound function in
		// funcName: String?
		//		optional. A string naming the function in objOrFunc to bind to the
		//		event. May also be a function reference.
		// example:
		//		add an onclick handler to every button on the page
		//		|	query("div:nth-child(odd)").connect("onclick", function(e){
		//		|		console.log("clicked!");
		//		|	});
		// example:
		//		attach foo.bar() to every odd div's onmouseover
		//		|	query("div:nth-child(odd)").connect("onmouseover", foo, "bar");

		return null;	// NodeList
	};
	=====*/

	nlp.coords = NodeList._adaptAsMap(dojo.coords);
	/*=====
	nlp.coords = function(){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//		Returns the box objects of all elements in a node list as
		//		an Array (*not* a NodeList). Acts like `domGeom.coords`, though assumes
		//		the node passed is each node in this list.

		return []; // Array
	};
	=====*/

	NodeList.events = [
		// summary:
		//		list of all DOM events used in NodeList
		"blur", "focus", "change", "click", "error", "keydown", "keypress",
		"keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove",
		"mouseout", "mouseover", "mouseup", "submit"
	];

	// FIXME: pseudo-doc the above automatically generated on-event functions

	// syntactic sugar for DOM events
	array.forEach(NodeList.events, function(evt){
			var _oe = "on" + evt;
			nlp[_oe] = function(a, b){
				return this.connect(_oe, a, b);
			};
				// FIXME: should these events trigger publishes?
				/*
				return (a ? this.connect(_oe, a, b) :
							this.forEach(function(n){
								// FIXME:
								//		listeners get buried by
								//		addEventListener and can't be dug back
								//		out to be triggered externally.
								// see:
								//		http://developer.mozilla.org/en/docs/DOM:element

								console.log(n, evt, _oe);

								// FIXME: need synthetic event support!
								var _e = { target: n, faux: true, type: evt };
								// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });
								try{ n[evt](_e); }catch(e){ console.log(e); }
								try{ n[_oe](_e); }catch(e){ console.log(e); }
							})
				);
				*/
		}
	);

	dojo.NodeList = NodeList;
	return NodeList;
});

},
'xide/data/ObservableStore':function(){
/** @module xide/data/ObservableStore **/
define([
    "dojo/_base/declare",
    "xide/types",
    "xide/mixins/EventedMixin"
], function (declare, types,EventedMixin) {

    var _debug = false;
    var _debugChange = false;
    /**
     * @class module:xide/data/ObservableStore
     */
    return declare('xide/data/Observable', EventedMixin, {
        _ignoreChangeEvents: true,
        observedProperties: [],
        mute:false,
        silent:function(silent){
            this._ignoreChangeEvents = silent;
        },
        putSync: function (item,publish) {
            this._ignoreChangeEvents = true;
            var res = this.inherited(arguments);
            this._ignoreChangeEvents = false;
            publish!==false && this.emit('added', res);
            return res;
        },
        removeSync: function (id) {
            var _item = this.getSync(id);
            _item && _item.onRemove && _item.onRemove();
            var res = this.inherited(arguments);
            return res;
        },
        postscript: function () {

            var thiz = this;
            thiz.inherited(arguments);
            if (!thiz.on) {
                return;
            }
            thiz.on('add', function (evt) {
                var _item = evt.target;
                thiz._observe(_item);
                if (!_item._store) {
                    _item._store = thiz;
                }
                _item._onCreated && _item._onCreated();
                if(!_item._onCreated && _debug){
                    console.warn('item doesnt have _onCreated',_item);
                }
                _item.onAdd && _item.onAdd(_item);
            });
        },
        /**
         *
         * @param item
         * @param property
         * @param value
         * @param source
         * @private
         */
        _onItemChanged: function (item, property, value, source) {
            if (this._ignoreChangeEvents) {
                return;
            }

            _debug && console.log('item changed', arguments);

            var args = {
                target: item,
                property: property,
                value: value,
                source: source
            };
            this.emit('update', args);
            item.onItemChanged && item.onItemChanged(args);
        },
        _observe: function (item) {
            var thiz = this,
                props = thiz.observedProperties;

            if (item && item.observed) {
                props = props.concat(item.observed);
            }
            props && props.forEach(function (property) {
                //_debug && console.log('observe item : ' + item.command + ' for ' + property);
                item.property(property).observe(function (value) {
                    if (!thiz._ignoreChangeEvents) {
                        _debugChange && console.log('property changed: ' + property);
                        thiz._onItemChanged(item, property, value, thiz);
                    }
                });
            });
        },
        setData: function (data) {
            this.inherited(arguments);
            this._ignoreChangeEvents = true;
            data && _.each(data,this._observe, this);
            this._ignoreChangeEvents = false;
        }
    });
});
},
'wcDocker/panel':function(){
/** @module wcPanel */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {
    /**
     * @class module:wcPanel
     * The public interface for the docking panel, it contains a number of convenience
     * functions and layout that manages the contents of the panel.
     */
    var Module = dcl(base, {
        declaredClass: 'wcPanel',
        /**
         * Std API
         */
        select:function(){
            var frame = this.getFrame();
            if (frame) {
                frame.panel(frame.panelIndex(this));
                this._startWidgets();
                this.onShow();
            }
        },
        /**
         * Helper to return parent splitter
         * @returns {*}
         */
        getSplitter:function(){
            return this._parentByClass('Splitter');
        },
        /**
         * Helper to return parent frame
         * @returns {*}
         */
        getFrame:function(){
            return this._parentByClass('Frame');
        },
        /**
         * Std API
         */
        resize: function () {
            this.__update();
            this.__trigger(wcDocker.EVENT.RESIZED);
        },

        /**
         * @memberOf module:wcPanel
         * <b><i>PRIVATE</i> - Use [wcDocker.addPanel]{@link module:wcDocker#addPanel}, [wcDocker.removePanel]{@link module:wcDocker#removePanel}, and
         * [wcDocker.movePanel]{@link module:wcDocker#movePanel} to manage panels, <u>this should never be constructed directly
         * by the user.</u></b>
         * @param {module:wcBase} parent - The parent.
         * @param {String} type - The name identifier for the panel.
         * @param {module:wcPanel~options} [options] - An options object passed from registration of the panel.
         */
        constructor: function (parent, type, options) {
            /**
             * An options object for the [panel]{@link module:wcPanel} constructor.
             * @typedef module:wcPanel~options
             * @property {String} [icon] - A CSS classname that represents the icon that should display on this panel's tab widget.
             * @property {String} [faicon] - An icon name using the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
             * @property {String|Boolean} [title] - A custom title to display for this panel, if false, title bar will not be shown.
             * @property {Number|String} [detachToWidth=600] - Determines the new width when the panel is detached (0 = Don't change). Can be a pixel value, or a string with a 'px' or '%' suffix.
             * @property {Number|String} [detachToHeight=400] - Determines the new height when the panel is detached (0 = Don't change).  Can be a pixel value, or a string with a 'px' or '%' suffix.
             */

            /**
             * The outer container element of the panel.
             * @member {external:jQuery~Object}
             */
            this.$container = null;
            this._parent = parent;
            this.$icon = null;
            this.$closeIcon = null;
            this.$title = null;
            this.$titleText = null;
            this.$loading = null;

            this._panelObject = null;
            this._initialized = false;
            this._collapseDirection = undefined;

            this._type = type;
            this._title = type;
            this._titleVisible = true;

            this._options = options;

            this._layout = null;

            this._buttonList = [];

            this._actualPos = {
                x: 0.5,
                y: 0.5
            };

            this._actualSize = {
                x: 0,
                y: 0
            };

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._pos = {
                x: 0.5,
                y: 0.5
            };

            this._moveData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._size = {
                x: -1,
                y: -1
            };

            this._minSize = {
                x: 100,
                y: 50
            };

            this._maxSize = {
                x: Infinity,
                y: Infinity
            };

            this._scroll = {
                x: 0,
                y: 0
            };

            this._scrollable = {
                x: true,
                y: true
            };

            this._collapsible = true;
            this._overflowVisible = false;
            this._moveable = true;
            this._detachable = true;
            this._closeable = true;
            this._resizeVisible = true;
            this._isVisible = false;
            this._events = {};
            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Gets, or Sets the title for this panel.
         * Titles appear in the tab widget associated with the panel.
         * @function module:wcPanel#title
         * @param {String|Boolean} title - If supplied, sets the new title (this can be html text). If false, the title bar will be removed.
         * @returns {String|Boolean} - The current title.
         */
        title: function (title) {
            if (typeof title !== 'undefined') {
                if (title === false) {
                    this._titleVisible = false;
                    this.$titleText.html(this._type);
                } else {
                    this._title = title;
                    this.$titleText.html(title);
                }

                if (this.$icon) {
                    this.$titleText.prepend(this.$icon);
                }

                if (this.$closeIcon) {
                    this.$titleText.append(this.$closeIcon);
                    this.$closeIcon[0].__panel= this;
                }


                if (this._parent && this._parent.instanceOf('wcFrame')) {
                    this._parent.__updateTabs();
                }
            }
            return this._title;
        },

        /**
         * Retrieves the registration info of the panel as declared from
         * [wcDocker.registerPanelType]{@link module:wcDocker#registerPanelType};
         * @function module:wcPanel#info
         * @returns {module:wcDocker~registerOptions} - Registered options of the panel type.
         * @see [wcDocker.panelTypeInfo]{@link module:wcDocker#panelTypeInfo}.
         */
        info: function () {
            return this.docker().panelTypeInfo(this._type);
        },

        /**
         * Retrieves the layout instance.
         * @function module:wcPanel#layout
         * @returns {module:wcLayoutSimple|wcLayoutTable} - The layout instance.
         */
        layout: function () {
            return this._layout;
        },

        /**
         * Brings this panel into focus. If it is floating, it will be moved to the front of all other panels.
         * @function module:wcPanel#focus
         * @param {Boolean} [flash] - If true, in addition to bringing the panel into focus, it will also flash for the user.
         */
        focus: function (flash) {
            var docker = this.docker();
            if (docker) {
                docker.__focus(this._parent, flash);
                for (var i = 0; i < this._parent._panelList.length; ++i) {
                    if (this._parent._panelList[i] === this && this._parent._curTab !== i) {
                        this._parent.panel(i);
                        break;
                    }
                }
            }
        },

        /**
         * @callback wcPanel~CollapseDirection
         * @see module:wcPanel#collapseDirection
         * @param {module:wcDocker~Bounds} bounds - The bounds of this panel relative to the wcDocker container.
         * @returns {module:wcDocker.DOCK} - A collapse direction to use, must only be LEFT, RIGHT, or BOTTOM
         */

        /**
         * Gets, or Sets the collapse direction for this panel.
         * @function module:wcPanel#collapseDirection
         * @param {module:wcPanel~CollapseDirection|wcDocker.DOCK} direction - The collapse direction to use for this panel.<br>If this value is omitted, the default collapse direction will be used.
         */
        collapseDirection: function (direction) {
            this._collapseDirection = direction;
        },

        /**
         * Retrieves whether this panel can be seen by the user.
         * @function module:wcPanel#isVisible
         * @returns {Boolean} - Visibility state.
         */
        isVisible: function () {
            return this._isVisible;
        },

        /**
         * Retrieves whether this panel is floating.
         * @function module:wcPanel#isFloating
         * @returns {Boolean}
         */
        isFloating: function () {
            if (this._parent && this._parent.instanceOf('wcFrame')) {
                return this._parent._isFloating;
            }
            return false;
        },

        /**
         * Retrieves whether this panel is in focus.
         * @function module:wcPanel#isInFocus
         * @return {Boolean}
         */
        isInFocus: function () {
            var docker = this.docker();
            if (docker && this._parent && this._parent.instanceOf('wcFrame')) {
                return this._parent === docker._focusFrame;
            }
            return false;
        },

        /**
         * Creates a new custom button that will appear in the title bar when the panel is active.
         * @function module:wcPanel#addButton
         * @param {String} name               - The name of the button, to identify it later.
         * @param {String} className          - A CSS class name to apply to the button.
         * @param {String} text               - Text to apply to the button.
         * @param {String} tip                - Tooltip text for the user.
         * @param {Boolean} [isTogglable]     - If true, will make the button toggle on and off per click.
         * @param {String} [toggleClassName]  - If this button is toggleable, you can designate an optional CSS class name that will replace the original class name.
         */
        addButton: function (name, className, text, tip, isTogglable, toggleClassName) {
            this._buttonList.push({
                name: name,
                className: className,
                toggleClassName: toggleClassName,
                text: text,
                tip: tip,
                isTogglable: isTogglable,
                isToggled: false
            });

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__update();
            }
        },

        /**
         * Removes a custom button from the panel.
         * @function module:wcPanel#removeButton
         * @param {String} name - The name identifier for the button to remove.
         * @returns {Boolean} - Success or failure.
         */
        removeButton: function (name) {
            for (var i = 0; i < this._buttonList.length; ++i) {
                if (this._buttonList[i].name === name) {
                    this._buttonList.splice(i, 1);
                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__onTabChange();
                    }

                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__update();
                    }

                    return true;
                }
            }
            return false;
        },

        /**
         * Gets, or Sets the current toggle state of a custom button that was
         * added using [wcPanel.addButton]{@link module:wcPanel#addButton}.
         * @function module:wcPanel#buttonState
         * @param {String} name - The name identifier of the button.
         * @param {Boolean} [toggleState] - If supplied, will assign a new toggle state to the button.
         * @returns {Boolean} - The current toggle state of the button.
         */
        buttonState: function (name, toggleState) {
            for (var i = 0; i < this._buttonList.length; ++i) {
                if (this._buttonList[i].name === name) {
                    if (typeof toggleState !== 'undefined') {
                        this._buttonList[i].isToggled = toggleState;
                        if (this._parent && this._parent.instanceOf('wcFrame')) {
                            this._parent.__onTabChange();
                        }
                    }

                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__update();
                    }

                    return this._buttonList[i].isToggled;
                }
            }
            return false;
        },

        /**
         * Gets, or Sets the default position of the panel if it is floating. <b>Warning: after the panel has been initialized, this value no longer reflects the current position of the panel.</b>
         * @function module:wcPanel#initPos
         * @param {Number|String} [x] - If supplied, sets the horizontal position of the floating panel. Can be a percentage position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the vertical position of the floating panel. Can be a percentage position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Coordinate} - The current default position of the panel.
         */
        initPos: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._pos.x = docker.__stringToPercent(x, docker.$container.width());
                } else {
                    this._pos.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._pos.y = docker.__stringToPercent(y, docker.$container.height());
                } else {
                    this._pos.y = y;
                }
            }

            return {x: this._pos.x, y: this._pos.y};
        },

        /**
         * Gets, or Sets the desired size of the panel. <b>Warning: after the panel has been initialized, this value no longer reflects the current size of the panel.</b>
         * @function module:wcPanel#initSize
         * @param {Number|String} [x] - If supplied, sets the desired initial horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired initial vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current initial size of the panel.
         */
        initSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._size.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._size.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._size.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._size.y = y;
                }
            }
            return {x: this._size.x, y: this._size.y};
        },

        /**
         * Gets, or Sets the minimum size constraint of the panel.
         * @function module:wcPanel#minSize
         * @param {Number|String} [x] - If supplied, sets the desired minimum horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired minimum vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current minimum size.
         */
        minSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._minSize.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._minSize.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._minSize.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._minSize.y = y;
                }
            }
            return {x: this._minSize.x, y: this._minSize.y};
        },

        /**
         * Gets, or Sets the maximum size constraint of the panel.
         * @function module:wcPanel#maxSize
         * @param {Number|String} [x] - If supplied, sets the desired maximum horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired maximum vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current maximum size.
         */
        maxSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._maxSize.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._maxSize.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._maxSize.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._maxSize.y = y;
                }
            }
            return {x: this._maxSize.x, y: this._maxSize.y};
        },

        /**
         * Retrieves the width of the panel contents.
         * @function module:wcPanel#width
         * @returns {Number} - Panel width.
         */
        width: function () {
            if (this.$container) {
                return this.$container.width();
            }
            return 0.0;
        },

        /**
         * Retrieves the height of the panel contents.
         * @function module:wcPanel#height
         * @returns {Number} - Panel height.
         */
        height: function () {
            if (this.$container) {
                return this.$container.height();
            }
            return 0.0;
        },

        /**
         * Sets the icon for the panel, shown in the panels tab widget. Must be a css class name that contains the icon.
         * @function module:wcPanel#icon
         * @param {String} icon - The icon class name.
         */
        icon: function (icon) {
            if (!this.$icon) {
                this.$icon = $('<div>');
                this.$titleText.prepend(this.$icon);
            }

            this.$icon.removeClass();
            this.$icon.addClass('wcTabIcon ' + icon);

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__updateTabs();
            }

            this._icon = icon;

        },

        /**
         * Sets the icon for the panel, shown in the panels tab widget,
         * to an icon defined from the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
         * @function module:wcPanel#faicon
         * @param {String} icon - The font-awesome icon name.
         */
        faicon: function (icon) {
            if (!this.$icon) {
                this.$icon = $('<div>');
                this.$titleText.prepend(this.$icon);
            }

            this.$icon.removeClass();
            this.$icon.addClass('wcTabIcon fa fa-fw fa-' + icon);

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__updateTabs();
            }
        },

        /**
         * Gets, or Sets whether the window is scrollable.
         * @function module:wcPanel#scrollable
         * @param {Boolean} [x] - If supplied, assigns whether the window is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the window is scrollable in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scrollable status.
         */
        scrollable: function (x, y) {
            if (typeof x !== 'undefined') {
                this._scrollable.x = !!x;
                this._scrollable.y = !!y;
            }

            return {x: this._scrollable.x, y: this._scrollable.y};
        },

        /**
         * Gets, or Sets the scroll position of the panel's contents if it is scrollable; See [wcPanel.scrollable]{@link module:wcPanel#scrollable}).
         * @function module:wcPanel#scroll
         * @param {Number} [x]        - If supplied, sets the scroll horizontal position of the panel.
         * @param {Number} [y]        - If supplied, sets the scroll vertical position of the panel.
         * @param {Number} [duration] - If supplied, will animate the scroll movement with the supplied duration (in milliseconds).
         * @returns {module:wcDocker~Coordinate} The current scroll position.
         */
        scroll: function (x, y, duration) {
            if (!this.$container) {
                return {x: 0, y: 0};
            }

            if (typeof x !== 'undefined') {
                if (duration) {
                    this.$container.parent().stop().animate({
                        scrollLeft: x,
                        scrollTop: y
                    }, duration);
                } else {
                    this.$container.parent().scrollLeft(x);
                    this.$container.parent().scrollTop(y);
                }
            }

            return {
                x: this.$container.parent().scrollLeft(),
                y: this.$container.parent().scrollTop()
            };
        },

        /**
         * Gets, or Sets whether this panel can be collapsed to the side or bottom.<br>
         * This only works if the collapse feature is enabled {@link module:wcDocker~Options}.
         * @function module:wcPanel#collapsible
         * @param {Boolean} [enabled] - If supplied, assigns whether collapsing is enabled.
         * @returns {Boolean} - The current collapsible enabled state.
         */
        collapsible: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._collapsible = !!enabled;
            }

            return this._collapsible;
        },

        /**
         * Gets, or Sets whether overflow on this panel is visible.
         * Use this if a child element within this panel is intended to 'popup' and be visible outside of its parent area.
         * @function module:wcPanel#overflowVisible
         * @param {Boolean} [visible] - If supplied, assigns whether overflow is visible.
         * @returns {Boolean} - The current overflow visibility.
         */
        overflowVisible: function (visible) {
            if (typeof visible !== 'undefined') {
                this._overflowVisible = !!visible;
            }

            return this._overflowVisible;
        },

        /**
         * Gets, or Sets whether the contents of the panel are visible on resize.
         * Use this if the panel has extremely expensive contents which take a long time to resize.
         * @function module:wcPanel#resizeVisible
         * @param {Boolean} [visible] - If supplied, assigns whether panel contents are visible during resize.
         * @returns {Boolean} - The current resize visibility.
         */
        resizeVisible: function (visible) {
            if (typeof visible !== 'undefined') {
                this._resizeVisible = !!visible;
            }

            return this._resizeVisible;
        },

        /**
         * Sets, or Gets the moveable status of the window.
         * Note: Other panels can not dock beside a non-moving panel as doing so could cause it to move.
         * @function module:wcPanel#moveable
         * @param {Boolean} [enabled] - If supplied, assigns whether this panel can be moved.
         * @returns {Boolean} - Whether the panel is moveable.
         */
        moveable: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._moveable = !!enabled;
                this.$title.toggleClass('wcNotMoveable', !this._moveable);
            }

            return this._moveable;
        },

        /**
         * Sets, or Gets whether this panel can be detached into a floating panel.
         * @function module:wcPanel#detachable
         * @param {Boolean} [enabled] - If supplied, assigns whether this panel can be detached.
         * @returns {Boolean} - Whether this panel can detach.
         */
        detachable: function(enabled) {
            if (typeof enabled !== 'undefined') {
                this._detachable = !!enabled;
            }

            return this._detachable;
        },

        /**
         * Gets, or Sets whether this dock window can be closed by the user.
         * Note: The panel can still be closed programmatically.
         * @function module:wcPanel#closeable
         * @param {Boolean} [enabled] - If supplied, toggles whether it can be closed.
         * @returns {Boolean} the current closeable status.
         */
        closeable: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._closeable = !!enabled;
                if (this._closeable) {
                    if(!this.$closeIcon) {
                        this.$closeIcon = $('<div class="wcPanelCloseIcon fa fa-close"/>');
                        this.$titleText.append(this.$closeIcon);
                    }
                }else{
                    this.$closeIcon && this.$closeIcon.remove();
                    this.$closeIcon = null;
                }
                if (this._parent) {
                    this._parent.__update();
                }
            }
            return this._closeable;
        },

        /**
         * Forces the window to close.
         * @function module:wcPanel#close
         */
        close: function () {
            var docker = this.docker();
            if (docker) {
                docker.__closePanel(this);
            }
        },

        /**
         * Shows the loading screen.
         * @function module:wcPanel#startLoading
         * @param {String} [label] - An optional label to display.
         * @param {Number} [opacity=0.4] - If supplied, assigns a custom opacity value to the loading screen.
         * @param {Number} [textOpacity=1] - If supplied, assigns a custom opacity value to the loading icon and text displayed.
         */
        startLoading: function (label, opacity, textOpacity) {
            if (!this.$loading) {
                var markup = '<div class="container-fluid center-block" style="opacity: 1;position: absolute;top:50%;">'+
                    '<div class="">'+
                        '<div class="offset3 span6 centering center-block">'+
                            '<div class="fa fa-3x fa-spinner fa-spin "/>' +
                        '</div>' +
                    '</div>' +
                '</div>';
                this.$loading = $(markup);
                this.$container.append(this.$loading);
                /*

                this.$loading = $('<div class="wcLoadingContainer"></div>');
                this.$container.append(this.$loading);

                var $background = $('<div class="wcLoadingBackground"></div>');
                if (typeof opacity !== 'number') {
                    opacity = 0.4;
                }

                this.$loading.append($background);

                var $icon = $('<div class="wcLoadingIconContainer"><i class="wcLoadingIcon ' + this.docker()._options.loadingClass + '"></i></div>');
                this.$loading.append($icon);

                if (label) {
                    var $label = $('<span class="wcLoadingLabel">' + label + '</span>');
                    this.$loading.append($label);
                }

                if (typeof textOpacity !== 'number') {
                    textOpacity = 1;
                }

                // Override opacity values if the global loading screen is active.
                if (this.docker().$loading) {
                    opacity = 0;
                    textOpacity = 0;
                }

                $background.css('opacity', opacity);
                $icon.css('opacity', textOpacity);

                if ($label) {
                    $label.css('opacity', textOpacity);
                }
                */
            }
        },

        /**
         * Hides the loading screen.
         * @function module:wcPanel#finishLoading
         * @param {Number} [fadeDuration=0] - If supplied, assigns a fade out duration for the loading screen.
         */
        finishLoading: function (fadeDuration) {
            if (this.$loading) {
                if (fadeDuration > 0) {
                    var self = this;
                    this.$loading.fadeOut(fadeDuration, function () {
                        self.$loading.remove();
                        self.$loading = null;
                        self.docker().__testLoadFinished();
                    });
                } else {
                    this.$loading.remove();
                    this.$loading = null;
                    this.docker().__testLoadFinished();
                }

            }
        },

        /**
         * Registers an [event]{@link module:wcDocker.EVENT} associated with this panel.
         * @function module:wcPanel#on
         * @param {String} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {module:wcDocker#onEvent} handler - An event handler function to be called when the event is fired.
         * @returns {Boolean} - Event registration success or failure.
         */
        on: function (eventType, handler) {
            if (!eventType) {
                return false;
            }

            if (!this._events[eventType]) {
                this._events[eventType] = [];
            }

            if (this._events[eventType].indexOf(handler) !== -1) {
                return false;
            }

            this._events[eventType].push(handler);
            return true;
        },

        /**
         * Unregisters an [event]{@link module:wcDocker.EVENT} associated with this panel.
         * @function module:wcPanel#off
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} [handler] - The handler function registered with the event. If omitted, all events registered to the event type are unregistered.
         */
        off: function (eventType, handler) {
            if (typeof eventType === 'undefined') {
                this._events = {};
            } else {
                if (this._events[eventType]) {
                    if (typeof handler === 'undefined') {
                        this._events[eventType] = [];
                    } else {
                        for (var i = 0; i < this._events[eventType].length; ++i) {
                            if (this._events[eventType][i] === handler) {
                                this._events[eventType].splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },

        /**
         * Triggers an [event]{@link module:wcDocker.EVENT} of a given type to all panels, including itself.
         * @function module:wcPanel#trigger
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {Object} [data] - A custom data object to pass into all handlers.
         * @returns {Object[]} results - Returns an array with all results returned by event handlers.
         */
        trigger: function (eventType, data) {
            var docker = this.docker();
            if (docker) {
                return docker.trigger(eventType, data);
            }
            return [];
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            var layoutClass = (this._options && this._options.layout) || 'wcLayoutTable';
            this._layout = new (this.docker().__getClass(layoutClass))(this.$container, this);
            this.$title = $('<div class="wcPanelTab">');
            this.$titleText = $('<div>' + this._title + '</div>');
            this.$title.append(this.$titleText);

            if (this._options.hasOwnProperty('title')) {
                this.title(this._options.title);
            }

            if (this._options.icon) {
                this.icon(this._options.icon);
            }
            if (this._options.faicon) {
                this.faicon(this._options.faicon);
            }
        },

        // Updates the size of the layout.
        __update: function () {
            var docker = this.docker();
            if (!docker) return;

            this._layout.__update();
            if (!this.$container) {
                return;
            }

            if (this._resizeVisible) {
                this._parent.$frame.removeClass('wcHideOnResize');
            } else {
                this._parent.$frame.addClass('wcHideOnResize');
            }

            if (!this._initialized) {
                this._initialized = true;
                var self = this;
                setTimeout(function () {
                    self.__trigger(wcDocker.EVENT.INIT);

                    docker.__testLoadFinished();
                }, 0);
            } else {
                this.__trigger(wcDocker.EVENT.UPDATED);
            }

            var width = this.$container.width();
            var height = this.$container.height();
            if (this._actualSize.x !== width || this._actualSize.y !== height) {
                this._resizeData.time = new Date();
                if (!this._resizeData.timeout) {
                    this._resizeData.timeout = true;
                    setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                    this.__trigger(wcDocker.EVENT.RESIZE_STARTED, {width: this._actualSize.x, height: this._actualSize.y});
                }

                this._actualSize.x = width;
                this._actualSize.y = height;
                this.__trigger(wcDocker.EVENT.RESIZED, {width: this._actualSize.x, height: this._actualSize.y});
            }

            var offset = this.$container.offset();
            if (this._actualPos.x !== offset.left || this._actualPos.y !== offset.top) {
                this._moveData.time = new Date();
                if (!this._moveData.timeout) {
                    this._moveData.timeout = true;
                    setTimeout(this.__moveEnd.bind(this), this._moveData.delta);
                    this.__trigger(wcDocker.EVENT.MOVE_STARTED, {x: this._actualPos.x, y: this._actualPos.y});
                }

                this._actualPos.x = offset.left;
                this._actualPos.y = offset.top;
                this.__trigger(wcDocker.EVENT.MOVED, {x: this._actualPos.x, y: this._actualPos.y});
            }
        },

        __resizeEnd: function () {
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
                this.__trigger(wcDocker.EVENT.RESIZE_ENDED, {width: this._actualSize.x, height: this._actualSize.y});
            }
        },

        __moveEnd: function () {
            if (new Date() - this._moveData.time < this._moveData.delta) {
                setTimeout(this.__moveEnd.bind(this), this._moveData.delta);
            } else {
                this._moveData.timeout = false;
                this.__trigger(wcDocker.EVENT.MOVE_ENDED, {x: this._actualPos.x, y: this._actualPos.y});
            }
        },

        __isVisible: function (inView) {
            if (this._isVisible !== inView) {
                this._isVisible = inView;

                this.__trigger(wcDocker.EVENT.VISIBILITY_CHANGED, this._isVisible);
            }
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.type = 'wcPanel';
            if (this._icon) {
                data.icon = this._icon;
            }else{
                console.log('have no icon');
            }
            data.panelType = this._type;
            // data.title = this._title;
            data.size = {
                x: this._size.x,
                y: this._size.y
            };
            // data.minSize = {
            //   x: this._minSize.x,
            //   y: this._minSize.y,
            // };
            // data.maxSize = {
            //   x: this._maxSize.x,
            //   y: this._maxSize.y,
            // };
            // data.scrollable = {
            //   x: this._scrollable.x,
            //   y: this._scrollable.y,
            // };
            // data.moveable = this._moveable;
            // data.closeable = this._closeable;
            // data.resizeVisible = this.resizeVisible();
            data.customData = {};
            this.__trigger(wcDocker.EVENT.SAVE_LAYOUT, data.customData);
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data) {
            // this._title = data.title;
            if (data.size) {
                this._size.x = data.size.x;
                this._size.y = data.size.y;
            }
            // this._minSize.x = data.minSize.x;
            // this._minSize.y = data.minSize.y;
            // this._maxSize.x = data.maxSize.x;
            // this._maxSize.y = data.maxSize.y;
            // this._scrollable.x = data.scrollable.x;
            // this._scrollable.y = data.scrollable.y;
            // this._moveable = data.moveable;
            // this._closeable = data.closeable;
            // this.resizeVisible(data.resizeVisible);
            this.__trigger(wcDocker.EVENT.RESTORE_LAYOUT, data.customData);

            data.icon && this.icon(data.icon);
            var docker = this.docker();
            if(docker){
                docker._emit('restorePanel',data.customData);
            }else{
                console.error('restorePanel : failed, have no docker');
            }

        },

        // Triggers an event of a given type onto this current panel.
        // Params:
        //    eventType     The event to trigger.
        //    data          A custom data object to pass into all handlers.
        __trigger: function (eventType, data) {
            if (!eventType) {
                return false;
            }

            var results = [];
            if (this._events[eventType]) {
                var events = this._events[eventType].slice(0);
                for (var i = 0; i < events.length; ++i) {
                    results.push(events[i].call(this, data));
                }
            }

            return results;
        },

        // Retrieves the bounding rect for this widget.
        __rect: function () {
            var offset = this.$container.offset();
            var width = this.$container.width();
            var height = this.$container.height();

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }
            this.$container = $container;
            if (this.$container) {
                this._layout.__container(this.$container);
                if (this.$loading) {
                    this.$container.append(this.$loading);
                }
            } else {
                this._layout.__container(null);
                this.finishLoading();
            }
            if(this.$container) {
                this.$container[0].id = this.id;
            }
            return this.$container;
        },
        // Destroys this panel.
        __destroy: function () {
            this._panelObject = null;
            if(this.$closeIcon) {
                this.$closeIcon.__panel = null;
            };
            this.off();

            this.__container(null);
            this._parent = null;
        }
    });

    dcl.chainAfter(Module,"resize");
    return Module;
});

},
'xide/data/Source':function(){
/** @module xide/data/Source **/
define([
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/utils'
], function (dcl, declare, utils) {

    var _debug = false;
    /**
     * @class module:xide/data/Source
     */
    var Implementation = {
        _references: null,
        _originReference: null,
        onReferenceUpdate: function () {
        },
        onReferenceRemoved: function () {
        },
        onReferenceDelete: function () {
        },
        updateReference: function () {
        },
        getReferences: function () {
            return this._references ? utils.pluck(this._references, 'item') : [];
        },
        addReference: function (item, settings, addSource) {

            if (!this._references) {
                this._references = [];
            }

            this._references.push({
                item: item,
                settings: settings
            });

            var thiz = this;

            if (settings && settings.onDelete) {
                if (item._store) {
                    item._store.on('delete', function (evt) {
                        if (evt.target == item) {
                            thiz._store.removeSync(thiz[thiz._store['idProperty']]);
                        }
                    })
                }
            }

            if (addSource) {
                if (item.addSource) {
                    item.addSource(this, settings);
                } else {
                    _debug && console.log('empty: ', item.command);
                }
            }
        },
        removeReference: function (Reference) {
            _debug && console.log('remove reference ' + Reference.label, Reference);
            this._references && _.each(this._references, function (ref) {
                if (ref && ref.item == Reference) {
                    this._references && this._references.remove(ref);
                }
            }, this);
        },
        updateReferences: function (args) {


            var property = args.property,
                value = args.value;

            if (!this._references) {
                this._references = [];
            }

            for (var i = 0; i < this._references.length; i++) {

                var link = this._references[i],
                    item = link.item,
                    settings = link.settings,
                    store = item._store;

                if (this._originReference == item) {
                    continue;
                }

                if (args.property && settings.properties && settings.properties[args.property]) {

                    if (store) {
                        store._ignoreChangeEvents = true;
                    }
                    try {
                        if (item.onSourceChanged) {
                            item.onSourceChanged(property, value);
                        } else {
                            item.set(property, value);
                        }

                    } catch (e) {
                        _debug && console.error('error updating reference! ' + e, e);
                    }
                    if (store) {
                        store._ignoreChangeEvents = false;
                        store.emit('update', {target: item});
                    }
                }
            }
        },
        constructor: function (properties) {
            this._references = [];
            utils.mixin(this, properties);
        },
        onItemChanged: function (args) {
            this.updateReferences(args);
        }
    };
    //package via declare
    var Module = declare('xgrid.data.Source', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    Module.Implementation = Implementation;
    return Module;
});

},
'xgrid/Grid':function(){
/** @module xgrid/Grid **/
define([
    'dojo/_base/declare',
    'xide/types',
    './Base'
],function (declare,types,Base) {
    /**
     *
     * Please read {@link module:xgrid/types}
     *
     * @class module:xgrid/Grid
     * @augments module:xgrid/Base
     */
    var grid = declare('xgrid/Grid',Base,{});

    grid.createGridClass = Base.createGridClass;

    //track defaults on module
    grid.classFactory = Base.classFactory;
    grid.DEFAULT_GRID_FEATURES = types.DEFAULT_GRID_FEATURES;
    grid.DEFAULT_GRID_BASES = Base.DEFAULT_GRID_BASES;
    grid.DEFAULT_GRID_OPTIONS = types.DEFAULT_GRID_OPTIONS;
    grid.DEFAULT_GRID_OPTION_KEYS = types.DEFAULT_GRID_OPTION_KEYS;

    return grid;
});
},
'dojo/query':function(){
define(["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"],
	function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
});

},
'xfile/component':function(){
define([
    "dcl/dcl",
    "xide/model/Component"
], function (dcl,Component) {

    /**
     * @class xfile.component
     * @inheritDoc
     */
    return dcl(Component, {
        /**
         * @inheritDoc
         */
        beanType:'BTFILE',
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies:function(){
            return [
                "xfile/types",
                "xfile/manager/FileManager",
                "xfile/manager/MountManager",
                "xfile/factory/Store",
                "xfile/views/FileGrid"
            ];
        },
        /**
         * @inheritDoc
         */
        getLabel: function () {
            return 'xfile';
        },
        /**
         * @inheritDoc
         */
        getBeanType:function(){
            return this.beanType;
        }
    });
});


},
'xfile/views/FileGridLight':function(){
/** @module xfile/views/FileGrid **/
define([
    "xdojo/declare",
    "dojo/dom-class",
    'dojo/Deferred',
    'xide/types',
    'xide/utils',
    'xide/views/History',
    'xaction/DefaultActions',
    'xfile/views/GridLight',
    'xfile/factory/Store',
    'xide/model/Path',
    'xfile/model/File',
    "xfile/types",
    'xlang/i18'
], function (declare, domClass, Deferred, types, utils, History,DefaultActions,GridLight,factory,Path,File,fTypes,il8){
    

    var ACTION = types.ACTION;
    var DEFAULT_PERMISSIONS = fTypes.DEFAULT_FILE_GRID_PERMISSIONS;
    /**
     * A grid feature
     * @class module:xfile/views/FileGrid
     */
    var GridClass = declare('xfile.views.FileGrid', GridLight, {
        resizeAfterStartup:true,
        menuOrder: {
            'File': 110,
            'Edit': 100,
            'View': 50,
            'Settings': 20,
            'Navigation': 10,
            'Window': 5
        },
        groupOrder: {
            'Clipboard': 110,
            'File': 100,
            'Step': 80,
            'Open': 70,
            'Organize': 60,
            'Insert': 10,
            'Navigation':5,
            'Select': 0
        },
        tabOrder: {
            'Home': 100,
            'View': 50,
            'Settings': 20,
            'Navigation':10
        },
        /**
         *
         */
        noDataMessage: '<span/>',

        /**
         * history {module:xide/views/History}
         */
        _history:null,
        options: utils.clone(types.DEFAULT_GRID_OPTIONS),
        _columns: {},
        toolbarInitiallyHidden:true,
        itemType:types.ITEM_TYPE.FILE,
        permissions: DEFAULT_PERMISSIONS,
        contextMenuArgs:{
            limitTo:null
        },

        /**
         *
         * @param state
         * @returns {*}
         */
        setState:function(state){

            this.inherited(arguments);

            var self = this,
                collection = self.collection,
                path = state.store.path,//'./client/src'
                item = collection.getSync(path),
                dfd = self.refresh();

            try {
                dfd.then(function () {
                    item = collection.getItem(path, true).then(function (item) {
                        self.openFolder(item);
                    });
                });

            }catch(e){
                console.error('error restoring folder state');
            }
            return dfd;
        },
        /**
         *
         * @returns {*|{dir, lang, textDir}|{dir, lang}}
         */
        postMixInProperties: function () {
            var state =this.state;
            if(state){
                if(state._columns){
                    this._columns = state._columns;
                }
            }

            if (!this.columns) {
                this.columns = this.getColumns();
            }

            if(!this.collection && this.state){

                var _store = this.state.store,
                    ctx = this.ctx,
                    store = factory.createFileStore(_store.mount,_store.storeOptions,ctx.config);
                this.collection = store.getDefaultCollection();
            }
            return this.inherited(arguments);
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        getState:function(state) {
            state = this.inherited(arguments) || {};
            state.store = {
                mount:this.collection.mount,
                path:this.getCurrentFolder().path,
                storeOptions:this.collection.options
            };
            state._columns = {};
            _.each(this._columns,function(c){
                state._columns[c.label]= !this.isColumnHidden(c.id);
            },this);
            return state;
        },
        onSaveLayout:function(e){
            var customData = e.data,
                gridState = this.getState(),
                data = {
                    widget:this.declaredClass,
                    state:gridState
                };

            customData.widgets.push(data);
            return customData;
        },
        formatColumn: function (field, value, obj) {
            var renderer = this.selectedRenderer ? this.selectedRenderer.prototype : this;
            if (renderer.formatColumn) {
                var result = renderer.formatColumn.apply(arguments);
                if (result) {
                    return result;
                }
            }
            if(obj.renderColumn){
               var rendered = obj.renderColumn.apply(this,arguments);
                if(rendered){
                    return rendered;
                }

            }
            switch (field) {

                case "fileType":{
                    if(value=='folder'){
                        return il8.localize('kindFolder');
                    }else{
                        if(obj.mime) {
                            var mime = obj.mime.split('/')[1]  ||  "unknown";
                            var key = 'kind' + mime.toUpperCase();
                            var _translated = il8.localize(key);
                            return key !== _translated ? _translated : value;
                        }
                    }
                }
                case "name":{

                    var directory = obj && obj.directory != null && obj.directory === true;
                    var no_access = obj.read === false && obj.write === false;
                    var isBack = obj.name == '..';

                    var folderClass = 'fa-folder';

                    var isLoading = obj.isLoading;
                    if(isLoading){
                        //folderClass = ' fa-spinner fa-spin';
                    }

                    var icon = '';
                    var imageClass = '';
                    var useCSS = false;
                    if (directory) {
                        if (isBack) {
                            imageClass = 'fa fa-level-up itemFolderList';
                            useCSS = true;
                        } else if (!no_access) {
                            imageClass = 'fa ' + folderClass +' itemFolderList';

                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }

                    } else {

                        if (!no_access) {
                            imageClass = 'itemFolderList fa ' + utils.getIconClass(obj.path);
                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }
                    }
                    var label = obj.showPath === true ? obj.path : value;
                    if (!useCSS) {
                        return '<img class="fileGridIconCell" src="' + icon + ' "/><span class="fileGridNameCell">' + label + '</span>';
                    } else {
                        return '<span class=\"' + imageClass + '\""></span><span class="name fileGridNameNode" style="vertical-align: middle;padding-top: 0px">' + label + '</span>';
                    }
                }
                case "sizeBytes":
                {
                    return obj.size;
                }
                case "fileType":
                {
                    return utils.capitalize(obj.fileType || 'unknown');
                }
                case "mediaInfo":{
                    return obj.mediaInfo || 'unknown';
                }
                case "owner":
                {
                    if(obj) {
                        var owner = obj.owner;
                        if (owner && owner.user) {
                            return owner.user.name;
                        }
                    }
                    return ""
                }
                case "modified":
                {
                    if(value ===''){
                        return value;
                    }
                    var directory = !obj.directory == null;
                    var dateStr = '';
                    if (directory) {

                    } else {
                        var dateFormat = il8.translations.dateFormat;
                        if(dateFormat){
                            var res = il8.formatDate(value);
                            return res.replace('ms','');
                        }
                    }
                    return dateStr;
                }

            }
            return value;
        },
        getColumns: function () {
            var thiz = this;
            this.columns = [];
            function createColumn(label, field, sortable, hidden) {

                if (thiz._columns[label] != null) {
                    hidden = !thiz._columns[label];
                }

                thiz.columns.push({
                    renderExpando: label === 'Name',
                    label: label,
                    field: field,
                    sortable: sortable,
                    formatter: function (value, obj) {
                        return thiz.formatColumn(field, value, obj);
                    },
                    hidden: hidden
                });
            }
            createColumn('Name', 'name', true, false);
            createColumn('Type', 'fileType', true, true);
            createColumn('Path', 'path', true, true);
            createColumn('Size', 'sizeBytes', true, false);
            createColumn('Modified', 'modified', true, false);
            createColumn('Owner', 'owner', true, true);
            createColumn('Media', 'mediaInfo', true, true);
            return this.columns;
        },
        _focus:function(){
            var thiz = this,
                rows = thiz.getRows();
            if(rows[0]){
                var _row = thiz.row(rows[0]);
                thiz.focus(_row.data);
            }
        },
        setQueryEx: function (item, settings) {
            settings = settings || {
                focus: true,
                delay:1
            };
            if (!item) {
                console.error('bad, no item!');
                return false;
            }

            if (!item.directory) {
                return false;
            }

            this._lastPath = item.getPath();
            var thiz = this,
                grid = thiz,
                dfd = new Deferred();

            if (!grid) {
                console.error('have no grid');
                return;
            }
            var col = thiz.collection,
                focusNext;

            if (item.path === '.') {
                col.resetQueryLog();
                grid.set("collection", col.getDefaultCollection(item.getPath()));
                if(dfd.resolve){
                    dfd.resolve();
                }

            } else {
                col.open(item).then(function (items) {
                    col.resetQueryLog();
                    grid.set("collection", col.getDefaultCollection(item.getPath()));
                    if(dfd.resolve) {
                        dfd.resolve(items);
                    }
                });
            }
            return dfd;
        },
        getCurrentFolder:function(){
            var renderer = this.getSelectedRenderer();
            if(renderer && renderer.getCurrentFolder){
                var _result = renderer.getCurrentFolder.apply(this);
                if(_result){
                    if(_result.isBack){
                        var __result = this.collection.getSync(_result.rPath);
                        if(__result){
                            _result = __result;
                        }
                    }
                    return _result;
                }
            }
            var item = this.getRows()[0];
            if(item && (item._S || item._store)) {
                if(item.isBack==true){
                    var _now = this.getHistory().getNow();
                    if(_now){
                        return this.collection.getSync(_now);
                    }
                }
                //current folder:
                var _parent = item._S.getParent(item);
                if(_parent){
                    return _parent;
                }
            }
            return null;
        },
        getClass:function(){
            return GridClass;
        },
        getHistory:function(){
            if(!this._history){
                this._history = new History();
            }
            return this._history;
        },
        renderArray:function(what,data){
            var items = arguments[0];
            var self = this;
            var firstItem = items[0],
                _parent = null;
            var addBack = !_.find(items,{
                isBack:true
            });
            return this.inherited(arguments);
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var res  = this.inherited(arguments);
            domClass.add(this.domNode, 'xfileGrid');
            this.set('loading',true);
            if (this.permissions) {
                var _defaultActions = DefaultActions.getDefaultActions(this.permissions, this,this);
                _defaultActions = _defaultActions.concat(this.getFileActions(this.permissions));
                this.addActions(_defaultActions);
            }
            this._history = new History();
            var self = this;

            this.subscribe(types.EVENTS.ON_CLIPBOARD_COPY,function(evt){
                if(evt.type === self.itemType){
                    self.currentCopySelection = evt.selection;
                    self.refreshActions();
                }
            });
            
            self._on('noData',function(){

                var _rows = self.getRows();
                if(self._total>0){
                    return;
                }
                var _history = self._history,
                    now = _history.getNow();

                if(!now || now ==='./.'){
                    return;
                }
                self.renderArray([
                    {
                        name: '..',
                        path:'..',
                        rPath:now,
                        sizeBytes:0,
                        size:'',
                        icon:'fa-level-up',
                        isBack:true,
                        modified:'',
                        _S:self.collection,
                        directory:true,
                        _EX:true,
                        children:[],
                        mayHaveChildren:false
                    }
                ]);
            });

            this.on('dgrid-refresh-complete',function(){
                var rows = self.getRows();
                if(rows && rows.length>1){
                    var back = _.find(rows,{
                        isBack:true
                    });
                    if(back){
                        self.removeRow(back);
                        self.refresh();
                    }
                }
            })

            this._on('openFolder',function(evt){
                var isBack = evt.back,
                    item = evt.item,
                    path = item.path,
                    history = self._history;
                self.set('title',item.name);
            });

            //initiate
            if(self.selectedRenderer) {
                res = this.refresh();
                res && res.then(function () {
                    self.set('loading',false);
                    self.setRenderer(self.selectedRenderer,false);
                });
            }
            this._on('onChangeRenderer',function(){
                self.refresh();
            });
            setTimeout(function(){
                self.resize();
            },500);
            return res;
        }
    });

    /**
     *
     * @param ctx
     * @param args
     * @param parent
     * @param register
     * @param startup
     * @param store
     * @returns {widgetProto}
     */
    function createDefault(ctx,args,parent,register,startup,store) {

        args = utils.mixin({
            collection: store.getDefaultCollection(),
            _parent: parent,
            Module:GridClass,
            ctx:ctx
        }, args || {});

        var grid = utils.addWidget(GridClass, args, null, parent, startup, null, null, true, null);
        if (register) {
            ctx.getWindowManager().registerView(grid,false);
        }
        return grid;
    }

    GridClass.prototype.Module = GridClass;
    GridClass.Module = GridClass;
    GridClass.createDefault = createDefault;
    GridClass.DEFAULT_PERMISSIONS = DEFAULT_PERMISSIONS;

    return GridClass;

});
},
'xace/views/_AceMultiDocs':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    "module",
    "xace/base_handler",
    "xace/complete_util"
],function (dcl,declare,module,baseLanguageHandler,completeUtil){

    var analysisCache = {}; // path => {identifier: 3, ...}
    var globalWordIndex = {}; // word => frequency
    var globalWordFiles = {}; // word => [path]
    var precachedPath;
    var precachedDoc;

    var completer = module.exports = Object.create(baseLanguageHandler);

    completer.handlesLanguage = function(language) {
        return true;
    };

    completer.handlesEditor = function() {
        return this.HANDLES_ANY;
    };

    completer.getMaxFileSizeSupported = function() {
        return 1000 * 1000;
    };

    function frequencyAnalyzer(path, text, identDict, fileDict) {
        var identifiers = text.split(/[^a-zA-Z_0-9\$]+/);
        for (var i = 0; i < identifiers.length; i++) {
            var ident = identifiers[i];
            if (!ident)
                continue;

            if (Object.prototype.hasOwnProperty.call(identDict, ident)) {
                identDict[ident]++;
                fileDict[ident][path] = true;
            }
            else {
                identDict[ident] = 1;
                fileDict[ident] = {};
                fileDict[ident][path] = true;
            }
        }
        return identDict;
    }

    function removeDocumentFromCache(path) {
        var analysis = analysisCache[path];
        if (!analysis) return;

        for (var id in analysis) {
            globalWordIndex[id] -= analysis[id];
            delete globalWordFiles[id][path];
            if (globalWordIndex[id] === 0) {
                delete globalWordIndex[id];
                delete globalWordFiles[id];
            }
        }
        delete analysisCache[path];
    }

    function analyzeDocument(path, allCode) {
        if (!analysisCache[path]) {
            if (allCode.size > 80 * 10000) {
                delete analysisCache[path];
                return;
            }
            // Delay this slightly, because in Firefox document.value is not immediately filled
            analysisCache[path] = frequencyAnalyzer(path, allCode, {}, {});
            // may be a bit redundant to do this twice, but alright...
            frequencyAnalyzer(path, allCode, globalWordIndex, globalWordFiles);
        }
    }

    completer.onDocumentOpen = function(path, doc, oldPath, callback) {
        if (!analysisCache[path]) {
            analyzeDocument(path, doc.getValue());
        }
        callback();
    };

    completer.addDocument = function(path, value) {
        if (!analysisCache[path]) {
            analyzeDocument(path, value);
        }

    };

    completer.onDocumentClose = function(path, callback) {
        removeDocumentFromCache(path);
        if (path == precachedPath)
            precachedDoc = null;
        callback();
    };

    completer.analyze = function(doc, ast, callback, minimalAnalysis) {
        if (precachedDoc && this.path !== precachedPath) {
            removeDocumentFromCache(precachedPath);
            analyzeDocument(precachedPath, precachedDoc);
            precachedDoc = null;
        }
        precachedPath = this.path;
        precachedDoc = doc;
        callback();
    };

    completer.complete = function(editor, fullAst, pos, currentNode, callback) {

        var doc = editor.getSession();
        var line = doc.getLine(pos.row);
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, this.$getIdentifierRegex());
        var identDict = globalWordIndex;

        var allIdentifiers = [];
        for (var ident in identDict) {
            allIdentifiers.push(ident);
        }
        var matches = completeUtil.findCompletions(identifier, allIdentifiers);

        var currentPath = this.path;
        matches = matches.filter(function(m) {
            return !globalWordFiles[m][currentPath];
        });

        matches = matches.slice(0, 100); // limits results for performance

        callback(matches.filter(function(m) {
            return !m.match(/^[0-9$_\/]/);
        }).map(function(m) {
            var path = Object.keys(globalWordFiles[m])[0] || "[unknown]";
            var pathParts = path.split("/");
            var foundInFile = pathParts[pathParts.length-1];
            return {
                name: m,
                value: m,
                icon: null,
                score: identDict[m],
                meta: foundInFile,
                priority: 0,
                isGeneric: true
            };
        }));
    };

    completer.getCompletions=function (editor, session, pos, prefix, callback) {
        var completions = null;
        var _c = function(_completions){
            completions = _completions;
        };
        completer.complete(editor,null,pos,null,_c);
        callback(null,completions);
    };

    var Module  = dcl(null,{

        declaredClass:"xide.views._AceMultiDocs",
        didAddMCompleter:false,
        multiFileCompleter:null,
        addFileCompleter:function(){
            var compl = null;
            if(!this.didAddMCompleter) {
                compl = completer;
                this.multiFileCompleter= compl;
                var langTools = ace.require("ace/ext/language_tools");
                langTools.addCompleter(compl);
                this.didAddMCompleter=true;
            }
            return compl;
        }
    });

    Module.completer = completer;

    return Module;
});
},
'dojo/request/util':function(){
define([
	'exports',
	'../errors/RequestError',
	'../errors/CancelError',
	'../Deferred',
	'../io-query',
	'../_base/array',
	'../_base/lang',
	'../promise/Promise'
], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise){
	exports.deepCopy = function deepCopy(target, source){
		for(var name in source){
			var tval = target[name],
				sval = source[name];
			if(tval !== sval){
				if(tval && typeof tval === 'object' && sval && typeof sval === 'object'){
					exports.deepCopy(tval, sval);
				}else{
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data || response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;
		
		if(data && !skipData){
			if(typeof data === 'object'){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
});

},
'xide/factory/Events':function(){
define([
    'xide/factory',
    'dojo/_base/connect',
    'dojo/_base/lang',
    "dojo/on",
    'dojo/has'
], function (factory, connect, lang, on,has) {

    var _debug = false,         //print publish messages in console
        _tryEvents = false,     //put publish in try/catch block
        _foo=null,              //noop
        _nativeEvents = {
            "click": _foo,
            "dblclick":_foo,
            "mousedown":_foo,
            "mouseup":_foo,
            "mouseover":_foo,
            "mousemove":_foo,
            "mouseout":_foo,
            "keypress":_foo,
            "keydown":_foo,
            "keyup":_foo,
            "focus":_foo,
            "blur":_foo,
            "change":_foo
        },
        _debugGroup=false;


    /**
     * Returns true if it is a DOM element, might be not needed anymore
     * @param o
     * @returns {*}
     * @private
     */
    function _isElement(o){
        return (
            typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
        );
    }
    /**
     * Event debouncer/throttler
     * @param eventHandler
     * @param waitForMirror
     * @returns {Function}
     */
    function applyEventOnce(eventHandler, waitForMirror) {
        var timer;
        var mirror = this;
        return function() {
            var _arguments = arguments;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {
                if (waitForMirror && mirror.isPending())
                    return setTimeout(function() { applyEventOnce(eventHandler, true) }, 0);
                eventHandler.apply(eventHandler, _arguments);
            }, 0);
        };
    }

    /**
     * asyncForEach does runs a chain of promises, needed this specialized for event callbacks
     * @param array
     * @param fn
     * @param test
     * @param callback
     */
    function asyncForEach(array, fn, test, callback) {
        if (!callback) {
            callback = test;
            test = null;
        }

        array = array.slice(); // copy before use

        var nested = false, callNext = true;
        loop();

        function loop() {
            while (callNext && !nested) {
                callNext = false;
                while (array.length > 0 && test && !test(array[0]))
                    array.shift();

                var item = array.shift();
                // TODO: implement proper err argument?
                if (!item)
                    return callback && callback();

                nested = true;
                fn(item, loop);
                nested = false;
            }
            callNext = true;
        }
    }

    /***
     * @param keys
     * @param data
     * @param callee
     * @extends module:xide/factory
     * @memberOf xide/factory
     */
    factory.publish = function (keys, data, callee,filter) {

        var msgStruct   = data ? _.isString(data) ? {message: data} : data : {},
            eventKeys   = keys,
            _publish    = connect.publish,
            result      = [];//lookup cache

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }
        for (var i = 0,l=eventKeys.length; i < l; i++) {

            var eventKey = eventKeys[i];

            if(filter && !filter(eventKey)){
                continue;
            }

            if (_debug) {
                //console.group("Events");
                _debugGroup = true;
                console.log('publish ' + eventKey + ' from : ' + (callee ? callee.id : ''), msgStruct);
            }

            if(_tryEvents) {
                try {
                    result = _publish(eventKey, msgStruct);
                } catch (e) {
                    logError(e,'error whilst publishing event ' + eventKey);
                }
            }else{
                result = _publish(eventKey, msgStruct);
            }
        }

        return result;
    };

    /***
     *
     * Subscribes to multiple events
     * @param keys {String[]}
     * @param _cb {function|null} When null, it expects the owner having a function matching the event key!
     * @param owner {Object}
     * @extends module:xide/factory
     * @memberOf xide/factory
     * @returns {Object[]|null} Returns an array of regular Dojo-subscribe/on handles
     */
    factory.subscribe = function (keys, cb, owner,filter) {

        if( false ){
            if(!keys){
                _debug && console.error('subscribe failed, event key is empty!');
                return null;
            }
        }

        //some vars
        var eventKeys  = keys,
            _subscribe = connect.subscribe,     //cache
            events = [];                        //resulting subscribe handles
            //_isDom = _isElement(owner),       //dom element?

        //-- not good for use-strict
        //owner = owner || arguments.callee;

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }

        for (var i = 0,l=eventKeys.length; i < l; i++) {

            if(!eventKeys[i] || filter && !filter(eventKey)){
                continue;
            }

            var _item =
                    //the raw item
                    eventKeys[i],
                    //is string?
                    _isString = _.isString(_item),
                    //if string: use it, otherwise assume struct
                    eventKey =  _isString ? _item : _item.key,
                    //pick handler from arguments or struct
                    _handler = _isString ? cb : _item.handler,
                    //is native event?
                    _isNative = eventKey in _nativeEvents,
                    //the final handle
                    _handle;


            //owner specified, hitch the callback into owner's scope
            if (owner != null) {
                //try cb first, then owner.onEVENT_KEY, that enables similar effect as in Dojo2/Evented
                var _cb = _handler !=null ? _handler : owner[eventKey];
                if(_isNative){
                    _handle = on(owner, eventKey, lang.hitch(owner, _cb));
                }else{
                    _handle = _subscribe(eventKey, lang.hitch(owner, _cb));
                }
                _handle.handler = lang.hitch(owner, _cb);
            } else {
                _handle =  connect.subscribe(eventKey, _handler);
                _handle.handler = _handler;
            }
            //track the actual event type
            _handle.type = eventKey;
            events.push(_handle);
        }
        return events;
    };
    return factory;
});
},
'xbox/GUIALL':function(){
define([
    //'xide/views/ToggleSplitter',
    'xide/factory/Widgets',
    'xide/factory/Views',
    'dgrid/util/touch',
    'dgrid/TouchScroll',
    'dgrid/extensions/_DnD-touch-autoscroll'
], function () {

});
},
'xide/encoding/SHA1':function(){
define(["./_base"], function(base){

	var chrsz=8,	//	change to 16 for unicode.
		mask=(1<<chrsz)-1;

	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function FT(t,b,c,d){
		if(t<20){ return (b&c)|((~b)&d); }
		if(t<40){ return b^c^d; }
		if(t<60){ return (b&c)|(b&d)|(c&d); }
		return b^c^d;
	}
	function KT(t){ return (t<20)?1518500249:(t<40)?1859775393:(t<60)?-1894007588:-899497514; }

	function core(x,len){
		x[len>>5]|=0x80<<(24-len%32);
		x[((len+64>>9)<<4)+15]=len;

		var w=new Array(80), a=1732584193, b=-271733879, c=-1732584194, d=271733878, e=-1009589776;
		for(var i=0; i<x.length; i+=16){
			var olda=a, oldb=b, oldc=c, oldd=d, olde=e;
			for(var j=0;j<80;j++){
				if(j<16){ w[j]=x[i+j]; }
				else { w[j]=R(w[j-3]^w[j-8]^w[j-14]^w[j-16],1); }
				var t = base.addWords(base.addWords(R(a,5),FT(j,b,c,d)),base.addWords(base.addWords(e,w[j]),KT(j)));
				e=d; d=c; c=R(b,30); b=a; a=t;
			}
			a=base.addWords(a,olda);
			b=base.addWords(b,oldb);
			c=base.addWords(c,oldc);
			d=base.addWords(d,oldd);
			e=base.addWords(e,olde);
		}
		return [a, b, c, d, e];
	}

	function hmac(data, key){
		var wa=toWord(key);
		if(wa.length>16){ wa=core(wa, key.length*chrsz); }

		var ipad=new Array(16), opad=new Array(16);
		for(var i=0;i<16;i++){
			ipad[i]=wa[i]^0x36363636;
			opad[i]=wa[i]^0x5c5c5c5c;
		}

		var hash=core(ipad.concat(toWord(data)),512+data.length*chrsz);
		return core(opad.concat(hash), 512+160);
	}

	function toWord(s){
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(32-chrsz-i%32);
		}
		return wa;	//	word[]
	}

	function toHex(wa){
		//	slightly different than the common one.
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((3-i%4)*8+4))&0xF), h.charAt((wa[i>>2]>>((3-i%4)*8))&0xF));
		}
		return s.join("");	//	string
	}

	function _toString(wa){
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(32-chrsz-i%32))&mask));
		}
		return s.join("");	//	string
	}

	function toBase64(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(3-i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*(3-(i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*(3-(i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	public function
	base.SHA1=function(/* String */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		Computes the SHA1 digest of the data, and returns the result according to output type.
		var out=outputType||base.outputTypes.Base64;
		var wa=core(toWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.SHA1._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	return base.SHA1;
});

},
'xide/utils/StringUtils':function(){
/** @module xide/utils/StringUtils
 *  @description All string related functions
 */
define([
    'xide/utils',
    'xide/types',
    'dojo/json',
    'xide/lodash'
], function (utils, types, json, _) {
    "use strict";

    /**
     *
     * @param replacer
     * @param cycleReplacer
     * @returns {Function}
     */
    function serializer(replacer, cycleReplacer) {
        var stack = [], keys = [];

        if (cycleReplacer == null) cycleReplacer = function (key, value) {
            if (stack[0] === value) return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
        };

        return function (key, value) {
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this);
                ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
                ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
                if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
            }
            else stack.push(value);

            return replacer == null ? value : replacer.call(this, key, value)
        }
    }

    /**
     *
     * @param obj
     * @returns {*}
     */
    utils.stringify = function (obj) {
        return JSON.stringify(obj, serializer(), 2);
    };

    function stringify(obj, replacer, spaces, cycleReplacer) {
        return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }

    /**
     * Takes a number and returns a rounded fixed digit string.
     * Returns an empty string if first parameter is NaN, (-)Infinity or not of type number.
     * If parameter trailing is set to true trailing zeros will be kept.
     *
     * @param {number} num the number
     * @param {number} [digits=3] digit count
     * @param {boolean} [trailing=false] keep trailing zeros
     * @memberOf module:xide/utils/StringUtils
     *
     * @example
     *
     test(fsuxx(-6.8999999999999995), '-6.9');
     test(fsuxx(0.020000000000000004), '0.02');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 1), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     test(fsuxx('muh'), '');
     test(fsuxx(false), '');
     test(fsuxx(null), '');
     test(fsuxx(), '');
     test(fsuxx(NaN), '');
     test(fsuxx(Infinity), '');
     test(fsuxx({bla: 'blub'}), '');
     test(fsuxx([1,2,3]), '');
     test(fsuxx(6.8999999999999995), '6.9');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     *
     *
     * @returns {string}
     *
     */
    utils.round = function (num, digits, trailing) {

        if (typeof num !== 'number' || isNaN(num) || num === Infinity || num === -Infinity) return '';

        digits = ((typeof digits === 'undefined') ? 3 : (parseInt(digits, 10) || 0));

        var f = Math.pow(10, digits);
        var res = (Math.round(num * f) / f).toFixed(digits);

        // remove trailing zeros and cast back to string
        if (!trailing) res = '' + (+res);

        return res;
    };




    /**
     *
     * @param bytes
     * @param si
     * @returns {string}
     */
    utils.humanFileSize = function (bytes, si) {
        var thresh = si ? 1000 : 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = si
            ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1) + ' ' + units[u];
    };

    if (typeof String.prototype.startsWith != 'function') {
        // see below for better implementation!
        String.prototype.startsWith = function (str) {
            return this.indexOf(str) === 0;
        };
    }

    if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
            return this.substring( this.length - str.length, this.length ) === str;
        }
    }

    /**
     *
     * @param str
     * @returns {boolean}
     */
    utils.isNativeEvent = function (str) {
        var _foo = null,//just for having an optimized object map for a native event lookup below
            _nativeEvents = {
                "onclick": _foo,
                "ondblclick": _foo,
                "onmousedown": _foo,
                "onmouseup": _foo,
                "onmouseover": _foo,
                "onmousemove": _foo,
                "onmouseout": _foo,
                "onkeypress": _foo,
                "onkeydown": _foo,
                "onkeyup": _foo,
                "onfocus": _foo,
                "onblur": _foo,
                "onchange": _foo
            };

        if (str in _nativeEvents) {
            return true;
        }
        _nativeEvents = {
            "click": _foo,
            "dblclick": _foo,
            "mousedown": _foo,
            "mouseup": _foo,
            "mouseover": _foo,
            "mousemove": _foo,
            "mouseout": _foo,
            "keypress": _foo,
            "keydown": _foo,
            "keyup": _foo,
            "focus": _foo,
            "blur": _foo,
            "change": _foo
        };

        return str in _nativeEvents;

    };
    /**
     *
     * @param str
     * @returns {boolean}
     *
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isSystemEvent = function (str) {
        for (var t in types.EVENTS) {
            if (types.EVENTS[t] === str) {
                return true;
            }
        }
        return false;
    };

    /**
     *
     * @param arr
     * @param val
     * @returns {number}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.contains = function (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === val) {
                return i;
            }
        }
        return -1;
    };
    /**
     *
     * @param obj
     * @param val
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getObjectKeyByValue = function (obj, val) {
        if (obj && val) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] === val)
                        return prop;
                }
            }
        }
        return null;
    };

    /**
     *
     * @param url
     * @param parameter
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.removeURLParameter = function (url, parameter) {
        //prefer to use l.search if you have a location/link object
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {

            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);

            //reverse iteration as may be destructive
            for (var i = pars.length; i-- > 0;) {
                //idiom for string.startsWith
                if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                    pars.splice(i, 1);
                }
            }

            url = urlparts[0] + '?' + pars.join('&');
            return url;
        } else {
            return url;
        }
    };

    /**
     *
     * @param url
     * @param paramName
     * @param paramValue
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceUrlParam = function (url, paramName, paramValue) {
        if (url.indexOf(paramName) == -1) {
            url += (url.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue;
            return url;
        }
        var pattern = new RegExp('(' + paramName + '=).*?(&|$)');
        var newUrl = url.replace(pattern, '$1' + paramValue + '$2');
        if (newUrl == url) {
            newUrl = newUrl + (newUrl.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue
        }
        return newUrl
    };

    /**
     *
     * @param mount
     * @param path
     * @param encode
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.buildPath = function (mount, path, encode) {

        //fix mount
        var _mount = '' + mount;
        _mount = utils.replaceAll('/', '', mount);
        var _path = '' + path;
        _path = _path.replace('./', '/').replace(/^\/|\/$/g, '');

        var _res = _mount + '://' + _path;
        if (encode === true) {
            return encodeURIComponent(_res);
        }
        return _res;
    };

    /**
     *
     * @param string
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     *
     */
    utils.isImage = function (string) {
        return string.toLowerCase().match(/\.(jpeg|jpg|gif|png)$/) != null;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag3 = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param enumValue
     * @param field
     * @returns {int|*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.disableFlag = function (enumValue, field) {
        enumValue &= ~(1 << field);
        return enumValue;
    };
    /**
     * XApp specific url string cleaner
     * @param string
     * @returns {*}
     */
    utils.cleanUrl = function (string) {
        if (string) {
            string = string.replace('//', '/');
            string = string.replace('./', '/');
            string = string.replace('http:/', 'http://');
            string = string.replace('./', '/');
            string = string.replace('////', '/');
            string = string.replace('///', '/');
            return string;
        }
        return string;
    };
    /**
     * Return data from JSON
     * @param inData
     * @param validOnly
     * @param imit
     * @memberOf module:xide/utils/StringUtils
     * @returns {*}
     */
    utils.getJson = function (inData, validOnly, ommit) {
        try {
            return _.isString(inData) ? json.parse(inData, false) : validOnly === true ? null : inData;
        } catch (e) {
            ommit !== false && console.error('error parsing json data ' + inData + ' error = ' + e);
        }
        return null;
    };

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.fromJson = function (js) {
        if (!_.isString(js)) {
            return js;
        }
        var res = null;
        var didFail = false;
        try {
            res = eval("(" + js + ")", {});
        } catch (e) {
            didFail = true;
        }
        if (didFail) {
            js = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                res = eval("(" + js + ")", {});
            } catch (e) {
                throw new Error(js);
            }
        }
        return res;
    };

    /**
     * String Replace which works with multiple found items. Native aborts on the first needle.
     * @param find
     * @param replace
     * @param str
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceAll = function (find, replace, str) {
        return str ? str.split(find).join(replace) : '';
    };

    /**
     * CI compatible string check for null and length>0
     * @param input
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isValidString = function (input) {
        return input != null && input.length != null && input.length > 0 && input != "undefined"; //Boolean
    };

    /**
     * Dojo style template replacer
     * @param template
     * @param obj
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.substituteString = function (template, obj) {
        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key) {
            return obj[key];
        });
    };

    /**
     *
     * @param expression
     * @param delimiters
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.findOcurrences = function (expression, delimiters) {
        var d = {
            begin: utils.escapeRegExp(delimiters.begin),
            end: utils.escapeRegExp(delimiters.end)
        };
        return expression.match(new RegExp(d.begin + "([^" + d.end + "]*)" + d.end, 'g'));
    };

    /**
     * Escape regular expressions in a string
     * @param string
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.escapeRegExp = function (string) {
        var special = ["[", "]", "(", ")", "{", "}", "*", "+", ".", "|", "||"];
        for (var n = 0; n < special.length; n++) {
            string = string.replace(special[n], "\\" + special[n]);
        }

        return string;
    };
    /**
     *
     * @param str {string} haystack
     * @param hash {Object}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.multipleReplace = function (str, hash) {
        //to array
        var a = [];
        for (var key in hash) {
            a[a.length] = key;
        }
        return str.replace(new RegExp(a.join('\\b|\\b'), 'g'), function (m) {
            return hash[m] || hash["\\" + m];
        });
    };

    /**
     * Flexible replacer, supports multiple replace and safe replace
     *
     * @param str {string} the haystack

     * @param needle {string|null} optional, only needed for simple cases, otherwise its using the 'what' map
     *
     * @param what {string|Object}. When string, its replacing 'needle' with 'what'. If its a hash-map:
     * variable:value, its replacing occurrences of all variables in 'haystack'. In such case, you can specify
     * delimiters to make sure that 'unresolved' variables will be stripped of in the result.
     *
     * @param delimiters {Object} Delimiters to identify variables. This is used to eliminate unresolved variables from
     * the result.
     *
     * @param delimiters.begin {string}
     * @param delimiters.end {string}
     *
     * @returns {string}
     *
     *
     * @example:
     *
     * 1. simple case: replace all '/' with ''
     *
     * return utils.replace('/foo/','/','') //returns 'foo'
     *
     * 2. simple case with multiple variables:
     *
     * return utils.replace('darling, i miss you so much',null,{'miss':'kiss','much':'little'})
     * # darling, i kiss you so little
     *
     * @memberOf module:xide/utils
     * @extends xide/utils
     */
    utils.replace = function (str, needle, what, delimiters) {
        if (!str) {
            return '';
        }
        if (what && _.isObject(what) || _.isArray(what)) {
            if (delimiters) {
                var ocurr = utils.findOcurrences(str, delimiters),
                    replaceAll = utils.replaceAll;
                if (ocurr) {

                    for (var i = 0, j = ocurr.length; i < j; i++) {
                        var el = ocurr[i];

                        //strip off delimiters
                        var _variableName = replaceAll(delimiters.begin, '', el);
                        _variableName = replaceAll(delimiters.end, '', _variableName);
                        str = replaceAll(el, what[_variableName], str);
                    }
                } else {
                    return str;
                }
            } else {
                //fast case
                return utils.multipleReplace(str, what)
            }
            return str;
        }
        //fast case
        return utils.replaceAll(needle, what, str);
    };

    /**
     * Capitalize
     * @param word
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.capitalize = function (word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1);
    };

    /**
     * vsprintf impl. of PHP
     * @param format
     * @param args
     * @example
     // example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1]);
     // returns 1: '1988-08-01'
     * @memberOf module:xide/utils/StringUtils
     */
    utils.vsprintf = function (format, args) {
        return utils.sprintf.apply(this, [format].concat(args));
    };
    /**
     * PHP.js version of sprintf
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @link http://kevin.vanzonneveld.net
     */
    utils.sprintf = function () {
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        var a = arguments,
            i = 0,
            format = a[i++];

        // pad()
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        };

        // justify()
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };

        // formatBaseX()
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {
                    '2': '0b',
                    '8': '0',
                    '16': '0x'
                }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };

        // formatString()
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };

        // doFormat()
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;

            if (substring === '%%') {
                return '%';
            }

            // parse flags
            var leftJustify = false,
                positivePrefix = '',
                zeroPad = false,
                prefixBaseX = false,
                customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                    case ' ':
                        positivePrefix = ' ';
                        break;
                    case '+':
                        positivePrefix = '+';
                        break;
                    case '-':
                        leftJustify = true;
                        break;
                    case "'":
                        customPadChar = flags.charAt(j + 1);
                        break;
                    case '0':
                        zeroPad = true;
                        break;
                    case '#':
                        prefixBaseX = true;
                        break;
                }
            }

            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth === '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }

            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
            } else if (precision === '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }

            // grab value using valueIndex if required?
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
                case 's':
                    return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
                case 'c':
                    return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
                case 'b':
                    return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'o':
                    return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'x':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'X':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
                case 'u':
                    return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'i':
                case 'd':
                    number = +value || 0;
                    number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
                    prefix = number < 0 ? '-' : positivePrefix;
                    value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad);
                case 'e':
                case 'E':
                case 'f': // Should handle locales (as per setlocale)
                case 'F':
                case 'g':
                case 'G':
                    number = +value;
                    prefix = number < 0 ? '-' : positivePrefix;
                    method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                    textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                    value = prefix + Math.abs(number)[method](precision);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                default:
                    return substring;
            }
        };

        return format.replace(regex, doFormat);
    };
    /***
     *
     * @param str
     * @returns {string | null}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.cleanString = function (str) {
        if (!str) {
            return null;
        }
        str = str.replace(/[\r]/g, '')
            .replace(/[\b]/g, '')
            .replace(/[\f]/g, '')
            .replace(/[\n]/g, '')
            .replace(/\\/g, '');
        return str;
    };
    /***
     *
     * @param str {string}
     * @returns {string | null}
     */
    utils.normalizePath = function (str) {
        if (!str) {
            return null;
        }
        str = utils.cleanString(str);//control characters
        str = str.replace('./', '');//file store specifics
        str = str.replace('/.', '');//file store specifics
        str = str.replace(/([^:]\/)\/+/g, "$1");//double slashes
        return str;
    };

    /**
     *
     * @enum
     * @global
     * @memberOf module:xide/types
     */
    types.PATH_PARTS = {
        'DIRNAME': 1,
        'BASENAME': 2,
        'EXTENSION': 4,
        'FILENAME': 8,
        'PATHINFO_ALL': 0
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix {string}
     * @example
     //   example 1: basename('/www/site/home.htm', '.htm');
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1');
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/');
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext');
     //   returns 4: 'path_ext'
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     * @link http://phpjs.org/functions/basename/
     */
    utils.basename = function (path, suffix) {
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1);
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) == suffix) {
            b = b.substr(0, b.length - suffix.length);
        }
        return b;
    };

    /**
     *
     * @param path
     * @param options
     * @example
     //   example 1: pathinfo('/www/htdocs/index.html', 1);
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME');
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION');
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME');
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4);
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL');
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html');
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     * @returns {object}
     * @link http://phpjs.org/functions/pathinfo/
     * @memberOf module:xide/utils/StringUtils
     */
    utils.pathinfo = function (path, options) {
        //  discuss at:
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //        note: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //        note: The way the bitwise arguments are handled allows for greater flexibility
        //        note: & compatability. We might even standardize this code and use a similar approach for
        //        note: other bitwise PHP functions
        //        note: php.js tries very hard to stay away from a core.js file with global dependencies, because we like
        //        note: that you can just take a couple of functions and be on your way.
        //        note: But by way we implemented this function, if you want you can still declare the PATHINFO_*
        //        note: yourself, and then you can use: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //        note: which makes it fully compliant with PHP syntax.
        //  depends on: basename
        var opt = '',
            real_opt = '',
            optName = '',
            optTemp = 0,
            tmp_arr = {},
            cnt = 0,
            i = 0;
        var have_basename = false,
            have_extension = false,
            have_filename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false;
        }
        if (!options) {
            options = 'PATHINFO_ALL';
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName];
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]];
                }
            }
            options = optTemp;
        }

        // Internal Functions
        var __getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : '';
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path.replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmp_arr.dirname = dirName === path ? '.' : dirName;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            tmp_arr.basename = have_basename;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false !== have_extension) {
                tmp_arr.extension = have_extension;
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false === have_filename) {
                have_filename = have_basename.slice(0, have_basename.length - (have_extension ? have_extension.length + 1 :
                        have_extension === false ? 0 : 1));
            }

            tmp_arr.filename = have_filename;
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmp_arr) {
            if (tmp_arr.hasOwnProperty(opt)) {
                cnt++;
                real_opt = opt;
            }
        }
        if (cnt === 1) {
            return tmp_arr[real_opt];
        }

        // Return full-blown array
        return tmp_arr;
    };

    /**
     * PHP.js version of parse_url
     * @param str {string}
     * @param component {string} enum
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.parse_url = function (str, component) {
        //       discuss at: http://phpjs.org/functions/parse_url/
        //      improved by: Brett Zamir (http://brett-zamir.me)
        //             note: original by http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: blog post at http://blog.stevenlevithan.com/archives/parseuri
        //             note: demo at http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: Does not replace invalid characters with '_' as in PHP, nor does it return false with
        //             note: a seriously malformed URL.
        //             note: Besides function name, is essentially the same as parseUri as well as our allowing
        //             note: an extra slash after the scheme/protocol (to allow file:/// as in PHP)
        //        example 1: parse_url('http://username:password@hostname/path?arg=value#anchor');
        //        returns 1: {scheme: 'http', host: 'hostname', user: 'username', pass: 'password', path: '/path', query: 'arg=value', fragment: 'anchor'}
        var query, key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port',
                'relative', 'path', 'directory', 'file', 'query', 'fragment'
            ],
            ini = (this.php_js && this.php_js.ini) || {},
            mode = (ini['phpjs.parse_url.mode'] &&
                ini['phpjs.parse_url.mode'].local_value) || 'php',
            parser = {
                php: /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // Added one optional slash to post-scheme to catch file:/// (should restrict this)
            };

        var m = parser[mode].exec(str),
            uri = {},
            i = 14;
        while (i--) {
            if (m[i]) {
                uri[key[i]] = m[i];
            }
        }

        if (component) {
            return uri[component.replace('PHP_URL_', '')
                .toLowerCase()];
        }
        if (mode !== 'php') {
            var name = (ini['phpjs.parse_url.queryKey'] &&
                ini['phpjs.parse_url.queryKey'].local_value) || 'queryKey';
            parser = /(?:^|&)([^&=]*)=?([^&]*)/g;
            uri[name] = {};
            query = uri[key[12]] || '';
            query.replace(parser, function ($0, $1, $2) {
                if ($1) {
                    uri[name][$1] = $2;
                }
            });
        }
        delete uri.source;
        return uri;
    };

    /***
     *
     * @deprecated
     */
    utils.getMimeTable = function () {
        return {};
    };

    /***
     * @deprecated
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getMimeTable2 = function () {
        return {
            "mid": "fa-file-audio-o",
            "txt": "fa-file-text-o",
            "sql": "fa-cube",
            "js": "fa-cube",
            "gif": "fa-file-picture-o",
            "jpg": "fa-file-picture-o",
            "html": "fa-cube",
            "htm": "fa-cube",
            "rar": "fa-file-zip-o",
            "gz": "fa-file-zip-o",
            "tgz": "fa-file-zip-o",
            "z": "fa-file-zip-o",
            "ra": "fa-file-movie-o",
            "ram": "fa-file-movie-o",
            "rm": "fa-file-movie-o",
            "pl": "source_pl.png",
            "zip": "fa-file-zip-o",
            "wav": "fa-file-audio-o",
            "php": "fa-cube",
            "php3": "fa-cube",
            "phtml": "fa-cube",
            "exe": "fa-file-o",
            "bmp": "fa-file-picture-o",
            "png": "fa-file-picture-o",
            "css": "fa-cube",
            "mp3": "fa-file-audio-o",
            "m4a": "fa-file-audio-o",
            "aac": "fa-file-audio-o",
            "xls": "fa-file-excel-o",
            "xlsx": "fa-file-excel-o",
            "ods": "fa-file-excel-o",
            "sxc": "fa-file-excel-o",
            "csv": "fa-file-excel-o",
            "tsv": "fa-file-excel-o",
            "doc": "fa-file-word-o",
            "docx": "fa-file-word-o",
            "odt": "fa-file-word-o",
            "swx": "fa-file-word-o",
            "rtf": "fa-file-word-o",
            "md": "fa-file-word-o",
            "ppt": "fa-file-powerpoint-o",
            "pps": "fa-file-powerpoint-o",
            "odp": "fa-file-powerpoint-o",
            "sxi": "fa-file-powerpoint-o",
            "pdf": "fa-file-pdf-o",
            "mov": "fa-file-movie-o",
            "avi": "fa-file-movie-o",
            "mpg": "fa-file-movie-o",
            "mpeg": "fa-file-movie-o",
            "mp4": "fa-file-movie-o",
            "m4v": "fa-file-movie-o",
            "ogv": "fa-file-movie-o",
            "webm": "fa-file-movie-o",
            "wmv": "fa-file-movie-o",
            "swf": "fa-file-movie-o",
            "flv": "fa-file-movie-o",
            "tiff": "fa-file-picture-o",
            "tif": "fa-file-picture-o",
            "svg": "fa-file-picture-o",
            "psd": "fa-file-picture-o",
            "ers": "horo.png"
        };
    };
    /***
     *
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     */
    utils.getIconTable = function () {
        return {};
    };


    /**
     *
     * @param string
     * @param overwrite
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     * @deprecated
     */
    utils.urlDecode = function (string, overwrite) {
        if (!string || !string.length) {
            return {}
        }
        var obj = {};
        var pairs = string.split("&");
        var pair, name, value;
        for (var i = 0, len = pairs.length; i < len; i++) {
            pair = pairs[i].split("=");
            name = decodeURIComponent(pair[0]);
            value = decodeURIComponent(pair[1]);
            if (value != null && value === 'true') {
                value = true;
            } else if (value === 'false') {
                value = false;
            }
            if (overwrite !== true) {
                if (typeof obj[name] == "undefined") {
                    obj[name] = value
                } else {
                    if (typeof obj[name] == "string") {
                        obj[name] = [obj[name]];
                        obj[name].push(value)
                    } else {
                        obj[name].push(value)
                    }
                }
            } else {
                obj[name] = value
            }
        }
        return obj;
    };
    /**
     *
     * @param string {string}
     * @returns {object}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getUrlArgs = function (string) {
        var args = {};
        if (string && (string.indexOf('?') != -1 || string.indexOf('&') != -1)) {

            var query = string.substr(string.indexOf("?") + 1) || location.search.substring(1);
            var pairs = query.split("&");
            for (var i = 0; i < pairs.length; i++) {
                var pos = pairs[i].indexOf("=");
                var name = pairs[i].substring(0, pos);
                var value = pairs[i].substring(pos + 1);
                value = decodeURIComponent(value);
                args[name] = value;
            }
        }
        return args;
    };

    /**
     *
     * @param url {string}
     * @returns {object}
     * @deprecated
     */
    utils.urlArgs = function (url) {
        var query = utils.getUrlArgs(url);
        var map = {};
        for (var param in query) {
            var value = query[param],
                options = utils.findOcurrences(value, {
                    begin: "|",
                    end: "|"
                }),
                parameterOptions = null;

            if (options && options.length) {
                //clean value:
                value = value.replace(options[0], '');
                //parse options
                var optionString = options[0].substr(1, options[0].length - 2),
                    optionSplit = optionString.split(','),
                    optionsData = {};

                for (var i = 0; i < optionSplit.length; i++) {

                    var keyValue = optionSplit[i],
                        pair = keyValue.split(':');

                    optionsData[pair[0]] = pair[1];
                }
                parameterOptions = optionsData;
            }

            if (value && value.length) {
                map[param] = {
                    value: value,
                    options: parameterOptions
                }
            }
        }
        return map;
    };

    /**
     *
     * @param fileName {string}
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIcon = function (fileName) {
        if (!fileName) {
            return 'txt2.png';
        }
        var extension = utils.getFileExtension(fileName);
        if (extension) {
            var mime = utils.getMimeTable();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'txt2.png';
    };
    /**
     *
     * @param fileName
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIconClass = function (fileName) {
        if (!fileName) {
            return 'fa-file-o';
        }
        var extension = utils.getFileExtension(fileName);
        if (types.customMimeIcons[extension]) {
            return types.customMimeIcons[extension];
        }
        if (extension) {
            var mime = utils.getMimeTable2();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'fa-file-o';
    };
    /**
     * File extension
     * @deprecated
     * @param fileName {string}
     * @returns {string}
     */
    utils.getFileExtension = function (fileName) {
        if (!fileName || fileName == "") return "";
        var split = utils.getBaseName(fileName).split('.');
        if (split.length > 1) return split[split.length - 1].toLowerCase();
        return '';
    };
    /**
     * Create a basic UUID via with Math.Random
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.createUUID = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4()); //String
    };
    /**
     * Basename
     * @param fileName {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getBaseName = function (fileName) {
        if (fileName == null) return null;
        var separator = "/";
        if (fileName.indexOf("\\") !==-1)
            separator = "\\";
        return fileName.substr(fileName.lastIndexOf(separator) + 1, fileName.length);
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @example

     //   example 1: basename('/www/site/home.htm', '.htm')
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1')
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/')
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext')
     //   returns 4: 'path_ext'

     * @memberOf module:xide/utils/StringUtils
     */
    utils.basename = function basename(path, suffix) {
        //  discuss at: http://locutus.io/php/basename/
        // original by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Ash Searle (http://hexmen.com/blog/)
        // improved by: Lincoln Ramsay
        // improved by: djmix
        // improved by: Dmitry Gorelenkov
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1)
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) === suffix) {
            b = b.substr(0, b.length - suffix.length)
        }

        return b
    };
    /**
     *
     * @param path {string}
     * @param options
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     *
     * @example
     *
     //   example 1: pathinfo('/www/htdocs/index.html', 1)
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME')
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION')
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME')
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4)
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL')
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html')
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     */
    utils.pathinfo = function (path, options) {
        //  discuss at: http://locutus.io/php/pathinfo/
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //      note 1: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //      note 1: The way the bitwise arguments are handled allows for greater flexibility
        //      note 1: & compatability. We might even standardize this
        //      note 1: code and use a similar approach for
        //      note 1: other bitwise PHP functions
        //      note 1: Locutus tries very hard to stay away from a core.js
        //      note 1: file with global dependencies, because we like
        //      note 1: that you can just take a couple of functions and be on your way.
        //      note 1: But by way we implemented this function,
        //      note 1: if you want you can still declare the PATHINFO_*
        //      note 1: yourself, and then you can use:
        //      note 1: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //      note 1: which makes it fully compliant with PHP syntax.


        var basename = utils.basename;
        var opt = '';
        var realOpt = '';
        var optName = '';
        var optTemp = 0;
        var tmpArr = {};
        var cnt = 0;
        var i = 0;
        var haveBasename = false;
        var haveExtension = false;
        var haveFilename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false
        }
        if (!options) {
            options = 'PATHINFO_ALL'
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName]
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]]
                }
            }
            options = optTemp
        }

        // Internal Functions
        var _getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : ''
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path
                .replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmpArr.dirname = dirName === path ? '.' : dirName
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            tmpArr.basename = haveBasename
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveExtension !== false) {
                tmpArr.extension = haveExtension
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveFilename === false) {
                haveFilename = haveBasename.slice(0, haveBasename.length - (haveExtension
                            ? haveExtension.length + 1
                            : haveExtension === false
                            ? 0
                            : 1
                    )
                )
            }

            tmpArr.filename = haveFilename
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmpArr) {
            if (tmpArr.hasOwnProperty(opt)) {
                cnt++;
                realOpt = opt
            }
        }
        if (cnt === 1) {
            return tmpArr[realOpt]
        }

        // Return full-blown array
        return tmpArr
    };

    /**
     *
     * @param input {string}
     * @param allowed {string}
     * @example
     //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>');
     //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
     //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>');
     //   returns 2: '<p>Kevin van Zonneveld</p>'
     //   example 3: strip_tags("<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>", "<a>");
     //   returns 3: "<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>"
     //   example 4: strip_tags('1 < 5 5 > 1');
     //   returns 4: '1 < 5 5 > 1'
     //   example 5: strip_tags('1 <br/> 1');
     //   returns 5: '1  1'
     //   example 6: strip_tags('1 <br/> 1', '<br>');
     //   returns 6: '1 <br/> 1'
     //   example 7: strip_tags('1 <br/> 1', '<br><br/>');
     //   returns 7: '1 <br/> 1'
     * @returns {string}
     */
    utils.strip_tags = function (input, allowed) {
        //  discuss at: http://phpjs.org/functions/strip_tags/
        allowed = (((allowed || '') + '')
            .toLowerCase()
            .match(/<[a-z][a-z0-9]*>/g) || [])
            .join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,
            commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
        return input.replace(commentsAndPhpTags, '')
            .replace(tags, function ($0, $1) {
                return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
            });
    };
    return utils;
});

},
'dojo/ready':function(){
define(["./_base/kernel", "./has", "require", "./domReady", "./_base/lang"], function(dojo, has, require, domReady, lang){
	// module:
	//		dojo/ready
	// note:
	//		This module should be unnecessary in dojo 2.0

	var
		// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
		isDomReady = 0,

		// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
		loadQ = [],

		// prevent recursion in onLoad
		onLoadRecursiveGuard = 0,

		handleDomReady = function(){
			isDomReady = 1;
			dojo._postLoad = dojo.config.afterOnLoad = true;
			onEvent();
		},

		onEvent = function(){
			// Called when some state changes:
			//		- dom ready
			//		- dojo/domReady has finished processing everything in its queue
			//		- task added to loadQ
			//		- require() has finished loading all currently requested modules
			//
			// Run the functions queued with dojo.ready if appropriate.


			//guard against recursions into this function
			if(onLoadRecursiveGuard){
				return;
			}
			onLoadRecursiveGuard = 1;

			// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
			// pending tasks registered via domReady().
			// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
			// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
			// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
			while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
				var f = loadQ.shift();
				try{
					f();
				}catch(e){
					// force the dojo.js on("error") handler do display the message
					e.info = e.message;
					if(require.signal){
						require.signal("error", e);
					}else{
						throw e;
					}
				}
			}

			onLoadRecursiveGuard = 0;
		};

	// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
	// finishes processing it's queue.
	require.on && require.on("idle", onEvent);
	if(domReady){
		domReady._onQEmpty = onEvent;
	}

	var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
		// summary:
		//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
		//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
		//
		//		When called in a non-browser environment, just checks that all requested modules have arrived and been
		//		evaluated.
		// priority: Integer?
		//		The order in which to exec this callback relative to other callbacks, defaults to 1000
		// context: Object?|Function
		//		The context in which to run execute callback, or a callback if not using context
		// callback: Function?
		//		The function to execute.
		//
		// example:
		//	Simple DOM and Modules ready syntax
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(function(){ alert("Dom ready!"); });
		//	|	});
		//
		// example:
		//	Using a priority
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(2, function(){ alert("low priority ready!"); })
		//	|	});
		//
		// example:
		//	Using context
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(foo, function(){
		//	|			// in here, this == foo
		//	|		});
		//	|	});
		//
		// example:
		//	Using dojo/hitch style args:
		//	|	require(["dojo/ready"], function(ready){
		//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		//	|		ready(foo, "dojoReady");
		//	|	});

		var hitchArgs = lang._toArray(arguments);
		if(typeof priority != "number"){
			callback = context;
			context = priority;
			priority = 1000;
		}else{
			hitchArgs.shift();
		}
		callback = callback ?
			lang.hitch.apply(dojo, hitchArgs) :
			function(){
				context();
			};
		callback.priority = priority;
		for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
		loadQ.splice(i, 0, callback);
		onEvent();
	};

	 1 || has.add("dojo-config-addOnLoad", 1);
	if( 1 ){
		var dca = dojo.config.addOnLoad;
		if(dca){
			ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
		}
	}

	if( 0  && dojo.config.parseOnLoad && !dojo.isAsync){
		ready(99, function(){
			if(!dojo.parser){
				dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
				require(["dojo/parser"]);
			}
		});
	}

	if(domReady){
		domReady(handleDomReady);
	}else{
		handleDomReady();
	}

	return ready;
});

},
'dojo/mouse':function(){
define(["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
});

},
'xide/factory/Views':function(){
define([
    'xide/factory',
    'xide/utils',
    'xide/types'
], function (factory, utils, types, ContentPane) {
    /**
     * Default pane factory
     * @TODO: trash
     * @param title
     * @param iconClass
     * @param target
     * @param mixins
     * @param cssClass
     * @returns {xide/layout/ContentPane}
     */
    factory.createPane = function(title,iconClass,target,mixins,cssClass,baseClasses,classExtension){};

    /**
     * @TODO: trash
     * @param show
     * @returns {null}
     */
    factory.showStandBy = function (show) {
        var splash = document.getElementById('loadingWrapper');
        if (splash) {
            if (show) {
                splash.style.display = 'inline-block';
            } else {
                splash.style.display = 'none';
            }
        }
        return null;
    };
    /**
     * @TODO: trash
     * @param CIS
     * @param parent
     * @param showAllTab
     * @returns {TabContainer}
     */
    factory.createTabbedSettingsView = function (CIS, parent, showAllTab) {

        // tab container :
        var tabContainer = new xide.layout.TabContainer({
            tabStrip: true,
            tabPosition: "left-h",
            splitter: true,
            style: "min-width:450px;",
            "className": "ui-widget-content"
        });

        parent.domNode.appendChild(tabContainer.domNode);
        tabContainer.startup();


        var widgetTabMap = {};
        var widgetGroups = [];
        if (showAllTab) {
            var dstTabContainerAll = widgetTabMap[types.WidgetGroup.All];
            if (dstTabContainerAll == null) {
                dstTabContainerAll = new ContentPane({
                    title: "All",
                    style: "padding:5px;",
                    closeable: false
                });
                widgetTabMap[types.WidgetGroup.All] = dstTabContainerAll;
                dstTabContainerAll.startup();
                tabContainer.addChild(dstTabContainerAll);
            }
        }


        var widgetGroup = null;
        for (var i = 0; i < CIS.length; i++) {
            var ci = CIS[i];

            var groupTitle = utils.toString(ci['group']) || null;
            if (groupTitle === '-1') {
                groupTitle = null;
            }

            if (groupTitle == null) {
                widgetGroup = utils.getWidgetGroup(ci);
                if (widgetGroup == types.WidgetGroup.Hidden)
                    continue;

                groupTitle = utils.getWidgetGroupTitle(widgetGroup);
            } else {
                widgetGroup = groupTitle;
            }
            var dstTabContainer = widgetTabMap[widgetGroup];
            if (dstTabContainer == null ) {
                widgetGroups.push(widgetGroup);
                dstTabContainer = new ContentPane({
                    title: groupTitle,
                    preload: false,
                    closeable: false,
                    adjustChildsToWidth: true
                });
                widgetTabMap[widgetGroup] = dstTabContainer;
            }
        }

        // sort by widget group
        widgetGroups.sort(function (a, b) {
            return a - b;
        });

        //attach widget containers
        for (var wgi = 0; wgi < widgetGroups.length; wgi++) {

            widgetGroup = widgetGroups[wgi];
            var container = widgetTabMap[widgetGroup];
            if(container) {
                container.startup();
                tabContainer.addChild(container);
            }
        }
        tabContainer["widgetTabMap"] = widgetTabMap;
        return tabContainer;
    };
});

},
'xaction/ActionContext':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    'xide/types',
    'dojo/aspect',
    'xide/views/History'
], function (dcl, declare, types, aspect, History) {
    var _debug = false;
    /**
     * Mixin to handle different action contexts.
     *
     * @mixin module:xaction/ActionContext
     */
    var Implementation = {
        currentActionEmitter: null,
        _history: null,
        isEmpty: function () {
            var _emitter = this.getCurrentEmitter();
            if (_emitter) {
                return _emitter.getActionStore().getAll().length == 0;
            }
            return true;
        },
        getCurrentEmitter: function () {
            return this.currentActionEmitter;
        },
        _onRemoveEmitter: function (emitter) {
            this._history.remove(emitter);
            var _next = this._history.getNow();
            var cEmitter = this.currentActionEmitter;
            if (cEmitter == emitter) {
                this.currentActionEmitter = null;
            }
            var _last = _next;
            if (_last) {
                this.setActionEmitter(_last);
            }
        },
        refreshActions: function (actions) {
            var _self = this;
            _.each(actions, function (action) {
                if (_self.renderAction) {
                    _self.renderAction(action, null, null, null, null);
                } else {
                    console.error('renderAction not implemented for refresh actions ' + _self.declaredClass);
                }
            });
        },
        setActionEmitter: function (emitter, what, event) {
            if (emitter && emitter.getActionStore && !emitter.getActionStore()) {
                _debug && console.warn('setActionEmitter: emitter returns null action store! abort ' + emitter.declaredClass, emitter);
                return;
            }
            if (this.currentActionEmitter == emitter) {
                if (!emitter) {
                    this.setActionStore(null);
                }
                return;
            }
            _debug && console.log('setActionEmitter ' + this.id + ' ' + this.declaredClass + ' for : ' + what + ' emitter : ' + emitter.id);
            try {
                var cEmitter = this.currentActionEmitter;
                if (cEmitter) {
                    if (cEmitter.getActionStore) {
                        var store = cEmitter.getActionStore();
                        if (store) {
                            store._all = null;
                        } else {
                            _debug && console.warn('setActionEmitter no store');
                        }
                        this.clearActions();
                    } else {
                        _debug && console.warn('setActionEmitter current emitter has no getActionStore', cEmitter);
                    }
                    cEmitter && cEmitter.onDeactivateActionContext && cEmitter.onDeactivateActionContext(this, event);
                }
            } catch (e) {
                logError(e, 'setActionEmitter crash');
            }
            if (emitter && !emitter.getActionStore) {
                _debug && console.error('not an action emitter ' + emitter.declaredClass);
                return;
            }
            this.currentActionEmitter = emitter;
            if (!emitter) {
                this.setActionStore(null);
                return;
            }
            var newEmitterStore = emitter.getActionStore();
            if (!newEmitterStore) {
                _debug && console.error('new emitter has no action store ! ' + emitter.declaredClass);
                return;
            }

            newEmitterStore.__all = null;
            emitter && emitter.onUseActionStore && emitter.onUseActionStore(newEmitterStore, emitter);
            this.setActionStore(newEmitterStore, emitter);
            newEmitterStore.addRenderer(this);
            emitter && emitter.onActivateActionContext && emitter.onActivateActionContext(this, event);
            this._emit('setActionEmitter', {
                emitter: emitter
            });
            !this._history && (this._history = new History());
            this._history.setNow(emitter);
        },
        _registerActionEmitter: function (emitter) {

            if(this[this.id +'_emitter_'+emitter.id]){
                return;
            }

            this[this.id +'_emitter_'+emitter.id]=true;

            if (emitter && !emitter.getActionStore) {
                _debug && console.error('_registerActionEmitter: is not an action provider');
                return;
            }
            if (!emitter || !emitter.on) {
                _debug && console.warn('register action emitter : emitter = null');
                return false;
            }
            var thiz = this,
                handler = function (what, e) {
                    thiz.setActionEmitter(emitter, what, e);
                },
                _handle = emitter._on('selectionChanged', function (e) {
                    e[thiz.id + '_aceDid'] = true;
                    var type = e.why == 'clear' ? 'selectionCleared' : 'selectionChanged';
                    handler(type, e);
                });



            emitter.on('click', function (e) {
                if(e.__did){
                    return;
                }
                e.__did = true;
                var doHandler = true;
                if (emitter.handleActionClick) {
                    doHandler = emitter.handleActionClick(e);
                }
                doHandler && handler('click', e);
            });
            !this._history && (this._history = new History());
            emitter._on(types.EVENTS.ON_VIEW_SHOW, function (view) {
                if (thiz._history.indexOf(view)) {
                    view.view && (view = view.view);
                    thiz.setActionEmitter(view, types.EVENTS.ON_VIEW_SHOW, view);
                }
            });
        },
        destroy: function () {
            this.inherited && this.inherited(arguments);
            this._history && this._history.destroy() && delete this._history;
        },
        addActionEmitter: function (emitter) {
            if (!emitter) {
                _debug && console.warn('addActionEmitter::emitter is null');
                return;
            }
            var thiz = this;
            !this._history && (this._history = new History());
            if (!emitter.getActionStore) {
                _debug && console.error('invalid emitter ', emitter);
                return;
            }

            this._history.push(emitter);
            thiz._registerActionEmitter(emitter);
            function remove(emitter) {
                thiz._onRemoveEmitter(emitter);
            }

            aspect.after(emitter, 'destroy', function () {
                remove(emitter);
            }, true);

            emitter._on('destroy', function () {
                try {
                    remove(emitter);
                } catch (e) {
                    logError(e, 'addActionEmitter');
                }
            }, true);
        }
    };
    //package via declare
    var Module = declare('xaction/ActionContext', null, Implementation);
    //package via dcl
    Module.dcl = dcl(null, Implementation);
    return Module;
});
},
'dgrid/extensions/_DnD-touch-autoscroll':function(){
define([
	'dojo/aspect',
	'dojo/dom-geometry',
	'dojo/dnd/autoscroll',
	'../List'
], function (aspect, domGeometry, autoscroll, List) {
	// summary:
	//		This module patches the autoScrollNodes function from the
	//		dojo/dnd/autoscroll module, in order to behave properly for
	//		dgrid TouchScroll components.

	var original = autoscroll.autoScrollNodes,
		instances, findEnclosing;

	// In order to properly detect autoscroll cases for dgrid+TouchScroll
	// instances, we need to register instances so that we can look them up based
	// on child nodes later.

	instances = {};
	aspect.after(List.prototype, 'postCreate', function (r) {
		var id = this.id;
		// Since this code is only hooked in some cases, don't throw an error here,
		// but do warn since duplicate IDs or improper destruction are likely going
		// to lead to unintended consequences.
		if (instances[id]) {
			console.warn('dgrid instance registered with duplicate id "' + id + '"');
		}
		instances[id] = this;
		return r;
	});
	aspect.after(List.prototype, 'destroy', function (r) {
		delete instances[this.id];
		return r;
	});
	findEnclosing = function (node) {
		var id, instance;
		while (node) {
			if ((id = node.id) && (instance = instances[id])) {
				return instance;
			}
			node = node.parentNode;
		}
	};

	autoscroll.autoScrollNodes = function (evt) {
		var node = evt.target,
			list = findEnclosing(node),
			pos, nodeX, nodeY, thresholdX, thresholdY, dx, dy, oldScroll, newScroll;

		if (list) {
			// We're inside a dgrid component with TouchScroll; handle using the
			// getScrollPosition and scrollTo APIs instead of scrollTop/Left.
			// All logic here is designed to be functionally equivalent to the
			// existing logic in the original dojo/dnd/autoscroll function.

			node = list.touchNode.parentNode;
			pos = domGeometry.position(node, true);
			nodeX = evt.pageX - pos.x;
			nodeY = evt.pageY - pos.y;
			// Use standard threshold, unless element is too small to warrant it.
			thresholdX = Math.min(autoscroll.H_TRIGGER_AUTOSCROLL, pos.w / 2);
			thresholdY = Math.min(autoscroll.V_TRIGGER_AUTOSCROLL, pos.h / 2);

			// Check whether event occurred beyond threshold in any given direction.
			// If so, we will scroll by an amount equal to the calculated threshold.
			if (nodeX < thresholdX) {
				dx = -thresholdX;
			}
			else if (nodeX > pos.w - thresholdX) {
				dx = thresholdX;
			}

			if (nodeY < thresholdY) {
				dy = -thresholdY;
			}
			else if (nodeY > pos.h - thresholdY) {
				dy = thresholdY;
			}

			// Perform any warranted scrolling.
			if (dx || dy) {
				oldScroll = list.getScrollPosition();
				newScroll = {};
				if (dx) {
					newScroll.x = oldScroll.x + dx;
				}
				if (dy) {
					newScroll.y = oldScroll.y + dy;
				}

				list.scrollTo(newScroll);
				return;
			}
		}
		// If we're not inside a dgrid component with TouchScroll, fall back to
		// the original logic to handle scroll on other elements and the document.
		original.call(this, evt);
	};

	return autoscroll;
});

},
'xide/serverDebug':function(){
define([
    'xdojo/declare',
    'xdojo/has'
],function(declare,has){

    var Module = declare("xide.serverDebug", null,{

    });

    /**
     * @var object
     */
    var local_storage = null;
    var color1 = '#888';
    var color2 = '#0563ad';

    var ALLOWED_TYPES = {
        'group': 1,
        'groupEnd': 1,
        'groupCollapsed': 1,
        'warn': 1,
        'error': 1,
        'info': 1,
        'table': 1,
        'log': 1
    };

    /**
     * @var array
     */
    var queue = [];

    /**
     * @var bool
     */
    var use_queue = true;

    /**
     * should we show line numbers?
     *
     * @return bool
     */
    function _showLineNumbers()
    {
        return true;
    }

    /**
     * logs nicely formatted data in new format
     *
     * @param Object
     * @return void
     */
    function _logData(data, callback)
    {

        //console.log('server log : ',data);

        var column_map = {};
        var column_name;

        for (var key in data.columns) {
            column_name = data.columns[key];
            column_map[column_name] = key;
        }

        var rows = data.rows,
            i = 0,
            length = rows.length;

        for (i = 0; i < length; i++) {
            var row = rows[i],
                backtrace = row[column_map.backtrace],
                label = row[column_map.label],
                log = row[column_map.log],
                type = row[column_map.type] || 'log';

            if (_showLineNumbers() && backtrace !== null) {
                console.log('%c' + backtrace, 'color: ' + color1 + '; font-weight: bold;');
            }

            // new version without label
            var new_version = false;
            if (data.columns.indexOf('label') === -1) {
                new_version = true;
            }

            // if this is the old version do some converting
            if (!new_version) {
                var show_label = label && typeof label === "string";

                log = [log];

                if (show_label) {
                    log.unshift(label);
                }
            }

            var logs = [];
            var current_log;
            var last_log;
            var new_string;

            // loop through logs to add in any class name labels that should be here
            for (var j = 0; j < log.length; j++) {
                current_log = log[j];
                last_log = logs[logs.length - 1];

                if (current_log && typeof current_log === 'object' && current_log['___class_name']) {
                    new_string = '%c' + current_log['___class_name'];

                    if (typeof last_log === 'string') {

                        // if the last log was a string we need to append to it
                        // in order for the coloring to work correctly
                        logs[logs.length - 1] = last_log + ' ' + new_string;
                    }
                    else {

                        // otherwise just push the new string to the end of the list
                        logs.push(new_string);
                    }

                    logs.push('color: ' + color2 + '; font-weight: bold;');
                    delete log[j]['___class_name'];
                }

                logs.push(current_log);
            }

            if (!(type in ALLOWED_TYPES)) {
                type = 'log';
            }

            console[type].apply(console, logs);
        }

        if (typeof callback === 'function') {
            callback();
        }
    }
    function _decode(header) {
        return JSON.parse(atob(header));
    }

    Module.logError = function(data){
        _logData(_decode(data));
    }

    return Module;
});
},
'xfile/views/FileSize':function(){
/** @module xgrid/Base **/
define([
    "dcl/dcl",
    "xide/_base/_Widget"

], function (dcl, _XWidget) {
    var Module = dcl(_XWidget,{
        _find:function(path,nodes){
            var res = _.find(nodes,{
                    path:path
                }),
                self = this;
            if(res && res.children && res.children){
                var _child = self._find(path,res.children);
                if(_child){
                    res = _child;
                }
            }
            if(!res){
                _.each(nodes,function(node){
                    var _inner = null;
                    if(node.children && node.children.length){
                        _inner = self._find(path,node.children);
                        if(_inner){
                            res=_inner;
                        }
                    }
                });
            }
            return res;
        },
        select:function(path){
            var d = this._find(path,this.d3Nodes);
            if(d) {
                this.highlight(d);
            }

        },
        direction:'left',
        templateString:'<div class="sizeDisplay tabbable tabs-${!direction}" attachTo="containerNode" style="width: inherit;height: 100%;padding: 4px">' +

        '<ul class="nav nav-tabs tabs-right" role="tablist">'+


        '<li class="active">'+
        '<a href="#_tab-content2_${!id}" data-toggle="tab">Overall</a>'+
        '</li>'+

        '<li>'+
        '<a href="#_tab-content1_${!id}" data-toggle="tab">By Type</a>'+
        '</li>'+



        '</ul>'+
        '<div class="body tab-content">'+

        '<div attachTo="tab2" id="_tab-content2_${!id}" class="tab-pane active clearfix">'+

        '<div class="chart1" attachTo="chart1" style="width: 100%;height: inherit;min-height:250px">'+
        '<div class="" style="" id="detailInfo"></div>'+
        '<div class="widget" id="explanation" >'+
        '<span id="percentage"></span><br/>'+
        '<span id="percentageDetail"></span>'+
        '</div>'+
        '</div>'+

        '</div>'+

        '<div attachTo="tab1" id="_tab-content1_${!id}" class="tab-pane">'+

        '<svg class="chart2" style="width: 100%;height: inherit;min-height:250px">'+

        '</svg>'+
        '<div id="tooltip" class="hidden">'+
        '<span id="chart2Per1">A</span> <br>'+
        '<span id="chart2Per2">100</span>'+
        '</div>'+

        '</div>'+


        '</div>'+

        '</div>',
        data:null,
        owner:self,
        vis:null,
        d3Nodes:null,
        colors : {
            "dir": "#5687d1",
            /*pictures same color*/
            "jpeg":"#9b59b6",
            "jpg":"#9b59b6",
            "png":"#9b59b6",
            "gif":"#9b59b6",
            "psd":"#9b59b6",
            /*audios same color*/
            "mp3":"#3498db",
            "wav":"#3498db",
            "wma":"#3498db",
            /*videos same color*/
            "wmv":"#2ecc71",
            "3gp":"#2ecc71",
            "mp4":"#2ecc71",
            "plv":"#2ecc71",
            "mpg":"#2ecc71",
            "mpeg":"#2ecc71",
            "mkv":"#2ecc71",
            "rm":"#2ecc71",
            "rmvb":"#2ecc71",
            "mov":"#2ecc71",
            /*office products same color*/
            "doc":"#1abc9c",
            "xls":"#1abc9c",
            "ppt":"#1abc9c",
            "docx":"#1abc9c",
            "xlsx":"#1abc9c",
            "pptx":"#1abc9c",
            /*mac products same color*/
            "pages":"#e74c3c",
            "key":"#e74c3c",
            "numbers":"#e74c3c",

            "pdf": "#7b615c",
            "epub": "#7b615c",
            /*programming langs*/
            "c":"#f1c40f",
            "cpp":"#f1c40f",
            "h":"#f1c40f",
            "html":"#f1c40f",
            "js":"#f1c40f",
            "css":"#f1c40f",
            "pl":"#f1c40f",
            "py":"#f1c40f",
            "php":"#f1c40f",
            "sql":"#f1c40f",
            "csv":"#de783b",
            "odp":"#de783b",
            /*zip files*/
            "gz":"#6ab975",
            "tar":"#6ab975",
            "rar":"#6ab975",
            "zip":"#6ab975",
            "7z":"#6ab975",
            "default": "#34495e"
        },
        totalSize : 0,
        result:{},
        overallSize:0,
        buildHierarchy:function(csv) {
            var root = {"name": "root", "children": []};
            for (var i = 0; i < csv.length; i++) {
                var sequence = csv[i][0];

                var size = +csv[i][1];
                if (isNaN(size)) { // e.g. if this is a header row
                    continue;
                }
                var parts = sequence.split("/");
                var currentNode = root;
                for (var j = 0; j < parts.length; j++) {
                    var children = currentNode["children"];
                    var nodeName = parts[j];
                    var childNode;
                    if (j + 1 < parts.length) {
                        // Not yet at the end of the sequence; move down the tree.
                        var foundChild = false;
                        for (var k = 0; k < children.length; k++) {
                            if (children[k]["name"] == nodeName) {
                                childNode = children[k];
                                foundChild = true;
                                break;
                            }
                        }
                        // If we don't already have a child node for this branch, create it.
                        if (!foundChild) {
                            childNode = {"name": nodeName, "type": "dir", "children": [],"path":sequence};
                            children.push(childNode);
                        }
                        currentNode = childNode;
                    } else {
                        var filetype = nodeName.split('.').pop();
                        if (filetype.length < 7) {
                            if (filetype in this.result) {
                                this.result[filetype] += size;
                            }
                            else {
                                this.result[filetype] = size;
                            }
                        }
                        childNode = {"name": nodeName, "type": filetype, "size": size,"path":sequence};
                        this.overallSize += size;
                        children.push(childNode);
                    }
                }
            }
            return root;
        },
        bytesToSize:function(bytes) {
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            if (bytes == 0) return 'n/a';
            var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            if (i == 0) return bytes + ' ' + sizes[i];
            return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i];
        },
        getAncestors:function(node) {
            var path = [];
            var current = node;
            while (current.parent) {
                path.unshift(current);
                current = current.parent;
            }
            return path;
        },
        highlight:function(d){
            if(d){
                var percentage = (100 * d.value / this.totalSize).toPrecision(3);
                var percentageString = percentage + "%";
                if (percentage < 0.1) {
                    percentageString = "< 0.1%";
                }
                var percentageDetail = this.bytesToSize(d.value) + '/' + this.bytesToSize(this.totalSize);
                var colors = this.colors;
                d3.select("#percentage")
                    .text(percentageString);
                d3.select("#percentageDetail")
                    .text(percentageDetail);
                d3.select("#explanation")
                    .style("visibility", "");
                var sequenceArray = this.getAncestors(d);
                var arrayLength = sequenceArray.length;
                var htmlString = '';
                for (var i = 0; i < arrayLength; i++) {
                    var nodeType = sequenceArray[i].type;
                    if (nodeType == 'dir'){
                        htmlString+='<span style="color:'+colors[nodeType]+'">' + sequenceArray[i].name +'/</span>';
                    }
                    else {
                        htmlString+='<span style="color:'+colors[nodeType]+'">' + sequenceArray[i].name +'</span>';
                    }
                }
                $("#detailInfo").html(htmlString);
                // Fade all the segments.
                d3.selectAll("path").style("opacity", 0.3);
                // Then highlight only those that are an ancestor of the current segment.
                var foundNode = this.vis.selectAll("path")
                    .filter(function(node) {
                        return (sequenceArray.indexOf(node) >= 0);
                    })
                    .style("opacity", 1);
            }else{
                console.error('cant find '+path);
            }
        },
        createChart1:function(json,vis,width,height,radius) {
            vis.append("svg:circle")
                .attr("r", radius)
                .style("opacity", 0);

            var colors = this.colors,
                self = this;
            var partition = d3.layout.partition(radius)
                .size([2 * Math.PI, radius * radius])
                .value(function(d) { return d.size; });
            function mouseleave(d) {

                //return;

                // Hide the breadcrumb trail
                d3.select("#trail")
                    .style("visibility", "hidden");

                // Deactivate all segments during transition.
                d3.selectAll("path").on("mouseover", null);

                // Transition each segment to full opacity and then reactivate it.
                d3.selectAll("path")
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .each("end", function() {
                        d3.select(this).on("mouseover", mouseover);
                    });

                d3.select("#explanation")
                    .transition()
                    .duration(1000)
                    .style("visibility", "hidden");

                $("#detailInfo").html("");

            }
            function mouseover(d) {
                var percentage = (100 * d.value / self.totalSize).toPrecision(3);
                var percentageString = percentage + "%";
                if (percentage < 0.1) {
                    percentageString = "< 0.1%";
                }
                var percentageDetail = self.bytesToSize(d.value) + '/' + self.bytesToSize(self.totalSize);

                d3.select("#percentage")
                    .text(percentageString);
                d3.select("#percentageDetail")
                    .text(percentageDetail);

                d3.select("#explanation")
                    .style("visibility", "");
                var sequenceArray = self.getAncestors(d);
                var arrayLength = sequenceArray.length;
                var htmlString = '';
                for (var i = 0; i < arrayLength; i++) {
                    var nodeType = sequenceArray[i].type;
                    if (nodeType == 'dir'){
                        htmlString+='<span style="color:'+colors[nodeType]+'">' + sequenceArray[i].name +'/</span>';
                    }
                    else {
                        htmlString+='<span style="color:'+colors[nodeType]+'">' + sequenceArray[i].name +'</span>';
                    }
                }
                $("#detailInfo").html(htmlString);

                // Fade all the segments.
                d3.selectAll("path")
                    .style("opacity", 0.3);

                // Then highlight only those that are an ancestor of the current segment.
                vis.selectAll("path")
                    .filter(function(node) {
                        return (sequenceArray.indexOf(node) >= 0);
                    })
                    .style("opacity", 1);
            }

            // For efficiency, filter nodes to keep only those large enough to see.
            var nodes = partition.nodes(json,radius)
                .filter(function(d) {
                    return (d.dx > 0.005); // 0.005 radians = 0.29 degrees
                });

            var arc = d3.svg.arc()
                .startAngle(function(d) { return d.x; })
                .endAngle(function(d) { return d.x + d.dx; })
                .innerRadius(function(d) { return Math.sqrt(d.y); })
                .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });

            var path = vis.data([json]).selectAll("path")
                .data(nodes)
                .enter().append("svg:path")
                .attr("display", function(d) { return d.depth ? null : "none"; })
                .attr("d", arc)
                .attr("fill-rule", "evenodd")
                .style("fill", function(d) { return colors[d.type]?colors[d.type]:colors["default"]; })
                .style("opacity", 1)
                .on("mouseover", mouseover);

            // Add the mouseleave handler to the bounding circle.
            d3.select("#container").on("mouseleave", mouseleave);

            // Get total size of the tree = value of root node from partition.
            this.totalSize = path.node().__data__.value;

            return nodes;
        },
        render:function(data){
            var node = $(this.tab2);
            var width = node.height() -50;
            var height = node.height() -50;
            if(width < 400){
                width = 400;
            }
            if(height < 300){
                height = 300;
            }
            var radius = height;
            var visParent = this.chart1;
            var vis = d3.select(visParent).append("svg:svg")
                .attr("width", width)
                .attr("height", height)
                .append("svg:g")
                .attr("id", "container")
                .attr("transform", "translate(" + height/2 + "," + height/2  + ")");

            var nodes = this.createChart1(data,vis,width,height,radius/4,vis);
            var filetypeJSON = [];
            for (var x in this.result) {
                var tempF = this.result[x] / this.overallSize;
                if (tempF < 0.001) {
                    //console.error('skip');
                    continue;
                }
                var tempN = this.bytesToSize(this.result[x]) + '/' + this.bytesToSize(this.overallSize);
                var temp = {filetype: x, "usage": tempF, "detail": tempN};
                filetypeJSON.push(temp);
            }

            this.vis = vis;
            this.d3Nodes = nodes;

            var node2 = $(this.tab1);
            width = node2.width();
            if(width < 400){
                width = 400;
            }
            this.createChart2(filetypeJSON,width,height-100);

        },
        createChart2:function(inputJson,width,height) {
            var margin = {top: 20, right: 30, bottom: 30, left: 40};

            var x = d3.scale.ordinal()
                .rangeRoundBands([0, width], .1);

            var y = d3.scale.linear()
                .range([height, 0]);

            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");


            var node = this.tab1.children[0],
                colors = this.colors;

            var chart = d3.select(node)
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var data = inputJson;

            x.domain(inputJson.map(function(d) {return d.filetype; }));

            y.domain([0, d3.max(inputJson, function(d) { return d.usage; })]);

            chart.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            chart.append("g")
                .attr("class", "y axis")
                .call(yAxis);

            chart.selectAll(".bar")
                .data(inputJson)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("id", function(d) { return 'bar'+d.filetype;})
                .attr("x", function(d) { return x(d.filetype); })
                .attr("y", function(d) { return y(d.usage); })
                .attr("height", function(d) { return height - y(d.usage); })
                .attr("width", x.rangeBand())
                .attr("fill", function(d) { return colors[d.filetype]?colors[d.filetype]:colors["default"]; })
                .on("mouseover", function(d) {
                    d3.select(this)
                        .transition()
                        .duration(50)
                        .attr("fill", "#7f8c8d");

                    //Get this bar's x/y values, then augment for the tooltip
                    var xPosition = parseFloat(d3.select(this).attr("x")) + x.rangeBand() / 2;
                    var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + height / 2;

                    var usageString = parseFloat(d.usage * 100).toFixed(2) + '%('+ d.filetype +')';
                    //Update the tooltip position and value
                    d3.select("#tooltip")
                        .style("left", xPosition + "px")
                        .style("top", yPosition + "px")
                        .select("#chart2Per2")
                        .text(d.detail);

                    d3.select("#chart2Per1")
                        .text(usageString);

                    //Show the tooltip
                    d3.select("#tooltip").classed("hidden", false);
                })

                .on("mouseout", function() {
                    d3.select(this)
                        .transition()
                        .delay(100)
                        .duration(250)
                        .attr("fill", function(d) { return colors[d.filetype]?colors[d.filetype]:colors["default"]; })

                    //Hide the tooltip
                    d3.select("#tooltip").classed("hidden", true);

                });
        },
        startup:function(){
            if(!this.owner){
                return;
            }
            var owner = this.owner,
                rows = owner.getRows();
            var csv = [];
            _.each(rows,function(row){
                csv.push([row.path.replace('./',''),"" + row.sizeBytes]);
            });
            var json = this.buildHierarchy(csv);
            this.render(json);
            var self = this;
            owner._on('selectionChanged',function(evt){
                if(evt.why=='clear'){
                    return;
                }
                var selection = evt.selection;
                var first = selection ? selection[0] : null;
                var row = owner.row(first);
                var element = row ? row.element : null;
                if(!first || !element){
                    return;
                }
                var path = first.path.replace('./','');
                if(!self.d3Nodes){
                    return;
                }
                self.select(path);
            })
        }
    });
    return Module;
});
},
'dojo/aspect':function(){
define([], function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
						args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
						if(after.receiveArguments){
							var newResults = after.advice.apply(this, args);
							// change the return value only if a new value was returned
							results = newResults === undefined ? results : newResults;
						}else{
							results = after.advice.call(this, results, args);
						}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
});

},
'dojo/_base/sniff':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(! 1 ){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
});

},
'xbox/run':function(){
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
/**
 * This file is used to reconfigure parts of the loader at runtime for this application. Weve put this extra
 * configuration in a separate file, instead of adding it directly to index.html, because it contains options that
 * can be shared if the application is run on both the client and the server.
 *
 * If you arent planning on running your app on both the client and the server, you could easily move this
 * configuration into index.html (as a dojoConfig object) if it makes your life easier.
 */
require({
    // The base path for all packages and modules. If you don't provide this, baseUrl defaults to the directory
    // that contains dojo.js. Since all packages are in the root, we just leave it blank. (If you change this, you
    // will also need to update app.profile.js).

    // A list of packages to register. Strictly speaking, you do not need to register any packages,
    // but you can't require "xbox" and get xbox/main.js if you do not register the "xbox" package (the loader will look
    // for a module at <baseUrl>/xbox.js instead). Unregistered packages also cannot use the packageMap feature, which
    // might be important to you if you need to relocate dependencies. TL;DR, register all your packages all the time:
    // it will make your life easier.
    packages: [
        // If you are registering a package that has an identical name and location, you can just pass a string
        // instead, and it will configure it using that string for both the "name" and "location" properties. Handy!
        'dojo',
        'dijit',
        'dojox',
        {
            name: 'xapp',
            location: 'xapp',
            packageMap: {}
        },
        {

            name: 'xas',
            location: 'xas',
            packageMap: {}
        },
        {
            name: 'xbox',
            location: 'xbox',
            packageMap: {}
        },
        {
            name: 'cbtree',
            location: 'cbtree',
            packageMap: {}
        },
        {
            name: 'xappconnect',
            location: 'xappconnect',
            packageMap: {}
        },
        {
            name: 'xide',
            location: 'xide',
            packageMap: {}
        },
        {
            name: 'dgrid',
            location: 'dgrid',
            packageMap: {}
        },
        {
            name: 'put-selector',
            location: 'put-selector',
            packageMap: {}
        },
        {
            name: 'xstyle',
            location: 'xstyle',
            packageMap: {}
        },
        {
            name: 'xfile',
            location: 'xfile',
            packageMap: {}
        },
        {
            name: 'xlog',
            location: 'xlog',
            packageMap: {}
        },
        {
            name: 'dcl',
            location: 'dcl',
            packageMap: {}
        },
        {
            name: 'xideve',
            location: 'xideve',
            packageMap: {}
        },
        {
            name: 'wcDocker',
            location: 'wcDocker/Code',
            packageMap: {}
        },
        {
            name: 'xdocker',
            location: 'xdocker',
            packageMap: {}
        },

        {
            name: 'xace',
            location: 'xace',
            packageMap: {}
        },
	{
            name: 'xlang',
            location: 'xlang',
            packageMap: {}
        },
        {
            name: 'xdojo',
            location: 'xdojo/build',
            packageMap: {}
        },
        {
            name: 'xaction',
            location: 'xaction/src',
            packageMap: {}
        },
        {
            name: 'xconsole',
            location: 'xconsole',
            packageMap: {}
        },
        'xbox'
    ],
    cache: {}
// Require 'xbox'. This loads the main application file, xbox/main.js.
}, ['xbox']);

});

},
'xide/xide':function(){

},
'dgrid/OnDemandList':function(){
define([
	'./List',
	'./_StoreMixin',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/on',
	'dojo/when',
	'./util/misc'
], function (List, _StoreMixin, declare, lang, domConstruct, on, when, miscUtil) {

	return declare([ List, _StoreMixin ], {
		// summary:
		//		Extends List to include virtual scrolling functionality, querying a
		//		dojo/store instance for the appropriate range when the user scrolls.

		// minRowsPerPage: Integer
		//		The minimum number of rows to request at one time.
		minRowsPerPage: 2500,

		// maxRowsPerPage: Integer
		//		The maximum number of rows to request at one time.
		maxRowsPerPage: 250,

		// maxEmptySpace: Integer
		//		Defines the maximum size (in pixels) of unrendered space below the
		//		currently-rendered rows. Setting this to less than Infinity can be useful if you
		//		wish to limit the initial vertical scrolling of the grid so that the scrolling is
		// 		not excessively sensitive. With very large grids of data this may make scrolling
		//		easier to use, albiet it can limit the ability to instantly scroll to the end.
		maxEmptySpace: Infinity,

		// bufferRows: Integer
		//	  The number of rows to keep ready on each side of the viewport area so that the user can
		//	  perform local scrolling without seeing the grid being built. Increasing this number can
		//	  improve perceived performance when the data is being retrieved over a slow network.
		bufferRows: 10,

		// farOffRemoval: Integer
		//		Defines the minimum distance (in pixels) from the visible viewport area
		//		rows must be in order to be removed.  Setting to Infinity causes rows
		//		to never be removed.
		farOffRemoval: 2000,

		// queryRowsOverlap: Integer
		//		Indicates the number of rows to overlap queries. This helps keep
		//		continuous data when underlying data changes (and thus pages don't
		//		exactly align)
		queryRowsOverlap: 0,

		// pagingMethod: String
		//		Method (from dgrid/util/misc) to use to either throttle or debounce
		//		requests.  Default is "debounce" which will cause the grid to wait until
		//		the user pauses scrolling before firing any requests; can be set to
		//		"throttleDelayed" instead to progressively request as the user scrolls,
		//		which generally incurs more overhead but might appear more responsive.
		pagingMethod: 'debounce',

		// pagingDelay: Integer
		//		Indicates the delay (in milliseconds) imposed upon pagingMethod, to wait
		//		before paging in more data on scroll events. This can be increased to
		//		reduce client-side overhead or the number of requests sent to a server.
		pagingDelay: miscUtil.defaultDelay,

		// keepScrollPosition: Boolean
		//		When refreshing the list, controls whether the scroll position is
		//		preserved, or reset to the top.  This can also be overridden for
		//		specific calls to refresh.
		keepScrollPosition: false,

		// rowHeight: Number
		//		Average row height, computed in renderQuery during the rendering of
		//		the first range of data.
		rowHeight: 0,

		postCreate: function () {
			this.inherited(arguments);
			var self = this;
			// check visibility on scroll events
			on(this.bodyNode, 'scroll',
				miscUtil[this.pagingMethod](function (event) {
					self._processScroll(event);
				}, null, this.pagingDelay)
			);
		},

		destroy: function () {
			this.inherited(arguments);
			if (this._refreshTimeout) {
				clearTimeout(this._refreshTimeout);
			}
		},

		renderQuery: function (query, options) {
			// summary:
			//		Creates a preload node for rendering a query into, and executes the query
			//		for the first page of data. Subsequent data will be downloaded as it comes
			//		into view.
			// query: Function
			//		Function to be called when requesting new data.
			// options: Object?
			//		Optional object containing the following:
			//		* container: Container to build preload nodes within; defaults to this.contentNode

			var self = this,
				container = (options && options.container) || this.contentNode,
				preload = {
					query: query,
					count: 0
				},
				preloadNode,
				priorPreload = this.preload;

			// Initial query; set up top and bottom preload nodes
			var topPreload = {
				node: domConstruct.create('div', {
					className: 'dgrid-preload',
					style: { height: '0' }
				}, container),
				count: 0,
				query: query,
				next: preload
			};
			topPreload.node.rowIndex = 0;
			preload.node = preloadNode = domConstruct.create('div', {
				className: 'dgrid-preload'
			}, container);
			preload.previous = topPreload;

			// this preload node is used to represent the area of the grid that hasn't been
			// downloaded yet
			preloadNode.rowIndex = this.minRowsPerPage;

			if (priorPreload) {
				// the preload nodes (if there are multiple) are represented as a linked list, need to insert it
				if ((preload.next = priorPreload.next) &&
						// is this preload node below the prior preload node?
						preloadNode.offsetTop >= priorPreload.node.offsetTop) {
					// the prior preload is above/before in the linked list
					preload.previous = priorPreload;
				}
				else {
					// the prior preload is below/after in the linked list
					preload.next = priorPreload;
					preload.previous = priorPreload.previous;
				}
				// adjust the previous and next links so the linked list is proper
				preload.previous.next = preload;
				preload.next.previous = preload;
			}
			else {
				this.preload = preload;
			}

			var loadingNode = domConstruct.create('div', {
					className: 'dgrid-loading'
				}, preloadNode, 'before'),
				innerNode = domConstruct.create('div', {
					className: 'dgrid-below'
				}, loadingNode);
			innerNode.innerHTML = this.loadingMessage;

			// Establish query options, mixing in our own.
			options = lang.mixin({ start: 0, count: this.minRowsPerPage },
				'level' in query ? { queryLevel: query.level } : null);

			// Protect the query within a _trackError call, but return the resulting collection
			return this._trackError(function () {
				var results = query(options);

				// Render the result set
				return self.renderQueryResults(results, preloadNode, options).then(function (trs) {
					return results.totalLength.then(function (total) {
						var trCount = trs.length,
							parentNode = preloadNode.parentNode,
							noDataNode = self.noDataNode;

						if (self._rows) {
							self._rows.min = 0;
							self._rows.max = trCount === total ? Infinity : trCount - 1;
						}

						domConstruct.destroy(loadingNode);
						if (!('queryLevel' in options)) {
							self._total = total;
						}
						// now we need to adjust the height and total count based on the first result set
						if (total === 0 && parentNode) {
							if (noDataNode) {
								domConstruct.destroy(noDataNode);
								delete self.noDataNode;
							}
							self.noDataNode = noDataNode = domConstruct.create('div', {
								className: 'dgrid-no-data',
								innerHTML: self.noDataMessage
							});
							self._emit('noData');
							parentNode.insertBefore(noDataNode, self._getFirstRowSibling(parentNode));
						}
						var height = 0;
						for (var i = 0; i < trCount; i++) {
							height += self._calcRowHeight(trs[i]);
						}
						// only update rowHeight if we actually got results and are visible
						if (trCount && height) {
							self.rowHeight = height / trCount;
						}

						total -= trCount;
						preload.count = total;
						preloadNode.rowIndex = trCount;
						if (total) {
							preloadNode.style.height = Math.min(total * self.rowHeight, self.maxEmptySpace) + 'px';
						}
						else {
							preloadNode.style.display = 'none';
						}

						if (self._previousScrollPosition) {
							// Restore position after a refresh operation w/ keepScrollPosition
							self.scrollTo(self._previousScrollPosition);
							delete self._previousScrollPosition;
						}

						// Redo scroll processing in case the query didn't fill the screen,
						// or in case scroll position was restored
						return when(self._processScroll()).then(function () {
							return trs;
						});
					});
				}).otherwise(function (err) {
					// remove the loadingNode and re-throw
					domConstruct.destroy(loadingNode);
					throw err;
				});
			});
		},

		refresh: function (options) {
			// summary:
			//		Refreshes the contents of the grid.
			// options: Object?
			//		Optional object, supporting the following parameters:
			//		* keepScrollPosition: like the keepScrollPosition instance property;
			//			specifying it in the options here will override the instance
			//			property's value for this specific refresh call only.

			var self = this,
				keep = (options && options.keepScrollPosition);

			// Fall back to instance property if option is not defined
			if (typeof keep === 'undefined') {
				keep = this.keepScrollPosition;
			}

			// Store scroll position to be restored after new total is received
			if (keep) {
				this._previousScrollPosition = this.getScrollPosition();
			}

			this.inherited(arguments);
			if (this._renderedCollection) {
				// render the query

				// renderQuery calls _trackError internally
				return this.renderQuery(function (queryOptions) {
					return self._renderedCollection.fetchRange({
						start: queryOptions.start,
						end: queryOptions.start + queryOptions.count
					});
				}).then(function () {
					// Emit on a separate turn to enable event to be used consistently for
					// initial render, regardless of whether the backing store is async
					self._refreshTimeout = setTimeout(function () {
						on.emit(self.domNode, 'dgrid-refresh-complete', {
							bubbles: true,
							cancelable: false,
							grid: self
						});
						self._refreshTimeout = null;
					}, 0);
				});
			}
		},

		resize: function () {
			this.inherited(arguments);
			this._processScroll();
		},

		cleanup: function () {
			this.inherited(arguments);
			this.preload = null;
		},

		renderQueryResults: function (results) {
			var rows = this.inherited(arguments);
			var collection = this._renderedCollection;

			if (collection && collection.releaseRange) {
				rows.then(function (resolvedRows) {
					if (resolvedRows[0] && !resolvedRows[0].parentNode.tagName) {
						// Release this range, since it was never actually rendered;
						// need to wait until totalLength promise resolves, since
						// Trackable only adds the range then to begin with
						results.totalLength.then(function () {
							collection.releaseRange(resolvedRows[0].rowIndex,
								resolvedRows[resolvedRows.length - 1].rowIndex + 1);
						});
					}
				});
			}

			return rows;
		},

		_getFirstRowSibling: function (container) {
			// summary:
			//		Returns the DOM node that a new row should be inserted before
			//		when there are no other rows in the current result set.
			//		In the case of OnDemandList, this will always be the last child
			//		of the container (which will be a trailing preload node).
			return container.lastChild;
		},

		_calcRowHeight: function (rowElement) {
			// summary:
			//		Calculate the height of a row. This is a method so it can be overriden for
			//		plugins that add connected elements to a row, like the tree

			var sibling = rowElement.nextSibling;

			// If a next row exists, compare the top of this row with the
			// next one (in case "rows" are actually rendering side-by-side).
			// If no next row exists, this is either the last or only row,
			// in which case we count its own height.
			if (sibling && !/\bdgrid-preload\b/.test(sibling.className)) {
				return sibling.offsetTop - rowElement.offsetTop;
			}

			return rowElement.offsetHeight;
		},

		lastScrollTop: 0,
		_processScroll: function (evt) {
			// summary:
			//		Checks to make sure that everything in the viewable area has been
			//		downloaded, and triggering a request for the necessary data when needed.

			if (!this.rowHeight) {
				return;
			}

			var grid = this,
				scrollNode = grid.bodyNode,
				// grab current visible top from event if provided, otherwise from node
				visibleTop = (evt && evt.scrollTop) || this.getScrollPosition().y,
				visibleBottom = scrollNode.offsetHeight + visibleTop,
				priorPreload, preloadNode, preload = grid.preload,
				lastScrollTop = grid.lastScrollTop,
				requestBuffer = grid.bufferRows * grid.rowHeight,
				searchBuffer = requestBuffer - grid.rowHeight, // Avoid rounding causing multiple queries
				// References related to emitting dgrid-refresh-complete if applicable
				lastRows,
				preloadSearchNext = true;

			// XXX: I do not know why this happens.
			// munging the actual location of the viewport relative to the preload node by a few pixels in either
			// direction is necessary because at least WebKit on Windows seems to have an error that causes it to
			// not quite get the entire element being focused in the viewport during keyboard navigation,
			// which means it becomes impossible to load more data using keyboard navigation because there is
			// no more data to scroll to to trigger the fetch.
			// 1 is arbitrary and just gets it to work correctly with our current test cases; dont wanna go
			// crazy and set it to a big number without understanding more about what is going on.
			// wondering if it has to do with border-box or something, but changing the border widths does not
			// seem to make it break more or less, so I do not know
			var mungeAmount = 1;

			grid.lastScrollTop = visibleTop;

			function removeDistantNodes(preload, distanceOff, traversal, below) {
				// we check to see the the nodes are "far off"
				var farOffRemoval = grid.farOffRemoval,
					preloadNode = preload.node;
				// by checking to see if it is the farOffRemoval distance away
				if (distanceOff > 2 * farOffRemoval) {
					// there is a preloadNode that is far off;
					// remove rows until we get to in the current viewport
					var row;
					var nextRow = preloadNode[traversal];
					var reclaimedHeight = 0;
					var count = 0;
					var toDelete = [];
					var firstRowIndex = nextRow && nextRow.rowIndex;
					var lastRowIndex;

					while ((row = nextRow)) {
						var rowHeight = grid._calcRowHeight(row);
						if (reclaimedHeight + rowHeight + farOffRemoval > distanceOff ||
								(nextRow.className.indexOf('dgrid-row') < 0 &&
									nextRow.className.indexOf('dgrid-loading') < 0)) {
							// we have reclaimed enough rows or we have gone beyond grid rows
							break;
						}

						nextRow = row[traversal];
						reclaimedHeight += rowHeight;
						count += row.count || 1;
						// Just do cleanup here, as we will do a more efficient node destruction in a setTimeout below
						grid.removeRow(row, true);
						toDelete.push(row);

						if ('rowIndex' in row) {
							lastRowIndex = row.rowIndex;
						}
					}

					if (grid._renderedCollection.releaseRange &&
							typeof firstRowIndex === 'number' && typeof lastRowIndex === 'number') {
						// Note that currently child rows in Tree structures are never unrendered;
						// this logic will need to be revisited when that is addressed.

						// releaseRange is end-exclusive, and won't remove anything if start >= end.
						if (below) {
							grid._renderedCollection.releaseRange(lastRowIndex, firstRowIndex + 1);
						}
						else {
							grid._renderedCollection.releaseRange(firstRowIndex, lastRowIndex + 1);
						}

						grid._rows[below ? 'max' : 'min'] = lastRowIndex;
						if (grid._rows.max >= grid._total - 1) {
							grid._rows.max = Infinity;
						}
					}
					// now adjust the preloadNode based on the reclaimed space
					preload.count += count;
					if (below) {
						preloadNode.rowIndex -= count;
						adjustHeight(preload);
					}
					else {
						// if it is above, we can calculate the change in exact row changes,
						// which we must do to not mess with the scroll position
						preloadNode.style.height = (preloadNode.offsetHeight + reclaimedHeight) + 'px';
					}
					// we remove the elements after expanding the preload node so that
					// the contraction doesn't alter the scroll position
					var trashBin = document.createElement('div');
					for (var i = toDelete.length; i--;) {
						trashBin.appendChild(toDelete[i]);
					}
					setTimeout(function () {
						// we can defer the destruction until later
						domConstruct.destroy(trashBin);
					}, 1);
				}
			}

			function adjustHeight(preload, noMax) {
				preload.node.style.height = Math.min(preload.count * grid.rowHeight,
					noMax ? Infinity : grid.maxEmptySpace) + 'px';
			}
			function traversePreload(preload, moveNext) {
				// Skip past preloads that are not currently connected
				do {
					preload = moveNext ? preload.next : preload.previous;
				} while (preload && !preload.node.offsetWidth);
				return preload;
			}
			while (preload && !preload.node.offsetWidth) {
				// skip past preloads that are not currently connected
				preload = preload.previous;
			}
			// there can be multiple preloadNodes (if they split, or multiple queries are created),
			//	so we can traverse them until we find whatever is in the current viewport, making
			//	sure we don't backtrack
			while (preload && preload !== priorPreload) {
				priorPreload = grid.preload;
				grid.preload = preload;
				preloadNode = preload.node;
				var preloadTop = preloadNode.offsetTop;
				var preloadHeight;

				if (visibleBottom + mungeAmount + searchBuffer < preloadTop) {
					// the preload is below the line of sight
					preload = traversePreload(preload, (preloadSearchNext = false));
				}
				else if (visibleTop - mungeAmount - searchBuffer >
						(preloadTop + (preloadHeight = preloadNode.offsetHeight))) {
					// the preload is above the line of sight
					preload = traversePreload(preload, (preloadSearchNext = true));
				}
				else {
					// the preload node is visible, or close to visible, better show it
					var offset = ((preloadNode.rowIndex ? visibleTop - requestBuffer :
						visibleBottom) - preloadTop) / grid.rowHeight;
					var count = (visibleBottom - visibleTop + 2 * requestBuffer) / grid.rowHeight;
					// utilize momentum for predictions
					var momentum = Math.max(
						Math.min((visibleTop - lastScrollTop) * grid.rowHeight, grid.maxRowsPerPage / 2),
						grid.maxRowsPerPage / -2);
					count += Math.min(Math.abs(momentum), 10);
					if (preloadNode.rowIndex === 0) {
						// at the top, adjust from bottom to top
						offset -= count;
					}
					offset = Math.max(offset, 0);
					if (offset < 10 && offset > 0 && count + offset < grid.maxRowsPerPage) {
						// connect to the top of the preloadNode if possible to avoid excessive adjustments
						count += Math.max(0, offset);
						offset = 0;
					}
					count = Math.min(Math.max(count, grid.minRowsPerPage),
										grid.maxRowsPerPage, preload.count);

					if (count === 0) {
						preload = traversePreload(preload, preloadSearchNext);
						continue;
					}

					count = Math.ceil(count);
					offset = Math.min(Math.floor(offset), preload.count - count);

					var options = {};
					preload.count -= count;
					var beforeNode = preloadNode,
						keepScrollTo, queryRowsOverlap = grid.queryRowsOverlap,
						below = (preloadNode.rowIndex > 0 || preloadNode.offsetTop > visibleTop) && preload;
					if (below) {
						// add new rows below
						var previous = preload.previous;
						if (previous) {
							removeDistantNodes(previous,
								visibleTop - (previous.node.offsetTop + previous.node.offsetHeight),
								'nextSibling');
							if (offset > 0 && previous.node === preloadNode.previousSibling) {
								// all of the nodes above were removed
								offset = Math.min(preload.count, offset);
								preload.previous.count += offset;
								adjustHeight(preload.previous, true);
								preloadNode.rowIndex += offset;
								queryRowsOverlap = 0;
							}
							else {
								count += offset;
							}
							preload.count -= offset;
						}
						options.start = preloadNode.rowIndex - queryRowsOverlap;
						options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
						preloadNode.rowIndex = options.start + options.count;
					}
					else {
						// add new rows above
						if (preload.next) {
							// remove out of sight nodes first
							removeDistantNodes(preload.next, preload.next.node.offsetTop - visibleBottom,
								'previousSibling', true);
							beforeNode = preloadNode.nextSibling;
							if (beforeNode === preload.next.node) {
								// all of the nodes were removed, can position wherever we want
								preload.next.count += preload.count - offset;
								preload.next.node.rowIndex = offset + count;
								adjustHeight(preload.next);
								preload.count = offset;
								queryRowsOverlap = 0;
							}
							else {
								keepScrollTo = true;
							}

						}
						options.start = preload.count;
						options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
					}
					if (keepScrollTo && beforeNode && beforeNode.offsetWidth) {
						keepScrollTo = beforeNode.offsetTop;
					}

					adjustHeight(preload);

					// use the query associated with the preload node to get the next "page"
					if ('level' in preload.query) {
						options.queryLevel = preload.query.level;
					}

					// Avoid spurious queries (ideally this should be unnecessary...)
					if (!('queryLevel' in options) && (options.start > grid._total || options.count < 0)) {
						continue;
					}

					// create a loading node as a placeholder while the data is loaded
					var loadingNode = domConstruct.create('div', {
						className: 'dgrid-loading',
						style: { height: count * grid.rowHeight + 'px' }
					}, beforeNode, 'before');
					domConstruct.create('div', {
						className: 'dgrid-' + (below ? 'below' : 'above'),
						innerHTML: grid.loadingMessage
					}, loadingNode);
					loadingNode.count = count;

					// Query now to fill in these rows.
					grid._trackError(function () {
						// Use function to isolate the variables in case we make multiple requests
						// (which can happen if we need to render on both sides of an island of already-rendered rows)
						(function (loadingNode, below, keepScrollTo) {
							/* jshint maxlen: 122 */
							var rangeResults = preload.query(options);
							lastRows = grid.renderQueryResults(rangeResults, loadingNode, options).then(function (rows) {
								var gridRows = grid._rows;
								if (gridRows && !('queryLevel' in options) && rows.length) {
									// Update relevant observed range for top-level items
									if (below) {
										if (gridRows.max <= gridRows.min) {
											// All rows were removed; update start of rendered range as well
											gridRows.min = rows[0].rowIndex;
										}
										gridRows.max = rows[rows.length - 1].rowIndex;
									}
									else {
										if (gridRows.max <= gridRows.min) {
											// All rows were removed; update end of rendered range as well
											gridRows.max = rows[rows.length - 1].rowIndex;
										}
										gridRows.min = rows[0].rowIndex;
									}
								}

								// can remove the loading node now
								beforeNode = loadingNode.nextSibling;
								domConstruct.destroy(loadingNode);
								// beforeNode may have been removed if the query results loading node was removed
								// as a distant node before rendering
								if (keepScrollTo && beforeNode && beforeNode.offsetWidth) {
									// if the preload area above the nodes is approximated based on average
									// row height, we may need to adjust the scroll once they are filled in
									// so we don't "jump" in the scrolling position
									var pos = grid.getScrollPosition();
									grid.scrollTo({
										// Since we already had to query the scroll position,
										// include x to avoid TouchScroll querying it again on its end.
										x: pos.x,
										y: pos.y + beforeNode.offsetTop - keepScrollTo,
										// Don't kill momentum mid-scroll (for TouchScroll only).
										preserveMomentum: true
									});
								}

								rangeResults.totalLength.then(function (total) {
									if (!('queryLevel' in options)) {
										grid._total = total;
										if (grid._rows && grid._rows.max >= grid._total - 1) {
											grid._rows.max = Infinity;
										}
									}
									if (below) {
										// if it is below, we will use the total from the collection to update
										// the count of the last preload in case the total changes as
										// later pages are retrieved

										// recalculate the count
										below.count = total - below.node.rowIndex;
										// readjust the height
										adjustHeight(below);
									}
								});

								// make sure we have covered the visible area
								grid._processScroll();
								return rows;
							}, function (e) {
								domConstruct.destroy(loadingNode);
								throw e;
							});
						})(loadingNode, below, keepScrollTo);
					});

					preload = preload.previous;

				}
			}

			// return the promise from the last render
			return lastRows;
		}
	});

});

},
'dojo/hccss':function(){
define([
	"require",			// require, require.toUrl
	"./_base/config", // config.blankGif
	"./dom-class", // domClass.add
	"./dom-style", // domStyle.getComputedStyle
	"./has",
	"./domReady",
	"./_base/window" // win.body
], function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
			"background-image: url(" + (config.blankGif || require.toUrl("./resources/blank.gif")) + ");";
		win.body().appendChild(div);

		var cs = domStyle.getComputedStyle(div),
			bkImg = cs.backgroundImage,
			hc = (cs.borderTopColor == cs.borderRightColor) ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));

		if(has("ie") <= 8){
			div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
		}else{
			win.body().removeChild(div);
		}

		return hc;
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
});

},
'dojo/on':function(){
define(["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has){

	"use strict";
	if( 1 ){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			// All browsers except firefox support focusin, but too hard to feature test webkit since element.onfocusin
			// is undefined.  Just return true for IE and use fallback path for other browsers.
			return !!element.attachEvent;
		});
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(listen){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(listen, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it 
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype 
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The 
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			var events = type.split(/\s*,\s*/);
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){
				handles.push(addListener(target, eventName, listener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1, 
				//but works through "resize" on window
				type = "resize"; 
				target = window;
				listener = fixTouchListener(listener);
			} 
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}

	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to 
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(listen, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				// see if we have a valid matchesTarget or default to dojo/query
				matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
				// there is a selector, so make sure it matches
				while(!matchesTarget.matches(eventTarget, selector, target)){
					if(eventTarget == target || children === false || !(eventTarget = eventTarget.parentNode) || eventTarget.nodeType != 1){ // intentional assignment
						return;
					}
				}
				return eventTarget;
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				return eventTarget && listener.call(eventTarget, event);
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain 
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and 
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent 
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable 
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		}
	} 
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event				
				// we could create branch into the different types of event constructors, but 
				// that would be a lot of extra code, with little benefit that I can see, seems 
				// best to use the generic constructor and copy properties over, making it 
				// easy to have events look like the ones created with specific initializers
				var nativeEvent = target.ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || 
						has("jscript") < 5.8) && 
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){ 
		var Event = function(){};
		var windowOrientation = window.orientation; 
		var fixTouchListener = function(listener){ 
			return function(originalEvent){ 
				//Event normalization(for ontouchxxx and resize): 
				//1.incorrect e.pageX|pageY in iOS 
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties make them mutable
					}catch(e){} 
					if(originalEvent.type){
						// deleting properties doesn't work (older iOS), have to use delegation
						if(has('mozilla')){
							// Firefox doesn't like delegated properties, so we have to copy
							var event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}else{
							// old iOS branch
							Event.prototype = originalEvent;
							var event = new Event;
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){ 
							return null;//double tap causes an unexpected 'resize' in Android
						} 
						windowOrientation = window.orientation;
						event.type = "orientationchange"; 
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0; 
						event.scale = 1;
					}
					//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
					var firstChangeTouch = event.changedTouches[0];
					for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
						delete event[i]; // delete it first to make it mutable
						event[i] = firstChangeTouch[i];
					}
				}
				return listener.call(this, event); 
			}; 
		}; 
	}
	return on;
});

},
'dojo/errors/create':function(){
define(["../_base/lang"], function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
});

},
'dgrid/util/has-css3':function(){
define([
	'dojo/has'
], function (has) {
	// This module defines feature tests for CSS3 features such as transitions.
	// The css-transitions, css-transforms, and css-transforms3d has-features
	// can report either boolean or string:
	// * false indicates no support
	// * true indicates prefix-less support
	// * string indicates the vendor prefix under which the feature is supported

	var cssPrefixes = ['ms', 'O', 'Moz', 'Webkit'];

	function testStyle(element, property) {
		var style = element.style,
			i;

		if (property in style) {
			// Standard, no prefix
			return true;
		}
		property = property.slice(0, 1).toUpperCase() + property.slice(1);
		for (i = cssPrefixes.length; i--;) {
			if ((cssPrefixes[i] + property) in style) {
				// Vendor-specific css property prefix
				return cssPrefixes[i];
			}
		}

		// Otherwise, not supported
		return false;
	}

	has.add('css-transitions', function (global, doc, element) {
		return testStyle(element, 'transitionProperty');
	});

	has.add('css-transforms', function (global, doc, element) {
		return testStyle(element, 'transform');
	});

	has.add('css-transforms3d', function (global, doc, element) {
		return testStyle(element, 'perspective');
	});

	has.add('transitionend', function () {
		// Infer transitionend event name based on CSS transitions has-feature.
		var tpfx = has('css-transitions');
		if (!tpfx) {
			return false;
		}
		if (tpfx === true) {
			return 'transitionend';
		}
		return {
			ms: 'MSTransitionEnd',
			O: 'oTransitionEnd',
			Moz: 'transitionend',
			Webkit: 'webkitTransitionEnd'
		}[tpfx];
	});

	return has;
});

},
'xide/rpc/AdapterRegistry':function(){
define(["dojo/_base/kernel", "dojo/_base/lang"], function (dojo, lang) {
    var AdapterRegistry = dojo.AdapterRegistry = function (/*Boolean?*/ returnWrappers) {
        // summary:
        //		A registry to make contextual calling/searching easier.
        // description:
        //		Objects of this class keep list of arrays in the form [name, check,
        //		wrap, directReturn] that are used to determine what the contextual
        //		result of a set of checked arguments is. All check/wrap functions
        //		in this registry should be of the same arity.
        // example:
        //	|	// create a new registry
        //	|	require(["dojo/AdapterRegistry"],
        //	|	function(AdapterRegistry){
        //	|		var reg = new AdapterRegistry();
        //	|		reg.register("handleString",
        //	|			function(str){
        //	|				return typeof val == "string"
        //	|			},
        //	|			function(str){
        //	|				// do something with the string here
        //	|			}
        //	|		);
        //	|		reg.register("handleArr",
        //	|			dojo.isArray,
        //	|			function(arr){
        //	|				// do something with the array here
        //	|			}
        //	|		);
        //	|
        //	|		// now we can pass reg.match() *either* an array or a string and
        //	|		// the value we pass will get handled by the right function
        //	|		reg.match("someValue"); // will call the first function
        //	|		reg.match(["someValue"]); // will call the second
        //	|	});

        this.pairs = [];
        this.returnWrappers = returnWrappers || false; // Boolean
    };

    lang.extend(AdapterRegistry, {
        register: function (/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override) {
            // summary:
            //		register a check function to determine if the wrap function or
            //		object gets selected
            // name:
            //		a way to identify this matcher.
            // check:
            //		a function that arguments are passed to from the adapter's
            //		match() function.  The check function should return true if the
            //		given arguments are appropriate for the wrap function.
            // directReturn:
            //		If directReturn is true, the value passed in for wrap will be
            //		returned instead of being called. Alternately, the
            //		AdapterRegistry can be set globally to "return not call" using
            //		the returnWrappers property. Either way, this behavior allows
            //		the registry to act as a "search" function instead of a
            //		function interception library.
            // override:
            //		If override is given and true, the check function will be given
            //		highest priority. Otherwise, it will be the lowest priority
            //		adapter.
            this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
        },

        match: function (/* ... */) {
            // summary:
            //		Find an adapter for the given arguments. If no suitable adapter
            //		is found, throws an exception. match() accepts any number of
            //		arguments, all of which are passed to all matching functions
            //		from the registered pairs.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[1].apply(this, arguments)) {
                    if ((pair[3]) || (this.returnWrappers)) {
                        return pair[2];
                    } else {
                        return pair[2].apply(this, arguments);
                    }
                }
            }
            throw new Error("No match found");
        },

        unregister: function (name) {
            // summary:
            //		Remove a named adapter from the registry
            // name: String
            //		The name of the adapter.
            // returns: Boolean
            //		Returns true if operation is successful.
            //		Returns false if operation fails.

            // FIXME: this is kind of a dumb way to handle this. On a large
            // registry this will be slow-ish and we can use the name as a lookup
            // should we choose to trade memory for speed.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[0] == name) {
                    this.pairs.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
    });

    return AdapterRegistry;
});

},
'xide/mixins/ActionMixin':function(){
define([
    "dcl/dcl",
    "xdojo/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    var Implementation = {
        store:null,
        getActionStore:function(){
            return this.store;
        },
        setActionStore:function(store){
            return this.store = store;
        },
        _publishActionWidget:function(widget,action,parent,visibility){
            var thiz = this;
            action._emit(thiz.visibility + '_WIDGET_CREATED',{
                parent:parent,
                widget:widget,
                owner:thiz
            });

            action._emit('WIDGET_CREATED',{
                parent:parent,
                widget:widget,
                visibility:thiz.visibility,
                owner:thiz
            });

            if (visibility){
                visibility.widget = widget;
                visibility.widget.visibility = thiz.visibility;
            }

            if(action.addReference)
            {
                action.addReference(widget, {
                    properties: {
                        "value": true,
                        "disabled":true
                    }
                }, true);
            }
        },
        /**
         * Sort
         * @param groups
         * @param groupMap
         * @returns {*}
         */
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (a.label && b.label && groupMap[a.label] != null && groupMap[b.label] != null) {
                    var orderA = groupMap[a.label];
                    var orderB = groupMap[b.label];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        /**
         * The visibility filter. There are the events "REGISTER_ACTION" and "SET_ITEM_ACTIONS" a sub-class might listening too.
         * When receiving a new set of actions, in most cases any income action needs to be filtered agains this value.         *
         * Please @see {model:xide/action/Action for more}.
         *
         * @member visibility {module:xide/types/ACTION_VISIBILITY}
         * @type {string|null}
         */
        visibility: null,
        /**
         * All actions, there is also _incomingActions for the last set
         * type {xide/action/Action[]}
         */
        _actions: [],
        /**
         *
         * @param visibility {string|null}
         */
        clearActions: function (visibility,_store) {

            visibility = visibility || this.visibility;

            var store = _store || this.getActionStore(),
                actions = store.data;

            if(!store){
                return;
            }
            actions && _.each(actions,function(action){
                var actionVisibility = action.getVisibility!= null ? action.getVisibility(visibility) : null;
                if(actionVisibility){
                    var widget = actionVisibility.widget;
                    if(widget){
                        //remove action reference widget
                        action.removeReference && action.removeReference(widget);
                        widget.destroy();
                        this.setVisibilityField(action, 'widget', null);
                    }
                }
            },this);
        },
        /**
         * computeList modifies a set of actions in that way:
         *
         * 1. prepare the incoming list of 'actions' by grouping them using the actions.command first path element.
         * 2. order the inner branches created above, using the action's 'order', 'group' and 'command' field
         * 3. composite the the entire tree by overriding each top level's 'item' attribute
         *
         * @param items {xide/action/Action[]}
         * @returns {xide/action/Action[]} the modified version of the input
         * @private
         */
        _computeList: function (items, add) {
            return this._actions;
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField:function(action,field,_default){
            var actionVisibility = action.getVisibility !=null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !=null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField:function(action,field,value){
            var _default = {};
            if(action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction:function(action){
            if(this.getVisibilityField(action,'show')==false){
                return false;
            }else if(action.getVisibility && action.getVisibility(this.visibility)==null){
                return false;
            }
            return true;
        }
    }

    /**
     * Provides tools to deal with 'actions' (xide/action/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/_MenuMixin) in a subclass.
     *
     * @mixin module:xide/mixins/ActionMixin
     */
    var Module = declare("xide/mixins/ActionMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});

},
'xdocker/types':function(){
/** @module xgrid/Base **/
define([
    "xdojo/declare",
    'xide/types'
], function (declare, types) {

    /*!
     * Web Cabin Docker - Docking Layout Interface.
     *
     * Dependencies:
     *  JQuery 1.11.1
     *  JQuery-contextMenu 1.6.6
     *  font-awesome 4.2.0
     *
     * Author: Jeff Houde (lochemage@webcabin.org)
     * Web: https://docker.webcabin.org/
     *
     * Licensed under
     *   MIT License http://www.opensource.org/licenses/mit-license
     *   GPL v3 http://opensource.org/licenses/GPL-3.0
     *
     */


    types.DOCKER = {
        DOCK:null
    };

    types.DOCKER.DOCK = {
        /** A floating panel that blocks input until closed */
        MODAL: 'modal',
        /** A floating panel */
        FLOAT: 'float',
        /** Docks to the top of a target or window */
        TOP: 'top',
        /** Docks to the left of a target or window */
        LEFT: 'left',
        /** Docks to the right of a target or window */
        RIGHT: 'right',
        /** Docks to the bottom of a target or window */
        BOTTOM: 'bottom',
        /** Docks as another tabbed item along with the target */
        STACKED: 'stacked'
    };

    /**
     * Enumerated Internal events
     * @version 3.0.0
     * @enum {String}
     */

    types.DOCKER.EVENT = {

        SELECT: 'ON_VIEW_SELECT',

        /** When the panel is initialized */

        INIT: 'panelInit',
        /** When all panels have finished loading */
        LOADED: 'dockerLoaded',
        /** When the panel is updated */
        UPDATED: 'panelUpdated',
        /** When the panel has changed its visibility */
        VISIBILITY_CHANGED: 'panelVisibilityChanged',
        /** When the user begins moving any panel from its current docked position */
        BEGIN_DOCK: 'panelBeginDock',
        /** When the user finishes moving or docking a panel */
        END_DOCK: 'panelEndDock',
        /** When the user brings this panel into focus */
        GAIN_FOCUS: 'panelGainFocus',
        /** When the user leaves focus on this panel */
        LOST_FOCUS: 'panelLostFocus',
        /** When the panel is being closed */
        CLOSED: 'panelClosed',
        /** When a custom button is clicked, See [wcPanel.addButton]{@link wcPanel#addButton} */
        BUTTON: 'panelButton',
        /** When the panel has moved from floating to a docked position */
        ATTACHED: 'panelAttached',
        /** When the panel has moved from a docked position to floating */
        DETACHED: 'panelDetached',
        /** When the user has started moving the panel (top-left coordinates changed) */
        MOVE_STARTED: 'panelMoveStarted',
        /** When the user has finished moving the panel */
        MOVE_ENDED: 'panelMoveEnded',
        /** When the top-left coordinates of the panel has changed */
        MOVED: 'panelMoved',
        /** When the user has started resizing the panel (width or height changed) */
        RESIZE_STARTED: 'panelResizeStarted',
        /** When the user has finished resizing the panel */
        RESIZE_ENDED: 'panelResizeEnded',
        /** When the panels width or height has changed */
        RESIZED: 'panelResized',
        /** When the contents of the panel has been scrolled */
        SCROLLED: 'panelScrolled',
        /** When the layout is being saved, See [wcDocker.save]{@link wcDocker#save} */
        SAVE_LAYOUT: 'layoutSave',
        /** When the layout is being restored, See [wcDocker.restore]{@link wcDocker#restore} */
        RESTORE_LAYOUT: 'layoutRestore',
        /** When the current tab on a custom tab widget associated with this panel has changed, See {@link wcTabFrame} */
        CUSTOM_TAB_CHANGED: 'customTabChanged',
        /** When a tab has been closed on a custom tab widget associated with this panel, See {@link wcTabFrame} */
        CUSTOM_TAB_CLOSED: 'customTabClosed',
        /** When a splitter position has been changed */
        SPLITTER_POS_CHANGED: 'splitterPosChanged',
        
        BEGIN_FLOAT_RESIZE: 'beginFloatResize',
        END_FLOAT_RESIZE: 'endFloatResize',
        BEGIN_RESIZE:"beginResize",
        END_RESIZE:"endResize"

    };

    /**
     * The name of the placeholder panel.
     * @constant {String}
     */
    types.DOCKER.PANEL_PLACEHOLDER = '__wcDockerPlaceholderPanel';


    /**
     * Used when [adding]{@link wcDocker#addPanel} or [moving]{@link wcDocker#movePanel} a panel to designate the target location as collapsed.<br>
     * Must be used with [docking]{@link wcDocker.DOCK} positions LEFT, RIGHT, or BOTTOM only.
     * @constant {String}
     */

    types.DOCKER.COLLAPSED = '__wcDockerCollapsedPanel';

    /**
     * Used for the splitter bar orientation.
     * @version 3.0.0
     * @enum {Boolean}
     */
    types.DOCKER.ORIENTATION = {
        /** Top and Bottom panes */
        VERTICAL: false,
        /** Left and Right panes */
        HORIZONTAL: true
    };


    types.DOCKER.TAB = {
        /** The default, puts tabs at the top of the frame */
        TOP: 'top',
        /** Puts tabs on the left side of the frame */
        LEFT: 'left',
        /** Puts tabs on the right side of the frame */
        RIGHT: 'right',
        /** Puts tabs on the bottom of the frame */
        BOTTOM: 'bottom'
    };

    types.DOCKER.TAB.ORIENTATION = {
        /** Top and Bottom panes */
        VERTICAL: false,
        /** Left and Right panes */
        HORIZONTAL: true
    };


    types.PANEL_TYPES = {
        DefaultFixed : 'DefaultFixed',
        DefaultTab : 'DefaultTab',
        Collapsible : 'Collapsible'
    }

    return declare('xide.docker.types',null,{});


});
},
'wcDocker/ghost':function(){
/** @module wcGhost **/
define([
    "dcl/dcl",
    "wcDocker/types"
], function (dcl, wcDocker) {

    /**
     * @class module:wcGhost
     * A ghost object that follows the mouse around during dock movement.
     */
    var Module = dcl(null, {
        declaredClass: 'wcGhost',
        
        /**
         * @memberOf module:wcGhost
         * @param {module:wcDocker~Rect} rect - A rectangle area to begin the ghost highlighting.
         * @param {module:wcDocker~Coordinate} mouse - The mouse position.
         * @param {module:wcDocker} docker - The docker object.
         */
        constructor: function (rect, mouse, docker) {
            this.$ghost = null;
            this._rect;
            this._anchorMouse = false;
            this._anchor = null;
            this._docker = docker;

            this._outer = docker.__findInner();
            if (this._outer && this._outer.instanceOf('wcSplitter')) {
                this._inner = this._outer.right();
            }

            this.__init(rect, mouse);
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Updates the ghost based on the given screen position.
         * @function module:wcGhost#update
         * @param {module:wcDocker~Coordinate} position - The mouse position.
         * @param {Boolean} [disableFloating] - If true, the ghost will not float.
         */
        update: function (position, disableFloating) {
            this.__move(position);

            for (var i = 0; i < this._docker._floatingList.length; ++i) {
                var rect = this._docker._floatingList[i].__rect();
                if (position.x > rect.x && position.y > rect.y
                    && position.x < rect.x + rect.w && position.y < rect.y + rect.h) {

                    if (!this._docker._floatingList[i].__checkAnchorDrop(position, false, this, true, undefined, true)) {
                        if (!disableFloating) {
                            this.anchor(position, null);
                        }
                    } else {
                        this._anchor.panel = this._docker._floatingList[i].panel();
                    }
                    return;
                }
            }

            for (var i = 0; i < this._docker._frameList.length; ++i) {
                var rect = this._docker._frameList[i].__rect();
                if (position.x > rect.x && position.y > rect.y
                    && position.x < rect.x + rect.w && position.y < rect.y + rect.h) {

                    if (!this._docker._frameList[i].__checkAnchorDrop(position, false, this, true, undefined, true)) {
                        if (!disableFloating) {
                            this.anchor(position, null);
                        }
                    } else {
                        this._anchor.panel = this._docker._frameList[i].panel();
                    }
                    return;
                }
            }
        },

        /**
         * Get, or Sets the ghost's anchor.
         * @function module:wcGhost#anchor
         * @param {module:wcDocker~Coordinate} [mouse] - If supplied with the anchor, .
         * @param {module:wcDocker~Anchor} [anchor] - If supplied, assigns a new anchor.
         */
        anchor: function (mouse, anchor) {
            if (typeof mouse === 'undefined') {
                return this._anchor;
            }

            if (anchor && this._anchor && anchor.loc === this._anchor.loc && anchor.item === this._anchor.item) {
                return;
            }

            var rect = {
                x: parseInt(this.$ghost.css('left')),
                y: parseInt(this.$ghost.css('top')),
                w: parseInt(this.$ghost.css('width')),
                h: parseInt(this.$ghost.css('height'))
            };

            this._anchorMouse = {
                x: rect.x - mouse.x,
                y: rect.y - mouse.y
            };

            this._rect.x = -this._anchorMouse.x;
            this._rect.y = -this._anchorMouse.y;

            if (!anchor) {
                if (!this._anchor) {
                    return;
                }

                if (this._docker._draggingFrame && this._docker._draggingFrame.$container) {
                    var detachToWidth = this._docker._draggingFrame._panelList[0]._options.detachToWidth || this._docker._options.detachToWidth || this._rect.w;
                    var detachToHeight = this._docker._draggingFrame._panelList[0]._options.detachToHeight || this._docker._options.detachToHeight || this._rect.h;
                    this._rect.w = this._docker.__stringToPixel(detachToWidth, this._docker.$container.width());
                    this._rect.h = this._docker.__stringToPixel(detachToHeight, this._docker.$container.height());
                }

                this._anchor = null;
                this.$ghost.show();
                this.$ghost.stop().animate({
                    opacity: 0.3,
                    'margin-left': this._rect.x - this._rect.w / 2 + 'px',
                    'margin-top': this._rect.y - 10 + 'px',
                    width: this._rect.w + 'px',
                    height: this._rect.h + 'px'
                }, 150);
                return;
            }

            this._anchor = anchor;
            var opacity = 0.8;
            if (anchor.self && anchor.loc === wcDocker.DOCK.STACKED) {
                opacity = 0;
                this.$ghost.hide();
            } else {
                this.$ghost.show();
            }
            this.$ghost.stop().animate({
                opacity: opacity,
                'margin-left': '2px',
                'margin-top': '2px',
                border: '0px',
                left: anchor.x + 'px',
                top: anchor.y + 'px',
                width: anchor.w + 'px',
                height: anchor.h + 'px'
            }, 150);
        },

        /**
         * Retrieves the rectangle area of the ghost's anchor.
         * @function module:wcGhost#rect
         * @returns {module:wcDocker~AnchorRect} - The rectangle area of the anchor.
         */
        rect: function () {
            return {
                x: this.$ghost.offset().left,
                y: this.$ghost.offset().top,
                w: parseInt(this.$ghost.css('width')),
                h: parseInt(this.$ghost.css('height')),
                tabOrientation: this._anchor && this._anchor.tab
            };
        },

        /**
         * Destroys the instance of the ghost.
         * @function module:wcGhost#destroy
         */
        destroy: function () {
            this.__destroy();
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function (rect, mouse) {
            this.$ghost = $('<div class="wcGhost">')
                .css('opacity', 0)
                .css('top', rect.y + 'px')
                .css('left', rect.x + 'px')
                .css('width', rect.w + 'px')
                .css('height', rect.h + 'px');

            this._anchorMouse = {
                x: rect.x - mouse.x,
                y: rect.y - mouse.y
            };

            this._rect = {
                x: -this._anchorMouse.x,
                y: -this._anchorMouse.y,
                w: rect.w,
                h: rect.h
            };

            $('body').append(this.$ghost);

            this.anchor(mouse, rect);
        },

        // Updates the size of the layout.
        __move: function (mouse) {
            if (this._anchor) {
                return;
            }

            var x = parseInt(this.$ghost.css('left'));
            var y = parseInt(this.$ghost.css('top'));

            x = mouse.x + this._anchorMouse.x;
            y = mouse.y + this._anchorMouse.y;

            this.$ghost.css('left', x + 'px');
            this.$ghost.css('top', y + 'px');
        },

        // Gets the original size of the moving widget.
        __rect: function () {
            return this._rect;
        },

        // Exorcise the ghost.
        __destroy: function () {
            this.$ghost.stop().animate({
                opacity: 0.0
            }, {
                duration: 175,
                complete: function () {
                    $(this).remove();
                }
            });
        }
    });
    return Module;

});

},
'dgrid/List':function(){
/** @module dgrid/List **/
define([
	'dojo/_base/declare',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/has',
	'./util/misc',
	'dojo/_base/sniff'
], function (declare, domConstruct, domClass, listen, has, miscUtil) {
	// Add user agent/feature CSS classes needed for structural CSS
	var featureClasses = [];
	if (has('mozilla')) {
		featureClasses.push('has-mozilla');
	}
	if (has('touch')) {
		featureClasses.push('has-touch');
	}
	domClass.add(document.documentElement, featureClasses);

	// Add a feature test for pointer (only Dojo 1.10 has pointer-events and MSPointer tests)
	has.add('pointer', function (global) {
		return 'PointerEvent' in global ? 'pointer' :
			'MSPointerEvent' in global ? 'MSPointer' : false;
	});

	var oddClass = 'dgrid-row-odd',
		evenClass = 'dgrid-row-even',
		scrollbarWidth, scrollbarHeight;

	function byId(id) {
		return document.getElementById(id);
	}

	function cleanupTestElement(element) {
		element.className = '';
		if (element.parentNode) {
			document.body.removeChild(element);
		}
	}

	function getScrollbarSize(element, dimension) {
		// Used by has tests for scrollbar width/height
		element.className = 'dgrid-scrollbar-measure';
		document.body.appendChild(element);
		var size = element['offset' + dimension] - element['client' + dimension];
		cleanupTestElement(element);
		return size;
	}
	has.add('dom-scrollbar-width', function (global, doc, element) {
		return getScrollbarSize(element, 'Width');
	});
	has.add('dom-scrollbar-height', function (global, doc, element) {
		return getScrollbarSize(element, 'Height');
	});

	has.add('dom-rtl-scrollbar-left', function (global, doc, element) {
		var div = document.createElement('div'),
			isLeft;

		element.className = 'dgrid-scrollbar-measure';
		element.setAttribute('dir', 'rtl');
		element.appendChild(div);
		document.body.appendChild(element);

		// position: absolute makes modern IE and Edge always report child's offsetLeft as 0,
		// but other browsers factor in the position of the scrollbar if it is to the left.
		// All versions of IE and Edge are known to move the scrollbar to the left side for rtl.
		isLeft = !!has('ie') || !!has('trident') || /\bEdge\//.test(navigator.userAgent) ||
			div.offsetLeft >= has('dom-scrollbar-width');
		cleanupTestElement(element);
		domConstruct.destroy(div);
		element.removeAttribute('dir');
		return isLeft;
	});

	// var and function for autogenerating ID when one isn't provided
	var autoId = 0;
	function generateId() {
		return List.autoIdPrefix + autoId++;
	}

	// common functions for class and className setters/getters
	// (these are run in instance context)
	function setClass(cls) {
		// TODO: unit test
		domClass.replace(this.domNode, cls, this._class || '');

		// Store for later retrieval/removal.
		this._class = cls;
	}
	function getClass() {
		return this._class;
	}

	// window resize event handler, run in context of List instance
	//xhack no longer needed
	//var winResizeHandler = function () {
	//	console.log('reis');
	//	if (this._started) {
	//		this.resize();
	//	}
	//};

	/**
	 * Grid base class
	 * @class module:dgrid/List
	 */
	var List = declare(null, {
		tabableHeader: false,

		// showHeader: Boolean
		//		Whether to render header (sub)rows.
		showHeader: false,

		// showFooter: Boolean
		//		Whether to render footer area.  Extensions which display content
		//		in the footer area should set this to true.
		showFooter: false,

		// maintainOddEven: Boolean
		//		Whether to maintain the odd/even classes when new rows are inserted.
		//		This can be disabled to improve insertion performance if odd/even styling is not employed.
		maintainOddEven: true,

		// cleanAddedRules: Boolean
		//		Whether to track rules added via the addCssRule method to be removed
		//		when the list is destroyed.  Note this is effective at the time of
		//		the call to addCssRule, not at the time of destruction.
		cleanAddedRules: true,

		// addUiClasses: Boolean
		//		Whether to add jQuery UI classes to various elements in dgrid's DOM.
		addUiClasses: false,

		// highlightDuration: Integer
		//		The amount of time (in milliseconds) that a row should remain
		//		highlighted after it has been updated.
		highlightDuration: 250,

		postscript: function (params, srcNodeRef) {
			// perform setup and invoke create in postScript to allow descendants to
			// perform logic before create/postCreate happen (a la dijit/_WidgetBase)
			var grid = this;

			(this._Row = function (id, object, element) {
				this.id = id;
				this.data = object;
				this.element = element;
			}).prototype.remove = function () {
				grid.removeRow(this.element);
			};

			if (srcNodeRef) {
				// normalize srcNodeRef and store on instance during create process.
				// Doing this in postscript is a bit earlier than dijit would do it,
				// but allows subclasses to access it pre-normalized during create.
				this.srcNodeRef = srcNodeRef =
					srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
			}
			this.create(params, srcNodeRef);
		},
		listType: 'list',

		create: function (params, srcNodeRef) {
			var domNode = this.domNode = srcNodeRef || document.createElement('div'),
				cls;

			if (params) {
				this.params = params;
				declare.safeMixin(this, params);

				// Check for initial class or className in params or on domNode
				cls = params['class'] || params.className || domNode.className;
			}

			// ensure arrays and hashes are initialized
			this.sort = this.sort || [];
			this._listeners = [];
			this._rowIdToObject = {};

			this.postMixInProperties && this.postMixInProperties();

			// Apply id to widget and domNode,
			// from incoming node, widget params, or autogenerated.
			this.id = domNode.id = domNode.id || this.id || generateId();

			// Perform initial rendering, and apply classes if any were specified.
			this.buildRendering();
			if (cls) {
				setClass.call(this, cls);
			}

			this.postCreate();

			// remove srcNodeRef instance property post-create
			delete this.srcNodeRef;
			// to preserve "it just works" behavior, call startup if we're visible
			//xhack, non of your business
			//if (this.domNode.offsetHeight) {
			//	//this.startup();
			//}
		},
		buildRendering: function () {
			var domNode = this.domNode,
				addUiClasses = this.addUiClasses,
				self = this,
				headerNode,
				bodyNode,
				footerNode,
				isRTL;

			// Detect RTL on html/body nodes; taken from dojo/dom-geometry
			isRTL = this.isRTL = (document.body.dir || document.documentElement.dir ||
				document.body.style.direction).toLowerCase() === 'rtl';

			// Clear out className (any pre-applied classes will be re-applied via the
			// class / className setter), then apply standard classes/attributes
			domNode.className = '';

			domNode.setAttribute('role', 'grid');
			domClass.add(domNode, 'dgrid dgrid-' + this.listType +
				(addUiClasses ? ' ui-widget' : ''));

			// Place header node (initially hidden if showHeader is false).
			headerNode = this.headerNode = domConstruct.create('div', {
				tabIndex:-1,
				className: 'dgrid-header dgrid-header-row' + (addUiClasses ? ' ui-widget-header' : '') +
					(this.showHeader ? '' : ' dgrid-header-hidden')
			}, domNode);

			bodyNode = this.bodyNode = domConstruct.create('div', {
				className: 'dgrid-scroller'
			}, domNode);

			// Firefox 4+ adds overflow: auto elements to the tab index by default;
			// force them to not be tabbable, but restrict this to Firefox,
			// since it breaks accessibility support in other browsers
			if (has('ff')) {
				bodyNode.tabIndex = -1;
			}

			this.headerScrollNode = domConstruct.create('div', {
				className: 'dgrid-header dgrid-header-scroll dgrid-scrollbar-width' +
					(addUiClasses ? ' widget' : '')
			}, domNode);

			// Place footer node (initially hidden if showFooter is false).
			footerNode = this.footerNode = domConstruct.create('div', {
				className: 'dgrid-footer' + (this.showFooter ? '' : ' dgrid-footer-hidden')
			}, domNode);

			if (isRTL) {
				domNode.className += ' dgrid-rtl' +
					(has('dom-rtl-scrollbar-left') ? ' dgrid-rtl-swap' : '');
			}

			listen(bodyNode, 'scroll', function (event) {
				if (self.showHeader) {
					// keep the header aligned with the body
					headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
				}
				// re-fire, since browsers are not consistent about propagation here
				event.stopPropagation();
				listen.emit(domNode, 'scroll', {scrollTarget: bodyNode});
			});
			this.configStructure();
			this.renderHeader();

			this.contentNode = this.touchNode = domConstruct.create('div', {
				className: 'dgrid-content' + (addUiClasses ? ' widget' : '')
			}, this.bodyNode);

			// add window resize handler, with reference for later removal if needed
			//xhack: not your business
			//this._listeners.push(this._resizeHandle = listen(window, 'resize',miscUtil.throttleDelayed(winResizeHandler, this)));
		},

		//xhack: not needed postCreate: function () {},
		startup: function () {
			// summary:
			//		Called automatically after postCreate if the component is already
			//		visible; otherwise, should be called manually once placed.

			if (this._started) {
				return;
			}
			this.inherited(arguments);
			this._started = true;
			//xhack: not needed this.resize();
			// apply sort (and refresh) now that we're ready to render
			this.set('sort', this.sort);
		},

		configStructure: function () {
			// does nothing in List, this is more of a hook for the Grid
		},
		resize: function () {
			var bodyNode = this.bodyNode,
				headerNode = this.headerNode,
				footerNode = this.footerNode,
				headerHeight = headerNode.offsetHeight,
				footerHeight = this.showFooter ? footerNode.offsetHeight : 0;

			this.headerScrollNode.style.height = bodyNode.style.marginTop = headerHeight + 'px';
			bodyNode.style.marginBottom = footerHeight + 'px';

			if (!scrollbarWidth) {
				// Measure the browser's scrollbar width using a DIV we'll delete right away
				scrollbarWidth = has('dom-scrollbar-width');
				scrollbarHeight = has('dom-scrollbar-height');

				// Avoid issues with certain widgets inside in IE7, and
				// ColumnSet scroll issues with all supported IE versions
				if (has('ie')) {
					scrollbarWidth++;
					scrollbarHeight++;
				}

				// add rules that can be used where scrollbar width/height is needed
				//miscUtil.addCssRule('.dgrid-scrollbar-width', 'width: ' + scrollbarWidth + 'px');
				//miscUtil.addCssRule('.dgrid-scrollbar-height', 'height: ' + scrollbarHeight + 'px');

				if (scrollbarWidth !== 17) {
					// for modern browsers, we can perform a one-time operation which adds
					// a rule to account for scrollbar width in all grid headers.
					//miscUtil.addCssRule('.dgrid-header-row', 'right: ' + scrollbarWidth + 'px');
					// add another for RTL grids
					miscUtil.addCssRule('.dgrid-rtl-swap .dgrid-header-row', 'left: ' + scrollbarWidth + 'px');
				}
			}
		},

		addCssRule: function (selector, css) {
			// summary:
			//		Version of util/misc.addCssRule which tracks added rules and removes
			//		them when the List is destroyed.

			var rule = miscUtil.addCssRule(selector, css);
			if (this.cleanAddedRules) {
				// Although this isn't a listener, it shares the same remove contract
				this._listeners.push(rule);
			}
			return rule;
		},

		on: function (eventType, listener) {
			// delegate events to the domNode
			var signal = listen(this.domNode, eventType, listener);
			if (!has('dom-addeventlistener')) {
				this._listeners.push(signal);
			}
			return signal;
		},

		cleanup: function () {
			// summary:
			//		Clears out all rows currently in the list.

			var i;
			for (i in this._rowIdToObject) {
				if (this._rowIdToObject[i] !== this.columns) {
					var rowElement = byId(i);
					if (rowElement) {
						this.removeRow(rowElement, true);
					}
				}
			}
		},
		destroy: function () {
			// summary:
			//		Destroys this grid

			// Remove any event listeners and other such removables
			if (this._listeners) { // Guard against accidental subsequent calls to destroy
				for (var i = this._listeners.length; i--;) {
					this._listeners[i].remove();
				}
				this._listeners = null;
			}

			this._started = false;
			this.cleanup();
			// destroy DOM
			domConstruct.destroy(this.domNode);
		},
		refresh: function () {
			// summary:
			//		refreshes the contents of the grid
			this.cleanup();
			this._rowIdToObject = {};
			this._autoRowId = 0;

			// make sure all the content has been removed so it can be recreated
			this.contentNode.innerHTML = '';
			// Ensure scroll position always resets
			this.scrollTo({ x: 0, y: 0 });
		},

		/* xhack: not needed
		highlightRow: function (rowElement, delay) {
			// summary:
			//		Highlights a row.  Used when updating rows due to store
			//		notifications, but potentially also useful in other cases.
			// rowElement: Object
			//		Row element (or object returned from the row method) to
			//		highlight.
			// delay: Number
			//		Number of milliseconds between adding and removing the
			//		ui-state-highlight class.

			var classes = 'dgrid-highlight' + (this.addUiClasses ? ' ui-state-highlight' : '');

			rowElement = rowElement.element || rowElement;
			domClass.add(rowElement, classes);
			setTimeout(function () {
				domClass.remove(rowElement, classes);
			}, delay || this.highlightDuration);
		},
		*/
		adjustRowIndices: function (firstRow) {
			// this traverses through rows to maintain odd/even classes on the rows when indexes shift;
			var next = firstRow;
			var rowIndex = next.rowIndex;
			if (rowIndex > -1) { // make sure we have a real number in case this is called on a non-row
				do {
					// Skip non-numeric, non-rows
					if (next.rowIndex > -1) {
						if (this.maintainOddEven) {
							if (domClass.contains(next, 'dgrid-row')) {
								domClass.replace(next, (rowIndex % 2 === 1 ? oddClass : evenClass),
									(rowIndex % 2 === 0 ? oddClass : evenClass));
							}
						}
						next.rowIndex = rowIndex++;
					}
				} while ((next = next.nextSibling) && next.rowIndex !== rowIndex);
			}
		},
		renderArray: function (results, beforeNode, options) {
			// summary:
			//		Renders an array of objects as rows, before the given node.

			options = options || {};
			var self = this,
				start = options.start || 0,
				rowsFragment = document.createDocumentFragment(),
				rows = [],
				container,
				i = 0,
				len = results.length;

			if (!beforeNode) {
				this._lastCollection = results;
			}

			// Insert a row for each item into the document fragment
			while (i < len) {
				rows[i] = this.insertRow(results[i], rowsFragment, null, start++, options);
				i++;
			}

			// Insert the document fragment into the appropriate position
			container = beforeNode ? beforeNode.parentNode : self.contentNode;
			if (container && container.parentNode &&
					(container !== self.contentNode || len)) {
				container.insertBefore(rowsFragment, beforeNode || null);
				if (len) {
					self.adjustRowIndices(rows[len - 1]);
				}
			}

			return rows;
		},

		renderHeader: function () {
			// no-op in a plain list
		},

		_autoRowId: 0,
		insertRow: function (object, parent, beforeNode, i, options) {
			// summary:
			//		Creates a single row in the grid.

			// Include parentId within row identifier if one was specified in options.
			// (This is used by tree to allow the same object to appear under
			// multiple parents.)
			var id = this.id + '-row-' + ((this.collection && this.collection.getIdentity) ?
					this.collection.getIdentity(object) : this._autoRowId++),
				row = byId(id),
				previousRow = row && row.previousSibling;

			if (row) {
				// If it existed elsewhere in the DOM, we will remove it, so we can recreate it
				if (row === beforeNode) {
					beforeNode = (beforeNode.connected || beforeNode).nextSibling;
				}
				this.removeRow(row, false, options);
			}
			row = this.renderRow(object, options);
			row.className = (row.className || '') + ' dgrid-row ' + (i % 2 === 1 ? oddClass : evenClass);
			// Get the row id for easy retrieval
			this._rowIdToObject[row.id = id] = object;
			parent.insertBefore(row, beforeNode || null);

			row.rowIndex = i;
			if (previousRow && previousRow.rowIndex !== (row.rowIndex - 1)) {
				// In this case, we are pulling the row from another location in the grid,
				// and we need to readjust the rowIndices from the point it was removed
				this.adjustRowIndices(previousRow);
			}
			return row;
		},
		renderRow: function (value) {
			// summary:
			//		Responsible for returning the DOM for a single row in the grid.
			// value: Mixed
			//		Value to render
			// options: Object?
			//		Optional object with additional options

			var div = document.createElement('div');
			div.appendChild(document.createTextNode(value));
			return div;
		},
		removeRow: function (rowElement, preserveDom) {
			// summary:
			//		Simply deletes the node in a plain List.
			//		Column plugins may aspect this to implement their own cleanup routines.
			// rowElement: Object|DOMNode
			//		Object or element representing the row to be removed.
			// preserveDom: Boolean?
			//		If true, the row element will not be removed from the DOM; this can
			//		be used by extensions/plugins in cases where the DOM will be
			//		massively cleaned up at a later point in time.
			// options: Object?
			//		May be specified with a `rows` property for the purpose of
			//		cleaning up collection tracking (used by `_StoreMixin`).

			rowElement = rowElement.element || rowElement;
			delete this._rowIdToObject[rowElement.id];
			if (!preserveDom) {
				domConstruct.destroy(rowElement);
			}
		},

		row: function (target) {
			// summary:
			//		Get the row object by id, object, node, or event
			var id;

			if (target instanceof this._Row) {
				return target; // No-op; already a row
			}

			if(!target){
				return null;
			}
			if (target.target && target.target.nodeType) {
				// Event
				target = target.target;
			}
			if (target.nodeType) {
				// Row element, or child of a row element
				var object;
				do {
					var rowId = target.id;
					if ((object = this._rowIdToObject[rowId])) {
						return new this._Row(rowId.substring(this.id.length + 5), object, target);
					}
					target = target.parentNode;
				}while (target && target !== this.domNode);
				return;
			}

			if (typeof target === 'object') {
				// Assume target represents a collection item
				id = this.collection.getIdentity(target);
			}
			else {
				// Assume target is a row ID
				id = target;
				target = this._rowIdToObject[this.id + '-row-' + id];
			}
			return new this._Row(id, target, byId(this.id + '-row-' + id));
		},
		cell: function (target) {
			// this doesn't do much in a plain list
			return {
				row: this.row(target)
			};
		},

		_move: function (item, steps, targetClass, visible) {
			var nextSibling, current, element;
			// Start at the element indicated by the provided row or cell object.
			element = current = item.element;
			steps = steps || 1;

			do {
				// Outer loop: move in the appropriate direction.
				if ((nextSibling = current[steps < 0 ? 'previousSibling' : 'nextSibling'])) {
					do {
						// Inner loop: advance, and dig into children if applicable.
						current = nextSibling;
						if (current && (current.className + ' ').indexOf(targetClass + ' ') > -1) {
							// Element with the appropriate class name; count step, stop digging.
							element = current;
							steps += steps < 0 ? 1 : -1;
							break;
						}
						// If the next sibling isn't a match, drill down to search, unless
						// visible is true and children are hidden.
					} while ((nextSibling = (!visible || !current.hidden) &&
						current[steps < 0 ? 'lastChild' : 'firstChild']));
				}
				else {
					current = current.parentNode;
					if (!current || current === this.bodyNode || current === this.headerNode) {
						// Break out if we step out of the navigation area entirely.
						break;
					}
				}
			}while (steps);
			// Return the final element we arrived at, which might still be the
			// starting element if we couldn't navigate further in that direction.
			return element;
		},

		up: function (row, steps, visible) {
			if(!row){
				console.warn('have now row');
				return null;
			}
			// summary:
			//		Returns the row that is the given number of steps (1 by default)
			//		above the row represented by the given object.
			// row:
			//		The row to navigate upward from.
			// steps:
			//		Number of steps to navigate up from the given row; default is 1.
			// visible:
			//		If true, rows that are currently hidden (i.e. children of
			//		collapsed tree rows) will not be counted in the traversal.
			// returns:
			//		A row object representing the appropriate row.  If the top of the
			//		list is reached before the given number of steps, the first row will
			//		be returned.
			if (!row.element) {
				row = this.row(row);
			}
			return this.row(this._move(row, -(steps || 1), 'dgrid-row', visible));
		},
		down: function (row, steps, visible) {
			// summary:
			//		Returns the row that is the given number of steps (1 by default)
			//		below the row represented by the given object.
			// row:
			//		The row to navigate downward from.
			// steps:
			//		Number of steps to navigate down from the given row; default is 1.
			// visible:
			//		If true, rows that are currently hidden (i.e. children of
			//		collapsed tree rows) will not be counted in the traversal.
			// returns:
			//		A row object representing the appropriate row.  If the bottom of the
			//		list is reached before the given number of steps, the last row will
			//		be returned.
			if(!row){
				console.warn('have now row');
				return null;
			}
			if (!row.element) {
				row = this.row(row);
			}
			return this.row(this._move(row, steps || 1, 'dgrid-row', visible));
		},

		scrollTo: function (options) {
			if (typeof options.x !== 'undefined') {
				this.bodyNode.scrollLeft = options.x;
			}
			if (typeof options.y !== 'undefined') {
				this.bodyNode.scrollTop = options.y;
			}
		},

		getScrollPosition: function () {
			return {
				x: this.bodyNode.scrollLeft,
				y: this.bodyNode.scrollTop
			};
		},

		get: function (/*String*/ name /*, ... */) {
			// summary:
			//		Get a property on a List instance.
			//	name:
			//		The property to get.
			//	returns:
			//		The property value on this List instance.
			// description:
			//		Get a named property on a List object. The property may
			//		potentially be retrieved via a getter method in subclasses. In the base class
			//		this just retrieves the object's property.

			var fn = '_get' + name.charAt(0).toUpperCase() + name.slice(1);

			if (typeof this[fn] === 'function') {
				return this[fn].apply(this, [].slice.call(arguments, 1));
			}

			// Alert users that try to use Dijit-style getter/setters so they dont get confused
			// if they try to use them and it does not work
			if (! 1  && typeof this[fn + 'Attr'] === 'function') {
				console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for getting ' + name);
			}

			return this[name];
		},

		set: function (/*String*/ name, /*Object*/ value /*, ... */) {
			//	summary:
			//		Set a property on a List instance
			//	name:
			//		The property to set.
			//	value:
			//		The value to set in the property.
			//	returns:
			//		The function returns this List instance.
			//	description:
			//		Sets named properties on a List object.
			//		A programmatic setter may be defined in subclasses.
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//	|	myObj.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	})
			//		This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

			if (typeof name === 'object') {
				for (var k in name) {
					this.set(k, name[k]);
				}
			}
			else {
				var fn = '_set' + name.charAt(0).toUpperCase() + name.slice(1);

				if (typeof this[fn] === 'function') {
					this[fn].apply(this, [].slice.call(arguments, 1));
				}
				else {
					// Alert users that try to use Dijit-style getter/setters so they dont get confused
					// if they try to use them and it does not work
					if (! 1  && typeof this[fn + 'Attr'] === 'function') {
						console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for setting ' + name);
					}

					this[name] = value;
				}
			}

			return this;
		},

		// Accept both class and className programmatically to set domNode class.
		_getClass: getClass,
		_setClass: setClass,
		_getClassName: getClass,
		_setClassName: setClass,

		_setSort: function (property, descending) {
			// summary:
			//		Sort the content
			// property: String|Array
			//		String specifying field to sort by, or actual array of objects
			//		with property and descending properties
			// descending: boolean
			//		In the case where property is a string, this argument
			//		specifies whether to sort ascending (false) or descending (true)

			this.sort = typeof property !== 'string' ? property :
				[{property: property, descending: descending}];

			this._applySort();
		},

		_applySort: function () {
			// summary:
			//		Applies the current sort
			// description:
			//		This is an extension point to allow specializations to apply the sort differently

			this.refresh();

			if (this._lastCollection) {
				var sort = this.sort;
				if (sort && sort.length > 0) {
					var property = sort[0].property,
						descending = !!sort[0].descending;
					this._lastCollection.sort(function (a, b) {
						var aVal = a[property], bVal = b[property];
						// fall back undefined values to "" for more consistent behavior
						if (aVal === undefined) {
							aVal = '';
						}
						if (bVal === undefined) {
							bVal = '';
						}
						return aVal === bVal ? 0 : (aVal > bVal !== descending ? 1 : -1);
					});
				}
				this.renderArray(this._lastCollection);
			}
		},

		_setShowHeader: function (show) {
			// this is in List rather than just in Grid, primarily for two reasons:
			// (1) just in case someone *does* want to show a header in a List
			// (2) helps address IE < 8 header display issue in List

			var headerNode = this.headerNode;

			this.showHeader = show;

			// add/remove class which has styles for "hiding" header
			domClass.toggle(headerNode, 'dgrid-header-hidden', !show);

			this.renderHeader();
			this.resize(); // resize to account for (dis)appearance of header

			if (show) {
				// Update scroll position of header to make sure it's in sync.
				headerNode.scrollLeft = this.getScrollPosition().x;
			}
		},

		_setShowFooter: function (show) {
			this.showFooter = show;

			// add/remove class which has styles for hiding footer
			domClass.toggle(this.footerNode, 'dgrid-footer-hidden', !show);

			this.resize(); // to account for (dis)appearance of footer
		}
	});

	List.autoIdPrefix = 'dgrid_';

	return List;
});

},
'dstore/Store':function(){
define([
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/has',
	'dojo/when',
	'dojo/Deferred',
	'dojo/_base/declare',
	'dstore/QueryMethod',
	'dstore/Filter',
	'dojo/Evented'
], function (lang, arrayUtil, aspect, has, when, Deferred, declare, QueryMethod, Filter, Evented) {

	// module:
	//		dstore/Store
	/* jshint proto: true */
	// detect __proto__, and avoid using it on Firefox, as they warn about
	// deoptimizations. The watch method is a clear indicator of the Firefox
	// JS engine.
	has.add('object-proto', !!{}.__proto__ && !({}).watch);
	var hasProto = has('object-proto');

	function emitUpdateEvent(type) {
		return function (result, args) {
			var self = this;
			when(result, function (result) {
				var event = { target: result },
					options = args[1] || {};
				if ('beforeId' in options) {
					event.beforeId = options.beforeId;
				}
				self.emit(type, event);
			});

			return result;
		};
	}

	var base = Evented;
	/*=====
	base = [ Evented, Collection ];
	=====*/

	return /*==== Store= ====*/declare(base, {
		constructor: function (options) {
			// perform the mixin
			options && declare.safeMixin(this, options);

			if (this.Model && this.Model.createSubclass) {
				// we need a distinct model for each store, so we can
				// save the reference back to this store on it.
				// we always create a new model to be safe.
				this.Model = this.Model.createSubclass([]).extend({
					// give a reference back to the store for saving, etc.
					_store: this
				});
			}

			// the object the store can use for holding any local data or events
			this.storage = new Evented();
			var store = this;
			if (this.autoEmitEvents) {
				// emit events when modification operations are called
				aspect.after(this, 'add', emitUpdateEvent('add'));
				aspect.after(this, 'put', emitUpdateEvent('update'));
				aspect.after(this, 'remove', function (result, args) {
					when(result, function () {
						store.emit('delete', {id: args[0]});
					});
					return result;
				});
			}
		},

		// autoEmitEvents: Boolean
		//		Indicates if the events should automatically be fired for put, add, remove
		//		method calls. Stores may wish to explicitly fire events, to control when
		//		and which event is fired.
		autoEmitEvents: true,

		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: 'id',

		// queryAccessors: Boolean
		//		Indicates if client-side query engine filtering should (if the store property is true)
		//		access object properties through the get() function (enabling querying by
		//		computed properties), or if it should (by setting this to false) use direct/raw
		// 		property access (which may more closely follow database querying style).
		queryAccessors: true,

		getIdentity: function (object) {
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: String|Number

			return object.get ? object.get(this.idProperty) : object[this.idProperty];
		},

		_setIdentity: function (object, identityArg) {
			// summary:
			//		Sets an object's identity
			// description:
			//		This method sets an object's identity and is useful to override to support
			//		multi-key identities and object's whose properties are not stored directly on the object.
			// object: Object
			//		The target object
			// identityArg:
			//		The argument used to set the identity

			if (object.set) {
				object.set(this.idProperty, identityArg);
			} else {
				object[this.idProperty] = identityArg;
			}
		},

		forEach: function (callback, thisObject) {
			var collection = this;
			return when(this.fetch(), function (data) {
				for (var i = 0, item; (item = data[i]) !== undefined; i++) {
					callback.call(thisObject, item, i, collection);
				}
				return data;
			});
		},
		on: function (type, listener) {
			return this.storage.on(type, listener);
		},
		emit: function (type, event) {
			event = event || {};
			event.type = type;
			try {
				return this.storage.emit(type, event);
			} finally {
				// Return the initial value of event.cancelable because a listener error makes it impossible
				// to know whether the event was actually canceled
				return event.cancelable;
			}
		},

		// parse: Function
		//		One can provide a parsing function that will permit the parsing of the data. By
		//		default we assume the provide data is a simple JavaScript array that requires
		//		no parsing (subclass stores may provide their own default parse function)
		parse: null,

		// stringify: Function
		//		For stores that serialize data (to send to a server, for example) the stringify
		//		function can be specified to control how objects are serialized to strings
		stringify: null,

		// Model: Function
		//		This should be a entity (like a class/constructor) with a 'prototype' property that will be
		//		used as the prototype for all objects returned from this store. One can set
		//		this to the Model from dmodel/Model to return Model objects, or leave this
		//		to null if you don't want any methods to decorate the returned
		//		objects (this can improve performance by avoiding prototype setting),
		Model: null,

		_restore: function (object, mutateAllowed) {
			// summary:
			//		Restores a plain raw object, making an instance of the store's model.
			//		This is called when an object had been persisted into the underlying
			//		medium, and is now being restored. Typically restored objects will come
			//		through a phase of deserialization (through JSON.parse, DB retrieval, etc.)
			//		in which their __proto__ will be set to Object.prototype. To provide
			//		data model support, the returned object needs to be an instance of the model.
			//		This can be accomplished by setting __proto__ to the model's prototype
			//		or by creating a new instance of the model, and copying the properties to it.
			//		Also, model's can provide their own restore method that will allow for
			//		custom model-defined behavior. However, one should be aware that copying
			//		properties is a slower operation than prototype assignment.
			//		The restore process is designed to be distinct from the create process
			//		so their is a clear delineation between new objects and restored objects.
			// object: Object
			//		The raw object with the properties that need to be defined on the new
			//		model instance
			// mutateAllowed: boolean
			//		This indicates if restore is allowed to mutate the original object
			//		(by setting its __proto__). If this isn't true, than the restore should
			//		copy the object to a new object with the correct type.
			// returns: Object
			//		An instance of the store model, with all the properties that were defined
			//		on object. This may or may not be the same object that was passed in.
			var Model = this.Model;
			if (Model && object) {
				var prototype = Model.prototype;
				var restore = prototype._restore;
				if (restore) {
					// the prototype provides its own restore method
					object = restore.call(object, Model, mutateAllowed);
				} else if (hasProto && mutateAllowed) {
					// the fast easy way
					// http://jsperf.com/setting-the-prototype
					object.__proto__ = prototype;
				} else {
					// create a new object with the correct prototype
					object = lang.delegate(prototype, object);
				}
			}
			return object;
		},

		create: function (properties) {
			// summary:
			//		This creates a new instance from the store's model.
			//	properties:
			//		The properties that are passed to the model constructor to
			//		be copied onto the new instance. Note, that should only be called
			//		when new objects are being created, not when existing objects
			//		are being restored from storage.
			return new this.Model(properties);
		},

		_createSubCollection: function (kwArgs) {
			var newCollection = lang.delegate(this.constructor.prototype);

			for (var i in this) {
				if (this._includePropertyInSubCollection(i, newCollection)) {
					newCollection[i] = this[i];
				}
			}

			return declare.safeMixin(newCollection, kwArgs);
		},

		_includePropertyInSubCollection: function (name, subCollection) {
			return !(name in subCollection) || subCollection[name] !== this[name];
		},

		// queryLog: __QueryLogEntry[]
		//		The query operations represented by this collection
		queryLog: [],	// NOTE: It's ok to define this on the prototype because the array instance is never modified

		filter: new QueryMethod({
			type: 'filter',
			normalizeArguments: function (filter) {
				var Filter = this.Filter;
				if (filter instanceof Filter) {
					return [filter];
				}
				return [new Filter(filter)];
			}
		}),

		Filter: Filter,

		sort: new QueryMethod({
			type: 'sort',
			normalizeArguments: function (property, descending) {
				var sorted;
				if (typeof property === 'function') {
					sorted = [ property ];
				} else {
					if (property instanceof Array) {
						sorted = property.slice();
					} else if (typeof property === 'object') {
						sorted = [].slice.call(arguments);
					} else {
						sorted = [{ property: property, descending: descending }];
					}

					sorted = arrayUtil.map(sorted, function (sort) {
						// copy the sort object to avoid mutating the original arguments
						sort = lang.mixin({}, sort);
						sort.descending = !!sort.descending;
						return sort;
					});
					// wrap in array because sort objects are a single array argument
					sorted = [ sorted ];
				}
				return sorted;
			}
		}),

		select: new QueryMethod({
			type: 'select'
		}),

		_getQuerierFactory: function (type) {
			var uppercaseType = type[0].toUpperCase() + type.substr(1);
			return this['_create' + uppercaseType + 'Querier'];
		}

/*====,
		get: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
		},
		put: function (object, directives) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for storing objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		add: function (object, directives) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for creating objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		remove: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
		},
		transaction: function () {
			// summary:
			//		Starts a new transaction.
			//		Note that a store user might not call transaction() prior to using put,
			//		delete, etc. in which case these operations effectively could be thought of
			//		as "auto-commit" style actions.
			// returns: dstore/Store.Transaction
			//		This represents the new current transaction.
		},
		getChildren: function (parent) {
			// summary:
			//		Retrieves the children of an object.
			// parent: Object
			//		The object to find the children of.
			// returns: dstore/Store.Collection
			//		A result set of the children of the parent object.
		}
====*/
	});
});


/*====
	var Collection = declare(null, {
		// summary:
		//		This is an abstract API for a collection of objects, which can be filtered,
		//		sorted, and sliced to create new collections. This is considered to be base
		//		interface for all stores and  query results in dstore. Note that the objects in the
		//		collection may not be immediately retrieved from the underlying data
		//		storage until they are actually accessed through forEach() or fetch().

		filter: function (query) {
			// summary:
			//		Filters the collection, returning a new subset collection
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// returns: Collection
		},
		sort: function (property, descending) {
			// summary:
			//		Sorts the current collection into a new collection, reordering the objects by the provided sort order.
			// property: String|Function
			//		The property to sort on. Alternately a function can be provided to sort with
			// descending?: Boolean
			//		Indicate if the sort order should be descending (defaults to ascending)
			// returns: Collection
		},
		fetchRange: function (kwArgs) {
			// summary:
			//		Retrieves a range of objects from the collection, returning a promise to an array.
			// kwArgs.start: Number
			//		The starting index of objects to return (0-indexed)
			// kwArgs.end: Number
			//		The exclusive end of objects to return
			// returns: Collection
		},
		forEach: function (callback, thisObject) {
			// summary:
			//		Iterates over the query results, based on
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach.
			//		Note that this may executed asynchronously (in which case it will return a promise),
			//		and the callback may be called after this function returns.
			// callback:
			//		Function that is called for each object in the query results
			// thisObject:
			//		The object to use as |this| in the callback.
			// returns:
			//		undefined|Promise
		},
		fetch: function () {
			// summary:
			//		This can be called to materialize and request the data behind this collection.
			//		Often collections may be lazy, and won't retrieve their underlying data until
			//		forEach or fetch is called. This returns an array, or for asynchronous stores,
			//		this will return a promise, resolving to an array of objects, once the
			//		operation is complete.
			//	returns Array|Promise
		},
		on: function (type, listener) {
			// summary:
			//		This registers a callback for notification of when data is modified in the query results.
			// type: String
			//		There are four types of events defined in this API:
			//		- add - A new object was added
			//		- update - An object was updated
			//		- delete - An object was deleted
			// listener: Function
			//		The listener function is called when objects in the query results are modified
			//		to affect the query result. The listener function is called with a single event object argument:
			//		| listener(event);
			//
			//		- The event object as the following properties:
			//		- type - The event type (of the four above)
			//		- target - This indicates the object that was create or modified.
			//		- id - If an object was removed, this indicates the object that was removed.
			//		The next two properties will only be available if array tracking is employed,
			//		which is usually provided by dstore/Trackable
			//		- previousIndex - The previousIndex parameter indicates the index in the result array where
			//		the object used to be. If the value is -1, then the object is an addition to
			//		this result set (due to a new object being created, or changed such that it
			//		is a part of the result set).
			//		- index - The inex parameter indicates the index in the result array where
			//		the object should be now. If the value is -1, then the object is a removal
			//		from this result set (due to an object being deleted, or changed such that it
			//		is not a part of the result set).

		}
	});

	Collection.SortInformation = declare(null, {
		// summary:
		//		An object describing what property to sort on, and the direction of the sort.
		// property: String
		//		The name of the property to sort on.
		// descending: Boolean
		//		The direction of the sort.  Default is false.
	});
	Store.Collection = Collection;

	Store.PutDirectives = declare(null, {
		// summary:
		//		Directives passed to put() and add() handlers for guiding the update and
		//		creation of stored objects.
		// id: String|Number?
		//		Indicates the identity of the object if a new object is created
		// beforeId: String?
		//		If the collection of objects in the store has a natural ordering,
		//		this indicates that the created or updated object should be placed before the
		//		object whose identity is specified as the value of this property. A value of null indicates that the
		//		object should be last.
		// parent: Object?,
		//		If the store is hierarchical (with single parenting) this property indicates the
		//		new parent of the created or updated object.
		// overwrite: Boolean?
		//		If this is provided as a boolean it indicates that the object should or should not
		//		overwrite an existing object. A value of true indicates that a new object
		//		should not be created, the operation should update an existing object. A
		//		value of false indicates that an existing object should not be updated, a new
		//		object should be created (which is the same as an add() operation). When
		//		this property is not provided, either an update or creation is acceptable.
	});

	Store.Transaction = declare(null, {
		// summary:
		//		This is an object returned from transaction() calls that represents the current
		//		transaction.

		commit: function () {
			// summary:
			//		Commits the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the commit.
		},
		abort: function (callback, thisObject) {
			// summary:
			//		Aborts the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the abort.
		}
	});

	var __QueryLogEntry = {
		type: String
			The query type
		arguments: Array
			The original query arguments
		normalizedArguments: Array
			The normalized query arguments
		querier: Function?
			A client-side implementation of the query that takes an item array and returns an item array
	};
====*/

},
'dojo/promise/instrumentation':function(){
define([
	"./tracer",
	"../has",
	"../_base/lang",
	"../_base/array"
], function(tracer, has, lang, arrayUtil){
	function logError(error, rejection, deferred){
		var stack = "";
		if(error && error.stack){
			stack += error.stack;
		}
		if(rejection && rejection.stack){
			stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
		}
		if(deferred && deferred.stack){
			stack += "\n    ----------------------------------------\n" + deferred.stack;
		}
		console.error(error, stack);
	}

	function reportRejections(error, handled, rejection, deferred){
		if(!handled){
			logError(error, rejection, deferred);
		}
	}

	var errors = [];
	var activeTimeout = false;
	var unhandledWait = 1000;
	function trackUnhandledRejections(error, handled, rejection, deferred){
		if(handled){
			arrayUtil.some(errors, function(obj, ix){
				if(obj.error === error){
					errors.splice(ix, 1);
					return true;
				}
			});
		}else if(!arrayUtil.some(errors, function(obj){ return obj.error === error; })){
			errors.push({
				error: error,
				rejection: rejection,
				deferred: deferred,
				timestamp: new Date().getTime()
			});
		}

		if(!activeTimeout){
			activeTimeout = setTimeout(logRejected, unhandledWait);
		}
	}

	function logRejected(){
		var now = new Date().getTime();
		var reportBefore = now - unhandledWait;
		errors = arrayUtil.filter(errors, function(obj){
			if(obj.timestamp < reportBefore){
				logError(obj.error, obj.rejection, obj.deferred);
				return false;
			}
			return true;
		});

		if(errors.length){
			activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
		}else{
			activeTimeout = false;
		}
	}

	return function(Deferred){
		// summary:
		//		Initialize instrumentation for the Deferred class.
		// description:
		//		Initialize instrumentation for the Deferred class.
		//		Done automatically by `dojo/Deferred` if the
		//		`deferredInstrumentation` and `useDeferredInstrumentation`
		//		config options are set.
		//
		//		Sets up `dojo/promise/tracer` to log to the console.
		//
		//		Sets up instrumentation of rejected deferreds so unhandled
		//		errors are logged to the console.

		var usage = has("config-useDeferredInstrumentation");
		if(usage){
			tracer.on("resolved", lang.hitch(console, "log", "resolved"));
			tracer.on("rejected", lang.hitch(console, "log", "rejected"));
			tracer.on("progress", lang.hitch(console, "log", "progress"));

			var args = [];
			if(typeof usage === "string"){
				args = usage.split(",");
				usage = args.shift();
			}
			if(usage === "report-rejections"){
				Deferred.instrumentRejected = reportRejections;
			}else if(usage === "report-unhandled-rejections" || usage === true || usage === 1){
				Deferred.instrumentRejected = trackUnhandledRejections;
				unhandledWait = parseInt(args[0], 10) || unhandledWait;
			}else{
				throw new Error("Unsupported instrumentation usage <" + usage + ">");
			}
		}
	};
});

},
'xdojo/declare':function(){
define([
    'dcl/dcl',
    'module',
    'xide/utils',
    'dojo/_base/declare'
], function (_dcl,module,utils,dDeclare) {


    ////////////////////////////////////////////////////////////////////
    //
    // Extras
    //
    ///////////////////////////////////////////////////////////////////

    function addExtras(handler) {

        /**
         *
         * @param name
         * @param bases {object}
         * @param extraClasses {object[]}
         * @param implmentation
         * @param defaults
         * @returns {*}
         */
        function classFactory(name, bases, extraClasses, implmentation, defaults) {


            var baseClasses = bases != null ? bases : utils.cloneKeys(defaults || {}),
                extras = extraClasses || [],
                _name = name || 'xgrid.Base',
                _implmentation = implmentation || {};

            if (bases) {
                utils.mixin(baseClasses, bases);
            }

            var classes = [];
            for (var _class in baseClasses) {
                var _classProto = baseClasses[_class];
                if (_classProto) {
                    classes.push(baseClasses[_class]);
                }
            }

            classes = classes.concat(extras);

            return handler(_name, classes, _implmentation);
        }

        handler.classFactory = classFactory;

    }


    //now make Dcl working like declare, supporting declaredClass.
    //This could be done via define('module') and then module.id but i don't trust it.
    addExtras(dDeclare);
    return dDeclare;
});
},
'xide/widgets/ActionToolbar4':function(){
/** @module xide/widgets/ActionToolbar4 **/
define([
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/_base/_Widget',
    "xide/mixins/ActionMixin",
    'xaction/ActionContext',
    "xide/model/Path",
    'xlang/i18',
    "xide/widgets/_MenuMixin4",
    "xide/popup"
], function (dcl,types,utils,_XWidget,
             ActionMixin,ActionContext,Path,i18,
             _MenuMixin4,popup){

    var OPEN_DELAY = 200;
    var ContainerClass =  dcl([_XWidget,ActionContext.dcl,ActionMixin.dcl],{
        templateString:'<div attachTo="navigation" class="actionToolbar">'+
        '<nav attachTo="navigationRoot" class="" role="navigation">'+
        '<ul attachTo="navBar" class="nav navbar-nav"/>'+
        '</nav>'+
        '</div>'
    });
    /**
     * @class module:xide/widgets/ActionToolbar4
     */
    var ActionRendererClass = dcl(null,{
        ITEM_TAG : "div",
        CONTAINER_TAG : "div",
        ITEM_CLASS : "actionItem",
        renderTopLevel:function(name,where){
            where = where || $(this.getRootContainer());
            var item =$('<li tabindex="-1" class="dropdown">' +
                '<a href="#" class="dropdown-toggle" data-toggle="dropdown">' + i18.localize(name) +'<b class="caret"></b></a>'+
                '</li>');

            where.append(item);
            return item;
        },
        getRootContainer:function(){
            return this.navBar;
        }
    });
    var Module = dcl([ContainerClass,_MenuMixin4,ActionRendererClass,_XWidget.StoreMixin],{
        declaredClass:'xide.widgets.Actiontoolbar',
        target:null,
        hideSubsFirst:true,
        visibility: types.ACTION_VISIBILITY.ACTION_TOOLBAR,
        actionFilter:{
            quick:true
        },
        _renderItem:function(item,data,$menu,action, owner, label, icon, visibility, showKeyCombo, lazy){
            var self = this;
            var labelLocalized = self.localize(label);
            var actionType = visibility.actionType || action.actionType;
            var parentAction = action.getParent ? action.getParent() : null;
            var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
            var keyComboString = ' \n';
            var element = null;
            if (action.keyboardMappings && showKeyCombo !== false) {
                var mappings = action.keyboardMappings;
                var keyCombos = mappings[0].keys;
                if (keyCombos && keyCombos.length) {
                    keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                }
            }

            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                element = '<li class="" >';
                var id = action._store.id + '_' + action.command + '_' + self.id;
                var checked = action.get('value');
                //checkbox-circle
                element += '<div class="action-checkbox checkbox checkbox-success ">';
                element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                element += '<label for="' + id + '">';
                element += self.localize(data.text);
                element += '</label>';
                element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                element += '</div>';

                $menu.addClass('noclose');
                var result = $(element);
                var checkBox = result.find('INPUT');
                checkBox.on('change', function (e) {
                    action._originReference = data;
                    action._originEvent = e;
                    action.set('value', checkBox[0].checked);
                    action._originReference = null;
                });
                self.setVisibilityField(action, 'widget', data);
                return result;
            }
            closeOnClick === false && $menu.addClass('noclose');
            if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                var value = action.value || action.get('value');
                var parentValue = parentAction.get('value');
                if (value == parentValue) {
                    icon = 'fa fa-check';
                }
            }
            var title = data.text || labelLocalized || self.localize(action.title);

            //default:
            element = '<li class="" title="' + title + ' ' + keyComboString + '">';
            var _icon = data.icon || icon;
            //icon
            if (typeof _icon !== 'undefined') {
                //already html string
                if (/<[a-z][\s\S]*>/i.test(_icon)) {
                    element += _icon;
                } else {
                    element += '<span style="" class="icon ' + _icon + '"/> ';
                }
            }
            element +='<a class="">';
            element += data.text;
            element += '</a></li>';
            self.setVisibilityField(action, 'widget', data);
            return $(element);
        },
        init2: function(opts){
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root,'click',null,function(e){
                if(!self.isOpen){
                    return;
                }
                self.isOpen=false;
                self.onClose(e)
                $('.dropdown-context').css({
                    display:''
                }).find('.drop-left').removeClass('drop-left');
            });
            if(options.preventDoubleContext){
                this.__on(root,'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }

            function correctPosition(_root,$sub){
                var level = 0;
                var _levelAttr = $sub.attr('level');
                if(!_levelAttr){
                    _levelAttr = parseInt($sub.parent().attr('level'),10) || 0;
                }

                if(_levelAttr===0){
                    $sub.css({
                        left:0
                    });
                }
                var parent = _root.parent();
                var parentTopAbs = parent.offset().top;
                var rootOffset = _root.offset();
                var rootPos = _root.position();
                var rootHeight = _root.height();
                var parentDelta = parentTopAbs - rootOffset.top;
                var newTop = (rootPos.top + rootHeight) + parentDelta;
                var offset = 0;
                if(_levelAttr!==0) {
                    newTop += offset;
                }
                $sub.css({
                    top:0
                });
                var subHeight = $sub.height() + 0;
                var totalH = $('html').height();
                var pos = $sub.offset();
                var posWrapper = $sub.offset();
                var overlapYDown = totalH - (pos.top + subHeight);
                if((pos.top + subHeight) > totalH){
                    $sub.css({
                        top: overlapYDown - 30
                    });
                }
                ////////////////////////////////////////////////////////////
                var subWidth = $sub.width(),
                    subLeft = $sub.offset().left,
                    collision = (subWidth+subLeft) > window.innerWidth;

                if(collision){
                    $sub.addClass('drop-left');
                }
            }

            function mouseEnterHandler(e){
                var _root = $(e.currentTarget);
                var $sub = _root.find('.dropdown-context-sub:first');
                var didPopup = false;
                if ($sub.length === 0) {
                    $sub = _root.data('sub');
                    if($sub){
                        didPopup = true;
                    }else {
                        return;
                    }
                }

                var data = $sub.data('data');
                var level = data ? data[0].level : 0;
                var isFirst = level ===1;

                $sub.css('display', 'none');
                $sub.data('left',false);
                _root.data('left',false);
                if(isFirst) {
                    $sub.css('display', 'initial');
                    $sub.css('position', 'initial');
                    function close() {
                        $sub.data('open',false);
                        popup.close($sub[0]);
                    }
                    if(_root.data('didSetup')!==true){
                        _root.data('didSetup',true);
                        _root.data('sub',$sub);
                        _root.on('mouseleave', function (e) {
                            var _thisSub = _root.data('sub');
                            var next = e.toElement;
                            if(next==_thisSub[0] || $.contains(_thisSub[0],next)){
                                return;
                            }
                            close();
                        });
                    }
                    if (!didPopup) {
                        _root.data('sub', $sub);
                        $sub.data('owner', self);
                        if(!$sub.data('didSetup')){
                            $sub.data('root',_root);
                            $sub.on('mouseleave', function () {
                                $sub.data('left',true);
                                close();

                            });
                            $sub.data('didSetup',true);
                            $sub.on('mouseenter', function(e){
                                $sub.data('entered',true);
                            });
                        }
                    }
                    function open() {

                        if($sub.data('open')){
                            return;
                        }
                        $sub.data('open',true);
                        var wrapper = popup.open({
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            extraClass: 'ActionToolbar',
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                close();
                            },
                            onClose: function () {
                                _root.data('left',true);
                                close();
                            }
                        });
                        correctPosition(_root,$sub,$(wrapper));
                    }
                    open();
                    /*
                     //clearTimeout($sub.data('openTimer'));
                     return;
                     $sub.data('openTimer',setTimeout(function(){
                     if($sub.data('left')!==true) {

                     }else{
                     console.log('left');
                     $sub.css('display', 'none');
                     }
                     },OPEN_DELAY));
                     return;
                     */
                }else{
                    $sub.css('display','block');
                    if(!$sub.data('didSetup')){
                        $sub.data('didSetup',true);
                        $sub.on('mouseleave',function(){
                            $sub.css('display','');
                            $sub.data('left',true);

                        });
                    }
                    if(!_root.data('didSetup')){
                        _root.data('didSetup',true);
                        _root.on('mouseleave',function(){
                            _root.data('left',true);
                            $sub.css('display','');

                        });
                    }
                }
                var autoH = $sub.height() + 0;
                var totalH = $('html').height();
                var pos = $sub.offset();
                var overlapYDown = totalH - (pos.top + autoH);
                if ((pos.top + autoH) > totalH) {
                    $sub.css({
                        top: overlapYDown - 30
                    }).fadeIn(options.fadeSpeed);
                }
                ////////////////////////////////////////////////////////////
                var subWidth = $sub.width(),
                    subLeft = $sub.offset().left,
                    collision = (subWidth + subLeft) > window.innerWidth;

                if (collision) {
                    $sub.addClass('drop-left');
                }
            }
            this.__on(root,'mouseenter', '.dropdown-submenu', mouseEnterHandler.bind(this));
        },
        resize:function(){
            this._height = this.$navBar.height();
            if (this._height > 0){
                this.$navBar.css('width',this.$navigation.width());
                this.$navigationRoot.css('width',this.$navigation.width());
                this.$navigation.css('height',this._height);
                this.$navigationRoot.css('height', this._height);
            }
        },
        destroy:function(){
            utils.destroy(this.$navBar[0]);
            utils.destroy(this.$navigation[0]);
        },
        buildMenu:function (data, id, subMenu,update) {
            var subClass = (subMenu) ? ' dropdown-context-sub' : ' scrollable-menu ',
                menuString = '<ul aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>',
                $menu = update ? (this._rootMenu || this.$navBar || $(menuString)) : $(menuString);

            if(!subMenu){
                this._rootMenu = $menu;
            }
            $menu.data('data',data);
            return this.buildMenuItems($menu, data, id, subMenu);
        },
        setActionStore: function (store, owner,subscribe,update,itemActions) {
            if(!update && store && this.store && store!=this.store){
                this.removeCustomActions();
            }

            if(!update){
                this._clear();
                this.addActionStore(store);
            }

            if(!store){
                return;
            }

            this.store = store;

            var self = this,
                visibility = self.visibility,
                rootContainer = $(self.getRootContainer());

            var tree = update ? self.lastTree : self.buildActionTree(store,owner);

            var allActions = tree.allActions,
                rootActions = tree.rootActions,
                allActionPaths = tree.allActionPaths,
                oldMenuData = self.menuData;

            if(subscribe!==false) {
                if(!this['_handleAdded_' + store.id]) {
                    this.addHandle('added', store._on('onActionsAdded', function (actions) {
                        self.onActionAdded(actions);
                    }));

                    this.addHandle('delete', store.on('delete', function (evt) {
                        self.onActionRemoved(evt);
                    }));
                    this['_handleAdded_' + store.id]=true;
                }
            }

            // final menu data
            var data = [];
            if(!update) {
                _.each(tree.root, function (menuActions, level) {
                    var lastGroup = '';
                    _.each(menuActions, function (command) {
                        var action = self.getAction(command, store);
                        var isDynamicAction = false;
                        if (!action) {
                            isDynamicAction = true;
                            action = self.createAction(command);
                        }
                        if (action) {

                            var renderData = self.getActionData(action),
                                icon = renderData.icon,
                                label = renderData.label,
                                visibility = renderData.visibility,
                                group = renderData.group,
                                lastHeader = {
                                    header: ''
                                };


                            if (visibility === false) {
                                return;
                            }

                            /*
                             if (!isDynamicAction && group && groupedActions[group] && groupedActions[group].length >= 1) {
                             //if (lastGroup !== group) {
                             var name = groupedActions[group].length >= 2 ? i18.localize(group) : "";
                             lastHeader = {divider: name,vertial:true};
                             data.push(lastHeader);
                             lastGroup = group;
                             //}
                             }
                             */

                            var item = self.toMenuItem(action, owner, '', icon, visibility || {}, false);
                            data.push(item);
                            item.level = 0;
                            visibility.widget = item;

                            self.addReference(action, item);

                            var childPaths = new Path(command).getChildren(allActionPaths, false),
                                isContainer = childPaths.length > 0;

                            function parseChildren(command, parent) {
                                var childPaths = new Path(command).getChildren(allActionPaths, false),
                                    isContainer = childPaths.length > 0,
                                    childActions = isContainer ? self.toActions(childPaths, store) : null;
                                if (childActions) {
                                    var subs = [];
                                    _.each(childActions, function (child) {
                                        var _renderData = self.getActionData(child);
                                        var _item = self.toMenuItem(child, owner, _renderData.label, _renderData.icon, _renderData.visibility,false);
                                        var parentLevel = parent.level || 0;
                                        _item.level = parentLevel + 1;
                                        self.addReference(child, _item);
                                        subs.push(_item);
                                        var _childPaths = new Path(child.command).getChildren(allActionPaths, false),
                                            _isContainer = _childPaths.length > 0;
                                        if (_isContainer) {
                                            parseChildren(child.command, _item);
                                        }
                                    });
                                    parent.subMenu = subs;
                                }
                            }
                            parseChildren(command, item);
                            self.buildMenuItems(rootContainer, [item], "-" + new Date().getTime());

                        }
                    });
                });
                self.onDidRenderActions(store, owner);
                this.menuData = data;
            }else{
                if(itemActions || !_.isEmpty(itemActions)) {

                    _.each(itemActions, function (newAction) {
                        if (newAction) {
                            var action = self.getAction(newAction.command);
                            if (action){


                                var renderData = self.getActionData(action),
                                    icon = renderData.icon,
                                    label = renderData.label,
                                    aVisibility = renderData.visibility,
                                    group = renderData.group,
                                    item = self.toMenuItem(action, owner, label, icon, aVisibility || {},null,false);

                                if(aVisibility.widget){
                                    return;
                                }

                                aVisibility.widget = item;

                                self.addReference(newAction, item);

                                if(!action.getParentCommand){
                                    return;
                                }
                                var parentCommand = action.getParentCommand();
                                var parent = self._findParentData(oldMenuData,parentCommand);
                                if(parent && parent.subMenu){
                                    parent.lazy = true;
                                    parent.subMenu.push(item);
                                }else{
                                    oldMenuData.splice(0, 0, item);
                                }
                            } else {
                                console.error('cant find action ' + newAction.command);
                            }
                        }
                    });
                    self.buildMenu(oldMenuData, self.id,null,update);
                }
            }
            this.resize();
        },
        startup:function(){
            this.correctSubMenu = true;
            this.init2({
                preventDoubleContext: false
            });
            this.menu = this.$navigation;
        }
    });
    dcl.chainAfter(Module,'destroy');
    return Module;
});


},
'xaction/DefaultActions':function(){
/** @module xaction/DefaultActions **/
define([
    "dcl/dcl",
    'dcl/inherited',
    "xdojo/declare",
    'xide/types',
    'xide/utils',
    'xlang/i18'
], function (dcl,inherited,declare,types,utils,i18) {
    /**
     * @mixin module:xide/action/DefaultActions
     */
    var Module = declare("xaction/DefaultActions", null , {});
    /**
     *
     * @param title
     * @param command
     * @param group
     * @param icon
     * @param handler
     * @param accelKey
     * @param keyCombo
     * @param keyProfile
     * @param keyTarget
     * @param keyScope
     * @param mixin
     * @returns {{title: *, command: *, group: *, icon: *, handler: *, accelKey: *, keyCombo: *, keyProfile: *, keyTarget: *, keyScope: *}}
     */
    Module.createActionParameters=function(title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope,mixin){
        return {
            title:title,
            command: command,
            group: group,
            icon: icon,
            handler: handler,
            accelKey: accelKey,
            keyCombo: keyCombo,
            keyProfile: keyProfile,
            keyTarget: keyTarget,
            keyScope: keyScope,
            mixin:mixin
        };
    };
    /**
     *
     * @param label
     * @param command
     * @param icon
     * @param keycombo
     * @param tab
     * @param group
     * @param filterGroup
     * @param onCreate
     * @param handler
     * @param mixin
     * @param shouldShow
     * @param shouldDisable
     * @param container
     * @returns {*}
     */
    var createAction = function(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,container){
        if(keycombo) {
            if (_.isString(keycombo)) {
                keycombo = [keycombo];
            }
        }

        mixin = utils.mixin({
            filterGroup:filterGroup || "item|view",
            tab:tab||'File',
            onCreate: onCreate || function (action){},
            shouldShow:shouldShow||function(){return true;},
            shouldDisable:shouldDisable||function(){return false;}
        },mixin);

        var _action = Module.createActionParameters(
            label,
            command,
            group || 'File',//Group
            icon, handler || null, "", keycombo, null, container, null, mixin);

        utils.mixin(_action,mixin);

        return _action;
    };

    /**
     * Find action in permission
     * @param what
     * @returns {boolean}
     */
    function hasAction(permissions,what){
        return _.contains(permissions,what);
    }

    /**
     * After action default handler, trys:
     * - this::onAfterAction
     * - emit onAfterAction
     *
     * @param dfdResult
     * @param event
     * @param action
     * @private
     */
    function _afterAction(dfdResult,event,action) {
        var who = this;
        // call onAfterAction with this results
        var onAfterActionDfd = null;
        who.onAfterAction && (onAfterActionDfd = who.onAfterAction(action, dfdResult, event));

        who._emit && who._emit('onAfterAction', {
            action: action,
            result: dfdResult,
            source: who,
            afterAction: onAfterActionDfd
        });
    }
    /**
     * Default handler, does
     * - try this::runAction || action#handler
     * - call afterAction
     *
     * As last cal
     * @param action {module:xaction/ActionModel}
     * @param event
     */
    function defaultHandler(action,event){
        var actionDfd,
            who = this;

        who && who.onBeforeAction && who.onBeforeAction(action);
        if(who.runAction){
            actionDfd = who.runAction.apply(who,[action,null,event]);
        }else if(action.handler){
            actionDfd = action.handler.apply(who,[action,null,event]);
        }
        if(actionDfd && actionDfd.then){
            actionDfd.then(function(actionResult){
                _afterAction.apply(who,[actionResult,event,action]);
            });

        }else{
            _afterAction.apply(who,[actionDfd,event,action]);
        }
        return actionDfd;
    }

    /**
     *
     * @param permissions
     * @param grid
     * @param owner
     * @returns {Array}
     */
    function getDefaultActions(permissions,grid,owner){
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultEmptySelection(selection,reference,visibility){
            selection = selection || grid ? grid.getSelection() : [];

            if(!selection || !selection.length){
                return true;
            }
            return false;
        }
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultFileOnly(selection,reference,visibility){

            if(shouldDisableDefaultEmptySelection.apply(this,arguments)){
                return true;
            }
            selection = selection || grid ? grid.getSelection() : [];

            if(selection && selection[0].isDir === true){
                return true;
            }
            return false;
        }

        var root = 'File/',
            thiz = this,
            renderActions = [],
            VISIBILITY = types.ACTION_VISIBILITY,
            result = [],
            ACTION = types.ACTION,
            ACTION_ICON = types.ACTION_ICON,
            creator = owner || grid;

        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         */
        function addAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable){
            var action = null;
            mixin = mixin || {};
            utils.mixin(mixin,{owner:owner || grid});

            if(mixin.addPermission || hasAction(permissions,command)){

                handler = handler || defaultHandler;

                action = createAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,grid.domNode);

                if(action) {
                    if (owner && owner.addAction) {
                        owner.addAction(null, action);
                    }
                    result.push(action);
                }
            }
        }
        if(hasAction(permissions, ACTION.CLIPBOARD) && grid.getClipboardActions){
            result.push(creator.createAction({
                label: 'Clipboard',
                command: 'Edit/Clipboard',
                icon: 'fa-clipboard',
                tab: 'Edit',
                group: 'Clipboard',
                mixin:{
                    addPermission:true,
                    dynamic:true,
                    quick:true
                },
                onCreate:function(action){
                    action.setVisibility(VISIBILITY.RIBBON,{
                        expand:true,
                        tab:"File"
                    });
                }
            }));

            result = result.concat(grid.getClipboardActions(addAction));
        }

        result.push(creator.createAction({
            label: 'Show',
            command: 'View/Show',
            icon: 'fa-eye',
            tab: 'View',
            group: 'Show',
            mixin:{
                addPermission:true,
                dynamic:true
            },
            onCreate:function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }
        }));


        if(hasAction(permissions,ACTION.LAYOUT) && grid.getRendererActions){
            result = result.concat(grid.getRendererActions());
        }

        if(hasAction(permissions,ACTION.COLUMNS) && grid.getColumnHiderActions){
            result = result.concat(grid.getColumnHiderActions(permissions));
        }
        ///////////////////////////////////////
        //
        //  Open/Edit
        //
        //
        result.push(creator.createAction({
            label: 'Edit',
            command: 'File/Edit',
            icon: ACTION_ICON.EDIT,
            tab: 'Home',
            group: 'Open',
            keycombo: ['f4', 'enter','dblclick'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultFileOnly
        }));


        ///////////////////////////////////////
        //
        //  Organize
        //
        result.push(creator.createAction({
            label: 'Delete',
            command: 'File/Delete',
            icon: ACTION_ICON.DELETE,
            tab: 'Home',
            group: 'Organize',
            keycombo: ['f8','delete'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultEmptySelection
        }));

        addAction('Rename','File/Rename','fa-edit',['f2'],'Home','Organize','item',null,null,null,null,shouldDisableDefaultEmptySelection);

        result.push(creator.createAction({
            label: 'Reload',
            command: 'File/Reload',
            icon: ACTION_ICON.RELOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl l'],
            mixin:{
                quick:true
            }
        }));
        addAction('Create archive','File/Compress',ACTION_ICON.COMPRESS,['ctrl z'],'Home','Organize','item|view',null,null,null,null,shouldDisableDefaultEmptySelection);

        ///////////////////////////////////////
        //
        //  File
        //
        addAction('Extract','File/Extract',ACTION_ICON.EXTRACT,['ctrl e'],'Home','File','item|view',null,null,null,null,function(){
            return true;
            //return shouldDisableDefaultFileOnly.apply(this,arguments);
        });

        result.push(creator.createAction({
            label: 'Download',
            command: 'File/Download',
            icon: ACTION_ICON.DOWNLOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl down'],
            mixin:{
                quick:true
            }
        }));

        //////////////////////////////////////////
        //
        //  New
        //
        if(hasAction(permissions,ACTION.NEW_DIRECTORY)|| hasAction(permissions,ACTION.NEW_FILE)) {

            addAction('New','File/New','fa-magic',null,'Home','New','item|view',null,null,{},null,null);
/*
            result.push(creator.createAction({
                label: 'New',
                command: 'File/New',
                icon: 'fa-magic',
                tab: 'Home',
                group: 'File',
                keycombo: ['ctrl down'],
                mixin:{
                    quick:true
                }
            }));*/

        }
        addAction('New Folder',ACTION.NEW_DIRECTORY,'fa-folder',['f7'],'Home','New','item|view',null,null,{quick:true},null,null);
        addAction('New File',ACTION.NEW_FILE,'el-icon-file',['ctrl f4'],'Home','New','item|view',null,null,{quick:true},null,null);


        //////////////////////////////////////////
        //
        //  Preview
        //
        if(hasAction(permissions,ACTION.PREVIEW)) {
            result.push(creator.createAction({
                label: 'Preview',
                command: 'File/Preview',
                icon: 'fa-eye',
                tab: 'Home',
                group: 'Open',
                keycombo: ['f3'],
                mixin:{
                    quick:true
                },
                shouldDisable:shouldDisableDefaultFileOnly
            }));
        }

        ///////////////////////////////////////
        //
        //  Selection
        //
        if(hasAction(permissions,ACTION.SELECTION)) {
            result.push(createAction('Select', 'File/Select', 'fa-hand-o-up', null, 'Home', 'Select', 'item|view', function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }, null, null, null, null,grid.domNode));

            var _mixin = {
                    owner:owner || grid
                },
                container = grid.domNode;

            result.push(createAction('Select all', 'File/Select/All', 'fa-th', ['ctrl a'], 'Home', 'Select', 'item|view', null, function(){
                grid.selectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Select none', 'File/Select/None', 'fa-square-o', 'ctrl d', 'Home', 'Select', 'item|view', null, function(){
                grid.deselectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Invert selection', 'File/Select/Invert', 'fa-square', ['ctrl i'], 'Home', 'Select', 'item|view', null, function(){
                grid.invertSelection();
            }, _mixin, null, null,container));
        }
        return result;
    }

    Module.createAction = createAction;
    Module.hasAction = hasAction;
    Module.getDefaultActions = getDefaultActions;
    Module.defaultHandler = defaultHandler;

    return Module;
});
},
'dojo/_base/connect':function(){
define(["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

 1  && lang.mixin(dojo, connect);
return connect;

});



},
'xide/Document':function(){
/** @module xide/Document **/
define([
    'xdojo/declare',
    "xide/utils",
    "dojo/window",
    "xide/Template",
    "xide/widgets/TemplatedWidgetBase"
], function (declare, utils, windowUtils, Template, TemplatedWidgetBase) {
    /**
     * Widget which wraps a templated document in a iFrame. It resolves variables into the final template.
     * have been loaded.
     *
     * @class module:xide/Document
     * @extends module:xide/widgets/TemplatedWidgetBase
     */
    return declare("xide/Document", [TemplatedWidgetBase], {
        document: null,
        templateString: "<div style='width: inherit; height: inherit'></div>",
        template: '',
        iframeattrs: {
            'class': 'silhouetteiframe_iframe'
        },
        resourceVariables: {},
        variableDelimiters: {
            begin: '{{',
            end: '}}'
        },
        templateArguments: {
            resourceDelegate: null,
            baseUrl: dojo.baseUrl,

            //this.ctx
            ctx: null,
            getDependencies: function () {
                return [];
            },
            resourceVariables: {
                requireUrl: dojo.baseUrl + 'ibm-js/requirejs/require.js'
            },
            bodyStyle: {
                width: "100%",
                height: "100%",
                visibility: "visible",
                margin: "0"
            },
            bootstrapModules: ""
        },
        getDocument: function () {
            return this.document;
        },
        getGlobal: function () {
            var doc = this.getDocument();
            return doc ? windowUtils.get(doc) : null;
        },
        startup: function () {
            var templateInstance = new Template(this.templateArguments),
                templateContent = templateInstance.resolve(this.template, this.resourceVariables, this.variableDelimiters),
                frame = utils.create("iframe", this.iframeattrs, this.domNode);

            try {
                var doc = frame.contentDocument || frame.contentWindow.document,
                    thiz = this;

                doc.open();
                doc.write(templateContent);
                doc.close();
                doc.onreadystatechange = function (state) {
                    try {
                        var state = doc.readyState;
                        if (state == 'interactive') {
                        } else if (state == 'complete') {
                            thiz._emit('ready', {
                                doc: doc,
                                global: thiz.getGlobal()
                            });
                        }
                    }catch(e){
                        console.error(e);
                    }

                };
                this.document = doc;

            } catch (e) {
                console.error('error creating document ' + e, e);
            }
        }
    });
});
},
'xide/debug':function(){
define([
    'xdojo/declare',
    'dojo/has',
    'xdojo/has!debug?xide/serverDebug'
],function(declare,has,serverDebug){
	var Module = declare("xide.debug", null,{});

    if( false ) {

        function displayServerDebugData(data){
            serverDebug && serverDebug.logError(data);
        }

        window.xappServerDebug = displayServerDebugData;

        var callback = function (stackframes) {
            var stringifiedStack = stackframes.map(function (sf) {
                return sf.toString();
            }).join('\n');
            console.log(stringifiedStack);
        };

        var errback = function (err) {
            console.log(err.message);
        };


        window.onerror = function (msg, file, line, col, error) {
            StackTrace.fromError(error).then(callback)['catch'](errback);
        };
        if (!window.logError) {
            window.logError = function (e, message) {
                console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
                if (typeof 'StackTracke' === 'undefined') {
                    var stack = e.stack;
                    stack = stack.split('\n').map(function (line) {
                        return line.trim();
                    });
                    stack.splice(stack[0] == 'Error' ? 2 : 1);
                    console.log(stack.join('\n'));
                } else {
                    StackTrace.fromError(e).then(callback)['catch'](errback);

                }
            }
        } else {
            console.log('logError already created');
        }
    }else{
        window.onerror = function (msg, file, line, col, error) {
            console.error(msg, error);
        };
        window.logError = function (e, message) {
            console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
        }
    }
    return Module;
});
},
'xgrid/Focus':function(){
define([
    "xdojo/declare",
    "xide/types",
    "xide/utils"
], function (declare,types,utils) {

    var Implementation = {
        _focused:false,
        _detectFocus:null,
        _detectBlur:null,
        destroy:function(){
            this.inherited(arguments);
            window.removeEventListener('focus', this._detectFocus, true);
            window.removeEventListener('blur', this._detectBlur, true);
        },
        _onBlur:function(){
        },
        set:function(what,value){
            if(what=='focused'){
                this._onFocusChanged(value);
              }
            return this.inherited(arguments);
        },
        _onFocusChanged:function(focused,type){
            if(this._focused && !focused){
                this._onBlur();
            }
            if(!this._focused && focused){
                this._emit(types.EVENTS.ON_VIEW_SHOW,this);
            }
            this._focused = focused;
            this.highlight  && this.highlight(focused);
        },
        getFocused:function(domNode){
            if(this._focusedNode){
                var row = this.row(this._focusedNode);
                if(row){
                    return row[domNode? 'element' : 'data' ];
                }
            }
            return null;
        },
        startup:function(){
            this.inherited(arguments);
            var thiz = this,
                node = thiz.domNode.parentNode;


            //@TODO: /active=true
            this.headerNode.tabIndex=-1;
            this._focused  = true;
        }

    };
    //package via declare
    var _class = declare('xgrid.Focus',null,Implementation);
    _class.Implementation = Implementation;
    return _class;
});
},
'xfile/views/UploadMixin':function(){
define([
    'xdojo/declare',
    'xide/utils',
    'xide/types',
    "dojo/promise/all"
], function (declare, utils, types, all) {

    return declare("xfiles.views.UploadMixin", null, {
        cssClass: 'uploadFilesList droparea dropareaHover',
        __currentDragOverRow: null,
        __currentDragOverTimer: null,
        __currentDragOverTimeRow: null,
        buildRendering: function () {
            this.inherited(arguments);
            $(this.domNode).addClass(this.cssClass);
        },
        _createUploadItemTemplate: function (name, progress, obj) {
            var _textClass = obj.failed ? 'text-danger' : 'text-info';
            return '<div class="" style="position: relative;margin: 0.1em;height: auto">' +

                '<div style="margin:0;vertical-align: middle;padding: 1px;" class="progress" role="progressbar" aria-valuemin="0" aria-valuemax="100">' +
                '<div class="progress-bar progress-bar-info" style="width:' + progress + ';background-color: rgba(102, 161, 179, 0.35);height:auto;magin:0;">' +
                '<span class="' + _textClass + '" style="left: 0px">' + name + '</span>' +
                '</div>' +
                '</div>' +
                '</div>';
        },
        _createUploadItems: function (files) {

            var thiz = this;
            var store = this.collection,
                selectedRenderer = thiz.selectedRenderer;

            var parent = this.getCurrentFolder();
            if (this.__currentDragOverRow) {
                parent = this.__currentDragOverRow.data;
            }
            function createItem(file) {
                var _item = {
                    sizeBytes: utils.humanFileSize(file.size),
                    size: utils.humanFileSize(file.size),
                    name: file.name,
                    type: file.type,
                    path: parent.path + '/' + file.name + '__uploading__' + Math.random(2),
                    isDir: false,
                    mount: parent.mount,
                    parent: parent.path,
                    progress: 0,
                    isUpload: true,
                    modified: file.lastModified / 1000,
                    renderColumn: function (field, value, obj) {

                        if (field === 'name') {
                            return thiz._createUploadItemTemplate(obj.name, obj.progress + '%', obj);
                        }
                        if (field === 'sizeBytes') {
                            if (obj.progress < 100) {
                                return utils.humanFileSize(obj.loaded) + ' of ' + utils.humanFileSize(obj.total);
                            }
                        }
                    }
                }
                //_item._S = store;
                store.putSync(_item);
                _item = store.getSync(_item.path);
                file._item = _item;
                return _item;
            }

            var items = [];
            _.each(files, function (file) {
                items.push(createItem(file));
            });
            return items;

        },
        _onAllUploaded: function (files) {
            var total = 0, items = this._toUploadItems(files),
                thiz = this;
            _.each(items, function (file) {
                var item = file._store ? file : file._item;
                if (item) {
                    item.progress = item.failed ? 0 : 100;
                    item.refresh();
                    setTimeout(function () {
                        item.remove();
                    }, 1);
                }
            });
            setTimeout(function () {
                thiz.runAction(types.ACTION.RELOAD).then(function () {
                });
            }, 1);
        },
        _onBrowserFilesDropped: function (panel, files, view) {
            var fm = this.ctx.getFileManager();
            var parent = panel.getCurrentFolder();
            if (this.__currentDragOverRow) {
                parent = this.__currentDragOverRow.data;
            }
            var dst = parent;
            var items = this._createUploadItems(files);
            return fm.upload(files, dst.mount, dst ? dst.path : './tmp', panel, view);
        },
        _onUploadFailed: function (uploadItem) {
            if (!uploadItem) {
                return;
            }
            uploadItem.failed = true;
            uploadItem.done = true;
        },
        _onSomeFileUploaded: function (uploadItem) {
            var thiz = this
            if (uploadItem) {
                uploadItem.progress = 100;
                uploadItem.done = true;
                uploadItem.renderColumn = null;
                uploadItem.renderRow = null;
                uploadItem.refresh();
                setTimeout(function () {
                    thiz.runAction(types.ACTION.RELOAD).then(function () {
                    });
                    uploadItem.remove();
                }, 1);
            }
            return true;

        },
        _toUploadItems: function (files) {
            var items = [];
            _.each(files, function (_file) {
                _.each(_file, function (file) {
                    items.push(file);
                });
            });
            return items;

        },
        _toUploadStoreItem: function (data) {
            var file = data.file,
                storeItem = file._item;
            return storeItem;

        },
        onBrowserFilesDropped: function (view, files) {
            var dfds = this._onBrowserFilesDropped(this, files, view),
                thiz = this,
                items = thiz._toUploadItems(files),
                isSingleUpload = items.length == 1;
            all(dfds).then(this._onAllUploaded.bind(this, [files]));
            function check() {
                var done = 0;
                _.each(items, function (item) {
                    item.done && done++;
                });
                done == items.length && thiz._onAllUploaded(files);
            }

            _.each(dfds, function (dfd) {
                dfd.then(function (data) {
                    //only refresh item if its a multi upload
                    !isSingleUpload && thiz._onSomeFileUploaded(thiz._toUploadStoreItem(data)) && check();
                }, function (data) {

                    thiz._onUploadFailed(thiz._toUploadStoreItem(data));
                    isSingleUpload && thiz._onAllUploaded(files);
                    !isSingleUpload && check();
                }, function (data) {

                    var computableEvent = data.progress,
                        item = data.item,
                        file = item.file,
                        storeItem = file._item,
                        percentage = Math.round((computableEvent.loaded * 100) / computableEvent.total);

                    if (storeItem) {
                        storeItem.progress = percentage;
                        storeItem.loaded = computableEvent.loaded;
                        storeItem.total = computableEvent.total;
                        storeItem.refresh();
                    }
                });
            });
        },
        onBrowserUrlDropped: function (srcView, url) {
            if (this.delegate && this.delegate.onBrowserUrlDropped) {
                this.delegate.onBrowserUrlDropped(this, url);
            }
        },
        dragEnter: function (e) {
            e.preventDefault();
        },
        dragLeave: function (e) {
        },
        dragOver: function (e) {
            e.preventDefault();
            if (!this.row) {
                return;
            }

            var self = this,
                row = this.row(e),
                oldRow = this.__currentDragOverRow,
                oldItem = oldRow ? oldRow.data : null,
                current = row ? row.data : null,
                isFolder = current ? current.directory == true : false;

            if (this.__currentDragOverRow) {
                $(this.__currentDragOverRow.element).removeClass('dgrid-focus');
            }

            if (row && row.element && row.data && row.data.directory === true) {
                if (!this.__currentDragOverTimer) {
                    self.__currentDragOverTimeRow = row;
                    //set up timer
                    self.__currentDragOverTimer = setTimeout(function () {
                        var _last = self.__currentDragOverTimeRow.data;
                        if (_last && oldItem && _last == oldItem) {
                            self.__currentDragOverTimeRow = null;
                            self.__currentDragOverTimer = null;
                            self.openFolder(_last);
                            return;
                        }
                        self.__currentDragOverTimer = null;
                    }, 1550);
                }
                this.__currentDragOverRow = row;
                $(row.element).addClass('dgrid-focus');
            } else {
                this.__currentDragOverRow = null;
            }
        },
        drop: function (e) {
            e.preventDefault();
            var dt = e.dataTransfer;
            if (dt) {
                var files = dt.files;
                if (files && files.length) {
                    if (this.onBrowserFilesDropped) {
                        this.onBrowserFilesDropped(this, files);
                    } else {
                        console.warn('upload failed, invalid state : have no delegate or delegate::onBrowserFilesDropped doesnt exists');
                    }
                } else {
                    try {
                        var url = e.dataTransfer.getData('text/plain');
                        if (url && url.length) {
                            this.delegate.onBrowserUrlDropped(this, url);
                        }
                    } catch (err) {
                        console.error('dropping url failed ' + err);
                    }
                }
            }
        },
        initDND: function () {
            var thiz = this;
            var dstNode = this.domNode;
            if (dstNode) {
                dstNode.addEventListener("dragover", function (e) {
                    thiz.dragOver(e);
                }, false);
                dstNode.addEventListener("drop", function (e) {
                    e.preventDefault();
                    thiz.drop(e);
                }, false);
            } else {
                console.error('have not drop destination');
            }
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var res = this.inherited(arguments);
            this.initDND();
            var grid = this,
                node = this.domNode;
            /*
             this._on('onAddActions', function (evt) {

             var actions = evt.actions,
             permissions = evt.permissions,
             action = types.ACTION.UPLOAD;
             if(!evt.store.getSync(action)) {
             var _action = grid.createAction('Upload', action, types.ACTION_ICON.UPLOAD, null, 'Home', 'File', 'item|view', null, null, null, null, null, permissions, node, grid);
             if (!_action) {
             return;
             }
             actions.push(_action);
             }
             });
             */
            return res;
        }
    });
});
},
'xide/manager/SettingsManager':function(){
/** module:xide/manager/SettingsManager **/
define([
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    "xide/manager/ManagerBase",
    "xide/data/Memory",
    "dojo/Deferred"
], function (dcl,ServerActionBase, utils, ManagerBase,Memory,Deferred) {
    var Module = dcl([ManagerBase, ServerActionBase], {
        declaredClass:"xide.manager.SettingsManager",
        serviceClass: 'XApp_Store',
        settingsStore: null,
        settingsDataAll: null,
        section: 'settings',
        store:null,
        has: function (section, path, query, data, readyCB) {},
        getSetting:function(id){
            var _val = this.getStore().query({
                id:id
            });
            return _val && _val[0] ? _val[0].value : null;
        },
        getStore: function () {
            return this.settingsStore;
        },
        _createStore: function (data) {
            return new Memory({
                data: data,
                idProperty: 'id'
            });
        },
        onSettingsReceived: function (data) {
            this.settingsDataAll = data;
            if (!data) {
                this._createStore([]);
                return;
            }
            var _a = data['' + this.section];
            this.settingsStore = this._createStore(_a);
        },
        replace: function (path, query, operation, newValue, readyCB) {
            var thiz = this;
            var defered = this.serviceObject[this.serviceClass].set(
                this.store,
                path || '.', query, operation, newValue
            );
            defered.addCallback(function (res) {
                if (readyCB) {
                    readyCB(res);
                }
            });
        },
        read: function (section, path, query, readyCB) {
            return this.runDeferred(null, 'get', [section, path, query]).then(function (data) {
                readyCB && readyCB(data);
            }.bind(this));
        },
        update: function (section, path, query, data, decode) {
            //return this.callMethodEx(this.serviceClass, 'update', [section || this.section, path, query, data, decode], readyCB, false);
            return this.runDeferred(null, 'update', [section || this.section, path, query, data, decode]);
        },
        write: function (section, path, query, data, decode, readyCB) {
            try {
                var itemLocal = utils.queryStoreEx(this.settingsStore, {id: data.id}, true, true);
                if (itemLocal) {
                    return this.update(section, path, {id: data.id}, data.data, decode, readyCB);
                } else {
                    return this.callMethodEx(this.serviceClass, 'set', [section || this.section, path, query, data, decode], readyCB, false);
                }
            } catch (e) {
                logError(e, 'update');
            }
        },
        write2: function (section, path, query, data, decode, readyCB) {
            try {
                //var itemLocal = utils.queryStoreEx(this.settingsStore, {id: data.id}, true, true);
                var itemLocal = utils.queryStoreEx(this.settingsStore, query, true, true);
                if (itemLocal) {
                    utils.mixin(itemLocal,data);
                    return this.update(section, path, query, data, decode, readyCB);
                } else {
                    return this.callMethodEx(this.serviceClass, 'set', [section || this.section, path, query, data, decode], readyCB, false);
                }
            } catch (e) {
                logError(e, 'update');
            }
        },
        initStore: function () {
            var dfd = new Deferred();
            var self = this;
            this.serviceObject.__init.then(function() {
                self.read(self.section, '.', null, self.onSettingsReceived.bind(self));
                dfd.resolve();
            });
            return dfd;
        },
        init:function(){
            var dfd = new Deferred();
            var self = this;
            dfd.resolve();
            return dfd;
        }
    });
    return Module;
});
},
'xace/views/_Actions':function(){
/** @module xace/views/Editor **/
define([
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xide/types/Types', //  <--important for build
    'xaction/types', //  <--important for build
    'xaction/ActionProvider',
    'xace/views/ACEEditor',
    'xaction/Toolbar',
    'xaction/DefaultActions',
    'dojo/Deferred',
    'xace/formatters'
], function (dcl, utils, types, Types,aTypes,ActionProvider,ACEEditor,Toolbar, DefaultActions,Deferred,formatters) {

        var ACTION = types.ACTION,
        EDITOR_SETTINGS = 'Editor/Settings',
        INCREASE_FONT_SIZE = 'View/Increase Font Size',
        DECREASE_FONT_SIZE = 'View/Decrease Font Size',
        EDITOR_HELP = 'Help/Editor Shortcuts',
        EDITOR_THEMES = 'View/Themes',
        SNIPPETS = 'Editor/Snippets',
        EDITOR_CONSOLE = 'Editor/Console',
        KEYBOARD = 'Editor/Keyboard',
        LAYOUT = 'View/Layout',
        FORMAT = 'Edit/Format',
        SPLIT_MODE = types.VIEW_SPLIT_MODE,
        DEFAULT_PERMISSIONS = [
            ACTION.RELOAD,
            ACTION.SAVE,
            ACTION.FIND,
            ACTION.TOOLBAR,
            KEYBOARD,
            INCREASE_FONT_SIZE,
            DECREASE_FONT_SIZE,
            EDITOR_THEMES,
            'Help/Editor Shortcuts',
            SNIPPETS,
            EDITOR_CONSOLE,
            EDITOR_SETTINGS,
            ACTION.FULLSCREEN,
            LAYOUT,
            FORMAT
        ];
    /**
     * Default Editor with all extras added : Actions, Toolbar and ACE-Features
     @class module:xgrid/Base
     */
    var Module = dcl([ACEEditor, Toolbar.dcl, ActionProvider.dcl], {
            permissions: DEFAULT_PERMISSIONS,
            _searchBoxOpen: false,
            onSingleView: function () {

            },
            setSplitMode: function (mode) {
                this.splitMode = mode;
                if (!this.doSplit) {
                    if (mode == 'Diff') {
                        this.doDiff();
                        return;
                    }
                    var isSplit = mode == SPLIT_MODE.SPLIT_HORIZONTAL || mode == SPLIT_MODE.SPLIT_VERTICAL;
                    var _ed = this.getEditor();
                    var sp = this.split;
                    if (isSplit) {
                        var newEditor = (sp.getSplits() == 1);
                        sp.setOrientation(mode == SPLIT_MODE.SPLIT_HORIZONTAL ? sp.BELOW : sp.BESIDE);
                        sp.setSplits(2);
                        if (newEditor) {
                            var session = sp.getEditor(0).session;
                            var newSession = sp.setSession(session, 1);
                            newSession.name = session.name;
                            var options = _ed.getOptions();
                            sp.getEditor(1).setOptions(options);
                        }
                    } else {
                        sp.setSplits(1);
                        this.onSingleView();
                    }
                }
            },
            onMaximized: function (maximized) {
                var parent = this.getParent();
                if (maximized === false) {
                    if (parent && parent.resize) {
                        parent.resize();
                    }
                }
                var toolbar = this.getToolbar();
                if (toolbar) {
                    if (maximized) {
                        $(toolbar.domNode).addClass('bg-opaque');
                    } else {
                        $(toolbar.domNode).removeClass('bg-opaque');
                    }
                }
                if (maximized === false) {
                    this.resize();
                    parent && utils.resizeTo(this, parent, true, true);
                    this.publish(types.EVENTS.ON_VIEW_MAXIMIZE_END);
                }
                this.getEditor().focus();
            },
            maximize: function () {
                var node = this.domNode,
                    $node = $(node),
                    _toolbar = this.getToolbar();

                if (!this._isMaximized) {
                    this.publish(types.EVENTS.ON_VIEW_MAXIMIZE_START);
                    this._isMaximized = true;
                    var vp = $(this.domNode.ownerDocument);
                    var root = $('body')[0];
                    var container = utils.create('div', {
                        className: 'ACEContainer bg-opaque',
                        style: 'z-index:300;height:100%;width:100%'
                    });

                    this._maximizeContainer = container;
                    root.appendChild(container);
                    $(node).addClass('AceEditorPaneFullScreen');
                    $(node).css('width', vp.width());
                    $(node).css('height', vp.height());
                    this.resize();
                    this._lastParent = node.parentNode;
                    container.appendChild(node);
                    $(container).addClass('bg-opaque');
                    $(container).css('width', vp.width());
                    $(container).css('height', vp.height());
                    $(container).css({
                        position: "absolute",
                        left: "0px",
                        top: "0px",
                        border: 'none medium',
                        width: '100%',
                        height: '100%'
                    });

                } else {
                    this._isMaximized = false;
                    $node.removeClass('AceEditorPaneFullScreen');
                    this._lastParent.appendChild(node);
                    utils.destroy(this._maximizeContainer);
                }
                this.onMaximized(this._isMaximized);
                return true;
            },
            save: function (item) {
                var value = this.get('value');
                var res = this.saveContent(this.get('value'), item);
                var thiz = this;
                this._emit(types.EVENTS.ON_FILE_CONTENT_CHANGED,{
                    content:value,
                    item:item
                });
                setTimeout(function () {
                    var _ed = thiz.getEditor();
                    if (_ed) {
                        _ed.focus();
                    }
                }, 600);
                return res;
            },
            reload:function(){
                var self = this;
                var dfd = new Deferred();
                this.getContent(
                    this.item,
                    function (content) {//onSuccess
                        self.lastSavedContent = content;
                        self.set('value',content);
                        dfd.resolve(content);
                    },
                    function (e) {//onError
                        logError(e, 'error loading content from file');
                        dfd.reject(e);
                    }
                );
                return dfd;
            },
            runAction: function (action) {
                action = this.getAction(action);
                if (!action) {
                    return false;
                }

                var self = this,
                    command = action.command,
                    ACTION = types.ACTION,
                    editor = this.getEditor(),
                    session = this.editorSession,
                    result = false;

                if (command.indexOf(LAYOUT) != -1) {
                    self.setSplitMode(action.option, null);
                }

                switch (command) {
                    case ACTION.RELOAD:
                    {
                        return this.reload();
                    }
                    case INCREASE_FONT_SIZE:
                    {
                        editor.setFontSize(editor.getFontSize() + 1);
                        return true;
                    }
                    case DECREASE_FONT_SIZE:
                    {
                        editor.setFontSize(editor.getFontSize() - 1);
                        return true;
                    }
                    case ACTION.FULLSCREEN:
                    {
                        return this.maximize();
                    }
                    case EDITOR_HELP:
                    {
                        self.showHelp();
                        break;
                    }
                    case ACTION.SAVE:
                    {
                        result = self.save(this.item);
                        break;
                    }
                    case ACTION.FIND:
                    {
                        var net = ace.require("ace/lib/net");
                        var webRoot = this.getWebRoot();
                        var sb = editor.searchBox;
                        function _search(sb) {
                            var shown = self._searchBoxOpen;
                            if (!shown) {
                                sb.show(editor.session.getTextRange(), null);
                                self._searchBoxOpen = true;
                            } else {
                                sb.hide();
                                self._searchBoxOpen = false;
                            }
                        }
                        if (sb) {
                            _search(sb);
                        } else {
                            net.loadScript(webRoot + '/xfile/ext/ace/ext-searchbox.js', function (what) {
                                var sbm = ace.require("ace/ext/searchbox");
                                _search(new sbm.SearchBox(editor));
                            });
                        }
                        return true;
                    }
                }

                //themes
                if (command.indexOf(EDITOR_THEMES) !==-1) {
                    self.set('theme', action.theme);
                    var parentAction = action.getParent ?  action.getParent() : null;
                    //action._originEvent = 'change';
                    if(parentAction) {
                        var rendererActions = parentAction.getChildren();
                        _.each(rendererActions, function (child) {
                            child.set('icon', child._oldIcon);
                        });
                    }
                    action.set('icon', 'fa fa-check');
                }
                //formatters :
                if (command.indexOf(FORMAT) !==-1) {
                     if (editor) {
                         var _value = formatters.format(editor, action.formatter);
                         self.set('value',_value);
                     }
                }
                /*
                if (command.indexOf(KEYBOARD) !==-1) {
                    var option = action.option,
                        keybindings = {
                        ace: null, // Null = use "default" keymapping
                        vim: ace.require("ace/keyboard/vim").handler,
                        emacs: "ace/keyboard/emacs"
                    };
                    editor.setKeyboardHandler(keybindings[action.option]);
                    return true;
                }
                */

                if (command.indexOf(EDITOR_SETTINGS) !==-1) {
                    var key = action.option,
                        option = editor.getOption(action.option),
                        isBoolean = _.isBoolean(option);
                    if (key === 'highlightActive') {
                        editor.setHighlightActiveLine(!editor.getHighlightActiveLine());
                        return;
                    }
                    if (isBoolean) {
                        editor.setOption(action.option, !option);
                    } else {
                        if (key === 'wordWrap') {
                            var mode = session.getUseWrapMode();
                            this.set('wordWrap', !mode);
                            return true;
                        }
                        if (option === 'off' || option === 'on') {
                            editor.setOption(key, option === 'off' ? 'on' : 'off');
                        } else {
                            editor.setOption(action.option, false);
                        }
                    }
                    return true;
                }

                return this.inherited(arguments);
            },
            getEditorActions: function (permissions) {

                var actions = [],
                    self = this,
                    ACTION = types.ACTION,
                    ICON = types.ACTION_ICON;

                /* @TODO: reactivate reload action
                actions.push(this.createAction({
                    label: 'Reload',
                    command: ACTION.RELOAD,
                    icon: ICON.RELOAD,
                    keycombo: 'ctrl r'
                }));
                */
                actions.push(this.createAction({
                    label: 'Save',
                    command: ACTION.SAVE,
                    icon: ICON.SAVE,
                    keycombo: 'ctrl s',
                    group: 'File'
                }));

                actions.push(this.createAction({
                    label: 'Find',
                    command: ACTION.FIND,
                    icon: ICON.SEARCH,
                    keycombo: 'ctrl f',
                    group: 'Search'
                }));

                actions.push(this.createAction({
                    label: 'Fullscreen',
                    command: ACTION.FULLSCREEN,
                    icon: ICON.MAXIMIZE,
                    keycombo: 'ctrl f11',
                    group: 'View'
                }));


                actions.push(this.createAction({
                    label: 'Increase Fontsize',
                    command: INCREASE_FONT_SIZE,
                    icon: 'fa-text-height',
                    group: 'View'
                }));

                actions.push(this.createAction({
                    label: 'Decrease Fontsize',
                    command: DECREASE_FONT_SIZE,
                    icon: 'fa-text-height',
                    group: 'View'
                }));

                if (DefaultActions.hasAction(permissions, EDITOR_THEMES)) {
                    actions.push(this.createAction({
                        label: 'Themes',
                        command: EDITOR_THEMES,
                        icon: 'fa-paint-brush',
                        group: 'View',
                        mixin:{
                            closeOnClick:false,
                            value:this.defaultPrefenceTheme
                        },
                        onCreate:function(action){
                            var options = self.getDefaultOptions();
                            action.set('value',options.theme);
                        }
                    }));

                    self._addThemes && self._addThemes(actions);
                }

                actions.push(this.createAction({
                    label: 'Help',
                    command: EDITOR_HELP,
                    icon: 'fa-question',
                    keycombo: 'f1'
                }));

                ///editor settings
                actions.push(this.createAction({
                    label: 'Settings',
                    command: EDITOR_SETTINGS,
                    icon: 'fa-cogs',
                    group: "Settings"
                }));

                function _createSettings(label, command, icon, option, mixin, group, actionType, params) {
                    command = command || EDITOR_SETTINGS + '/' + label;
                    mixin = mixin || {};
                    command = command || EDITOR_SETTINGS + '/' + label;
                    mixin = mixin || {};
                    var action = self.createAction(utils.mixin({
                        label: label,
                        command: command,
                        icon: icon || 'fa-cogs',
                        group: group || "Settings",
                        mixin: utils.mixin({
                            addPermission: true,
                            option: option,
                            actionType: actionType,
                            owner: self
                        }, mixin)
                    }, params));
                    actions.push(action);
                    return action;
                }
                var _params = {
                    onCreate: function (action) {
                        var optionValue = self.getOptionsMixed()[this.option];
                        if (optionValue !== null) {
                            action.set('value', optionValue);
                        }
                    },
                    onChange: function (property, value) {
                        this.value = value;
                        self.runAction(this);
                    }
                };


                _createSettings('Show Gutters', null, null, 'showGutter', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Show Print Margin', null, null, 'showPrintMargin', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Display Intend Guides', null, null, 'displayIndentGuides', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Show Line Numbers', null, null, 'showLineNumbers', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Show Indivisibles', null, null, 'showInvisibles', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Use Soft Tabs', null, null, 'useSoftTabs', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Use Elastic Tab Stops', null, null, 'useElasticTabstops', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                //_createSettings('Use Elastic Tab Stops', null, null, 'useElasticTabstops');
                _createSettings('Animated Scroll', null, null, 'animatedScroll', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Word Wrap', null, null, 'wordWrap', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);
                _createSettings('Highlight Active Line', null, null, 'highlightActive', null, null, types.ACTION_TYPE.MULTI_TOGGLE, _params);

                /*
                 var keybindings = {
                 ace: null, // Null = use "default" keymapping
                 vim: ace.require("ace/keyboard/vim").handler,
                 emacs: "ace/keyboard/emacs"
                 };
                 */

                /*
                 actions.push(this.createAction({
                 label: 'Keyboard',
                 command: KEYBOARD,
                 icon: 'fa-keyboard-o',
                 group: "Settings"
                 }));

                 if(DefaultActions.hasAction(permissions,KEYBOARD)){
                 _createSettings('Default', KEYBOARD + '/Default', null, 'ace');
                 _createSettings('Vim', KEYBOARD + '/Vim', null, 'vim');
                 _createSettings('EMacs', KEYBOARD + '/EMacs', null, 'emacs');
                 }
                 */
                var VISIBILITY = types.ACTION_VISIBILITY;
                if (DefaultActions.hasAction(permissions, FORMAT)) {
                    actions.push(this.createAction({
                        label: 'Format',
                        command: 'Edit/Format',
                        icon: 'fa-indent',
                        group: "Edit"
                    }));

                    var modes = formatters.modes;
                    var creatorFn = function (label, icon, value) {

                        var head = self.createAction({
                            label: label,
                            command: 'Edit/Format/'+label,
                            icon: 'fa-indent',
                            group: "Edit",
                            mixin:{
                                addPermission: true,
                                formatter:value
                            },
                            onCreate:function(action){
                                /*
                                action.setVisibility(VISIBILITY.ACTION_TOOLBAR, {label: ''}).
                                setVisibility(VISIBILITY.MAIN_MENU, {show: false}).
                                setVisibility(VISIBILITY.CONTEXT_MENU, null);*/
                            }
                        });

                        actions.push(head);

                        /*
                        return Action.create(label, icon, 'Edit/Format/' + label, false, null, 'TEXT', 'viewActions', null, false, function () {
                            formatCode(value);
                        });
                        */
                    };

                    for (var _f in modes) {
                        actions.push(creatorFn(modes[_f], '', _f));
                    }
                    /*
                    var format = Action.createDefault('Format', 'fa-indent', 'Edit/Format', '_a', null, {
                        dummy: true
                    }).setVisibility(VISIBILITY.ACTION_TOOLBAR, {label: ''}).
                    setVisibility(VISIBILITY.MAIN_MENU, {show: false}).
                    setVisibility(VISIBILITY.CONTEXT_MENU, null);

                    this.addAction(actions,format);

                    for (var _f in modes) {
                        actions.push(creatorFn(modes[_f], '', _f));
                    }
                    */


                    /*

                    //layout
                    actions.push(_createSettings('None', 'View/Layout/None', 'fa-columns', SPLIT_MODE.SOURCE, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    actions.push(_createSettings('Horizontal', 'View/Layout/Horizontal', 'layoutIcon-horizontalSplit', SPLIT_MODE.SPLIT_HORIZONTAL, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    actions.push(_createSettings('Vertical', 'View/Layout/Vertical', 'layoutIcon-layout293', SPLIT_MODE.SPLIT_VERTICAL, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    */
                    //actions.push(_createSettings('Diff', 'View/Layout/Diff', 'fa-columns', 'Diff', null, 'View'));
                }

                if (DefaultActions.hasAction(permissions, LAYOUT)) {
                    actions.push(this.createAction({
                        label: 'Split',
                        command: 'View/Layout',
                        icon: 'fa-columns',
                        group: "View"
                    }));
                    //layout
                    actions.push(_createSettings('None', 'View/Layout/None', 'fa-columns', SPLIT_MODE.SOURCE, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    actions.push(_createSettings('Horizontal', 'View/Layout/Horizontal', 'layoutIcon-horizontalSplit', SPLIT_MODE.SPLIT_HORIZONTAL, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    actions.push(_createSettings('Vertical', 'View/Layout/Vertical', 'layoutIcon-layout293', SPLIT_MODE.SPLIT_VERTICAL, null, 'View', types.ACTION_TYPE.SINGLE_TOGGLE));
                    //actions.push(_createSettings('Diff', 'View/Layout/Diff', 'fa-columns', 'Diff', null, 'View'));
                }
                return actions;
            },
            _addThemes: function (actions) {
                var themes = this.getThemeData(),
                    thiz = this;

                var creatorFn = function (label, icon, value) {
                    return thiz.createAction({
                        label: label,
                        command: EDITOR_THEMES + '/' + label,
                        group: 'View',
                        icon: icon,
                        mixin: {
                            addPermission: true,
                            value:value,
                            theme: value,
                            closeOnClick:false
                        },
                        onCreate:function(action) {
                            action._oldIcon = icon;
                            action.set('value', value);
                            action.actionType = types.ACTION_TYPE.SINGLE_TOGGLE;
                        }
                    });
                };

                //clean and complete theme data
                for (var i = 0; i < themes.length; i++) {
                    var data = themes[i];
                    var name = data[1] || data[0].replace(/ /g, "_").toLowerCase();
                    var theme = creatorFn(data[0], ' ', name);//@TODO: _MenuMixin not creating icon node, use white space for now
                    actions.push(theme);
                }
            },
            showHelp: function (editor) {
                editor = editor || this.getEditor();
                var config = ace.require("ace/config");
                config.loadModule("ace/ext/keybinding_menu", function (module) {
                    module.init(editor);
                    editor.showKeyboardShortcuts();
                });
            },
            getThemeData: function () {
                return [
                    ["Chrome"],
                    ["Clouds"],
                    ["Crimson Editor"],
                    ["Dawn"],
                    ["Dreamweaver"],
                    ["Eclipse"],
                    ["GitHub"],
                    ["Solarized Light"],
                    ["TextMate"],
                    ["Tomorrow"],
                    ["XCode"],
                    ["Kuroir"],
                    ["KatzenMilch"],
                    ["Ambiance", "ambiance", "dark"],
                    ["Day", "cloud9_day"],
                    ["Night", "cloud9_night"],
                    ["Chaos", "chaos", "dark"],
                    ["Midnight", "clouds_midnight", "dark"],
                    ["Cobalt", "cobalt", "dark"],
                    ["idle Fingers", "idle_fingers", "dark"],
                    ["krTheme", "kr_theme", "dark"],
                    ["Merbivore", "merbivore", "dark"],
                    ["Merbivore-Soft", "merbivore_soft", "dark"],
                    ["Mono Industrial", "mono_industrial", "dark"],
                    ["Monokai", "monokai", "dark"],
                    ["Pastel on dark", "pastel_on_dark", "dark"],
                    ["Solarized Dark", "solarized_dark", "dark"],
                    ["Terminal", "terminal", "dark"],
                    ["Tomorrow-Night", "tomorrow_night", "dark"],
                    ["Tomorrow-Night-Blue", "tomorrow_night_blue", "dark"],
                    ["Tomorrow-Night-Bright", "tomorrow_night_bright", "dark"],
                    ["Tomorrow-Night-80s", "tomorrow_night_eighties", "dark"],
                    ["Twilight", "twilight", "dark"],
                    ["Vibrant Ink", "vibrant_ink", "dark"]
                ];
            }
        }
    );
    Module.DEFAULT_PERMISSIONS = DEFAULT_PERMISSIONS;
    dcl.chainAfter('runAction',Module);
    return Module;
});
},
'dgrid/dgrid':function(){

},
'dijit/main':function(){
define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'xdocker/Frame2':function(){
define([
    "dcl/dcl",
    "wcDocker/frame"
], function (dcl,frame) {

    var Module = dcl([frame],{
        _showTitlebar:true,
        panel: function (tabIndex, autoFocus) {
            if (typeof tabIndex !== 'undefined') {
                if (this.isCollapser() && tabIndex === this._curTab) {
                    this.collapse();
                    tabIndex = -1;
                }
                if (tabIndex < this._panelList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive active');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    if (this._curTab !== tabIndex) {
                        this.collapse();
                    }
                    this._curTab = tabIndex;
                    if (tabIndex > -1) {
                        this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + tabIndex + '"]').addClass('wcPanelTabActive active');
                        this.$center.children('.wcPanelTabContent[id="' + tabIndex + '"]').removeClass('wcPanelTabContentHidden');
                        this.expand();
                    }
                    this.__updateTabs(autoFocus);
                }
            }

            if (this._curTab > -1 && this._curTab < this._panelList.length) {
                return this._panelList[this._curTab];
            } else if (this.isCollapser() && this._panelList.length) {
                return this._panelList[0];
            }
            return false;
        },
        __init: function () {
            this.$frame = $('<div class="wcFrame wcWide wcTall widget">');
            this.$title = $('<div class="wcFrameTitle">');
            this.$titleBar = $('<div class="wcFrameTitleBar wcFrameTopper">');
            this.$tabBar = $('<header class="wcFrameTitleBar">');
            this.$tabScroll = $('<ul class="wcTabScroller nav nav-tabs">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><div class="fa fa-close"></div>X</div>');
            this.$collapse = $('<div class="wcFrameButton" title="Collapse the active panel"><div class="fa fa-download"></div>C</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');
            this.$tabButtonBar = $('<div class="wcFrameButtonBar">');

            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$tabButtonBar);
            this.$frame.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);
            this.$buttonBar.append(this.$collapse);
            this.$frame.append(this.$center);

            if (this._isFloating) {
                this.$top = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('top', '-6px').css('left', '0px').css('right', '0px');
                this.$bottom = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('bottom', '-6px').css('left', '0px').css('right', '0px');
                this.$left = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('left', '-6px').css('top', '0px').css('bottom', '0px');
                this.$right = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('right', '-6px').css('top', '0px').css('bottom', '0px');
                this.$corner1 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('top', '-6px').css('left', '-6px');
                this.$corner2 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('top', '-6px').css('right', '-6px');
                this.$corner3 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('bottom', '-6px').css('right', '-6px');
                this.$corner4 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('bottom', '-6px').css('left', '-6px');

                this.$frame.append(this.$top);
                this.$frame.append(this.$bottom);
                this.$frame.append(this.$left);
                this.$frame.append(this.$right);
                this.$frame.append(this.$corner1);
                this.$frame.append(this.$corner2);
                this.$frame.append(this.$corner3);
                this.$frame.append(this.$corner4);
            }
            this.__container(this.$container);
            if (this._isFloating) {
                this.$frame.addClass('wcFloating');
            }
            this.$center.scroll(this.__scrolled.bind(this));
        },
        /**
         * Get/Set for 'show title bar'
         * @param show {boolean}
         * @returns {boolean}
         */
        showTitlebar:function(show){
            if(show!=null) {
                var prop = show ? 'inherit' : 'none',
                    what = 'display',
                    who = this;

                who.$titleBar.css(what, prop);
                who.$tabBar.css(what, prop);
                who.$center.css('top', show ? 30 : 0);
                this._showTitlebar = show;
            }
            return this._showTitlebar
        },
        currentPanel:function(){
            return this._panelList[this._curTab];
        },
        __widgets:function(){
            return this._panelList;
        },
        panels:function(){
            return this._panelList;
        },
        panelAt:function(index){
            return this._panelList[index];
        },
        panelIndex:function(panel) {
            return _.findIndex(this._panelList,panel);
        }
    });    
    return Module;
});
},
'dojo/_base/event':function(){
define(["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if( 1 ){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
});

},
'dojo/_base/html':function(){
define(["./kernel", "../dom", "../dom-style", "../dom-attr", "../dom-prop", "../dom-class", "../dom-construct", "../dom-geometry"], function(dojo, dom, style, attr, prop, cls, ctr, geom){
	// module:
	//		dojo/dom

	/*=====
	return {
		// summary:
		//		This module is a stub for the core dojo DOM API.
	};
	=====*/

	// mix-in dom
	dojo.byId = dom.byId;
	dojo.isDescendant = dom.isDescendant;
	dojo.setSelectable = dom.setSelectable;

	// mix-in dom-attr
	dojo.getAttr = attr.get;
	dojo.setAttr = attr.set;
	dojo.hasAttr = attr.has;
	dojo.removeAttr = attr.remove;
	dojo.getNodeProp = attr.getNodeProp;

	dojo.attr = function(node, name, value){
		// summary:
		//		Gets or sets an attribute on an HTML element.
		// description:
		//		Handles normalized getting and setting of attributes on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to get or set the attribute on
		// name: String|Object
		//		the name of the attribute to get or set.
		// value: String?
		//		The value to set for the attribute
		// returns:
		//		when used as a getter, the value of the requested attribute
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	dojo.attr(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.attr("nodeId", "foo");
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	dojo.attr("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.attr("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//	Style is s special case: Only set with an object hash of styles
		//	|	dojo.attr("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//	Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.attr("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return attr[typeof name == "string" ? "get" : "set"](node, name);
		}
		return attr.set(node, name, value);
	};

	// mix-in dom-class
	dojo.hasClass = cls.contains;
	dojo.addClass = cls.add;
	dojo.removeClass = cls.remove;
	dojo.toggleClass = cls.toggle;
	dojo.replaceClass = cls.replace;

	// mix-in dom-construct
	dojo._toDom = dojo.toDom = ctr.toDom;
	dojo.place = ctr.place;
	dojo.create = ctr.create;
	dojo.empty = function(node){ ctr.empty(node); };
	dojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };

	// mix-in dom-geometry
	dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
	dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
	dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
	dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
	dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
	dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
	dojo.setMarginBox = geom.setMarginBox;
	dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
	dojo.setContentSize = geom.setContentSize;
	dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
	dojo._docScroll = dojo.docScroll = geom.docScroll;
	dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
	dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
	dojo.position = geom.position;

	dojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the margin-box of node.
		// description:
		//		Getter/setter for the margin-box of node.
		//		Returns an object in the expected format of box (regardless
		//		if box is passed). The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a margin width of 300px and a margin-height of
		//		150px.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.marginBox() should
		//		update/set the margin box for node. Box is an object in the
		//		above format. All properties are optional if passed.
		// example:
		//		Retrieve the margin box of a passed node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	console.dir(box);
		//
		// example:
		//		Set a node's margin box to the size of another node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	dojo.marginBox("someOtherNode", box);
		return box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object
	};

	dojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the content-box of node.
		// description:
		//		Returns an object in the expected format of box (regardless if box is passed).
		//		The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a content width of 300px and a content-height of
		//		150px. Note that the content box may have a much larger border
		//		or margin box, depending on the box model currently in use and
		//		CSS values set/inherited for node.
		//		While the getter will return top and left values, the
		//		setter only accepts setting the width and height.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.contentBox() should
		//		update/set the content box for node. Box is an object in the
		//		above format, but only w (width) and h (height) are supported.
		//		All properties are optional if passed.
		return box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object
	};

	dojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//
		//		Returns an object that measures margin-box (w)idth/(h)eight
		//		and absolute position x/y of the border-box. Also returned
		//		is computed (l)eft and (t)op values in pixels from the
		//		node's offsetParent as returned from marginBox().
		//		Return value will be in the form:
		//|			{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
		//		Does not act as a setter. If includeScroll is passed, the x and
		//		y params are affected as one would expect in dojo.position().
		dojo.deprecated("dojo.coords()", "Use dojo.position() or dojo.marginBox().");
		node = dom.byId(node);
		var s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);
		var abs = geom.position(node, includeScroll);
		mb.x = abs.x;
		mb.y = abs.y;
		return mb;	// Object
	};

	// mix-in dom-prop
	dojo.getProp = prop.get;
	dojo.setProp = prop.set;

	dojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){
		// summary:
		//		Gets or sets a property on an HTML element.
		// description:
		//		Handles normalized getting and setting of properties on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node:
		//		id or reference to the element to get or set the property on
		// name:
		//		the name of the property to get or set.
		// value:
		//		The value to set for the property
		// returns:
		//		when used as a getter, the value of the requested property
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	dojo.prop(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.prop("nodeId", "foo");
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	dojo.prop("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.prop("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//		Style is s special case: Only set with an object hash of styles
		//	|	dojo.prop("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//		Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.prop("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return prop[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return prop.set(node, name, value);
	};

	// mix-in dom-style
	dojo.getStyle = style.get;
	dojo.setStyle = style.set;
	dojo.getComputedStyle = style.getComputedStyle;
	dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;

	dojo.style = function(node, name, value){
		// summary:
		//		Accesses styles on a node. If 2 arguments are
		//		passed, acts as a getter. If 3 arguments are passed, acts
		//		as a setter.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo.marginBox()`,
		//		`dojo.contentBox()` or `dojo.position()`.
		// node: DOMNode|String
		//		id or reference to node to get/set style for
		// name: String|Object?
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		// returns:
		//		when used as a getter, return the computed style of the node if passing in an ID or node,
		//		or return the normalized, computed value for the property when passing in a node and a style property
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	dojo.style("thinger");
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	dojo.style("thinger", "opacity"); // 1 by default
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	dojo.style("thinger", "opacity", 0.5); // == 0.5
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	dojo.style("thinger", {
		//	|		"opacity": 0.5,
		//	|		"border": "3px solid black",
		//	|		"height": "300px"
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	dojo.style("thinger",{
		//	|		fontSize:"14pt",
		//	|		letterSpacing:"1.2em"
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo.style() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	dojo.query(".someClassName").style("visibility","hidden");
		//	|	// or
		//	|	dojo.query("#baz > div").style({
		//	|		opacity:0.75,
		//	|		fontSize:"13pt"
		//	|	});

		switch(arguments.length){
			case 1:
				return style.get(node);
			case 2:
				return style[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return style.set(node, name, value);
	};

	return dojo;
});

},
'dstore/Memory':function(){
define([
	'dojo/_base/declare',
	'dojo/_base/array',
	'./Store',
	'./Promised',
	'./SimpleQuery',
	'./QueryResults'
], function (declare, arrayUtil, Store, Promised, SimpleQuery, QueryResults) {

	// module:
	//		dstore/Memory
	return declare([Store, Promised, SimpleQuery ], {
		constructor: function () {
			// summary:
			//		Creates a memory object store.
			// options: dstore/Memory
			//		This provides any configuration information that will be mixed into the store.
			//		This should generally include the data property to provide the starting set of data.

			// Add a version property so subcollections can detect when they're using stale data
			this.storage.version = 0;
		},

		postscript: function () {
			this.inherited(arguments);

			// Set the data in `postscript` so subclasses can override `data` in their constructors
			// (e.g., a LocalStorage store that retrieves its data from localStorage)
			this.setData(this.data || []);
		},

		// data: Array
		//		The array of all the objects in the memory store
		data: null,

		autoEmitEvents: false, // this is handled by the methods themselves

		getSync: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
			return this.storage.fullData[this.storage.index[id]];
		},
		putSync: function (object, options) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number

			options = options || {};

			var storage = this.storage,
				index = storage.index,
				data = storage.fullData;

			var Model = this.Model;
			if (Model && !(object instanceof Model)) {
				// if it is not the correct type, restore a
				// properly typed version of the object. Note that we do not allow
				// mutation here
				object = this._restore(object);
			}
			var id = this.getIdentity(object);
			if (id == null) {
				this._setIdentity(object, ('id' in options) ? options.id : Math.random());
				id = this.getIdentity(object);
			}
			storage.version++;

			var eventType = id in index ? 'update' : 'add',
				event = { target: object },
				previousIndex,
				defaultDestination;
			if (eventType === 'update') {
				if (options.overwrite === false) {
					throw new Error('Object already exists');
				} else {
					data.splice(previousIndex = index[id], 1);
					defaultDestination = previousIndex;
				}
			} else {
				defaultDestination = this.defaultNewToStart ? 0 : data.length;
			}

			var destination;
			if ('beforeId' in options) {
				var beforeId = options.beforeId;

				if (beforeId === null) {
					destination = data.length;
				} else {
					destination = index[beforeId];

					// Account for the removed item
					if (previousIndex < destination) {
						--destination;
					}
				}

				if (destination !== undefined) {
					event.beforeId = beforeId;
				} else {
					console.error('options.beforeId was specified but no corresponding index was found');
					destination = defaultDestination;
				}
			} else {
				destination = defaultDestination;
			}
			data.splice(destination, 0, object);

			// the fullData has been changed, so the index needs updated
			var i = isFinite(previousIndex) ? Math.min(previousIndex, destination) : destination;
			for (var l = data.length; i < l; ++i) {
				index[this.getIdentity(data[i])] = i;
			}

			this.emit(eventType, event);

			return object;
		},
		addSync: function (object, options) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number
			(options = options || {}).overwrite = false;
			// call put with overwrite being false
			return this.putSync(object, options);
		},
		removeSync: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
			// returns: Boolean
			//		Returns true if an object was removed, falsy (undefined) if no object matched the id
			var storage = this.storage;
			var index = storage.index;
			var data = storage.fullData;
			if (id in index) {
				var removed = data.splice(index[id], 1)[0];
				// now we have to reindex
				this._reindex();
				this._ignoreChangeEvents !==true && this.emit('delete', {id: id, target: removed});
				return true;
			}
		},
		setData: function (data) {
			// summary:
			//		Sets the given data as the source for this store, and indexes it
			// data: Object[]
			//		An array of objects to use as the source of data. Note that this
			//		array will not be copied, it is used directly and mutated as
			//		data changes.

			if (this.parse) {
				data = this.parse(data);
			}
			if (data.items) {
				// just for convenience with the data format ItemFileReadStore expects
				this.idProperty = data.identifier || this.idProperty;
				data = data.items;
			}
			var storage = this.storage;
			storage.fullData = this.data = data;
			this._reindex();
		},

		_reindex: function () {
			var storage = this.storage;
			var index = storage.index = {};
			var data = storage.fullData;
			var Model = this.Model;
			var ObjectPrototype = Object.prototype;
			for (var i = 0, l = data.length; i < l; i++) {
				var object = data[i];
				if (Model && !(object instanceof Model)) {
					var restoredObject = this._restore(object,
							// only allow mutation if it is a plain object
							// (which is generally the expected input),
							// if "typed" objects are actually passed in, we will
							// respect that, and leave the original alone
							object.__proto__ === ObjectPrototype);
					if (object !== restoredObject) {
						// a new object was generated in the restoration process,
						// so we have to update the item in the data array.
						data[i] = object = restoredObject;
					}
				}
				index[this.getIdentity(object)] = i;
			}
			storage.version++;
		},

		fetchSync: function () {
			var data = this.data;
			if (!data || data._version !== this.storage.version) {
				// our data is absent or out-of-date, so we requery from the root
				// start with the root data
				data = this.storage.fullData;
				var queryLog = this.queryLog;
				// iterate through the query log, applying each querier
				for (var i = 0, l = queryLog.length; i < l; i++) {
					data = queryLog[i].querier(data);
				}
				// store it, with the storage version stamp
				data._version = this.storage.version;
				this.data = data;
			}
			return new QueryResults(data);
		},

		fetchRangeSync: function (kwArgs) {
			var data = this.fetchSync(),
				start = kwArgs.start,
				end = kwArgs.end;
			return new QueryResults(data.slice(start, end), {
				totalLength: data.length
			});
		},

		_includePropertyInSubCollection: function (name) {
			return name !== 'data' && this.inherited(arguments);
		}
	});
});

},
'dojo/_base/kernel':function(){
define(["../has", "./config", "require", "module"], function(has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:this,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			this[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = ! 1  || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 11, patch: 2, flag: "",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If  1  is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	 1 || has.add("extend-dojo", 1);


	(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if( 0 ){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	 1 || has.add("dojo-guarantee-console",
		// ensure that console.log, console.warn, etc. are defined
		1
	);
	if( 1 ){
		typeof console != "undefined" || (console = {});
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.apply({}, arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	 1 || has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if( 1 ){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	 1 || has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if( 1 ){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lenghty relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
});

},
'xgrid/Actions':function(){
/** module xgrid/actions **/
define([
    "xdojo/declare",
    'xide/types',
    'xaction/ActionProvider',
    'xaction/DefaultActions'
], function (declare, types, ActionProvider, DefaultActions) {
    var _debug = false;
    /**
     * @class xgrid.actions
     *
     * All about actions:
     * 1. implements std before and after actions:
     * 1.1 on onAfterAction its restoring focus and selection automatically
     * 2. handles and forwards click, contextmenu and onAddActions     *
     */
    var Implementation = {

        _ActionContextState: null,
        onActivateActionContext: function (context, e) {
            return;
            var state = this._ActionContextState;
            if (this._isRestoring) {
                return;
            }
            this._isRestoring = true;
            if (e != null && e.selection && state) {
                state.selection = e != null ? e.selection : state.selection;
            }
            var self = this;
            _debug && console.log('onActivateActionContext', e);
            //@TODO Fixme
            /*setTimeout(function () {*/
                var dfd = self._restoreSelection(state, 0, false, 'onActivateActionContext');
                if (dfd && dfd.then) {
                    dfd.then(function (e) {
                        self._isRestoring = false;
                    });
                } else {
                    self._isRestoring = false;
                }
            /*}, 1000);*/
        },
        onDeactivateActionContext: function (context, event) {
            return;
            _debug && console.log('onDeactivateActionContext ' + this.id, event);
            this._ActionContextState = this._preserveSelection();
        },
        /**
         * Callback when action is performed:before (xide/widgets/_MenuMixin)
         * @param action {module:xaction/Action}
         */
        onBeforeAction: function (action) {
        },
        /**
         * Callback when action is performed: after (xide/widgets/_MenuMixin)
         *
         * @TODO Run the post selection only when we are active!
         *
         *
         * @param action {module:xaction/Action}
         */
        onAfterAction: function (action, actionDfdResult) {
            action = this.getAction(action);
            _debug && console.log('on after ' + action.command, actionDfdResult);
            if (actionDfdResult != null) {
                if (_.isObject(actionDfdResult)) {
                    // post work: selection & focus
                    var select = actionDfdResult.select,
                        focus = actionDfdResult.focus || true;
                    if (select) {
                        var options = {
                            append: actionDfdResult.append,
                            focus: focus,
                            delay: actionDfdResult.delay || 1,
                            expand: actionDfdResult.expand
                        };
                        //focus == true ? null : this.focus();
                        return this.select(select, null, true, options);
                    }
                }
            }
            this._emit(types.EVENTS.ON_AFTER_ACTION,action);
        },
        hasPermission: function (permission) {
            return DefaultActions.hasAction(this.permissions, permission);
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        addAction: function (where, action) {
            if (action.keyCombo && _.isArray(action.keyCombo)) {
                if (action.keyCombo.indexOf('dblclick') !== -1) {
                    var thiz = this;
                    this.on('dblclick', function (e) {
                        var row = thiz.row(e);
                        row && thiz.runAction(action, row.data);
                    });
                }
            }
            return this.inherited(arguments);
        },
        /**
         * Callback when selection changed, refreshes all actions
         * @param evt
         * @private
         */
        _onSelectionChanged: function (evt) {
            this.inherited(arguments);
            this.refreshActions();
        },
        ////////////////////////////////////////////////////////////////////////////
        //
        //  Original ActionMixin
        //
        ///////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param provider
         * @param target
         */
        updateActions: function (provider, target) {
            var actions,
                actionsFiltered,
                selection = this.getSelection();

            if (provider && target) {
                actions = provider.getItemActions();
                actionsFiltered = this._filterActions(selection, actions, provider);
                target.setItemActions({}, actionsFiltered);
            }
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var thiz = this;
            thiz.domNode.tabIndex = -1;
            var clickHandler = function (evt) {
                //var active = thiz.isActive();
                //container
                if (evt && evt.target && $(evt.target).hasClass('dgrid-content')) {

                    thiz.select([], null, false);
                    thiz.deselectAll();
                    if (evt.type !== 'contextmenu') {
                        setTimeout(function () {
                            thiz.domNode.focus();
                            document.activeElement = thiz.domNode;
                            $(thiz.domNode).focus();
                        }, 1);
                    }
                }
            };
            this.on("contextmenu", clickHandler.bind(this));
            this._on('selectionChanged', function (evt) {
                this._onSelectionChanged(evt);
            }.bind(this));


            this._on('onAddActions', function (evt) {
                var actions = evt.actions,
                    permissions = evt.permissions,
                    container = thiz.domNode,
                    action = types.ACTION.HEADER;

                if(!thiz.getAction(action)) {
                    actions.push(thiz.createAction({
                        label: 'Header',
                        command: action,
                        icon: 'fa-hdd-o',
                        tab: 'View',
                        group: 'Show',
                        mixin: {
                            actionType: 'multiToggle'
                        },
                        onCreate: function (action) {
                            action.set('value', thiz.showHeader);
                        },
                        onChange: function (property, value) {
                            thiz._setShowHeader(value);
                            thiz.showHeader = value;
                            thiz.onAfterAction(types.ACTION.HEADER);
                        }
                    }));
                }
            });
            return this.inherited(arguments);
        }
    };
    //package via declare
    var _class = declare('xgrid.Actions', ActionProvider, Implementation);
    _class.Implementation = Implementation;
    return _class;
});
},
'xfile/manager/MountManager':function(){
define([
    'dcl/dcl',
    "dojo/_base/lang",
    "xide/manager/ResourceManager",
    "xide/mixins/ReloadMixin",
    "xide/mixins/EventedMixin",
    "xide/types",
    'xide/utils',
    'dojo/Deferred'
], function (dcl, lang, ResourceManager, ReloadMixin, EventedMixin, types, utils,Deferred) {
    return dcl([ResourceManager, EventedMixin.dcl, ReloadMixin.dcl], {
        declaredClass: "xfile.manager.MountManager",
        serviceClass: "XApp_Resource_Service",
        mountData: null,
        didReload: false,
        editMount: function (mount) {
            /*
            if (!mount) {
                return;
            }
            if (mount.type === 'FILE_PROXY') {
                this.registerLocalMount(mount);
            } else if (mount.type === 'REMOTE_FILE_PROXY') {

                if (has('remote-vfs')) {
                    if (mount.adapter === 'Ftp') {
                        this.registerFTP(mount);
                    }
                    if (mount.adapter === 'Sftp') {
                        this.registerSFTP(mount);
                    }
                    if (mount.adapter === 'Dropbox') {
                        this.registerDropbox(mount);
                    }
                    if (mount.adapter === 'Webdav') {
                        this.registerWebDav(mount);
                    }
                }
            }
            */
        },
        removeMount: function (mount) {
            /*
            if (!mount) {
                return;
            }
            var thiz = this;
            var onOk = function () {
                var _cb = function () {
                    thiz.ls(function (data) {
                        thiz.onMountDataReady(data)
                    });
                };
                thiz.removeResource(mount, false, _cb);

            };

            var dlg = new FileDeleteDialog({
                title: 'Remove ' + mount.name,
                config: this.config,
                delegate: {
                    onOk: function () {
                        onOk();
                    }
                },
                ctx: this.ctx,
                titleBarClass: 'ui-state-error',
                inserts: [{
                    query: '.dijitDialogPaneContent',
                    insert: '<div><span class="fileManagerDialogText">Do you really want to remove this item' + '?</span></div>',
                    place: 'first'
                }]

            });
            domClass.add(dlg.domNode, 'fileOperationDialog');
            dlg.show();
            dlg.addActionButtons();
            dlg.fixHeight();
            dlg.resize();
            setTimeout(function () {
                dlg.resize();
            }, 1000);
            */
        },
        getMounts: function () {
            return this.mountData;
        },
        _onDialogOk: function (dlg, data, mount) {
            var options = utils.toOptions(data);
            var thiz = this;

            var isUpdate = mount.name != null;

            //build resource object
            var resourceObject = {
                "class": "cmx.types.Resource",
                "enabled": true
            };

            //merge options to resource config
            for (var i = 0; i < options.length; i++) {
                var option = options[i];
                if (option.user == null) {
                    resourceObject[option.name] = option.value;//std resource field
                } else {

                    //we put adapter specific fields into the resource's 'config' field
                    if (!resourceObject.config) {
                        resourceObject.config = {};
                    }
                    resourceObject.config[option.name] = option.value;
                }
            }

            //complete resource config
            var label = '';
            if (resourceObject.label) {
                label = resourceObject.label;
            } else if (resourceObject.config.label) {
                label = resourceObject.config.label;
            }

            resourceObject.name = '' + (mount.name != null ? mount.name : label.toLowerCase());

            if (resourceObject.config.type === 'FILE_PROXY') {
                resourceObject.path = '' + resourceObject.path + '';//VFS Local adjustment
                lang.mixin(resourceObject, resourceObject.config);
            } else if (resourceObject.config.type === 'REMOTE_FILE_PROXY') {
                resourceObject.path = resourceObject.name + '://';//VFS Remote adjustment
            }
            var _cb = function () {
                thiz.ls(function (data) {
                    thiz.onMountDataReady(data)
                });
            };
            if (!isUpdate) {
                this.createResource(resourceObject, false, _cb);
            } else {
                this.updateResource(resourceObject, false, _cb);
            }

        },
        registerLocalMount: function (mount) {
/*
            var name = mount ? mount.name : '';
            var path = mount ? mount.path : '';
            if (mount && mount.config && mount.config.path) {
                path = mount.config.path;
            }
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: name ? 'Edit Mount ' + name : 'New Local Mount',
                style: 'max-width:400px;min-height:300px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: name
                    }),
                    utils.createCI('path', 13, '', {
                        group: 'Common',
                        title: 'Path',
                        value: path
                    }),
                    utils.createCI('type', 13, '', {
                        visible: false,
                        value: "FILE_PROXY"
                    })
                ]
            });
            actionDialog.show();
            */
        },
        registerFTP: function (mount) {
/*
            mount = mount || {};
            var config = mount.config || {};


            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: mount.name ? 'Edit Ftp ' + mount.name : 'New Ftp',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: mount.name

                    }),
                    xide.utils.createCI('root', 13, '', {
                        group: 'Ftp',
                        title: 'Start Path',
                        value: config.root,
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Ftp'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'Ftp',
                        title: 'Host',
                        user: {
                            config: true
                        },
                        value: config.host
                    }),
                    xide.utils.createCI('username', 13, '', {
                        group: 'Ftp',
                        title: 'User',
                        user: {
                            config: true
                        },
                        value: config.username
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'Ftp',
                        title: 'Password',
                        user: {
                            config: true
                        },
                        value: config.password
                    }),
                    xide.utils.createCI('passive', 0, '', {
                        group: 'Ftp',
                        title: 'Passive',
                        user: {
                            config: true
                        },
                        value: config.passive
                    }),
                    xide.utils.createCI('ssl', 0, '', {
                        group: 'Ftp',
                        title: 'SSL',
                        user: {
                            config: true
                        },
                        value: config.ssl != null ? config.ssl : false
                    }),
                    xide.utils.createCI('port', 13, '', {
                        group: 'Ftp',
                        title: 'Port',
                        user: {
                            config: true
                        },
                        value: config.port != null ? config.port : 21
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerSFTP: function (mount) {
            /*
            mount = mount || {};
            var config = mount.config || {};


            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: mount.name ? 'Edit Ftp ' + mount.name : 'New Ftp',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: mount.name

                    }),
                    xide.utils.createCI('root', 13, '', {
                        group: 'SFtp',
                        title: 'Start Path',
                        value: config.root,
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Sftp'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'SFtp',
                        title: 'Host',
                        user: {
                            config: true
                        },
                        value: config.host
                    }),
                    xide.utils.createCI('username', 13, '', {
                        group: 'SFtp',
                        title: 'User',
                        user: {
                            config: true
                        },
                        value: config.username
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'SFtp',
                        title: 'Password',
                        user: {
                            config: true
                        },
                        value: config.password
                    }),
                    xide.utils.createCI('port', 13, '', {
                        group: 'SFtp',
                        title: 'Port',
                        user: {
                            config: true
                        },
                        value: config.port != null ? config.port : 22
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerDropbox: function (mount) {
            /*
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: 'New Dropbox',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: 'Dropbox1'

                    }),
                    xide.utils.createCI('pathPrefix', 13, '', {
                        group: 'Common',
                        title: 'Start Path',
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Dropbox'
                    }),
                    xide.utils.createCI('token', 13, '', {
                        group: 'Dropbox',
                        title: 'Token',
                        user: {
                            config: true
                        },
                        value: 'h16UVItP7qQAAAAAAAAABP3qmBJFOHj3fA5ffKyaHH-j7HCLvFOceZxhENV0sy24'
                    }),
                    xide.utils.createCI('appname', 13, '', {
                        group: 'Dropbox',
                        title: 'App Name',
                        user: {
                            config: true
                        },
                        value: 'xapp_local'
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerWebDav: function () {
            /*
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: 'New Webdav',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'name'
                    }),
                    xide.utils.createCI('pathPrefix', 13, '', {
                        group: 'Common',
                        title: 'Start Path'
                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'WebDav'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'WebDav',
                        title: 'Host'
                    }),
                    xide.utils.createCI('baseUri', 13, '', {
                        group: 'WebDav',
                        title: 'Base URI'
                    }),
                    xide.utils.createCI('userName', 13, '', {
                        group: 'WebDav',
                        title: 'User Name'
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'WebDav',
                        title: 'Password'
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })
                ]
            });
            actionDialog.show();
            */
        },
        onMountDataReady: function (data) {
            this.mountData = data;
            this.publish(types.EVENTS.ON_MOUNT_DATA_READY, {data: data});
            var thiz = this;
            setTimeout(function () {
                thiz.publish(types.EVENTS.ON_MOUNT_DATA_READY, {data: data});
            }, 4000);
        },
        check: function () {
            if (!this.serviceObject)
                this._initService();
        },
        /**
         * Callback when context initializes us
         */
        init: function () {
            if (this.ctx.getFileManager()) {
                this.serviceObject = this.ctx.getFileManager().serviceObject;
            }
        },
        /////////////////////////////////////////////////////////////////////////////////
        //
        //  Server Methods
        //
        //////////////////////////////////////////////////////////////////////////////////
        createResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'createResource', [resource, test], readyCB, true);
        },
        removeResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'removeResource', [resource, true], readyCB, true);
        },
        updateResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'updateResource', [resource, true], readyCB, true);
        },

        ls: function (readyCB) {

            function data(_data){
                this.mountData = _data;
                this.onMountDataReady(_data);
                if (readyCB) {
                    readyCB(_data);
                }
            }
            if(this.prefetch){
                var dfd = new Deferred();
                dfd.resolve(this.prefetch);
                data.apply(this,[this.prefetch]);
                delete this.prefetch;
                return dfd;
            }

            return this.runDeferred(null, 'ls', []).then(data.bind(this));
        }
    });
});
},
'xide/model/Path':function(){
/** @module xide/model/Path */
define([
    "xide/utils",
    "dcl/dcl"
], function (utils, dcl) {
    var Path = dcl(null, {
        declaredClass: "xide.model.Path",
        /**
         * @class xide.model.Path
         * @constructor
         */
        constructor: function (path, hasLeading, hasTrailing) {
            path = path || '.';  // if empty string, use '.'
            if (typeof path == 'string') {
                this.path = path;
                this.getSegments();
            } else {
                this.segments = path;
                this.hasLeading = hasLeading !== null ? hasLeading : false;
                this.hasTrailing = hasTrailing !== null ? hasLeading : false;
            }
        },

        endsWith: function (tail) {
            var segments = utils.clone(this.segments);
            var tailSegments = (new Path(tail)).getSegments();
            while (tailSegments.length > 0 && segments.length > 0) {
                if (tailSegments.pop() != segments.pop()) {
                    return false;
                }
            }
            return true;
        },
        getExtension: function () {
            if (!this.extension) {
                this.extension = this.path.substr(this.path.lastIndexOf('.') + 1);
            }
            return this.extension;
        },
        segment: function (index) {
            var segs = this.getSegments();
            if (segs.length < index) {
                return null;
            }
            return segs[index];
        },
        /**
         * Return all items under this path
         * @param items {String[]}
         * @param recursive {boolean}
         * @returns {String[]}
         */
        getChildren: function (items, recursive) {
            var result = [];
            var root = this,
                path = this.toString();

            function addChild(child) {
                var _path = typeof child !== 'string' ? child.toString() : child;
                if (_path !== path && result.indexOf(_path) == -1) {
                    result.push(_path);
                }
            }

            _.each(items, function (item) {
                var child = new Path(item);
                //root match
                if (child.startsWith(root)) {
                    if (recursive) {
                        addChild(child.toString());
                    } else {

                        var diff = child.relativeTo(path);
                        if (diff) {
                            var diffSegments = diff.getSegments();
                            //direct child
                            if (diffSegments.length == 1) {
                                addChild(child);
                            } else if (diffSegments.length > 1) {

                                //make sure that its parent has been added:
                                var parent = child.getParentPath();
                                var parentDiff = parent.relativeTo(path);

                                //check diff again
                                if (parentDiff.getSegments().length == 1) {
                                    addChild(parent.toString());
                                }
                            }
                        }
                    }

                }
            });
            return result;
        },
        getSegments: function () {
            if (!this.segments) {
                var path = this.path;
                this.segments = path.split('/');
                if (path.charAt(0) == '/') {
                    this.hasLeading = true;
                }
                if (path.charAt(path.length - 1) == '/') {
                    this.hasTrailing = true;
                    // If the path ends in '/', split() will create an array whose last element
                    // is an empty string. Remove that here.
                    this.segments.pop();
                }
                this._canonicalize();
            }
            return this.segments;
        },
        isAbsolute: function () {
            return this.hasLeading;
        },
        getParentPath: function () {
            if (!this._parentPath) {
                var parentSegments = utils.clone(this.segments);
                parentSegments.pop();
                this._parentPath = new Path(parentSegments, this.hasLeading);
            }
            return utils.clone(this._parentPath);
        },
        _clone: function () {
            return new Path(utils.clone(this.segments), this.hasLeading, this.hasTrailing);
        },
        append: function (tail) {
            tail = tail || "";
            if (typeof tail == 'string') {
                tail = new Path(tail);
            }
            if (tail.isAbsolute()) {
                return tail;
            }
            var mySegments = this.segments;
            var tailSegments = tail.getSegments();
            var newSegments = mySegments.concat(tailSegments);
            var result = new Path(newSegments, this.hasLeading, tail.hasTrailing);
            if (tailSegments[0] == ".." || tailSegments[0] == ".") {
                result._canonicalize();
            }
            return result;
        },
        toString: function () {
            var result = [];
            if (this.hasLeading) {
                result.push('/');
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (i > 0) {
                    result.push('/');
                }
                result.push(this.segments[i]);
            }
            if (this.hasTrailing) {
                result.push('/');
            }
            return result.join("");
        },
        removeRelative: function () {
            var segs = this.getSegments();
            if (segs.length > 0 && segs[1] == ".") {
                return this.removeFirstSegments(1);
            }
            return this;
        },
        relativeTo: function (base, ignoreFilename) {
            if (typeof base == 'string') {
                base = new Path(base);
            }
            var mySegments = this.segments;
            if (this.isAbsolute()) {
                return this;
            }
            var baseSegments = base.getSegments();
            var commonLength = this.matchingFirstSegments(base);
            var baseSegmentLength = baseSegments.length;
            if (ignoreFilename) {
                baseSegmentLength = baseSegmentLength - 1;
            }
            var differenceLength = baseSegmentLength - commonLength;
            var newSegmentLength = differenceLength + mySegments.length - commonLength;
            if (newSegmentLength == 0) {
                return Path.EMPTY;
            }
            var newSegments = [];
            for (var i = 0; i < differenceLength; i++) {
                newSegments.push('..');
            }
            for (var i = commonLength; i < mySegments.length; i++) {
                newSegments.push(mySegments[i]);
            }
            return new Path(newSegments, false, this.hasTrailing);
        },
        startsWith: function (anotherPath) {
            var count = this.matchingFirstSegments(anotherPath);
            return anotherPath._length() == count;
        },
        _length: function () {
            return this.segments.length;
        },
        matchingFirstSegments: function (anotherPath) {
            var mySegments = this.segments;
            var pathSegments = anotherPath.getSegments();
            var max = Math.min(mySegments.length, pathSegments.length);
            var count = 0;
            for (var i = 0; i < max; i++) {
                if (mySegments[i] != pathSegments[i]) {
                    return count;
                }
                count++;
            }
            return count;
        },
        removeFirstSegments: function (count) {
            return new Path(this.segments.slice(count, this.segments.length), this.hasLeading, this.hasTrailing);
        },
        removeMatchingLastSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this.removeLastSegments(match);
        },
        removeMatchingFirstSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this._clone().removeFirstSegments(match);
        },
        removeLastSegments: function (count) {
            if (!count) {
                count = 1;
            }
            return new Path(this.segments.slice(0, this.segments.length - count), this.hasLeading, this.hasTrailing);
        },
        lastSegment: function () {
            return this.segments[this.segments.length - 1];
        },
        firstSegment: function (length) {
            return this.segments[length || 0];
        },
        equals: function (anotherPath) {
            if (this.segments.length != anotherPath.segments.length) {
                return false;
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (anotherPath.segments[i] != this.segments[i]) {
                    return false;
                }
            }
            return true;
        },
        _canonicalize: function () {
            var doIt;
            var segments = this.segments;
            for (var i = 0; i < segments.length; i++) {
                if (segments[i] == "." || segments[i] == "..") {
                    doIt = true;
                    break;
                }
            }
            if (doIt) {
                var stack = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i] == "..") {
                        if (stack.length == 0) {
                            // if the stack is empty we are going out of our scope
                            // so we need to accumulate segments.  But only if the original
                            // path is relative.  If it is absolute then we can't go any higher than
                            // root so simply toss the .. references.
                            if (!this.hasLeading) {
                                stack.push(segments[i]); //stack push
                            }
                        } else {
                            // if the top is '..' then we are accumulating segments so don't pop
                            if (".." == stack[stack.length - 1]) {
                                stack.push("..");
                            } else {
                                stack.pop();
                            }
                        }
                        //collapse current references
                    } else if (segments[i] != "." || this.segments.length == 1) {
                        stack.push(segments[i]); //stack push
                    }
                }
                //if the number of segments hasn't changed, then no modification needed
                if (stack.length == segments.length) {
                    return;
                }
                this.segments = stack;
            }
        }

    });
    Path.EMPTY = new Path("");
    return Path;
});
},
'dojo/dom-style':function(){
define(["./sniff", "./dom"], function(has, dom){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			if(!node){
				return {};
			}
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			if(!node){
				console.error('getComputedStyle :: invalid node');
				return node;
			}
			return node.nodeType == 1 /* ELEMENT_NODE*/ ?
				node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	 style.getComputedStyle = function(node){
	 // summary:
	 //		Returns a "computed style" object.
	 //
	 // description:
	 //		Gets a "computed style" object which can be used to gather
	 //		information about the current state of the rendered node.
	 //
	 //		Note that this may behave differently on different browsers.
	 //		Values may have different formats and value encodings across
	 //		browsers.
	 //
	 //		Note also that this method is expensive.  Wherever possible,
	 //		reuse the returned object.
	 //
	 //		Use the dojo/dom-style.get() method for more consistent (pixelized)
	 //		return values.
	 //
	 // node: DOMNode
	 //		A reference to a DOM node. Does NOT support taking an
	 //		ID string for speed reasons.
	 // example:
	 //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
	 //	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
	 //	|	});
	 //
	 // example:
	 //		Reusing the returned object, avoiding multiple lookups:
	 //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
	 //	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
	 //	|		var w = cs.width, h = cs.height;
	 //	|	});
	 return; // CSS2Properties
	 };
	 =====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	 style.toPixelValue = function(node, value){
	 // summary:
	 //		converts style value to pixels on IE or return a numeric value.
	 // node: DOMNode
	 // value: String
	 // returns: Number
	 };
	 =====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
			function(node){
				return getComputedStyle(node).opacity;
			};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
			function(node, opacity){
				return node.style.opacity = opacity;
			};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
});

},
'dojo/Stateful':function(){
define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediatly
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendent class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});

},
'dojo/selector/lite':function(){
define(["../has", "../_base/kernel"], function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matchesSelector || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector; // IE9, WebKit, Firefox have this, but not Opera yet
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		// fast path regardless of whether or not querySelectorAll exists
		if(match[2]){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
});

},
'xbox/views/MainView':function(){
define([
    "dcl/dcl",
    'xide/views/_MainView',
    'xdocker/types'
], function (dcl,_MainView) {
    var RootView = dcl(null,{});
    return dcl([_MainView,RootView],{});
});

},
'dojo/dnd/autoscroll':function(){
define(["../_base/lang", "../sniff", "../_base/window", "../dom-geometry", "../dom-style", "../window"],
	function(lang, has, win, domGeom, domStyle, winUtils){

// module:
//		dojo/dnd/autoscroll

var exports = {
	// summary:
	//		Used by dojo/dnd/Manager to scroll document or internal node when the user
	//		drags near the edge of the viewport or a scrollable node
};
lang.setObject("dojo.dnd.autoscroll", exports);

exports.getViewport = winUtils.getBox;

exports.V_TRIGGER_AUTOSCROLL = 32;
exports.H_TRIGGER_AUTOSCROLL = 32;

exports.V_AUTOSCROLL_VALUE = 16;
exports.H_AUTOSCROLL_VALUE = 16;

// These are set by autoScrollStart().
// Set to default values in case autoScrollStart() isn't called. (back-compat, remove for 2.0)
var viewport,
	doc = win.doc,
	maxScrollTop = Infinity,
	maxScrollLeft = Infinity;

exports.autoScrollStart = function(d){
	// summary:
	//		Called at the start of a drag.
	// d: Document
	//		The document of the node being dragged.

	doc = d;
	viewport = winUtils.getBox(doc);

	// Save height/width of document at start of drag, before it gets distorted by a user dragging an avatar past
	// the document's edge
	var html = win.body(doc).parentNode;
	maxScrollTop = Math.max(html.scrollHeight - viewport.h, 0);
	maxScrollLeft = Math.max(html.scrollWidth - viewport.w, 0);	// usually 0
};

exports.autoScroll = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the window, if
	//		necessary
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!
	var v = viewport || winUtils.getBox(doc), // getBox() call for back-compat, in case autoScrollStart() wasn't called
		html = win.body(doc).parentNode,
		dx = 0, dy = 0;
	if(e.clientX < exports.H_TRIGGER_AUTOSCROLL){
		dx = -exports.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - exports.H_TRIGGER_AUTOSCROLL){
		dx = Math.min(exports.H_AUTOSCROLL_VALUE, maxScrollLeft - html.scrollLeft);	// don't scroll past edge of doc
	}
	if(e.clientY < exports.V_TRIGGER_AUTOSCROLL){
		dy = -exports.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - exports.V_TRIGGER_AUTOSCROLL){
		dy = Math.min(exports.V_AUTOSCROLL_VALUE, maxScrollTop - html.scrollTop);	// don't scroll past edge of doc
	}
	window.scrollBy(dx, dy);
};

exports._validNodes = {"div": 1, "p": 1, "td": 1};
exports._validOverflow = {"auto": 1, "scroll": 1};

exports.autoScrollNodes = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the first available
	//		Dom element, it falls back to exports.autoScroll()
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!

	var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;

	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in exports._validNodes)){
			var s = domStyle.getComputedStyle(n),
				overflowX = (s.overflowX.toLowerCase() in exports._validOverflow),
				overflowY = (s.overflowY.toLowerCase() in exports._validOverflow);
			if(overflowX || overflowY){
				b = domGeom.getContentBox(n, s);
				t = domGeom.position(n, true);
			}
			// overflow-x
			if(overflowX){
				w = Math.min(exports.H_TRIGGER_AUTOSCROLL, b.w / 2);
				rx = e.pageX - t.x;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += win.body().scrollLeft;
				}
				dx = 0;
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
					oldLeft = n.scrollLeft;
					n.scrollLeft = n.scrollLeft + dx;
				}
			}
			// overflow-y
			if(overflowY){
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				h = Math.min(exports.V_TRIGGER_AUTOSCROLL, b.h / 2);
				ry = e.pageY - t.y;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					ry += win.body().scrollTop;
				}
				dy = 0;
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
					oldTop = n.scrollTop;
					n.scrollTop  = n.scrollTop  + dy;
				}
			}
			if(dx || dy){ return; }
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	exports.autoScroll(e);
};

return exports;

});

},
'xide/views/_MainView':function(){
/** module:xide/views/_MainView **/
define([
    'xide/types',
    'xdojo/has',
    'xdocker/Docker2',
    'dcl/dcl',
    'xide/utils',
    'xide/views/_LayoutMixin',
    'xide/_base/_Widget',
    'xaction/ActionProvider',
    //'xfile/Breadcrumb',
    'xide/widgets/MainMenu',
    'xide/widgets/ActionToolbar',
    'xide/widgets/Ribbon',
    'xide/registry',
    "wcDocker/iframe",
    "wcDocker/types",
    'dojo/text!./welcome.html',
    'xide/$'
], function (types, has, Docker, dcl, utils, _LayoutMixin, _Widget, ActionProvider, /*Breadcrumb*/MainMenu, ActionToolbar, Ribbon, registry, iframe, dTypes, _Welcome,$) {
    var ACTION = types.ACTION;
    var LayoutClass = dcl(null, {});

    var BorderLayoutClass = dcl(LayoutClass, {
        welcomePage: null,
        welcomeWidget: null,
        getLayoutMain: function (args, create) {
        },
        getLastTab: function () {
            var panels = this.getDocker().allPanels(),
                main = this.getLayoutMain();
            return _.find(panels, function (panel) {
                var canAdd = panel.option('canAdd');
                return panel != main && canAdd === true;
            });

        },
        /**
         * Std
         * @param args
         * @returns {module:xDocker/Panel2}
         */
        getNewDefaultTab: function (args) {
            var docker = this.getDocker(),
                main = this.getLayoutMain(),
                last = this.getLastTab();

            var DOCKER_TYPE = types.DOCKER;

            if (this.hasAction(ACTION.NAVIGATION)) {
                utils.mixin(args, {
                    target: this.layoutCenter,
                    location: DOCKER_TYPE.DOCK.STACKED,
                    tabOrientation: DOCKER_TYPE.TAB.TOP,
                    dynamic: true
                });
                return this.getDocker().addTab(null, args);
            }

            var targetTab = last || main;
            utils.mixin(args, {
                target: targetTab,
                location: DOCKER_TYPE.DOCK.STACKED,
                tabOrientation: DOCKER_TYPE.TAB.TOP
            });

            if (targetTab && targetTab.option('autoHideTabBar') === true) {
                targetTab.getFrame().showTitlebar(true);
                var title = targetTab.option('titleStacked');
                targetTab.title(title);
            }

            var tab = docker.addTab(null, args);
            setTimeout(function () {
                docker.resize();
            }, 100);
            return tab;
        },
        createWidgets: function () {

            var top = this.layoutTop;
            if (this.hasAction(ACTION.MAIN_MENU)) {
                var _args = {
                    style: 'height:auto',
                    resizeToParent: false,
                    actionStores: [this.ctx.getActionStore()]
                };
                this.mainMenu = utils.addWidget(MainMenu, _args, this, top, true);
                $(this.mainMenu.domNode).css({
                    'height': 'auto',
                    'min-height': 31
                });
                //top.resizeToChildren = true;
                //top.add(this.mainMenu);
                //this.getDocker().resize();
                //top.resize();
            }/*
            if (this.hasAction(ACTION.RIBBON)) {
                top.resizeToChildren = true;
                this.toolbar = utils.addWidget(Ribbon, {
                    cssClass:'MainRibbonToolbar',
                    //actionStores: [this.ctx.getActionStore()],
                    actionFilter: {
                        quick: true
                    }
                }, null, top, true);
            }
            */
            if (this.hasAction(ACTION.TOOLBAR)) {
                //top.minHeight()
                this.toolbar = utils.addWidget(ActionToolbar, {
                    //attachToGlobal: true,
                    visibility: types.ACTION_VISIBILITY.QUICK_LAUNCH,
                    actionFilter: {
                        quick: true
                    },
                    _hide: false
                }, null, top, true);
                $(this.toolbar.domNode).css({
                    'margin-right': '16px'
                });
                this.toolbar.$navigation.addClass('quickToolbar');
                //top.resizeToChildren = true;
                //top.add(this.toolbar);
                //this.getDocker().resize();
                //top.resize();
            }

            if (this.hasAction(ACTION.BREADCRUMB)) {

                return;
                /*
                 var breadcrumb = utils.addWidget(Breadcrumb, {
                 resizeToParent: false
                 }, null, top, true);

                 breadcrumb.resizeToParent = false;
                 top._parent.$container.css({
                 padding:0
                 });
                 var _frame = top.getFrame();
                 _frame.$frame.css({
                 'border-radius':0
                 })

                 var bcNode = $(breadcrumb.domNode);
                 $(breadcrumb.domNode).css({
                 'height':'auto',
                 'width':'40%'
                 //'float':'left'
                 });
                 this.breadcrumb = breadcrumb;
                 */
            }
            top && top.resize();

        },
        createBottom: function () {
            var layoutBottom = this.getDocker().addPanel('DefaultTab', types.DOCKER.DOCK.BOTTOM, null, {
                w: '33%',
                h: '20px',
                title: '&nbsp;&nbsp;',
                mixin: {
                    _scrollable: {
                        x: false,
                        y: false
                    }
                }
            });
            layoutBottom._minSize.y = 40;
            this.layoutBottom = layoutBottom;
            layoutBottom.minSize(null, 30);
            layoutBottom.maxSize(null, 30);
            layoutBottom.closeable(false);
            layoutBottom.resizeToChildren = false;
            layoutBottom.getFrame().showTitlebar(false);
            return layoutBottom;
        },
        createLayout: function (docker, permissions) {
            var self = this,
                top;
            if (this.hasAction(ACTION.BREADCRUMB) || this.hasAction(ACTION.MAIN_MENU) || this.hasAction(ACTION.RIBBON)) {
                top = this.layoutTop = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.TOP, null, {
                    h: 50,
                    title: '&nbsp;&nbsp;',
                    canAdd: false,
                    mixin: {
                        _scrollable: {
                            x: false,
                            y: false
                        }
                    }

                });
                top.title(false);
                top.initSize(null, 37);
                top.maxSize(null, 44);
                //top.resizeToChildren = true;

            }
            if(this.hasAction(ACTION.NAVIGATION)){
                this.layoutLeft = docker.addPanel('DefaultTab', types.DOCKER.DOCK.BOTTOM, top, {
                    title: '&nbsp;&nbsp;',
                    autoHideTabBar: true,
                    titleStacked: "Navigation"
                });

                this.layoutLeft.closeable(false);
                this.layoutLeft.resizeToChildren = false;
                this.layoutLeft.getFrame().showTitlebar(false);
                $(this.layoutLeft.containerNode).css({
                    'overflow-x': 'hidden',
                    'overflow-y': 'auto'
                });
            }
            if (this.hasAction(ACTION.NAVIGATION)) {
                if (this.hasAction(ACTION.WELCOME)) {
                    this.layoutCenter = docker.addPanel('DefaultTab', types.DOCKER.DOCK.RIGHT, this.layoutLeft, {
                        w: '80%',
                        title: 'Welcome',
                        mixin: {
                            isDefault: true
                        }
                    });
                    this.layoutCenter.closeable(false);
                    this.layoutCenter.containerNode.id = 'editorsStackContainer';
                    this.layoutCenter.containerNode.domNode=this.layoutCenter.containerNode;
                    registry.add(this.layoutCenter.containerNode);
                    if (has('xcf')) {
                        var iFrame = null;
                        if ( false ) {

                            this.ctx.getSettingsManager().initStore().then(function () {
                                if(!has('x-markdown')) {
                                    var $container = $('<div style="position:absolute;top:0;left:0;right:0;bottom:0;"></div>');
                                    this.layoutCenter.layout().addItem($container);
                                    iFrame = new iframe($container, this.layoutCenter);
                                    iFrame.openURL("../../../Control-Freak-Documentation/daux/Getting_Started?theme=" + self.ctx.getApplication().getTheme());
                                    self.layoutCenter.startLoading('Loading...');
                                    iFrame.onLoaded(function () {
                                        self.layoutCenter.finishLoading(250);
                                    });
                                }else{
                                    //this is handled by the application
                                }
                            });
                        } else {

                            if(!has('x-markdown')) {
                                var $container = $('<div style="position:absolute;top:0;left:0;right:0;bottom:0;"></div>');
                                this.layoutCenter.layout().addItem($container);
                                var url = "../../../docs/Getting_Started.html";
                                iFrame = new iframe($container, this.layoutCenter);
                                iFrame.openURL(url);
                                this.layoutCenter.startLoading('Loading...');
                                iFrame.onLoaded(function () {
                                    self.layoutCenter.finishLoading(250);
                                });
                            }else{
                                //this is handled by the application
                            }

                        }
                        this.welcomePage = this.layoutCenter;
                        if(iFrame) {
                            this.welcomeWidget = iFrame;
                            this.welcomeWidget.domNode = this.welcomeWidget.$container[0];
                        }

                    } else {
                        var widget = utils.addWidget(_Widget, {
                            templateString: _Welcome,
                            resizeToParent: true
                        }, null, this.layoutCenter, true);
                        this.layoutCenter.add(widget, null, false);
                    }
                    this.layoutCenter.resize();
                    //make maqetta happy til we updated xideve
                    if ( false  && this.welcomeWidget) {
                        this.welcomeWidget.id = 'editorsStackContainer';
                        registry.add(this.welcomeWidget);
                    }
                }
            }
            if (this.hasAction(ACTION.STATUSBAR)) {
                this.createBottom();
                this.subscribe(types.EVENTS.ON_STATUS_MESSAGE);
            }
            docker.resize();

            var spl = top ? top.getSplitter() : null;
            if(spl){
                spl.$bar.css('display','none');
            }

        }
    });

    var permissions = [
        //ACTION.BREADCRUMB,
        //ACTION.RIBBON,
        ACTION.MAIN_MENU,
        ACTION.NAVIGATION,
        ACTION.STATUSBAR,
        ACTION.WELCOME,
        ACTION.TOOLBAR
    ];

    if (has('phone')) {
        permissions = [
            ACTION.NAVIGATION
        ];
    }
    /**
     * @class module:xide/views/_MainView
     * @extends module:xide/_base/_Widget
     * @extends module:xide/views/_LayoutMixin
     */
    var DockerView = dcl([_Widget, _LayoutMixin.dcl, ActionProvider.dcl, BorderLayoutClass], {
        templateString: '<div style="height: 100%;width: 100%;"></div>',
        _statusMessageTimer: null,
        permissions: permissions,
        createStatusbar: function (where) {
            if (!this.layoutBottom) {
                return null;
            }
            where = this.layoutBottom.containerNode;
            var statusbar = this.statusbar,
                self = this;

            if (!statusbar) {
                var root = $('<div class="statusbar widget" style="width:inherit;padding: 0;margin:0;padding-left: 4px;min-height: 10px;height:100%"></div>')[0];
                where.appendChild(root);
                statusbar = $('<div class="status-bar-text ellipsis" style="display: inline-block;">0 items selected</div>')[0];
                root.appendChild(statusbar);
                var $collapser = $('<div class="status-bar-collapser" style="" ></div>');
                $collapser.click(function (e) {
                    self.onStatusbarCollapse($collapser);
                });
                var collapser = $collapser[0];
                root.appendChild(collapser);
                this.statusbar = statusbar;
                //this.statusbarCollapse = collapser;
                this.statusbarRoot = root;
                this._emit('createStatusbar', {
                    root: root,
                    statusbar: statusbar,
                    collapser: collapser
                });
            }
            return statusbar;
        },
        onStatusMessage: function (evt) {
            if (this._statusMessageTimer) {
                clearTimeout(this._statusMessageTimer);
                this._statusMessageTimer=null;
            }
            var statusbar = this.getStatusbar();
            var pane = this.layoutBottom;
            if (!pane) {
                return;
            }
            var text = evt.text;
            if (evt.type) {
                if (evt.type === 'error') {
                    text = '<span class="statusbarMessage text-danger">' + text + '</span>';
                }
                if (evt.type === 'warning') {
                    text = '<span class="statusbarMessage text-warning">' + text + '</span>';
                }
                if (evt.type === 'info') {
                    text = '<span class="statusbarMessage text-info">' + text + '</span>';
                }
            }
            statusbar.innerHTML = text;

            this._statusMessageTimer = setTimeout(function () {
                statusbar.innerHTML = "";
            }, evt.delay || 5000);

        },
        getStatusbar: function () {
            if (this.statusbar) {
                return this.statusbar;
            } else {
                return this.createStatusbar();
            }
        },
        getMainMenu: function () {
            return this.mainMenu;
        },
        getBreadcrumb: function () {
            return this.breadcrumb;
        },
        initWithConfig: function () {
        },
        /**
         * @returns {module:xdocker/Panel2}
         */
        getLayoutMain: function () {
            return this.layoutLeft;
        },
        /**
         * @returns {module:xdocker/Panel2}
         */
        getLayoutLeft: function () {
            return this.layoutLeft;
        },
        /**
         * @returns {module:xdocker/Panel2}
         */
        getLayoutCenter: function () {
            return this.layoutCenter;
        },
        getToolbar: function () {
            return this.toolbar;
        },
        onLastPanelClosed: function () {
            var main = this.getLayoutMain();
            if (main.option('autoHideTabBar')) {
                main.title(main.option('title'));
                main.getFrame().showTitlebar(false);
            }
            this.getDocker().resize();
        },
        onPanelClosed: function () {
            var self = this,
                main = self.getLayoutMain(),
                docker = self.getDocker();
            setTimeout(function () {
                var panels = docker.allPanels().filter(function (panel) {
                    return panel.option('canAdd') !== false;
                });
                if (panels.length == 1 && panels[0] == main) {
                    self.onLastPanelClosed();
                }
            }, 1);
            this.getDocker().resize();
        },
        _resizeToWindow: function () {
            var target = $('#root')[0];
            var staticTop = $('#staticTopContainer');
            var staticTopH = 0;
            if (staticTop && staticTop) {
                staticTopH = staticTop.height();
            }
            utils.resizeTo(target, window, true, true, null, {
                h: -staticTopH
            });
            if (this.layoutMain) {
                utils.resizeTo(this.layoutMain, target, true, true);
                this.layoutMain.resize();
                var _total = $('#root').height();
                _total -= this.extraBottomHeight;
                _toolbar -= staticTopH;
                var _toolbar = $(this.layoutTop.domNode).height();
                $(this.layoutCenter.domNode).css('height', _total - _toolbar);
            }
            this.getDocker().resize();
        },
        _resize: function () {
            this._resizeToWindow();
            this.publish(types.EVENTS.RESIZE, {}, this);
            $('window').trigger('resize');
            this.getDocker().resize();
        },
        startup: function () {
            var docker = Docker.createDefault(this.domNode);
            this.add(docker, null, false);
            this._docker = docker;
            var self = this;
            docker._on(dTypes.EVENT.CLOSED, function (panel) {
                self.onPanelClosed(panel);
            });
            this.createLayout(docker, this.permissions);
            this.createWidgets();
            function _resize() {
                self._resize();
            }

            $(window).resize(function () {
                return self.debounce('resize', _resize.bind(self), 1000, null);
            });
            setTimeout(function(){
                self._resizeToWindow();
            },1000);
        }
    });
    dcl.chainAfter(DockerView, 'startup');
    dcl.chainAfter(DockerView, 'resize');
    dcl.chainAfter(DockerView, 'createLayout');
    dcl.chainAfter(DockerView, 'createWidgets');
    return DockerView;
});
},
'xide/widgets/MainMenu':function(){
/** @module xide/widgets/MainMenu **/
define([
    'dcl/dcl',
    'xide/types',
    'xide/_base/_Widget',
    'xlang/i18',
    "xide/mixins/ActionMixin",
    'xaction/ActionContext',
    "xide/widgets/_MenuMixin4",
    "xide/model/Path",
    "xide/$",
    "xide/lodash",
    "xide/widgets/_MenuKeyboard"
], function (dcl, types, _XWidget, i18, ActionMixin, ActionContext, MenuMixinClass, Path,$,_,_MenuKeyboard) {
    var _debug = false;
    var ContainerClass = dcl([_XWidget, ActionContext.dcl, ActionMixin.dcl], {
        templateString: '<div class="navbar navbar-default mainMenu bg-opaque">' +
        '<nav attachTo="navigation" class="" role="navigation">' +
        '<ul tabindex="-1" attachTo="navBar" class="nav navbar-nav"/>' +
        '</nav>' +
        '</div>'
    });
    var ActionRendererClass = dcl(null, {
        renderTopLevel: function (name, where) {
            var val  = i18.localize(name);
            var shortcutKey = "";
            var text;
            var ndx =0;
            if(ndx >= 0){
                shortcutKey = val.charAt(ndx);
                var prefix = val.substr(0, ndx);
                var suffix = val.substr(ndx + 1);
                val = prefix + '<span class="shortcutKey">' + shortcutKey + '</span>' + suffix;
                this.shortcuts[shortcutKey]=name;
            }
            where = where || $(this.getRootContainer());
            var item = $('<li tabindex="-1" class="dropdown">' +
                '<a href="#" data-delay="1500" class="dropdown-toggle" data-toggle="dropdown">' + val + '<b class="caret"></b></a>' +
                '</li>');
            where.append(item);
            //var trigger = item.find('A');
            //trigger.bootstrapDropdownHover();
            return item;
        },
        getRootContainer: function () {
            return this.navBar;
        }
    });
    var KeyboardControl = _MenuKeyboard;
    var MainMenu = dcl([ContainerClass, ActionRendererClass, MenuMixinClass, _XWidget.StoreMixin], {
        target: null,
        visibility: types.ACTION_VISIBILITY.MAIN_MENU,
        attachToGlobal: true,
        declaredClass: 'xide.widgets.MainMenu',
        shortcuts:null,
        _topLevelMenu:null,
        _altDown:false,
        _shiftDown:false,
        addContext: function (selector, data) {
            var id,
                $menu,
                self = this;
            if (typeof data.id !== 'undefined' && typeof data.data !== 'undefined') {
                id = data.id;
                $menu = $('body').find('#dropdown-' + id)[0];
                if (typeof $menu === 'undefined') {
                    $menu = self.buildMenu(data.data, id);
                    selector.append($menu);
                }
            } else {
                var d = new Date();
                id = d.getTime();
                $menu = self.buildMenu(data, id);
                selector.append($menu);
            }
            return $menu;
        },
        onRootAction: function (level, container) {
            return this.renderTopLevel(level, container);
        },
        setActionStore: function (store, owner) {
            this._clear();
            this._tmpActions = [];
            delete this._topLevelMenu;
            this._topLevelMenu={};
            this.store = store;
            if (!store) {
                return;
            }
            this.addActionStore(store);
            var self = this,
                visibility = self.visibility,
                rootContainer = $(self.getRootContainer()),
                tree = self.buildActionTree(store, owner),
                allActions = tree.allActions,
                rootActions = tree.rootActions,
                allActionPaths = tree.allActionPaths,
                delegate = this.delegate;

            /*
             var mapping = Keyboard.defaultMapping(keyCombo, handler, keyProfile || types.KEYBOARD_PROFILE.DEFAULT, keyTarget, keyScope, [action]);
             mapping = this.registerKeyboardMapping(mapping);
             keyboardMappings.push(mapping);
             */

            function registerRootKeyboardHandler(name){
                var keyboardCombo = 'alt ' + name[0];
            }

            _.each(tree.root, function (menuActions, level) {

                var root = self.onRootAction(level, rootContainer);
                self._topLevelMenu[level]=root;
                var lastHeader = {
                    header: ''
                };

                // final menu data
                var data = [];
                var groupedActions = menuActions.grouped;

                //temp group string of the last rendered action's group
                var lastGroup = '';
                _.each(menuActions, function (command) {
                    var action = self.getAction(command, store);
                    var isDynamicAction = false;
                    if (!action) {
                        isDynamicAction = true;
                        action = self.createAction(command);
                    }
                    if (action) {
                        var renderData = self.getActionData(action);
                        var icon = renderData.icon,
                            label = renderData.label,
                            visibility = renderData.visibility,
                            group = renderData.group;

                        if (visibility === false) {
                            return;
                        }
                        if (!isDynamicAction && group && groupedActions[group] && groupedActions[group].length >= 1) {
                            if (lastGroup !== group) {
                                var name = groupedActions[group].length >= 2 ? i18.localize(group) : "";
                                lastHeader = {header: name};
                                data.push(lastHeader);
                                lastGroup = group;
                            }
                        }
                        var item = self.toMenuItem(action, owner, label, icon, visibility || {}, true);
                        data.push(item);
                        visibility.widget = item;
                        self.addReference(action, item);

                        function parseChildren(command, parent) {

                            var childPaths = new Path(command).getChildren(allActionPaths, false),
                                isContainer = childPaths.length > 0,
                                childActions = isContainer ? self.toActions(childPaths, store) : null;

                            if (isContainer && childActions) {
                                var subs = [];
                                _.each(childActions, function (child) {
                                    var _renderData = self.getActionData(child);
                                    var _item = self.toMenuItem(child, owner, _renderData.label, _renderData.icon, _renderData.visibility, true);
                                    self.addReference(child, _item);
                                    subs.push(_item);
                                    var _childPaths = new Path(child.command).getChildren(allActionPaths, false);
                                    _childPaths.length > 0 && parseChildren(child.command, _item);
                                });
                                parent.subMenu = subs;
                            }
                        }

                        parseChildren(command, item);
                    }
                });
                return self.attach(root, data);
            });

            self.onDidRenderActions(store, owner);
        },
        startup: function () {
            this.init({preventDoubleContext: false});
            if (this.attachToGlobal) {
                var node = $('#staticTopContainer');
                if (!node[0]) {
                    var body = $('body');
                    node = $('<div id="staticTopContainer" class=""></div>');
                    body.prepend(node);
                }
                node.append($(this.domNode));
            }
        },
        lastFocused:null,
        setupKeyboard:function(node){

            function keyhandler(e){
                try {
                    if(e && e.target && e.target.className) {
                        var className = e.target.className.toLowerCase();
                        if (e.target.tagName !== 'BUTTON' && className.indexOf('input') == -1) {
                            e.keyCode === 16 && (this._shiftDown = e.type === 'keydown');
                            if (e.keyCode == 27) {
                                var navData = this.keyboardController.toNavigationData($(e.target), this.getRootContainer());
                                navData && navData.element && this.keyboardController.close(navData.element);
                                $(this.lastFocused).focus();
                            }
                            if (this._shiftDown && e.key in this.shortcuts) {
                                this.lastFocused = document.activeElement;
                                //open root
                                this.keyboardController.openRoot(null, this._topLevelMenu[this.shortcuts[e.key]]);
                            }
                        }
                    }
                }catch (e){
                    logError(e,'error in keyboard handler');
                }
            }
            $(node).on('keydown',keyhandler.bind(this));
        },
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            this.shortcuts = {};

            this.setupKeyboard(this.delegate._domNode || typeof document !=='undefined' ? document : null);

            var options = this.getDefaultOptions();
            this.keyboardController = new KeyboardControl();
            this.keyboardController.setup(this);
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);


            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });

            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            function mouseEnterHandlerSubs(e){
                var navigationData = this.keyboardController.toNavigationData($(e.target),self.getRootContainer());
                if(!navigationData) {
                    return;
                }
                var _parent = navigationData.parent;
                _parent.focus();
                navigationData.element.focus();
                _parent.data('currentTarget',navigationData.element);
                this.keyboardController.initContainer(_parent);
            }
            this.__on(this.getRootContainer(), 'mouseenter', '.dropdown-menu >LI', mouseEnterHandlerSubs.bind(this));
        }
    });
    return MainMenu;
});
},
'xide/layout/ContentPane':function(){
define([
    'dcl/dcl',
    "dojo/_base/array",
    "dojo/dom-style",
    "dojo/dom-geometry", // domGeometry.position
    'xide/types',
    'xide/mixins/EventedMixin',
    "xide/_base/_Widget"
], function (dcl, array, domStyle, registry, domGeometry, types, _Widget) {

    return dcl(_Widget, {
        templateString:'<div></div>',
        declareClass: "xide.layout.ContentPane",
        cssClass: "layoutContainer",
        region: 'center',
        closable: false,
        adjustChildsToWidth: false,
        didClose: false,
        isOpen: function () {
            return this.didClose !== true;
        },
        onToggleSplitter: function (state) {
        },
        sameWidth: function () {

            var max = 0;
            var children = this.containerNode.children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (!child.style) {
                    continue;
                }
                domStyle.set(child, {
                    width: 'auto'
                });
                var box = domGeometry.getContentBox(child);
                if (box.w > max) {
                    max = box.w;
                }
            }

            max -= 15;

            for (var i = 0; i < children.length; i++) {
                var child = children[i];

                if (!child.style) {
                    continue;
                }

                domStyle.set(child, {
                    width: max + 'px'
                });
            }
        },
        onResize: function () {

            if (this.adjustChildsToWidth) {
                this.sameWidth();
            }

            array.forEach(registry.findWidgets(this.containerNode), function (child) {
                if (child.onResize) {
                    child.onResize();
                }
            });
        },
        getOnShowTarget: function () {
            return this;
        },
        onShow: function () {

            this.inherited(arguments);
            this.resize();

            if (this.adjustChildsToWidth) {
                this.sameWidth();
            }

            if (this.onResize) {
                this.onResize();
            }

            this._emit(types.EVENTS.ON_VIEW_SHOW, {
                view: this.getOnShowTarget(),
                item: this.item
            });
            _.each(registry.findWidgets(this.containerNode), function (child) {
                if (child.onShow) {
                    child.onShow();
                }
            });

        },
        _close: function () {
            var splitter = this._splitterWidget;
            if (splitter) {
                switch (splitter.state) {
                    case "collapsed":
                    case "full":
                        splitter.set("state", 'closed');
                }

                this.publish(types.EVENTS.RESIZE, {}, this);
            }
        },
        _open: function () {
            var splitter = this._splitterWidget;
            if (splitter) {
                switch (splitter.state) {
                    case "full":
                        break;
                    case "collapsed":
                    case "closed":
                    {
                        splitter.set("state", 'full');

                        this.publish(types.EVENTS.RESIZE, {}, this);

                        break;
                    }
                }
            }
        },
        startup: function () {
            var splitter = this._splitterWidget,
                self = this;
            if (splitter) {
                splitter._on('splitterMoveEnd', function (e) {
                    self._emit('splitterMoveEnd');
                });

                splitter._on('splitterMoveStart', function (e) {
                    self._emit('splitterMoveStart');
                });
            }

        }
    });
});
},
'dojo/has':function(){
define(["require", "module"], function(require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(! 1 ){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			global = this,
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		 1 || has.add("host-browser", isBrowser);
		 1 || has.add("dom", isBrowser);
		 0 && has.add("dojo-dom-ready-api", 1);
		 0 && has.add("dojo-sniff", 1);
	}

	if( 1 ){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);
		has.add("touch", "ontouchstart" in document || window.navigator.msMaxTouchPoints > 0);
		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
});

},
'xaction/Action':function(){
/** @module xaction/Action **/
define([
    'xdojo/declare',
    'xide/model/Base',
    'xide/types',
    'xide/utils/ObjectUtils',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (declare, Base, types, ObjectUtils, utils,EventedMixin) {
    /***
     * Extend the core types for action visibility(main menu,...) options/enums:
     * 1. 'Main menu',
     * 2. 'Context menu'
     * 3. 'Action toolbar'
     * 4. 'Property view'
     */
    utils.mixin(types, {
        /**
         * ActionVisibility
         * @enum module:xide/types/ACTION_VISIBILITY
         * @memberOf module:xide/types
         */
        ACTION_VISIBILITY: {
            /**
             * Enable visibility in main menu, which does
             * render actions in a menu bar whereby 'sub' levels
             * are rendered as sub level menus.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            MAIN_MENU: 'MAIN_MENU',

            /**
             * Enable visivibilty in context menu.
             *
             * Different to the main menu, all actions
             * are 'flatted'. The action's group field
             * will auto-create separators among these
             * groups.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            CONTEXT_MENU: 'CONTEXT_MENU',

            QUICK_LAUNCH: 'QUICK_LAUNCH',

            /**
             * Enable visivibilty in primary action toolbar.
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            ACTION_TOOLBAR: 'ACTION_TOOLBAR',

            /**
             * Enable visibility in an item's property view (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            PROPERTY_VIEW: 'PROPERTY_VIEW',

            /**
             * Enable visibility the ribbon toolbar (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            RIBBON: 'RIBBON',

            /**
             * A mixin to be used whilst creating the widget
             * @type {object}
             */
            widgetArgs: null,

            /**
             * Util for the constructor yo create a visibilty. A visibility is a key/value store where the
             * key is ACTION_VISIBILITY
             * and its value is stored in this.ACTION_VISIBILITY_val ! Thus you'r accessing this store in a doc-friendly
             * and enum like function
             * @example
             *  this.getVisibility(types.ACTION_VISIBILITY.MAIN_MENU)'     *
             *
             * the returning value is of type {object}, or {integer(1|0)}
             * @type {function}
             * @returns {module:xide/types/ACTION_VISIBILITY}
             */
            factory: function () {

                var _in = arguments[1] || utils.clone(types.ACTION_VISIBILITY),
                    _args = arguments;

                //
                // A mode when we have the arguments like (1,1,1,2).
                //  This clones types.ACTION_VISIBILITY and blends in an integer mask

                if (_args[0].length > 0 && _.isNumber(_args[0][0])) {

                    var _FlagArgs = _args[0],
                        _val = null,
                        _index = 0;

                    //integer case, sets this[propIndex] to something
                    _.each(_in, function (index, prop) {
                        if (typeof _in[prop] !== 'function') {
                            if (_index < _FlagArgs.length) {
                                //set the value per key but preserve the actualy key by storing
                                //the value in a new key_val field
                                _in[prop + '_val'] = _FlagArgs[_index];
                            }
                        }
                        _index++;
                    });
                }

                // A modus when we have the arguments like (MAIN_MENU,something). set value in this.ENUM_val
                if (_.isString(_args[0][0])) {
                    if (_args[0][2] === true) {
                        utils.mixin(_in[_args[0][0] + '_val'], _args[0][2]);
                    } else {
                        _in[_args[0][0] + '_val'] = _args[0][1];
                        return _in;
                    }
                    return _args[1];
                }
                return _in;
            }
        }
    });
    types.ACTION_VISIBILITY_ALL = 'ACTION_VISIBILITY_ALL';
    /**
     * Basic model to represent an 'action'. Its just a structure
     * object with some factory methods and built-in store to have
     * versions of it self per 'ACTION_VISIBILITY' which may alter
     * rendering for such visibility.
     *
     * Please read {@link module:xide/types}
     *
     * @class module:xaction/Action
     * @augments xide/model/Base
     */
    var Module = declare("xaction/Action", [Base, EventedMixin], {
        disabled: false,
        /**
         * Turn on/off this action
         * @type {boolean}
         * @default true
         */
        enabled: true,
        /**
         * The object or bean we're up to. This is mostly the user's selection.
         * @type {Object|Object[]|Array}
         */
        object: null,
        /**
         * Show/hide this action in ui
         * @member show {boolean}
         */
        show: true,
        /**
         * A group for this action. This is being used in interface only.
         * @type {string|Object=}
         */
        group: '',
        /**
         * A comma separated list of bean types. This specifies on which bean types
         * this action can be applied
         * @type {string|Object=}
         */
        types: '',
        /**
         * A identifier of a command within a "bean action context". This should be human readable.
         * Remember, this is being used for populating menu items in toolbars.
         * @example "Edit/Copy", "Views/Log" and so forth
         * @type {string|integer}
         */
        command: null,
        /**
         * Icon class. You can use font-awesome, dijit icon classes or Elusive icons
         * @type {string}
         * @default fa-play
         */
        icon: 'fa-play',
        /**
         * An event key when the action is performed. This will be published automatically when this action
         * is performed.
         * @type {string|null}
         * @default null
         */
        event: null,
        /**
         * The function to be invoked
         * @type {function|null}
         */
        handler: null,
        /**
         * The tab (visual)
         * @type {string|null}
         * @default null
         */
        tab: null,

        /**
         * A store to override per visibility an action attributes like label, icon, renderer, handler
         * or whatever this action needs. This acts as store per VISIBILITY "Zone" as descried in the enumerations. Its
         * one simple object or single integer store.
         *
         * This storage must be fast as its used in mouse-over, don't use any dojo/dstore or whatever fancy stuff; the
         * operations in the consumer side are already heavy enough (loadash 'group' and 'sort' come up to 5000 calls for
         * just 10 actions)
         *
         * @see {module:xide/types/ACTION_VISIBILITY}
         * @type {xide/types/ACTION_VISIBILITY}
         * @augments {xide/types/ACTION_VISIBILITY}
         * @default null
         * @property
         * @member
         *
         * @example
         * {
         *      MAIN_MENU:"MAIN_MENU",
         *      MAIN_MENU_val:0
         *      //or MAIN_MENU_val:1
         *      ACTION_TOOLBAR:"ACTION_TOOLBAR",
         *      ACTION_TOOLBAR_val:{
         *          icon:"fa or el or dijit", //supports font-awesome, elusive or dojo/dijit
         *          label:"" // in some cases like an action bar you may override this per visibility to hide a label 
         *      }
         * }
         *
         */
        visibility_: null,
        /**
         * An action might contain a value. For instance the action might toggle
         * a checkbox...
         *
         * @type {object|*|null}
         */
        value: null,
        /**
         * Sets visibility options per visibility type.
         *
         * @param {mixed} arguments will blend a number of integers into a copy of
         * xide/types/ACTION_VISIBILITY. Be aware of the exact order!
         * @example
         *
         *
         //Example 1. : set the visibility per type
         setVisibility(1,1,0);// will result in:
         {
                 MAIN_MENU:1,
                 CONTEXT_MENU:1,
                 ACTION_TOOLBAR:0
         }

         //Example 2. : set the visibility per type. @TODO:specify merge filter bits
         setVisibility(types.ACTION_VISIBILITY.MAIN_MENU,{
                label:null  //don't show a label
            });

         */
        setVisibility: function () {
            if (arguments.length == 2 && _.isString(arguments[0]) && arguments[0] == types.ACTION_VISIBILITY_ALL) {
                var _obj = arguments[1],
                    _vis = types.ACTION_VISIBILITY,
                    thiz = this;

                //track vis key in all
                [_vis.MAIN_MENU, _vis.ACTION_TOOLBAR, _vis.CONTEXT_MENU, _vis.RIBBON].forEach(function (vis) {
                    thiz.setVisibility(vis, utils.cloneKeys(_obj, false));
                });
                return this;

            }
            var _args = _.isArray(arguments[0]) ? arguments[0] : arguments;
            this.visibility_ = types.ACTION_VISIBILITY.factory(_args, this.visibility_);
            return this;
        },
        /**
         * Visibility getter
         * @param key
         * @returns {module:xide/types/ACTION_VISIBILITY}
         */
        getVisibility: function (key) {
            if (!this.visibility_) {
                this.setVisibility(types.ACTION_VISIBILITY_ALL, {});
            }
            if (this.visibility_) {
                if (this.visibility_[key + '_val'] == null) {
                    this.visibility_[key + '_val'] = {
                        vis: key
                    };
                }
                return this.visibility_[key + '_val'];
            }
            return {};
        },
        /**
         *
         * @param _visibility
         * @param who
         * @param newItem
         * @returns {boolean}
         */
        shouldDestroyWidget: function (_visibility, who, newItem) {
            var visibility = this.getVisibility != null ? this.getVisibility(_visibility) : null;
            var destroy = true;
            if (visibility && visibility.permanent) {
                destroy = !(_.isFunction(visibility.permanent) ? visibility.permanent(this, who, newItem) : visibility.permanent);
            }
            return destroy;
        }

    });
    /**
     * Static factory
     * @param label {string}
     * @param icon
     * @param command
     * @param permanent
     * @param operation
     * @param btypes
     * @param group
     * @param visibility
     * @param register
     * @param handler
     * @param mixin
     * @static
     * @memberOf xaction/Action
     *
     * @example for queuing a clip board action:
     *
     *  var _copyAction  = Action.create('Copy', 'fa-copy', 'Edit/Copy', true, types.OPERATION_INT.CLIPBOARD_COPY, types.ITEM_TYPE.FILE, 'clipboard', null, true, _clipboardManager);
     *  _copy.accelKey = 'CTRL+C';
     *
     * @returns {module:xaction/Action}
     */
    Module.create = function (label, icon, command, permanent, operation, btypes, group, visibility, register, handler, mixin) {
        var _action = new Module({
            permanent: permanent,
            command: command,
            icon: icon,
            label: label,
            owner: this,
            types: btypes,
            operation: operation,
            group: group,
            handler: handler,
            title: label
        });
        /*
         var VISIBILITY = types.ACTION_VISIBILITY,
         VISIBILITIES = [
         VISIBILITY.ACTION_TOOLBAR,
         VISIBILITY.RIBBON,
         VISIBILITY.MAIN_MENU,
         VISIBILITY.CONTEXT_MENU
         ];
         */
        utils.mixin(_action, mixin);
        return _action;
    };
    /**
     * Simple wrapper for action.create
     * @param label {string}
     * @param icon
     * @param command
     * @param group
     * @param handler
     * @param mixin
     * @returns {module:xaction/Action}
     */
    Module.createDefault = function (label, icon, command, group, handler, mixin) {
        return Module.create(label, icon, command, false, null, null, group || 'nogroup', null, false, handler, mixin);
    };
    return Module;
});

},
'xide/manager/Application':function(){
/** module:xide/manager/Application **/
define([
    'dcl/dcl',
    'xdojo/has',
    'xide/manager/ManagerBase',
    'xide/types',
    'xide/utils',
    'dojo/Deferred',
    'dojo/promise/all',
    'xide/manager/Application_UI'
], function (dcl,has, ManagerBase, types, utils, Deferred,all,Application_UI) {
    var bases = [ManagerBase];
    if ( 1 ) {
        bases.push(Application_UI);
    }
    /**
     * @class module:xide/manager/Application
     * @extends module:xide/manager/ManagerBase
     * @extends module:xide/mixins/EventedMixin
     */
    return dcl(bases, {
        declaredClass:"xide.manager.Application",
        container: null,
        ctx: null,
        _debug: true,
        _loadedComponents: {},
        _loadingComponents: null,
        /***********************************************************************/
        /*
         * Component implementation
         */
        getComponents: function () {
            return this._loadedComponents;
        },
        doComponents: function () {
            var componentsToLoad = this.loadComponents(),
                _re = require,
                thiz = this,
                inits = [];

            var head = new Deferred();

            if (!componentsToLoad || !componentsToLoad.dfd) {
                console.error('componentsToLoad is null or has no head dfd');
                return componentsToLoad;
            }
            var COMPONENT_NAMES = types.COMPONENT_NAMES;

            function doComponent(feature,fn){
                if (has(feature) && componentsToLoad[feature]) {
                    if (componentsToLoad[feature].dfd) {
                        var sub = new Deferred();
                        inits.push(sub);
                        componentsToLoad[feature].dfd.then(function () {
                            fn(sub);
                        });
                    }
                }
            }
            doComponent(COMPONENT_NAMES.XTRACK,function(sub){
                sub.resolve();
            });
            doComponent(COMPONENT_NAMES.XFILE,function(sub){
                thiz.initXFile().then(function(){
                    sub.resolve();
                });
            });

            doComponent(COMPONENT_NAMES.XIDEVE,function(sub){
                thiz.initXIDEVE().then(function(){
                    sub.resolve();
                });
            });
            doComponent(COMPONENT_NAMES.XNODE,function(sub){
                thiz.initXNODE().then(function(){
                    sub.resolve();
                });
            });

            doComponent(COMPONENT_NAMES.XBLOX,function(sub){
                _re([
                    'xblox/embedded_ui',
                    'xfile/manager/BlockManager',
                    'xblox/views/BlocksFileEditor'
                ], function () {
                    thiz.onXBlocksReady().then(function(){
                        sub.resolve();
                    });
                });
            });

            componentsToLoad.dfd.then(function(){
                var inner = all(inits);
                inner.then(function(){
                    head.resolve();
                });
            });

            head.then(function () {
                thiz.registerEditorExtensions();
            });


            return head;

        },
        loadComponents: function (components) {
            if (this._loadingComponents) {
                return this._loadingComponents;
            }

            var thiz = this,
                _loadNext,
                _loadComponent;

            thiz._loadedComponents = {};
            components = components || utils.getJson(this.ctx.getResourceManager().getVariable('COMPONENTS'));
            _.each(components, function (val, component) {
                if (has(component) === false) {
                    delete components[component];
                }
            });

            if (!components) {
                return null;
            }
            /**
             * Loop function to load remaining components
             */
            _loadNext = function () {

                var next = _.find(components, {status: 0});
                if (next) {
                    _loadComponent(next.name, next);
                } else {
                    //all loaded
                    components.dfd.resolve(components);
                    thiz.publish(types.EVENTS.ON_ALL_COMPONENTS_LOADED,components);
                    components.dfd.resolve();
                }
            };

            /**
             * private component loader function
             *
             */
            _loadComponent = function (name, process) {
                var settings = process.settings;
                if (has(name) === false) {
                    console.error('loading component ' + name + 'which is disabled by has!');
                }
                thiz.ctx.getPluginManager().loadComponent(name, null, settings === true ? null : settings).then(function (_component) {
                    thiz._loadedComponents[name] = _component;
                    var evtData = {
                        component: _component,
                        name: name
                    };
                    process.dfd.resolve(evtData);
                    thiz.publish(types.EVENTS.ON_COMPONENT_READY, evtData);
                    process.status = 1;
                    _loadNext();
                });
            };

            /**
             * Iterate over components and prepare them for being loaded serial
             */
            for (var component in components) {
                var name = '' + component,
                    settings = components[name];

                if (settings) {
                    components[name] = {
                        settings: settings,
                        status: 0,
                        name: name,
                        dfd: new Deferred()
                    };

                } else {
                    components[name] = {
                        status: 1
                    };
                }
            }
            components.dfd = new Deferred();
            //now fire loading sequence
            _loadNext();

            this._loadingComponents = components;

            return components;
        },
        hasComponent: function (name) {
            var components = utils.getJson(this.ctx.getResourceManager().getVariable('COMPONENTS'));
            return !!(components && components[name]);
        }
    });
});
},
'wcDocker/collapser':function(){
/** @module wcCollapser */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/splitter",
    "wcDocker/drawer",
    "wcDocker/base"
], function (dcl, wcDocker, wcSplitter, wcDrawer, base) {

    /**
     * A collapsable container for carrying panels.<br>
     *
     * @class module:wcCollapser
     * @version 3.0.0
     * @description A docker container for carrying its own arrangement of docked panels as a slide out drawer.<br/>
     * <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
     */
    var Module = dcl(base, {
        declaredClass:'wcCollapser',
        /**
         * @memberOf module:wcCollapser
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this drawer.
         * @param {module:wcSplitter|wcDocker} parent  - The drawer's parent object.
         * @param {module:wcDocker.DOCK} position      - A docking position to place this drawer.
         */
        constructor: function (container, parent, position) {

            this.$container = $(container);
            this.$frame = null;

            this._position = position;
            this._parent = parent;
            this._splitter = null;
            this._drawer = null;
            this._size = 0;
            this._orientation = (this._position === wcDocker.DOCK.LEFT || this._position === wcDocker.DOCK.RIGHT) ? wcDocker.ORIENTATION.HORIZONTAL : wcDocker.ORIENTATION.VERTICAL;

            this.__init();
        },
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Collapses the drawer to its respective side wall.
         * @function module:wcCollapser#collapse
         */
        collapse: function (instant) {
            this._drawer.collapse();
        },

        /**
         * Expands the drawer.
         * @function module:wcCollapser#expand
         */
        expand: function () {
            this._drawer.expand();
        },

        /**
         * Gets whether the drawer is expanded.
         * @function module:wcCollapser#isExpanded
         * @returns {Boolean} - The current expanded state.
         */
        isExpanded: function () {
            return this._drawer.isExpanded();
        },

        /**
         * The minimum size constraint for the side bar area.
         * @function module:wcCollapser#minSize
         * @returns {module:wcDocker~Size} - The minimum size.
         */
        minSize: function () {
            return {x: this._size, y: this._size};
        },

        /**
         * The maximum size constraint for the side bar area.
         * @function module:wcCollapser#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var isHorizontal = (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) ? true : false;
            return {
                x: (isHorizontal ? this._size : Infinity),
                y: (!isHorizontal ? this._size : Infinity)
            };
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Private Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        __init: function () {
            this.$frame = $('<div class="wcCollapserFrame">');
            this.__container(this.$container);

            var docker = this.docker();
            this._splitter = new (this.docker().__getClass('wcSplitter'))(docker.$container, this, this._orientation);
            this._drawer = new (this.docker().__getClass('wcDrawer'))(docker.$transition, this._splitter, this._position);
            switch (this._position) {
                case wcDocker.DOCK.LEFT:
                    this._splitter.pane(0, this._drawer);
                    this._splitter.$pane[1].remove();
                    this._splitter.$pane[0].addClass('wcDrawer');
                    this._splitter.pos(0);
                    break;
                case wcDocker.DOCK.RIGHT:
                case wcDocker.DOCK.BOTTOM:
                    this._splitter.pane(1, this._drawer);
                    this._splitter.$pane[0].remove();
                    this._splitter.$pane[1].addClass('wcDrawer');
                    this._splitter.pos(1);
                    break;
            }

            this._parent.$bar.addClass('wcSplitterHidden');
        },

        // Updates the size of the collapser.
        __update: function (opt_dontMove) {
            this._splitter.__update();
            this.__adjustSize();
        },

        // Adjusts the size of the collapser based on css
        __adjustSize: function () {
            if (this._drawer._frame._panelList.length) {
                this._size = this._drawer._frame.$tabBar.outerHeight();
            } else {
                this._size = 0;
            }
        },

        // Retrieves the bounding rect for this collapser.
        __rect: function () {
            return this._drawer.__rect();
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.size = this._size;
            data.drawer = this._drawer.__save();
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._size = data.size;
            this._drawer.__restore(data.drawer, docker);
            this.__adjustSize();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;

            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            if (this._splitter) {
                this._splitter.__destroy();
                this._splitter = null;
                this._frame = null;
            }

            this.__container(null);
            this._parent = null;
        }
    });

    return Module;

});

},
'xide/types/Types':function(){
/** @module xide/types
 *  @description All the package's constants and enums in C style structures.
 */
define([
    'dojo/_base/lang',
    'xide/types',
    'dojo/_base/json',
    'dojo/_base/kernel'
], function (lang, types, json, dojo) {
    /**
     * @TODO:
     * - apply xide/registry for types
     * - move mime handling to xfile
     * - remove ui types
     * - remove all other things which are part of ui or server only
     */
    /**
     * Custom CI Types, see ECITYPE enumeration. Each enum is mapped to a widget.
     */
    if (types['customTypes'] == null) {
        types['customTypes'] = {};
    }
    /**
     * ECTYPE_ENUM is mapped to and label-value option array
     */
    if (types['customEnumerations'] == null) {
        types['customEnumerations'] = {};
    }
    /**
     * The actual mapping of custom types to widget proto classes
     */
    if (types['widgetMappings'] == null) {
        types['widgetMappings'] = {};
    }
    /**
     * Mixes in new mime icons per ECITYPE & file extensions. Rendered by FontAwesome
     */
    if (types['customMimeIcons'] == null) {
        types['customMimeIcons'] = {};
    }

    /**
     * Public ECI_TYPE registry getter
     * @param type
     * @returns {*}
     */
    types.resolveType = function (type) {
        if (types['customTypes'][type]) {
            return types['customTypes'][type];
        }
        return null;
    };
    /**
     * Public ECI_TYPE registry setter
     * @param type
     * @param map
     */
    types.registerType = function (type, map) {
        types['customTypes'][type] = map;
    };
    /**
     * Public widget-type registry setter
     * @param type
     * @param map
     */
    types.registerWidgetMapping = function (type, map) {
        types['widgetMappings'][type] = map;
    };
    /**
     * Public custom enum registry setter
     * @param type
     * @param map
     */
    types.registerEnumeration = function (type, map) {
        types['customEnumerations'][type] = map;
    };
    /**
     * Public custom enumeration registry getter
     * @param type
     */
    types.resolveEnumeration = function (type) {
        if (types['customEnumerations'][type]) {
            return types['customEnumerations'][type];
        }
        return null;
    };
    /**
     * Public type-widget mapping registry setter
     * @param type
     */
    types.resolveWidgetMapping = function (type) {
        if (types['widgetMappings'][type]) {
            return types['widgetMappings'][type];
        }
        return null;
    };
    types.GRID_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    types.VIEW_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    types.KEYBOARD_PROFILE = {
        DEFAULT: {
            prevent_default: true,
            prevent_repeat: false
        },
        PASS_THROUGH: {
            prevent_default: false,
            prevent_repeat: false
        },
        SEQUENCE: {
            prevent_default: true,
            is_sequence: true,
            prevent_repeat: true
        }
    };
    /////////////////////////////////////////////////////////////////////////////
    //
    // CORE TYPES
    //
    /////////////////////////////////////////////////////////////////////////////
    /**
     * A 'Configurable Information's ("CI") processing state during post or pre-processing.
     *
     * @enum {int} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_STATE = {
        /**
         * Nothing done, could also mean there is nothing to do all
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * In pending state. At that time the compiler has accepted additional work and ci flag processing is queued
         * but not scheduled yet.
         * @constant
         * @type int
         */
        PENDING: 0x00000001,
        /**
         * The processing state.
         * @constant
         * @type int
         */
        PROCESSING: 0x00000002,
        /**
         * The CI has been processed but it failed.
         * @constant
         * @type int
         */
        FAILED: 0x00000004,
        /**
         * The CI was successfully processed.
         * @constant
         * @type int
         */
        SUCCESSED: 0x00000008,
        /**
         * The CI has been processed.
         * @constant
         * @type int
         */
        PROCESSED: 0x00000010,
        /**
         * The CI left the post/pre processor entirly but has not been accepted by the originating source.
         * This state can happen when the source became invalid and so its sort of orphan.
         * @constant
         * @type int
         */
        DEQUEUED: 0x00000020,
        /**
         * The CI fully resolved and no references except by the source are around.
         * @constant
         * @type int
         */
        SOLVED: 0x00000040,
        /**
         * Flag to mark the core's end of this bitmask, from here its user land
         * @constant
         * @type int
         */
        END: 0x00000080
    };
    /**
     * A 'Configurable Information's ("CI") type flags for post and pre-processing a value.
     * @enum {string} module:xide/types/CIFlag
     * @global CIFLAGS
     * @memberOf module:xide/types
     */

    types.CIFLAG = {
        /**
         * Instruct for no additional extra processing
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Will instruct the pre/post processor to base-64 decode or encode
         * @constant
         * @type int
         */
        BASE_64: 0x00000001,
        /**
         * Post/Pre process the value with a user function
         * @constant
         * @type int
         */
        USE_FUNCTION: 0x00000002,
        /**
         * Replace variables with local scope's variables during the post/pre process
         * @constant
         * @type int
         */
        REPLACE_VARIABLES: 0x00000004,
        /**
         * Replace variables with local scope's variables during the post/pre process but evaluate the whole string
         * as Javascript
         * @constant
         * @type int
         */
        REPLACE_VARIABLES_EVALUATED: 0x00000008,
        /**
         * Will instruct the pre/post processor to escpape evaluated or replaced variables or expressions
         * @constant
         * @type int
         */
        ESCAPE: 0x00000010,
        /**
         * Will instruct the pre/post processor to replace block calls with oridinary vanilla script
         * @constant
         * @type int
         */
        REPLACE_BLOCK_CALLS: 0x00000020,
        /**
         * Will instruct the pre/post processor to remove variable delimitters/placeholders from the final string
         * @constant
         * @type int
         */
        REMOVE_DELIMTTERS: 0x00000040,
        /**
         * Will instruct the pre/post processor to remove   "[" ,"]" , "(" , ")" , "{", "}" , "*" , "+" , "."
         * @constant
         * @type int
         */
        ESCAPE_SPECIAL_CHARS: 0x00000080,
        /**
         * Will instruct the pre/post processor to use regular expressions over string substitution
         * @constant
         * @type int
         */
        USE_REGEX: 0x00000100,
        /**
         * Will instruct the pre/post processor to use Filtrex (custom bison parser, needs xexpression) over string substitution
         * @constant
         * @type int
         */
        USE_FILTREX: 0x00000200,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        CASCADE: 0x00000400,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        EXPRESSION: 0x00000800,
        /**
         * Dont parse anything
         * @constant
         * @type int
         */
        DONT_PARSE: 0x000001000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        TO_HEX: 0x000002000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        REPLACE_HEX: 0x000004000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        WAIT: 0x000008000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        DONT_ESCAPE: 0x000010000,
        /**
         * Flag to mark the maximum core bit mask, after here its user land
         * @constant
         * @type int
         */
        END: 0x000020000
    };
    /**
     * A CI's default post-pre processing order.
     *
     * @enum {string} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_CORDER = {};
    /**
     * A 'Configurable Information's ("CI") type information. Every CI has this information. You can
     * re-composite new types with ECIType.STRUCTURE. However all 'beans' (rich objects) in the system all displayed through a set of CIs,
     * also called the CIS (Configurable Information Set). There are many types already :
     *
     * Each ECIType has mapped widgets, BOOL : checkbox, STRING: Text-Areay and so forth.
     *
     * @enum {string} module:xide/types/ECIType
     * @memberOf module:xide/types
     */
    types.ECIType = {
        /**
         * @const
         * @type { int}
         */
        BOOL: 0,
        /**
         * @const
         * @type { int}
         */
        BOX: 1,
        /**
         * @const
         * @type { int}
         */
        COLOUR: 2,
        /**
         * @const
         * @type { int}
         */
        ENUMERATION: 3,
        /**
         * @const
         * @type { int}
         */
        FILE: 4,
        /**
         * @const
         * @type { int}
         */
        FLAGS: 5,
        /**
         * @const
         * @type { int}
         */
        FLOAT: 6,
        /**
         * @const
         * @type { int}
         */
        INTEGER: 7,
        /**
         * @const
         * @type { int}
         */
        MATRIX: 8,
        /**
         * @const
         * @type { int}
         */
        OBJECT: 9,
        /**
         * @const
         * @type { int}
         */
        REFERENCE: 10,
        /**
         * @const
         * @type { int}
         */
        QUATERNION: 11,
        /**
         * @const
         * @type { int}
         */
        RECTANGLE: 12,
        /**
         * @const
         * @type { int}
         */
        STRING: 13,
        /**
         * @const
         * @type { int}
         */
        VECTOR: 14,
        /**
         * @const
         * @type { int}
         */
        VECTOR2D: 15,
        /**
         * @const
         * @type { int}
         */
        VECTOR4D: 16,
        /**
         * @const
         * @type { int}
         */
        ICON: 17,
        /**
         * @const
         * @type { int}
         */
        IMAGE: 18,
        /**
         * @const
         * @type { int}
         */
        BANNER: 19,
        /**
         * @const
         * @type { int}
         */
        LOGO: 20,
        /**
         * @const
         * @type { int}
         */
        STRUCTURE: 21,
        /**
         * @const
         * @type { int}
         */
        BANNER2: 22,
        /**
         * @const
         * @type { int}
         */
        ICON_SET: 23,
        /**
         * @const
         * @type { int}
         */
        SCRIPT: 24,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION: 25,
        /**
         * @const
         * @type { int}
         */
        RICHTEXT: 26,
        /**
         * @const
         * @type { int}
         */
        ARGUMENT: 27,
        /**
         * @const
         * @type { int}
         */
        JSON_DATA: 28,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION_EDITOR: 29,
        /**
         * @const
         * @type { int}
         */
        WIDGET_REFERENCE: 30,
        /**
         * @const
         * @type { int}
         */
        DOM_PROPERTIES: 31,

        /**
         * @const
         * @type { int}
         */
        BLOCK_REFERENCE: 32,

        /**
         * @const
         * @type { int}
         */
        BLOCK_SETTINGS: 33,
        /**
         * @const
         * @type { int}
         */
        FILE_EDITOR: 34,
        /**
         * @const
         * @type { int}
         */
        END: 35,
        /**
         * @const
         * @type { int}
         */
        UNKNOWN: -1
    };
    /**
     * Stub for registered bean types. This value is needed to let the UI switch between configurations per such type.
     * At the very root is the bean action context which may include more contexts.
     * @enum {string} module:xide/types/ITEM_TYPE
     * @memberOf module:xide/types
     */
    types.ITEM_TYPE = {
        /**
         * Bean type 'file' is handled by the xfile package
         * @constant
         */
        FILE: 'BTFILE',         //file object
        /**
         * Bean type 'widget' is handled by the xide/ve and davinci package
         * @constant
         */
        WIDGET: 'WIDGET',       //ui designer
        /**
         * Bean type 'block' is handled by the xblox package
         * @constant
         */
        BLOCK: 'BLOCK',         //xblox
        /**
         * Bean type 'text' is used for text editors
         * @constant
         */
        TEXT: 'TEXT',           //xace
        /**
         * Bean type 'xexpression' is used for user expressions
         * @constant
         */
        EXPRESSION: 'EXPRESSION'       //xexpression
    };

    /**
     * Expression Parser is a map of currently existing parsers
     * and might be extended by additional modules. Thus, it acts as registry
     * and is here as stub.
     *
     * @enum module:xide/types/EXPRESSION_PARSER
     * @memberOf module:xide/types
     */
    if (!types.EXPRESSION_PARSER) {
        types.EXPRESSION_PARSER = {};
    }
    /**
     * Component names stub, might be extended by sub-classing applications
     * @constant xide.types.COMPONENT_NAMES
     */
    types.COMPONENT_NAMES = {
        XIDEVE: 'xideve',
        XNODE: 'xnode',
        XBLOX: 'xblox',
        XFILE: 'xfile',
        XACE: 'xace',
        XEXPRESSION: 'xexpression',
        XCONSOLE: 'xconsole',
        XTRACK: 'xtrack'
    };

    /**
     * WIDGET_REFERENCE_MODE enumerates possible modes to resolve a string expression
     * into instances. There are a few CI based widgets subclassed from xide/widgets/Referenced.
     * The reference structure consist out of this mode and that expression.
     *
     * @constant {Array.<module:xide/types~WidgetReferenceMode>}
     *     module:xide/types~WIDGET_REFERENCE_MODE
     */
    types.WIDGET_REFERENCE_MODE = {
        BY_ID: 'byid',
        BY_CLASS: 'byclass',
        BY_CSS: 'bycss',
        BY_EXPRESSION: 'expression'
    };
    /**
     * Possible split modes for rich editors with preview or live coding views.
     *
     * @constant {Array.<module:xide/types~ViewSplitMode>}
     *     module:xide/types~VIEW_SPLIT_MODE
     */
    types.VIEW_SPLIT_MODE = {
        DESIGN: 1,
        SOURCE: 2,
        SPLIT_VERTICAL: 6,
        SPLIT_HORIZONTAL: 7
    };

    /**
     * All client resources are through variables on the server side. Here the minimum variables for an xjs application.
     *
     * @constant {Array.<module:xide/types~RESOURCE_VARIABLES>}
     *     module:xide/types~RESOURCE_VARIABLES
     */
    types.RESOURCE_VARIABLES = {
        ACE: 'ACE',
        APP_URL: 'APP_URL',
        SITE_URL: 'SITE_URL'
    };
    /**
     * Events of xide.*
     * @enum {string} module:xide/types/EVENTS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.EVENTS = {

        /**
         * generic
         */
        ERROR: 'onError',//xhr
        STATUS: 'onStatus',//xhr
        ON_CREATED_MANAGER: 'onCreatedManager',//context

        /**
         * item events, to be renoved
         */
        ON_ITEM_SELECTED: 'onItemSelected',
        ON_ITEM_REMOVED: 'onItemRemoved',
        ON_ITEM_CLOSED: 'onItemClosed',
        ON_ITEM_ADDED: 'onItemAdded',
        ON_ITEM_MODIFIED: 'onItemModified',
        ON_NODE_SERVICE_STORE_READY: 'onNodeServiceStoreReady',
        /**
         * old, to be removd
         */
        ON_FILE_STORE_READY: 'onFileStoreReady',
        ON_CONTEXT_MENU_OPEN: 'onContextMenuOpen',
        /**
         * CI events
         */
        ON_CI_UPDATE: 'onCIUpdate',

        /**
         * widgets
         */
        ON_WIDGET_READY: 'onWidgetReady',
        ON_CREATED_WIDGET: 'onWidgetCreated',
        RESIZE: 'onResize',
        /**
         * Event to notify classes about a reloaded module
         * @constant
         * @type string
         */
        ON_MODULE_RELOADED: 'onModuleReloaded',
        ON_MODULE_UPDATED: 'onModuleUpdated',


        ON_DID_OPEN_ITEM: 'onDidOpenItem',//remove
        ON_DID_RENDER_COLLECTION: 'onDidRenderCollection',//move

        ON_PLUGIN_LOADED: 'onPluginLoaded',
        ON_PLUGIN_READY: 'onPluginReady',
        ALL_PLUGINS_READY: 'onAllPluginsReady',

        /**
         * editors
         */
        ON_CREATE_EDITOR_BEGIN: 'onCreateEditorBegin',//move to xedit
        ON_CREATE_EDITOR_END: 'onCreateEditorEnd',//move to xedit
        REGISTER_EDITOR: 'registerEditor',//move to xedit
        ON_EXPRESSION_EDITOR_ADD_FUNCTIONS: 'onExpressionEditorAddFunctions',//move to xedit
        ON_ACE_READY: 'onACEReady',//remove

        /**
         * Files
         */
        ON_UNSAVED_CONTENT: 'onUnSavedContent',
        ON_FILE_CHANGED: 'fileChanged',
        ON_FILE_DELETED: 'fileDeleted',
        IMAGE_LOADED: 'imageLoaded',
        IMAGE_ERROR: 'imageError',
        UPLOAD_BEGIN: 'uploadBegin',
        UPLOAD_PROGRESS: 'uploadProgress',
        UPLOAD_FINISH: 'uploadFinish',
        UPLOAD_FAILED: 'uploadFailed',
        ON_FILE_CONTENT_CHANGED: 'onFileContentChanged',
        ON_COPY_BEGIN: 'onCopyBegin',
        ON_COPY_END: 'onCopyEnd',
        ON_DELETE_BEGIN: 'onDeleteBegin',
        ON_DELETE_END: 'onDeleteEnd',
        ON_MOVE_BEGIN: 'onMoveBegin',
        ON_MOVE_END: 'onMoveEnd',
        ON_CHANGED_CONTENT: 'onChangedContent',
        ON_COMPRESS_BEGIN: 'onCompressBegin',
        ON_COMPRESS_END: 'onCompressEnd',



        ON_COMPONENT_READY: 'onComponentReady',
        ON_ALL_COMPONENTS_LOADED: 'onAllComponentsLoaded',
        ON_APP_READY: 'onAppReady',
        /**
         * Store
         */
        ON_CREATE_STORE: 'onCreateStore',
        ON_STORE_CREATED: 'onStoreCreated',
        ON_STORE_CHANGED: 'onStoreChanged',
        ON_STATUS_MESSAGE: 'onStatusMessage',
        /**
         * layout
         */
        SAVE_LAYOUT: 'layoutSave',
        RESTORE_LAYOUT: 'layoutRestore',
        /**
         * views, panels and 'main view'
         */
        ON_SHOW_PANEL: 'onShowPanel',
        ON_PANEL_CLOSED: 'onPanelClosed',
        ON_PANEL_CREATED: 'onPanelCreated',

        ON_MAIN_VIEW_READY: 'onMainViewReady',
        ON_MAIN_MENU_READY: 'onMainMenuReady',
        ON_MAIN_MENU_OPEN: 'onMainMenuOpen',
        ON_VIEW_REMOVED: 'onViewRemoved',
        ON_VIEW_SHOW: 'onViewShow',
        ON_VIEW_HIDE: 'onViewHide',
        ON_VIEW_ADDED: 'onViewAdded',
        ON_OPEN_VIEW: 'onOpenView',
        ON_VIEW_MAXIMIZE_START: 'onViewMaximizeStart',
        ON_VIEW_MAXIMIZE_END: 'onViewMaximizeEnd',
        ON_CONTAINER_ADDED: 'onContainerAdded',
        ON_CONTAINER_REMOVED: 'onContainerRemoved',
        ON_REMOVE_CONTAINER: 'onRemoveContainer',
        ON_CONTAINER_REPLACED: 'onContainerReplaced',
        ON_CONTAINER_SPLIT: 'onContainerSplit'
    };
    /**
     * To be moved
     * @type {{SIZE_NORMAL: string, SIZE_SMALL: string, SIZE_WIDE: string, SIZE_LARGE: string}}
     */
    types.DIALOG_SIZE = {
        SIZE_NORMAL: 'size-normal',
        SIZE_SMALL: 'size-small',
        SIZE_WIDE: 'size-wide',    // size-wide is equal to modal-lg
        SIZE_LARGE: 'size-large'
    };

    /**
     * To be moved
     * @type {{DEFAULT: string, INFO: string, PRIMARY: string, SUCCESS: string, WARNING: string, DANGER: string}}
     */
    types.DIALOG_TYPE = {
        DEFAULT: 'type-default',
        INFO: 'type-info',
        PRIMARY: 'type-primary',
        SUCCESS: 'type-success',
        WARNING: 'type-warning',
        DANGER: 'type-danger'
    };
    /**
     * @TODO: remove, defined in xideve
     */
    lang.mixin(types, {
        LAYOUT_RIGHT_CENTER_BOTTOM: 'LAYOUT_RIGHT_CENTER_BOTTOM',
        LAYOUT_CENTER_BOTTOM: 'LAYOUT_CENTER_BOTTOM',
        LAYOUT_CENTER_RIGHT: 'LAYOUT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT: 'LAYOUT_LEFT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT_BOTTOM: 'LAYOUT_LEFT_CENTER_RIGHT_BOTTOM'
    });

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     */
    dojo.fromJson = function (js, debug) {
        var res = null;
        var didFail = false;
        debug = true;
        try {
            res = eval("(" + js + ")");
        } catch (e) {
            didFail = true;
        }

        if (didFail) {
            var js2 = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                js2 && (res = eval("(" + js2 + ")"));
            } catch (e) {
                debug !== false && console.error('error in json parsing! ' + js);
                if (js.indexOf('error') !== -1) {
                    return {
                        "jsonrpc": "2.0",
                        "result": {
                            "error": {
                                "code": 1,
                                "message": js,
                                "data": null
                            }
                        }, "id": 0
                    };
                }
                throw new Error(js);
            }
        }
        return res;
    };
    return types;
});
},
'wcDocker/splitter':function(){
/** @module wcSplitter */
define([
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class module:wcSplitter
     * Splits an area in two, dividing it with a resize-able splitter bar. This is the same class
     * used throughout [docker]{@link module:wcDocker} to organize the docking interface, but it can also
     * be used inside a panel as a custom widget.
     * <b>Note:</b> The container needs to be positioned in either absolute or relative coordinates in css.
     */
    var Module = dcl(base, {

        declaredClass: 'wcSplitter',

        /**
         * @memberOf module:wcSplitter
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this splitter.
         * @param {wcLayout|wcSplitter|wcDocker} parent   - The splitter's parent object.
         * @param {module:wcDocker.ORIENTATION} orientation      - The orientation of the splitter bar.
         */
        constructor:function(container, parent, orientation) {
            this.$container = $(container);
            this._parent = parent;
            this._orientation = orientation;

            this._pane = [false, false];
            /**
             * An array of two elements representing each side of the splitter.
             * Index 0 is always either top or left depending on [orientation]{@link module:wcDocker.ORIENTATION}.
             * @member
             * @type {external:jQuery~Object[]}
             */
            this.$pane = [];
            this.$bar = null;
            this._pos = 0.5;
            this._posTarget = 0.5;
            this._pixelPos = -1;
            this._findBestPos = false;
            this._anim = 0;

            this._boundEvents = [];

            this.__init();

            this.docker()._splitterList.push(this);
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Initializes the two [panes]{@link module:wcSplitter#$pane} of the splitter with its own layouts.<br>
         * This should be used to initialize the splitter when creating one for use inside your panel.
         * @function module:wcSplitter#initLayouts
         * @param {module:wcDocker.LAYOUT} [topLeftLayout=wcDocker.LAYOUT.TABLE] - The type of layout to use for the top or left pane.
         * @param {module:wcDocker.LAYOUT} [bottomRightLayout=wcDocker.LAYOUT.TABLE] - The type of layout to use for the bottom or right pane.
         */
        initLayouts: function (topLeftLayout, bottomRightLayout) {
            var layoutClass = topLeftLayout || 'wcLayoutTable';
            var layout0 = new (this.docker().__getClass(layoutClass))(this.$pane[0], this);

            layoutClass = bottomRightLayout || 'wcLayoutTable';
            var layout1 = new (this.docker().__getClass(layoutClass))(this.$pane[1], this);

            this.pane(0, layout0);
            this.pane(1, layout1);
        },

        /**
         * Gets, or Sets the orientation of the splitter.
         * @function module:wcSplitter#orientation
         * @param {module:wcDocker.ORIENTATION} orientation - The new orientation of the splitter.
         */
        orientation: function (orientation) {
            if (typeof orientation === 'undefined') {
                return this._orientation;
            }

            if (this._orientation != orientation) {
                this._orientation = orientation;

                if (this._orientation) {
                    // this.$pane[0].removeClass('wcWide').addClass('wcTall');
                    // this.$pane[1].removeClass('wcWide').addClass('wcTall');
                    this.$bar.removeClass('wcWide').removeClass('wcSplitterBarH').addClass('wcTall').addClass('wcSplitterBarV');
                } else {
                    // this.$pane[0].removeClass('wcTall').addClass('wcWide');
                    // this.$pane[1].removeClass('wcTall').addClass('wcWide');
                    this.$bar.removeClass('wcTall').removeClass('wcSplitterBarV').addClass('wcWide').addClass('wcSplitterBarH');
                }

                this.$pane[0].css('top', '').css('left', '').css('width', '').css('height', '');
                this.$pane[1].css('top', '').css('left', '').css('width', '').css('height', '');
                this.$bar.css('top', '').css('left', '').css('width', '').css('height', '');
                this.__update();

                if (this._parent && this._parent.instanceOf('wcPanel')) {
                    this._parent.__trigger(wcDocker.EVENT.UPDATED);
                }
            }
        },

        /**
         * Gets the minimum size constraint of the outer splitter area.
         * @function module:wcSplitter#minSize
         * @returns {module:wcDocker~Size} The minimum size.
         */
        minSize: function () {
            var minSize1;
            var minSize2;
            if (this._pane[0] && typeof this._pane[0].minSize === 'function') {
                minSize1 = this._pane[0].minSize();
            }

            if (this._pane[1] && typeof this._pane[1].minSize === 'function') {
                minSize2 = this._pane[1].minSize();
            }

            if (minSize1 && minSize2) {
                if (this._orientation) {
                    minSize1.x += minSize2.x;
                    minSize1.y = Math.max(minSize1.y, minSize2.y);
                } else {
                    minSize1.y += minSize2.y;
                    minSize1.x = Math.max(minSize1.x, minSize2.x);
                }
                return minSize1;
                return {
                    x: Math.min(minSize1.x, minSize2.x),
                    y: Math.min(minSize1.y, minSize2.y)
                };
            } else if (minSize1) {
                return minSize1;
            } else if (minSize2) {
                return minSize2;
            }

            return false;
        },

        /**
         * Gets the maximum size constraint of the outer splitter area.
         * @function module:wcSplitter#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var maxSize1;
            var maxSize2;
            if (this._pane[0] && typeof this._pane[0].maxSize === 'function') {
                maxSize1 = this._pane[0].maxSize();
            }

            if (this._pane[1] && typeof this._pane[1].maxSize === 'function') {
                maxSize2 = this._pane[1].maxSize();
            }

            if (maxSize1 && maxSize2) {
                if (this._orientation) {
                    maxSize1.x += maxSize2.x;
                    maxSize1.y = Math.min(maxSize1.y, maxSize2.y);
                } else {
                    maxSize1.y += maxSize2.y;
                    maxSize1.x = Math.min(maxSize1.x, maxSize2.x);
                }
                return maxSize1;
                return {
                    x: Math.min(maxSize1.x, maxSize2.x),
                    y: Math.min(maxSize1.y, maxSize2.y)
                };
            } else if (maxSize1) {
                return maxSize1;
            } else if (maxSize2) {
                return maxSize2;
            }

            return false;
        },

        /**
         * Get, or Set the current splitter position.
         * @function module:wcSplitter#pos
         * @param {Number} [value] - If supplied, assigns a new splitter position. Value must be a percentage value between 0 and 1.
         * @returns {Number} - The current position.
         */
        pos: function (value) {

            if (typeof value !== 'undefined') {

                if(Math.abs(value) < 0.1 && value!==0){
                    return;
                }
                this._pos = this._posTarget = value;
                this.__update();

                if (this._parent && this._parent.instanceOf('wcPanel')) {
                    this._parent.__trigger(wcDocker.EVENT.UPDATED);
                }
            }

            return this._posTarget;
        },

        /**
         * Animates to a given splitter position.
         * @function module:wcSplitter#animPos
         * @param {Number} value - Assigns the target splitter position. Value must be a percentage between 0 and 1.
         * @param {module:wcSplitter~onFinished} - A finished event handler.
         */
        animPos: function (value, callback) {
            this._posTarget = value;
            var self = this;
            this.$bar.queue(function (next) {
                if (self._anim) {
                    clearInterval(self._anim);
                }
                self._anim = setInterval(function () {
                    if (self._pos > self._posTarget) {
                        self._pos -= (self._pos - self._posTarget) / 5;
                        if (self._pos <= self._posTarget + 0.01) {
                            self._pos = self._posTarget;
                        }
                    }

                    if (self._pos < self._posTarget) {
                        self._pos += (self._posTarget - self._pos) / 5;
                        if (self._pos >= self._posTarget - 0.01) {
                            self._pos = self._posTarget;
                        }
                    }

                    self.__update();
                    if (self._pos == self._posTarget) {
                        callback && callback();
                        next();
                        clearInterval(self._anim);
                        self._anim = 0;
                    }
                }, 5);
            });
            this.$bar.dequeue();
        },

        /**
         * Gets, or Sets the element associated with a pane.
         * @function module:wcSplitter#pane
         * @param {Number} index - The index of the pane, only 0 and 1 are valid.
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        pane: function (index, item) {
            if (index >= 0 && index < 2) {
                if (typeof item === 'undefined') {
                    return this._pane[index];
                } else {
                    if (item) {
                        this._pane[index] = item;
                        item._parent = this;
                        item.__container(this.$pane[index]);

                        if (this._pane[0] && this._pane[1]) {
                            this.__update();
                        }
                        return item;
                    } else if (this._pane[index]) {
                        this._pane[index].__container(null);
                        this._pane[index] = false;
                    }
                }
            }
            // this.__update();
            return false;
        },

        /**
         * Gets, or Sets the element associated with the left side pane (for horizontal layouts).
         * @function module:wcSplitter#left
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        left: function (item) {
            return this.pane(0, item);
        },

        /**
         * Gets, or Sets the element associated with the right side pane (for horizontal layouts).
         * @function module:wcSplitter#right
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        right: function (item) {
            return this.pane(1, item);
        },

        /**
         * Gets, or Sets the element associated with the top pane (for vertical layouts).
         * @function module:wcSplitter#top
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        top: function (item) {
            return this.pane(0, item);
        },

        /**
         * Gets, or Sets the element associated with the bottom pane (for vertical layouts).
         * @function module:wcSplitter#bottom
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        bottom: function (item) {
            return this.pane(1, item);
        },

        /**
         * Gets, or Sets whether a pane can be scrolled via scroll bars.
         * By default, scrolling is enabled in both directions.
         * @function module:wcSplitter#scrollable
         * @param {Number} index - The index of the pane, only 0 and 1 are valid.
         * @param {Boolean} [x] - Whether to allow scrolling in the horizontal direction.
         * @param {Boolean} [y] - Whether to allow scrolling in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scroll state for each direction.
         */
        scrollable: function (index, x, y) {
            if (typeof x !== 'undefined') {
                this.$pane[index].toggleClass('wcScrollableX', x);
            }
            if (typeof y !== 'undefined') {
                this.$pane[index].toggleClass('wcScrollableY', y);
            }

            return {
                x: this.$pane[index].hasClass('wcScrollableX'),
                y: this.$pane[index].hasClass('wcScrollableY')
            };
        },

        /**
         * Destroys the splitter.
         * @function module:wcSplitter#destroy
         * @param {Boolean} [destroyPanes=true] - If true, both panes attached will be destroyed as well. Use false if you plan to continue using the objects assigned to each pane, or make sure to remove them first before destruction.
         */
        destroy: function (destroyPanes) {
            var docker = this.docker();
            if (docker) {
                var index = this.docker()._splitterList.indexOf(this);
                if (index > -1) {
                    this.docker()._splitterList.splice(index, 1);
                }
            }

            if (destroyPanes === undefined || destroyPanes) {
                this.__destroy();
            } else {
                this.__container(null);
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$pane.push($('<div class="wcLayoutPane wcScrollableX wcScrollableY">'));
            this.$pane.push($('<div class="wcLayoutPane wcScrollableX wcScrollableY">'));
            this.$bar = $('<div class="wcSplitterBar">');

            if (this._orientation) {
                // this.$pane[0].addClass('wcTall');
                // this.$pane[1].addClass('wcTall');
                this.$bar.addClass('wcTall').addClass('wcSplitterBarV');
            } else {
                // this.$pane[0].addClass('wcWide');
                // this.$pane[1].addClass('wcWide');
                this.$bar.addClass('wcWide').addClass('wcSplitterBarH');
            }

            this.__container(this.$container);

            if (this._parent && this._parent.instanceOf('wcPanel')) {
                this._boundEvents.push({event: wcDocker.EVENT.UPDATED, handler: this.__update.bind(this)});
                this._boundEvents.push({event: wcDocker.EVENT.CLOSED, handler: this.destroy.bind(this)});

                for (var i = 0; i < this._boundEvents.length; ++i) {
                    this._parent.on(this._boundEvents[i].event, this._boundEvents[i].handler);
                }
            }
        },

        // Updates the size of the splitter.
        __update: function (opt_dontMove) {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var minSize = this.__minPos();
            var maxSize = this.__maxPos();

            if (this._findBestPos) {
                this._findBestPos = false;

                var size1;
                var size2;
                if (this._pane[0] && typeof this._pane[0].initSize === 'function') {
                    size1 = this._pane[0].initSize();
                    if (size1) {
                        if (size1.x < 0) {
                            size1.x = width / 2;
                        }
                        if (size1.y < 0) {
                            size1.y = height / 2;
                        }
                    }
                }

                if (this._pane[1] && typeof this._pane[1].initSize === 'function') {
                    size2 = this._pane[1].initSize();
                    if (size2) {
                        if (size2.x < 0) {
                            size2.x = width / 2;
                        }
                        if (size2.y < 0) {
                            size2.y = height / 2;
                        }

                        size2.x = width - size2.x;
                        size2.y = height - size2.y;
                    }
                }

                var size;
                if (size1 && size2) {
                    size = {
                        x: Math.min(size1.x, size2.x),
                        y: Math.min(size1.y, size2.y)
                    };
                } else if (size1) {
                    size = size1;
                } else if (size2) {
                    size = size2;
                }

                if (size) {
                    if (this._orientation) {
                        this._pos = size.x / width;
                    } else {
                        this._pos = size.y / height;
                    }
                }
            }

            this.$bar.toggleClass('wcSplitterBarStatic', this.__isStatic());

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                var barBorder = parseInt(this.$bar.css('border-top-width')) + parseInt(this.$bar.css('border-bottom-width'));
                if (opt_dontMove) {
                    var offset = this._pixelPos - (this.$container.offset().left + parseInt(this.$container.css('border-left-width'))) - this.$bar.outerWidth() / 2;
                    this._pos = offset / (width - this.$bar.outerWidth());
                }

                this._pos = Math.min(Math.max(this._pos, 0), 1);
                var size = (width - this.$bar.outerWidth()) * this._pos + barSize;
                if (minSize) {
                    size = Math.max(minSize.x, size);
                }
                if (maxSize) {
                    size = Math.min(maxSize.x, size);
                }

                var top = 0;
                var bottom = 0;
                if (this._parent && this._parent.declaredClass === 'wcCollapser') {
                    var $outer = this.docker().$container;
                    var $inner = this._parent.$container;

                    top = $inner.offset().top - $outer.offset().top;
                    bottom = ($outer.offset().top + $outer.outerHeight()) - ($inner.offset().top + $inner.outerHeight());
                }

                // Bar is top to bottom
                this.$bar.css('left', size - barSize);
                this.$bar.css('top', top);
                this.$bar.css('height', height - barBorder - bottom);
                this.$pane[0].css('width', size - barSize);
                this.$pane[0].css('left', '0px');
                this.$pane[0].css('right', '');
                this.$pane[0].css('top', top);
                this.$pane[0].css('bottom', bottom);
                this.$pane[1].css('left', '');
                this.$pane[1].css('right', '0px');
                this.$pane[1].css('width', width - size - barSize - parseInt(this.$container.css('border-left-width')) * 2);
                this.$pane[1].css('top', top);
                this.$pane[1].css('bottom', bottom);

                this._pixelPos = this.$bar.offset().left + barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                var barBorder = parseInt(this.$bar.css('border-left-width')) + parseInt(this.$bar.css('border-right-width'));
                if (opt_dontMove) {
                    var offset = this._pixelPos - (this.$container.offset().top + parseInt(this.$container.css('border-top-width'))) - this.$bar.outerHeight() / 2;
                    this._pos = offset / (height - this.$bar.outerHeight());
                }

                this._pos = Math.min(Math.max(this._pos, 0), 1);
                var size = (height - this.$bar.outerHeight()) * this._pos + barSize;
                if (minSize) {
                    size = Math.max(minSize.y, size);
                }
                if (maxSize) {
                    size = Math.min(maxSize.y, size);
                }

                var left = 0;
                var right = 0;
                if (this._parent && this._parent.declaredClass === 'wcCollapser') {
                    var $outer = this.docker().$container;
                    var $inner = this._parent.$container;

                    left = $inner.offset().left - $outer.offset().left;
                    right = ($outer.offset().left + $outer.outerWidth()) - ($inner.offset().left + $inner.outerWidth());
                }

                // Bar is left to right
                this.$bar.css('top', size - barSize);
                this.$bar.css('left', left);
                this.$bar.css('width', width - barBorder - bottom);
                this.$pane[0].css('height', size - barSize);
                this.$pane[0].css('top', '0px');
                this.$pane[0].css('bottom', '');
                this.$pane[0].css('left', left);
                this.$pane[0].css('right', right);
                this.$pane[1].css('top', '');
                this.$pane[1].css('bottom', '0px');
                this.$pane[1].css('height', height - size - barSize - parseInt(this.$container.css('border-top-width')) * 2);
                this.$pane[1].css('left', left);
                this.$pane[1].css('right', right);

                this._pixelPos = this.$bar.offset().top + barSize;
            }

            if (opt_dontMove === undefined) {
                opt_dontMove = true;
            }
            this._pane[0] && this._pane[0].__update(opt_dontMove);
            this._pane[1] && this._pane[1].__update(opt_dontMove);
            //console.log('pos ' + this.pos());
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            // If this is a collapser splitter, do not save it, skip to the children.
            if (this._pane[0] && this._pane[0].declaredClass === 'wcCollapser') {
                return this._pane[1].__save();
            }
            if (this._pane[1] && this._pane[1].declaredClass === 'wcCollapser') {
                return this._pane[0].__save();
            }

            var data = {};
            data.type = 'wcSplitter';
            data.horizontal = this._orientation;
            data.isDrawer = this.$bar.hasClass('wcDrawerSplitterBar');
            data.pane0 = this._pane[0] ? this._pane[0].__save() : null;
            data.pane1 = this._pane[1] ? this._pane[1].__save() : null;
            data.pos = this._pos;
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._pos = data.pos;
            if (data.isDrawer) {
                this.$bar.addClass('wcDrawerSplitterBar');
            }
            if (data.pane0) {
                this._pane[0] = docker.__create(data.pane0, this, this.$pane[0]);
                this._pane[0].__restore(data.pane0, docker);
            }
            if (data.pane1) {
                this._pane[1] = docker.__create(data.pane1, this, this.$pane[1]);
                this._pane[1].__restore(data.pane1, docker);
            }
        },

        // Attempts to find the best splitter position based on
        // the contents of each pane.
        __findBestPos: function () {
            this._findBestPos = false;
        },

        // Moves the slider bar based on a mouse position.
        // Params:
        //    mouse       The mouse offset position.
        __moveBar: function (mouse) {
            var offset = this.$container.offset();
            mouse.x -= offset.left;
            mouse.y -= offset.top;

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var width = this.$container.outerWidth() - this.$bar.outerWidth();
                mouse.x += 1 - parseInt(this.$container.css('border-left-width')) - (this.$bar.outerWidth() / 2);
                this.pos(mouse.x / width);
            } else {
                var height = this.$container.outerHeight() - this.$bar.outerHeight();
                mouse.y += 1 - parseInt(this.$container.css('border-top-width')) - (this.$bar.outerHeight() / 2);
                this.pos(mouse.y / height);
            }
        },

        // Gets the minimum position of the splitter divider.
        __minPos: function () {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var minSize;
            if (this._pane[0] && typeof this._pane[0].minSize === 'function') {
                minSize = this._pane[0].minSize();
            } else {
                minSize = {x: 50, y: 50};
            }

            var maxSize;
            if (this._pane[1] && typeof this._pane[1].maxSize === 'function') {
                maxSize = this._pane[1].maxSize();
            } else {
                maxSize = {x: width, y: height};
            }

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                minSize.x += barSize;
                width -= barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                minSize.y += barSize;
                height -= barSize;
            }

            maxSize.x = width - Math.min(maxSize.x, width);
            maxSize.y = height - Math.min(maxSize.y, height);

            minSize.x = Math.max(minSize.x, maxSize.x);
            minSize.y = Math.max(minSize.y, maxSize.y);

            return minSize;
        },

        // Gets the maximum position of the splitter divider.
        __maxPos: function () {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var maxSize;
            if (this._pane[0] && typeof this._pane[0].maxSize === 'function') {
                maxSize = this._pane[0].maxSize();
            } else {
                maxSize = {x: width, y: height};
            }

            var minSize;
            if (this._pane[1] && typeof this._pane[1].minSize === 'function') {
                minSize = this._pane[1].minSize();
            } else {
                minSize = {x: 50, y: 50};
            }

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                maxSize.x += barSize;
                width -= barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                maxSize.y += barSize;
                height -= barSize;
            }

            minSize.x = width - minSize.x;
            minSize.y = height - minSize.y;

            maxSize.x = Math.min(minSize.x, maxSize.x);
            maxSize.y = Math.min(minSize.y, maxSize.y);
            return maxSize;
        },

        // Retrieves whether the splitter is static (not moveable).
        __isStatic: function () {
            var attr = this._orientation === wcDocker.ORIENTATION.HORIZONTAL ? 'x' : 'y';
            for (var i = 0; i < 2; ++i) {
                if (this._pane[i] && this._pane[i].minSize && this._pane[i].maxSize &&
                    this._pane[i].maxSize()[attr] - this._pane[i].minSize()[attr] === 0) {
                    return true;
                }
            }

            return false;
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;

            if (this.$container) {
                this.$container.append(this.$pane[0]);
                this.$container.append(this.$pane[1]);
                this.$container.append(this.$bar);
            } else {
                this.$pane[0].remove();
                this.$pane[1].remove();
                this.$bar.remove();
            }
            return this.$container;
        },

        // Removes a child from this splitter.
        // Params:
        //    child         The child to remove.
        __removeChild: function (child) {
            if (this._pane[0] === child) {
                this._pane[0] = false;
            } else if (this._pane[1] === child) {
                this._pane[1] = false;
            } else {
                return;
            }

            if (child) {
                child.__container(null);
                child._parent = null;
            }
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            // Stop any animations.
            if (this._anim) {
                clearInterval(this._anim);
                this._anim = 0;
            }
            this.$bar.clearQueue();

            // Remove all registered events.
            while (this._boundEvents.length) {
                this._parent.off(this._boundEvents[0].event, this._boundEvents[0].handler);
                this._boundEvents.shift();
            }

            if (this._pane[0]) {
                this._pane[0].__destroy();
                this._pane[0] = null;
            }
            if (this._pane[1]) {
                this._pane[1].__destroy();
                this._pane[1] = null;
            }

            this.__container(null);
            this._parent = false;
        }
    });

    // window['wcSplitter'] = Module;

    return Module;
});

/**
 * A callback function that is called when an action is finished.
 *
 * @callback wcSplitter~onFinished
 */

},
'dojo/errors/CancelError':function(){
define(["./create"], function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	
	return create("CancelError", null, null, { dojoType: "cancel" });
});

},
'dcl/advise':function(){
(function(factory){
	if(typeof define != "undefined"){
		define([], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		advise = factory();
	}
})(function(){
	"use strict";

	function Node(instance, name){
		this.next_before = this.prev_before = this.next_after = this.prev_after =
			this.next_around = this.prev_around = this;
		this.instance = instance;
		this.name = name;
	}
	var p = Node.prototype = {
		add: function(before, after, around, original){
			var node = new Node(this.instance, this.name);
			node.parent = this;
			node.before = before;
			this._add("before", node);
			node.after = after;
			this._add("after", node);
			node.around = around;
			this._add("around", node, original);
			node.original = original;
			if(original){ node.around = advise._instantiate(original, node.prev_around.around, this); }
			return node;
		},
		_add: function(topic, node, flag){
			if(node[topic] || flag){
				var n = "next_" + topic, p = "prev_" + topic;
				(node[p] = this[p])[n] = (node[n] = this)[p] = node;
			}
		},
		remove: function(node){
			this._remove("before", node);
			this._remove("after",  node);
			this._remove("around", node);
		},
		_remove: function(topic, node){
			var n = "next_" + topic, p = "prev_" + topic;
			node[n][p] = node[p];
			node[p][n] = node[n];
		},
		destroy: function(){
			var around = this.prev_around.around, t = this.next_around, parent = this.parent;
			this.remove(this);
			if(t !== this){
				for(; t !== parent; around = t.around, t = t.next_around){
					if(t.original){
						t.around = advise._instantiate(t.original, around, this);
					}
				}
			}
			this.instance = 0;
		}
	};
	p.unadvise = p.destroy;   // alias

	function makeAOPStub(node){
		var f = function(){
			var p, r, t = this, a = arguments, thrown;
			// running the before chain
			for(p = node.prev_before; p !== node; p = p.prev_before){
				p.before.apply(t, a);
			}
			// running the around chain
			try{
				if(node.prev_around !== node){ r = node.prev_around.around.apply(t, a); }
			}catch(e){
				r = e;
				thrown = true;
			}
			// running the after chain
			for(p = node.next_after; p !== node; p = p.next_after){
				p.after.call(t, a, r);
			}
			if(thrown){
				throw r;
			}
			return r;
		};
		f.adviceNode = node;
		return f;
	}

	function advise(instance, name, advice){
		var f = instance[name], node;
		if(f && f.adviceNode && f.adviceNode instanceof Node){
			node = f.adviceNode;
		}else{
			node = new Node(instance, name);
			if(f && f.advices){
				f = f.advices;
				node.add(f.before, f.after, f.around);
			}else{
				node.add(0, 0, f);
			}
			instance[name] = makeAOPStub(node);
		}
		if(typeof advice == "function"){ advice = advice(name, instance); }
		return node.add(advice.before, advice.after, 0, advice.around);
	}

	advise.before = function(instance, name, f){ return advise(instance, name, {before: f}); };
	advise.after  = function(instance, name, f){ return advise(instance, name, {after:  f}); };
	advise.around = function(instance, name, f){ return advise(instance, name, {around: f}); };
	advise.Node = Node;

	advise._instantiate = function(advice, previous, node){ return advice(previous); };

	return advise;
});

},
'dojo/_base/url':function(){
define(["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'dojo/selector/_loader':function(){
define(["../has", "require"],
		function(has, require){

"use strict";
var testDiv = document.createElement("div");
has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
has.add("dom-qsa3", function(){
			// test to see if we have a reasonable native selector engine available
			try{
				testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
				// Safari can't handle uppercase or unicode characters when
				// in quirks mode, IE8 can't handle pseudos like :empty
				return testDiv.querySelectorAll(".TEST:empty").length == 1;
			}catch(e){}
		});
var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
});

},
'xbox/Managers':function(){
define([
    'xide/manager/Context',
    'xide/manager/Application',
    'xide/manager/ManagerBase',
    'xfile/manager/Context',
    'xfile/manager/FileManager',
    'xide/manager/PluginManager'
],function(){});
},
'dojo/parser':function(){
define([
	"require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window",
		"./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./query", "./on", "./ready"
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval("(" + text + ")");
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
	var _ctorMap = {};

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		var ts = types.join();
		if(!_ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					(contextRequire ? contextRequire(t) : require(t)))));
			}
			var ctor = mixins.shift();
			_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return _ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojoType";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			var root;
			if(!options && rootNode && rootNode.rootNode){
				options = rootNode;
				root = options.rootNode;
			}else if(rootNode && dlang.isObject(rootNode) && !("nodeType" in rootNode)){
				options = rootNode;
			}else{
				root = rootNode;
			}
			root = root ? dom.byId(root) : dwindow.body();

			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if( 1 ){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
});

},
'xide/widgets/_Search':function(){
/** @module xide/widgets/Search **/
define([
    'xdojo/declare',
    'dojo/dom-construct',
    'dojo/on'
], function (declare,domConstruct,on) {
    /**
     * @class module:xide/Search
     * */
    return declare('xide/_Search', null,{
        _searchBoxHTML:'<div class="widget form-group grid_search right ">'+
                '<button type="button" action="hide" class="grid_searchbtn_close"></button>'+
                '<div class="grid_search_form">'+
                    '<input class="form-control input-transparent grid_search_field" placeholder="Search for" spellcheck="false"></input>'+
                    '<button type="button input-group-addon" action="findNext" class="grid_searchbtn next"></button>'+
                    '<button type="button" action="findPrev" class="grid_searchbtn prev"></button>'+
                    '<button type="button" action="findAll" class="grid_searchbtn" title="Alt-Enter">All</button>'+
                '</div> '+
                '<div class="ace_replace_form">'+
                    '<input class="grid_search_field" placeholder="Replace with" spellcheck="false"/>'+
                    '<button type="button" action="replaceAndFindNext" class="ace_replacebtn">Replace</button>'+
                    '<button type="button" action="replaceAll" class="ace_replacebtn">All</button>'+
                '</div>'+
                '<div class="grid_search_options">'+
                    '<span action="toggleRegexpMode" class="ace_button" title="RegExp Search">.*</span>'+
                    '<span action="toggleCaseSensitive" class="ace_button" title="CaseSensitive Search">Aa</span>'+
                    '<span action="toggleWholeWords" class="ace_button" title="Whole Word Search">\\b</span>'+
                '</div>'+
            '</div>'.replace(/>\s+/g, ">"),
        isHidden:function(){
            return !$(this.element).is(":visible");
        },
        showSearchBox:function(container){

            var div = domConstruct.create("div");
            div.innerHTML = this._searchBoxHTML;
            this.element = div.firstChild;
            container.appendChild(div);
            this.init();
        },
        highlight : function(re) {
            /*
             this.editor.session.highlight(re || this.editor.$search.$options.re);
             this.editor.renderer.updateBackMarkers()*/
        },
        find : function(skipCurrent, backwards) {

            var searchText = this.searchInput.value;

            //console.log('search for ',searchText);

            /*
             var range = this.editor.find(this.searchInput.value, {
             skipCurrent: skipCurrent,
             backwards: backwards,
             wrap: true,
             regExp: this.regExpOption.checked,
             caseSensitive: this.caseSensitiveOption.checked,
             wholeWord: this.wholeWordOption.checked
             });
             var noMatch = !range && this.searchInput.value;
             dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
             this.editor._emit("findSearchBox", { match: !noMatch });
             this.highlight();*/
        },
        findNext : function() {
            this.find(true, false);
        },
        findPrev : function() {
            this.find(true, true);
        },
        findAll : function(){
            /*
             var range = this.editor.findAll(this.searchInput.value, {
             regExp: this.regExpOption.checked,
             caseSensitive: this.caseSensitiveOption.checked,
             wholeWord: this.wholeWordOption.checked
             });
             var noMatch = !range && this.searchInput.value;
             dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
             this.editor._emit("findSearchBox", { match: !noMatch });
             this.highlight();
             this.hide();
             */
        },
        replace : function() {
            /*
             if (!this.editor.getReadOnly())
             this.editor.replace(this.replaceInput.value);
             */
        },
        replaceAndFindNext : function() {
            /*
             if (!this.editor.getReadOnly()) {
             this.editor.replace(this.replaceInput.value);
             this.findNext()
             }*/
        },
        replaceAll : function() {
            /*
             if (!this.editor.getReadOnly())
             this.editor.replaceAll(this.replaceInput.value);
             */
        },
        hide : function() {
            this.element.style.display = "none";
        },
        show : function(value, isReplace) {
            this.element.style.display = "";
            this.replaceBox.style.display = isReplace ? "" : "none";

            this.isReplace = isReplace;

            if (value)
                this.searchInput.value = value;
            this.searchInput.focus();
            this.searchInput.select();
            //this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
        },

        isFocused : function() {
            var el = document.activeElement;
            return el == this.searchInput || el == this.replaceInput;
        },
        initElements : function(sb) {
            this.searchBox = sb.querySelector(".grid_search_form");
            this.replaceBox = sb.querySelector(".ace_replace_form");
            this.searchOptions = sb.querySelector(".grid_search_options");
            this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
            this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
            this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
            this.searchInput = this.searchBox.querySelector(".grid_search_field");
            this.replaceInput = this.replaceBox.querySelector(".grid_search_field");
        },
        init : function() {

            var sb = this.element;

            this.initElements(sb);

            var _this = this;

            on(sb, "mousedown", function(e) {
                setTimeout(function(){
                    _this.activeInput.focus();
                }, 0);
                event.stopPropagation(e);
            });

            on(sb, "click", function(e) {

                /*
                 var t = e.target || e.srcElement;
                 var action = t.getAttribute("action");
                 if (action && _this[action]) {
                 _this[action]();
                 }
                 else if (_this.$searchBarKb.commands[action])
                 {
                 _this.$searchBarKb.commands[action].exec(_this);
                 }


                 event.stopPropagation(e);
                 */
            });




            /*
             event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
             var keyString = keyUtil.keyCodeToString(keyCode);
             var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
             if (command && command.exec) {
             command.exec(_this);
             event.stopEvent(e);
             }
             });
             */

            /*
             this.$onChange = lang.delayedCall(function() {
             _this.find(false, false);
             });*/

            var _lang = {
                delayedCall : function(fcn, defaultTimeout) {
                    var timer = null;
                    var callback = function() {
                        timer = null;
                        fcn();
                    };

                    var _self = function(timeout) {
                        if (timer == null)
                            timer = setTimeout(callback, timeout || defaultTimeout);
                    };

                    _self.delay = function(timeout) {
                        timer && clearTimeout(timer);
                        timer = setTimeout(callback, timeout || defaultTimeout);
                    };
                    _self.schedule = _self;

                    _self.call = function() {
                        this.cancel();
                        fcn();
                    };

                    _self.cancel = function() {
                        timer && clearTimeout(timer);
                        timer = null;
                    };

                    _self.isPending = function() {
                        return timer;
                    };

                    return _self;
                }
            }

            this.$onChange = _lang.delayedCall(function() {
                _this.find(false, false);
            });

            on(this.searchInput, "input", function() {
                _this.$onChange.schedule(20);
            });
            on(this.searchInput, "focus", function() {
                _this.activeInput = _this.searchInput;
                _this.searchInput.value && _this.highlight();
            });
            on(this.replaceInput, "focus", function() {
                _this.activeInput = _this.replaceInput;
                _this.searchInput.value && _this.highlight();
            });
        }
    });
});

},
'dojo/promise/all':function(){
define([
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

},
'xide/views/_EditorMixin':function(){
define([
        "dojo/_base/declare"
    ],function (declare){
        /**
         * Adds minimum comfort to an editor ready to be used in xide/xfile
         */
        return declare("xide.views._EditorMixin",null,{

            /**
             * The icon class when doing any storage operation
             * @member loadingIcon {string}
             */
            loadingIcon:'fa-spinner fa-spin',
            /**
             * The original icon class
             * @member iconClassNormal {string}
             */
            iconClassNormal:'fa-code',
            /**
             *
             */
            onLoaded:function(){
                this.set('iconClass', this.iconClassNormal);
            },
            /**
             * getContent reads the remote file's content and passes it onto onSuccess
             * @param item
             * @param onSuccess
             */
            getContent:function(item,onSuccess){

                var thiz=this;
                this.set('iconClass', this.loadingIcon);
                var _ready = function(content){
                    thiz.onLoaded();
                    onSuccess(content);
                };
                this.ctx.getFileManager().getContent(item.mount,item.path,_ready);
            },

            saveContent:function(value,item,onSuccess,onError){
                this.ctx.getFileManager().setContent(item.mount,item.path,value,onSuccess);
            },
            startup:function(){

                //save icon class normal
                this.iconClassNormal = '' + this.iconClass;
                this.set('iconClass', this.loadingIcon);
                this.inherited(arguments);
            }
        });
    });
},
'xgrid/ListRenderer':function(){
/** @module xgrid/ListRenderer **/
define([
    "xdojo/declare",
    'xide/types',
    './Renderer',
    'dojo/dom-construct',
    'dgrid/Grid'
], function (declare,types,Renderer,domConstruct,Grid) {

    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xgrid/ListRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {

        _getLabel:function(){ return "List"; },
        _getIcon:function(){ return "fa-th-list"; },
        activateRenderer:function(renderer){
            this._showHeader(true);
        },
        deactivateRenderer:function(renderer){},
        _configColumns: function () {
            return Grid.prototype._configColumns.apply(this, arguments);
        },
        insertRow:function(object,options) {
            return Grid.prototype.insertRow.apply(this, arguments);
        },
        renderRow:function(object,options){

            var self = this;
            var row = this.createRowCells('td', function (td, column) {
                var data = object;
                // Support get function or field property (similar to DataGrid)
                if (column.get) {
                    data = column.get(object);
                }
                else if ('field' in column && column.field !== '_item') {
                    data = data[column.field];
                }
                self._defaultRenderCell.call(column, object, data, td, options);
            }, options && options.subRows, object);
            // row gets a wrapper div for a couple reasons:
            // 1. So that one can set a fixed height on rows (heights can't be set on <table>'s AFAICT)
            // 2. So that outline style can be set on a row when it is focused,
            // and Safari's outline style is broken on <table>
            var div = domConstruct.create('div', { role: 'row' });
            div.appendChild(row);
            return div;
        }
    };

    //package via declare
    var _class = declare('xgrid.ListRenderer',[Renderer],Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'xide/_base/_Widget':function(){
/**
 * @module xide/_base/_Widget
 */
define([
    'dcl/dcl',
    "dcl/inherited",
    'xide/widgets/_Widget',
    "xide/utils",
    "dojo/string",
    "dojo/_base/lang",
    "xide/registry",
    "dojo/cache",
    "dojo/dom-construct",
    'xide/lodash',
    'xide/$'
], function (dcl,inherited,_Widget,utils,string,lang,registry,cache,domConstruct,_,$) {
    /////////////////////////////////////////////////////////////////
    //
    //  Attach Mixin Class
    //
    var attachAttribute = 'attachTo';
    /**
     *		Mixin for widgets to attach to dom nodes and setup events via
     *		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
     *
     *		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
     *		server.
     *
     *		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
     *		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
     *		doesn't.


     * _attachPoints: [private] String[]
     *		List of widget attribute names associated with data-dojo-attach-point=... in the
     *		template, ex: ["containerNode", "labelNode"]
     _attachPoints: [],

     * _attachEvents: [private] Handle[]
     *		List of connections associated with data-dojo-attach-event=... in the
     *		template
     _attachEvents: [],

     * attachScope: [public] Object
     *		Object to which attach points and events will be scoped.  Defaults
     *		to 'this'.
     attachScope: undefined,
     */
    var _AttachMixinClass = dcl(null, {

        __attachAsjQueryObject:true,
        __attachViaAddChild:true,
        __stopAtContainerNode:false,
        _started:false,
        //attachDirect:true,
        declaredClass:"xide/_base/_AttachMixin",
        cssClass:'',
        /**
         * Attach to DOM nodes marked with special attributes.
         */
        buildRendering: function(){
            this._attachPoints = [];
            //console.log('AttachMixin:: buildRendering');
            // recurse through the node, looking for, and attaching to, our
            // attachment points and events, which should be defined on the template node.
            this._attachTemplateNodes(this.domNode);
            this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
            this.cssClass && this.domNode && $(this.domNode).addClass(this.cssClass);

        },
        _beforeFillContent: function(){},
        /**
         * Iterate through the dom nodes and attach functions and nodes accordingly.
         * @description Map widget properties and functions to the handlers specified in
         *		the dom node and it's descendants. This function iterates over all
         *		nodes and looks for these properties:
         *	    - attachTo
         *
         * @param rootNode {HTMLElement}
         **/
        _attachTemplateNodes: function(rootNode){

            // DFS to process all nodes except those inside of this.containerNode
            var node = rootNode;
            while(true){
                if  (
                    node.nodeType == 1 &&
                    ( this._processTemplateNode(node,function(n,p){return n.getAttribute(p);},this._attach)) &&
                    node.firstChild
                ){
                    node = node.firstChild;
                }else{
                    if(node == rootNode){
                        return;
                    }
                    while(!node.nextSibling){
                        node = node.parentNode;
                        if(node == rootNode){
                            return;
                        }
                    }
                    node = node.nextSibling;
                }
            }
        },

        _processTemplateNode: function(baseNode, getAttrFunc, attachFunc){
            // summary:
            //		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
            //		Returns true if caller should process baseNode's children too.
            var ret = true;

            // Process data-dojo-attach-point
            var _attachScope = this.attachScope || this,
                attachPoint = getAttrFunc(baseNode, attachAttribute);

            if(attachPoint){
                var point, points = attachPoint.split(/\s*,\s*/);
                while((point = points.shift())){
                    if(_.isArray(_attachScope[point])){
                        _attachScope[point].push(baseNode);
                    }else{
                        _attachScope[point] = baseNode;
                        this.__attachAsjQueryObject &&  (_attachScope['$'+point] = $(baseNode));
                    }
                    ret = this.__stopAtContainerNode ? (point != "containerNode") : ret;
                    this._attachPoints.push(point);
                }
            }
            return ret;
        },
        /**
         * Detach and clean up the attachments made in _attachtempalteNodes.
         * @private
         */
        _detachTemplateNodes: function() {

            // Delete all attach points to prevent IE6 memory leaks.
            var _attachScope = this.attachScope || this;
            _.each(this._attachPoints, function(point){
                delete _attachScope[point];
            });
            this._attachPoints = [];
        },

        destroyRendering: function(){
            this._detachTemplateNodes();
            this.inherited && this.inherited(arguments);
        },
        startup:dcl.superCall(function(sup) {
            return function () {
                var res = null;
                if(sup){
                    res = sup.call(this);
                }
                this._started=true;
                return res;
            };
        })
    });
    /////////////////////////////////////////////////////////////////
    //
    //  Templated Mixin Class
    //
    //
    var _TemplatedMixin = dcl(_AttachMixinClass, {

        declaredClass:"xide/_base/_TemplatedMixin",
        // summary:
        //		Mixin for widgets that are instantiated from a template
        // templateString: [protected] String
        //		A string that represents the widget template.
        //		Use in conjunction with dojo.cache() to load from a file.
        templateString: null,
        // templatePath: [protected deprecated] String
        //		Path to template (HTML file) for this widget relative to dojo.baseUrl.
        //		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
        templatePath: null,
        // skipNodeCache: [protected] Boolean
        //		If using a cached widget template nodes poses issues for a
        //		particular widget class, it can set this property to ensure
        //		that its template is always re-built from a string
        _skipNodeCache: false,
        /*=====
         // _rendered: Boolean
         //		Not normally use, but this flag can be set by the app if the server has already rendered the template,
         //		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
         //		just function like _AttachMixin.
         _rendered: false,
         =====*/
        _stringRepl: function(tmpl){
            // summary:
            //		Does substitution of ${foo} type properties in template string
            // tags:
            //		private
            var className = this.declaredClass, _this = this;
            // Cache contains a string because we need to do property replacement
            // do the property replacement
            return string.substitute(tmpl, this, function(value, key){
                if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
                if(typeof value == "undefined"){
                    var error = new Error(className+" template:"+key)
                    logError(error);
                } // a debugging aide
                if(value == null){ return ""; }

                // Substitution keys beginning with ! will skip the transform step,
                // in case a user wishes to insert unescaped markup, e.g. ${!foo}
                return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
            }, this);
        },
        _escapeValue: function(/*String*/ val){
            // summary:
            //		Escape a value to be inserted into the template, either into an attribute value
            //		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

            // Safer substitution, see heading "Attribute values" in
            // http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
            // and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
            return val.replace(/["'<>&]/g, function(val){
                return {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    "\"": "&quot;",
                    "'": "&#x27;"
                }[val];
            });
        },
        /*
         * @description Construct the UI for this widget from a template, setting this.domNode.
         */
        buildRendering: dcl.superCall(function(sup){
            return function(){

                if(!this._rendered){

                    if(!this.templateString){
                        this.templateString = cache(this.templatePath, {sanitize: true});
                    }

                    // Lookup cached version of template, and download to cache if it
                    // isn't there already.  Returns either a DomNode or a string, depending on
                    // whether or not the template contains ${foo} replacement parameters.
                    var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);
                    var node;
                    if(_.isString(cached)){
                        node =  $(this._stringRepl(cached))[0];
                        if(node.nodeType != 1){
                            // Flag common problems such as templates with multiple top level nodes (nodeType == 11)
                            throw new Error("Invalid template: " + cached);
                        }
                    }else{
                        // if it's a node, all we have to do is clone it
                        node = cached.cloneNode(true);
                    }
                    this.domNode = node;
                }

                // Call down to _WidgetBase.buildRendering() to get base classes assigned
                sup.call(this, arguments);
                if(!this._rendered){
                    this._fillContent(this.srcNodeRef);
                }
                this._rendered = true;
                if(this.domNode && this.declaredClass){
                    $(this.domNode).addClass(utils.replaceAll('/','.',this.declaredClass));
                }
            };
        }),
        /**
         *
         * @param source {HTMLElement}
         * @private
         */
        _fillContent: function(source){
            // summary:
            //		Relocate source contents to templated container node.
            //		this.containerNode must be able to receive children, or exceptions will be thrown.
            // tags:
            //		protected
            var dest = this.containerNode;
            if(source && dest){
                while(source.hasChildNodes()){
                    dest.appendChild(source.firstChild);
                }
            }
        }

    });

    // key is templateString; object is either string or DOM tree
    _TemplatedMixin._templateCache = {};
    _TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
        // summary:
        //		Static method to get a template based on the templatePath or
        //		templateString key
        // templateString: String
        //		The template
        // alwaysUseString: Boolean
        //		Don't cache the DOM tree for this template, even if it doesn't have any variables
        // doc: Document?
        //		The target document.   Defaults to document global if unspecified.
        // returns: Mixed
        //		Either string (if there are ${} variables that need to be replaced) or just
        //		a DOM tree (if the node can be cloned directly)

        // is it already cached?
        var tmplts = _TemplatedMixin._templateCache;
        var key = templateString;
        var cached = tmplts[key];
        if(cached){
            try{
                // if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
                // current document, then use the current cached value
                if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
                    // string or node of the same document
                    return cached;
                }
            }catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
            domConstruct.destroy(cached);
        }

        templateString = _.trim(templateString);

        if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
            // there are variables in the template so all we can do is cache the string
            return (tmplts[key] = templateString); //String
        }else{
            // there are no variables in the template so we can cache the DOM tree
            var node = domConstruct.toDom(templateString, doc);
            if(node.nodeType != 1){
                throw new Error("Invalid template: " + templateString);
            }
            return (tmplts[key] = node); //Node
        }
    };

    /////////////////////////////////////////////////////////////////
    //
    //  Actual Widget base class, adding an API
    //
    function createClass_WidgetBase(){

        var tagAttrs = {};

        function getAttrs(obj){
            var ret = {};
            for(var attr in obj){
                ret[attr.toLowerCase()] = true;
            }
            return ret;
        }
        function isEqual(a, b){
            //	summary:
            //		Function that determines whether two values are identical,
            //		taking into account that NaN is not normally equal to itself
            //		in JS.
            return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
        }

        /**
         * @class module:xide/_base/_Widget
         */
        var Module = dcl(null,{
            _attrPairNames: {}, // shared between all widgets
            attributeMap: {},
            declaredClass:'xide/_base/_Widget',

            on:function(type,handler){
                return this._on(type,handler);
            },
            emit:function(type,args){
                return this._emit(type,args);
            },
            _set: function(/*String*/ name, /*anything*/ value){
                // summary:
                //		Helper function to set new value for specified property, and call handlers
                //		registered with watch() if the value has changed.
                var oldValue = this[name];
                this[name] = value;
                if(this._created && !isEqual(oldValue, value)){
                    this._watchCallbacks && this._watchCallbacks(name, oldValue, value);
                    this.emit("attrmodified-" + name, {
                        detail: {
                            prevValue: oldValue,
                            newValue: value
                        }
                    });
                }
            },
            /**
             * Helper function to get value for specified property stored by this._set(),
             * i.e. for properties with custom setters.  Used mainly by custom getters.
             *  For example, CheckBox._getValueAttr() calls this._get("value").
             * @param name {string}
             * @returns {*}
             * @private
             */
            _get: function( name){
                // future: return name in this.props ? this.props[name] : this[name];
                return this[name];
            },
            /**
             *  Helper function for get() and set().
             *  Caches attribute name values so we don't do the string ops every time.
             * @param name
             * @returns {*}
             * @private
             */
            _getAttrNames: function(name){
                var apn = this._attrPairNames;
                if(apn[name]){
                    return apn[name];
                }
                var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
                    return c.charAt(c.length - 1).toUpperCase();
                });
                return (apn[name] = {
                    n: name + "Node",
                    s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
                    g: "_get" + uc + "Attr",
                    l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
                });
            },
            /**
             * Set a property on a widget
             * @description Sets named properties on a widget which may potentially be handled by a setter in the widget.
             *
             *		For example, if the widget has properties `foo` and `bar`
             *		and a method named `_setFooAttr()`, calling
             *		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
             *		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
             *		would be equivalent to the statement `widget.bar = 3;`
             *
             *      This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`
             *
             *		set() may also be called with a hash of name/value pairs, ex:
             *
             *	@example
             *	myWidget.set({
                    foo: "Howdy",
                    bar: 3
                    });
             *
             * @param name {string} The property to set.
             * @param value {object|null}
             * @returns {*}
             */
            set: function(name, value){
                if(typeof name === "object"){
                    for(var x in name){
                        this.set(x, name[x]);
                    }
                    return this;
                }
                var names = this._getAttrNames(name),
                    setter = this[names.s];

                if(_.isFunction(setter)){
                    // use the explicit setter
                    setter.apply(this, Array.prototype.slice.call(arguments, 1));
                }else{
                    // Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
                    // Map according to:
                    //		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
                    //		2. _setFooAttr: {...} type attribute in the widget (if one exists)
                    //		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
                    // Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
                    // attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
                    // Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
                    var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
                        tag = this[defaultNode] && this[defaultNode].tagName,
                        attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
                        map = name in this.attributeMap ? this.attributeMap[name] :
                            names.s in this ? this[names.s] :
                                ((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
                                /^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
                    if(map != null){
                        this._attrToDom(name, value, map);
                    }

                    this._set(name, value);

                }
                return this;
            },
            postCreate:function(){
            },
            postMixInProperties:dcl.superCall(function(sup){
                return function(props){
                    sup && sup.call(this, props);
                };
            }),
            create: function(params, srcNodeRef){
                // summary:
                //		Kick off the life-cycle of a widget
                // description:
                //		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
                //		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
                //		for a discussion of the widget creation lifecycle.
                //
                //		Of course, adventurous developers could override create entirely, but this should
                //		only be done as a last resort.
                // params: Object|null
                //		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
                //		and functions, typically callbacks like onClick.
                //		The hash can contain any of the widget's properties, excluding read-only properties.
                // srcNodeRef: DOMNode|String?
                //		If a srcNodeRef (DOM node) is specified:
                //
                //		- use srcNodeRef.innerHTML as my contents
                //		- if this is a behavioral widget then apply behavior to that srcNodeRef
                //		- otherwise, replace srcNodeRef with my generated DOM tree
                // tags:
                //		private

                // First time widget is instantiated, scan prototype to figure out info about custom setters etc.
                //this._introspect();

                // store pointer to original DOM tree
                this.srcNodeRef = $(srcNodeRef)[0];

                // No longer used, remove for 2.0.
                this._connects = [];
                this._supportingWidgets = [];

                // this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
                if(this.srcNodeRef && this.srcNodeRef.id){
                    this.id = this.srcNodeRef.id;
                }

                // mix in our passed parameters
                if(params){
                    this.params = params;
                    utils.mixin(this, params);
                }

                if(this.postMixInProperties) {
                    this.postMixInProperties();
                }

                // Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
                // Do this before buildRendering() because it might expect the id to be there.
                if(!this.id){
                    this.id = registry.getUniqueId(this.declaredClass.replace(/\//g, "_"));
                    if(this.params){
                        // if params contains {id: undefined}, prevent _applyAttributes() from processing it
                        delete this.params.id;
                    }
                }


                // The document and <body> node this widget is associated with
                this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
                this.ownerDocumentBody = $('body')[0];
                registry.add(this);

                this.buildRendering();
                if(this.domNode){
                    // Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
                    // Also calls custom setters for all attributes with custom setters.
                    //this._applyAttributes();

                    // If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
                    // For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
                    // widget being attached to the DOM since it isn't when a widget is created programmatically like
                    // new MyWidget({}).	See #11635.
                    var source = this.srcNodeRef;
                    if(source && source.parentNode && this.domNode !== source){
                        source.parentNode.replaceChild(this.domNode, source);
                    }
                    // Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
                    // assuming that dojo._scopeName even exists in 2.0
                    this.domNode.setAttribute("id", this.id);

                    if(this.style){
                        $(this.domNode).css(this.style);
                    }
                }
                this.postCreate();
                this._created = true;
            },
            constructor:function(params,container){
                this.postscript && this.postscript(params,container);
            },
            postscript:function(params,srcNodeRef){
                return this.create(params, srcNodeRef);
            },
            /**
             *		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             *		is this widget.   Note that it does not return all descendants, but rather just direct children.
             *		Analogous to [Node.childNodes](https:*developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
             *		except containing widgets rather than DOMNodes.
             *
             *		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             *		outside of this.containerNode.
             *
             *		Note that the array returned is a simple array.  Application code should not assume
             *		existence of methods like forEach().
             *
             * @returns {*}
             */
            getChildren: function(){
                return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
            },
            getParent: function(){
                // summary:
                //		Returns the parent widget of this widget.
                return registry.getEnclosingWidget(this.domNode.parentNode);
            },
            //////////// DESTROY FUNCTIONS ////////////////////////////////
            /**
             * Destroy this widget and its descendants
             * @description If true, this method will leave the original DOM structure
             *		alone of descendant Widgets. Note: This will NOT work with
             *		dijit._TemplatedMixin widgets.
             * @param preserveDom {boolean}
             */
            destroyRecursive: function(preserveDom){
                this._beingDestroyed = true;
                this.destroyDescendants(preserveDom);
                this.destroy(preserveDom);
            },
            destroy: function(/*Boolean*/ preserveDom){
                // summary:
                //		Destroy this widget, but not its descendants.  Descendants means widgets inside of
                //		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
                //
                //		This method will also destroy internal widgets such as those created from a template,
                //		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
                //
                //		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
                //		depend on the current ability to destroy a widget without destroying its descendants.   Generally
                //		they should use destroyRecursive() for widgets with children.
                // preserveDom: Boolean
                //		If true, this method will leave the original DOM structure alone.
                //		Note: This will not yet work with _TemplatedMixin widgets

                this._beingDestroyed = true;

                function destroy(w){
                    if(w.destroyRecursive){
                        w.destroyRecursive(preserveDom);
                    }else if(w.destroy){
                        w.destroy(preserveDom);
                    }
                }
                // Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
                // here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
                if(this.domNode){
                    _.each(registry.findWidgets(this.domNode, this.containerNode), destroy);
                }
                this.destroyRendering(preserveDom);
                registry.remove(this.id);
                this._destroyed = true;
                this._emit('destroy');
            },
            destroyRendering: function(/*Boolean?*/ preserveDom){
                // summary:
                //		Destroys the DOM nodes associated with this widget.
                // preserveDom:
                //		If true, this method will leave the original DOM structure alone
                //		during tear-down. Note: this will not work with _Templated
                //		widgets yet.
                // tags:
                //		protected

                if(this.domNode){
                    if(preserveDom){

                    }else{
                        domConstruct.destroy(this.domNode);
                    }
                    delete this.domNode;
                }

                if(this.srcNodeRef){
                    if(!preserveDom){
                        domConstruct.destroy(this.srcNodeRef);
                    }
                    delete this.srcNodeRef;
                }
            },
            destroyDescendants: function(/*Boolean?*/ preserveDom){
                // summary:
                //		Recursively destroy the children of this widget and their
                //		descendants.
                // preserveDom:
                //		If true, the preserveDom attribute is passed to all descendant
                //		widget's .destroy() method. Not for use with _Templated
                //		widgets.

                // get all direct descendants and destroy them recursively
                _.each(this.getChildren(), function(widget){
                    if(widget.destroyRecursive){
                        widget.destroyRecursive(preserveDom);
                    }
                });
            }
        });
        return Module;

    }

    var StoreMixin = dcl(null,{
        wireStore:function(store,updateFn,events){
            store = store || this.store;
            var handles = [];
            events = events || ['update','added','remove','delete'];
            for (var i = 0; i < events.length; i++) {
                var event = events[i];
                var _handle = store.on(event, updateFn.bind(this));
                handles.push(_handle);
                this.addHandle && this.addHandle(event,_handle);
            }
            return handles;
        }
    });

    var _WidgetClass = createClass_WidgetBase();

    /////////////////////////////////////////////////////////////////
    //
    //  Module exports
    //
    //
    var Module = dcl([_WidgetClass,_TemplatedMixin,_Widget.dcl],{});

    Module.AttachClass = _AttachMixinClass;
    Module.TemplateClass = _TemplatedMixin;
    Module.WidgetClass = _WidgetClass;
    Module.StoreMixin = StoreMixin;

    dcl.chainAfter(Module,"resize");
    dcl.chainAfter(Module,"destroy");
    dcl.chainAfter(Module,"startup");
    return Module;
});
},
'xide/encoding/_base':function(){
define([
	"dojo/_base/lang"

], function(lang){

	//	These functions are 32-bit word-based.  See _sha-64 for 64-bit word ops.
	var base = {};//lang.getObject("dojox.encoding.digests", true);

	base.outputTypes={
		// summary:
		//		Enumeration for input and output encodings.
		Base64:0, Hex:1, String:2, Raw:3
	};

	//	word-based addition
	base.addWords=function(/* word */a, /* word */b){
		// summary:
		//		add a pair of words together with rollover
		var l=(a&0xFFFF)+(b&0xFFFF);
		var m=(a>>16)+(b>>16)+(l>>16);
		return (m<<16)|(l&0xFFFF);	//	word
	};

	//	word-based conversion method, for efficiency sake;
	//	most digests operate on words, and this should be faster
	//	than the encoding version (which works on bytes).
	var chrsz=8;	//	16 for Unicode
	var mask=(1<<chrsz)-1;

	base.stringToWord=function(/* string */s){
		// summary:
		//		convert a string to a word array
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
		}
		return wa;	//	word[]
	};

	base.wordToString=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a string
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		}
		return s.join("");	//	string
	};

	base.wordToHex=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a hex tab
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");	//	string
	};

	base.wordToBase64=function(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	convert to UTF-8
	base.stringToUtf8 = function(input){
		var output = "";
		var i = -1;
		var x, y;

		while(++i < input.length){
			x = input.charCodeAt(i);
			y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
			if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF){
				x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
				i++;
			}

			if(x <= 0x7F)
				output += String.fromCharCode(x);
			else if(x <= 0x7FF)
				output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F), 0x80 | (x & 0x3F));
			else if(x <= 0xFFFF)
				output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
			else if(x <= 0x1FFFFF)
				output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07), 0x80 | ((x >>> 12) & 0x3F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
		}
		return output;
	};

	return base;
});

},
'xgrid/ThumbRenderer':function(){
/** @module xgrid/ThumbRenderer **/
define([
    "xdojo/declare",
    'xide/types',
    'dojo/dom-construct',
    './Renderer'
], function (declare,types,domConstruct,Renderer) {
    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xgrid/ThumbRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        isThumbGrid:false,
        _getLabel:function(){ return "Thumb"; },
        _getIcon:function(){ return "fa-th-large"; },
        activateRenderer:function(renderer){
            this._showHeader(false);
            this.isThumbGrid = true;
        },
        deactivateRenderer:function(renderer){
            this.isThumbGrid = false;
        },
        /**
         * Override renderRow
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {
            if (obj.render) {
                return obj.render(obj, this.inherited);
            }
            return domConstruct.create('span', {
                className: "fileGridCell",
                innerHTML: '<span class=\"' + 'fa-cube fa-5x' + '\""></span> <div class="name">' + obj.name + '</div>',
                style: 'color:blue;max-width:200px;float:left;margin:18px;padding:18px;'
            });
        }
    };

    //package via declare
    var _class = declare('xgrid.ThumbRenderer',[Renderer],Implementation);
    _class.Implementation = Implementation;

    return _class;
});
},
'xide/utils/StoreUtils':function(){
define([
    'xide/utils',
    'xide/data/Memory',
    'dojo/_base/kernel'
], function (utils, Memory,dojo) {
    "use strict";
    /**
     *
     * @param store
     * @param item
     * @param recursive
     * @param idAttribute
     * @param parentAttr
     */
    utils.removeFromStore = function (store, item, recursive, idAttribute, parentAttr) {
        //remove the item itself
        store.removeSync(item[idAttribute]);
        //remove children recursively
        var query = {};
        query[parentAttr] = item[idAttribute];
        var items = store.query(query);
        if (items && items.length) {
            for (var i = 0; i < items.length; i++) {
                utils.removeFromStore(store, items[i], recursive, idAttribute, parentAttr);
            }
        }
    };
    /**
     * CI related tools.
     * @param val {string|array|null}
     * @returns {string|null}
     */
    utils.toString = function (val) {
        if (val != null) {
            if (!dojo.isArray(val)) {
                return '' + val;
            }
            if (val && val.length == 1 && val[0] == null) {
                return null;
            }
            return '' + (val[0] != null ? val[0] : val);
        }
        return null;
    };
    utils.toBoolean = function (data) {
        var resInt = false;
        if (data != null) {
            var _dataStr = data[0] ? data[0] : data;
            if (_dataStr != null) {
                resInt = !!(( _dataStr === true || _dataStr === 'true' || _dataStr === '1'));
            }
        }
        return resInt;
    };
    utils.toObject = function (data) {
        if (data != null) {
            return data[0] ? data[0] : data;
        }
        return null;
    };
    utils.toInt = function (data) {
        if(_.isNumber(data)){
            return data;
        }
        var resInt = -1;
        if (data!=null) {
            var _dataStr = data.length > 1 ? data : data[0] ? data[0] : data;
            if (_dataStr != null) {
                resInt = parseInt(_dataStr, 10);
            }
        }
        return resInt;
    };
    /***
     *
     * @param store
     * @param id
     * @return {null}
     */
    utils.getStoreItemById = function (store, id) {
        return utils.queryStoreEx(store, {id: id},null,null);
    };
    /***
     *
     * @param store
     * @param id
     * @param type
     * @return {null}
     */
    utils.getAppDataElementByIdAndType = function (store, id, type) {
        return utils.queryStore(store, {uid: id, type: type},null,null);
    };
    /***
     *
     * @param store
     * @param type
     * @return {null}
     */
    utils.getElementsByType = function (store, type) {
        return utils.queryStoreEx(store, {type: type});
    };


    /***
     * @param store {module:xide/data/_Base} Store to query
     * @param query {object} Literal to match
     * @param nullEmpty {boolean|null} Return null if nothing has been found
     * @param single {boolean|null} Return first entry
     * @returns {*}
     */
    utils.queryStoreEx = function (store, query, nullEmpty, single) {
        if (!store) {
            console.error('utils.queryStoreEx: store = null');
            return null;
        }
        if (store instanceof Memory) {
            var result = utils.queryMemoryStoreEx(store, query);
            if (single && result && result[0]) {
                return result[0];
            }
            return result;
        }
        var res = null;
        if (store.query) {
            res = store.query(query);
        }
        if (nullEmpty === true) {
            if (res && res.length === 0) {
                return null;
            }
        }
        if (single === true) {
            if (res && res.length == 1) {
                return res[0];
            }
        }
        return res;
    };

    /**
     *
     * @param store
     * @param query
     * @param nullEmpty {boolean|null}
     * @returns {*}
     */
    utils.queryStore = function (store, query, nullEmpty) {
        var res = utils.queryStoreEx(store, query,null,null);
        if (res && res.length == 1) {
            return res[0];
        }
        if (nullEmpty === true) {
            if (res && res.length === 0) {
                return null;
            }
        }
        return res;
    };

    /**
     *
     * @param store
     * @param query
     * @returns {Array}
     */
    utils.queryMemoryStoreEx = function (store, query) {
        var result = [];
        store.query(query).forEach(function (entry) {
            result.push(entry);
        });
        return result;
    };

    utils.queryMemoryStoreSingle = function (store, query) {
        var result = utils.queryMemoryStoreEx(store, query);
        if (result.length == 1) {
            return result[0];
        }
        return result;
    };

    return utils;
});
},
'url:xide/views/welcome.html':"<div class=\"widget\" style=\"overflow: auto;margin: 4px;font-size: 30px !important;\">\n\n<div class=\"widget\" attachTo=\"welcomeHead\"/>\n\n\n<pre style=\"font-size: initial\" class=\"widget\" attachTo=\"welcomeMain\">\n\nKeyboard\n\nF1 : Help\nF2 : Rename\nF3 : Preview file\nF4 / Enter : Edit file\nF5 : Copy to\nF6 : Move to\nF7 : Create directory\nF8 / Delete : Delete\nF9 : Create file\n\nNavigation\n\nEnter : Open or edit folder or file\nAlt + ENTER : Open in new tab\nBACKSPACE : Go back in history\n\n    Window\n\nCTRL + W : Close current tab\nF11 : Browser fullscreen\nALT + F11 : Toggle navigation panel (if exists)\nCTRL + F11 : Toggle navigation panel and ribbon, (if exists)\nNUM + + : Num & Plus selects next tab\nNUM + - : Num & Minus/Subtract selects prev. tab\n\n    Selection\n\nSHIFT+UP/DOWN : Multi-Selection, hold CTRL and release SHIFT to skip next whilst pressing up or down\nCTRL+A : Select all\nCTRL-D : Select none\nCTRL-I : Inverse\nCTRL + CLICK : Append/add to selection\nHOME : Go to first row : works with SHIFT\nEND : Go to last row : works with SHIFT\n\n    Tree\n\nLeft : Collapse/Expand folder\nRight : Expand folder, if open, go into!\n\n    Clipboard\n\nCTRL + C : Copy selection to clipboard\nCTRL + X : Cut selection to clipboard\nCTRL + V : Paste selection\n\n    Editor (ACE)\n\nCTRL + F11 : Maximize Toggle\nCTRL + S : Save\nCTRL + F : Open search\nCTRL + L : Reload\n\nCtrl-F / Cmd-F : Start searching\n\nCtrl-G / Cmd-G : Find next\nCtrl -/ + : Change Font Size\n\nSHIFT + CTRL-G / SHIFT-Cmd-G : Find previous\n\nSHIFT-Ctrl-F / Cmd-Option-F : Replace\nSHIFT-Ctrl-R / SHIFT-Cmd-Option-F : Replace all\n\n    Console\n\nEnter : Send or run buffer (in single line mode)\nCTRL + Enter : Send or run buffer (in multi-line mode)\nSHIFT + Enter : Clear output\nMain - Menu\n\nSHIFT + ALT + F : Open main menu\n\n    Controls - Mouse\n\nRight-Click : Open context menu\nCTRL : Enable copy mode for drag and drop\n\n    Upload\n\nSimple drag files from your desktop into any file panel\nRemote downloads: drag the browser url into any file panel\n</pre>\n</div>"}});
(function(){
	// must use this.require to make this work in node.js
	var require = this.require;
	// consume the cached dojo layer
	require({cache:{}});
	!require.async && require(["dojo"]);
	require.boot && require.apply(null, require.boot);
})();
