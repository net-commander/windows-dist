(function () {

    //bloody boiler code
    var __isAMD = !!(typeof define === 'function' && define.amd),
        __isNode = (typeof exports === 'object'),
        __isWeb = !__isNode,
    //is that enough at some point?
        __isDojoRequire = !!(typeof require === 'function' && require.packs),
        __isRequireJS = !__isDojoRequire,
        __deliteHas = !!(typeof has === 'function' && has.addModule),
        __hasDcl = !!(typeof dcl === 'function'),//false if dcl has not been required yet
        __preferDcl = false;//!__isDojoRequire && __hasDcl;

    /**
     * @TODO
     *
     * - convert dojo base classes recursive, currently it only accepts simple dojo classes, not with multiple
     * base classes but you can use as many dcl base classes as you want.
     * - deal with un-tested cases: nodejs, cjs
     *
     * @example  tested cases:

     1. var fooBar = dDeclare('foo.bar',null,{}); // works with dcl or dojo

     2. var myFooBarKid = dDeclare('my.foo.bar',[fooBar],{}); // works with dcl or dojo

     3. using a Dojo declared class together with a dcl declared class:

     var _myDojoClass = declare('dojoClass',null,{});
     var _classD2 = dDeclare('my mixed class',[myFooBarKid,_myDojoClass],{});

     *
     */
    var _define = define;

    _define([
        //needed?
        'exports',
        'module',
        'xide/utils',
        'dojo/_base/declare',
        (typeof __isDojoRequire !='undefined' && __isDojoRequire ) ? __preferDcl ? 'dcl/dcl' :  'dojo/_base/declare' : 'dcl/dcl'

    ], function (exports, module,utils,dDeclare) {

        /*
        console.log('xdojo/declare:\n\t  _isAMD:' +__isAMD +
            "\n\t isNode:" + __isNode +
            "\n\t isDojoRequire:" + __isDojoRequire +
            "\n\t isRequireJS:" + __isRequireJS +
            "\n\t __deliteHas:" + __deliteHas +
            "\n\t __hasDcl:" + __hasDcl +
            "\n\t __preferDcl:" + __preferDcl
        );
        */


        if(!__isDojoRequire && __preferDcl) {
            var _dcl = null;//
            try {

                _dcl = require('dcl/dcl');
                if (_dcl) {
                    dDeclare = _dcl;
                }
            } catch (e) {

            }
        }

        ////////////////////////////////////////////////////////////////////
        //
        // Extras
        //
        ///////////////////////////////////////////////////////////////////

        function addExtras(handler){

            /**
             *
             * @param name
             * @param bases {object}
             * @param extraClasses {object[]}
             * @param implmentation
             * @param defaults
             * @returns {*}
             */
            function classFactory(name, bases, extraClasses, implmentation,defaults) {


                var baseClasses = bases!=null ? bases : utils.cloneKeys(defaults || {}),
                    extras = extraClasses || [],
                    _name = name || 'xgrid.Base',
                    _implmentation = implmentation || {};

                if (bases) {
                    utils.mixin(baseClasses, bases);
                }

                var classes = [];
                for (var _class in baseClasses) {
                    var _classProto = baseClasses[_class];
                    if ( _classProto) {
                        classes.push(baseClasses[_class]);
                    }
                }

                classes = classes.concat(extras);

                return handler(_name, classes, _implmentation);
            }

            handler.classFactory=classFactory;

        }


        if (dDeclare) {

            //node.js
            if (typeof exports !== "undefined") {
                exports.declare = dDeclare;
            }

            if (__isNode) {
                return module.exports;
            } else if (__isWeb && __isAMD) {

                //todo: where to place this?
                var _patchDCL = true,     //patch DCL for Dojo declare signature
                    _convertToDCL = true, //if a dojo/declared class is passed, convert it to DCL
                    handler = dDeclare;

                //now make Dcl working like declare, supporting declaredClass.
                //This could be done via define('module') and then module.id but i don't trust it.
                if (handler && __preferDcl && !dDeclare.safeMixin) {

                    if(_patchDCL) {

                        //the Dojo to Dcl converter, see TODO's
                        function makeClass(name,_class,_declare){
                            return _declare(null,_class,_class.prototype);
                        }

                        //in-place base class check & convert from dojo declared base class to dcl base class
                        //@TODO: recursive and cache !! There is probably more..
                        function checkClasses(classes,_declare){

                            for (var i = 0, j = classes.length; i < j ; i++) {

                                var o = classes[i];
                                //convert dojo base class
                                if(o.createSubclass){
                                    var declaredClass =  o.declaredClass || o.prototype.declaredClass;
                                    var out = makeClass(declaredClass,o,handler);
                                    classes[i] = o = out;
                                }
                            }
                            return classes;
                        }

                        var _declareFunction = function () {

                            var _declaredClass = null,
                                args = arguments,
                                context = arguments.callee;//no need actually



                            //eat declared string arg
                            if (typeof arguments[0] == 'string') {
                                _declaredClass = arguments[0];
                                args = Array.prototype.slice.call(arguments, 1);
                            }

                            //patch props for declaredClass, @TODO: not sure dcl() has really only 2 args
                            if(_declaredClass) {

                                //this will add declared class into the new class's prototype
                                args[args.length-1]['declaredClass'] = _declaredClass;

                            }

                            switch (args.length) {
                                case 1:
                                    //fast and legit dcl case, no base classes given
                                    return handler.call(context,null,args[0]);
                                case 2:{

                                    //base classes given and prototype given, convert to Dojo if desired

                                    //straight forward
                                    if(!_convertToDCL) {
                                        return handler.call(context, args[0], args[1]);
                                    }

                                    //convert base classes if given
                                    /*
                                    if(handler.Advice && args[0] == null) {
                                        return handler.call(args[0] != null ? checkClasses(args[0]) : args[0], args[1]);
                                    }*/
                                    var bases = args[0] != null ? checkClasses(args[0]) : args[0];
                                    var proto = args[1];
                                    /*
                                    if(handler.Advice && bases) {
                                        return handler.call(bases, proto);
                                    }*/
                                    return handler.call(context, bases, proto);
                                }
                                // fall through
                                default:
                                    return handler.call(context,args);
                            }
                        };
                        addExtras(_declareFunction);
                        return _declareFunction;
                    }
                }
                addExtras(dDeclare);
                return dDeclare;
            }
            addExtras(dDeclare);
            return dDeclare;

        } else {

            //@TODO, add fallback version?
            //we shouldn't be here anyways, dcl or dojo/declare has not been loaded yet!
            return resultingDeclare;
        }
    });
}).call(this);
define("xdojo/declare", function(){});

define('xide/types',[
    "dcl/dcl"
],function(dcl){
    var mod = new dcl(null,{
        declaredClass:"xide/types"
    });
    mod.test = 22;
    return mod;
});


/** @module xgrid/Renderer **/
define('xgrid/Renderer',[
    "xdojo/declare",
    'xide/types'
], function (declare,types) {
    var Implementation = {
        _renderIndex: 0,
        _lastRenderedArray: null,
        publishRendering: false,
        _getLabel:function(){return ''},
        activateRenderer:function(renderer){},
        deactivateRenderer:function(renderer){},
        runAction:function(action){},
        /**
         * Placeholder
         */
        delegate: {
            onDidRenderCollection: function () {}
        },
        /**
         * Override render row to enable model side rendering
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {
            if (obj.render) {
                return obj.render(obj, this.inherited);
            }
            return this.inherited(arguments);
        },
        /**
         * Override renderArray in dgrid/List to track the
         * last rendered array
         * @returns {HTMLElement[]}
         */
        renderArray: function () {
            this._lastRenderedArray = this.inherited(arguments);
            this._onDidRenderCollection(arguments);
            return this._lastRenderedArray;
        },
        /**
         * Callback for dgrid/List#refresh promise, used to publish
         * the last rendered collection
         *
         */
        _onDidRenderCollection: function () {
            var info = {
                collection: this._renderedCollection,
                elements: this._lastRenderedArray,
                grid: this
            };
            this._renderIndex++;
        },
        /**
         * Return that this grid has actually rendered anything.
         * @returns {boolean}
         */
        didRender: function () {
            return this._renderIndex >= 0;
        }
    };

    //package via declare
    var _class = declare('xgrid.Renderer',null,Implementation);
    _class.Implementation = Implementation;

    return _class;
});
define('dgrid/util/misc',[
	'dojo/has'
], function (has) {
	// summary:
	//		This module defines miscellaneous utility methods for purposes of
	//		adding styles, and throttling/debouncing function calls.

	has.add('dom-contains', function (global, doc, element) {
		return !!element.contains; // not supported by FF < 9
	});

	// establish an extra stylesheet which addCssRule calls will use,
	// plus an array to track actual indices in stylesheet for removal
	var extraRules = [],
		extraSheet,
		removeMethod,
		rulesProperty,
		invalidCssChars = /([^A-Za-z0-9_\u00A0-\uFFFF-])/g;

	function removeRule(index) {
		// Function called by the remove method on objects returned by addCssRule.
		var realIndex = extraRules[index],
			i, l;
		if (realIndex === undefined) {
			return; // already removed
		}

		// remove rule indicated in internal array at index
		extraSheet[removeMethod](realIndex);

		// Clear internal array item representing rule that was just deleted.
		// NOTE: we do NOT splice, since the point of this array is specifically
		// to negotiate the splicing that occurs in the stylesheet itself!
		extraRules[index] = undefined;

		// Then update array items as necessary to downshift remaining rule indices.
		// Can start at index + 1, since array is sparse but strictly increasing.
		for (i = index + 1, l = extraRules.length; i < l; i++) {
			if (extraRules[i] > realIndex) {
				extraRules[i]--;
			}
		}
	}

	var util = {
		// Throttle/debounce functions


		defaultDelay: 15,
		throttle: function (cb, context, delay) {
			// summary:
			//		Returns a function which calls the given callback at most once per
			//		delay milliseconds.  (Inspired by plugd)
			var ran = false;
			delay = delay || util.defaultDelay;
			return function () {
				if (ran) {
					return;
				}
				ran = true;
				cb.apply(context, arguments);
				setTimeout(function () {
					ran = false;
				}, delay);
			};
		},
		throttleDelayed: function (cb, context, delay) {
			// summary:
			//		Like throttle, except that the callback runs after the delay,
			//		rather than before it.
			var ran = false;
			delay = delay || util.defaultDelay;
			return function () {
				if (ran) {
					return;
				}
				ran = true;
				var a = arguments;
				setTimeout(function () {
					ran = false;
					cb.apply(context, a);
				}, delay);
			};
		},
		debounce: function (cb, context, delay) {
			// summary:
			//		Returns a function which calls the given callback only after a
			//		certain time has passed without successive calls.  (Inspired by plugd)
			var timer;
			delay = delay || util.defaultDelay;
			return function () {
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}
				var a = arguments;
				timer = setTimeout(function () {
					cb.apply(context, a);
				}, delay);
			};
		},

		// Iterative functions

		each: function (arrayOrObject, callback, context) {
			// summary:
			//		Given an array or object, iterates through its keys.
			//		Does not use hasOwnProperty (since even Dojo does not
			//		consistently use it), but will iterate using a for or for-in
			//		loop as appropriate.

			var i, len;

			if (!arrayOrObject) {
				return;
			}

			if (typeof arrayOrObject.length === 'number') {
				for (i = 0, len = arrayOrObject.length; i < len; i++) {
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}
			else {
				for (i in arrayOrObject) {
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}
		},

		// DOM-related functions

		contains: function (parent, node) {
			// summary:
			//		Checks to see if an element is contained in another element.

			if (has('dom-contains')) {
				return parent.contains(node);
			}
			else {
				return parent.compareDocumentPosition(node) & /* DOCUMENT_POSITION_CONTAINS */ 8;
			}
		},

		// CSS-related functions

		addCssRule: function (selector, css) {
			// summary:
			//		Dynamically adds a style rule to the document.  Returns an object
			//		with a remove method which can be called to later remove the rule.

			if (!extraSheet) {
				// First time, create an extra stylesheet for adding rules
				extraSheet = document.createElement('style');
				document.getElementsByTagName('head')[0].appendChild(extraSheet);
				// Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
				extraSheet = extraSheet.sheet || extraSheet.styleSheet;
				// Store name of method used to remove rules (`removeRule` for IE < 9)
				removeMethod = extraSheet.deleteRule ? 'deleteRule' : 'removeRule';
				// Store name of property used to access rules (`rules` for IE < 9)
				rulesProperty = extraSheet.cssRules ? 'cssRules' : 'rules';
			}

			var index = extraRules.length;
			extraRules[index] = (extraSheet.cssRules || extraSheet.rules).length;
			extraSheet.addRule ?
				extraSheet.addRule(selector, css) :
				extraSheet.insertRule(selector + '{' + css + '}', extraRules[index]);

			return {
				get: function (prop) {
					return extraSheet[rulesProperty][extraRules[index]].style[prop];
				},
				set: function (prop, value) {
					if (typeof extraRules[index] !== 'undefined') {
						extraSheet[rulesProperty][extraRules[index]].style[prop] = value;
					}
				},
				remove: function () {
					removeRule(index);
				}
				
			};
		},

		escapeCssIdentifier: function (id, replace) {
			// summary:
			//		Escapes normally-invalid characters in a CSS identifier (such as . or :);
			//		see http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
			// id: String
			//		CSS identifier (e.g. tag name, class, or id) to be escaped
			// replace: String?
			//		If specified, indicates that invalid characters should be
			//		replaced by the given string rather than being escaped

			return typeof id === 'string' ? id.replace(invalidCssChars, replace || '\\$1') : id;
		}
	};
	return util;
});
/** @module xide/$ **/
define('xide/$',[],function(){
    /**
     * temp. wanna be shim for jQuery
     */
    if(typeof $ !=="undefined"){
        return $;
    }
});

/** @module dgrid/List **/
define('dgrid/List',[
    'dojo/_base/declare',
    'dojo/dom-construct',
    'dojo/dom-class',
    'dojo/on',
    'dojo/has',
    './util/misc',
    'xide/$'
], function (declare, domConstruct, domClass, listen, has, miscUtil, $) {
    // Add user agent/feature CSS classes needed for structural CSS
    var featureClasses = [];
    if (has('mozilla')) {
        featureClasses.push('has-mozilla');
    }
    if (has('touch')) {
        featureClasses.push('has-touch');
    }
    domClass.add(document.documentElement, featureClasses);

    // Add a feature test for pointer (only Dojo 1.10 has pointer-events and MSPointer tests)
    has.add('pointer', function (global) {
        return 'PointerEvent' in global ? 'pointer' :
            'MSPointerEvent' in global ? 'MSPointer' : false;
    });

    var oddClass = 'dgrid-row-odd',
        evenClass = 'dgrid-row-even',
        scrollbarWidth, scrollbarHeight;

    function byId(id) {
        return document.getElementById(id);
    }

    function cleanupTestElement(element) {
        element.className = '';
        if (element.parentNode) {
            document.body.removeChild(element);
        }
    }

    function getScrollbarSize(element, dimension) {
        // Used by has tests for scrollbar width/height
        element.className = 'dgrid-scrollbar-measure';
        document.body.appendChild(element);
        var size = element['offset' + dimension] - element['client' + dimension];
        cleanupTestElement(element);
        return size;
    }

    has.add('dom-scrollbar-width', function (global, doc, element) {
        return getScrollbarSize(element, 'Width');
    });
    has.add('dom-scrollbar-height', function (global, doc, element) {
        return getScrollbarSize(element, 'Height');
    });

    has.add('dom-rtl-scrollbar-left', function (global, doc, element) {
        var div = document.createElement('div'),
            isLeft;

        element.className = 'dgrid-scrollbar-measure';
        element.setAttribute('dir', 'rtl');
        element.appendChild(div);
        document.body.appendChild(element);

        // position: absolute makes modern IE and Edge always report child's offsetLeft as 0,
        // but other browsers factor in the position of the scrollbar if it is to the left.
        // All versions of IE and Edge are known to move the scrollbar to the left side for rtl.
        isLeft = !!has('ie') || !!has('trident') || /\bEdge\//.test(navigator.userAgent) ||
            div.offsetLeft >= has('dom-scrollbar-width');
        cleanupTestElement(element);
        domConstruct.destroy(div);
        element.removeAttribute('dir');
        return isLeft;
    });

    // var and function for autogenerating ID when one isn't provided
    var autoId = 0;

    function generateId() {
        return List.autoIdPrefix + autoId++;
    }

    // common functions for class and className setters/getters
    // (these are run in instance context)
    function setClass(cls) {
        // TODO: unit test
        domClass.replace(this.domNode, cls, this._class || '');

        // Store for later retrieval/removal.
        this._class = cls;
    }

    function getClass() {
        return this._class;
    }

    // window resize event handler, run in context of List instance
    //xhack no longer needed
    //var winResizeHandler = function () {
    //	console.log('reis');
    //	if (this._started) {
    //		this.resize();
    //	}
    //};

    /**
     * Grid base class
     * @class module:dgrid/List
     */
    var List = declare(null, {
        tabableHeader: false,

        // showHeader: Boolean
        //		Whether to render header (sub)rows.
        showHeader: false,

        // showFooter: Boolean
        //		Whether to render footer area.  Extensions which display content
        //		in the footer area should set this to true.
        showFooter: false,

        // maintainOddEven: Boolean
        //		Whether to maintain the odd/even classes when new rows are inserted.
        //		This can be disabled to improve insertion performance if odd/even styling is not employed.
        maintainOddEven: true,

        // cleanAddedRules: Boolean
        //		Whether to track rules added via the addCssRule method to be removed
        //		when the list is destroyed.  Note this is effective at the time of
        //		the call to addCssRule, not at the time of destruction.
        cleanAddedRules: true,

        // addUiClasses: Boolean
        //		Whether to add jQuery UI classes to various elements in dgrid's DOM.
        addUiClasses: false,

        // highlightDuration: Integer
        //		The amount of time (in milliseconds) that a row should remain
        //		highlighted after it has been updated.
        highlightDuration: 250,

        postscript: function (params, srcNodeRef) {
            // perform setup and invoke create in postScript to allow descendants to
            // perform logic before create/postCreate happen (a la dijit/_WidgetBase)
            var grid = this;

            (this._Row = function (id, object, element) {
                this.id = id;
                this.data = object;
                this.element = element;
            }).prototype.remove = function () {
                grid.removeRow(this.element);
            };

            if (srcNodeRef) {
                // normalize srcNodeRef and store on instance during create process.
                // Doing this in postscript is a bit earlier than dijit would do it,
                // but allows subclasses to access it pre-normalized during create.
                this.srcNodeRef = srcNodeRef =
                    srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
            }
            this.create(params, srcNodeRef);
        },
        listType: 'list',

        create: function (params, srcNodeRef) {
            var domNode = this.domNode = srcNodeRef || document.createElement('div'),
                cls;

            if (params) {
                this.params = params;
                declare.safeMixin(this, params);

                // Check for initial class or className in params or on domNode
                cls = params['class'] || params.className || domNode.className;
            }

            // ensure arrays and hashes are initialized
            this.sort = this.sort || [];
            this._listeners = [];
            this._rowIdToObject = {};

            this.postMixInProperties && this.postMixInProperties();

            // Apply id to widget and domNode,
            // from incoming node, widget params, or autogenerated.
            this.id = domNode.id = domNode.id || this.id || generateId();

            // Perform initial rendering, and apply classes if any were specified.
            this.buildRendering();
            if (cls) {
                setClass.call(this, cls);
            }

            this.postCreate();

            // remove srcNodeRef instance property post-create
            delete this.srcNodeRef;
            // to preserve "it just works" behavior, call startup if we're visible
            //xhack, non of your business
            //if (this.domNode.offsetHeight) {
            //	//this.startup();
            //}
        },
        buildRendering: function () {
            var domNode = this.domNode,
                addUiClasses = this.addUiClasses,
                self = this,
                headerNode,
                bodyNode,
                footerNode,
                isRTL;

            // Detect RTL on html/body nodes; taken from dojo/dom-geometry
            isRTL = this.isRTL = (document.body.dir || document.documentElement.dir ||
                document.body.style.direction).toLowerCase() === 'rtl';

            // Clear out className (any pre-applied classes will be re-applied via the
            // class / className setter), then apply standard classes/attributes
            domNode.className = '';

            domNode.setAttribute('role', 'grid');
            domClass.add(domNode, 'dgrid dgrid-' + this.listType +
                (addUiClasses ? ' ui-widget' : ''));

            // Place header node (initially hidden if showHeader is false).
            headerNode = this.headerNode = domConstruct.create('div', {
                tabIndex: -1,
                className: 'dgrid-header dgrid-header-row' + (addUiClasses ? ' ui-widget-header' : '') +
                (this.showHeader ? '' : ' dgrid-header-hidden')
            }, domNode);

            bodyNode = this.bodyNode = domConstruct.create('div', {
                className: 'dgrid-scroller'
            }, domNode);

            // Firefox 4+ adds overflow: auto elements to the tab index by default;
            // force them to not be tabbable, but restrict this to Firefox,
            // since it breaks accessibility support in other browsers
            if (has('ff')) {
                bodyNode.tabIndex = -1;
            }

            this.headerScrollNode = domConstruct.create('div', {
                className: 'dgrid-header dgrid-header-scroll dgrid-scrollbar-width' +
                (addUiClasses ? ' widget' : '')
            }, domNode);

            // Place footer node (initially hidden if showFooter is false).
            this.footerNode = domConstruct.create('div', {
                className: 'dgrid-footer' + (this.showFooter ? '' : ' dgrid-footer-hidden')
            }, domNode);

            if (isRTL) {
                domNode.className += ' dgrid-rtl' +
                    (has('dom-rtl-scrollbar-left') ? ' dgrid-rtl-swap' : '');
            }
            listen(bodyNode, 'scroll', function (event) {
                if (self.showHeader) {
                    // keep the header aligned with the body
                    headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
                }
                // re-fire, since browsers are not consistent about propagation here
                event.stopPropagation();
                listen.emit(domNode, 'scroll', {scrollTarget: bodyNode});
            });
            this.configStructure();
            this.renderHeader();
            this.contentNode = this.touchNode = domConstruct.create('div', {
                className: 'dgrid-content' + (addUiClasses ? ' widget' : '')
            }, this.bodyNode);
        },
        startup: function () {
            // summary:
            //		Called automatically after postCreate if the component is already
            //		visible; otherwise, should be called manually once placed.

            if (this._started) {
                return;
            }
            this.inherited(arguments);
            this._started = true;
            //xhack: not needed this.resize();
            // apply sort (and refresh) now that we're ready to render
            this.set('sort', this.sort);
        },

        configStructure: function () {
            // does nothing in List, this is more of a hook for the Grid
        },
        resize: function () {
            var bodyNode = this.bodyNode,
                headerNode = this.headerNode,
                footerNode = this.footerNode,
                headerHeight = headerNode.offsetHeight,
                footerHeight = this.showFooter ? footerNode.offsetHeight : 0;

            this.headerScrollNode.style.height = bodyNode.style.marginTop = headerHeight + 'px';
            bodyNode.style.marginBottom = footerHeight + 'px';

            if (!scrollbarWidth) {
                // Measure the browser's scrollbar width using a DIV we'll delete right away
                scrollbarWidth = has('dom-scrollbar-width');
                scrollbarHeight = has('dom-scrollbar-height');

                // Avoid issues with certain widgets inside in IE7, and
                // ColumnSet scroll issues with all supported IE versions
                if (has('ie')) {
                    scrollbarWidth++;
                    scrollbarHeight++;
                }

                // add rules that can be used where scrollbar width/height is needed
                //miscUtil.addCssRule('.dgrid-scrollbar-width', 'width: ' + scrollbarWidth + 'px');
                //miscUtil.addCssRule('.dgrid-scrollbar-height', 'height: ' + scrollbarHeight + 'px');

                if (scrollbarWidth !== 17) {
                    // for modern browsers, we can perform a one-time operation which adds
                    // a rule to account for scrollbar width in all grid headers.
                    //miscUtil.addCssRule('.dgrid-header-row', 'right: ' + scrollbarWidth + 'px');
                    // add another for RTL grids
                    miscUtil.addCssRule('.dgrid-rtl-swap .dgrid-header-row', 'left: ' + scrollbarWidth + 'px');
                }
            }
        },

        addCssRule: function (selector, css) {
            // summary:
            //		Version of util/misc.addCssRule which tracks added rules and removes
            //		them when the List is destroyed.

            var rule = miscUtil.addCssRule(selector, css);
            if (this.cleanAddedRules) {
                // Although this isn't a listener, it shares the same remove contract
                this._listeners.push(rule);
            }
            return rule;
        },

        on: function (eventType, listener) {
            // delegate events to the domNode
            var signal = listen(this.domNode, eventType, listener);
            if (!has('dom-addeventlistener')) {
                this._listeners.push(signal);
            }
            return signal;
        },

        cleanup: function () {
            // summary:
            //		Clears out all rows currently in the list.

            var i;
            for (i in this._rowIdToObject) {
                if (this._rowIdToObject[i] !== this.columns) {
                    var rowElement = byId(i);
                    if (rowElement) {
                        this.removeRow(rowElement, true);
                    }
                }
            }
        },
        destroy: function () {
            // summary:
            //		Destroys this grid

            // Remove any event listeners and other such removables
            if (this._listeners) { // Guard against accidental subsequent calls to destroy
                for (var i = this._listeners.length; i--;) {
                    this._listeners[i].remove();
                }
                this._listeners = null;
            }

            this._started = false;
            this.cleanup();
            // destroy DOM
            $(this.domNode).remove();
        },
        refresh: function () {
            // summary:
            //		refreshes the contents of the grid
            this.cleanup();
            this._rowIdToObject = {};
            this._autoRowId = 0;

            // make sure all the content has been removed so it can be recreated
            $(this.contentNode).empty();
            //xhack: Ensure scroll position always resets. no, we don't! this is causing side effects in xide
            //this.scrollTo({ x: 0, y: 0 });
        },
        adjustRowIndices: function (firstRow) {
            // this traverses through rows to maintain odd/even classes on the rows when indexes shift;
            var next = firstRow;
            var rowIndex = next.rowIndex;
            if (rowIndex > -1) { // make sure we have a real number in case this is called on a non-row
                do {
                    // Skip non-numeric, non-rows
                    if (next.rowIndex > -1) {
                        if (this.maintainOddEven) {
                            if (domClass.contains(next, 'dgrid-row')) {
                                domClass.replace(next, (rowIndex % 2 === 1 ? oddClass : evenClass),
                                    (rowIndex % 2 === 0 ? oddClass : evenClass));
                            }
                        }
                        next.rowIndex = rowIndex++;
                    }
                } while ((next = next.nextSibling) && next.rowIndex !== rowIndex);
            }
        },
        renderArray: function (results, beforeNode, options) {
            // summary:
            //		Renders an array of objects as rows, before the given node.

            options = options || {};
            var self = this,
                start = options.start || 0,
                rowsFragment = document.createDocumentFragment(),
                rows = [],
                container,
                i = 0,
                len = results.length;

            if (!beforeNode) {
                this._lastCollection = results;
            }

            // Insert a row for each item into the document fragment
            while (i < len) {
                rows[i] = this.insertRow(results[i], rowsFragment, null, start++, options);
                i++;
            }

            // Insert the document fragment into the appropriate position
            container = beforeNode ? beforeNode.parentNode : self.contentNode;
            if (container && container.parentNode && (container !== self.contentNode || len)) {
                container.insertBefore(rowsFragment, beforeNode || null);
                if (len) {
                    self.adjustRowIndices(rows[len - 1]);
                }
            }

            return rows;
        },

        renderHeader: function () {
            // no-op in a plain list
        },

        _autoRowId: 0,
        insertRow: function (object, parent, beforeNode, i, options) {
            // summary:
            //		Creates a single row in the grid.

            // Include parentId within row identifier if one was specified in options.
            // (This is used by tree to allow the same object to appear under
            // multiple parents.)
            var id = this.id + '-row-' + ((this.collection && this.collection.getIdentity) ?
                        this.collection.getIdentity(object) : this._autoRowId++),
                row = byId(id),
                previousRow = row && row.previousSibling;

            if (row) {
                // If it existed elsewhere in the DOM, we will remove it, so we can recreate it
                if (row === beforeNode) {
                    beforeNode = (beforeNode.connected || beforeNode).nextSibling;
                }
                this.removeRow(row, false, options);
            }
            row = this.renderRow(object, options);
            row.className = (row.className || '') + ' dgrid-row ' + (i % 2 === 1 ? oddClass : evenClass);
            // Get the row id for easy retrieval
            this._rowIdToObject[row.id = id] = object;
            parent.insertBefore(row, beforeNode || null);

            row.rowIndex = i;
            if (previousRow && previousRow.rowIndex !== (row.rowIndex - 1)) {
                // In this case, we are pulling the row from another location in the grid,
                // and we need to readjust the rowIndices from the point it was removed
                this.adjustRowIndices(previousRow);
            }
            return row;
        },
        renderRow: function (value) {
            // summary:
            //		Responsible for returning the DOM for a single row in the grid.
            // value: Mixed
            //		Value to render
            // options: Object?
            //		Optional object with additional options

            var div = document.createElement('div');
            div.appendChild(document.createTextNode(value));
            return div;
        },
        removeRow: function (rowElement, preserveDom) {
            // summary:
            //		Simply deletes the node in a plain List.
            //		Column plugins may aspect this to implement their own cleanup routines.
            // rowElement: Object|DOMNode
            //		Object or element representing the row to be removed.
            // preserveDom: Boolean?
            //		If true, the row element will not be removed from the DOM; this can
            //		be used by extensions/plugins in cases where the DOM will be
            //		massively cleaned up at a later point in time.
            // options: Object?
            //		May be specified with a `rows` property for the purpose of
            //		cleaning up collection tracking (used by `_StoreMixin`).

            rowElement = rowElement.element || rowElement;
            delete this._rowIdToObject[rowElement.id];
            if (!preserveDom) {
                //#xhack, cleanup node data right
                $(rowElement).remove();
            }
        },

        row: function (target) {
            // summary:
            //		Get the row object by id, object, node, or event
            var id;

            if (target instanceof this._Row) {
                return target; // No-op; already a row
            }

            if (!target) {
                return null;
            }
            if (target.target && target.target.nodeType) {
                // Event
                target = target.target;
            }
            if (target.nodeType) {
                // Row element, or child of a row element
                var object;
                do {
                    var rowId = target.id;
                    if ((object = this._rowIdToObject[rowId])) {
                        return new this._Row(rowId.substring(this.id.length + 5), object, target);
                    }
                    target = target.parentNode;
                } while (target && target !== this.domNode);
                return;
            }

            if (typeof target === 'object') {
                // Assume target represents a collection item
                id = this.collection.getIdentity(target);
            }
            else {
                // Assume target is a row ID
                id = target;
                target = this._rowIdToObject[this.id + '-row-' + id];
            }
            return new this._Row(id, target, byId(this.id + '-row-' + id));
        },
        cell: function (target) {
            // this doesn't do much in a plain list
            return {
                row: this.row(target)
            };
        },

        _move: function (item, steps, targetClass, visible) {
            var nextSibling, current, element;
            // Start at the element indicated by the provided row or cell object.
            element = current = item.element;
            steps = steps || 1;

            do {
                // Outer loop: move in the appropriate direction.
                if ((nextSibling = current[steps < 0 ? 'previousSibling' : 'nextSibling'])) {
                    do {
                        // Inner loop: advance, and dig into children if applicable.
                        current = nextSibling;
                        if (current && (current.className + ' ').indexOf(targetClass + ' ') > -1) {
                            // Element with the appropriate class name; count step, stop digging.
                            element = current;
                            steps += steps < 0 ? 1 : -1;
                            break;
                        }
                        // If the next sibling isn't a match, drill down to search, unless
                        // visible is true and children are hidden.
                    } while ((nextSibling = (!visible || !current.hidden) &&
                        current[steps < 0 ? 'lastChild' : 'firstChild']));
                }
                else {
                    current = current.parentNode;
                    if (!current || current === this.bodyNode || current === this.headerNode) {
                        // Break out if we step out of the navigation area entirely.
                        break;
                    }
                }
            } while (steps);
            // Return the final element we arrived at, which might still be the
            // starting element if we couldn't navigate further in that direction.
            return element;
        },

        up: function (row, steps, visible) {
            // summary:
            //		Returns the row that is the given number of steps (1 by default)
            //		above the row represented by the given object.
            // row:
            //		The row to navigate upward from.
            // steps:
            //		Number of steps to navigate up from the given row; default is 1.
            // visible:
            //		If true, rows that are currently hidden (i.e. children of
            //		collapsed tree rows) will not be counted in the traversal.
            // returns:
            //		A row object representing the appropriate row.  If the top of the
            //		list is reached before the given number of steps, the first row will
            //		be returned.
            if (!row.element) {
                row = this.row(row);
            }
            return this.row(this._move(row, -(steps || 1), 'dgrid-row', visible));
        },
        down: function (row, steps, visible) {
            // summary:
            //		Returns the row that is the given number of steps (1 by default)
            //		below the row represented by the given object.
            // row:
            //		The row to navigate downward from.
            // steps:
            //		Number of steps to navigate down from the given row; default is 1.
            // visible:
            //		If true, rows that are currently hidden (i.e. children of
            //		collapsed tree rows) will not be counted in the traversal.
            // returns:
            //		A row object representing the appropriate row.  If the bottom of the
            //		list is reached before the given number of steps, the last row will
            //		be returned.
            if (!row.element) {
                row = this.row(row);
            }
            return this.row(this._move(row, steps || 1, 'dgrid-row', visible));
        },

        scrollTo: function (options) {
            if (typeof options.x !== 'undefined') {
                this.bodyNode.scrollLeft = options.x;
            }
            if (typeof options.y !== 'undefined') {
                this.bodyNode.scrollTop = options.y;
            }
        },

        getScrollPosition: function () {
            return {
                x: this.bodyNode.scrollLeft,
                y: this.bodyNode.scrollTop
            };
        },

        get: function (/*String*/ name /*, ... */) {
            // summary:
            //		Get a property on a List instance.
            //	name:
            //		The property to get.
            //	returns:
            //		The property value on this List instance.
            // description:
            //		Get a named property on a List object. The property may
            //		potentially be retrieved via a getter method in subclasses. In the base class
            //		this just retrieves the object's property.

            var fn = '_get' + name.charAt(0).toUpperCase() + name.slice(1);

            if (typeof this[fn] === 'function') {
                return this[fn].apply(this, [].slice.call(arguments, 1));
            }
            return this[name];
        },

        set: function (/*String*/ name, /*Object*/ value /*, ... */) {
            //	summary:
            //		Set a property on a List instance
            //	name:
            //		The property to set.
            //	value:
            //		The value to set in the property.
            //	returns:
            //		The function returns this List instance.
            //	description:
            //		Sets named properties on a List object.
            //		A programmatic setter may be defined in subclasses.
            //
            //		set() may also be called with a hash of name/value pairs, ex:
            //	|	myObj.set({
            //	|		foo: "Howdy",
            //	|		bar: 3
            //	|	})
            //		This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

            if (typeof name === 'object') {
                for (var k in name) {
                    this.set(k, name[k]);
                }
            }
            else {
                var fn = '_set' + name.charAt(0).toUpperCase() + name.slice(1);
                if (typeof this[fn] === 'function') {
                    this[fn].apply(this, [].slice.call(arguments, 1));
                }
                else {
                    this[name] = value;
                }
            }

            return this;
        },

        // Accept both class and className programmatically to set domNode class.
        _getClass: getClass,
        _setClass: setClass,
        _getClassName: getClass,
        _setClassName: setClass,

        _setSort: function (property, descending) {
            // summary:
            //		Sort the content
            // property: String|Array
            //		String specifying field to sort by, or actual array of objects
            //		with property and descending properties
            // descending: boolean
            //		In the case where property is a string, this argument
            //		specifies whether to sort ascending (false) or descending (true)

            this.sort = typeof property !== 'string' ? property :
                [{property: property, descending: descending}];

            this._applySort();
        },

        _applySort: function () {
            // summary:
            //		Applies the current sort
            // description:
            //		This is an extension point to allow specializations to apply the sort differently

            this.refresh();

            if (this._lastCollection) {
                var sort = this.sort;
                if (sort && sort.length > 0) {
                    var property = sort[0].property,
                        descending = !!sort[0].descending;
                    this._lastCollection.sort(function (a, b) {
                        var aVal = a[property], bVal = b[property];
                        // fall back undefined values to "" for more consistent behavior
                        if (aVal === undefined) {
                            aVal = '';
                        }
                        if (bVal === undefined) {
                            bVal = '';
                        }
                        return aVal === bVal ? 0 : (aVal > bVal !== descending ? 1 : -1);
                    });
                }
                this.renderArray(this._lastCollection);
            }
        },

        _setShowHeader: function (show) {
            // this is in List rather than just in Grid, primarily for two reasons:
            // (1) just in case someone *does* want to show a header in a List
            // (2) helps address IE < 8 header display issue in List

            var headerNode = this.headerNode;

            this.showHeader = show;

            // add/remove class which has styles for "hiding" header
            domClass.toggle(headerNode, 'dgrid-header-hidden', !show);

            this.renderHeader();
            this.resize(); // resize to account for (dis)appearance of header

            if (show) {
                // Update scroll position of header to make sure it's in sync.
                headerNode.scrollLeft = this.getScrollPosition().x;
            }
        },

        _setShowFooter: function (show) {
            this.showFooter = show;

            // add/remove class which has styles for hiding footer
            domClass.toggle(this.footerNode, 'dgrid-footer-hidden', !show);

            this.resize(); // to account for (dis)appearance of footer
        }
    });

    List.autoIdPrefix = 'dgrid_';

    return List;
});

define('dgrid/Grid',[
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/has',
	'./List',
	'./util/misc',
	'dojo/_base/sniff'
], function (declare, lang, domConstruct, domClass, listen, has, List, miscUtil) {
	function appendIfNode(parent, subNode) {
		if (subNode && subNode.nodeType) {
			parent.appendChild(subNode);
		}
	}

	function replaceInvalidChars(str) {
		// Replaces invalid characters for a CSS identifier with hyphen,
		// as dgrid does for field names / column IDs when adding classes.
		return miscUtil.escapeCssIdentifier(str, '-');
	}

	var Grid = declare(List, {
		columns: null,

		// hasNeutralSort: Boolean
		//		Determines behavior of toggling sort on the same column.
		//		If false, sort toggles between ascending and descending and cannot be
		//		reset to neutral without sorting another column.
		//		If true, sort toggles between ascending, descending, and neutral.
		hasNeutralSort: false,

		// cellNavigation: Boolean
		//		This indicates that focus is at the cell level. This may be set to false to cause
		//		focus to be at the row level, which is useful if you want only want row-level
		//		navigation.
		cellNavigation: true,

		tabableHeader: true,
		showHeader: true,
		column: function (target) {
			// summary:
			//		Get the column object by node, or event, or a columnId
			if (typeof target !== 'object') {
				return this.columns[target];
			}
			else {
				return this.cell(target).column;
			}
		},
		listType: 'grid',
		cell: function (target, columnId) {
			// summary:
			//		Get the cell object by node, or event, id, plus a columnId

			if (target.column && target.element) {
				return target;
			}

			if (target.target && target.target.nodeType) {
				// event
				target = target.target;
			}
			var element;
			if (target.nodeType) {
				do {
					if (this._rowIdToObject[target.id]) {
						break;
					}
					var colId = target.columnId;
					if (colId) {
						columnId = colId;
						element = target;
						break;
					}
					target = target.parentNode;
				} while (target && target !== this.domNode);
			}
			if (!element && typeof columnId !== 'undefined') {
				var row = this.row(target),
					rowElement = row && row.element;
				if (rowElement) {
					var elements = rowElement.getElementsByTagName('td');
					for (var i = 0; i < elements.length; i++) {
						if (elements[i].columnId === columnId) {
							element = elements[i];
							break;
						}
					}
				}
			}
			if (target != null) {
				return {
					row: row || this.row(target),
					column: columnId && this.column(columnId),
					element: element
				};
			}
		},

		createRowCells: function (tag, createCell, subRows, item, options) {
			// summary:
			//		Generates the grid for each row (used by renderHeader and and renderRow)
			var row = domConstruct.create('table', {
					className: 'dgrid-row-table',
					role: 'presentation'
				}),
				// IE < 9 needs an explicit tbody; other browsers do not
				tbody = (has('ie') < 9) ? domConstruct.create('tbody', null, row) : row,
				tr,
				si, sl, i, l, // iterators
				subRow, column, id, extraClasses, className,
				cell, colSpan, rowSpan; // used inside loops

			// Allow specification of custom/specific subRows, falling back to
			// those defined on the instance.
			subRows = subRows || this.subRows;

			for (si = 0, sl = subRows.length; si < sl; si++) {
				subRow = subRows[si];
				// for single-subrow cases in modern browsers, TR can be skipped
				// http://jsperf.com/table-without-trs
				tr = domConstruct.create('tr', null, tbody);
				if (subRow.className) {
					tr.className = subRow.className;
				}

				for (i = 0, l = subRow.length; i < l; i++) {
					// iterate through the columns
					column = subRow[i];
					id = column.id;

					extraClasses = column.field ?
						' field-' + replaceInvalidChars(column.field) :
						'';
					className = typeof column.className === 'function' ?
						column.className(item) : column.className;
					if (className) {
						extraClasses += ' ' + className;
					}

					cell = domConstruct.create(tag, {
						className: 'dgrid-cell' +
							(id ? ' dgrid-column-' + replaceInvalidChars(id) : '') + extraClasses,
						role: tag === 'th' ? 'columnheader' : 'gridcell'
					});
					cell.columnId = id;
					colSpan = column.colSpan;
					if (colSpan) {
						cell.colSpan = colSpan;
					}
					rowSpan = column.rowSpan;
					if (rowSpan) {
						cell.rowSpan = rowSpan;
					}
					createCell(cell, column, item, options);
					// add the td to the tr at the end for better performance
					tr.appendChild(cell);
				}
			}
			return row;
		},

		_createBodyRowCell: function (cellElement, column, item, options) {
			var cellData = item;

			// Support get function or field property (similar to DataGrid)
			if (column.get) {
				cellData = column.get(item);
			}
			else if ('field' in column && column.field !== '_item') {
				cellData = item[column.field];
			}

			if (column.renderCell) {
				// A column can provide a renderCell method to do its own DOM manipulation,
				// event handling, etc.
				appendIfNode(cellElement, column.renderCell(item, cellData, cellElement, options));
			}
			else {
				this._defaultRenderCell.call(column, item, cellData, cellElement, options);
			}
		},

		_createHeaderRowCell: function (cellElement, column) {
			var contentNode = column.headerNode = cellElement;
			var field = column.field;
			if (field) {
				cellElement.field = field;
			}
			// allow for custom header content manipulation
			if (column.renderHeaderCell) {
				appendIfNode(contentNode, column.renderHeaderCell(contentNode));
			}
			else if ('label' in column || column.field) {
				contentNode.appendChild(document.createTextNode(
					'label' in column ? column.label : column.field));
			}
			if (column.sortable !== false && field && field !== '_item') {
				cellElement.sortable = true;
				cellElement.className += ' dgrid-sortable';
			}
		},

		left: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			return this.cell(this._move(cell, -(steps || 1), 'dgrid-cell'));
		},
		right: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			return this.cell(this._move(cell, steps || 1, 'dgrid-cell'));
		},

		_defaultRenderCell: function (object, value, td) {
			// summary:
			//		Default renderCell implementation.
			//		NOTE: Called in context of column definition object.
			// object: Object
			//		The data item for the row currently being rendered
			// value: Mixed
			//		The value of the field applicable to the current cell
			// td: DOMNode
			//		The cell element representing the current item/field
			// options: Object?
			//		Any additional options passed through from renderRow

			if (this.formatter) {
				// Support formatter, with or without formatterScope
				var formatter = this.formatter,
					formatterScope = this.grid.formatterScope;
				td.innerHTML = typeof formatter === 'string' && formatterScope ?
					formatterScope[formatter](value, object) : this.formatter(value, object);
			}
			else if (value != null) {
				td.appendChild(document.createTextNode(value));
			}
		},

		renderRow: function (item, options) {
			var row = this.createRowCells('td', lang.hitch(this, '_createBodyRowCell'),
				options && options.subRows, item, options);

			// row gets a wrapper div for a couple reasons:
			// 1. So that one can set a fixed height on rows (heights can't be set on <table>'s AFAICT)
			// 2. So that outline style can be set on a row when it is focused,
			// and Safari's outline style is broken on <table>
			var div = domConstruct.create('div', { role: 'row' });
			div.appendChild(row);
			return div;
		},

		renderHeader: function () {
			// summary:
			//		Setup the headers for the grid
			var grid = this,
				headerNode = this.headerNode;

			headerNode.setAttribute('role', 'row');

			// clear out existing header in case we're resetting
			domConstruct.empty(headerNode);

			var row = this.createRowCells('th', lang.hitch(this, '_createHeaderRowCell'),
				this.subRows && this.subRows.headerRows);
			this._rowIdToObject[row.id = this.id + '-header'] = this.columns;
			headerNode.appendChild(row);

			// If the columns are sortable, re-sort on clicks.
			// Use a separate listener property to be managed by renderHeader in case
			// of subsequent calls.
			if (this._sortListener) {
				this._sortListener.remove();
			}
			this._sortListener = listen(row, 'click,keydown', function (event) {
				// respond to click, space keypress, or enter keypress
				if (event.type === 'click' || event.keyCode === 32 ||
						(!has('opera') && event.keyCode === 13)) {
					var target = event.target;
					var field;
					var sort;
					var newSort;
					var eventObj;

					do {
						if (target.sortable) {
							field = target.field || target.columnId;
							sort = grid.sort[0];
							if (!grid.hasNeutralSort || !sort || sort.property !== field || !sort.descending) {
								// If the user toggled the same column as the active sort,
								// reverse sort direction
								newSort = [{
									property: field,
									descending: sort && sort.property === field &&
										!sort.descending
								}];
							}
							else {
								// If the grid allows neutral sort and user toggled an already-descending column,
								// clear sort entirely
								newSort = [];
							}

							// Emit an event with the new sort
							eventObj = {
								bubbles: true,
								cancelable: true,
								grid: grid,
								parentType: event.type,
								sort: newSort
							};

							if (listen.emit(event.target, 'dgrid-sort', eventObj)) {
								// Stash node subject to DOM manipulations,
								// to be referenced then removed by sort()
								grid._sortNode = target;
								grid.set('sort', newSort);
							}

							break;
						}
					} while ((target = target.parentNode) && target !== headerNode);
				}
			});
		},

		resize: function () {
			// extension of List.resize to allow accounting for
			// column sizes larger than actual grid area
			if(!this.headerNode){
				return;
			}
			var headerTableNode = this.headerNode.firstChild,
				contentNode = this.contentNode,
				width;

			this.inherited(arguments);

			// Force contentNode width to match up with header width.
			contentNode.style.width = ''; // reset first
			if (contentNode && headerTableNode) {
				if ((width = headerTableNode.offsetWidth) > contentNode.offsetWidth) {
					// update size of content node if necessary (to match size of rows)
					// (if headerTableNode can't be found, there isn't much we can do)
					contentNode.style.width = width + 'px';
				}
			}
		},

		destroy: function () {
			// Run _destroyColumns first to perform any column plugin tear-down logic.
			this._destroyColumns();
			if (this._sortListener) {
				this._sortListener.remove();
			}

			this.inherited(arguments);
		},

		_setSort: function () {
			// summary:
			//		Extension of List.js sort to update sort arrow in UI

			// Normalize sort first via inherited logic, then update the sort arrow
			this.inherited(arguments);
			this.updateSortArrow(this.sort);
		},

		_findSortArrowParent: function (field) {
			// summary:
			//		Method responsible for finding cell that sort arrow should be
			//		added under.  Called by updateSortArrow; separated for extensibility.

			var columns = this.columns;
			for (var i in columns) {
				var column = columns[i];
				if (column.field === field) {
					return column.headerNode;
				}
			}
		},

		updateSortArrow: function (sort, updateSort) {
			// summary:
			//		Method responsible for updating the placement of the arrow in the
			//		appropriate header cell.  Typically this should not be called (call
			//		set("sort", ...) when actually updating sort programmatically), but
			//		this method may be used by code which is customizing sort (e.g.
			//		by reacting to the dgrid-sort event, canceling it, then
			//		performing logic and calling this manually).
			// sort: Array
			//		Standard sort parameter - array of object(s) containing property name
			//		and optional descending flag
			// updateSort: Boolean?
			//		If true, will update this.sort based on the passed sort array
			//		(i.e. to keep it in sync when custom logic is otherwise preventing
			//		it from being updated); defaults to false

			// Clean up UI from any previous sort
			if (this._lastSortedArrow) {
				// Remove the sort classes from the parent node
				domClass.remove(this._lastSortedArrow.parentNode, 'dgrid-sort-up dgrid-sort-down');
				// Destroy the lastSortedArrow node
				domConstruct.destroy(this._lastSortedArrow);
				delete this._lastSortedArrow;
			}

			if (updateSort) {
				this.sort = sort;
			}
			if (!sort[0]) {
				return; // Nothing to do if no sort is specified
			}

			var prop = sort[0].property,
				desc = sort[0].descending,
				// if invoked from header click, target is stashed in _sortNode
				target = this._sortNode || this._findSortArrowParent(prop),
				arrowNode;

			delete this._sortNode;

			// Skip this logic if field being sorted isn't actually displayed
			if (target) {
				target = target.contents || target;
				// Place sort arrow under clicked node, and add up/down sort class
				arrowNode = this._lastSortedArrow = domConstruct.create('div', {
					className: 'dgrid-sort-arrow ui-icon',
					innerHTML: '&nbsp;',
					role: 'presentation'
				}, target, 'first');
				domClass.add(target, 'dgrid-sort-' + (desc ? 'down' : 'up'));
				// Call resize in case relocation of sort arrow caused any height changes
				this.resize();
			}
		},

		styleColumn: function (colId, css) {
			// summary:
			//		Dynamically creates a stylesheet rule to alter a column's style.

			return this.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) +
				' .dgrid-column-' + replaceInvalidChars(colId), css);
		},

		/*=====
		_configColumn: function (column, rowColumns, prefix) {
			// summary:
			//		Method called when normalizing base configuration of a single
			//		column.  Can be used as an extension point for behavior requiring
			//		access to columns when a new configuration is applied.
		},=====*/

		_configColumns: function (prefix, rowColumns) {
			// configure the current column
			var subRow = [],
				isArray = rowColumns instanceof Array;

			function configColumn(column, columnId) {
				if (typeof column === 'string') {
					rowColumns[columnId] = column = { label: column };
				}
				if (!isArray && !column.field) {
					column.field = columnId;
				}
				columnId = column.id = column.id || (isNaN(columnId) ? columnId : (prefix + columnId));
				// allow further base configuration in subclasses
				if (this._configColumn) {
					this._configColumn(column, rowColumns, prefix);
					// Allow the subclasses to modify the column id.
					columnId = column.id;
				}
				if (isArray) {
					this.columns[columnId] = column;
				}

				// add grid reference to each column object for potential use by plugins
				column.grid = this;
				subRow.push(column); // make sure it can be iterated on
			}

			miscUtil.each(rowColumns, configColumn, this);
			return isArray ? rowColumns : subRow;
		},

		_destroyColumns: function () {
			// summary:
			//		Extension point for column-related cleanup.  This is called
			//		immediately before configuring a new column structure,
			//		and when the grid is destroyed.

			// First remove rows (since they'll be refreshed after we're done),
			// so that anything temporarily extending removeRow can run.
			// (cleanup will end up running again, but with nothing to iterate.)
			this.cleanup();
		},

		configStructure: function () {
			// configure the columns and subRows
			var subRows = this.subRows,
				columns = this._columns = this.columns;

			// Reset this.columns unless it was already passed in as an object
			this.columns = !columns || columns instanceof Array ? {} : columns;

			if (subRows) {
				// Process subrows, which will in turn populate the this.columns object
				for (var i = 0; i < subRows.length; i++) {
					subRows[i] = this._configColumns(i + '-', subRows[i]);
				}
			}
			else {
				this.subRows = [this._configColumns('', columns)];
			}
		},

		_getColumns: function () {
			// _columns preserves what was passed to set("columns"), but if subRows
			// was set instead, columns contains the "object-ified" version, which
			// was always accessible in the past, so maintain that accessibility going
			// forward.
			return this._columns || this.columns;
		},
		_setColumns: function (columns) {
			this._destroyColumns();
			// reset instance variables
			this.subRows = null;
			this.columns = columns;
			// re-run logic
			this._updateColumns();
		},

		_setSubRows: function (subrows) {
			this._destroyColumns();
			this.subRows = subrows;
			this._updateColumns();
		},

		_updateColumns: function () {
			// summary:
			//		Called when columns, subRows, or columnSets are reset

			this.configStructure();
			this.renderHeader();

			this.refresh();
			// re-render last collection if present
			this._lastCollection && this.renderArray(this._lastCollection);

			// After re-rendering the header, re-apply the sort arrow if needed.
			if (this._started) {
				if (this.sort.length) {
					this._lastSortedArrow = null;
					this.updateSortArrow(this.sort);
				} else {
					// Only call resize directly if we didn't call updateSortArrow,
					// since that calls resize itself when it updates.
					this.resize();
				}
			}
		}
	});

	Grid.appendIfNode = appendIfNode;

	return Grid;
});

/** @module xgrid/ListRenderer **/
define('xgrid/ListRenderer',[
    "xdojo/declare",
    'xide/types',
    './Renderer',
    'dojo/dom-construct',
    'dgrid/Grid'
], function (declare,types,Renderer,domConstruct,Grid) {

    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xgrid/ListRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {

        _getLabel:function(){ return "List"; },
        _getIcon:function(){ return "fa-th-list"; },
        activateRenderer:function(renderer){
            this._showHeader(true);
        },
        deactivateRenderer:function(renderer){},
        _configColumns: function () {
            return Grid.prototype._configColumns.apply(this, arguments);
        },
        insertRow:function(object,options) {
            return Grid.prototype.insertRow.apply(this, arguments);
        },
        renderRow:function(object,options){

            var self = this;
            var row = this.createRowCells('td', function (td, column) {
                var data = object;
                // Support get function or field property (similar to DataGrid)
                if (column.get) {
                    data = column.get(object);
                }
                else if ('field' in column && column.field !== '_item') {
                    data = data[column.field];
                }
                self._defaultRenderCell.call(column, object, data, td, options);
            }, options && options.subRows, object);
            // row gets a wrapper div for a couple reasons:
            // 1. So that one can set a fixed height on rows (heights can't be set on <table>'s AFAICT)
            // 2. So that outline style can be set on a row when it is focused,
            // and Safari's outline style is broken on <table>
            var div = domConstruct.create('div', { role: 'row' });
            div.appendChild(row);
            return div;
        }
    };

    //package via declare
    var _class = declare('xgrid.ListRenderer',[Renderer],Implementation);
    _class.Implementation = Implementation;

    return _class;
});
define('xide/utils',[
    "dcl/dcl"
], function (dcl) {
    return dcl(null, {
        declaredClass:"xide.utils"
    });
});
/** @module xide/types
 *  @description All the package's constants and enums in C style structures.
 */
define('xide/types/Types',[
    'dojo/_base/lang',
    'xide/types',
    'dojo/_base/json',
    'dojo/_base/kernel',
    'xide/utils'
], function (lang, types, json, dojo,utils) {
    /**
     * @TODO:
     * - apply xide/registry for types
     * - move mime handling to xfile
     * - remove ui types
     * - remove all other things which are part of ui or server only
     */
    /**
     * Custom CI Types, see ECITYPE enumeration. Each enum is mapped to a widget.
     */
    if (types['customTypes'] == null) {
        types['customTypes'] = {};
    }
    /**
     * ECTYPE_ENUM is mapped to and label-value option array
     */
    if (types['customEnumerations'] == null) {
        types['customEnumerations'] = {};
    }
    /**
     * The actual mapping of custom types to widget proto classes
     */
    if (types['widgetMappings'] == null) {
        types['widgetMappings'] = {};
    }
    /**
     * Mixes in new mime icons per ECITYPE & file extensions. Rendered by FontAwesome
     */
    if (types['customMimeIcons'] == null) {
        types['customMimeIcons'] = {};
    }
    /**
     * CI Render callbacks
     */
    if (types['CICallbacks'] == null) {
        types['CICallbacks'] = {};
    }
    /**
     * Public ECI_TYPE registry getter
     * @param type
     * @returns {*}
     */
    types.resolveType = function (type) {
        if (types['customTypes'][type]) {
            return types['customTypes'][type];
        }
        return null;
    };
    /**
     * Public ECI_TYPE registry setter
     * @param type
     * @param map
     */
    types.registerType = function (type, map) {
        types['customTypes'][type] = map;
    };
    /**
     * Public widget-type registry setter
     * @param type
     * @param map
     */
    types.registerWidgetMapping = function (type, map) {
        types['widgetMappings'][type] = map;
    };
    /**
     * Public custom enum registry setter
     * @param type
     * @param map
     */
    types.registerEnumeration = function (type, map) {
        types['customEnumerations'][type] = map;
    };
    /**
     * Public custom enumeration registry getter
     * @param type
     */
    types.resolveEnumeration = function (type) {
        if (types['customEnumerations'][type]) {
            return types['customEnumerations'][type];
        }
        return null;
    };
    /**
     * Public type-widget mapping registry setter
     * @param type
     */
    types.resolveWidgetMapping = function (type) {
        if (types['widgetMappings'][type]) {
            return types['widgetMappings'][type];
        }
        return null;
    };

    types.registerCICallbacks = function (type,callbacks) {
        if (!types['CICallbacks'][type]) {
            types['CICallbacks'][type] = {}
        }
        utils.mixin(types['CICallbacks'][type],callbacks);
        return null;
    };
    types.getCICallbacks = function (type) {
        if (types['CICallbacks'][type]){
            return types['CICallbacks'][type];
        }
        return null;
    };

    types.GRID_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    
    types.VIEW_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    
    types.KEYBOARD_PROFILE = {
        DEFAULT: {
            prevent_default: true,
            prevent_repeat: false
        },
        PASS_THROUGH: {
            prevent_default: false,
            prevent_repeat: false
        },
        SEQUENCE: {
            prevent_default: true,
            is_sequence: true,
            prevent_repeat: true
        }
    };
    /////////////////////////////////////////////////////////////////////////////
    //
    // CORE TYPES
    //
    /////////////////////////////////////////////////////////////////////////////
    /**
     * A 'Configurable Information's ("CI") processing state during post or pre-processing.
     *
     * @enum {int} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_STATE = {
        /**
         * Nothing done, could also mean there is nothing to do all
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * In pending state. At that time the compiler has accepted additional work and ci flag processing is queued
         * but not scheduled yet.
         * @constant
         * @type int
         */
        PENDING: 0x00000001,
        /**
         * The processing state.
         * @constant
         * @type int
         */
        PROCESSING: 0x00000002,
        /**
         * The CI has been processed but it failed.
         * @constant
         * @type int
         */
        FAILED: 0x00000004,
        /**
         * The CI was successfully processed.
         * @constant
         * @type int
         */
        SUCCESSED: 0x00000008,
        /**
         * The CI has been processed.
         * @constant
         * @type int
         */
        PROCESSED: 0x00000010,
        /**
         * The CI left the post/pre processor entirly but has not been accepted by the originating source.
         * This state can happen when the source became invalid and so its sort of orphan.
         * @constant
         * @type int
         */
        DEQUEUED: 0x00000020,
        /**
         * The CI fully resolved and no references except by the source are around.
         * @constant
         * @type int
         */
        SOLVED: 0x00000040,
        /**
         * Flag to mark the core's end of this bitmask, from here its user land
         * @constant
         * @type int
         */
        END: 0x00000080
    };
    /**
     * A 'Configurable Information's ("CI") type flags for post and pre-processing a value.
     * @enum {string} CIFLAGS
     * @global
     * @memberOf module:xide/types
     */
    types.CIFLAG = {
        /**
         * Instruct for no additional extra processing
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Will instruct the pre/post processor to base-64 decode or encode
         * @constant
         * @type int
         */
        BASE_64: 0x00000001,
        /**
         * Post/Pre process the value with a user function
         * @constant
         * @type int
         */
        USE_FUNCTION: 0x00000002,
        /**
         * Replace variables with local scope's variables during the post/pre process
         * @constant
         * @type int
         */
        REPLACE_VARIABLES: 0x00000004,
        /**
         * Replace variables with local scope's variables during the post/pre process but evaluate the whole string
         * as Javascript
         * @constant
         * @type int
         */
        REPLACE_VARIABLES_EVALUATED: 0x00000008,
        /**
         * Will instruct the pre/post processor to escpape evaluated or replaced variables or expressions
         * @constant
         * @type int
         */
        ESCAPE: 0x00000010,
        /**
         * Will instruct the pre/post processor to replace block calls with oridinary vanilla script
         * @constant
         * @type int
         */
        REPLACE_BLOCK_CALLS: 0x00000020,
        /**
         * Will instruct the pre/post processor to remove variable delimitters/placeholders from the final string
         * @constant
         * @type int
         */
        REMOVE_DELIMTTERS: 0x00000040,
        /**
         * Will instruct the pre/post processor to remove   "[" ,"]" , "(" , ")" , "{", "}" , "*" , "+" , "."
         * @constant
         * @type int
         */
        ESCAPE_SPECIAL_CHARS: 0x00000080,
        /**
         * Will instruct the pre/post processor to use regular expressions over string substitution
         * @constant
         * @type int
         */
        USE_REGEX: 0x00000100,
        /**
         * Will instruct the pre/post processor to use Filtrex (custom bison parser, needs xexpression) over string substitution
         * @constant
         * @type int
         */
        USE_FILTREX: 0x00000200,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        CASCADE: 0x00000400,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        EXPRESSION: 0x00000800,
        /**
         * Dont parse anything
         * @constant
         * @type int
         */
        DONT_PARSE: 0x000001000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        TO_HEX: 0x000002000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        REPLACE_HEX: 0x000004000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        WAIT: 0x000008000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        DONT_ESCAPE: 0x000010000,
        /**
         * Flag to mark the maximum core bit mask, after here its user land
         * @constant
         * @type int
         */
        END: 0x000020000
    };
    /**
     * A CI's default post-pre processing order.
     *
     * @enum {string} module:xide/types/CI_ORDER
     * @memberOf module:xide/types
     */
    types.CI_CORDER = {};

    /**
     * A 'Configurable Information's ("CI") type information. Every CI has this information. You can
     * re-composite new types with ECIType.STRUCTURE. However all 'beans' (rich objects) in the system all displayed through a set of CIs,
     * also called the CIS (Configurable Information Set). There are many types already :
     *
     * Each ECIType has mapped widgets, BOOL : checkbox, STRING: Text-Areay and so forth.
     *
     * @enum {string} module:xide/types/ECIType
     * @memberOf module:xide/types
     */
    types.ECIType = {
        /**
         * @const
         * @type { int}
         */
        BOOL: 0,
        /**
         * @const
         * @type { int}
         */
        BOX: 1,
        /**
         * @const
         * @type { int}
         */
        COLOUR: 2,
        /**
         * @const
         * @type { int}
         */
        ENUMERATION: 3,
        /**
         * @const
         * @type { int}
         */
        FILE: 4,
        /**
         * @const
         * @type { int}
         */
        FLAGS: 5,
        /**
         * @const
         * @type { int}
         */
        FLOAT: 6,
        /**
         * @const
         * @type { int}
         */
        INTEGER: 7,
        /**
         * @const
         * @type { int}
         */
        MATRIX: 8,
        /**
         * @const
         * @type { int}
         */
        OBJECT: 9,
        /**
         * @const
         * @type { int}
         */
        REFERENCE: 10,
        /**
         * @const
         * @type { int}
         */
        QUATERNION: 11,
        /**
         * @const
         * @type { int}
         */
        RECTANGLE: 12,
        /**
         * @const
         * @type { int}
         */
        STRING: 13,
        /**
         * @const
         * @type { int}
         */
        VECTOR: 14,
        /**
         * @const
         * @type { int}
         */
        VECTOR2D: 15,
        /**
         * @const
         * @type { int}
         */
        VECTOR4D: 16,
        /**
         * @const
         * @type { int}
         */
        ICON: 17,
        /**
         * @const
         * @type { int}
         */
        IMAGE: 18,
        /**
         * @const
         * @type { int}
         */
        BANNER: 19,
        /**
         * @const
         * @type { int}
         */
        LOGO: 20,
        /**
         * @const
         * @type { int}
         */
        STRUCTURE: 21,
        /**
         * @const
         * @type { int}
         */
        BANNER2: 22,
        /**
         * @const
         * @type { int}
         */
        ICON_SET: 23,
        /**
         * @const
         * @type { int}
         */
        SCRIPT: 24,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION: 25,
        /**
         * @const
         * @type { int}
         */
        RICHTEXT: 26,
        /**
         * @const
         * @type { int}
         */
        ARGUMENT: 27,
        /**
         * @const
         * @type { int}
         */
        JSON_DATA: 28,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION_EDITOR: 29,
        /**
         * @const
         * @type { int}
         */
        WIDGET_REFERENCE: 30,
        /**
         * @const
         * @type { int}
         */
        DOM_PROPERTIES: 31,

        /**
         * @const
         * @type { int}
         */
        BLOCK_REFERENCE: 32,

        /**
         * @const
         * @type { int}
         */
        BLOCK_SETTINGS: 33,
        /**
         * @const
         * @type { int}
         */
        FILE_EDITOR: 34,
        /**
         * @const
         * @type { int}
         */
        END: 35,
        /**
         * @const
         * @type { int}
         */
        UNKNOWN: -1
    };
    /**
     * Dummy type for jsdoc
     * @typedef {Object} module:xide/types/ConfigurableInformation
     * @property {String} id
     * @property {String} name
     * @property {module:xide/types/ECIType} type
     */
    /**
     * Stub for registered bean types. This value is needed to let the UI switch between configurations per such type.
     * At the very root is the bean action context which may include more contexts.
     * @enum {string} module:xide/types/ITEM_TYPE
     * @memberOf module:xide/types
     */
    types.ITEM_TYPE = {
        /**
         * Bean type 'file' is handled by the xfile package
         * @constant
         */
        FILE: 'BTFILE',         //file object
        /**
         * Bean type 'widget' is handled by the xide/ve and davinci package
         * @constant
         */
        WIDGET: 'WIDGET',       //ui designer
        /**
         * Bean type 'block' is handled by the xblox package
         * @constant
         */
        BLOCK: 'BLOCK',         //xblox
        /**
         * Bean type 'text' is used for text editors
         * @constant
         */
        TEXT: 'TEXT',           //xace
        /**
         * Bean type 'xexpression' is used for user expressions
         * @constant
         */
        EXPRESSION: 'EXPRESSION'       //xexpression
    };

    /**
     * Expression Parser is a map of currently existing parsers
     * and might be extended by additional modules. Thus, it acts as registry
     * and is here as stub.
     *
     * @enum module:xide/types/EXPRESSION_PARSER
     * @memberOf module:xide/types
     */
    if (!types.EXPRESSION_PARSER) {
        types.EXPRESSION_PARSER = {};
    }
    /**
     * Component names stub, might be extended by sub-classing applications
     * @constant xide.types.COMPONENT_NAMES
     */
    types.COMPONENT_NAMES = {
        XIDEVE: 'xideve',
        XNODE: 'xnode',
        XBLOX: 'xblox',
        XFILE: 'xfile',
        XACE: 'xace',
        XEXPRESSION: 'xexpression',
        XCONSOLE: 'xconsole',
        XTRACK: 'xtrack'
    };

    /**
     * WIDGET_REFERENCE_MODE enumerates possible modes to resolve a string expression
     * into instances. There are a few CI based widgets subclassed from xide/widgets/Referenced.
     * The reference structure consist out of this mode and that expression.
     *
     * @constant {Array.<module:xide/types~WidgetReferenceMode>}
     *     module:xide/types~WIDGET_REFERENCE_MODE
     */
    types.WIDGET_REFERENCE_MODE = {
        BY_ID: 'byid',
        BY_CLASS: 'byclass',
        BY_CSS: 'bycss',
        BY_EXPRESSION: 'expression'
    };
    /**
     * Possible split modes for rich editors with preview or live coding views.
     *
     * @constant {Array.<module:xide/types~ViewSplitMode>}
     *     module:xide/types~VIEW_SPLIT_MODE
     */
    types.VIEW_SPLIT_MODE = {
        DESIGN: 1,
        SOURCE: 2,
        SPLIT_VERTICAL: 6,
        SPLIT_HORIZONTAL: 7
    };
    /**
     * All client resources are through variables on the server side. Here the minimum variables for an xjs application.
     *
     * @constant {Array.<module:xide/types~RESOURCE_VARIABLES>}
     *     module:xide/types~RESOURCE_VARIABLES
     */
    types.RESOURCE_VARIABLES = {
        ACE: 'ACE',
        APP_URL: 'APP_URL',
        SITE_URL: 'SITE_URL'
    };
    /**
     * Events of xide.*
     * @enum {string} module:xide/types/EVENTS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.EVENTS = {
        /**
         * generic
         */
        ERROR: 'onError',//xhr
        STATUS: 'onStatus',//xhr
        ON_CREATED_MANAGER: 'onCreatedManager',//context

        /**
         * item events, to be renoved
         */
        ON_ITEM_SELECTED: 'onItemSelected',
        ON_ITEM_REMOVED: 'onItemRemoved',
        ON_ITEM_CLOSED: 'onItemClosed',
        ON_ITEM_ADDED: 'onItemAdded',
        ON_ITEM_MODIFIED: 'onItemModified',
        ON_NODE_SERVICE_STORE_READY: 'onNodeServiceStoreReady',
        /**
         * old, to be removd
         */
        ON_FILE_STORE_READY: 'onFileStoreReady',
        ON_CONTEXT_MENU_OPEN: 'onContextMenuOpen',
        /**
         * CI events
         */
        ON_CI_UPDATE: 'onCIUpdate',

        /**
         * widgets
         */
        ON_WIDGET_READY: 'onWidgetReady',
        ON_CREATED_WIDGET: 'onWidgetCreated',
        RESIZE: 'onResize',
        /**
         * Event to notify classes about a reloaded module
         * @constant
         * @type string
         */
        ON_MODULE_RELOADED: 'onModuleReloaded',
        ON_MODULE_UPDATED: 'onModuleUpdated',


        ON_DID_OPEN_ITEM: 'onDidOpenItem',//remove
        ON_DID_RENDER_COLLECTION: 'onDidRenderCollection',//move

        ON_PLUGIN_LOADED: 'onPluginLoaded',
        ON_PLUGIN_READY: 'onPluginReady',
        ALL_PLUGINS_READY: 'onAllPluginsReady',

        /**
         * editors
         */
        ON_CREATE_EDITOR_BEGIN: 'onCreateEditorBegin',//move to xedit
        ON_CREATE_EDITOR_END: 'onCreateEditorEnd',//move to xedit
        REGISTER_EDITOR: 'registerEditor',//move to xedit
        ON_EXPRESSION_EDITOR_ADD_FUNCTIONS: 'onExpressionEditorAddFunctions',//move to xedit
        ON_ACE_READY: 'onACEReady',//remove

        /**
         * Files
         */
        ON_UNSAVED_CONTENT: 'onUnSavedContent',
        ON_FILE_CHANGED: 'fileChanged',
        ON_FILE_DELETED: 'fileDeleted',
        IMAGE_LOADED: 'imageLoaded',
        IMAGE_ERROR: 'imageError',
        UPLOAD_BEGIN: 'uploadBegin',
        UPLOAD_PROGRESS: 'uploadProgress',
        UPLOAD_FINISH: 'uploadFinish',
        UPLOAD_FAILED: 'uploadFailed',
        ON_FILE_CONTENT_CHANGED: 'onFileContentChanged',
        ON_COPY_BEGIN: 'onCopyBegin',
        ON_COPY_END: 'onCopyEnd',
        ON_DELETE_BEGIN: 'onDeleteBegin',
        ON_DELETE_END: 'onDeleteEnd',
        ON_MOVE_BEGIN: 'onMoveBegin',
        ON_MOVE_END: 'onMoveEnd',
        ON_CHANGED_CONTENT: 'onChangedContent',
        ON_COMPRESS_BEGIN: 'onCompressBegin',
        ON_COMPRESS_END: 'onCompressEnd',



        ON_COMPONENT_READY: 'onComponentReady',
        ON_ALL_COMPONENTS_LOADED: 'onAllComponentsLoaded',
        ON_APP_READY: 'onAppReady',
        /**
         * Store
         */
        ON_CREATE_STORE: 'onCreateStore',
        ON_STORE_CREATED: 'onStoreCreated',
        ON_STORE_CHANGED: 'onStoreChanged',
        ON_STATUS_MESSAGE: 'onStatusMessage',
        /**
         * layout
         */
        SAVE_LAYOUT: 'layoutSave',
        RESTORE_LAYOUT: 'layoutRestore',
        /**
         * views, panels and 'main view'
         */
        ON_SHOW_PANEL: 'onShowPanel',
        ON_PANEL_CLOSED: 'onPanelClosed',
        ON_PANEL_CREATED: 'onPanelCreated',

        ON_MAIN_VIEW_READY: 'onMainViewReady',
        ON_MAIN_MENU_READY: 'onMainMenuReady',
        ON_MAIN_MENU_OPEN: 'onMainMenuOpen',
        ON_VIEW_REMOVED: 'onViewRemoved',
        ON_VIEW_SHOW: 'onViewShow',
        ON_VIEW_HIDE: 'onViewHide',
        ON_VIEW_ADDED: 'onViewAdded',
        ON_OPEN_VIEW: 'onOpenView',
        ON_VIEW_MAXIMIZE_START: 'onViewMaximizeStart',
        ON_VIEW_MAXIMIZE_END: 'onViewMaximizeEnd',
        ON_CONTAINER_ADDED: 'onContainerAdded',
        ON_CONTAINER_REMOVED: 'onContainerRemoved',
        ON_REMOVE_CONTAINER: 'onRemoveContainer',
        ON_CONTAINER_REPLACED: 'onContainerReplaced',
        ON_CONTAINER_SPLIT: 'onContainerSplit',
        ON_RENDER_WELCOME_GRID_GROUP:'onRenderWelcomeGridGroup',

        ON_DND_SOURCE_OVER:'/dnd/source/over',
        ON_DND_START:'/dnd/start',
        ON_DND_DROP_BEFORE:'/dnd/drop/before',
        ON_DND_DROP:'/dnd/drop',
        ON_DND_CANCEL:'/dnd/cancel'
    };
    /**
     * To be moved
     * @type {{SIZE_NORMAL: string, SIZE_SMALL: string, SIZE_WIDE: string, SIZE_LARGE: string}}
     */
    types.DIALOG_SIZE = {
        SIZE_NORMAL: 'size-normal',
        SIZE_SMALL: 'size-small',
        SIZE_WIDE: 'size-wide',    // size-wide is equal to modal-lg
        SIZE_LARGE: 'size-large'
    };

    /**
     * To be moved
     * @type {{DEFAULT: string, INFO: string, PRIMARY: string, SUCCESS: string, WARNING: string, DANGER: string}}
     */
    types.DIALOG_TYPE = {
        DEFAULT: 'type-default',
        INFO: 'type-info',
        PRIMARY: 'type-primary',
        SUCCESS: 'type-success',
        WARNING: 'type-warning',
        DANGER: 'type-danger'
    };
    /**
     * @TODO: remove, defined in xideve
     */
    lang.mixin(types, {
        LAYOUT_RIGHT_CENTER_BOTTOM: 'LAYOUT_RIGHT_CENTER_BOTTOM',
        LAYOUT_CENTER_BOTTOM: 'LAYOUT_CENTER_BOTTOM',
        LAYOUT_CENTER_RIGHT: 'LAYOUT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT: 'LAYOUT_LEFT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT_BOTTOM: 'LAYOUT_LEFT_CENTER_RIGHT_BOTTOM'
    });

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     */
    dojo.fromJson = function (js, debug) {
        var res = null;
        var didFail = false;
        debug = true;
        try {
            res = eval("(" + js + ")");
        } catch (e) {
            didFail = true;
        }

        if (didFail) {
            var js2 = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                js2 && (res = eval("(" + js2 + ")"));
            } catch (e) {
                debug !== false && console.error('error in json parsing! ' + js);
                if (js.indexOf('error') !== -1) {
                    return {
                        "jsonrpc": "2.0",
                        "result": {
                            "error": {
                                "code": 1,
                                "message": js,
                                "data": null
                            }
                        }, "id": 0
                    };
                }
                throw new Error(js);
            }
        }
        return res;
    };
    return types;
});
define('xaction/types',[
    'xide/types',
    'dojo/_base/lang'
],function(types,lang){

    lang.mixin(types.EVENTS,{
        ON_ACTION_CHANGE_CONTEXT: 'onChangeActionContext',
        ON_ACTION_CONTEXT_CHANGED: 'onActionContextChanged',
        REGISTER_ACTION: 'registerAction',
        SET_ITEM_ACTIONS: 'onSetItemsActions',
        ON_CLIPBOARD_COPY: 'onClipboardCopy',
        ON_CLIPBOARD_PASTE: 'onClipboardPaste',
        ON_CLIPBOARD_CUT: 'onClipboardCut',
        ON_RENDER_ACTIONS: 'onRenderActions',
        ON_DID_ACTION:'onDidAction',
        ON_AFTER_ACTION:'onAfterAction'
    });

    /**
     * Enumeration to define an Action command
     * @enum {string} module:xide/types/Action
     * @memberOf module:xide/types
     */
    types.ACTION =
    {
        LAYOUT: 'View/Layout',
        COLUMNS: 'View/Columns',
        SELECTION: 'File/Select',
        CLIPBOARD: 'Edit/Clipboard',
        UNDO: 'Edit/Undo',
        REDO: 'Edit/Redo',
        CLIPBOARD_COPY: 'Edit/Clipboard/Copy',
        CLIPBOARD_PASTE: 'Edit/Clipboard/Paste',
        CLIPBOARD_CUT: 'Edit/Clipboard/Cut',
        COPY: 'File/Copy',
        MOVE: 'File/Move',
        RENAME: 'File/Rename',
        DELETE: 'File/Delete',
        OPEN: 'File/Open',
        EDIT: 'File/Edit',
        SAVE: 'File/Save',
        SEARCH: 'File/Search',
        TOOLBAR: 'View/Show/Toolbar',
        STATUSBAR: 'View/Show/Statusbar',
        BREADCRUMB: 'View/Show/Breadcrumb',
        HEADER: 'View/Show/Header',
        DOWNLOAD: 'File/Download',
        DOWNLOAD_TO: 'File/downloadTo',
        INFO: 'File/Info',
        COMPRESS: 'File/Compress',
        RELOAD: 'File/Reload',
        UPLOAD: 'File/Upload',
        PREVIEW: 'File/Preview',
        OPEN_IN: 'File/Open In',
        INSERT_IMAGE: 'insertImage',
        COPY_PASTE: 'copypaste',
        DND: 'dnd',
        OPTIONS: 'options',
        NEW_FILE: 'File/New/New File',
        NEW_DIRECTORY: 'File/New/New Folder',
        GET_CONTENT: 'get',
        SET_CONTENT: 'set',
        FIND: 'File/Find',
        CUSTOM: 'custom',
        PERMA_LINK: 'permaLink',
        ADD_MOUNT: 'ADD_MOUNT',
        REMOVE_MOUNT: 'REMOVE_MOUNT',
        EDIT_MOUNT: 'EDIT_MOUNT',
        PERSPECTIVE: 'PERSPECTIVE',
        RUN: 'File/Run',
        GO_UP: 'Navigation/Go Up',
        STOP: 'File/Stop',
        CLOSE: 'View/Close',
        FULLSCREEN: 'View/Fullscreen',
        OPEN_IN_TAB: 'File/OpenInNewTab',
        SOURCE: 'Navigation/Source',
        RIBBON: 'View/Show/Ribbon',
        MAIN_MENU: 'View/Show/MainMenu',
        NAVIGATION: 'View/Show/Navigation',
        BASH_CONSOLE: 'File/Console/Bash',
        JS_CONSOLE: 'File/Console/JS',
        PHP_CONSOLE: 'File/Console/PHP',
        CONSOLE: 'File/Console/PHP',
        SIZE_STATS: 'View/Show/SizeStats',
        WELCOME: 'Window/Welcome',
        CONTEXT_MENU:'File/ContextMenu'
    };

    types.ACTION_TYPE = {
        MULTI_TOGGLE: 'multiToggle',
        SINGLE_TOGGLE: 'singleToggle'
    };

    types.ACTION_ICON =
    {
        CLIPBOARD_COPY: 'fa-copy',
        CLIPBOARD_PASTE: 'fa-paste',
        UPLOAD: 'fa-upload',
        RENAME: 'el-icon-edit',
        DELETE: 'text-danger fa-remove',
        RELOAD: 'fa-refresh',
        EDIT: 'fa-pencil',
        SAVE: 'fa-floppy-o',
        SEARCH: 'fa-search',
        NEW_DIRECTORY: 'fa-magic',
        NEW_FILE: 'fa-magic',
        RUN: 'text-success el-icon-play',
        COMPRESS: 'fa-file-archive-o',
        EXTRACT: 'fa-folder-open',
        DOWNLOAD: 'fa-download',
        GO_UP: 'fa-level-up',
        TOOLBAR: 'fa-bars',
        STATUSBAR: 'fa-terminal',
        PREVIEW: 'fa-eye',
        MAXIMIZE: 'fa-arrows-alt',
        UNDO: 'fa-undo',
        REDO: 'fa-repeat'

    };

    return types;
});
define('xfile/types',[
    'xide/utils',
    'xide/types',
    'xide/types/Types',
    'xaction/types'
], function (utils, types) {
    /**
     * Public mime registry setter
     * @param type
     * @param map
     */
    types.registerCustomMimeIconExtension = function (type, map) {
        types['customMimeIcons'][type] = map;
    };

    var ACTION = types.ACTION;

    var DEFAULT_PERMISSIONS = [
        ACTION.EDIT,
        ACTION.COPY,
        ACTION.CLOSE,
        ACTION.MOVE,
        ACTION.RENAME,
        ACTION.DOWNLOAD,
        ACTION.RELOAD,
        ACTION.DELETE,
        ACTION.NEW_FILE,
        ACTION.NEW_DIRECTORY,
        ACTION.CLIPBOARD,
        ACTION.LAYOUT,
        ACTION.COLUMNS,
        ACTION.SELECTION,
        ACTION.PREVIEW,
        ACTION.OPEN_IN,
        ACTION.GO_UP,
        ACTION.SEARCH,
        ACTION.OPEN_IN_TAB,
        ACTION.TOOLBAR,
        ACTION.STATUSBAR,
        ACTION.UPLOAD,
        ACTION.SIZE_STATS,
        ACTION.CONSOLE,
        ACTION.HEADER,
        'File/Compress',
        'File/New',
        ACTION.CONTEXT_MENU,
        ACTION.SOURCE,
        'File/OpenInOS'
    ];

    types.DEFAULT_FILE_GRID_PERMISSIONS = DEFAULT_PERMISSIONS;

    types.FIELDS = {
        SHOW_ISDIR: 1602,
        SHOW_OWNER: 1604,
        SHOW_MIME: 1608,
        SHOW_SIZE: 1616,
        SHOW_PERMISSIONS: 1632,
        SHOW_TIME: 1633,
        SHOW_FOLDER_SIZE: 1634,
        SHOW_FOLDER_HIDDEN: 1635,
        SHOW_TYPE: 1636,
        SHOW_MEDIA_INFO: 1637
    };

    types.FILE_PANEL_LAYOUT =
        {
            TREE: 1,
            LIST: 2,
            THUMB: 3,
            PREVIEW: 4,
            COVER: 5,
            SPLIT_VERTICAL: 6,
            SPLIT_HORIZONTAL: 7,
            IMAGE_GRID: 8
        };

    types.LAYOUT_PRESET =
        {
            DUAL: 1,
            SINGLE: 2,
            BROWSER: 3,
            PREVIEW: 4,
            GALLERY: 5,
            EDITOR: 6
        };

    types.PANEL_OPTIONS = {
        ALLOW_NEW_TABS: true,
        ALLOW_MULTI_TAB: false,
        ALLOW_INFO_VIEW: true,
        ALLOW_LOG_VIEW: true,
        ALLOW_CONTEXT_MENU: true,
        ALLOW_LAYOUT_SELECTOR: true,
        ALLOW_SOURCE_SELECTOR: true,
        ALLOW_COLUMN_RESIZE: true,
        ALLOW_COLUMN_REORDER: true,
        ALLOW_COLUMN_HIDE: true,
        ALLOW_ACTION_TOOLBAR: true,
        ALLOW_MAIN_MENU: true
    };

    /**
     * @TODO: remove
     * @type {{LAYOUT: number, AUTO_OPEN: boolean}}
     */
    types.FILE_PANEL_OPTIONS_LEFT = {
        LAYOUT: 2,
        AUTO_OPEN: true
    };

    types.FILE_PANEL_OPTIONS_MAIN = {
        LAYOUT: 3,
        AUTO_OPEN: true
    };

    types.FILE_PANEL_OPTIONS_RIGHT = {
        LAYOUT: 3,
        AUTO_OPEN: true
    };
    types.FILE_GRID_COLUMNS =
        {
            NAME: 'name',
            SIZE: 'size',
            MODIFIED: 'modified'
        };
    types.ACTION_TOOLBAR_MODE =
        {
            SELF: 'self'
        };

    utils.mixin(types.ITEM_TYPE, {
        FILE: 'BTFILE'
    });

    /***
     *
     * Extend the core events with xfile specific events
     */
    /**
     * ActionVisibility
     * @enum module:xide/types/EVENTS
     * @memberOf module:xide/types
     */
    utils.mixin(types.EVENTS, {
        STORE_CHANGED: 'onStoreChange',
        BEFORE_STORE_CHANGE: 'onBeforeStoreChange',
        STORE_REFRESHED: 'onStoreRefreshed',
        ON_FILE_STORE_READY: 'onFileStoreReady',
        ON_DID_OPEN_ITEM: 'onDidOpenItem',
        ON_SHOW_PANEL: 'onShowPanel',
        ITEM_SELECTED: 'onItemSelected',
        ERROR: 'fileOperationError',
        STATUS: 'fileOperationStatus',
        IMAGE_LOADED: 'imageLoaded',
        IMAGE_ERROR: 'imageError',
        RESIZE: 'resize',
        ON_UPLOAD_BEGIN: 'onUploadBegin',
        ON_UPLOAD_PROGRESS: 'onUploadProgress',
        ON_UPLOAD_FINISH: 'onUploadFinish',
        ON_UPLOAD_FAILED: 'onUploadFailed',
        ON_CLIPBOARD_COPY: 'onClipboardCopy',
        ON_CLIPBOARD_PASTE: 'onClipboardPaste',
        ON_CLIPBOARD_CUT: 'onClipboardCut',
        ON_CONTEXT_MENU_OPEN: 'onContextMenuOpen',
        ON_PLUGIN_LOADED: 'onPluginLoaded',
        ON_PLUGIN_READY: 'onPluginReady',
        ON_MAIN_VIEW_READY: 'onMainViewReady',
        ON_FILE_CONTENT_CHANGED: 'onFileContentChanged',
        ON_PANEL_CLOSED: 'onPanelClosed',
        ON_PANEL_CREATED: 'onPanelCreated',
        ON_COPY_BEGIN: 'onCopyBegin',
        ON_COPY_END: 'onCopyEnd',
        ON_DOWNLOAD_TO_BEGIN: 'onDownloadToBegin',
        ON_DOWNLOAD_TO_END: 'onDownloadToEnd',
        ON_DELETE_BEGIN: 'onDeleteBegin',
        ON_DELETE_END: 'onDeleteEnd',
        ON_MOVE_BEGIN: 'onMoveBegin',
        ON_MOVE_END: 'onMoveEnd',
        ON_COMPRESS_BEGIN: 'onCompressBegin',
        ON_COMPRESS_END: 'onCompressEnd',
        ON_SOURCE_MENU_OPEN: 'onSourceMenuOpen',
        ON_MOUNT_DATA_READY: 'onMountDataReady',
        ON_XFILE_READY: 'onXFileReady',
        ON_CHANGE_PERSPECTIVE: 'onChangePerspective',
        ON_FILE_PROPERTIES_RENDERED: 'onFilePropertiesRendered'
    });

    /**
     * SELECTION_MODE specfies the possible selection modes for xfile grid views
     * @enum module:xide/types/SELECTION_MODE
     * @memberOf module:xide/types
     */
    types.SELECTION_MODE =
        {
            /** Single
             * @const
             * @type {string}
             */
            SINGLE: 'single',
            /** Multiple
             * @const
             * @type {string}
             */
            MULTI: 'multiple',
            /** Extended
             * @const
             * @type {string}
             */
            EXTENDED: 'extended'
        };

    /**
     * @TODO: remove
     * OPERATION is the string representation of xfile commands
     * @enum module:xide/types/OPERATION
     * @memberOf module:xide/types
     */
    types.OPERATION =
        {

            COPY: 'copy',
            MOVE: 'move',
            RENAME: 'rename',
            DELETE: 'delete',
            OPEN: 'open',
            EDIT: 'edit',
            DOWNLOAD: 'download',
            DOWNLOAD_TO: 'downloadTo',
            INFO: 'info',
            COMPRESS: 'compress',
            RELOAD: 'reload',
            PREVIEW: 'preview',
            INSERT_IMAGE: 'insertImage',
            COPY_PASTE: 'copypaste',
            DND: 'dnd',
            OPTIONS: 'options',
            NEW_FILE: 'mkfile',
            NEW_DIRECTORY: 'mkdir',
            GET_CONTENT: 'get',
            SET_CONTENT: 'set',
            FIND: 'find',
            CUSTOM: 'custom',
            PERMA_LINK: 'permaLink',
            ADD_MOUNT: 'ADD_MOUNT',
            REMOVE_MOUNT: 'REMOVE_MOUNT',
            EDIT_MOUNT: 'EDIT_MOUNT',
            PERSPECTIVE: 'PERSPECTIVE',
            EXTRACT: 'extract'
        };

    /**
     * @TODO: remove
     * OPERATION_INT is the integer version of {xide/types/OPERATION}
     * @enum module:xide/types/OPERATION_INT
     * @memberOf module:xide/types
     */
    types.OPERATION_INT = {
        NONE: 0,
        EDIT: 1,
        COPY: 2,
        MOVE: 3,
        INFO: 4,
        DOWNLOAD: 5,
        COMPRESS: 6,
        DELETE: 7,
        RENAME: 8,
        DND: 9,
        COPY_PASTE: 10,
        OPEN: 11,
        RELOAD: 12,
        PREVIEW: 13,
        INSERT_IMAGE: 15,
        NEW_FILE: 16,
        NEW_DIRECTORY: 17,
        UPLOAD: 18,
        READ: 19,
        WRITE: 20,
        PLUGINS: 21,
        CUSTOM: 22,
        FIND: 23,
        PERMA_LINK: 24,
        ADD_MOUNT: 25,
        REMOVE_MOUNT: 26,
        EDIT_MOUNT: 27,
        PERSPECTIVE: 28,      //change perspective
        CLIPBOARD_COPY: 29,
        CLIPBOARD_CUT: 30,
        CLIPBOARD_PASTE: 31,
        EXTRACT: 32
    };

    types.EResolveMode = {
        "SKIP": "SKIP",
        "OVERWRITE": "OVERWRITE",
        "IF_NEWER": "IF_NEWER",
        "IF_SIZE_DIFFERS": "IF_SIZE_DIFFERS",
        "APPEND": "APPEND",
        "THROW": "THROW",
        "ABORT": "ABORT"
    }
    
    types.EResolve = {
        ALWAYS: "ALWAYS",
        THIS: "THIS"
    }
    
    types.EError = {
        NONE: 'None',
        EXISTS: 'EEXIST',
        PERMISSION: 'EACCES',
        NOEXISTS: 'ENOENT',
        ISDIR:'EISDIR'
    }
    return types;
});
/** @module xide/model/Base **/
define('xide/model/Base',[
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    
    var Implementation = {
        declaredClass:"xide/model/Base",
        /**
         * Mixin constructor arguments into this.
         * This could have been done in another base class but performance matters
         * @todo use a mixin from lodash
         * @constructor
         */
        constructor: function (args) {
            utils.mixin(this, args);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public interface, keep it small and easy
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Return a human friendly name
         * @abstract
         * @returns {string|null}
         */
        getLabel: function () {
            return null;
        },
        /**
         * Return a unique ID.
         * @abstract
         * @returns {string|null}
         */
        getID: function () {
            return null;
        }
    };

    var Module = declare("xide/model/Base",null,Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});


(function () {

    var __isAMD = !!(typeof define === 'function' && define.amd),
        __isNode = (typeof exports === 'object'),
        __isWeb = !__isNode,
    //is that enough at some point?
        __isDojoRequire = !!(typeof require === 'function' && require.packs),
        __isRequireJS = !__isDojoRequire,
        __deliteHas = !!(typeof has === 'function' && has.addModule);

    define('xdojo/has',[
        //needed?
        'require',
        'exports',
        //should be extended for the missing .config() method when in delite
        'module',
        __isDojoRequire ? 'dojo/has' : 'requirejs-dplugins/has'
    ], function (require, exports, module, dHas) {

        if (dHas) {
            if (typeof exports !== "undefined") {
                exports.has = dHas;
            }
            if (__isNode) {
                return module.exports;
            } else if (__isWeb && __isAMD) {
                return dHas;
            }
        } else {
            //@TODO, add simple version?
            //we shouldn't be here
            debugger;
        }
    });
}).call(this);
define('xide/factory',[
    'dcl/dcl'
],function(dcl){
    return new dcl(null,{
        declaredClass:'xide/factory'
    });
});
/** @module xide/mixins/EventedMixin **/
define('xide/mixins/EventedMixin',[
    "dojo/_base/array",
    "dcl/dcl",
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/factory'
], function (array, dcl, declare, has, types, factory) {

    var toString = Object.prototype.toString;
    /**
     * Adds convenient functions for events to the consumer, generalizing dojo.subscribe/publish or dojo.on.
     * This mixin can be applied to anything dijit/_Widget based or custom functional classes(needs to call destroy!)
     *
     * Check online-documentation {@link http://rawgit.com/mc007/xjs/dgrid_update/src/lib/xide/out/xide/0.1.1-dev/EventedMixin.html|here}
     *
     * @class module:xide/mixins/EventedMixin
     */
    var Impl = {

        _didRegisterSubscribers: false,

        subscribers: null,
        /**
         * Subscription filter map
         * @type {Object.<string,boolean}
         */
        subscribes: {},
        /**
         * Emit filter map
         * @type {Object.<string,boolean}
         */
        emits: {},
        /**
         * Array of dojo subscribe/on handles, destroyed on this.destroy();
         * @private
         * @type {Object[]}
         */
        __events: null,
        /**
         * Add emit filter
         * @param type
         * @param data
         */
        addPublishFilter: function (type, data) {
            if (type) {
                if (data != null) {
                    this.emits[type] = data;
                } else if (type in this.emits) {
                    delete this.emits[type];
                }
            }
        },
        /**
         * Simple filter function to block subscriptions.
         * @param key
         * @returns {boolean}
         */
        filterSubscribe: function (key) {

            if (this.subscribes) {
                return this.subscribes[key] !== false;
            }
            return true;
        },
        /**
         * Simple filter function to block publishing.
         * @param key
         * @returns {boolean}
         */
        filterPublish: function (key) {
            if (this.emits) {
                return this.emits[key] !== false;
            }
            return true;
        },
        /**
         * Subscribe to an event or multiple events. Attention, this is NOT checking for duplicates!
         *
         * @example
         *
         * // widget case with event callback delegation to 'this', code is written inside a custom widget or whatever
         * // class subclassing from this mixin:
         * // pre-requisites for dijit/dojox widgets: lang.extend(dijit.Button,EventedMixin.prototype);
         *
         * //simple example #1
         * var button = new dijit.Button({});
         * button.subscribe('click',this.onButtonClick,this);//calls this.onButtonClick with scope this
         *
         * //simple example #2
         * var button = new dijit.Button({});
         * button.subscribe('click',null,this);//calls this.click with scope this
         *
         * //multi-event example #1
         * var button = new dijit.Button({});
         * button.subscribe(['click','dblclick'],null,this);//calls this.click and this.dblclick with scope this
         *
         * // custom events (using dojo-publish/subscribe or dojo.topic)
         * // assuming you want listen to the events of dijit/layout/TabContainer or any other StackContainer. Notice,
         * // that stack-containers will publish events like this: topic.publish(this.id + "-removeChild", page);
         *
         * var tabContainerId = 'tabContainer';
         *
         * this.subscribe(tabContainerId + 'addChild',this.childAdded);//notice that the scope is set here automatically!
         *
         * //multi-event version, this will call this['tabContainerId-addChild'] and this['tabContainerId-removeChild']
         *
         * this.subscribe([tabContainerId + 'addChild',tabContainerId + 'removeChild']);
         *
         *
         *
         *
         *
         *
         * @param keys {String|String[]} : The event key(s), given as single string or an array of strings, holding all
         * event keys for publishing multiple events in one row.
         *
         * @param cb {Function} : callback, by the default the callback's scope will 'this'
         *
         * @param to {Object} : override 'this' scope to something else
         */
        subscribe: function (keys, cb, to) {
            if (!this.__events) {
                this.__events = {};
            }
            var self = this,
                events = factory.subscribe(keys, cb, to || self, self.filterSubscribe.bind(self)),
                container = self.__events;

            //replay on local tracking map
            for (var i = 0, l = events.length; i < l; i++) {
                var _type = events[i].type;
                if (!container[_type]) {
                    container[_type] = [];
                }
                container[_type].push(events[i]);
            }
            return events;

        },
        /**
         * Publish an event (uses dojo.publish)
         *
         * @param keys {String|String[]} : The event key, given as string or array for publishing multiple events in one row
         *
         * @param data {Object|null} : The actual event data.
         *
         * @param from {Object|null} : Send event 'as' this source. By default, its using 'this' as sender.
         *
         * @param delay {Number|null} : Send event with a delay, otherwise call now
         *
         */
        publish: function (keys, data, from, delay) {
            var self = this;
            if (delay > 0) {
                setTimeout(function () {
                    factory.publish(keys, data, from || self, self.filterPublish.bind(self));
                }.bind(self), delay);
            } else {
                factory.publish(keys, data, from || self, self.filterPublish.bind(self));
            }
        },
        /**
         * @TODO: deal with unsubscribe in _EventedMixin
         * @param key
         * @private
         */
        _destroyHandle: function (key) {
        },
        /**
         * Turns the lights off, kills all event handles.
         * @private
         * @returns void
         */
        _destroyHandles: function () {
            if (this.__events) {
                for (var type in this.__events) {
                    array.forEach(this.__events[type], function (item) {
                        if (item && item.remove) {
                            item.remove();
                        }
                    });
                }
                delete this.__events;
            }
        },
        /**
         * When using subscribe, all event subscription handles are stored in this.__events.
         * This function will remove all the event handles, using this._destroyHandles()
         */
        destroy: function () {
            this._emit('destroy');
            this.inherited && this.inherited(arguments);
            this._destroyHandles();
        },
        /**
         * Adds a one time listener for the event. This listener is invoked only the
         * next time the event is fired, after which it is removed.
         *
         * @name emitter.once(event, listener)
         * @param {String} event- The event name/id to listen for
         * @param {Function} listener - The function to bind to the event
         * @api public
         *
         * ```javascript
         * db.once('unauthorized', function (req) {
         *     // this event listener will fire once, then be unbound
         * });
         * ```
         */
        once: function (type, listener) {
            var self = this;

            function wrapped() {
                self.unsubscribe(type, listener);
                return listener.apply(self, arguments);
            }

            wrapped.listener = listener;
            self._on(type, wrapped);
            return this;
        },
        /*
         __emit:function(target,type,event){
         event = event || {};
         if (typeof target.emit === 'function' && !target.nodeType) {
         return target.emit(type, event);
         }
         if (target.dispatchEvent && target.ownerDocument && target.ownerDocument.createEvent) {
         var nativeEvent = target.ownerDocument.createEvent('HTMLEvents');
         nativeEvent.initEvent(type, Boolean(event.bubbles), Boolean(event.cancelable));
         for (var key in event) {
         if (!(key in nativeEvent)) {
         nativeEvent[key] = event[key];
         }
         }
         return target.dispatchEvent(nativeEvent);
         }
         throw new Error('Target must be an event emitter');
         },
         */
        /**
         * Execute each of the listeners in order with the supplied arguments.
         *
         * @name emitter.emit(event, [arg1], [arg2], [...])
         * @param {String} event - The event name/id to fire
         * @api public
         */
        _emit: function (type) {
            if (!this.__events)
                return;

            if (!this._didRegisterSubscribers && this.subscribers) {
                for (var i = 0; i < this.subscribers.length; i++) {
                    var subscriber = this.subscribers[i];
                    this._on(subscriber.event, subscriber.handler, subscriber.owner);
                }
                this._didRegisterSubscribers = true;
            }

            if (arguments[2] === true)
                throw new Error("Please use emit.sticky() instead of passing sticky=true for event: " + type);

            var handler = this.__events[type],
                eventArgs = arguments.length > 1 ? arguments[2] : null;

            if (!handler)
                return;

            var returnValue;

            if (typeof handler == 'function') {
                switch (arguments.length) {
                    // fast cases
                    case 1:
                        return handler.call(this);
                    case 2:
                        return handler.call(this, arguments[1]);
                    case 3:
                        return handler.call(this, arguments[1], arguments[2]);
                    // slower
                    default:
                        var args = Array.prototype.slice.call(arguments, 1);
                        returnValue = handler.apply(this, args);
                }
            }

            else if (_.isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);
                var listeners = handler.slice(), temp;
                var _listener = null;
                var who = null;

                for (var i = 0, l = listeners.length; i < l; i++) {

                    _listener = listeners[i];
                    who = _listener.owner || this;

                    args && args[0] && (args[0].owner = args[0] ? args[0].owner || who : null);

                    _listener.handler && (temp = _listener.handler.apply(who, args));
                    if (temp !== undefined) {
                        returnValue = temp;
                    }

                    args && args[0] && args[0].owner && (args[0].owner = null);


                }
            }

            //forward to global
            eventArgs && eventArgs['public'] === true && this.publish(type, args);

            return returnValue;
        },
        /**
         * Remove a listener from the listener array for the specified event. Caution:
         * changes array indices in the listener array behind the listener.
         *
         * @name emitter.removeListener(event, listener)
         * @param {String} event - The event name/id to remove the listener from
         * @param {Function} listener - The listener function to remove
         * @api public
         *
         * ```javascript
         * var callback = function (init) {
         *     console.log('duality app loaded');
         * };
         * devents.on('init', callback);
         * // ...
         * devents.removeListener('init', callback);
         * ```
         */
        unsubscribe: function (type, listener) {

            // does not use listeners(), so no side effect of creating __events[type]
            if (!this.__events || !this.__events[type]) return this;

            // no listener given, unsubscribe all per type
            if (('function' !== typeof listener || !listener)) {
                array.forEach(this.__events[type], dojo.unsubscribe);
                delete this.__events[type];
                this.__events[type] = [];
                return this;
            }
            var list = this.__events[type];
            if (_.isArray(list)) {
                var _remove = [];
                _.each(list, function (handle, a, b) {
                    var which = handle.handler == listener ? handle.handler : handle.handler.listener == listener ? handle.handler.listener : null;
                    if (which) {
                        _remove.push(handle);
                    }
                });
                _.each(_remove, function (handler) {
                    handler.remove();
                });
                if (list.length === 0) {
                    delete this.__events[type];
                }
            } else if ((this.__events[type].listener || this.__events[type]) === listener) {
                delete this.__events[type];
            }
            return this;
        },
        /**
         * Returns an array of listeners for the specified event. This array can be
         * manipulated, e.g. to remove listeners.
         *
         * @name emitter.listeners(event)
         * @param {String} events - The event name/id to return listeners for
         * @api public
         *
         * ```javascript
         * session.on('change', function (stream) {
         *     console.log('session changed');
         * });
         * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]
         * ```
         */
        listeners: function (type) {
            if (!this.__events) this.__events = {};
            if (!this.__events[type]) this.__events[type] = [];
            if (!isArray(this.__events[type])) {
                this.__events[type] = [this.__events[type]];
            }
            return this.__events[type];
        },
        /**
         *
         * @param type
         * @param handle
         * @returns {*}
         */
        addHandle: function (type, handle) {
            if (!this.__events) {
                this.__events = {}
            }
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            handle.type = type;
            this.__events[type].push(handle);
            return handle;
        },
        /**
         * jQuery sub
         * @param element
         * @param type
         * @param selector
         * @param handler
         * @returns {{handler: *, owner: (exports|module.exports|module:xide/mixins/EventedMixin), type: *, element: (*|jQuery|HTMLElement), selector: *, remove: _handle.remove}}
         */
        __on: function (element, type, selector, handler) {

            var _handler = handler;

            if (typeof selector == 'function' && !handler) {
                //no selector given
                handler = selector;
                selector = null;
            }

            element = element.jquery ? element : $(element);
            element.on(type, selector, handler);

            if (!this.__events) this.__events = {};
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            var eventList = this.__events[type];
            var _handle = {
                handler: _handler,
                owner: this,
                type: type,
                element: element,
                selector: selector,
                remove: function () {
                    eventList.remove(this);
                    this.element.off(this.type, this.selector, this.handler);
                }
            };
            eventList.push(_handle);
            return _handle;

        },
        /**
         * Dojo based sub
         * @param type
         * @param listener
         * @param owner
         * @returns {*}
         * @private
         */
        _on: function (type, listener, owner) {
            try {
                if (!this.__events) this.__events = {};

                if (!this.__events[type]) {
                    this.__events[type] = [];
                }

                var eventList = this.__events[type];


                if (!eventList) {
                    // Optimize the case of one listener. Don't need the extra array object.
                    this.__events[type] = listener;
                }
                else if (_.isArray(eventList)) {

                    if (eventList.indexOf(listener) != -1)
                        return console.warn("adding same listener twice", type);

                    // If we've already got an array, just append.
                    var _handle = {
                        handler: listener,
                        owner: owner || this,
                        type: type,
                        remove: function () {
                            eventList.remove(this);
                            owner && owner.__events && owner.__events[type] && owner.__events[type].remove(this);
                            this.owner = null;
                            this.handler = null;
                            delete this.type;
                        }
                    };
                    eventList.push(_handle);
                    return _handle;
                }
            } catch (e) {
                logError(e);
            }
            return this;
        }
    };

    //package via declare
    var Module = declare(null, Impl);
    //static access to Impl.
    Module.Impl = Impl;
    Module.dcl = dcl(null, Impl);
    dcl.chainAfter(Module.dcl, 'destroy');
    return Module;
});


/** @module xide/model/Component **/
define('xide/model/Component',[
    "dcl/dcl",
    "dojo/Deferred",
    "dojo/has",
    "require",
    "xide/model/Base",
    "xide/types",
    "xide/mixins/EventedMixin"
], function (dcl, Deferred, has, require, Base, types, EventedMixin) {
    /**
     * COMPONENT_FLAGS is a number of flags being used for the component's instance creation. Use an object instead of
     * an integer, never know how big this becomes and messing with 64bit integers doesn't worth the effort.
     *
     * @enum module:xide/types/COMPONENT_FLAGS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.COMPONENT_FLAGS = {
        /**
         * Due the object instantiation, instruct the component loader to call ::load()
         * @constant
         */
        LOAD: 1,
        /**
         * Due the object instantiation, instruct the component loader to call ::run()
         * @constant
         */
        RUN: 1
    };

    /**
     * @class xide/model/Component
     * @extends module:xide/mixins/EventedMixin
     * @extends module:xide/model/Base
     */
    return dcl([Base.dcl, EventedMixin.dcl], {
        declaredClass:"xide/model/Component",
        /**
         * Flag indicating that all dependencies are fully loaded
         * @type {boolean}
         * @default false
         */
        _loaded: false,
        /**
         * Pointer to a context, filled by the component loader
         * @member module:xide/manager/Context
         */
        ctx: null,
        /**
         * Pointer to an optional owner
         * @member {Object|null}
         */
        owner: {
            reloadComponent: function () {
            }
        },
        /**
         * Usually a component is about a new beantype.
         * @TODO handle many
         */
        beanType: null,
        /**
         * Array of typical JS packages
         * @member {Array|null} packages
         */
        packages: null,

        /**
         * Array of resources. A components has typically a bunch of resources like CSS.
         * @member {Array} resources
         */
        resources: [],
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies: function () {
            return [];
        },
        hasEditors: function () {
            return [];
        },
        /**
         * Return a human readable string
         * @returns {string}
         */
        getLabel: function () {
            return "Have no label";
        },
        /**
         * If this component has additional dependencies, load them here!
         * @returns {dojo.Deferred}
         */
        load: function (hasName) {
            var _defered = new Deferred(),
                thiz = this,
                _re = require;

            hasName = hasName || this.getLabel();

            _re(this.getDependencies(), function () {
                thiz._loaded = true;
                if (hasName) {
                    has.add(hasName, function () {
                        return true;
                    });
                }
                _defered.resolve();
            });
            return _defered.promise;
        },
        run: function () {
            return false;
        },
        onModuleReloaded: function () {
            this.owner.reloadComponent(this);
        },
        isLoaded: function () {
            return this._loaded;
        }
    });
});


define('xfile/component',[
    "dcl/dcl",
    "xide/model/Component"
], function (dcl,Component) {

    /**
     * @class xfile.component
     * @inheritDoc
     */
    return dcl(Component, {
        /**
         * @inheritDoc
         */
        beanType:'BTFILE',
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies:function(){
            return [
                "xfile/types",
                "xfile/manager/FileManager",
                "xfile/manager/MountManager",
                "xfile/factory/Store",
                "xfile/views/FileGrid"
            ];
        },
        /**
         * @inheritDoc
         */
        getLabel: function () {
            return 'xfile';
        },
        /**
         * @inheritDoc
         */
        getBeanType:function(){
            return this.beanType;
        }
    });
});


/** @module xgrid/ThumbRenderer **/
define('xgrid/ThumbRenderer',[
    "xdojo/declare",
    'xide/types',
    'dojo/dom-construct',
    './Renderer'
], function (declare,types,domConstruct,Renderer) {
    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xgrid/ThumbRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        isThumbGrid:false,
        _getLabel:function(){ return "Thumb"; },
        _getIcon:function(){ return "fa-th-large"; },
        activateRenderer:function(renderer){
            this._showHeader(false);
            this.isThumbGrid = true;
        },
        deactivateRenderer:function(renderer){
            this.isThumbGrid = false;
        },
        /**
         * Override renderRow
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {
            if (obj.render) {
                return obj.render(obj, this.inherited);
            }
            return domConstruct.create('span', {
                className: "fileGridCell",
                innerHTML: '<span class=\"' + 'fa-cube fa-5x' + '\""></span> <div class="name">' + obj.name + '</div>',
                style: 'color:blue;max-width:200px;float:left;margin:18px;padding:18px;'
            });
        }
    };

    //package via declare
    var _class = declare('xgrid.ThumbRenderer',[Renderer],Implementation);
    _class.Implementation = Implementation;

    return _class;
});
/** @module xfile/ThumbRenderer **/
define('xfile/ThumbRenderer',[
    "xdojo/declare",
    'xide/utils',
    'dojo/dom-construct',
    'xgrid/ThumbRenderer'
], function (declare,utils,domConstruct,ThumbRenderer) {

    /**
     * The list renderer does nothing since the xgrid/Base is already inherited from
     * dgrid/OnDemandList and its rendering as list already.
     *
     * @class module:xfile/ThumbRenderer
     * @extends module:xfile/Renderer
     */
    return declare('xfile.ThumbRenderer',[ThumbRenderer],{
        thumbSize: "400",
        resizeThumb: true,
        __type:'thumb',
        deactivateRenderer:function(){
            $(this.domNode.parentNode).removeClass('metro');
            $(this.domNode).css('padding','');
            this.isThumbGrid = false;

        },
        activateRenderer:function(){
            $(this.domNode.parentNode).addClass('metro');
            $(this.contentNode).css('padding','8px');
            this.isThumbGrid = true;
            this.refresh();
        },

        _renderUpload:function(name,progress,obj){

            progress = parseInt(progress.replace('%',''));
            if(progress==100){
                progress = 90;
            }

            var result = '<div class="tile widget uploadItem"><div class="radial-progress tile widget " data-progress="' + progress + '">'+
                '<div class="circle">'+
                '<div class="mask full">'+
                '<div class="fill"></div>'+
                '</div>'+
                '<div class="mask half">'+
                '<div class="fill"></div>'+
                '<div class="fill fix"></div>'+
                '</div>'+
                '<div class="shadow"></div>'+
                '</div>'+
                '<div class="inset">'+
                '<div class="percentage">'+
                '<div class="numbers"><span>-</span>';

            for(var i= 0 ; i< 99 ; i++){

                result+=('<span>' + i +'%' + '</span>');

            };

            result+='</div>'+
                '</div>'+
                '</div>'+
                '</div></div>';

            return result;

        },
        /**
         * Override renderRow
         * @param obj
         * @returns {*}
         */
        renderRow: function (obj) {
            if(obj.isUpload === true){
                return $(this._renderUpload(obj.name, obj.progress + '%',obj))[0];
            }
            if(obj.renderRow){
                var _res = obj.renderRow.apply(this,[obj]);
                if(_res){
                    return _res;
                }
            }
            var thiz = this,
                div = domConstruct.create('div', {
                    className: "tile widget"
                }),
                icon = obj.icon,
                no_access = obj.read === false && obj.write === false,
                isBack = obj.name == '..',
                directory = obj && !!obj.directory,
                useCSS = false,
                label = '',
                imageClass = 'fa fa-folder fa-5x',
                isImage = false;

            this._doubleWidthThumbs = true;
            var iconStyle='text-shadow: 2px 2px 5px rgba(0,0,0,0.3);font-size: 72px;opacity: 0.7';
            var contentClass = 'icon';
            if (directory) {

                if (isBack) {
                    imageClass = 'fa fa-level-up fa-5x itemFolder';
                    useCSS = true;
                } else if (!no_access) {
                    imageClass = 'fa fa-folder fa-5x itemFolder';
                    useCSS = true;
                } else {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                }

            } else {

                imageClass = 'itemIcon';

                if (no_access) {
                    imageClass = 'fa fa-lock fa-5x itemFolder';
                    useCSS = true;
                } else {

                    if (utils.isImage(obj.path)) {

                        var url = this.getImageUrl(obj);
                        if (url) {
                            obj.icon = url;
                        } else {
                            obj.icon = thiz.config.REPO_URL + '/' + obj.path;
                        }

                        imageClass = 'imageFile';

                    } else {
                        imageClass = 'fa fa-5x ' + utils.getIconClass(obj.path);
                        useCSS = true;
                    }
                }

            }

            label = obj.name;

            var folderContent =  '<span style="' + iconStyle + '" class="fa fa-6x '+imageClass +'"></span>';

            if (utils.isImage(obj.path)) {

                var url = this.getImageUrl(obj);
                if (url) {
                    obj.icon = url;
                } else {
                    obj.icon = thiz.config.REPO_URL + '/' + obj.path;
                }

                imageClass = '';
                contentClass = 'image';
                folderContent = '<div style="" class="tile-content image">' +
                    '<img class=\"' + imageClass + '\" src="' + obj.icon + '"/>' +
                    '</div>';

                useCSS = true;
                isImage = true;

            }
            var label2 = label + '\n' + obj.modified;
            var html = '<div title="' + label2 +'" class="tile-content ' + contentClass +'">'+
                folderContent +
                '</div>'+

                '<div class="brand opacity">'+
                '<span class="thumbText text opacity ellipsis" style="">'+
                label +
                '</span>'+
                '</div>';

            if (useCSS) {
                div.innerHTML = html;
                return div;
            }


            if (directory) {
                div.innerHTML = html;
            } else {
                div.innerHTML = '<img class=\"' + imageClass + '\" src="' + obj.icon + '"/>&nbsp;<div class="name">' + obj.name + '</div>';
            }
            return div;

        },
        getImageUrl: function (item) {
            var fileManager = this.ctx.getFileManager();
            if (fileManager && fileManager) {
                var params = null;
                if (this.resizeThumb) {
                    params = {
                        width: this.thumbSize
                    }
                }
                return fileManager.getImageUrl(item, null, params);
            }
            return null;
        }
    });
});
define('dgrid/util/has-css3',[
	'dojo/has'
], function (has) {
	// This module defines feature tests for CSS3 features such as transitions.
	// The css-transitions, css-transforms, and css-transforms3d has-features
	// can report either boolean or string:
	// * false indicates no support
	// * true indicates prefix-less support
	// * string indicates the vendor prefix under which the feature is supported

	var cssPrefixes = ['ms', 'O', 'Moz', 'Webkit'];

	function testStyle(element, property) {
		var style = element.style,
			i;

		if (property in style) {
			// Standard, no prefix
			return true;
		}
		property = property.slice(0, 1).toUpperCase() + property.slice(1);
		for (i = cssPrefixes.length; i--;) {
			if ((cssPrefixes[i] + property) in style) {
				// Vendor-specific css property prefix
				return cssPrefixes[i];
			}
		}

		// Otherwise, not supported
		return false;
	}

	has.add('css-transitions', function (global, doc, element) {
		return testStyle(element, 'transitionProperty');
	});

	has.add('css-transforms', function (global, doc, element) {
		return testStyle(element, 'transform');
	});

	has.add('css-transforms3d', function (global, doc, element) {
		return testStyle(element, 'perspective');
	});

	has.add('transitionend', function () {
		// Infer transitionend event name based on CSS transitions has-feature.
		var tpfx = has('css-transitions');
		if (!tpfx) {
			return false;
		}
		if (tpfx === true) {
			return 'transitionend';
		}
		return {
			ms: 'MSTransitionEnd',
			O: 'oTransitionEnd',
			Moz: 'transitionend',
			Webkit: 'webkitTransitionEnd'
		}[tpfx];
	});

	return has;
});

define('requirejs-dplugins/has',["module"], function (module) {
	var cache = (module.config && module.config()) || {};
	var tokensRE = /[\?:]|[^:\?]+/g;

	function resolve(resource, has, isBuild) {
		var tokens = resource.match(tokensRE);
		var i = 0;
		var get = function (skip) {
			var term = tokens[i++];
			if (term === ":") {
				// empty string module name; therefore, no dependency
				return "";
			} else {
				// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
				if (tokens[i++] === "?") {
					var hasResult = has(term);
					if (hasResult === undefined && isBuild) {
						return undefined;
					} else if (!skip && hasResult) {
						// matched the feature, get the first value from the options
						return get();
					} else {
						// did not match, get the second value, passing over the first
						get(true);
						return get(skip);
					}
				}
				// A module or empty string.
				// This allows to tell apart "undefined flag at build time" and "no module required" cases.
				return term || "";
			}
		};
		return get();
	}

	function forEachModule(tokens, callback) {
		for (var i = 0; i < tokens.length; i++) {
			if (tokens[i] !== ":" && tokens[i] !== "?" && tokens[i + 1] !== "?") {
				callback(tokens[i], i);
			}
		}
	}

	var has = function (name) {
		var global = (function () {
			return this;
		})();

		return typeof cache[name] === "function" ? (cache[name] = cache[name](global)) : cache[name]; // Boolean
	};

	has.cache = cache;

	has.add = function (name, test, now, force) {
		if (!has("builder")) {
			(typeof cache[name] === "undefined" || force) && (cache[name] = test);
			return now && has(name);
		}
	};

	has.normalize = function (resource, normalize) {
		var tokens = resource.match(tokensRE);

		forEachModule(tokens, function (module, index) {
			tokens[index] = normalize(module);
		});

		return tokens.join("");
	};

	has.load = function (resource, req, onLoad, config) {
		config = config || {};

		if (!resource) {
			onLoad();
			return;
		}

		var mid = resolve(resource, has, config.isBuild);

		if (mid) {
			req([mid], onLoad);
		} else {
			onLoad();
		}
	};

	has.addModules = function (pluginName, resource, addModules) {
		var modulesToInclude = [];

		var mid = resolve(resource, has, true);
		if (mid) {
			modulesToInclude.push(mid);
		} else if (typeof mid === "undefined") {
			// has expression cannot be resolved at build time so include all the modules just in case.
			var tokens = resource.match(tokensRE);
			forEachModule(tokens, function (module) {
				modulesToInclude.push(module);
			});
		}

		addModules(modulesToInclude);
	};

	return has;
});


define('dgrid/Tree',[
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/dom-construct',
	'dojo/dom-class',
	'dojo/on',
	'dojo/query',
	'dojo/when',
	'./util/has-css3',
	'./Grid',
	'xdojo/has!touch?./util/touch'
], function (declare, lang, arrayUtil, aspect, domConstruct, domClass, on, querySelector, when, has, Grid, touchUtil) {

	return declare(null, {
		// collapseOnRefresh: Boolean
		//		Whether to collapse all expanded nodes any time refresh is called.
		collapseOnRefresh: false,

		// enableTreeTransitions: Boolean
		//		Enables/disables all expand/collapse CSS transitions.
		enableTreeTransitions: false,

		// treeIndentWidth: Number
		//		Width (in pixels) of each level of indentation.
		treeIndentWidth: 9,

		constructor: function () {
			this._treeColumnListeners = [];
		},

		shouldExpand: function (row, level, previouslyExpanded) {
			// summary:
			//		Function called after each row is inserted to determine whether
			//		expand(rowElement, true) should be automatically called.
			//		The default implementation re-expands any rows that were expanded
			//		the last time they were rendered (if applicable).

			return previouslyExpanded;
		},

		expand: function (target, expand, noTransition) {
			// summary:
			//		Expands the row corresponding to the given target.
			// target: Object
			//		Row object (or something resolvable to one) to expand/collapse.
			// expand: Boolean?
			//		If specified, designates whether to expand or collapse the row;
			//		if unspecified, toggles the current state.

			if (!this._treeColumn) {
				return;
			}

			var grid = this,
				row = target.element ? target : this.row(target),
				isExpanded = !!this._expanded[row.id],
				hasTransitionend = has('transitionend'),
				promise;


			target = row.element;
            if(!target){
                return;
            }
			target = target.className.indexOf('dgrid-expando-icon') > -1 ? target :
				querySelector('.dgrid-expando-icon', target)[0];

			noTransition = noTransition || !this.enableTreeTransitions;

			if (target && target.mayHaveChildren && (noTransition || expand !== isExpanded)) {
				// toggle or set expand/collapsed state based on optional 2nd argument
				var expanded = expand === undefined ? !this._expanded[row.id] : expand;

				// update the expando display
				domClass.replace(target, 'ui-icon-triangle-1-' + (expanded ? 'se' : 'e'),
					'ui-icon-triangle-1-' + (expanded ? 'e' : 'se'));
				domClass.toggle(row.element, 'dgrid-row-expanded', expanded);

				var rowElement = row.element,
					container = rowElement.connected,
					containerStyle,
					scrollHeight,
					options = {};

				if (!container) {
					// if the children have not been created, create a container, a preload node and do the
					// query for the children
					container = options.container = rowElement.connected =
						domConstruct.create('div', { className: 'dgrid-tree-container' }, rowElement, 'after');
					var query = function (options) {
						var childCollection = grid._renderedCollection.getChildren(row.data),
								results;
						if (grid.sort) {
							childCollection = childCollection.sort(grid.sort);
						}
						if (childCollection.track && grid.shouldTrackCollection) {
							container._rows = options.rows = [];

							childCollection = childCollection.track();

							// remember observation handles so they can be removed when the parent row is destroyed
							container._handles = [
								childCollection.tracking,
								grid._observeCollection(childCollection, container, options)
							];
						}
						if ('start' in options) {
							var rangeArgs = {
								start: options.start,
								end: options.start + options.count
							};
							results = childCollection.fetchRange(rangeArgs);
						} else {
							results = childCollection.fetch();
						}
						return results;
					};
					// Include level information on query for renderQuery case
					if ('level' in target) {
						query.level = target.level;
					}

					// Add the query to the promise chain
					if (this.renderQuery) {
						promise = this.renderQuery(query, options);
					}
					else {
						// If not using OnDemandList, we don't need preload nodes,
						// but we still need a beforeNode to pass to renderArray,
						// so create a temporary one
						var firstChild = domConstruct.create('div', null, container);
						promise = this._trackError(function () {
							return grid.renderQueryResults(
								query(options),
								firstChild,
								lang.mixin({ rows: options.rows },
									'level' in query ? { queryLevel: query.level } : null
								)
							).then(function (rows) {
								domConstruct.destroy(firstChild);
								return rows;
							});
						});
					}

					if (hasTransitionend) {
						// Update height whenever a collapse/expand transition ends.
						// (This handler is only registered when each child container is first created.)
						on(container, hasTransitionend, this._onTreeTransitionEnd);
					}
				}

				// Show or hide all the children.

				container.hidden = !expanded;
				containerStyle = container.style;

				// make sure it is visible so we can measure it
				if (!hasTransitionend || noTransition) {
					containerStyle.display = expanded ? 'block' : 'none';
					containerStyle.height = '';
				}
				else {
					if (expanded) {
						containerStyle.display = 'block';
						scrollHeight = container.scrollHeight;
						containerStyle.height = '0px';
					}
					else {
						// if it will be hidden we need to be able to give a full height
						// without animating it, so it has the right starting point to animate to zero
						domClass.add(container, 'dgrid-tree-resetting');
						containerStyle.height = container.scrollHeight + 'px';
					}
					// Perform a transition for the expand or collapse.
					setTimeout(function () {
						domClass.remove(container, 'dgrid-tree-resetting');
						containerStyle.height =
							expanded ? (scrollHeight ? scrollHeight + 'px' : 'auto') : '0px';
					}, 0);
				}

				// Update _expanded map.
				if (expanded) {
					this._expanded[row.id] = true;
				}
				else {
					delete this._expanded[row.id];
				}
			}

			// Always return a promise
			return when(promise);
		},

		_configColumns: function () {
			var columnArray = this.inherited(arguments);

			// Set up hash to store IDs of expanded rows (here rather than in
			// _configureTreeColumn so nothing breaks if no column has renderExpando)
			this._expanded = {};

			for (var i = 0, l = columnArray.length; i < l; i++) {
				if (columnArray[i].renderExpando) {
					this._configureTreeColumn(columnArray[i]);
					break; // Allow only one tree column.
				}
			}
			return columnArray;
		},

		insertRow: function (object) {
			var rowElement = this.inherited(arguments);

			// Auto-expand (shouldExpand) considerations
			var row = this.row(rowElement),
				expanded = this.shouldExpand(row, this._currentLevel, this._expanded[row.id]);

			if (expanded) {
				this.expand(rowElement, true, true);
			}

			if (expanded || (!this.collection.mayHaveChildren || this.collection.mayHaveChildren(object))) {
				domClass.add(rowElement, 'dgrid-row-expandable');
			}

			return rowElement; // pass return value through
		},

		removeRow: function (rowElement, preserveDom) {
			var connected = rowElement.connected,
				childOptions = {};
			if (connected) {
				if (connected._handles) {
					arrayUtil.forEach(connected._handles, function (handle) {
						handle.remove();
					});
					delete connected._handles;
				}

				if (connected._rows) {
					childOptions.rows = connected._rows;
				}

				querySelector('>.dgrid-row', connected).forEach(function (element) {
					this.removeRow(element, true, childOptions);
				}, this);

				if (connected._rows) {
					connected._rows.length = 0;
					delete connected._rows;
				}

				if (!preserveDom) {
					domConstruct.destroy(connected);
				}
			}

			this.inherited(arguments);
		},

		_refreshCellFromItem: function (cell, item) {
			if (!cell.column.renderExpando) {
				return this.inherited(arguments);
			}

			this.inherited(arguments, [ cell, item, {
				queryLevel: querySelector('.dgrid-expando-icon', cell.element)[0].level - 1
			}]);
		},

		cleanup: function () {
			this.inherited(arguments);

			if (this.collapseOnRefresh) {
				// Clear out the _expanded hash on each call to cleanup
				// (which generally coincides with refreshes, as well as destroy)
				this._expanded = {};
			}
		},

		_destroyColumns: function () {
			this.inherited(arguments);
			var listeners = this._treeColumnListeners;

			for (var i = listeners.length; i--;) {
				listeners[i].remove();
			}
			this._treeColumnListeners = [];
			this._treeColumn = null;
		},

		_calcRowHeight: function (rowElement) {
			// Override this method to provide row height measurements that
			// include the children of a row
			var connected = rowElement.connected;
			// if connected, need to consider this in the total row height
			return this.inherited(arguments) + (connected ? connected.offsetHeight : 0);
		},

		_configureTreeColumn: function (column) {
			// summary:
			//		Adds tree navigation capability to a column.

			var grid = this;
			var collection = this.collection;
			var colSelector = '.dgrid-content .dgrid-column-' + column.id;
			var clicked; // tracks row that was clicked (for expand dblclick event handling)

			this._treeColumn = column;
			if (!column._isConfiguredTreeColumn) {
				var originalRenderCell = column.renderCell || this._defaultRenderCell;
				column._isConfiguredTreeColumn = true;
				column.renderCell = function (object, value, td, options) {
					// summary:
					//		Renders a cell that can be expanded, creating more rows

					if(!collection){
						return;
					}

					var level = Number(options && options.queryLevel) + 1,
							mayHaveChildren = !collection.mayHaveChildren || collection.mayHaveChildren(object),
							expando, node;

					level = grid._currentLevel = isNaN(level) ? 0 : level;

					expando = column.renderExpando(level, mayHaveChildren,
							grid._expanded[collection.getIdentity(object)], object);

					expando.level = level;
					expando.mayHaveChildren = mayHaveChildren;

					node = originalRenderCell.call(column, object, value, td, options);
					if (node && node.nodeType) {
						td.appendChild(expando);
						td.appendChild(node);
					}
					else {
						td.insertBefore(expando, td.firstChild);
					}
				};

				if (typeof column.renderExpando !== 'function') {
					column.renderExpando = this._defaultRenderExpando;
				}
			}

			var treeColumnListeners = this._treeColumnListeners;
			if (treeColumnListeners.length === 0) {
				// Set up the event listener once and use event delegation for better memory use.
				treeColumnListeners.push(this.on(column.expandOn ||
						'.dgrid-expando-icon:click,' + colSelector + ':dblclick,' + colSelector + ':keydown',
						function (event) {
							var row = grid.row(event);
							if ((!grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(row.data)) &&
									(event.type !== 'keydown' || event.keyCode === 32) && !(event.type === 'dblclick' &&
									clicked && clicked.count > 1 && row.id === clicked.id &&
									event.target.className.indexOf('dgrid-expando-icon') > -1)) {
								grid.expand(row);
							}

							// If the expando icon was clicked, update clicked object to prevent
							// potential over-triggering on dblclick (all tested browsers but IE < 9).
							if (event.target.className.indexOf('dgrid-expando-icon') > -1) {
								if (clicked && clicked.id === grid.row(event).id) {
									clicked.count++;
								}
								else {
									clicked = {
										id: grid.row(event).id,
										count: 1
									};
								}
							}
						})
				);

				if (has('touch')) {
					// Also listen on double-taps of the cell.
					treeColumnListeners.push(this.on(touchUtil.selector(colSelector, touchUtil.dbltap),
							function () {
								grid.expand(this);
							}));
				}
			}

			/*
			 column.renderCell = function (object, value, td, options) {
			 // summary:
			 //		Renders a cell that can be expanded, creating more rows

			 var grid = column.grid,
			 level = Number(options && options.queryLevel) + 1,
			 mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
			 expando, node;

			 level = grid._currentLevel = isNaN(level) ? 0 : level;
			 expando = column.renderExpando(level, mayHaveChildren,
			 grid._expanded[grid.collection.getIdentity(object)], object);
			 expando.level = level;
			 expando.mayHaveChildren = mayHaveChildren;

			 node = originalRenderCell.call(column, object, value, td, options);
			 if (node && node.nodeType) {
			 td.appendChild(expando);
			 td.appendChild(node);
			 }
			 else {
			 td.insertBefore(expando, td.firstChild);
			 }
			 };
			 *//*
			if (!column.originalRenderCell)
			{
				column.originalRenderCell = column.renderCell || this._defaultRenderCell;
				column.renderCell = function (object, value, td, options) {
					// summary:
					//              Renders a cell that can be expanded, creating more rows
					var grid = column.grid,
							level = Number(options && options.queryLevel) + 1,
							mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
							expando,
							node;

					level = grid._currentLevel = isNaN(level) ? 0 : level;
					expando = column.renderExpando(level, mayHaveChildren,
							grid._expanded[grid.collection.getIdentity(object)], object);
					expando.level = level;
					expando.mayHaveChildren = mayHaveChildren;
					node = column.originalRenderCell(object, value, td, options);
					if (node && node.nodeType) {
						td.appendChild(expando);
						td.appendChild(node);
					}
					else {
						td.insertBefore(expando, td.firstChild);
					}
				};
			}
			*/
		},

		_defaultRenderExpando: function (level, hasChildren, expanded) {
			// summary:
			//		Default implementation for column.renderExpando.
			//		NOTE: Called in context of the column definition object.
			// level: Number
			//		Level of indentation for this row (0 for top-level)
			// hasChildren: Boolean
			//		Whether this item may have children (in most cases this determines
			//		whether an expando icon should be rendered)
			// expanded: Boolean
			//		Whether this item is currently in expanded state
			// object: Object
			//		The item that this expando pertains to

			var dir = this.grid.isRTL ? 'right' : 'left',
				cls = 'dgrid-expando-icon';
			if (hasChildren) {
				cls += ' ui-icon ui-icon-triangle-1-' + (expanded ? 'se' : 'e');
			}
			return domConstruct.create('div', {
				className: cls,
				innerHTML: '&nbsp;',
				style: 'margin-' + dir + ': ' + (level * this.grid.treeIndentWidth) + 'px; float: ' + dir + ';'
			});
		},

		_onNotification: function (rows, event) {
			if (event.type === 'delete') {
				delete this._expanded[event.id];
			}
			this.inherited(arguments);
		},

		_onTreeTransitionEnd: function (event) {
			var container = this,
				height = this.style.height;
			if (height) {
				// After expansion, ensure display is correct;
				// after collapse, set display to none to improve performance
				this.style.display = height === '0px' ? 'none' : 'block';
			}

			// Reset height to be auto, so future height changes (from children
			// expansions, for example), will expand to the right height.
			if (event) {
				// For browsers with CSS transition support, setting the height to
				// auto or "" will cause an animation to zero height for some
				// reason, so temporarily set the transition to be zero duration
				domClass.add(this, 'dgrid-tree-resetting');
				setTimeout(function () {
					// Turn off the zero duration transition after we have let it render
					domClass.remove(container, 'dgrid-tree-resetting');
				}, 0);
			}
			// Now set the height to auto
			this.style.height = '';
		}
	});
});
/** @module xgrid/TreeRenderer **/
define('xgrid/TreeRenderer',[
    "xdojo/declare",
    'xgrid/Renderer',
    'dgrid/Tree',
    "dojo/keys",
    "dojo/on",
    "xide/$"
], function (declare, Renderer, Tree, keys, on, $) {

    function KEYBOARD_HANDLER(evt) {
        this.onTreeKey(evt);
        var thiz = this;
        if (thiz.isThumbGrid) {
            return;
        }
        if (evt.keyCode == keys.LEFT_ARROW || evt.keyCode == keys.RIGHT_ARROW || evt.keyCode == keys.HOME || evt.keyCode == keys.END) {
        } else {
            return;
        }
        var target = evt.target;
        if (target) {
            if (target.className.indexOf('InputInner') != -1 || target.className.indexOf('input') != -1 || evt.target.type === 'text') {
                return;
            }
        }

        var row = this.row(evt);
        if (!row || !row.data) {
            return;
        }
        var data = row.data,
            isExpanded = this._isExpanded(data),
            store = this.collection,
            storeItem = store.getSync(data[store.idProperty]);

        //old back compat: var children = data.getChildren ? data.getChildren() :  storeItem && storeItem.children ? null : store.children ? store.children(storeItem) : null;
        var children = data.getChildren ? data.getChildren() : storeItem && storeItem.children ? storeItem.children : null;

        //xideve hack
        var wasStoreBased = false;
        if (children == null && store.getChildrenSync && storeItem) {
            children = store.getChildrenSync(storeItem);
            if (children && children.length) {
                wasStoreBased = true;
            } else {
                children = null;
            }
        }

        var isFolder = storeItem ? (storeItem.isDir || storeItem.directory || storeItem.group) : false;
        if (!isFolder && wasStoreBased && children) {
            isFolder = true;
        }
        //xideve hack end

        var firstChild = children ? children[0] : false,
            focused = this._focusedNode,
            last = focused ? this.down(focused, children ? children.length : 0, true) : null,
            loaded = (storeItem._EX === true || storeItem._EX == null);

        var selection = this.getSelection ? this.getSelection() : [storeItem];
        //var selection2 = this.getSelection ? this._getSelected() : [storeItem];

        var down = this.down(focused, -1, true),
            up = this.down(focused, 1, true),
            defaultSelectArgs = {
                focus: true,
                append: false,
                delay: 1
            };

        if (firstChild && firstChild._reference) {
            var _b = store.getSync(firstChild._reference);
            if (_b) {
                firstChild = _b;
            }
        }
        if (evt.keyCode == keys.END) {
            if (isExpanded && isFolder && last && last.element !== focused) {
                this.select(last, null, true, defaultSelectArgs);
                return;
            }
        }

        function expand(what, expand) {
            _.each(what, function (item) {
                var _row = thiz.row(item);
                if (_row && _row.element) {
                    thiz.expand(_row, expand, true);
                }
            });
        }

        if (evt.keyCode == keys.LEFT_ARROW) {
            evt.preventDefault();
            if (data[store.parentField]) {
                var item = row.data;
                if (!isExpanded) {
                    var parent = store.getSync(item[store.parentField]);
                    var parentRow = parent ? this.row(parent) : null;
                    //we select the parent only if its rendered at all
                    if (parent && parentRow.element) {
                        return this.select([parent], null, true, defaultSelectArgs);
                    } else {
                        if (down) {
                            return this.select(down, null, true, defaultSelectArgs);
                        } else {
                            on.emit(this.contentNode, "keydown", { keyCode: 36, force: true });
                        }
                    }
                }
            }
            if (row) {
                if (isExpanded) {
                    expand(selection, false);
                } else {
                    this.select(down, null, true, defaultSelectArgs);
                }
            }
        }

        if (evt.keyCode == keys.RIGHT_ARROW) {
            evt.preventDefault();
            // empty folder:
            if (isFolder && loaded && isExpanded && !firstChild) {
                //go to next
                if (up) {
                    return this.select(up, null, true, defaultSelectArgs);
                }
            }

            if (loaded && isExpanded) {
                firstChild && this.select([firstChild], null, true, defaultSelectArgs);
            } else {
                //has children or not loaded yet
                if (firstChild || !loaded || isFolder) {
                    expand(selection, true);
                } else {
                    //case on an cell without no children: select
                    up && this.select(up, null, true, defaultSelectArgs);
                }
            }
        }
    }

    /**
     *
     * @class module:xgrid/TreeRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        _expandOnClickHandle: null,
        _getLabel: function () {
            return "Tree";
        },
        _getIcon: function () {
            return "fa-tree";
        },
        deactivateRenderer: function (renderer) {
            this._expandOnClickHandle && this._expandOnClickHandle.remove();
            if (this.expandOnClick) {
                $(this.domNode).removeClass('openTreeOnClick');
            }
        },
        activateRenderer: function () {
            this._showHeader(true);
            if (this.expandOnClick) {
                this._expandOnClickHandle = this.on("click", this.onTreeClick.bind(this));
                $(this.domNode).addClass('openTreeOnClick');
            }
        },
        __getParent: function (item) {
            if (item && item.getParent) {
                var _parent = item.getParent();
                if (_parent) {
                    var row = this.row(_parent);
                    if (row.element) {
                        return this.__getParent(_parent);
                    } else {
                        return _parent || item;
                    }
                }
            }
            return item;
        },
        /**
         * @TODO: move to xfile
         */
        getCurrentFolder: function () {
            return this.__getParent(this.getRows()[0]);
        },
        _isExpanded: function (item) {
            return !!this._expanded[this.row(item).id];
        },
        onTreeKey: function () {
            this.inherited(arguments);
        },
        onTreeClick: function (e) {
            var row = this.row(e);
            row && this.expand(row, !this._isExpanded(row.data), true);
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var res = this.inherited(arguments);
            this.on("keydown", KEYBOARD_HANDLER.bind(this));
            if (!this.renderers) {
                //we are the only renderer
                this.activateRenderer();
            }
            return res;
        }
    };

    //package via declare
    var Module = declare('xgrid.TreeRenderer', [Renderer, Tree], Implementation);
    Module.Implementation = Implementation;
    Module.KEYBOARD_HANDLER = KEYBOARD_HANDLER;
    return Module;
});
define('dgrid/util/touch',[
	'dojo/on'
	//'dojo/query'
], function (on, query) {
	// This module exposes useful functions for working with touch devices.

	var util = {
		// Overridable defaults related to extension events defined below.
		tapRadius: 10,
		dbltapTime: 250,

		selector: function (selector, eventType, children) {
			// summary:
			//		Reimplementation of on.selector, taking an iOS quirk into account
			return function (target, listener) {
				var bubble = eventType.bubble;
				if (bubble) {
					// the event type doesn't naturally bubble, but has a bubbling form, use that
					eventType = bubble;
				}
				else if (children !== false) {
					// for normal bubbling events we default to allowing children of the selector
					children = true;
				}
				return on(target, eventType, function (event) {
					var eventTarget = event.target;

					// iOS tends to report the text node an event was fired on, rather than
					// the top-level element; this may end up causing errors in selector engines
					if (eventTarget.nodeType === 3) {
						eventTarget = eventTarget.parentNode;
					}

					// there is a selector, so make sure it matches
					while (!query.matches(eventTarget, selector, target)) {
						//debugger;
						if (eventTarget === target || !children || !(eventTarget = eventTarget.parentNode)) {
							return;
						}
					}
					return listener.call(eventTarget, event);
				});
			};
		},

		countCurrentTouches: function (evt, node) {
			// summary:
			//		Given a touch event and a DOM node, counts how many current touches
			//		presently lie within that node.  Useful in cases where an accurate
			//		count is needed but tracking changedTouches won't suffice because
			//		other handlers stop events from bubbling high enough.

			if (!('touches' in evt)) {
				// Not a touch event (perhaps called from a mouse event on a
				// platform supporting touch events)
				return -1;
			}

			var i, numTouches, touch;
			for (i = 0, numTouches = 0; (touch = evt.touches[i]); ++i) {
				if (node.contains(touch.target)) {
					++numTouches;
				}
			}
			return numTouches;
		}
	};

	function handleTapStart(target, listener, evt, prevent) {
		// Common function for handling tap detection.
		// The passed listener will only be fired when and if a touchend is fired
		// which confirms the overall gesture resembled a tap.

		if (evt.targetTouches.length > 1) {
			return; // ignore multitouch
		}

		var start = evt.changedTouches[0],
			startX = start.screenX,
			startY = start.screenY;

		prevent && evt.preventDefault();

		var endListener = on(target, 'touchend', function (evt) {
			var end = evt.changedTouches[0];
			if (!evt.targetTouches.length) {
				// only call listener if this really seems like a tap
				if (Math.abs(end.screenX - startX) < util.tapRadius &&
						Math.abs(end.screenY - startY) < util.tapRadius) {
					prevent && evt.preventDefault();
					listener.call(this, evt);
				}
				endListener.remove();
			}
		});
	}

	function tap(target, listener) {
		// Function usable by dojo/on as a synthetic tap event.
		return on(target, 'touchstart', function (evt) {
			handleTapStart(target, listener, evt);
		});
	}

	function dbltap(target, listener) {
		// Function usable by dojo/on as a synthetic double-tap event.
		var first, timeout;

		return on(target, 'touchstart', function (evt) {
			if (!first) {
				// first potential tap: detect as usual, but with specific logic
				handleTapStart(target, function (evt) {
					first = evt.changedTouches[0];
					timeout = setTimeout(function () {
						first = timeout = null;
					}, util.dbltapTime);
				}, evt);
			}
			else {
				handleTapStart(target, function (evt) {
					// bail out if first was cleared between 2nd touchstart and touchend
					if (!first) {
						return;
					}
					var second = evt.changedTouches[0];
					// only call listener if both taps occurred near the same place
					if (Math.abs(second.screenX - first.screenX) < util.tapRadius &&
							Math.abs(second.screenY - first.screenY) < util.tapRadius) {
						timeout && clearTimeout(timeout);
						first = timeout = null;
						listener.call(this, evt);
					}
				}, evt, true);
			}
		});
	}

	util.tap = tap;
	util.dbltap = dbltap;

	return util;
});
define('dgrid/Selection',[
	'dojo/_base/declare',
	'dojo/dom-class',
	'dojo/on',
	'dojo/has',
	'dojo/aspect',
	'./List',
	'dgrid/util/touch',
	'dojo/query',
	'dojo/_base/sniff',
	'dojo/dom'
], function (declare, domClass, on, has, aspect, List, touchUtil) {

	has.add('dom-comparedocumentposition', function (global, doc, element) {
		return !!element.compareDocumentPosition;
	});

	// Add a feature test for the onselectstart event, which offers a more
	// graceful fallback solution than node.unselectable.
	has.add('dom-selectstart', typeof document.onselectstart !== 'undefined');

	var ctrlEquiv = has('mac') ? 'metaKey' : 'ctrlKey',
		hasUserSelect = has('css-user-select'),
		hasPointer = has('pointer'),
		hasMSPointer = hasPointer && hasPointer.slice(0, 2) === 'MS',
		downType = hasPointer ? hasPointer + (hasMSPointer ? 'Down' : 'down') : 'mousedown',
		upType = hasPointer ? hasPointer + (hasMSPointer ? 'Up' : 'up') : 'mouseup';

	if (hasUserSelect === 'WebkitUserSelect' && typeof document.documentElement.style.msUserSelect !== 'undefined') {
		// Edge defines both webkit and ms prefixes, rendering feature detects as brittle as UA sniffs...
		hasUserSelect = false;
	}

	function makeUnselectable(node, unselectable) {
		// Utility function used in fallback path for recursively setting unselectable
		var value = node.unselectable = unselectable ? 'on' : '',
			elements = node.getElementsByTagName('*'),
			i = elements.length;

		while (--i) {
			if (elements[i].tagName === 'INPUT' || elements[i].tagName === 'TEXTAREA') {
				continue; // Don't prevent text selection in text input fields.
			}
			elements[i].unselectable = value;
		}
	}

	function setSelectable(grid, selectable) {
		// Alternative version of dojo/dom.setSelectable based on feature detection.

		// For FF < 21, use -moz-none, which will respect -moz-user-select: text on
		// child elements (e.g. form inputs).  In FF 21, none behaves the same.
		// See https://developer.mozilla.org/en-US/docs/CSS/user-select
		var node = grid.bodyNode,
			value = selectable ? 'text' : has('ff') < 21 ? '-moz-none' : 'none';

		// In IE10+, -ms-user-select: none will block selection from starting within the
		// element, but will not block an existing selection from entering the element.
		// When using a modifier key, IE will select text inside of the element as well
		// as outside of the element, because it thinks the selection started outside.
		// Therefore, fall back to other means of blocking selection for IE10+.
		// Newer versions of Dojo do not even report msUserSelect (see https://github.com/dojo/dojo/commit/7ae2a43).
		if (hasUserSelect && hasUserSelect !== 'msUserSelect') {
			node.style[hasUserSelect] = value;
		}
		else if (has('dom-selectstart')) {
			// For browsers that don't support user-select but support selectstart (IE<10),
			// we can hook up an event handler as necessary.  Since selectstart bubbles,
			// it will handle any child elements as well.
			// Note, however, that both this and the unselectable fallback below are
			// incapable of preventing text selection from outside the targeted node.
			if (!selectable && !grid._selectstartHandle) {
				grid._selectstartHandle = on(node, 'selectstart', function (evt) {
					var tag = evt.target && evt.target.tagName;

					// Prevent selection except where a text input field is involved.
					if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
						evt.preventDefault();
					}
				});
			}
			else if (selectable && grid._selectstartHandle) {
				grid._selectstartHandle.remove();
				delete grid._selectstartHandle;
			}
		}
		else {
			// For browsers that don't support either user-select or selectstart (Opera),
			// we need to resort to setting the unselectable attribute on all nodes
			// involved.  Since this doesn't automatically apply to child nodes, we also
			// need to re-apply it whenever rows are rendered.
			makeUnselectable(node, !selectable);
			if (!selectable && !grid._unselectableHandle) {
				grid._unselectableHandle = aspect.after(grid, 'renderRow', function (row) {
					makeUnselectable(row, true);
					return row;
				});
			}
			else if (selectable && grid._unselectableHandle) {
				grid._unselectableHandle.remove();
				delete grid._unselectableHandle;
			}
		}
	}

	return declare(null, {
		// summary:
		//		Add selection capabilities to a grid. The grid will have a selection property and
		//		fire "dgrid-select" and "dgrid-deselect" events.

		// selectionDelegate: String
		//		Selector to delegate to as target of selection events.
		selectionDelegate: '.dgrid-row',

		// selectionEvents: String|Function
		//		Event (or comma-delimited events, or extension event) to listen on
		//		to trigger select logic.
		selectionEvents: downType + ',' + upType + ',dgrid-cellfocusin',

		// selectionTouchEvents: String|Function
		//		Event (or comma-delimited events, or extension event) to listen on
		//		in addition to selectionEvents for touch devices.
		selectionTouchEvents: has('touch') ? touchUtil.tap : null,

		// deselectOnRefresh: Boolean
		//		If true, the selection object will be cleared when refresh is called.
		deselectOnRefresh: true,

		// allowSelectAll: Boolean
		//		If true, allow ctrl/cmd+A to select all rows.
		//		Also consulted by the selector plugin for showing select-all checkbox.
		allowSelectAll: false,

		// selection:
		//		An object where the property names correspond to
		//		object ids and values are true or false depending on whether an item is selected
		selection: {},

		// selectionMode: String
		//		The selection mode to use, can be "none", "multiple", "single", or "extended".
		selectionMode: 'extended',

		// allowTextSelection: Boolean
		//		Whether to still allow text within cells to be selected.  The default
		//		behavior is to allow text selection only when selectionMode is none;
		//		setting this property to either true or false will explicitly set the
		//		behavior regardless of selectionMode.
		allowTextSelection: undefined,

		// _selectionTargetType: String
		//		Indicates the property added to emitted events for selected targets;
		//		overridden in CellSelection
		_selectionTargetType: 'rows',

		create: function () {
			this.selection = {};
			return this.inherited(arguments);
		},
		postCreate: function () {
			this.inherited(arguments);

			this._initSelectionEvents();

			// Force selectionMode setter to run
			var selectionMode = this.selectionMode;
			this.selectionMode = '';
			this._setSelectionMode(selectionMode);
		},

		destroy: function () {
			this.inherited(arguments);

			// Remove any extra handles added by Selection.
			if (this._selectstartHandle) {
				this._selectstartHandle.remove();
			}
			if (this._unselectableHandle) {
				this._unselectableHandle.remove();
			}
			if (this._removeDeselectSignals) {
				this._removeDeselectSignals();
			}
		},

		_setSelectionMode: function (mode) {
			// summary:
			//		Updates selectionMode, resetting necessary variables.

			if (mode === this.selectionMode) {
				return;
			}

			// Start selection fresh when switching mode.
			this.clearSelection();

			this.selectionMode = mode;

			// Compute name of selection handler for this mode once
			// (in the form of _fooSelectionHandler)
			this._selectionHandlerName = '_' + mode + 'SelectionHandler';

			// Also re-run allowTextSelection setter in case it is in automatic mode.
			this._setAllowTextSelection(this.allowTextSelection);
		},

		_setAllowTextSelection: function (allow) {
			if (typeof allow !== 'undefined') {
				setSelectable(this, allow);
			}
			else {
				setSelectable(this, this.selectionMode === 'none');
			}
			this.allowTextSelection = allow;
		},

		_handleSelect: function (event, target) {
			// Don't run if selection mode doesn't have a handler (incl. "none"), target can't be selected,
			// or if coming from a dgrid-cellfocusin from a mousedown
			if (!this[this._selectionHandlerName] || !this.allowSelect(this.row(target)) ||
					(event.type === 'dgrid-cellfocusin' && event.parentType === 'mousedown') ||
					(event.type === upType && target !== this._waitForMouseUp)) {
				return;
			}
			this._waitForMouseUp = null;
			this._selectionTriggerEvent = event;

			// Don't call select handler for ctrl+navigation
			if (!event.keyCode || !event.ctrlKey || event.keyCode === 32) {
				// If clicking a selected item, wait for mouseup so that drag n' drop
				// is possible without losing our selection
				if (!event.shiftKey && event.type === downType && this.isSelected(target)) {
					this._waitForMouseUp = target;
				}
				else {
					this[this._selectionHandlerName](event, target);
				}
			}
			this._selectionTriggerEvent = null;
		},

		_singleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "single" mode, where only one target may be
			//		selected at a time.

			var ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv];
			if (this._lastSelected === target) {
				// Allow ctrl to toggle selection, even within single select mode.
				this.select(target, null, !ctrlKey || !this.isSelected(target));
			}
			else {
				this.clearSelection();
				this.select(target);
				this._lastSelected = target;
			}
		},

		_multipleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "multiple" mode, where shift can be held to
			//		select ranges, ctrl/cmd can be held to toggle, and clicks/keystrokes
			//		without modifier keys will add to the current selection.

			var lastRow = this._lastSelected,
				ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv],
				value;

			if (!event.shiftKey) {
				// Toggle if ctrl is held; otherwise select
				value = ctrlKey ? null : true;
				lastRow = null;
			}

			this.select(target, lastRow, value,null,event.type.indexOf('mouse')!==-1 ? 'mouse' : event.type);

			if (!lastRow) {
				// Update reference for potential subsequent shift+select
				// (current row was already selected above)
				this._lastSelected = target;
			}
		},

		_extendedSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "extended" mode, which is like multiple mode
			//		except that clicks/keystrokes without modifier keys will clear
			//		the previous selection.

			// Clear selection first for right-clicks outside selection and non-ctrl-clicks;
			// otherwise, extended mode logic is identical to multiple mode
			if (event.button === 2 ? !this.isSelected(target) :
					!(event.keyCode ? event.ctrlKey : event[ctrlEquiv])) {
				this.clearSelection(null, true);
			}
			this._multipleSelectionHandler(event, target);
		},

		_toggleSelectionHandler: function (event, target) {
			// summary:
			//		Selection handler for "toggle" mode which simply toggles the selection
			//		of the given target.  Primarily useful for touch input.

			this.select(target, null, null);
		},

		_initSelectionEvents: function () {
			// summary:
			//		Performs first-time hookup of event handlers containing logic
			//		required for selection to operate.

			var grid = this,
				contentNode = this.contentNode,
				selector = this.selectionDelegate;

			this._selectionEventQueues = {
				deselect: [],
				select: []
			};

			if (has('touch') && !has('pointer') && this.selectionTouchEvents) {
				// Listen for taps, and also for mouse/keyboard, making sure not
				// to trigger both for the same interaction
				on(contentNode, touchUtil.selector(selector, this.selectionTouchEvents), function (evt) {
					grid._handleSelect(evt, this);
					grid._ignoreMouseSelect = this;
				});
				on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
					if (grid._ignoreMouseSelect !== this) {
						grid._handleSelect(event, this);
					}
					else if (event.type === upType) {
						grid._ignoreMouseSelect = null;
					}
				});
			}
			else {
				// Listen for mouse/keyboard actions that should cause selections
				on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
					grid._handleSelect(event, this);
				});
			}

			// Also hook up spacebar (for ctrl+space)
			if (this.addKeyHandler) {
				this.addKeyHandler(32, function (event) {
					grid._handleSelect(event, event.target);
				});
			}

			// If allowSelectAll is true, bind ctrl/cmd+A to (de)select all rows,
			// unless the event was received from an editor component.
			// (Handler further checks against _allowSelectAll, which may be updated
			// if selectionMode is changed post-init.)
			if (this.allowSelectAll) {
				this.on('keydown', function (event) {
					if (event[ctrlEquiv] && event.keyCode === 65 &&
							!/\bdgrid-input\b/.test(event.target.className)) {
						event.preventDefault();
						grid[grid.allSelected ? 'clearSelection' : 'selectAll']();
					}
				});
			}

			// Update aspects if there is a collection change
			if (this._setCollection) {
				aspect.before(this, '_setCollection', function (collection) {
					grid._updateDeselectionAspect(collection);
				});
			}
			this._updateDeselectionAspect();
		},

		_updateDeselectionAspect: function (collection) {
			// summary:
			//		Hooks up logic to handle deselection of removed items.
			//		Aspects to a trackable collection's notify method if applicable,
			//		or to the list/grid's removeRow method otherwise.

			var self = this,
				signals;

			function ifSelected(rowArg, methodName,why) {
				// Calls a method if the row corresponding to the object is selected.
				var row = self.row(rowArg),
					selection = row && self.selection[row.id];
				// Is the row currently in the selection list.
				if (selection) {
					self[methodName](row,null,true,null,why);
				}
			}

			// Remove anything previously configured
			if (this._removeDeselectSignals) {
				this._removeDeselectSignals();
			}

			if (collection && collection.track && this._observeCollection) {
				signals = [
					aspect.before(this, '_observeCollection', function (collection) {
						signals.push(
							collection.on('delete', function (event) {
								if (typeof event.index === 'undefined') {
									// Call deselect on the row if the object is being removed.  This allows the
									// deselect event to reference the row element while it still exists in the DOM.
									ifSelected(event.id, 'deselect');
								}
							})
						);
					}),
					aspect.after(this, '_observeCollection', function (collection) {
						signals.push(
							collection.on('update', function (event) {
								if (typeof event.index !== 'undefined') {
									// When List updates an item, the row element is removed and a new one inserted.
									// If at this point the object is still in grid.selection,
									// then call select on the row so the element's CSS is updated.
									ifSelected(collection.getIdentity(event.target), 'select','update');
								}
							})
						);
					}, true)
				];
			}
			else {
				signals = [
					aspect.before(this, 'removeRow', function (rowElement, preserveDom) {
						var row;
						if (!preserveDom) {
							row = this.row(rowElement);
							// if it is a real row removal for a selected item, deselect it
							if (row && (row.id in this.selection)) {
								this.deselect(row);
							}
						}
					})
				];
			}

			this._removeDeselectSignals = function () {
				for (var i = signals.length; i--;) {
					signals[i].remove();
				}
				signals = [];
			};
		},

		allowSelect: function () {
			// summary:
			//		A method that can be overriden to determine whether or not a row (or
			//		cell) can be selected. By default, all rows (or cells) are selectable.
			// target: Object
			//		Row object (for Selection) or Cell object (for CellSelection) for the
			//		row/cell in question
			return true;
		},

		_fireSelectionEvent: function (type) {
			// summary:
			//		Fires an event for the accumulated rows once a selection
			//		operation is finished (whether singular or for a range)

			var queue = this._selectionEventQueues[type],
				triggerEvent = this._selectionTriggerEvent,
				eventObject;

			eventObject = {
				bubbles: true,
				grid: this
			};
			if (triggerEvent) {
				eventObject.parentType = triggerEvent.type;
			}
			eventObject[this._selectionTargetType] = queue;

			// Clear the queue so that the next round of (de)selections starts anew
			this._selectionEventQueues[type] = [];

			on.emit(this.contentNode, 'dgrid-' + type, eventObject);
		},

		_fireSelectionEvents: function () {
			var queues = this._selectionEventQueues,
				type;

			for (type in queues) {
				if (queues[type].length) {
					this._fireSelectionEvent(type);
				}
			}
		},

		_select: function (row, toRow, value) {
			// summary:
			//		Contains logic for determining whether to select targets, but
			//		does not emit events.  Called from select, deselect, selectAll,
			//		and clearSelection.

			var selection,
				previousValue,
				element,
				toElement,
				direction;

			if (typeof value === 'undefined') {
				// default to true
				value = true;
			}
			if (!row.element) {
				row = this.row(row);
			}

			// Check whether we're allowed to select the given row before proceeding.
			// If a deselect operation is being performed, this check is skipped,
			// to avoid errors when changing column definitions, and since disabled
			// rows shouldn't ever be selected anyway.
			if (value === false || this.allowSelect(row)) {
				selection = this.selection;
				previousValue = !!selection[row.id];
				if (value === null) {
					// indicates a toggle
					value = !previousValue;
				}
				element = row.element;
				if (!value && !this.allSelected) {
					delete this.selection[row.id];
				}
				else {
					selection[row.id] = value;
				}
				if (element) {
					// add or remove classes as appropriate
					if (value) {
						domClass.add(element, 'dgrid-selected' +
							(this.addUiClasses ? ' ui-state-active' : ''));
					}
					else {
						domClass.remove(element, 'dgrid-selected ui-state-active');
					}
				}
				if (value !== previousValue && element) {
					// add to the queue of row events
					this._selectionEventQueues[(value ? '' : 'de') + 'select'].push(row);
				}

				if (toRow) {
					if (!toRow.element) {
						toRow = this.row(toRow);
					}

					if (!toRow) {
						this._lastSelected = element;
						console.warn('The selection range has been reset because the ' +
							'beginning of the selection is no longer in the DOM. ' +
							'If you are using OnDemandList, you may wish to increase ' +
							'farOffRemoval to avoid this, but note that keeping more nodes ' +
							'in the DOM may impact performance.');
						return;
					}

					toElement = toRow.element;
					if (toElement) {
						direction = this._determineSelectionDirection(element, toElement);
						if (!direction) {
							// The original element was actually replaced
							toElement = document.getElementById(toElement.id);
							direction = this._determineSelectionDirection(element, toElement);
						}
						while (row.element !== toElement && (row = this[direction](row))) {
							this._select(row, null, value);
						}
					}
				}
			}
		},

		// Implement _determineSelectionDirection differently based on whether the
		// browser supports element.compareDocumentPosition; use sourceIndex for IE<9
		_determineSelectionDirection: has('dom-comparedocumentposition') ? function (from, to) {
			var result = to.compareDocumentPosition(from);
			if (result & 1) {
				return false; // Out of document
			}
			return result === 2 ? 'down' : 'up';
		} : function (from, to) {
			if (to.sourceIndex < 1) {
				return false; // Out of document
			}
			return to.sourceIndex > from.sourceIndex ? 'down' : 'up';
		},

		select: function (row, toRow, value) {
			// summary:
			//		Selects or deselects the given row or range of rows.
			// row: Mixed
			//		Row object (or something that can resolve to one) to (de)select
			// toRow: Mixed
			//		If specified, the inclusive range between row and toRow will
			//		be (de)selected
			// value: Boolean|Null
			//		Whether to select (true/default), deselect (false), or toggle
			//		(null) the row

			this._select(row, toRow, value);
			this._fireSelectionEvents();
		},
		deselect: function (row, toRow) {
			// summary:
			//		Deselects the given row or range of rows.
			// row: Mixed
			//		Row object (or something that can resolve to one) to deselect
			// toRow: Mixed
			//		If specified, the inclusive range between row and toRow will
			//		be deselected

			this.select(row, toRow, false);
		},

		clearSelection: function (exceptId, dontResetLastSelected) {
			// summary:
			//		Deselects any currently-selected items.
			// exceptId: Mixed?
			//		If specified, the given id will not be deselected.

			this.allSelected = false;
			for (var id in this.selection) {
				if (exceptId !== id) {
					this._select(id, null, false);
				}
			}
			if (!dontResetLastSelected) {
				this._lastSelected = null;
			}
			this._fireSelectionEvents();
		},
		selectAll: function () {
			this.allSelected = true;
			this.selection = {}; // we do this to clear out pages from previous sorts
			for (var i in this._rowIdToObject) {
				var row = this.row(this._rowIdToObject[i]);
				this._select(row.id, null, true);
			}
			this._fireSelectionEvents();
		},

		isSelected: function (object) {
			// summary:
			//		Returns true if the indicated row is selected.

			if (typeof object === 'undefined' || object === null) {
				return false;
			}
			if (!object.element) {
				object = this.row(object);
			}
/*
            if (typeof object === 'undefined' || object === null) {
                return false;
            }*/


			// First check whether the given row is indicated in the selection hash;
			// failing that, check if allSelected is true (testing against the
			// allowSelect method if possible)
			return (object.id in this.selection) ? !!this.selection[object.id] :
				this.allSelected && (!object.data || this.allowSelect(object));
		},

		refresh: function () {
			if (this.deselectOnRefresh) {
				this.clearSelection();
			}
			this._lastSelected = null;
			return this.inherited(arguments);
		},

		renderArray: function () {
			var rows = this.inherited(arguments),
				selection = this.selection,
				i,
				row,
				selected;

			for (i = 0; i < rows.length; i++) {
				row = this.row(rows[i]);
				selected = row.id in selection ? selection[row.id] : this.allSelected;
				if (selected) {
					this.select(row, null, selected,null,'renderArray');
				}
			}
			this._fireSelectionEvents();
			return rows;
		}
	});
});

/** @module xide/lodash **/
define('xide/lodash',[],function(){

    /**
     * temp. wanna be shim for lodash til dojo-2/loader lands here
     */
    if(typeof _ !=="undefined"){
        return _;
    }else{
        console.error('error loading lodash',global['_']);
    }
});

/** @module xgrid/Selection **/
define('xgrid/Selection',[
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/utils',
    'dgrid/Selection',
    'dojo/dom-class',
    'dojo/on',
    'dojo/Deferred',
    'xide/lodash',
    'xide/$'
], function (declare, has, types, utils, Selection, domClass, on, Deferred, _, $) {

    /////////////////////////////////////////////////////////////////////
    //
    //  Utils
    //
    //
    /**
     * Event filter
     * @param event
     * @returns {string|boolean}
     */
    function handledEvent(event) {
        // Text boxes and other inputs that can use direction keys should be ignored
        // and not affect cell/row navigation
        var target = event.target;
        return target.type && (event.keyCode === 32);
    }

    /**
     *
     * @param selection to ids
     * @returns {string[]}
     */
    function rows(selection) {
        var result = [];
        if (selection && selection.rows) {
            selection.rows.forEach(function (row) {
                result.push(row.id);
            });
        }
        return result;
    }

    /**
     *
     * @param arrays
     * @returns {*|Array}
     */
    function allArraysAlike(arrays) {
        return _.all(arrays, function (array) {
            return array.length == arrays[0].length && _.difference(array, arrays[0]).length == 0;
        });
    }

    /**
     *
     * @param lastSelection
     * @param newSelection
     * @returns {*|Array}
     */
    function equals(lastSelection, newSelection) {
        var cSelected = rows(lastSelection);
        var nSelected = rows(newSelection);
        return allArraysAlike([cSelected, nSelected]);
    }

    /**
     *
     * @param items
     * @param now
     * @param idProperty
     * @returns {boolean}
     */
    function isSame(items, now, idProperty) {
        var newSelection = items ? items.map(function (item) {
            return item ? item.data || item : {};
        }) : [];
        var idsNew = newSelection.map(function (x) { return x[idProperty]; });
        var idsNow = now.map(function (x) { return x[idProperty]; });
        return (idsNew.join(',') === idsNow.join(','));
    }

    /**
     *
     * @param self {module:xgrid/Base}
     */
    function clearFocused(self) {
        $(self.domNode).find('.dgrid-focus').each(function (i, el) {
            $(el).removeClass('dgrid-focus');
        });
    }

    var _debug = false;
    var debugSelect = false;
    /**
     * @class module:xgrid/Selection
     * @lends module:xgrid/Base
     */
    var Implementation = {
        _lastSelection: null,
        _lastFocused: null,
        _refreshInProgress: null,
        __lastLast: null,
        __lastFirst: null,
        /**
         * Mute any selection events.
         */
        _muteSelectionEvents: true,
        selectAll: function (filter) {
            this.select(this.getRows(filter), null, true, {
                append: false,
                delay: 1
            });
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        setState: function (state) {
            state && state.selection && state.selection.selection && this.select(state.selection.selection, null, true, {
                expand: true,
                append: false,
                scrollInto: true
            }, 'restore');
            return this.inherited(arguments);
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        getState: function (state) {
            state = this.inherited(arguments) || {};
            var selection = this._preserveSelection();
            var thisState = {
                selection: []
            };
            var collection = this.collection;
            var idProp = collection.idProperty;
            if (selection.selection && idProp) {
                _.each(selection.selection, function (item) {
                    if (item && item[idProp]) {
                        thisState.selection.push(item[idProp]);
                    }
                });
            }
            if (selection.focused) {
                thisState.focused = selection.focused.path;
            }
            state.selection = thisState;
            return state;
        },
        /**
         *
         * @param restoreSelection
         * @returns {*}
         */
        refresh: function (restoreSelection) {
            if (!this.isRendered()) {
                return false;
            }
            if (this._refreshInProgress) {
                return this._refreshInProgress;
            }

            var _restore = restoreSelection !== false ? this._preserveSelection() : null,
                thiz = this,
                active = this.isActive(),
                res = this.inherited(arguments);

            this._refreshInProgress = res;

            res && res.then && res.then(function () {
                thiz._refreshInProgress = null;
                active && _restore && thiz._restoreSelection(_restore, 1, !active, 'restore');
            });
            return res;
        },
        /**
         * Normalize an item
         * @param what
         * @returns {*}
         * @private
         */
        _normalize: function (what) {
            if (!what) {
                return null;
            }
            if (!what.element) {
                what = this.cell(what);
            }
            if (what && what.row) {
                what = what.row;
            }
            return what;
        },
        /**
         * save deselect
         */
        deselectAll: function () {
            if (!this._lastSelection) {
                return;
            }
            this.clearSelection();
            this._lastSelection = null;
            this._lastFocused = null;
            $(this.domNode).find('.dgrid-focus').each(function (i, el) {
                $(el).removeClass('dgrid-focus');
            });
            this._emit('selectionChanged', {
                selection: [],
                why: "clear",
                source: 'code'
            });
        },
        invertSelection: function (items) {
            var selection = items || this._getSelection() || [];
            var newSelection = [],
                all = this.getRows();
            _.each(all, function (data) {
                if (selection.indexOf(data) === -1) {
                    newSelection.push(data);
                }
            });
            return this.select(newSelection, null, true, {
                append: false
            });
        },
        runAction: function (action) {
            if (_.isString(action)) {
                action = this.getActionStore().getSync(action);
            }
            if (action.command === 'File/Select/None') {
                this.deselectAll();
                return true;
            }
            if (action.command === 'File/Select/All') {
                this.selectAll();
                return true;
            }
            if (action.command === 'File/Select/Invert') {
                return this.invertSelection();
            }
            return this.inherited(arguments);
        },
        _preserveSelection: function () {
            this.__lastSelection = this._getSelection();
            this._lastFocused = this.getFocused();
            return {
                selection: this._getSelection(),
                focused: this.getFocused()
            };
        },
        _restoreSelection: function (what, delay, silent, reason) {
            var lastFocused = what ? what.focused : this._lastFocused;
            var lastSelection = what ? what.selection : this.__lastSelection;
            if (_.isEmpty(lastSelection)) {
                lastFocused = null;
                this._lastFocused = null;
            } else {
                //restore:
                var dfd = this.select(lastSelection, null, true, {
                    silent: silent != null ? silent : true,
                    append: false,
                    delay: delay != null ? delay : 0
                }, reason);

                if (lastFocused && this.isActive()) {
                    this.focus(this.row(lastFocused));
                }
                return dfd;
            }
        },
        /**
         * get previous item
         * @param from
         * @param domNode
         * @param skipSelected
         * @returns {*}
         */
        getPrevious: function (from, domNode, skipSelected) {
            from = from || this.getFocused(domNode);
            from = this._normalize(from);
            var nextNode = this.cell(this._move(from, -1, "dgrid-row"));
            if (nextNode && nextNode.row) {
                nextNode = nextNode.row[domNode ? 'element' : 'data'];
                if (skipSelected === true) {
                    if (this.isSelected(nextNode)) {
                        //nothing previous here
                        if (from && from.data && from.data == nextNode) {
                            return null;
                        }
                        var _nextNode = this.getPrevious(nextNode, domNode, skipSelected);
                        if (_nextNode) {
                            return _nextNode;
                        }
                    }
                }
            }
            return nextNode;
        },
        /**
         * get next item
         * @param from
         * @param domNode
         * @param skipSelected
         * @returns {*}
         */
        getNext: function (from, domNode, skipSelected) {
            from = from || this.getFocused(domNode);
            from = this._normalize(from);
            var nextNode = this.cell(this._move(from, 1, "dgrid-row"));
            if (nextNode && nextNode.row) {
                nextNode = nextNode.row[domNode ? 'element' : 'data'];
                if (skipSelected === true) {
                    if (this.isSelected(nextNode)) {
                        //nothing previous here
                        if (from && from.data && from.data == nextNode) {
                            return null;
                        }
                        var _nextNode = this.getNext(nextNode, domNode, skipSelected);
                        if (_nextNode) {
                            return _nextNode;
                        }
                    }
                }
            }
            return nextNode;
        },
        /**
         *
         * @param filterFunction
         * @returns selection {Object[] | NULL }
         */
        getSelection: function (filterFunction) {
            return this._getSelection(filterFunction);
        },
        /**
         *
         * @param filterFunction
         * @returns selection {Object[] | NULL }
         */
        _getSelection: function (filterFunction) {
            var result = [];
            var collection = this.collection;
            if (collection) {
                for (var id in this.selection) {
                    var item = this.collection.getSync(id);
                    item && result.push(item);
                }
                if (filterFunction) {
                    return result.filter(filterFunction);
                }
            }
            return result;
        },
        /**
         *
         * @param filterFunction
         * @returns selection {Object[] | NULL }
         */
        _getSelected: function () {
            return $('.dgrid-selected', this.domNode);
        },
        /**
         *
         * @param filter
         * @returns {*}
         */
        getSelectedItem: function (filter) {
            var _selection = this.getSelection(filter);
            if (_selection.length === 1) {
                return _selection[0];
            }
            return null;
        },
        /**
         * Override std::postCreate
         * @returns {*}
         */
        postCreate: function () {
            var thiz = this;
            if (this.options[types.GRID_OPTION.CLEAR_SELECTION_ON_CLICK] === true) {
                var clickHandler = function (evt) {
                    if (evt && evt.target && domClass.contains(evt.target, 'dgrid-content')) {
                        this.deselectAll();
                    }
                }.bind(this);
                this.on("click", function (evt) {
                    clickHandler(evt);
                }.bind(this));
            }
            this.on("dgrid-select", function (data) {
                if (!equals(thiz._lastSelection, data)) {
                    delete thiz._lastSelection;
                    thiz._lastSelection = data;
                    thiz._emit('selectionChanged', {
                        selection: thiz._getSelection(),
                        why: "select",
                        source: data.parentType
                    })
                }
            });
            return this.inherited(arguments);
        },
        /**
         * Override dgrid/Selection::_fireSelectionEvents
         * @returns {*}
         * @private
         */
        _fireSelectionEvents: function () {
            if (this._muteSelectionEvents === true) {
                return;
            }
            return this.inherited(arguments);
        },
        __select: function (items, toRow, select, dfd, reason) {
            _.each(items, function (item) {
                if (item) {
                    var _row = this.row(item);
                    if (_row) {
                        this._select(_row, toRow, select);
                    }
                }
            }, this);
            dfd && dfd.resolve(items);
            this._muteSelectionEvents = false;
            this._fireSelectionEvents();
            var rows = this.getRows();
            if (rows && rows.length && items && items.length && select && reason && reason !== 'mouse') {
                //trigger bounce if we hit
                var _last = items[items.length - 1];
                if (rows[rows.length - 1] == _last) {
                    if (this.__lastLast && this.__lastLast == _last) {
                        reason.indexOf('pointer') === -1 && this._emit('bounced', {
                            direction: 1,
                            item: _last
                        });
                        return;
                    }
                    this.__lastLast = _last;
                } else {
                    this.__lastLast = null;
                }


                var _first = items[0];
                if (rows[0] == _first) {
                    if (this.__lastFirst && this.__lastFirst == _first) {
                        reason.indexOf('pointer') === -1 && this._emit('bounced', {
                            direction: -1,
                            item: _first
                        })
                        return;
                    }
                    this.__lastFirst = _first;
                } else {
                    this.__lastFirst = null;
                }
            } else {
                this.__lastFirst = null;
            }
        },
        /**
         * Overrides dgrid selection
         * @param mixed
         * @param toRow {object|null} preserve super
         * @param select {boolean|null} preserve super
         * @param options {object}
         * @param options.focus {boolean}
         * @param options.silent {boolean}
         * @param options.append {boolean}
         * @param options.expand {boolean}
         * @param options.scrollInto {boolean}
         * @param reason {string} the origin event's type
         * returns dojo/Deferred
         */
        select: function (mixed, toRow, select, options, reason) {
            clearTimeout(this._selectTimer);
            this._selectTimer = null;
            var isMouse = reason === 'mouse',
                isPrioritySelect = isMouse || reason === 'update',
                isActive = this.isActive(),
                def = new Deferred();

            reason = reason || '';

            //sanitize/defaults
            options = options || {};

            if (isPrioritySelect) {
                isActive = true;
            }
            if (isMouse) {
                options.focus = true;
            }
            select = select === null ? true : select;
            var delay = options.delay || 0,
                self = this,
                coll = this.collection,
                idProperty = coll.idProperty;

            //silence selection change (batch or state restoring job)
            if (options.silent === true) {
                self._muteSelectionEvents = true;
            }

            //normalize to array
            var items = utils.isArray(mixed) ? mixed : [mixed];
            if (_.isEmpty(items)) {
                return;
            }
            var _newItems = [];

            //indices to items
            if (_.isNumber(items[0])) {
                var rows = self.getRows();
                _.each(items, function (item) {
                    _newItems.push(rows[item]);
                });
                items = _newItems;
            } else if (_.isString(items[0])) {
                _.each(items, function (item) {
                    var _item = coll.getSync(item);
                    if (_item) {
                        _newItems.push(_item);
                    }
                });

                items = _newItems;
            } else if (items && items[0] && items[0].tagName) {
                _.each(items, function (item) {
                    _newItems.push(self.row(item).data);
                });
                items = _newItems;
            }

            if (!items.length) {
                if (has('debug')) {
                    _debug && console.log('nothing to select!');
                }
                def.resolve();
                return def;
            }


            if (has('debug')) {
                debugSelect && console.log('selected : ', _.map(items, "name"));
            }

            var _last = this._lastSelection ? this._lastSelection.rows : [];
            var now = _last.map(function (x) { return x.data; });

            var isEqual = isSame(items, now, idProperty);

            //store update
            if (reason === 'update' && select) {
                options.focus = true;
                options.append = false;
                options.delay = 1;
                //this.focus();
            }

            if (reason === 'dgrid-cellfocusin') {
                options.focus = true;
            }

            //clear previous selection
            if (options.append === false && select && !isEqual) {
                self.clearSelection(items);
                clearFocused(self);
            }

            if (isEqual && (reason === 'update' || reason === 'dgrid-cellfocusin')) {
                if (options.focus) {
                    clearFocused(self);
                    self.focus(items[0]);
                }
                return;
            }

            //focus
            if (options.focus === true) {
                if (options.expand) {
                    if (!self.isRendered(items[0])) {
                        self._expandTo(items[0]);
                    }
                }
            }
            if (options.expand) {
                if (!self.isRendered(items[0])) {
                    self._expandTo(items[0]);
                }
            }
            if (options.scrollInto && reason !== 'restore') {
                var row = this.row(items[0]);
                if (row.element) {
                    row.element.scrollIntoView();
                }
            }

            if (delay && items.length) {
                this._selectTimer = setTimeout(function () {
                    if (self.destroyed || !self.collection) {
                        return;
                    }
                    if (options.append === false) {
                        self.clearSelection();
                    }
                    clearFocused(self);
                    self.focus(items[0], false);
                    self.__select(items, toRow, select, def, reason);
                }, delay);
            } else {
                self.__select(items, toRow, select, def, reason);
            }
            return def;
        },

        _setLast: function (selection) {
            var _ids = [];
            for (var i = 0; i < selection.length; i++) {
                var obj = selection[i];
                _ids.push(this.collection.getIdentity(obj));
            }
        },
        isExpanded: function (item) {
            item = this._normalize('root');
            return !!this._expanded[item.id];
        },
        _expandTo: function (item) {
            if (!item) {
                return;
            }
            var store = this.collection;
            if (_.isString(item)) {
                item = store.getSync(item);
            }
            var parent = store.getSync(item[store.parentField]) || item.getParent ? item.getParent() : null;
            if (parent) {
                if (!this.isRendered(parent)) {
                    this._expandTo(parent);
                } else {
                    if (!this.isExpanded(parent)) {
                        this.expand(parent, true, true);
                    }
                    if (!this.isExpanded(item)) {
                        this.expand(item, true, true);
                    }
                }
            }
        },
        startup: function () {
            var result = this.inherited(arguments);
            //we want keyboard navigation also when nothing is selected
            this.addHandle('keyup', on(this.domNode, 'keyup', function (event) {
                // For now, don't squash browser-specific functionality by letting
                // ALT and META function as they would natively
                if (event.metaKey || event.altKey) {
                    return;
                }
                var handler = this['keyMap'][event.keyCode];
                // Text boxes and other inputs that can use direction keys should be ignored
                // and not affect cell/row navigation
                if (handler && !handledEvent(event) && this._getSelection().length == 0) {
                    handler.call(this, event);
                }
            }.bind(this)));
            return result;
        }
    };
    //package via declare
    var _class = declare('xgrid.Selection', Selection, Implementation);
    _class.Implementation = Implementation;

    return _class;
});
define('xgrid/Keyboard',[
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/dom-class',
	'dojo/on',
	'dojo/_base/lang',
	'dojo/has',
	'dgrid/util/misc',
	'dojo/_base/sniff',
	'dcl/dcl'
], function (declare, aspect, domClass, on, lang, has, miscUtil,dcl) {

	var delegatingInputTypes = {
			checkbox: 1,
			radio: 1,
			button: 1
		},
		hasGridCellClass = /\bdgrid-cell\b/,
		hasGridRowClass = /\bdgrid-row\b/,
		_debug = false;

    has.add("dom-contains", function(global, doc, element){
        return !!element.contains; // not supported by FF < 9
    });

    function contains(parent, node){
        // summary:
        //		Checks to see if an element is contained by another element.

        if(has("dom-contains")){
            return parent.contains(node);
        }else{
            return parent.compareDocumentPosition(node) & 8 /* DOCUMENT_POSITION_CONTAINS */;
        }
    }

	var _upDownSelect = function(event,who,steps) {

		var prev     = steps < 0,
			selector = prev ? 'first:' : 'last',
			s, n, sib, top, left;

		var _current = who.row(event).element;
		var sel = $(_current); // header reports row as undefined

		var clDisabled = 'ui-state-disabled';
		function sibling(n, direction) {
			return n[direction+'All']('[id]:not(.'+clDisabled+'):not(.dgrid-content-parent):first');
		}
		var hasLeftRight=false;
		if (sel.length) {
			var next = who.up(who._focusedNode,1, true);
			s = sel;
			sib = $(next.element);
			if (!sib.length) {
				// there is no sibling on required side - do not move selection
				n = s;
			} else if (hasLeftRight) {//done somewhere else
				n = sib;
			} else {
				// find up/down side file in icons view
				top = s.position().top;
				left = s.position().left;
				n = s;
				if (prev) {
					do {
						n = n.prev('[id]');
					} while (n.length && !(n.position().top < top && n.position().left <= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'next');
					}
				} else {
					do {
						n = n.next('[id]');
					} while (n.length && !(n.position().top > top && n.position().left >= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'prev');
					}
				}
			}
		}
		return n;
	};
	var _rightLeftSelect = function(event,who,steps) {

		var prev     = steps < 0,
			selector = prev ? 'first:' : 'last',
			s, n, sib, top, left;

		var _current = who.row(event).element;
		var sel = $(_current); // header reports row as undefined

		var clDisabled = 'ui-state-disabled';
		function sibling(n, direction) {
			return n[direction+'All']('[id]:not(.'+clDisabled+'):not(.dgrid-content-parent):first');
		}
		var hasLeftRight=true;
		if (sel.length) {
			var next = who.up(who._focusedNode,1, true);
			s = sel;
			sib = $(next.element);
			if (!sib.length) {
				// there is no sibling on required side - do not move selection
				n = s;
			} else if (hasLeftRight) {//done somewhere else
				n = sib;
			} else {
				// find up/down side file in icons view
				top = s.position().top;
				left = s.position().left;
				n = s;
				if (prev) {
					do {
						n = n.prev('[id]');
					} while (n.length && !(n.position().top < top && n.position().left <= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'next');
					}
				} else {
					do {
						n = n.next('[id]');
					} while (n.length && !(n.position().top > top && n.position().left >= left));

					if (n.is('.'+clDisabled)) {
						n = sibling(n, 'prev');
					}
				}
			}
		}
		return n;
	};

	var Implementation = {
		// summary:
		//		Adds keyboard navigation capability to a list or grid.

		// pageSkip: Number
		//		Number of rows to jump by when page up or page down is pressed.
		pageSkip: 10,

		tabIndex: -1,

		// keyMap: Object
		//		Hash which maps key codes to functions to be executed (in the context
		//		of the instance) for key events within the grid's body.
		keyMap: null,

		// headerKeyMap: Object
		//		Hash which maps key codes to functions to be executed (in the context
		//		of the instance) for key events within the grid's header row.
		headerKeyMap: null,

		postMixInProperties: function () {
			this.inherited(arguments);

			if (!this.keyMap) {
				this.keyMap = lang.mixin({}, Implementation.defaultKeyMap);
			}
			if (!this.headerKeyMap) {
				this.headerKeyMap = lang.mixin({}, Implementation.defaultHeaderKeyMap);
			}
		},

		postCreate: function () {
			this.inherited(arguments);
			var grid = this;

			function handledEvent(event) {
				// Text boxes and other inputs that can use direction keys should be ignored
				// and not affect cell/row navigation
				var target = event.target;
				return target.type && (!delegatingInputTypes[target.type] || event.keyCode === 32);
			}

			function enableNavigation(areaNode) {

				var cellNavigation = grid.cellNavigation,
					isFocusableClass = cellNavigation ? hasGridCellClass : hasGridRowClass,
					isHeader = areaNode === grid.headerNode,
					initialNode = areaNode;

				function initHeader() {
					if (grid._focusedHeaderNode) {
						// Remove the tab index for the node that previously had it.
						grid._focusedHeaderNode.tabIndex = -1;
					}
					if (grid.showHeader) {
						if (cellNavigation) {
							// Get the focused element. Ensure that the focused element
							// is actually a grid cell, not a column-set-cell or some
							// other cell that should not be focused
							var elements = grid.headerNode.getElementsByTagName('th');
							for (var i = 0, element; (element = elements[i]); ++i) {
								if (isFocusableClass.test(element.className)) {
									grid._focusedHeaderNode = initialNode = element;
									break;
								}
							}
						}
						else {
							grid._focusedHeaderNode = initialNode = grid.headerNode;
						}

						// Set the tab index only if the header is visible.
						if (initialNode) {
							initialNode.tabIndex = grid.tabIndex;
						}
					}
				}

				if (isHeader) {
					// Initialize header now (since it's already been rendered),
					// and aspect after future renderHeader calls to reset focus.
					initHeader();
					aspect.after(grid, 'renderHeader', initHeader, true);
				}
				else {
					aspect.after(grid, 'renderArray', function (rows) {
						// summary:
						//		Ensures the first element of a grid is always keyboard selectable after data has been
						//		retrieved if there is not already a valid focused element.

						var focusedNode = grid._focusedNode || initialNode;

						// do not update the focused element if we already have a valid one
						if (isFocusableClass.test(focusedNode.className) && miscUtil.contains(areaNode, focusedNode)) {
							return rows;
						}

						// ensure that the focused element is actually a grid cell, not a
						// dgrid-preload or dgrid-content element, which should not be focusable,
						// even when data is loaded asynchronously
						var elements = areaNode.getElementsByTagName('*');
						for (var i = 0, element; (element = elements[i]); ++i) {
							if (isFocusableClass.test(element.className)) {
								focusedNode = grid._focusedNode = element;
								break;
							}
						}

						focusedNode.tabIndex = grid.tabIndex;
						return rows;
					});
				}

				grid._listeners.push(on(areaNode, 'mousedown', function (event) {
					if (!handledEvent(event)) {
						grid._focusOnNode(event.target, isHeader, event);
					}
				}));

				grid._listeners.push(on(areaNode, 'keydown', function (event) {
					//console.log('keyboardkey down : ',event);
					// For now, don't squash browser-specific functionalities by letting
					// ALT and META function as they would natively
					if (event.metaKey || event.altKey) {
						return;
					}

					var handler = grid[isHeader ? 'headerKeyMap' : 'keyMap'][event.keyCode];

					// Text boxes and other inputs that can use direction keys should be ignored
					// and not affect cell/row navigation
					if (handler && !handledEvent(event)) {
						handler.call(grid, event);
					}
				}));
			}

			if (this.tabableHeader) {
				enableNavigation(this.headerNode);
				on(this.headerNode, 'dgrid-cellfocusin', function () {
					grid.scrollTo({ x: this.scrollLeft });
				});
			}
			enableNavigation(this.contentNode);

			this._debouncedEnsureScroll = miscUtil.debounce(this._ensureScroll, this);
		},

		removeRow: function (rowElement) {
			if (!this._focusedNode) {
				// Nothing special to do if we have no record of anything focused
				return this.inherited(arguments);
			}

			var self = this,
				isActive = document.activeElement === this._focusedNode,

					focusedTarget = this[this.cellNavigation ? 'cell' : 'row'](this._focusedNode);

            if(!focusedTarget){
                console.error('no focus target');
                return this.inherited(arguments);
            }


				var focusedRow = focusedTarget.row || focusedTarget,
				sibling;
			rowElement = rowElement.element || rowElement;

			// If removed row previously had focus, temporarily store information
			// to be handled in an immediately-following insertRow call, or next turn
			if (rowElement === focusedRow.element) {
				sibling = this.down(focusedRow, true);

				// Check whether down call returned the same row, or failed to return
				// any (e.g. during a partial unrendering)
				if (!sibling || sibling.element === rowElement) {
					sibling = this.up(focusedRow, true);
				}

				this._removedFocus = {
					active: isActive,
					rowId: focusedRow.id,
					columnId: focusedTarget.column && focusedTarget.column.id,
					siblingId: !sibling || sibling.element === rowElement ? undefined : sibling.id
				};

				// Call _restoreFocus on next turn, to restore focus to sibling
				// if no replacement row was immediately inserted.
				// Pass original row's id in case it was re-inserted in a renderArray
				// call (and thus was found, but couldn't be focused immediately)
				setTimeout(function () {
					if (self._removedFocus) {
						self._restoreFocus(focusedRow.id);
					}
				}, 0);

				// Clear _focusedNode until _restoreFocus is called, to avoid
				// needlessly re-running this logic
				this._focusedNode = null;
			}

			this.inherited(arguments);
		},

		insertRow: function () {
			var rowElement = this.inherited(arguments);
			if (this._removedFocus && !this._removedFocus.wait) {
				this._restoreFocus(rowElement);
			}
			return rowElement;
		},

		_restoreFocus: function (row) {
			// summary:
			//		Restores focus to the newly inserted row if it matches the
			//		previously removed row, or to the nearest sibling otherwise.

			var focusInfo = this._removedFocus,
				newTarget,
				cell;

			row = row && this.row(row);
			newTarget = row && row.element && row.id === focusInfo.rowId ? row :
				typeof focusInfo.siblingId !== 'undefined' && this.row(focusInfo.siblingId);

			if (newTarget && newTarget.element) {
				if (!newTarget.element.parentNode.parentNode) {
					// This was called from renderArray, so the row hasn't
					// actually been placed in the DOM yet; handle it on the next
					// turn (called from removeRow).
					focusInfo.wait = true;
					return;
				}
				// Should focus be on a cell?
				if (typeof focusInfo.columnId !== 'undefined') {
					cell = this.cell(newTarget, focusInfo.columnId);
					if (cell && cell.element) {
						newTarget = cell;
					}
				}
				if (focusInfo.active && newTarget.element.offsetHeight !== 0) {
					// Row/cell was previously focused and is visible, so focus the new one immediately
					this._focusOnNode(newTarget, false, null);
				}
				else {
					// Row/cell was not focused or is not visible, but we still need to
					// update _focusedNode and the element's tabIndex/class
					domClass.add(newTarget.element, 'dgrid-focus');
					newTarget.element.tabIndex = this.tabIndex;
					this._focusedNode = newTarget.element;
				}
			}

			delete this._removedFocus;
		},

		addKeyHandler: function (key, callback, isHeader) {
			// summary:
			//		Adds a handler to the keyMap on the instance.
			//		Supports binding additional handlers to already-mapped keys.
			// key: Number
			//		Key code representing the key to be handled.
			// callback: Function
			//		Callback to be executed (in instance context) when the key is pressed.
			// isHeader: Boolean
			//		Whether the handler is to be added for the grid body (false, default)
			//		or the header (true).

			// Aspects may be about 10% slower than using an array-based appraoch,
			// but there is significantly less code involved (here and above).
			return aspect.after( // Handle
				this[isHeader ? 'headerKeyMap' : 'keyMap'], key, callback, true);
		},

		_ensureRowScroll: function (rowElement) {
			// summary:
			//		Ensures that the entire row is visible within the viewport.
			//		Called for cell navigation in complex structures.

			var scrollY = this.getScrollPosition().y;
			if (scrollY > rowElement.offsetTop) {
				// Row starts above the viewport
				this.scrollTo({ y: rowElement.offsetTop });
			}
			else if (scrollY + this.contentNode.offsetHeight < rowElement.offsetTop + rowElement.offsetHeight) {
				// Row ends below the viewport
				this.scrollTo({ y: rowElement.offsetTop - this.contentNode.offsetHeight + rowElement.offsetHeight });
			}
		},

		_ensureColumnScroll: function (cellElement) {
			// summary:
			//		Ensures that the entire cell is visible in the viewport.
			//		Called in cases where the grid can scroll horizontally.

			var scrollX = this.getScrollPosition().x;
			var cellLeft = cellElement.offsetLeft;
			if (scrollX > cellLeft) {
				this.scrollTo({ x: cellLeft });
			}
			else {
				var bodyWidth = this.bodyNode.clientWidth;
				var cellWidth = cellElement.offsetWidth;
				var cellRight = cellLeft + cellWidth;
				if (scrollX + bodyWidth < cellRight) {
					// Adjust so that the right side of the cell and grid body align,
					// unless the cell is actually wider than the body - then align the left sides
					this.scrollTo({ x: bodyWidth > cellWidth ? cellRight - bodyWidth : cellLeft });
				}
			}
		},

		_ensureScroll: function (cell, isHeader) {
			// summary:
			//		Corrects scroll based on the position of the newly-focused row/cell
			//		as necessary based on grid configuration and dimensions.

			if(this.cellNavigation && (this.columnSets || this.subRows.length > 1) && !isHeader){
				this._ensureRowScroll(cell.row.element);
			}
			if(this.bodyNode.clientWidth < this.contentNode.offsetWidth){
				this._ensureColumnScroll(cell.element);
			}
		},

		_focusOnNode: function (element,isHeader,event,emit) {
			var focusedNodeProperty = '_focused' + (isHeader ? 'Header' : '') + 'Node',
				focusedNode = this[focusedNodeProperty],
				cellOrRowType = this.cellNavigation ? 'cell' : 'row',
				cell = this[cellOrRowType](element),
				inputs,
				input,
				numInputs,
				inputFocused,
				i;

			element = cell && cell.element;

			if (!element /*|| element==this._focusedNode*/) {
				//console.error('same el');
				return;
			}

			if (this.cellNavigation) {
				inputs = element.getElementsByTagName('input');
				for (i = 0, numInputs = inputs.length; i < numInputs; i++) {
					input = inputs[i];
					if ((input.tabIndex !== -1 || '_dgridLastValue' in input) && !input.disabled) {
						input.focus();
						inputFocused = true;
						break;
					}
				}
			}

			// Set up event information for dgrid-cellfocusout/in events.
			// Note that these events are not fired for _restoreFocus.
			if (event !== null) {
				event = lang.mixin({ grid: this }, event);
				if (event.type) {
					event.parentType = event.type;
				}
				if (!event.bubbles) {
					// IE doesn't always have a bubbles property already true.
					// Opera throws if you try to set it to true if it is already true.
					event.bubbles = true;
				}
			}

			if (focusedNode) {
				// Clean up previously-focused element
				// Remove the class name and the tabIndex attribute
				domClass.remove(focusedNode, 'dgrid-focus');
				focusedNode.removeAttribute('tabindex');

				// Expose object representing focused cell or row losing focus, via
				// event.cell or event.row; which is set depends on cellNavigation.
				if (event) {
					event[cellOrRowType] = this[cellOrRowType](focusedNode);
					on.emit(focusedNode, 'dgrid-cellfocusout', event);
				}
			}
			focusedNode = this[focusedNodeProperty] = element;

			if (event) {
				// Expose object representing focused cell or row gaining focus, via
				// event.cell or event.row; which is set depends on cellNavigation.
				// Note that yes, the same event object is being reused; on.emit
				// performs a shallow copy of properties into a new event object.
				event[cellOrRowType] = cell;
			}

			var isFocusableClass = this.cellNavigation ? hasGridCellClass : hasGridRowClass;
			if (!inputFocused && isFocusableClass.test(element.className)) {

				element.tabIndex = this.tabIndex;
				element.focus();
			}
			domClass.add(element, 'dgrid-focus');


			if (event && emit!==false) {
				on.emit(focusedNode, 'dgrid-cellfocusin', event);
			}

			this._debouncedEnsureScroll(cell, isHeader);
		},

		focusHeader: function (element) {
			this._focusOnNode(element || this._focusedHeaderNode, true);
		},

		focus: function (element,emit) {
			_debug && console.log('focuse : ' + (element ? element.id : ''));
			var node = element || this._focusedNode;
			if (node) {
				if (element==this._focusedNode) {
					//console.error('same el');
					//return;
				}
				this._focusOnNode(node, false,null,emit);
			}
			else {
				this.contentNode.focus();
			}
		}
	};

	// Common functions used in default keyMap (called in instance context)

	var moveFocusVertical = Implementation.moveFocusVertical = function (event, steps) {
		if(this.isThumbGrid){
			var next = _upDownSelect(event,this,steps);
			if(next && next.length){
				this._focusOnNode(next[0], false, event);
				event.preventDefault();
				return;
			}
		}
		var cellNavigation = this.cellNavigation,
			target = this[cellNavigation ? 'cell' : 'row'](event),
			columnId = cellNavigation && target.column.id,
			next = this.down(this._focusedNode, steps, true);

		// Navigate within same column if cell navigation is enabled
		if (cellNavigation) {
			next = this.cell(next, columnId);
		}
		this._focusOnNode(next, false, event);

		event.preventDefault();
	};

	var moveFocusUp = Implementation.moveFocusUp = function (event) {
		moveFocusVertical.call(this, event, -1);
	};

	var moveFocusDown = Implementation.moveFocusDown = function (event) {
		moveFocusVertical.call(this, event, 1);
	};

	var moveFocusPageUp = Implementation.moveFocusPageUp = function (event) {
		moveFocusVertical.call(this, event, -this.pageSkip);
	};

	var moveFocusPageDown = Implementation.moveFocusPageDown = function (event) {
		moveFocusVertical.call(this, event, this.pageSkip);
	};

	var moveFocusHorizontal = Implementation.moveFocusHorizontal = function (event, steps) {

		if (!this.cellNavigation && this.isThumbGrid!==true) {
			return;
		}

		var isHeader = !this.row(event), // header reports row as undefined
			currentNode = this['_focused' + (isHeader ? 'Header' : '') + 'Node'];

		//var _row = this.row(event);
		if(this.isThumbGrid==true){

			var cellNavigation = this.cellNavigation,
				next = this.down(this._focusedNode, steps, true);

			// Navigate within same column if cell navigation is enabled
			this._focusOnNode(next, false, event);
			event.preventDefault();
			return ;
		}

		this._focusOnNode(this.right(currentNode, steps), isHeader, event);
		event.preventDefault();
	};

	var moveFocusLeft = Implementation.moveFocusLeft = function (event) {
		moveFocusHorizontal.call(this, event, -1);
	};

	var moveFocusRight = Implementation.moveFocusRight = function (event) {
		moveFocusHorizontal.call(this, event, 1);
	};

	var moveHeaderFocusEnd = Implementation.moveHeaderFocusEnd = function (event, scrollToBeginning) {
		// Header case is always simple, since all rows/cells are present
		var nodes;
		if (this.cellNavigation) {
			nodes = this.headerNode.getElementsByTagName('th');
			this._focusOnNode(nodes[scrollToBeginning ? 0 : nodes.length - 1], true, event);
		}
		// In row-navigation mode, there's nothing to do - only one row in header

		// Prevent browser from scrolling entire page
		event.preventDefault();
	};

	var moveHeaderFocusHome = Implementation.moveHeaderFocusHome = function (event) {
		moveHeaderFocusEnd.call(this, event, true);
	};

	var moveFocusEnd = Implementation.moveFocusEnd = function (event, scrollToTop) {
		// summary:
		//		Handles requests to scroll to the beginning or end of the grid.

		// Assume scrolling to top unless event is specifically for End key
		var cellNavigation = this.cellNavigation,
			contentNode = this.contentNode,
			contentPos = scrollToTop ? 0 : contentNode.scrollHeight,
			scrollPos = contentNode.scrollTop + contentPos,
			endChild = contentNode[scrollToTop ? 'firstChild' : 'lastChild'];

		if(endChild.className.indexOf('dgrid-extra') > -1){
			endChild = endChild['previousSibling'];
		}

		var	hasPreload = endChild.className.indexOf('dgrid-preload') > -1,
			endTarget = hasPreload ? endChild[(scrollToTop ? 'next' : 'previous') + 'Sibling'] : endChild,
			endPos = endTarget.offsetTop + (scrollToTop ? 0 : endTarget.offsetHeight),
			handle;

		if (hasPreload) {
			// Find the nearest dgrid-row to the relevant end of the grid
			while (endTarget && endTarget.className.indexOf('dgrid-row') < 0) {
				endTarget = endTarget[(scrollToTop ? 'next' : 'previous') + 'Sibling'];
			}
			// If none is found, there are no rows, and nothing to navigate
			if (!endTarget) {
				return;
			}
		}

		// Grid content may be lazy-loaded, so check if content needs to be
		// loaded first
		if (!hasPreload || endChild.offsetHeight < 1) {
			// End row is loaded; focus the first/last row/cell now
			if (cellNavigation) {
				// Preserve column that was currently focused
				endTarget = this.cell(endTarget, this.cell(event).column.id);
			}
			this._focusOnNode(endTarget, false, event);
		}
		else {
			// In IE < 9, the event member references will become invalid by the time
			// _focusOnNode is called, so make a (shallow) copy up-front
			if (!has('dom-addeventlistener')) {
				event = lang.mixin({}, event);
			}

			// If the topmost/bottommost row rendered doesn't reach the top/bottom of
			// the contentNode, we are using OnDemandList and need to wait for more
			// data to render, then focus the first/last row in the new content.
			handle = aspect.after(this, 'renderArray', function (rows) {
				var target = rows[scrollToTop ? 0 : rows.length - 1];
				if (cellNavigation) {
					// Preserve column that was currently focused
					target = this.cell(target, this.cell(event).column.id);
				}
				this._focusOnNode(target, false, event);
				handle.remove();
				return rows;
			});
		}

		if (scrollPos === endPos) {
			// Grid body is already scrolled to end; prevent browser from scrolling
			// entire page instead
			event.preventDefault();
		}
	};

	var moveFocusHome = Implementation.moveFocusHome = function (event) {
		moveFocusEnd.call(this, event, true);
	};

	function preventDefault(event) {
		event.preventDefault();
	}

	Implementation.defaultKeyMap = {
		32: preventDefault, // space
		33: moveFocusPageUp, // page up
		34: moveFocusPageDown, // page down
		35: moveFocusEnd, // end
		36: moveFocusHome, // home
		37: moveFocusLeft, // left
		38: moveFocusUp, // up
		39: moveFocusRight, // right
		40: moveFocusDown // down
	};

	// Header needs fewer default bindings (no vertical), so bind it separately
	Implementation.defaultHeaderKeyMap = {
		32: preventDefault, // space
		35: moveHeaderFocusEnd, // end
		36: moveHeaderFocusHome, // home
		37: moveFocusLeft, // left
		39: moveFocusRight // right
	};

	var Module = declare(null,Implementation);
	Module.dcl = dcl(null,Implementation);
	return Module;
});

define('xgrid/ColumnHider',[
	'xdojo/declare',
    'dojo/has',
    'dgrid/util/misc',
    'xide/types',
    'xide/utils'
], function (declare, has, misc,types,utils) {

    /*
     *	Column Hider plugin for dgrid
     *	Originally contributed by TRT 2011-09-28
     *
     *	A dGrid plugin that attaches a menu to a dgrid, along with a way of opening it,
     *	that will allow you to show and hide columns.  A few caveats:
     *
     *	1. Menu placement is entirely based on CSS definitions.
     *	2. If you want columns initially hidden, you must add "hidden: true" to your
     *		column definition.
     *	3. This implementation does NOT support ColumnSet, and has not been tested
     *		with multi-subrow records.
     *	4. Column show/hide is controlled via straight up HTML checkboxes.  If you
     *		are looking for something more fancy, you'll probably need to use this
     *		definition as a template to write your own plugin.
     *
     */
	return declare('xgrid.ColumnHider',null, {
        columnHiderActionRootCommand:'View/Columns',
		// i18nColumnHider: Object
		//		This object contains all of the internationalized strings for
		//		the ColumnHider extension as key/value pairs.
		i18nColumnHider: {},

		// _columnHiderRules: Object
		//		Hash containing handles returned from addCssRule.
		_columnHiderRules: null,
        _runAction:function(action,update,value){
            if(action && action.command.indexOf(this.columnHiderActionRootCommand)!=-1 ){
                var col = action.column;
                var isHidden = this.isColumnHidden(col.id);
                this.showColumn(col.id,isHidden);
                update!==false && action.set('value', !this.isColumnHidden(col.id));
            }
            return this.inherited(arguments);
        },
        /**
         *
         * @param permissions
         * @param actions
         * @returns {Array}
         */
		getColumnHiderActions:function(permissions,actions){
            var root = this.columnHiderActionRootCommand,
                thiz = this,
                columnActions = [],
                VISIBILITY = types.ACTION_VISIBILITY,
                node = this.domNode;

            actions = actions || [];
            var rootAction = _.find(actions,{
                command:root
            });
            if(!rootAction) {
                columnActions.push(this.createAction({
                    label:'Columns',
                    command:root,
                    icon:'fa-columns',
                    tab:'View',
                    group:'Columns',
                    toggleGroup:thiz.id + 'Columns',
                    onCreate:function(action){
                        action.setVisibility(VISIBILITY.RIBBON,{
                            expand:true
                        }).setVisibility(VISIBILITY.ACTION_TOOLBAR, false);
                    }
                }));
            }
            /**
             *
             * @param col
             * @private
             */
            function _createEntry(col) {

                var id = col.id,
                    label = 'Show ' + ( col.label || col.field || ''),
                    icon = col.icon || 'fa-cogs';

                // Allow cols to opt out of the hider (e.g. for selector column).
                if (col.unhidable) {
                    return;
                }
                var _action = thiz.createAction(label, root + '/' + label , icon, null, 'View', 'Columns', 'item|view',

                    //oncreate
                    function(action){

                        var widgetImplementation = {
                            postMixInProperties: function() {
                                this.inherited(arguments);
                                this.checked = this.item.get('value') === true;
                            },
                            startup:function(){
                                this.inherited(arguments);
                                this.on('change',function(val){
                                    thiz.showColumn(id,val);
                                });
                            }
                        };
                        var widgetArgs  ={
                            checked:!col.hidden,
                            iconClass:icon,
                            style:'float:inherit;'
                        };


                        var _visibilityMixin = {
                            //widgetClass:declare.classFactory('_Checked', [CheckedMenuItem,_ActionValueWidgetMixin], null, widgetImplementation ,null),
                            widgetArgs:widgetArgs,
                            actionType : 'multiToggle'
                        };

                        action.actionType = 'multiToggle';


                        action.setVisibility(types.ACTION_VISIBILITY_ALL,utils.cloneKeys(_visibilityMixin,false));

                        label = action.label.replace('Show ','');


                        //for ribbons we collapse into 'Checkboxes'
                        /*
                        action.setVisibility(VISIBILITY.RIBBON,{
                            widgetClass:declare.classFactory('_CheckedGroup', [ActionValueWidget], null,{
                                iconClass:"",
                                postMixInProperties: function() {
                                    this.inherited(arguments);
                                    this.checked = this.item.get('value') == true;
                                },
                                startup:function(){
                                    this.inherited(arguments);
                                    this.widget.on('change', function (val) {
                                        thiz.showColumn(id,val);
                                    }.bind(this));
                                }
                            } ,null),
                            widgetArgs:{
                                renderer:CheckBox,
                                checked:!col.hidden,
                                label:action.label.replace('Show ','')
                            }
                        });
                        */

                    }, /*handler*/ null ,
                    {
                        column:col,
                        filterGroup:"item|view",
                        tab:'View',
                        value:!col.hidden,
                        addPermission:true
                    },
                    null, null, permissions, node,thiz,thiz);

                if(_action){
                    columnActions.push(_action);
                }

                /**

                columnActions.push(_ActionMixin.createActionParameters(label, root + '/' + label, 'Columns', icon, function () {
                    console.log('handler');

                }, '', null, null, thiz, thiz, {
                    column:col,
                    filterGroup:"item|view",
                    tab:'View',
                    value:!col.hidden,
                    onCreate:function(action){

                        var _action = this;

                        action.owner = thiz;

                        var widgetImplementation = {
                            postMixInProperties: function() {
                                this.inherited(arguments);
                                this.checked = this.item.get('value') == true;
                            },
                            startup:function(){
                                this.inherited(arguments);
                                this.on('change',function(val){
                                    thiz.showColumn(id,val);
                                })
                            },
                            destroy:function(){

                                this.inherited(arguments);
                            }
                        };
                        var widgetArgs  ={
                            checked:!col.hidden,
                            iconClass:icon,
                            style:'float:inherit;'
                        };

                        var _visibilityMixin = {
                            widgetClass:declare.classFactory('_Checked', [CheckedMenuItem,_ActionValueWidgetMixin], null, widgetImplementation ,null),
                            widgetArgs:widgetArgs
                        };

                        action.setVisibility(types.ACTION_VISIBILITY_ALL,_visibilityMixin);

                        label = action.label.replace('Show ','');


                        //for ribbons we collapse into 'Checkboxes'
                        action.setVisibility(VISIBILITY.RIBBON,{
                            widgetClass:declare.classFactory('_CheckedGroup', [ActionValueWidget], null,{
                                iconClass:"",
                                postMixInProperties: function() {
                                    this.inherited(arguments);
                                    this.checked = this.item.get('value') == true;
                                },
                                startup:function(){
                                    this.inherited(arguments);
                                    this.widget.on('change', function (val) {
                                        thiz.showColumn(id,val);
                                    }.bind(this));
                                }
                            } ,null),
                            widgetArgs:{
                                renderer:CheckBox,
                                checked:!col.hidden,
                                label:action.label.replace('Show ','')
                            }
                        });

                    }
                }));

                */

            }
            var subRows = this.subRows,
                first = true,
                srLength, cLength, sr, c;
            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {
                    _createEntry(subRows[sr][c]);
                    if (first) {
                        first = false;
                    }
                }
            }
            return columnActions;

        },
        resize:function(){
            this.inherited(arguments);
            this._checkHiddenColumns();
        },
        _checkHiddenColumns:function(){
            var subRows = this.subRows,
                srLength, cLength, sr, c,
                totalWidth = $(this.domNode).width();

            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {
                    var col = subRows[sr][c];
                    if(col.minWidth){
                        if(totalWidth < col.minWidth){
                            if(!col.unhidable) {
                                this.showColumn(col.id,false);
                            }
                        }else{
                            this.showColumn(col.id,true);
                        }
                    }
                }
            }
        },
        startup:function(){
            if(this._started){
                return;
            }

            this._columnHiderCheckboxes = {};
            this._columnHiderRules = {};
            var res = this.inherited(arguments);
            this._checkHiddenColumns();
            var subRows = this.subRows,
                srLength, cLength, sr, c,
                thiz = this;

            for (sr = 0, srLength = subRows.length; sr < srLength; sr++) {
                for (c = 0, cLength = subRows[sr].length; c < cLength; c++) {

                    var col = subRows[sr][c],
                        id = col.id;

                    if (col.hidden===true) {
                        // Hide the column (reset first to avoid short-circuiting logic)
                        col.hidden = false;
                        thiz._hideColumn(id);
                        col.hidden = true;
                    }
                }
            }
            if(this.getActionStore){
                this.getActionStore().on('update',function(evt){
                    var action = evt.target;
                    if(action.command.indexOf('View/Columns')!==-1){
                        var col = action.column;
                        thiz.showColumn(col.id,action.get('value'));
                        thiz.onAfterAction(action);

                    }
                });
            }
            return res;

        },
		left: function (cell, steps) {
			return this.right(cell, -steps);
		},
		right: function (cell, steps) {
			if (!cell.element) {
				cell = this.cell(cell);
			}
			var nextCell = this.inherited(arguments),
				prevCell = cell;

			// Skip over hidden cells
			while (nextCell.column.hidden) {
				nextCell = this.inherited(arguments, [nextCell, steps > 0 ? 1 : -1]);
				if (prevCell.element === nextCell.element) {
					// No further visible cell found - return original
					return cell;
				}
				prevCell = nextCell;
			}
			return nextCell;
		},
		isColumnHidden: function (id) {
			// summary:
			//		Convenience method to determine current hidden state of a column
			return !!this._columnHiderRules[id];
		},
		_hideColumn: function (id) {
			// summary:
			//		Hides the column indicated by the given id.

			// Use misc function directly, since we clean these up ourselves anyway
			var grid = this,
                domId = this.template ? this.template.id : this.domNode.id,
                selectorPrefix = '#' + misc.escapeCssIdentifier(domId) + ' .dgrid-column-',
				tableRule; // used in IE8 code path

			if (this._columnHiderRules[id]) {
				return;
			}

			this._columnHiderRules[id] = misc.addCssRule(selectorPrefix + misc.escapeCssIdentifier(id, '-'), 'display: none;');
            
			if (has('ie') === 8 || has('ie') === 10) {
				// Work around IE8 display issue and IE10 issue where
				// header/body cells get out of sync when ColumnResizer is also used
				tableRule = misc.addCssRule('.dgrid-row-table', 'display: inline-table;');
				window.setTimeout(function () {
					tableRule.remove();
					grid.resize();
				}, 0);
			}
		},
		_showColumn: function (id) {
			// summary:
			//		Shows the column indicated by the given id
			//		(by removing the rule responsible for hiding it).

			if (this._columnHiderRules[id]) {
				this._columnHiderRules[id].remove();
				delete this._columnHiderRules[id];
			}
		},
        showColumn:function(id,show){
            if(this.isColumnHidden(id)){
                if(show) {
                    this._showColumn(id);
                }
            }else if(!show){
                this._hideColumn(id);
            }
        }
	});
});

define('dgrid/_StoreMixin',[
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/Deferred',
	'dojo/aspect',
	'dojo/dom-construct',
	'dojo/has',
	'dojo/on',
	'dojo/when'
], function (declare, lang, Deferred, aspect, domConstruct, has, on, when) {
	// This module isolates the base logic required by store-aware list/grid
	// components, e.g. OnDemandList/Grid and the Pagination extension.

	function emitError(err) {
		// called by _trackError in context of list/grid, if an error is encountered
		if (typeof err !== 'object') {
			// Ensure we actually have an error object, so we can attach a reference.
			err = new Error(err);
		}
		else if (err.dojoType === 'cancel') {
			// Don't fire dgrid-error events for errors due to canceled requests
			// (unfortunately, the Deferred instrumentation will still log them)
			return;
		}

		var event = on.emit(this.domNode, 'dgrid-error', {
			grid: this,
			error: err,
			cancelable: true,
			bubbles: true
		});
		if (event) {
			console.error(err);
		}
	}

	return declare(null, {
		// collection: Object
		//		The base object collection (implementing the dstore/api/Store API) before being sorted
		//		or otherwise processed by the grid. Use it for general purpose store operations such as
		//		`getIdentity` and `get`, `add`, `put`, and `remove`.
		collection: null,

		// _renderedCollection: Object
		//		The object collection from which data is to be fetched. This is the sorted collection.
		//		Use it when retrieving data to be rendered by the grid.
		_renderedCollection: null,

		// _rows: Array
		//		Sparse array of row nodes, used to maintain the grid in response to events from a tracked collection.
		//		Each node's index corresponds to the index of its data object in the collection.
		_rows: null,

		// _observerHandle: Object
		//		The observer handle for the current collection, if trackable.
		_observerHandle: null,

		// shouldTrackCollection: Boolean
		//		Whether this instance should track any trackable collection it is passed.
		shouldTrackCollection: false,

		// getBeforePut: boolean
		//		If true, a get request will be performed to the store before each put
		//		as a baseline when saving; otherwise, existing row data will be used.
		getBeforePut: true,

		// noDataMessage: String
		//		Message to be displayed when no results exist for a collection, whether at
		//		the time of the initial query or upon subsequent observed changes.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		noDataMessage: '',

		// loadingMessage: String
		//		Message displayed when data is loading.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		loadingMessage: '',

		_total: 0,

		constructor: function () {
			// Create empty objects on each instance, not the prototype
			this.dirty = {};
			this._updating = {}; // Tracks rows that are mid-update
			this._columnsWithSet = {};

			// Reset _columnsWithSet whenever column configuration is reset
			aspect.before(this, 'configStructure', lang.hitch(this, function () {
				this._columnsWithSet = {};
			}));
		},

		destroy: function () {
			this.inherited(arguments);

			if (this._renderedCollection) {
				this._cleanupCollection();
			}
		},

		_configColumn: function (column) {
			// summary:
			//		Implements extension point provided by Grid to store references to
			//		any columns with `set` methods, for use during `save`.
			if (column.set) {
				this._columnsWithSet[column.field] = column;
			}
			this.inherited(arguments);
		},

		_setCollection: function (collection) {
			// summary:
			//		Assigns a new collection to the list/grid, sets up tracking
			//		if applicable, and tells the list/grid to refresh.

			if (this._renderedCollection) {
				this.cleanup();
				this._cleanupCollection({
					// Only clear the dirty hash if the collection being used is actually from a different store
					// (i.e. not just a re-sorted / re-filtered version of the same store)
					shouldRevert: !collection || collection.storage !== this._renderedCollection.storage
				});
			}

			this.collection = collection;

			// Avoid unnecessary rendering and processing before the grid has started up
			if (this._started) {
				// Once startup is called, List.startup sets the sort property which calls _StoreMixin._applySort
				// which sets the collection property again.  So _StoreMixin._applySort will be executed again
				// after startup is called.
				if (collection) {
					var renderedCollection = collection;
					if (this.sort && this.sort.length > 0) {
						renderedCollection = collection.sort(this.sort);
					}

					if (renderedCollection.track && this.shouldTrackCollection) {
						renderedCollection = renderedCollection.track();
						this._rows = [];

						this._observerHandle = this._observeCollection(
							renderedCollection,
							this.contentNode,
							{ rows: this._rows }
						);
					}

					this._renderedCollection = renderedCollection;
				}
				this.refresh();
			}
		},

		_setStore: function () {
			if (!this.collection) {
				console.debug('set(\'store\') call detected, but you probably meant set(\'collection\')');
			}
		},

		_getTotal: function () {
			// summary:
			//		Retrieves the currently-tracked total (as updated by
			//		subclasses after store queries, or by _StoreMixin in response to
			//		updated totalLength in events)

			return this._total;
		},

		_cleanupCollection: function (options) {
			// summary:
			//		Handles cleanup duty for the previous collection;
			//		called during _setCollection and destroy.
			// options: Object?
			//		* shouldRevert: Whether to clear the dirty hash

			options = options || {};

			if (this._renderedCollection.tracking) {
				this._renderedCollection.tracking.remove();
			}

			// Remove observer and existing rows so any sub-row observers will be cleaned up
			if (this._observerHandle) {
				this._observerHandle.remove();
				this._observerHandle = this._rows = null;
			}

			// Discard dirty map, as it applied to a previous collection
			if (options.shouldRevert !== false) {
				this.dirty = {};
			}

			this._renderedCollection = this.collection = null;
		},

		_applySort: function () {
			if (this.collection) {
				this.set('collection', this.collection);
			}
		},

		row: function () {
			// Extend List#row with more appropriate lookup-by-id logic
			var row = this.inherited(arguments);
			if (row && row.data && typeof row.id !== 'undefined') {

				if(this.collection) {
					row.id = this.collection.getIdentity(row.data);
				}else{
					console.error('_StoreMixin:have no collection!');
				}

			}
			return row;
		},

		refresh: function () {
			var result = this.inherited(arguments);

			if (!this.collection) {
				
				this.noDataNode = domConstruct.create('div', {
					className: 'dgrid-no-data',
					innerHTML: this.noDataMessage
				}, this.contentNode);
				
				this._emit('noData');
			}
			//{"values":[{"key":"Marantz-Power","value":"%%PowerState%%"}]}
			return result;
		},

		refreshCell: function (cell) {
			/*
			 this.inherited(arguments);
			 var row = cell.row;
			 var self = this;
			 */
			if (!this.collection || !this._createBodyRowCell) {
				//throw new Error('refreshCell requires a Grid with a collection.');
				return false;
			}

			if(!cell.column){
				return;
			}
			if (cell.column && cell.column.selector) {
				return (new Deferred()).resolve();
			}
			this.inherited(arguments);
			return this.collection.get(cell.row.id).then(lang.hitch(this, '_refreshCellFromItem', cell));

/*
			return this.collection.get(row.id).then(function (item) {

				var cellElement = cell.element;

				if(cellElement) {

					if (cellElement.widget) {
						cellElement.widget.destroyRecursive();
					}
					domConstruct.empty(cellElement);

					var dirtyItem = self.dirty && self.dirty[row.id];
					if (dirtyItem) {
						item = lang.delegate(item, dirtyItem);
					}

					self._createBodyRowCell(cellElement, cell.column, item);
				}
			});
			*/
		},
		_refreshCellFromItem: function (cell, item, options) {
			if(!cell || !cell.element){
				return;
			}
			var cellElement = cell.element;
			if (cellElement.widget) {
				cellElement.widget.destroyRecursive();
			}
			domConstruct.empty(cellElement);

			var dirtyItem = this.dirty && this.dirty[cell.row.id];
			if (dirtyItem) {
				item = lang.delegate(item, dirtyItem);
			}

			this._createBodyRowCell(cellElement, cell.column, item, options);
		},
		renderArray: function () {
			var rows = this.inherited(arguments);

			if (!this.collection) {
				if (rows.length && this.noDataNode) {
					domConstruct.destroy(this.noDataNode);
				}
			}
			return rows;
		},

		insertRow: function (object, parent, beforeNode, i, options) {
			var store = this.collection,
				dirty = this.dirty,
				id = store && store.getIdentity(object),
				dirtyObj,
				row;

			if (id in dirty && !(id in this._updating)) {
				dirtyObj = dirty[id];
			}
			if (dirtyObj) {
				// restore dirty object as delegate on top of original object,
				// to provide protection for subsequent changes as well
				object = lang.delegate(object, dirtyObj);
			}

			row = this.inherited(arguments);

			if (options && options.rows) {
				options.rows[i] = row;
			}

			// Remove no data message when a new row appears.
			// Run after inherited logic to prevent confusion due to noDataNode
			// no longer being present as a sibling.
			if (this.noDataNode) {
				domConstruct.destroy(this.noDataNode);
				this.noDataNode = null;
			}

			return row;
		},

		updateDirty: function (id, field, value) {
			// summary:
			//		Updates dirty data of a field for the item with the specified ID.
			var dirty = this.dirty,
				dirtyObj = dirty[id];

			if (!dirtyObj) {
				dirtyObj = dirty[id] = {};
			}
			dirtyObj[field] = value;
		},

		save: function () {
			// Keep track of the store and puts
			var self = this,
				store = this.collection,
				dirty = this.dirty,
				dfd = new Deferred(),
				results = {},
				getFunc = function (id) {
					// returns a function to pass as a step in the promise chain,
					// with the id variable closured
					var data;
					return (self.getBeforePut || !(data = self.row(id).data)) ?
						function () {
							return store.get(id);
						} :
						function () {
							return data;
						};
				};

			// function called within loop to generate a function for putting an item
			function putter(id, dirtyObj) {
				// Return a function handler
				return function (object) {
					var colsWithSet = self._columnsWithSet,
						updating = self._updating,
						key, data;

					if (typeof object.set === 'function') {
						object.set(dirtyObj);
					} else {
						// Copy dirty props to the original, applying setters if applicable
						for (key in dirtyObj) {
							object[key] = dirtyObj[key];
						}
					}

					// Apply any set methods in column definitions.
					// Note that while in the most common cases column.set is intended
					// to return transformed data for the key in question, it is also
					// possible to directly modify the object to be saved.
					for (key in colsWithSet) {
						data = colsWithSet[key].set(object);
						if (data !== undefined) {
							object[key] = data;
						}
					}

					updating[id] = true;
					// Put it in the store, returning the result/promise
					return store.put(object).then(function (result) {
						// Clear the item now that it's been confirmed updated
						delete dirty[id];
						delete updating[id];
						results[id] = result;
						return results;
					});
				};
			}

			var promise = dfd.then(function () {
				// Ensure empty object is returned even if nothing was dirty, for consistency
				return results;
			});

			// For every dirty item, grab the ID
			for (var id in dirty) {
				// Create put function to handle the saving of the the item
				var put = putter(id, dirty[id]);

				// Add this item onto the promise chain,
				// getting the item from the store first if desired.
				promise = promise.then(getFunc(id)).then(put);
			}

			// Kick off and return the promise representing all applicable get/put ops.
			// If the success callback is fired, all operations succeeded; otherwise,
			// save will stop at the first error it encounters.
			dfd.resolve();
			return promise;
		},

		revert: function () {
			// summary:
			//		Reverts any changes since the previous save.
			this.dirty = {};
			this.refresh();
		},

		_trackError: function (func) {
			// summary:
			//		Utility function to handle emitting of error events.
			// func: Function|String
			//		A function which performs some store operation, or a String identifying
			//		a function to be invoked (sans arguments) hitched against the instance.
			//		If sync, it can return a value, but may throw an error on failure.
			//		If async, it should return a promise, which would fire the error
			//		callback on failure.
			// tags:
			//		protected

			if (typeof func === 'string') {
				func = lang.hitch(this, func);
			}

			var self = this,
				promise;

			try {
				promise = when(func());
			} catch (err) {
				// report sync error
				var dfd = new Deferred();
				dfd.reject(err);
				promise = dfd.promise;
			}

			promise.otherwise(function (err) {
				emitError.call(self, err);
			});
			return promise;
		},

		removeRow: function (rowElement, preserveDom, options) {
			var row = {element: rowElement};
			// Check to see if we are now empty...
			if (!preserveDom && this.noDataMessage &&
					(this.up(row).element === rowElement) &&
					(this.down(row).element === rowElement)) {
				// ...we are empty, so show the no data message.
				this.noDataNode = domConstruct.create('div', {
					className: 'dgrid-no-data',
					innerHTML: this.noDataMessage
				}, this.contentNode);
				this._emit('noData');
			}

			var rows = (options && options.rows) || this._rows;
			if (rows) {
				delete rows[rowElement.rowIndex];
			}

			return this.inherited(arguments);
		},

		renderQueryResults: function (results, beforeNode, options) {
			// summary:
			//		Renders objects from QueryResults as rows, before the given node.

			options = lang.mixin({ rows: this._rows }, options);
			var self = this;

			if (!has('dojo-built')) {
				// Check for null/undefined totalResults to help diagnose faulty services/stores
				results.totalLength.then(function (total) {
					if (total == null) {
						console.warn('Store reported null or undefined totalLength. ' +
							'Make sure your store (and service, if applicable) are reporting total correctly!');
					}
				});
			}

			return results.then(function (resolvedResults) {
				var resolvedRows = self.renderArray(resolvedResults, beforeNode, options);
				delete self._lastCollection; // used only for non-store List/Grid
				return resolvedRows;
			});
		},

		_observeCollection: function (collection, container, options) {
			var self = this,
				rows = options.rows,
				row;

			var handles = [
				collection.on('delete, update', function (event) {
					var from = event.previousIndex;
					var to = event.index;

					if (from !== undefined && rows[from]) {
						if ('max' in rows && (to === undefined || to < rows.min || to > rows.max)) {
							rows.max--;
						}

						row = rows[from];

						// check to make the sure the node is still there before we try to remove it
						// (in case it was moved to a different place in the DOM)
						if (row.parentNode === container) {
							self.removeRow(row, false, options);
						}

						// remove the old slot
						rows.splice(from, 1);

						if (event.type === 'delete' ||
								(event.type === 'update' && (from < to || to === undefined))) {
							// adjust the rowIndex so adjustRowIndices has the right starting point
							rows[from] && rows[from].rowIndex--;
						}
					}
					if (event.type === 'delete') {
						// Reset row in case this is later followed by an add;
						// only update events should retain the row variable below
						row = null;
					}
				}),

				collection.on('add, update', function (event) {
					var from = event.previousIndex;
					var to = event.index;
					var nextNode;

					function advanceNext() {
						nextNode = (nextNode.connected || nextNode).nextSibling;
					}

					// When possible, restrict observations to the actually rendered range
					if (to !== undefined && (!('max' in rows) || (to >= rows.min && to <= rows.max))) {
						if ('max' in rows && (from === undefined || from < rows.min || from > rows.max)) {
							rows.max++;
						}
						// Add to new slot (either before an existing row, or at the end)
						// First determine the DOM node that this should be placed before.
						if (rows.length) {
							nextNode = rows[to];
							if (!nextNode) {
								nextNode = rows[to - 1];
								if (nextNode) {
									// Make sure to skip connected nodes, so we don't accidentally
									// insert a row in between a parent and its children.
									advanceNext();
								}
							}
						}
						else {
							// There are no rows.  Allow for subclasses to insert new rows somewhere other than
							// at the end of the parent node.
							nextNode = self._getFirstRowSibling && self._getFirstRowSibling(container);
						}
						// Make sure we don't trip over a stale reference to a
						// node that was removed, or try to place a node before
						// itself (due to overlapped queries)
						if (row && nextNode && row.id === nextNode.id) {
							advanceNext();
						}
						if (nextNode && !nextNode.parentNode) {
							nextNode = document.getElementById(nextNode.id);
						}
						rows.splice(to, 0, undefined);
						row = self.insertRow(event.target, container, nextNode, to, options);
						self.highlightRow(row);
					}
					// Reset row so it doesn't get reused on the next event
					row = null;
				}),

				collection.on('add, delete, update', function (event) {
					var from = (typeof event.previousIndex !== 'undefined') ? event.previousIndex : Infinity,
						to = (typeof event.index !== 'undefined') ? event.index : Infinity,
						adjustAtIndex = Math.min(from, to);
					from !== to && rows[adjustAtIndex] && self.adjustRowIndices(rows[adjustAtIndex]);

					// the removal of rows could cause us to need to page in more items
					if (from !== Infinity && self._processScroll && (rows[from] || rows[from - 1])) {
						self._processScroll();
					}

					// Fire _onNotification, even for out-of-viewport notifications,
					// since some things may still need to update (e.g. Pagination's status/navigation)
					self._onNotification(rows, event, collection);

					// Update _total after _onNotification so that it can potentially
					// decide whether to perform actions based on whether the total changed
					if (collection === self._renderedCollection && 'totalLength' in event) {
						self._total = event.totalLength;
					}
				})
			];

			return {
				remove: function () {
					while (handles.length > 0) {
						handles.pop().remove();
					}
				}
			};
		},

		_onNotification: function () {
			// summary:
			//		Protected method called whenever a store notification is observed.
			//		Intended to be extended as necessary by mixins/extensions.
			// rows: Array
			//		A sparse array of row nodes corresponding to data objects in the collection.
			// event: Object
			//		The notification event
			// collection: Object
			//		The collection that the notification is relevant to.
			//		Useful for distinguishing child-level from top-level notifications.
		}
	});
});

define('dgrid/OnDemandList',[
	'./List',
	'./_StoreMixin',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/on',
	'dojo/when',
	'./util/misc'
], function (List, _StoreMixin, declare, lang, domConstruct, on, when, miscUtil) {

	return declare([ List, _StoreMixin ], {
		// summary:
		//		Extends List to include virtual scrolling functionality, querying a
		//		dojo/store instance for the appropriate range when the user scrolls.

		// minRowsPerPage: Integer
		//		The minimum number of rows to request at one time.
		minRowsPerPage: 2500,

		// maxRowsPerPage: Integer
		//		The maximum number of rows to request at one time.
		maxRowsPerPage: 250,

		// maxEmptySpace: Integer
		//		Defines the maximum size (in pixels) of unrendered space below the
		//		currently-rendered rows. Setting this to less than Infinity can be useful if you
		//		wish to limit the initial vertical scrolling of the grid so that the scrolling is
		// 		not excessively sensitive. With very large grids of data this may make scrolling
		//		easier to use, albiet it can limit the ability to instantly scroll to the end.
		maxEmptySpace: Infinity,

		// bufferRows: Integer
		//	  The number of rows to keep ready on each side of the viewport area so that the user can
		//	  perform local scrolling without seeing the grid being built. Increasing this number can
		//	  improve perceived performance when the data is being retrieved over a slow network.
		bufferRows: 10,

		// farOffRemoval: Integer
		//		Defines the minimum distance (in pixels) from the visible viewport area
		//		rows must be in order to be removed.  Setting to Infinity causes rows
		//		to never be removed.
		farOffRemoval: 2000,

		// queryRowsOverlap: Integer
		//		Indicates the number of rows to overlap queries. This helps keep
		//		continuous data when underlying data changes (and thus pages don't
		//		exactly align)
		queryRowsOverlap: 0,

		// pagingMethod: String
		//		Method (from dgrid/util/misc) to use to either throttle or debounce
		//		requests.  Default is "debounce" which will cause the grid to wait until
		//		the user pauses scrolling before firing any requests; can be set to
		//		"throttleDelayed" instead to progressively request as the user scrolls,
		//		which generally incurs more overhead but might appear more responsive.
		pagingMethod: 'debounce',

		// pagingDelay: Integer
		//		Indicates the delay (in milliseconds) imposed upon pagingMethod, to wait
		//		before paging in more data on scroll events. This can be increased to
		//		reduce client-side overhead or the number of requests sent to a server.
		pagingDelay: miscUtil.defaultDelay,

		// keepScrollPosition: Boolean
		//		When refreshing the list, controls whether the scroll position is
		//		preserved, or reset to the top.  This can also be overridden for
		//		specific calls to refresh.
		keepScrollPosition: true,

		// rowHeight: Number
		//		Average row height, computed in renderQuery during the rendering of
		//		the first range of data.
		rowHeight: 0,

		postCreate: function () {
			this.inherited(arguments);
			var self = this;
			// check visibility on scroll events
			on(this.bodyNode, 'scroll',
				miscUtil[this.pagingMethod](function (event) {
					self._processScroll(event);
				}, null, this.pagingDelay)
			);
		},

		destroy: function () {
			this.inherited(arguments);
			if (this._refreshTimeout) {
				clearTimeout(this._refreshTimeout);
			}
		},

		renderQuery: function (query, options) {
			// summary:
			//		Creates a preload node for rendering a query into, and executes the query
			//		for the first page of data. Subsequent data will be downloaded as it comes
			//		into view.
			// query: Function
			//		Function to be called when requesting new data.
			// options: Object?
			//		Optional object containing the following:
			//		* container: Container to build preload nodes within; defaults to this.contentNode

			var self = this,
				container = (options && options.container) || this.contentNode,
				preload = {
					query: query,
					count: 0
				},
				preloadNode,
				priorPreload = this.preload;

			// Initial query; set up top and bottom preload nodes
			var topPreload = {
				node: domConstruct.create('div', {
					className: 'dgrid-preload',
					style: { height: '0' }
				}, container),
				count: 0,
				query: query,
				next: preload
			};
			topPreload.node.rowIndex = 0;
			preload.node = preloadNode = domConstruct.create('div', {
				className: 'dgrid-preload'
			}, container);
			preload.previous = topPreload;

			// this preload node is used to represent the area of the grid that hasn't been
			// downloaded yet
			preloadNode.rowIndex = this.minRowsPerPage;

			if (priorPreload) {
				// the preload nodes (if there are multiple) are represented as a linked list, need to insert it
				if ((preload.next = priorPreload.next) &&
						// is this preload node below the prior preload node?
						preloadNode.offsetTop >= priorPreload.node.offsetTop) {
					// the prior preload is above/before in the linked list
					preload.previous = priorPreload;
				}
				else {
					// the prior preload is below/after in the linked list
					preload.next = priorPreload;
					preload.previous = priorPreload.previous;
				}
				// adjust the previous and next links so the linked list is proper
				preload.previous.next = preload;
				preload.next.previous = preload;
			}
			else {
				this.preload = preload;
			}

			var loadingNode = domConstruct.create('div', {
					className: 'dgrid-loading'
				}, preloadNode, 'before'),
				innerNode = domConstruct.create('div', {
					className: 'dgrid-below'
				}, loadingNode);
			innerNode.innerHTML = this.loadingMessage;

			// Establish query options, mixing in our own.
			options = lang.mixin({ start: 0, count: this.minRowsPerPage },
				'level' in query ? { queryLevel: query.level } : null);

			// Protect the query within a _trackError call, but return the resulting collection
			return this._trackError(function () {
				var results = query(options);

				// Render the result set
				return self.renderQueryResults(results, preloadNode, options).then(function (trs) {
					return results.totalLength.then(function (total) {
						var trCount = trs.length,
							parentNode = preloadNode.parentNode,
							noDataNode = self.noDataNode;

						if (self._rows) {
							self._rows.min = 0;
							self._rows.max = trCount === total ? Infinity : trCount - 1;
						}

						domConstruct.destroy(loadingNode);
						if (!('queryLevel' in options)) {
							self._total = total;
						}
						// now we need to adjust the height and total count based on the first result set
						if (total === 0 && parentNode) {
							if (noDataNode) {
								domConstruct.destroy(noDataNode);
								delete self.noDataNode;
							}
							self.noDataNode = noDataNode = domConstruct.create('div', {
								className: 'dgrid-no-data',
								innerHTML: self.noDataMessage
							});
							self._emit('noData');
							parentNode.insertBefore(noDataNode, self._getFirstRowSibling(parentNode));
						}
						var height = 0;
						for (var i = 0; i < trCount; i++) {
							height += self._calcRowHeight(trs[i]);
						}
						// only update rowHeight if we actually got results and are visible
						if (trCount && height) {
							self.rowHeight = height / trCount;
						}

						total -= trCount;
						preload.count = total;
						preloadNode.rowIndex = trCount;
						if (total) {
							preloadNode.style.height = Math.min(total * self.rowHeight, self.maxEmptySpace) + 'px';
						}
						else {
							preloadNode.style.display = 'none';
						}

						if (self._previousScrollPosition) {
							// Restore position after a refresh operation w/ keepScrollPosition
							self.scrollTo(self._previousScrollPosition);
							delete self._previousScrollPosition;
						}

						// Redo scroll processing in case the query didn't fill the screen,
						// or in case scroll position was restored
						return when(self._processScroll()).then(function () {
							return trs;
						});
					});
				}).otherwise(function (err) {
					// remove the loadingNode and re-throw
					domConstruct.destroy(loadingNode);
					throw err;
				});
			});
		},

		refresh: function (options) {
			// summary:
			//		Refreshes the contents of the grid.
			// options: Object?
			//		Optional object, supporting the following parameters:
			//		* keepScrollPosition: like the keepScrollPosition instance property;
			//			specifying it in the options here will override the instance
			//			property's value for this specific refresh call only.

			var self = this,
				keep = (options && options.keepScrollPosition);

			// Fall back to instance property if option is not defined
			if (typeof keep === 'undefined') {
				//keep = this.keepScrollPosition;
			}

			// Store scroll position to be restored after new total is received
			if (keep) {
				this._previousScrollPosition = this.getScrollPosition();
			}

			this.inherited(arguments);
			if (this._renderedCollection) {
				// render the query

				// renderQuery calls _trackError internally
				return this.renderQuery(function (queryOptions) {
					return self._renderedCollection.fetchRange({
						start: queryOptions.start,
						end: queryOptions.start + queryOptions.count
					});
				}).then(function () {
					// Emit on a separate turn to enable event to be used consistently for
					// initial render, regardless of whether the backing store is async
					self._refreshTimeout = setTimeout(function () {
						on.emit(self.domNode, 'dgrid-refresh-complete', {
							bubbles: true,
							cancelable: false,
							grid: self
						});
						self._refreshTimeout = null;
					}, 0);
				});
			}
		},

		resize: function () {
			this.inherited(arguments);
			this._processScroll();
		},

		cleanup: function () {
			this.inherited(arguments);
			this.preload = null;
		},

		renderQueryResults: function (results) {
			var rows = this.inherited(arguments);
			var collection = this._renderedCollection;

			if (collection && collection.releaseRange) {
				rows.then(function (resolvedRows) {
					if (resolvedRows[0] && !resolvedRows[0].parentNode.tagName) {
						// Release this range, since it was never actually rendered;
						// need to wait until totalLength promise resolves, since
						// Trackable only adds the range then to begin with
						results.totalLength.then(function () {
							collection.releaseRange(resolvedRows[0].rowIndex,
								resolvedRows[resolvedRows.length - 1].rowIndex + 1);
						});
					}
				});
			}

			return rows;
		},

		_getFirstRowSibling: function (container) {
			// summary:
			//		Returns the DOM node that a new row should be inserted before
			//		when there are no other rows in the current result set.
			//		In the case of OnDemandList, this will always be the last child
			//		of the container (which will be a trailing preload node).
			return container.lastChild;
		},

		_calcRowHeight: function (rowElement) {
			// summary:
			//		Calculate the height of a row. This is a method so it can be overriden for
			//		plugins that add connected elements to a row, like the tree

			var sibling = rowElement.nextSibling;

			// If a next row exists, compare the top of this row with the
			// next one (in case "rows" are actually rendering side-by-side).
			// If no next row exists, this is either the last or only row,
			// in which case we count its own height.
			if (sibling && !/\bdgrid-preload\b/.test(sibling.className)) {
				return sibling.offsetTop - rowElement.offsetTop;
			}

			return rowElement.offsetHeight;
		},

		lastScrollTop: 0,
		_processScroll: function (evt) {
			// summary:
			//		Checks to make sure that everything in the viewable area has been
			//		downloaded, and triggering a request for the necessary data when needed.

			if (!this.rowHeight) {
				return;
			}

			var grid = this,
				scrollNode = grid.bodyNode,
				// grab current visible top from event if provided, otherwise from node
				visibleTop = (evt && evt.scrollTop) || this.getScrollPosition().y,
				visibleBottom = scrollNode.offsetHeight + visibleTop,
				priorPreload, preloadNode, preload = grid.preload,
				lastScrollTop = grid.lastScrollTop,
				requestBuffer = grid.bufferRows * grid.rowHeight,
				searchBuffer = requestBuffer - grid.rowHeight, // Avoid rounding causing multiple queries
				// References related to emitting dgrid-refresh-complete if applicable
				lastRows,
				preloadSearchNext = true;

			// XXX: I do not know why this happens.
			// munging the actual location of the viewport relative to the preload node by a few pixels in either
			// direction is necessary because at least WebKit on Windows seems to have an error that causes it to
			// not quite get the entire element being focused in the viewport during keyboard navigation,
			// which means it becomes impossible to load more data using keyboard navigation because there is
			// no more data to scroll to to trigger the fetch.
			// 1 is arbitrary and just gets it to work correctly with our current test cases; dont wanna go
			// crazy and set it to a big number without understanding more about what is going on.
			// wondering if it has to do with border-box or something, but changing the border widths does not
			// seem to make it break more or less, so I do not know
			var mungeAmount = 1;

			grid.lastScrollTop = visibleTop;

			function removeDistantNodes(preload, distanceOff, traversal, below) {
				// we check to see the the nodes are "far off"
				var farOffRemoval = grid.farOffRemoval,
					preloadNode = preload.node;
				// by checking to see if it is the farOffRemoval distance away
				if (distanceOff > 2 * farOffRemoval) {
					// there is a preloadNode that is far off;
					// remove rows until we get to in the current viewport
					var row;
					var nextRow = preloadNode[traversal];
					var reclaimedHeight = 0;
					var count = 0;
					var toDelete = [];
					var firstRowIndex = nextRow && nextRow.rowIndex;
					var lastRowIndex;

					while ((row = nextRow)) {
						var rowHeight = grid._calcRowHeight(row);
						if (reclaimedHeight + rowHeight + farOffRemoval > distanceOff ||
								(nextRow.className.indexOf('dgrid-row') < 0 &&
									nextRow.className.indexOf('dgrid-loading') < 0)) {
							// we have reclaimed enough rows or we have gone beyond grid rows
							break;
						}

						nextRow = row[traversal];
						reclaimedHeight += rowHeight;
						count += row.count || 1;
						// Just do cleanup here, as we will do a more efficient node destruction in a setTimeout below
						grid.removeRow(row, true);
						toDelete.push(row);

						if ('rowIndex' in row) {
							lastRowIndex = row.rowIndex;
						}
					}

					if (grid._renderedCollection.releaseRange &&
							typeof firstRowIndex === 'number' && typeof lastRowIndex === 'number') {
						// Note that currently child rows in Tree structures are never unrendered;
						// this logic will need to be revisited when that is addressed.

						// releaseRange is end-exclusive, and won't remove anything if start >= end.
						if (below) {
							grid._renderedCollection.releaseRange(lastRowIndex, firstRowIndex + 1);
						}
						else {
							grid._renderedCollection.releaseRange(firstRowIndex, lastRowIndex + 1);
						}

						grid._rows[below ? 'max' : 'min'] = lastRowIndex;
						if (grid._rows.max >= grid._total - 1) {
							grid._rows.max = Infinity;
						}
					}
					// now adjust the preloadNode based on the reclaimed space
					preload.count += count;
					if (below) {
						preloadNode.rowIndex -= count;
						adjustHeight(preload);
					}
					else {
						// if it is above, we can calculate the change in exact row changes,
						// which we must do to not mess with the scroll position
						preloadNode.style.height = (preloadNode.offsetHeight + reclaimedHeight) + 'px';
					}
					// we remove the elements after expanding the preload node so that
					// the contraction doesn't alter the scroll position
					var trashBin = document.createElement('div');
					for (var i = toDelete.length; i--;) {
						trashBin.appendChild(toDelete[i]);
					}
					setTimeout(function () {
						// we can defer the destruction until later
						domConstruct.destroy(trashBin);
					}, 1);
				}
			}

			function adjustHeight(preload, noMax) {
				preload.node.style.height = Math.min(preload.count * grid.rowHeight,
					noMax ? Infinity : grid.maxEmptySpace) + 'px';
			}
			function traversePreload(preload, moveNext) {
				// Skip past preloads that are not currently connected
				do {
					preload = moveNext ? preload.next : preload.previous;
				} while (preload && !preload.node.offsetWidth);
				return preload;
			}
			while (preload && !preload.node.offsetWidth) {
				// skip past preloads that are not currently connected
				preload = preload.previous;
			}
			// there can be multiple preloadNodes (if they split, or multiple queries are created),
			//	so we can traverse them until we find whatever is in the current viewport, making
			//	sure we don't backtrack
			while (preload && preload !== priorPreload) {
				priorPreload = grid.preload;
				grid.preload = preload;
				preloadNode = preload.node;
				var preloadTop = preloadNode.offsetTop;
				var preloadHeight;

				if (visibleBottom + mungeAmount + searchBuffer < preloadTop) {
					// the preload is below the line of sight
					preload = traversePreload(preload, (preloadSearchNext = false));
				}
				else if (visibleTop - mungeAmount - searchBuffer >
						(preloadTop + (preloadHeight = preloadNode.offsetHeight))) {
					// the preload is above the line of sight
					preload = traversePreload(preload, (preloadSearchNext = true));
				}
				else {
					// the preload node is visible, or close to visible, better show it
					var offset = ((preloadNode.rowIndex ? visibleTop - requestBuffer :
						visibleBottom) - preloadTop) / grid.rowHeight;
					var count = (visibleBottom - visibleTop + 2 * requestBuffer) / grid.rowHeight;
					// utilize momentum for predictions
					var momentum = Math.max(
						Math.min((visibleTop - lastScrollTop) * grid.rowHeight, grid.maxRowsPerPage / 2),
						grid.maxRowsPerPage / -2);
					count += Math.min(Math.abs(momentum), 10);
					if (preloadNode.rowIndex === 0) {
						// at the top, adjust from bottom to top
						offset -= count;
					}
					offset = Math.max(offset, 0);
					if (offset < 10 && offset > 0 && count + offset < grid.maxRowsPerPage) {
						// connect to the top of the preloadNode if possible to avoid excessive adjustments
						count += Math.max(0, offset);
						offset = 0;
					}
					count = Math.min(Math.max(count, grid.minRowsPerPage),
										grid.maxRowsPerPage, preload.count);

					if (count === 0) {
						preload = traversePreload(preload, preloadSearchNext);
						continue;
					}

					count = Math.ceil(count);
					offset = Math.min(Math.floor(offset), preload.count - count);

					var options = {};
					preload.count -= count;
					var beforeNode = preloadNode,
						keepScrollTo, queryRowsOverlap = grid.queryRowsOverlap,
						below = (preloadNode.rowIndex > 0 || preloadNode.offsetTop > visibleTop) && preload;
					if (below) {
						// add new rows below
						var previous = preload.previous;
						if (previous) {
							removeDistantNodes(previous,
								visibleTop - (previous.node.offsetTop + previous.node.offsetHeight),
								'nextSibling');
							if (offset > 0 && previous.node === preloadNode.previousSibling) {
								// all of the nodes above were removed
								offset = Math.min(preload.count, offset);
								preload.previous.count += offset;
								adjustHeight(preload.previous, true);
								preloadNode.rowIndex += offset;
								queryRowsOverlap = 0;
							}
							else {
								count += offset;
							}
							preload.count -= offset;
						}
						options.start = preloadNode.rowIndex - queryRowsOverlap;
						options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
						preloadNode.rowIndex = options.start + options.count;
					}
					else {
						// add new rows above
						if (preload.next) {
							// remove out of sight nodes first
							removeDistantNodes(preload.next, preload.next.node.offsetTop - visibleBottom,
								'previousSibling', true);
							beforeNode = preloadNode.nextSibling;
							if (beforeNode === preload.next.node) {
								// all of the nodes were removed, can position wherever we want
								preload.next.count += preload.count - offset;
								preload.next.node.rowIndex = offset + count;
								adjustHeight(preload.next);
								preload.count = offset;
								queryRowsOverlap = 0;
							}
							else {
								keepScrollTo = true;
							}

						}
						options.start = preload.count;
						options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
					}
					if (keepScrollTo && beforeNode && beforeNode.offsetWidth) {
						keepScrollTo = beforeNode.offsetTop;
					}

					adjustHeight(preload);

					// use the query associated with the preload node to get the next "page"
					if ('level' in preload.query) {
						options.queryLevel = preload.query.level;
					}

					// Avoid spurious queries (ideally this should be unnecessary...)
					if (!('queryLevel' in options) && (options.start > grid._total || options.count < 0)) {
						continue;
					}

					// create a loading node as a placeholder while the data is loaded
					var loadingNode = domConstruct.create('div', {
						className: 'dgrid-loading',
						style: { height: count * grid.rowHeight + 'px' }
					}, beforeNode, 'before');
					domConstruct.create('div', {
						className: 'dgrid-' + (below ? 'below' : 'above'),
						innerHTML: grid.loadingMessage
					}, loadingNode);
					loadingNode.count = count;

					// Query now to fill in these rows.
					grid._trackError(function () {
						// Use function to isolate the variables in case we make multiple requests
						// (which can happen if we need to render on both sides of an island of already-rendered rows)
						(function (loadingNode, below, keepScrollTo) {
							/* jshint maxlen: 122 */
							var rangeResults = preload.query(options);
							lastRows = grid.renderQueryResults(rangeResults, loadingNode, options).then(function (rows) {
								var gridRows = grid._rows;
								if (gridRows && !('queryLevel' in options) && rows.length) {
									// Update relevant observed range for top-level items
									if (below) {
										if (gridRows.max <= gridRows.min) {
											// All rows were removed; update start of rendered range as well
											gridRows.min = rows[0].rowIndex;
										}
										gridRows.max = rows[rows.length - 1].rowIndex;
									}
									else {
										if (gridRows.max <= gridRows.min) {
											// All rows were removed; update end of rendered range as well
											gridRows.max = rows[rows.length - 1].rowIndex;
										}
										gridRows.min = rows[0].rowIndex;
									}
								}

								// can remove the loading node now
								beforeNode = loadingNode.nextSibling;
								domConstruct.destroy(loadingNode);
								// beforeNode may have been removed if the query results loading node was removed
								// as a distant node before rendering
								if (keepScrollTo && beforeNode && beforeNode.offsetWidth) {
									// if the preload area above the nodes is approximated based on average
									// row height, we may need to adjust the scroll once they are filled in
									// so we don't "jump" in the scrolling position
									var pos = grid.getScrollPosition();
									grid.scrollTo({
										// Since we already had to query the scroll position,
										// include x to avoid TouchScroll querying it again on its end.
										x: pos.x,
										y: pos.y + beforeNode.offsetTop - keepScrollTo,
										// Don't kill momentum mid-scroll (for TouchScroll only).
										preserveMomentum: true
									});
								}

								rangeResults.totalLength.then(function (total) {
									if (!('queryLevel' in options)) {
										grid._total = total;
										if (grid._rows && grid._rows.max >= grid._total - 1) {
											grid._rows.max = Infinity;
										}
									}
									if (below) {
										// if it is below, we will use the total from the collection to update
										// the count of the last preload in case the total changes as
										// later pages are retrieved

										// recalculate the count
										below.count = total - below.node.rowIndex;
										// readjust the height
										adjustHeight(below);
									}
								});

								// make sure we have covered the visible area
								grid._processScroll();
								return rows;
							}, function (e) {
								domConstruct.destroy(loadingNode);
								throw e;
							});
						})(loadingNode, below, keepScrollTo);
					});

					preload = preload.previous;

				}
			}

			// return the promise from the last render
			return lastRows;
		}
	});

});

define('dgrid/OnDemandGrid',[
	'dojo/_base/declare',
	'./Grid',
	'./OnDemandList'
], function (declare, Grid, OnDemandList) {
	return declare([ Grid, OnDemandList ], {});
});
/** @module xgrid/Defaults **/
define('xgrid/Defaults',[
    'xdojo/declare'
], function (declare) {
    /**
     * xGrid defaults
     * */
    return declare('xgrid/Defaults', null, {
        minRowsPerPage: 100,
        keepScrollPosition: true,
        rowsPerPage: 30,
        deselectOnRefresh: false,
        cellNavigation: false,
        _skipFirstRender: false,
        loadingMessage: null,
        preload: null,
        childSelector: ".dgrid-row",
        addUiClasses: false,
        noDataMessage: '<span class="textWarning">No data....</span>',
        showExtraSpace:true,
        expandOnClick:true
    });
});

/** module:xide/registry **/
define('xide/registry',[
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
    "xdojo/has"
], function(array, win, has){
	/**
	 * @TODOS:
	 * - add namespaces
	 * - remove window
	 * - augment consumer API
	 * - use std array
	 * - add framework constraint
	 * - move dom api out of here
	 * - define widget.id better
	 * - add search by class
     */
	var _widgetTypeCtr = {}, hash = {};
	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,
		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
                if(has('xblox')) {
                    this.remove(widget.id);
                    this.add(widget);
                }else{
                    throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
                }
			}
			hash[widget.id] = widget;
			this.length++;
		},
		/**
		 * Remove a widget from the registry. Does not destroy the widget; simply
		 * removes the reference.
		 * @param id
         */
		remove: function(id){
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},
		/**
		 *
		 * @param id {String|Widget}
		 * @returns {String|Widget}
         */
		byId: function( id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},
		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		/**
		 * Convert registry into a true Array
		 * @example:
		 *	Work with the widget .domNodes in a real Array
		 *	array.map(registry.toArray(), function(w){ return w.domNode; });
		 * @returns {obj[]}
         */
		toArray: function(){
			return _.values(_.mapKeys(hash, function(value, key) { value.id = key; return value; }));
		},
		/**
		 * Generates a unique id for a given widgetType
		 * @param widgetType {string}
		 * @returns {string}
         */
		getUniqueId: function(widgetType){
			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return id;
		},
		/**
		 * Search subtree under root returning widgets found.
		 * Doesn't search for nested widgets (ie, widgets inside other widgets).
		 * @param root {HTMLElement} Node to search under.
		 * @param skipNode {HTMLElement} If specified, don't search beneath this node (usually containerNode).
         * @returns {Array}
         */
		findWidgets: function(root, skipNode){
			var outAry = [];
			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}
			getChildrenHelper(root);
			return outAry;
		},
		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			// Destroy all the widgets, top down
			_.each(registry.findWidgets(win.body()),function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},
		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};
	return registry;
});

/** @module xide/widgets/_Widget **/
define('xide/widgets/_Widget',[
    'xdojo/declare',
    'dcl/dcl',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'xlang/i18'
], function (declare,dcl,utils,EventedMixin,registry,i18) {
    var forwardMethods = ['resize'];
    function _resize(what){
        try {
            if (typeof what['resize'] === "function" && what._started) {
                what['resize'].apply(what,arguments);
            }else{
                console.warn('widget has no resize or is not started yet ' + what.declaredClass,[what,what.resize]);
            }
        }catch(e){
            logError(e,'error resizing sub widget ' + what.id + ' class:'+what.declaredClass);
        }
    }

    function forward(method,args){
        _.each(this._widgets,function(what){
            if (what && typeof what[method] === "function") {
                what[method].apply(what,args);
            }
        },this);
    }

    function set(prop,value){
        _.each(this._widgets,function(what){
            if (what && what[prop]) {
                what[prop] = value;
            }
        },this);
    }

    /**
     * @class module:xide/widgets/_Widget
     */
    var Implementation = {
        _widgets:null,
        __eventHandles:null,
        _isResizing:false,
        cssClass:'',
        /**
         * @type {module:xide/manager/ContextBase}
         */
        ctx:null,
        /**
         *
         * @returns {module:xide/manager/ContextBase}
         */
        getContext:function(){
            return this.ctx;
        },
        onResizeBegin:function(){
            this._isResizing=true;
            _.each(this._widgets,function(what){
                what && (what._isResizing=true);
            },this);
        },
        onResizeEnd:function(){
            this._isResizing=false;
            _.each(this._widgets,function(what){
                what && (what._isResizing=false);
            },this);
        },
        _toWidget:function(element){
            if(element && element.id){
                var widget = registry.byId(element.id);
                if(widget){
                    return widget;
                }
            }
            return null;
        },
        parentByClass :function(className,max){
            var i = 0,
                element = this.domNode,
                widget = null;
            max = max || 20;
            while (!widget && i < max && element) {
                if (element) {
                    var _widget = this._toWidget(element);
                    if(_widget && _widget.declaredClass){
                        if(_widget.declaredClass === className){
                            widget = _widget;
                        }
                    }
                    element = element.parentNode;
                }
                i++;
            }
            return widget;
        },
        _startWidgets:function(){
            var result = false;
            if(this._widgets) {
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    if (w && !w._started && w.startup) {
                        w.startup();
                        w._started = true;
                        result = true;
                        w._emit('startup');
                    }
                }
            }
            return result;
        },
        _createForward:function(method){
            var self = this;
            if(!this[method]){
                this[method] = function(){
                    for (var i = 0; i < self._widgets.length; i++) {
                        var w = self._widgets[i];
                        w[method] && w[method]();
                    }
                };
            }
        },
        onShow:function(){
            if(this._widgets){
                this._startWidgets();
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    if(w && w!==this) {
                        w._showing=true;
                        w.open = true;
                        w.onShow && w.onShow();
                        w._emit && w._emit('show',{});

                    }
                }
            }
        },
        onHide:function(){
            if(this._widgets){
                for (var i = 0; i < this._widgets.length; i++) {
                    var w = this._widgets[i];
                    
                    if(!w){
                        console.warn('invalid widget');
                    }else {
                        if(w!==this){
                            w._showing = false;
                            w.open = false;
                            w.onHide && w.onHide();
                            try{
                                w._emit && w._emit('hide',{});
                            }catch(e){
                                logError(e,'error emitting on-hide');
                            }

                        }
                    }
                }
            }
        },
        _getChildren:function(){
            return this._widgets;
        },
        debounce:function(methodName,_function,delay,options,now){
            return utils.debounce(this,methodName,_function,delay,options,now);
        },
        __addHandler:function(element,type,handler){
            if(!element){
                return;
            }
            handler = _.isString(handler) ? this[handler] ? this[handler] : null : handler;
            var self = this;

            if(typeof handler ==='function'){
                return this.__on(element,type,null,function(){
                    handler.apply(self,arguments);
                });
            }
            return false;
        },
        _shouldResizeWidgets:function(){
            return true;
        },
        resize:function(){
            var _args = arguments;
            this.inherited && this.inherited(_args);
            if(this.shouldResizeWidgets && this.shouldResizeWidgets()===false){
                return;
            }
            //if(this._isResizing ===true){return;}
            if(this._widgets){
                for (var i = 0; i < this._widgets.length; i++) {
                    var what = this._widgets[i];
                    if (what) {
                        what.resizeToParent && utils.resizeTo(what, this, true, true);
                        if (what && typeof what['resize'] === "function" && what._started) {
                            what['resize'].apply(what, _args);
                        }
                    }
                }
            }
        },
        destroy:function(){
            this.inherited && this.inherited(arguments);
            var _widgets = this._widgets;
            if (_widgets) {
                for (var i = 0; i < _widgets.length; i++) {
                    var widget = _widgets[i];
                    if (widget && widget != this && widget._destroyed !== true) {
                        utils.destroy(widget);
                    }
                }
                delete this._widgets;
                this._widgets = null;
            }
            if(this.domNode) {
                registry.remove(this.domNode.id);
                utils.destroy(this.domNode);
            }
            this._destroyed = true;
        },
        onAdded:function(){
        },
        /**
         *
         * @param mixed
         * @param options
         * @param parent
         * @param startup
         * @param select
         * @param extension
         * @returns {*}
         */
        add:function(mixed,options,parent,startup,select,extension){
            if(mixed==this){
                return mixed;
            }
            !this._widgets && (this._widgets = []);

            var widgets = this._widgets;
            if(_.isNumber(options)){
                options = null;
            }
            if(options!==null && !_.isObject(options)){
                options ={};
            }
            var result = null;

            _.isEmpty(options) && (options=null);

            var _parent = parent || ( parent!==false ? this.containerNode || this.domNode : null);

            //case 1: instance or object
            if((mixed && !options && !parent) || (!options && !parent && !startup && !select && !extension)){
                widgets.indexOf(mixed)==-1 && (widgets.push(mixed));
                return mixed;

            //case 2: proto
            }else if(mixed && options){
                result = utils.addWidget(mixed,options,this,_parent,startup,null,null,select,extension);
                widgets.push(result);
            }
            return result;
        },
        remove:function(mixed){
            this._widgets && this._widgets.remove(mixed);
        },
        buildRendering:function() {
            this.inherited && this.inherited(arguments);
            var node = utils.getNode(this);
            node && this.cssClass && $(node).addClass(this.cssClass);
            node && this.style && $(node).attr('style',this.style);
        }
    };

    var _Widget = dcl([EventedMixin.dcl,i18.dcl],Implementation);
    var Module = declare('xide/widgets/_Widget',i18,Implementation);
    Module.Implmentation = Implementation;
    Module.dcl = _Widget;
    dcl.chainAfter(_Widget,'destroy');
    dcl.chainAfter(_Widget,'onResizeBegin');
    dcl.chainAfter(_Widget,'onResizeEnd');
    return Module;
});

/**
 * @module xide/_base/_Widget
 */
define('xide/_base/_Widget',[
    'dcl/dcl',
    "dcl/inherited",
    'xide/widgets/_Widget',
    "xide/utils",
    "dojo/string",
    "dojo/_base/lang",
    "xide/registry",
    "dojo/cache",
    "dojo/dom-construct",
    'xide/lodash',
    'xide/$'
], function (dcl,inherited,_Widget,utils,string,lang,registry,cache,domConstruct,_,$) {

    function destroy(w,preserveDom){
        if(w.destroyRecursive){
            w.destroyRecursive(preserveDom);
        }else if(w.destroy){
            w.destroy(preserveDom);
        }
    }

    /////////////////////////////////////////////////////////////////
    //
    //  Attach Mixin Class
    //
    var attachAttribute = 'attachTo';
    /**
     *		Mixin for widgets to attach to dom nodes and setup events via
     *		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
     *
     *		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
     *		server.
     *
     *		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
     *		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
     *		doesn't.


     * _attachPoints: [private] String[]
     *		List of widget attribute names associated with data-dojo-attach-point=... in the
     *		template, ex: ["containerNode", "labelNode"]
     _attachPoints: [],

     * _attachEvents: [private] Handle[]
     *		List of connections associated with data-dojo-attach-event=... in the
     *		template
     _attachEvents: [],

     * attachScope: [public] Object
     *		Object to which attach points and events will be scoped.  Defaults
     *		to 'this'.
     attachScope: undefined,
     */
    var _AttachMixinClass = dcl(null, {
        __attachAsjQueryObject:true,
        __attachViaAddChild:true,
        __stopAtContainerNode:false,
        _started:false,
        //attachDirect:true,
        declaredClass:"xide/_base/_AttachMixin",
        cssClass:'',
        /**
         * Attach to DOM nodes marked with special attributes.
         */
        buildRendering: function(){
            this._attachPoints = [];
            // recurse through the node, looking for, and attaching to, our
            // attachment points and events, which should be defined on the template node.
            this._attachTemplateNodes(this.domNode);
            this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
            this.cssClass && this.domNode && $(this.domNode).addClass(this.cssClass);
        },
        _beforeFillContent: function(){},
        /**
         * Iterate through the dom nodes and attach functions and nodes accordingly.
         * @description Map widget properties and functions to the handlers specified in
         *		the dom node and it's descendants. This function iterates over all
         *		nodes and looks for these properties:
         *	    - attachTo
         * @param rootNode {HTMLElement}
         **/
        _attachTemplateNodes: function(rootNode){
            // DFS to process all nodes except those inside of this.containerNode
            var node = rootNode;
            while(true){
                if  (
                    node.nodeType == 1 &&
                    ( this._processTemplateNode(node,function(n,p){return n.getAttribute(p);},this._attach)) &&
                    node.firstChild
                ){
                    node = node.firstChild;
                }else{
                    if(node == rootNode){
                        return;
                    }
                    while(!node.nextSibling){
                        node = node.parentNode;
                        if(node == rootNode){
                            return;
                        }
                    }
                    node = node.nextSibling;
                }
            }
        },

        _processTemplateNode: function(baseNode, getAttrFunc, attachFunc){
            // summary:
            //		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
            //		Returns true if caller should process baseNode's children too.
            var ret = true;

            // Process data-dojo-attach-point
            var _attachScope = this.attachScope || this,
                attachPoint = getAttrFunc(baseNode, attachAttribute);

            if(attachPoint){
                var point, points = attachPoint.split(/\s*,\s*/);
                while((point = points.shift())){
                    if(_.isArray(_attachScope[point])){
                        _attachScope[point].push(baseNode);
                    }else{
                        _attachScope[point] = baseNode;
                        this.__attachAsjQueryObject &&  (_attachScope['$'+point] = $(baseNode));
                    }
                    ret = this.__stopAtContainerNode ? (point != "containerNode") : ret;
                    this._attachPoints.push(point);
                }
            }
            return ret;
        },
        /**
         * Detach and clean up the attachments made in _attachtempalteNodes.
         * @private
         */
        _detachTemplateNodes: function() {
            // Delete all attach points to prevent IE6 memory leaks.
            var _attachScope = this.attachScope || this;
            _.each(this._attachPoints, function(point){
                delete _attachScope[point];
            });
            this._attachPoints = [];
        },
        destroyRendering: function(){
            this._detachTemplateNodes();
            this.inherited && this.inherited(arguments);
        },
        startup:dcl.superCall(function(sup) {
            return function () {
                var res = null;
                if(sup){
                    res = sup.call(this);
                }
                this._started=true;
                return res;
            };
        })
    });
    /////////////////////////////////////////////////////////////////
    //
    //  Templated Mixin Class
    //
    //
    var _TemplatedMixin = dcl(_AttachMixinClass, {
        declaredClass:"xide/_base/_TemplatedMixin",
        // summary:
        //		Mixin for widgets that are instantiated from a template
        // templateString: [protected] String
        //		A string that represents the widget template.
        //		Use in conjunction with dojo.cache() to load from a file.
        templateString: null,
        // templatePath: [protected deprecated] String
        //		Path to template (HTML file) for this widget relative to dojo.baseUrl.
        //		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
        templatePath: null,
        // skipNodeCache: [protected] Boolean
        //		If using a cached widget template nodes poses issues for a
        //		particular widget class, it can set this property to ensure
        //		that its template is always re-built from a string
        _skipNodeCache: false,
        /*=====
         // _rendered: Boolean
         //		Not normally use, but this flag can be set by the app if the server has already rendered the template,
         //		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
         //		just function like _AttachMixin.
         _rendered: false,
         =====*/
        _stringRepl: function(tmpl){
            // summary:
            //		Does substitution of ${foo} type properties in template string
            // tags:
            //		private
            var className = this.declaredClass, _this = this;
            // Cache contains a string because we need to do property replacement
            // do the property replacement
            return string.substitute(tmpl, this, function(value, key){
                if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
                if(typeof value == "undefined"){
                    var error = new Error(className+" template:"+key)
                    logError(error);
                } // a debugging aide
                if(value == null){ return ""; }

                // Substitution keys beginning with ! will skip the transform step,
                // in case a user wishes to insert unescaped markup, e.g. ${!foo}
                return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
            }, this);
        },
        _escapeValue: function(/*String*/ val){
            // summary:
            //		Escape a value to be inserted into the template, either into an attribute value
            //		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

            // Safer substitution, see heading "Attribute values" in
            // http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
            // and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
            return val.replace(/["'<>&]/g, function(val){
                return {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    "\"": "&quot;",
                    "'": "&#x27;"
                }[val];
            });
        },
        /*
         * @description Construct the UI for this widget from a template, setting this.domNode.
         */
        buildRendering: dcl.superCall(function(sup){
            return function(){
                if(!this._rendered){
                    if(!this.templateString){
                        this.templateString = cache(this.templatePath, {sanitize: true});
                    }
                    // Lookup cached version of template, and download to cache if it
                    // isn't there already.  Returns either a DomNode or a string, depending on
                    // whether or not the template contains ${foo} replacement parameters.
                    var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);
                    var node;
                    if(_.isString(cached)){
                        node =  $(this._stringRepl(cached))[0];
                        if(node.nodeType != 1){
                            // Flag common problems such as templates with multiple top level nodes (nodeType == 11)
                            throw new Error("Invalid template: " + cached);
                        }
                    }else{
                        // if it's a node, all we have to do is clone it
                        node = cached.cloneNode(true);
                    }
                    this.domNode = node;
                }

                // Call down to _WidgetBase.buildRendering() to get base classes assigned
                sup.call(this, arguments);
                if(!this._rendered){
                    this._fillContent(this.srcNodeRef);
                }
                this._rendered = true;
                if(this.domNode && this.declaredClass){
                    $(this.domNode).addClass(utils.replaceAll('/','.',this.declaredClass));
                }
            };
        }),
        /**
         *
         * @param source {HTMLElement}
         * @private
         */
        _fillContent: function(source){
            // summary:
            //		Relocate source contents to templated container node.
            //		this.containerNode must be able to receive children, or exceptions will be thrown.
            // tags:
            //		protected
            var dest = this.containerNode;
            if(source && dest){
                while(source.hasChildNodes()){
                    dest.appendChild(source.firstChild);
                }
            }
        }

    });

    // key is templateString; object is either string or DOM tree
    _TemplatedMixin._templateCache = {};
    _TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
        // summary:
        //		Static method to get a template based on the templatePath or
        //		templateString key
        // templateString: String
        //		The template
        // alwaysUseString: Boolean
        //		Don't cache the DOM tree for this template, even if it doesn't have any variables
        // doc: Document?
        //		The target document.   Defaults to document global if unspecified.
        // returns: Mixed
        //		Either string (if there are ${} variables that need to be replaced) or just
        //		a DOM tree (if the node can be cloned directly)

        // is it already cached?
        var tmplts = _TemplatedMixin._templateCache;
        var key = templateString;
        var cached = tmplts[key];
        if(cached){
            try{
                // if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
                // current document, then use the current cached value
                if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
                    // string or node of the same document
                    return cached;
                }
            }catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
            domConstruct.destroy(cached);
        }

        templateString = _.trim(templateString);

        if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
            // there are variables in the template so all we can do is cache the string
            return (tmplts[key] = templateString); //String
        }else{
            // there are no variables in the template so we can cache the DOM tree
            var node = domConstruct.toDom(templateString, doc);
            if(node.nodeType != 1){
                throw new Error("Invalid template: " + templateString);
            }
            return (tmplts[key] = node); //Node
        }
    };

    /////////////////////////////////////////////////////////////////
    //
    //  Actual Widget base class, adding an API
    //
    function createClass_WidgetBase(){
        var tagAttrs = {};
        function getAttrs(obj){
            var ret = {};
            for(var attr in obj){
                ret[attr.toLowerCase()] = true;
            }
            return ret;
        }
        function isEqual(a, b){
            //	summary:
            //		Function that determines whether two values are identical,
            //		taking into account that NaN is not normally equal to itself
            //		in JS.
            return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
        }
        /**
         * @class module:xide/_base/_Widget
         */
        var Module = dcl(null,{
            _attrPairNames: {}, // shared between all widgets
            attributeMap: {},
            declaredClass:'xide/_base/_Widget',
            on:function(type,handler){
                return this._on(type,handler);
            },
            emit:function(type,args){
                return this._emit(type,args);
            },
            _set: function(/*String*/ name, /*anything*/ value){
                // summary:
                //		Helper function to set new value for specified property, and call handlers
                //		registered with watch() if the value has changed.
                var oldValue = this[name];
                this[name] = value;
                if(this._created && !isEqual(oldValue, value)){
                    this._watchCallbacks && this._watchCallbacks(name, oldValue, value);
                    this.emit("attrmodified-" + name, {
                        detail: {
                            prevValue: oldValue,
                            newValue: value
                        }
                    });
                }
            },
            /**
             * Helper function to get value for specified property stored by this._set(),
             * i.e. for properties with custom setters.  Used mainly by custom getters.
             *  For example, CheckBox._getValueAttr() calls this._get("value").
             * @param name {string}
             * @returns {*}
             * @private
             */
            _get: function( name){
                // future: return name in this.props ? this.props[name] : this[name];
                return this[name];
            },
            /**
             *  Helper function for get() and set().
             *  Caches attribute name values so we don't do the string ops every time.
             * @param name
             * @returns {*}
             * @private
             */
            _getAttrNames: function(name){
                var apn = this._attrPairNames;
                if(apn[name]){
                    return apn[name];
                }
                var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
                    return c.charAt(c.length - 1).toUpperCase();
                });
                return (apn[name] = {
                    n: name + "Node",
                    s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
                    g: "_get" + uc + "Attr",
                    l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
                });
            },
            /**
             * Set a property on a widget
             * @description Sets named properties on a widget which may potentially be handled by a setter in the widget.
             *
             *		For example, if the widget has properties `foo` and `bar`
             *		and a method named `_setFooAttr()`, calling
             *		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
             *		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
             *		would be equivalent to the statement `widget.bar = 3;`
             *
             *      This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`
             *
             *		set() may also be called with a hash of name/value pairs, ex:
             *
             *	@example
             *	myWidget.set({
                    foo: "Howdy",
                    bar: 3
                    });
             *
             * @param name {string} The property to set.
             * @param value {object|null}
             * @returns {*}
             */
            set: function(name, value){
                if(typeof name === "object"){
                    for(var x in name){
                        this.set(x, name[x]);
                    }
                    return this;
                }
                var names = this._getAttrNames(name),
                    setter = this[names.s];

                if(_.isFunction(setter)){
                    // use the explicit setter
                    setter.apply(this, Array.prototype.slice.call(arguments, 1));
                }else{
                    // Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
                    // Map according to:
                    //		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
                    //		2. _setFooAttr: {...} type attribute in the widget (if one exists)
                    //		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
                    // Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
                    // attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
                    // Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
                    var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
                        tag = this[defaultNode] && this[defaultNode].tagName,
                        attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
                        map = name in this.attributeMap ? this.attributeMap[name] :
                            names.s in this ? this[names.s] :
                                ((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
                                /^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
                    if(map != null){
                        this._attrToDom(name, value, map);
                    }
                    this._set(name, value);
                }
                return this;
            },
            postCreate:function(){
            },
            postMixInProperties:dcl.superCall(function(sup){
                return function(props){
                    sup && sup.call(this, props);
                };
            }),
            create: function(params, srcNodeRef){
                // summary:
                //		Kick off the life-cycle of a widget
                // description:
                //		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
                //		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
                //		for a discussion of the widget creation lifecycle.
                //
                //		Of course, adventurous developers could override create entirely, but this should
                //		only be done as a last resort.
                // params: Object|null
                //		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
                //		and functions, typically callbacks like onClick.
                //		The hash can contain any of the widget's properties, excluding read-only properties.
                // srcNodeRef: DOMNode|String?
                //		If a srcNodeRef (DOM node) is specified:
                //
                //		- use srcNodeRef.innerHTML as my contents
                //		- if this is a behavioral widget then apply behavior to that srcNodeRef
                //		- otherwise, replace srcNodeRef with my generated DOM tree
                // tags:
                //		private

                // First time widget is instantiated, scan prototype to figure out info about custom setters etc.
                //this._introspect();

                // store pointer to original DOM tree
                this.srcNodeRef = $(srcNodeRef)[0];

                // No longer used, remove for 2.0.
                this._connects = [];
                this._supportingWidgets = [];

                // this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
                if(this.srcNodeRef && this.srcNodeRef.id){
                    this.id = this.srcNodeRef.id;
                }

                // mix in our passed parameters
                if(params){
                    this.params = params;
                    utils.mixin(this, params);
                }

                if(this.postMixInProperties) {
                    this.postMixInProperties();
                }

                // Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
                // Do this before buildRendering() because it might expect the id to be there.
                if(!this.id){
                    this.id = registry.getUniqueId(this.declaredClass.replace(/\//g, "_"));
                    if(this.params){
                        // if params contains {id: undefined}, prevent _applyAttributes() from processing it
                        delete this.params.id;
                    }
                }


                // The document and <body> node this widget is associated with
                this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
                this.ownerDocumentBody = $('body')[0];
                registry.add(this);

                this.buildRendering();
                if(this.domNode){
                    // Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
                    // Also calls custom setters for all attributes with custom setters.
                    //this._applyAttributes();

                    // If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
                    // For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
                    // widget being attached to the DOM since it isn't when a widget is created programmatically like
                    // new MyWidget({}).	See #11635.
                    var source = this.srcNodeRef;
                    if(source && source.parentNode && this.domNode !== source){
                        source.parentNode.replaceChild(this.domNode, source);
                    }
                    // Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
                    // assuming that dojo._scopeName even exists in 2.0
                    this.domNode.setAttribute("id", this.id);
                    if(this.style){
                        $(this.domNode).css(this.style);
                    }
                }
                this.postCreate();
                this._created = true;
            },
            constructor:function(params,container){
                this.postscript && this.postscript(params,container);
            },
            postscript:function(params,srcNodeRef){
                return this.create(params, srcNodeRef);
            },
            /**
             *		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             *		is this widget.   Note that it does not return all descendants, but rather just direct children.
             *		Analogous to [Node.childNodes](https:*developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
             *		except containing widgets rather than DOMNodes.
             *
             *		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             *		outside of this.containerNode.
             *
             *		Note that the array returned is a simple array.  Application code should not assume
             *		existence of methods like forEach().
             *
             * @returns {*}
             */
            getChildren: function(){
                return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
            },
            /**
             *
             * @returns {*}
             */
            getParent: function(){
                // summary:
                //		Returns the parent widget of this widget.
                return registry.getEnclosingWidget(this.domNode.parentNode);
            },
            //////////// DESTROY FUNCTIONS ////////////////////////////////
            /**
             * Destroy this widget and its descendants
             * @description If true, this method will leave the original DOM structure
             *		alone of descendant Widgets. Note: This will NOT work with
             *		dijit._TemplatedMixin widgets.
             * @param preserveDom {boolean}
             */
            destroyRecursive: function(preserveDom){
                this._beingDestroyed = true;
                this.destroyDescendants(preserveDom);
                this.destroy(preserveDom);
            },
            /**
             *
             * @param preserveDom {boolean}. If true, this method will leave the original DOM structure alone.
             * Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy: function(preserveDom){
                // summary:
                //		Destroy this widget, but not its descendants.  Descendants means widgets inside of
                //		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
                //
                //		This method will also destroy internal widgets such as those created from a template,
                //		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
                //
                //		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
                //		depend on the current ability to destroy a widget without destroying its descendants.   Generally
                //		they should use destroyRecursive() for widgets with children.
                this._beingDestroyed = true;
                // Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
                // here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
                if(this.domNode){
                    _.each(registry.findWidgets(this.domNode, this.containerNode), destroy);
                }
                this.destroyRendering(preserveDom);
                registry.remove(this.id);
                this._destroyed = true;
                this._emit('destroy');
            },
            /**
             * Destroys the DOM nodes associated with this widget.
             * @param {boolean} preserveDom. If true, this method will leave the original DOM structure alone during tear-down. Note: this will not work with _Templated widgets yet.
             */
            destroyRendering: function(preserveDom){
                if(this.domNode){
                    if(preserveDom){

                    }else{
                        domConstruct.destroy(this.domNode);
                    }
                    delete this.domNode;
                }
                if(this.srcNodeRef){
                    if(!preserveDom){
                        domConstruct.destroy(this.srcNodeRef);
                    }
                    delete this.srcNodeRef;
                }
            },
            destroyDescendants: function(/*Boolean?*/ preserveDom){
                // summary:
                //		Recursively destroy the children of this widget and their
                //		descendants.
                // preserveDom:
                //		If true, the preserveDom attribute is passed to all descendant
                //		widget's .destroy() method. Not for use with _Templated
                //		widgets.

                // get all direct descendants and destroy them recursively
                _.each(this.getChildren(), function(widget){
                    if(widget.destroyRecursive){
                        widget.destroyRecursive(preserveDom);
                    }
                });
            }
        });
        return Module;

    }

    var StoreMixin = dcl(null,{
        wireStore:function(store,updateFn,events){
            store = store || this.store;
            var handles = [];
            events = events || ['update','added','remove','delete'];
            for (var i = 0; i < events.length; i++) {
                var event = events[i];
                var _handle = store.on(event, updateFn.bind(this));
                handles.push(_handle);
                this.addHandle && this.addHandle(event,_handle);
            }
            return handles;
        }
    });
    var _WidgetClass = createClass_WidgetBase();
    /////////////////////////////////////////////////////////////////
    //
    //  Module exports
    //
    //
    var Module = dcl([_WidgetClass,_TemplatedMixin,_Widget.dcl],{});

    Module.AttachClass = _AttachMixinClass;
    Module.TemplateClass = _TemplatedMixin;
    Module.WidgetClass = _WidgetClass;
    Module.StoreMixin = StoreMixin;

    dcl.chainAfter(Module,"resize");
    dcl.chainAfter(Module,"destroy");
    dcl.chainAfter(Module,"startup");
    return Module;
});
define('xide/widgets/TemplatedWidgetBase',[
    'dcl/dcl',
    'xide/utils',
    'xide/_base/_Widget'
], function (dcl,utils,_XWidget2) {
    var Implementation = {
        declaredClass: 'xide.widgets.TemplatedWidgetBase',
        data: null,
        delegate: null,
        didLoad: false,
        templateString: null,
        getParent: function () {
            return this._parent;
        },
        debounce: function (methodName, _function, delay, options, now) {
            return utils.debounce(this, methodName, _function, delay, options, now);
        },
        translate: function (value) {
            return this.localize(value);
        },
        _setupTranslations: function () {
            this._messages = [];
        },
        updateTitleNode: function (value) {}
    };
    var Module = dcl([_XWidget2],Implementation);
    dcl.chainAfter(Module,'startup');
    dcl.chainAfter(Module,'destroy');
    return Module;
});
/** @module xgrid/Layout **/
define('xgrid/Layout',[
    "xdojo/declare",
    'xide/utils',
    'xide/widgets/TemplatedWidgetBase',
    'xide/registry',
    'xide/$'
], function (declare, utils, TemplatedWidgetBase, registry,$) {
    var template = '<div tabindex="-1" attachTo="template" class="grid-template" style="width: 100%;height: 100%;overflow: hidden;position: relative;padding: 0px;margin: 0px">'+
        '<div tabindex="-1" attachTo="header" class="grid-header row" style="width: 100%;height: auto"></div>'+
        '<div tabindex="0" attachTo="grid" class="grid-body row"></div>'+
        '<div attachTo="footer" class="grid-footer" style="position: absolute;bottom: 0px;width: 100%"></div>'+
    '</div>';
    /**
     *
     * @class module:xgrid/Layout
     */
    var Implementation = {
        template: null,
        attachDirect: true,
        destroy: function () {
            //important,remove us from our temp. template.
            this.template && this.template.remove(this) && utils.destroy(this.template,true,this);
            this.inherited(arguments);
        },
        getTemplateNode: function () {
            return this.template.domNode;
        },
        getHeaderNode: function () {
            return this.template.header;
        },
        getBodyNode: function () {
            return this.template.grid;
        },
        getFooterNode: function () {
            return this.template.footer;
        },
        resize: function () {
            this.inherited(arguments);
            var thiz = this,
                mainNode = thiz.template  ? thiz.template.domNode : this.domNode,
                isRerooted = false;

            if(this.__masterPanel){
                mainNode = this.__masterPanel.containerNode;
                isRerooted= true;
            }
            var totalHeight = $(mainNode).height();
            var template = thiz.template;
            if(!template){
                return;
            }
            var $header =$(template.header);
            var topHeight = $header ? $header.height() : 0;
            var _toolbarHeight = this._toolbar ? this._toolbar._height : 0;
            if(_toolbarHeight>0 && topHeight===0){
                topHeight +=_toolbarHeight;
            }
            if(_toolbarHeight && $header){
                $header.css('height','auto');
            }
            var footerHeight = template.footer ? $(template.footer).height() : 0;
            var finalHeight = totalHeight - topHeight - (footerHeight);

            if (finalHeight > 50) {
                $(template.grid).height(finalHeight + 'px');
                isRerooted && $(template.domNode).width($(mainNode).width());
            } else {
                $(template.grid).height('inherited');
            }


        },
        buildRendering: function () {
            if (this.template) {
                return;
            }
            this._domNode = this.domNode;
            var templated = utils.addWidget(TemplatedWidgetBase, {
                templateString: template,
                declaredClass: 'xgrid/_BaseParent_' + this.declaredClass
            }, null, this.domNode, true);

            $(templated.domNode).attr('tabIndex', -1);

            this.template = templated;
            this.header = templated.header;
            this.footer = templated.footer;
            this.gridBody = templated.grid;
            this.domNode = templated.grid;
            this.id = this.template.id;
            this.domNode.id = this.id;
            templated.domNode.id = this.id;
            registry._hash[this.id] = this;
            templated.add(this);
            return this.inherited(arguments);
        }
    };

    //package via declare
    var _class = declare('xgrid.Layout', null, Implementation);
    _class.Implementation = Implementation;
    return _class;
});

define('xgrid/Focus',[
    "xdojo/declare",
    "xide/types",
    "xide/utils"
], function (declare,types,utils) {

    var Implementation = {
        _focused:false,
        _detectFocus:null,
        _detectBlur:null,
        destroy:function(){
            this.inherited(arguments);
            window.removeEventListener('focus', this._detectFocus, true);
            window.removeEventListener('blur', this._detectBlur, true);
        },
        _onBlur:function(){
        },
        set:function(what,value){
            if(what=='focused'){
                this._onFocusChanged(value);
              }
            return this.inherited(arguments);
        },
        _onFocusChanged:function(focused,type){
            if(this._focused && !focused){
                this._onBlur();
            }
            if(!this._focused && focused){
                this._emit(types.EVENTS.ON_VIEW_SHOW,this);
            }
            this._focused = focused;
            this.highlight  && this.highlight(focused);
        },
        getFocused:function(domNode){
            if(this._focusedNode){
                var row = this.row(this._focusedNode);
                if(row){
                    return row[domNode? 'element' : 'data' ];
                }
            }
            return null;
        },
        startup:function(){
            this.inherited(arguments);
            var thiz = this,
                node = thiz.domNode.parentNode;


            //@TODO: /active=true
            this.headerNode.tabIndex=-1;
            this._focused  = true;
        }

    };
    //package via declare
    var _class = declare('xgrid.Focus',null,Implementation);
    _class.Implementation = Implementation;
    return _class;
});
/** @module xgrid/Clipboard **/
define('xgrid/Clipboard',[
    "xdojo/declare",
    'xide/types'
], function (declare,types) {

    var Implementation = {
        runAction:function(action){
            switch (action.command){
                case types.ACTION.CLIPBOARD_COPY:{
                    this.clipboardCopy();
                    this.refreshActions();
                    return true;
                }
                case types.ACTION.CLIPBOARD_PASTE:{
                    return this.clipboardPaste();
                }
                case types.ACTION.CLIPBOARD_CUT:{
                    this.clipboardCut();
                    return true;
                }
            }
            return this.inherited(arguments);
        },
        clipboardPaste:function(){
            return this.inherited(arguments);
        },
        /**
         * Clipboard/Copy action
         */

        clipboardCopy:function(){
            this.currentCutSelection=null;
            this.currentCopySelection=this.getSelection();
            this.publish(types.EVENTS.ON_CLIPBOARD_COPY,{
                selection:this.currentCopySelection,
                owner:this,
                type:this.itemType
            });
        },
        clipboardCut:function(){
            this.currentCopySelection = null;
            this.currentCutSelection = this.getSelection();
        },
        getClipboardActions:function(addAction){
            var thiz = this,
                actions = [],
                ACTION = types.ACTION;

            function _selection(){
                var selection = thiz.getSelection();
                if (!selection || !selection.length) {
                    return null;
                }
                var item = selection[0];
                if(!item){
                    console.error('have no item');
                    return null;
                }
                return selection;
            }

            function isItem() {
                var selection = _selection();
                if (!selection) {
                    return true;
                }
                return false;
            }

            function disable(){
                switch (this.title){
                    case 'Cut':
                    case 'Copy':{
                        return isItem()!==false;
                    }
                    case 'Paste':{
                        return thiz.currentCopySelection==null;
                    }
                }
                return false;
            }
            function _createEntry(label,command,icon,keyCombo) {
                actions.push(thiz.createAction({
                    label: label,
                    command: command,
                    icon: icon,
                    tab: 'Home',
                    group: 'Clipboard',
                    keycombo: keyCombo,
                    mixin: {
                        addPermission:true,
                        quick:true
                    },
                    shouldDisable:disable
                }));
            }
            _createEntry('Copy',ACTION.CLIPBOARD_COPY,'fa-copy','ctrl c');
            _createEntry('Paste',ACTION.CLIPBOARD_PASTE,'fa-paste','ctrl v');
            _createEntry('Cut',ACTION.CLIPBOARD_CUT,'fa-cut','ctrl x');
            return actions;
        }
    };

    //package via declare
    var _class = declare('xgrid.Clipboard',null,Implementation);
    _class.Implementation = Implementation;

    return _class;
});
/** @module xide/model/Path */
define('xide/model/Path',[
    "xide/utils",
    "dcl/dcl"
], function (utils, dcl) {
    var Path = dcl(null, {
        declaredClass: "xide.model.Path",
        /**
         * @class xide.model.Path
         * @constructor
         */
        constructor: function (path, hasLeading, hasTrailing) {
            path = path || '.';  // if empty string, use '.'
            if (typeof path == 'string') {
                this.path = path;
                this.getSegments();
            } else {
                this.segments = path;
                this.hasLeading = hasLeading !== null ? hasLeading : false;
                this.hasTrailing = hasTrailing !== null ? hasLeading : false;
            }
        },

        endsWith: function (tail) {
            var segments = utils.clone(this.segments);
            var tailSegments = (new Path(tail)).getSegments();
            while (tailSegments.length > 0 && segments.length > 0) {
                if (tailSegments.pop() != segments.pop()) {
                    return false;
                }
            }
            return true;
        },
        getExtension: function () {
            if (!this.extension) {
                this.extension = this.path.substr(this.path.lastIndexOf('.') + 1);
            }
            return this.extension;
        },
        segment: function (index) {
            var segs = this.getSegments();
            if (segs.length < index) {
                return null;
            }
            return segs[index];
        },
        /**
         * Return all items under this path
         * @param items {String[]}
         * @param recursive {boolean}
         * @returns {String[]}
         */
        getChildren: function (items, recursive) {
            var result = [];
            var root = this,
                path = this.toString();

            function addChild(child) {
                var _path = typeof child !== 'string' ? child.toString() : child;
                if (_path !== path && result.indexOf(_path) == -1) {
                    result.push(_path);
                }
            }

            _.each(items, function (item) {
                var child = new Path(item);
                //root match
                if (child.startsWith(root)) {
                    if (recursive) {
                        addChild(child.toString());
                    } else {

                        var diff = child.relativeTo(path);
                        if (diff) {
                            var diffSegments = diff.getSegments();
                            //direct child
                            if (diffSegments.length == 1) {
                                addChild(child);
                            } else if (diffSegments.length > 1) {

                                //make sure that its parent has been added:
                                var parent = child.getParentPath();
                                var parentDiff = parent.relativeTo(path);

                                //check diff again
                                if (parentDiff.getSegments().length == 1) {
                                    addChild(parent.toString());
                                }
                            }
                        }
                    }

                }
            });
            return result;
        },
        getSegments: function () {
            if (!this.segments) {
                var path = this.path;
                this.segments = path.split('/');
                if (path.charAt(0) == '/') {
                    this.hasLeading = true;
                }
                if (path.charAt(path.length - 1) == '/') {
                    this.hasTrailing = true;
                    // If the path ends in '/', split() will create an array whose last element
                    // is an empty string. Remove that here.
                    this.segments.pop();
                }
                this._canonicalize();
            }
            return this.segments;
        },
        isAbsolute: function () {
            return this.hasLeading;
        },
        getParentPath: function () {
            if (!this._parentPath) {
                var parentSegments = utils.clone(this.segments);
                parentSegments.pop();
                this._parentPath = new Path(parentSegments, this.hasLeading);
            }
            return utils.clone(this._parentPath);
        },
        _clone: function () {
            return new Path(utils.clone(this.segments), this.hasLeading, this.hasTrailing);
        },
        append: function (tail) {
            tail = tail || "";
            if (typeof tail == 'string') {
                tail = new Path(tail);
            }
            if (tail.isAbsolute()) {
                return tail;
            }
            var mySegments = this.segments;
            var tailSegments = tail.getSegments();
            var newSegments = mySegments.concat(tailSegments);
            var result = new Path(newSegments, this.hasLeading, tail.hasTrailing);
            if (tailSegments[0] == ".." || tailSegments[0] == ".") {
                result._canonicalize();
            }
            return result;
        },
        toString: function () {
            var result = [];
            if (this.hasLeading) {
                result.push('/');
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (i > 0) {
                    result.push('/');
                }
                result.push(this.segments[i]);
            }
            if (this.hasTrailing) {
                result.push('/');
            }
            return result.join("");
        },
        removeRelative: function () {
            var segs = this.getSegments();
            if (segs.length > 0 && segs[1] == ".") {
                return this.removeFirstSegments(1);
            }
            return this;
        },
        relativeTo: function (base, ignoreFilename) {
            if (typeof base == 'string') {
                base = new Path(base);
            }
            var mySegments = this.segments;
            if (this.isAbsolute()) {
                return this;
            }
            var baseSegments = base.getSegments();
            var commonLength = this.matchingFirstSegments(base);
            var baseSegmentLength = baseSegments.length;
            if (ignoreFilename) {
                baseSegmentLength = baseSegmentLength - 1;
            }
            var differenceLength = baseSegmentLength - commonLength;
            var newSegmentLength = differenceLength + mySegments.length - commonLength;
            if (newSegmentLength == 0) {
                return Path.EMPTY;
            }
            var newSegments = [];
            for (var i = 0; i < differenceLength; i++) {
                newSegments.push('..');
            }
            for (var i = commonLength; i < mySegments.length; i++) {
                newSegments.push(mySegments[i]);
            }
            return new Path(newSegments, false, this.hasTrailing);
        },
        startsWith: function (anotherPath) {
            var count = this.matchingFirstSegments(anotherPath);
            return anotherPath._length() == count;
        },
        _length: function () {
            return this.segments.length;
        },
        matchingFirstSegments: function (anotherPath) {
            var mySegments = this.segments;
            var pathSegments = anotherPath.getSegments();
            var max = Math.min(mySegments.length, pathSegments.length);
            var count = 0;
            for (var i = 0; i < max; i++) {
                if (mySegments[i] != pathSegments[i]) {
                    return count;
                }
                count++;
            }
            return count;
        },
        removeFirstSegments: function (count) {
            return new Path(this.segments.slice(count, this.segments.length), this.hasLeading, this.hasTrailing);
        },
        removeMatchingLastSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this.removeLastSegments(match);
        },
        removeMatchingFirstSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this._clone().removeFirstSegments(match);
        },
        removeLastSegments: function (count) {
            if (!count) {
                count = 1;
            }
            return new Path(this.segments.slice(0, this.segments.length - count), this.hasLeading, this.hasTrailing);
        },
        lastSegment: function () {
            return this.segments[this.segments.length - 1];
        },
        firstSegment: function (length) {
            return this.segments[length || 0];
        },
        equals: function (anotherPath) {
            if (this.segments.length != anotherPath.segments.length) {
                return false;
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (anotherPath.segments[i] != this.segments[i]) {
                    return false;
                }
            }
            return true;
        },
        _canonicalize: function () {
            var doIt;
            var segments = this.segments;
            for (var i = 0; i < segments.length; i++) {
                if (segments[i] == "." || segments[i] == "..") {
                    doIt = true;
                    break;
                }
            }
            if (doIt) {
                var stack = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i] == "..") {
                        if (stack.length == 0) {
                            // if the stack is empty we are going out of our scope
                            // so we need to accumulate segments.  But only if the original
                            // path is relative.  If it is absolute then we can't go any higher than
                            // root so simply toss the .. references.
                            if (!this.hasLeading) {
                                stack.push(segments[i]); //stack push
                            }
                        } else {
                            // if the top is '..' then we are accumulating segments so don't pop
                            if (".." == stack[stack.length - 1]) {
                                stack.push("..");
                            } else {
                                stack.pop();
                            }
                        }
                        //collapse current references
                    } else if (segments[i] != "." || this.segments.length == 1) {
                        stack.push(segments[i]); //stack push
                    }
                }
                //if the number of segments hasn't changed, then no modification needed
                if (stack.length == segments.length) {
                    return;
                }
                this.segments = stack;
            }
        }

    });
    Path.EMPTY = new Path("");
    return Path;
});
define('dstore/QueryMethod',[], function () {
	/*=====
	var __QueryMethodArgs = {
		// type: String
		//		The type of the query. This identifies the query's type in the query log
		//		and the name of the corresponding query engine method.
		// normalizeArguments: Function?
		//		A function that normalizes arguments for consumption by a query engine
		// applyQuery: Function?
		//		A function that takes the query's new subcollection and the query's log entry
		//		and applies it to the new subcollection. This is useful for collections that need
		//		to both declare and implement new query methods.
		// querierFactory: Function?
		//		A factory function that provides a default querier implementation to use when
		//		a collection does not define its own querier factory method for this query type.
	};
	=====*/
	return function QueryMethod(/*__QueryMethodArgs*/ kwArgs) {
		// summary:
		//		The constructor for a dstore collection query method
		// description:
		//		This is the constructor for a collection query method. It encapsulates the following:
		//		* Creating a new subcollection for the query results
		//		* Logging the query in the collection's `queryLog`
		//		* Normalizing query arguments
		//		* Applying the query engine
		// kwArgs:
		//		The properties that define the query method
		// returns: Function
		//		Returns a function that takes query arguments and returns a new collection with
		//		the query associated with it.

		var type = kwArgs.type,
			normalizeArguments = kwArgs.normalizeArguments,
			applyQuery = kwArgs.applyQuery,
			defaultQuerierFactory = kwArgs.querierFactory;

		return function () {
			// summary:
			//		A query method whose arguments are determined by the query type
			// returns: dstore/Collection
			//		A collection representing the query results

			var originalArguments = Array.prototype.slice.call(arguments),
				normalizedArguments = normalizeArguments
					? normalizeArguments.apply(this, originalArguments)
					: originalArguments,
				logEntry = {
					type: type,
					arguments: originalArguments,
					normalizedArguments: normalizedArguments
				},
				querierFactory = this._getQuerierFactory(type) || defaultQuerierFactory;

			if (querierFactory) {
				// Call the query factory in store context to support things like
				// mapping a filter query's string argument to a custom filter method on the collection
				logEntry.querier = querierFactory.apply(this, normalizedArguments);
			}

			var newCollection = this._createSubCollection({
				queryLog: this.queryLog.concat(logEntry)
			});

			return applyQuery ? applyQuery.call(this, newCollection, logEntry) : newCollection;
		};
	};
});

define('dstore/Filter',['dojo/_base/declare'], function (declare) {
	// a Filter builder
	function filterCreator(type) {
		// constructs a new filter based on type, used to create each comparison method
		return function newFilter() {
			var Filter = this.constructor;
			var filter = new Filter();
			filter.type = type;
			// ensure args is array so we can concat, slice, unshift
			filter.args = Array.prototype.slice.call(arguments);
			if (this.type) {
				// we are chaining, so combine with an and operator
				return filterCreator('and').call(Filter.prototype, this, filter);
			}
			return filter;
		};
	}
	function logicalOperatorCreator(type) {
		// constructs a new logical operator 'filter', used to create each logical operation method
		return function newLogicalOperator() {
			var Filter = this.constructor;
			var argsArray = [];
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				argsArray.push(arg instanceof Filter ? arg : new Filter(arg));
			}
			var filter = new Filter();
			filter.type = type;
			filter.args = argsArray;
			if (this.type === type) {
				// chaining, same type
				// combine arguments
				filter.args = this.args.concat(argsArray);
			} else if (this.type) {
				// chaining, different type
				// add this filter to start of arguments
				argsArray.unshift(this);
			} else if (argsArray.length === 1) {
				// not chaining and only one argument
				// returned filter is the same as the single argument
				filter.type = argsArray[0].type;
				filter.args = argsArray[0].args.slice();
			}
			return filter;
		};
	}
	var Filter = declare(null, {
		constructor: function (filterArg) {
			var argType = typeof filterArg;
			switch (argType) {
				case 'object':
					var filter = this;
					// construct a filter based on the query object
					for (var key in filterArg){
						var value = filterArg[key];
						if (value instanceof this.constructor) {
							// fully construct the filter from the single arg
							filter = filter[value.type](key, value.args[0]);
						} else if (value && value.test) {
							// support regex
							filter = filter.match(key, value);
						} else {
							filter = filter.eq(key, value);
						}
					}
					this.type = filter.type;
					this.args = filter.args;
					break;
				case 'function': case 'string':
					// allow string and function args as well
					this.type = argType;
					this.args = [filterArg];
			}
		},
		// define our operators
		and: logicalOperatorCreator('and'),
		or: logicalOperatorCreator('or'),
		eq: filterCreator('eq'),
		ne: filterCreator('ne'),
		lt: filterCreator('lt'),
		lte: filterCreator('lte'),
		gt: filterCreator('gt'),
		gte: filterCreator('gte'),
		contains: filterCreator('contains'),
		'in': filterCreator('in'),
		match: filterCreator('match')
	});
	Filter.filterCreator = filterCreator;
	Filter.logicalOperatorCreator = logicalOperatorCreator;
	return Filter;
});
/** @module dstore/Store **/
define('dstore/Store',[
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/has',
	'dojo/when',
    'dojo/_base/declare',
	'dstore/QueryMethod',
	'dstore/Filter',
	'dojo/Evented'
], function (lang, arrayUtil, aspect, has, when, declare, QueryMethod, Filter, Evented) {

	// module:
	//		dstore/Store
	/* jshint proto: true */
	// detect __proto__, and avoid using it on Firefox, as they warn about
	// deoptimizations. The watch method is a clear indicator of the Firefox
	// JS engine.
	has.add('object-proto', !!{}.__proto__ && !({}).watch);
	var hasProto = has('object-proto');

	function emitUpdateEvent(type) {
		return function (result, args) {
			var self = this;
			when(result, function (result) {
				var event = { target: result },
					options = args[1] || {};
				if ('beforeId' in options) {
					event.beforeId = options.beforeId;
				}
				self.emit(type, event);
			});

			return result;
		};
	}

	/**
     * Base store class
     * @class module:dstore/Store
     * @extends module:dojo/Evented
     */
	return declare(Evented, {
		constructor: function (options) {
			// perform the mixin
			options && declare.safeMixin(this, options);
            if (this.Model && this.Model.createSubclass) {

				// we need a distinct model for each store, so we can
				// save the reference back to this store on it.
				// we always create a new model to be safe.
                var self = this;
                this.Model = this.Model.createSubclass([],{

                }).extend({
					// give a reference back to the store for saving, etc.
                    _store:this
				});
			}

			// the object the store can use for holding any local data or events
			this.storage = new Evented();
			var store = this;
			if (this.autoEmitEvents) {
				// emit events when modification operations are called
				aspect.after(this, 'add', emitUpdateEvent('add'));
				aspect.after(this, 'put', emitUpdateEvent('update'));
				aspect.after(this, 'remove', function (result, args) {
					when(result, function () {
						store.emit('delete', {id: args[0]});
					});
					return result;
				});
			}
		},

		// autoEmitEvents: Boolean
		//		Indicates if the events should automatically be fired for put, add, remove
		//		method calls. Stores may wish to explicitly fire events, to control when
		//		and which event is fired.
		autoEmitEvents: true,

		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: 'id',

		// queryAccessors: Boolean
		//		Indicates if client-side query engine filtering should (if the store property is true)
		//		access object properties through the get() function (enabling querying by
		//		computed properties), or if it should (by setting this to false) use direct/raw
		// 		property access (which may more closely follow database querying style).
		queryAccessors: true,

		getIdentity: function (object) {
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: String|Number

			return object.get ? object.get(this.idProperty) : object[this.idProperty];
		},

		_setIdentity: function (object, identityArg) {
			// summary:
			//		Sets an object's identity
			// description:
			//		This method sets an object's identity and is useful to override to support
			//		multi-key identities and object's whose properties are not stored directly on the object.
			// object: Object
			//		The target object
			// identityArg:
			//		The argument used to set the identity

			if (object.set) {
				object.set(this.idProperty, identityArg);
			} else {
				object[this.idProperty] = identityArg;
			}
		},

		forEach: function (callback, thisObject) {
			var collection = this;
			return when(this.fetch(), function (data) {
				for (var i = 0, item; (item = data[i]) !== undefined; i++) {
					callback.call(thisObject, item, i, collection);
				}
				return data;
			});
		},
		on: function (type, listener) {
			return this.storage.on(type, listener);
		},
		emit: function (type, event) {
			event = event || {};
			event.type = type;
			try {
				return this.storage.emit(type, event);
			} finally {
				// Return the initial value of event.cancelable because a listener error makes it impossible
				// to know whether the event was actually canceled
				return event.cancelable;
			}
		},

		// parse: Function
		//		One can provide a parsing function that will permit the parsing of the data. By
		//		default we assume the provide data is a simple JavaScript array that requires
		//		no parsing (subclass stores may provide their own default parse function)
		parse: null,

		// stringify: Function
		//		For stores that serialize data (to send to a server, for example) the stringify
		//		function can be specified to control how objects are serialized to strings
		stringify: null,

		// Model: Function
		//		This should be a entity (like a class/constructor) with a 'prototype' property that will be
		//		used as the prototype for all objects returned from this store. One can set
		//		this to the Model from dmodel/Model to return Model objects, or leave this
		//		to null if you don't want any methods to decorate the returned
		//		objects (this can improve performance by avoiding prototype setting),
		Model: null,

		_restore: function (object, mutateAllowed) {
			// summary:
			//		Restores a plain raw object, making an instance of the store's model.
			//		This is called when an object had been persisted into the underlying
			//		medium, and is now being restored. Typically restored objects will come
			//		through a phase of deserialization (through JSON.parse, DB retrieval, etc.)
			//		in which their __proto__ will be set to Object.prototype. To provide
			//		data model support, the returned object needs to be an instance of the model.
			//		This can be accomplished by setting __proto__ to the model's prototype
			//		or by creating a new instance of the model, and copying the properties to it.
			//		Also, model's can provide their own restore method that will allow for
			//		custom model-defined behavior. However, one should be aware that copying
			//		properties is a slower operation than prototype assignment.
			//		The restore process is designed to be distinct from the create process
			//		so their is a clear delineation between new objects and restored objects.
			// object: Object
			//		The raw object with the properties that need to be defined on the new
			//		model instance
			// mutateAllowed: boolean
			//		This indicates if restore is allowed to mutate the original object
			//		(by setting its __proto__). If this isn't true, than the restore should
			//		copy the object to a new object with the correct type.
			// returns: Object
			//		An instance of the store model, with all the properties that were defined
			//		on object. This may or may not be the same object that was passed in.
			var Model = this.Model;
			if (Model && object) {
				var prototype = Model.prototype;
				var restore = prototype._restore;
				if (restore) {
					// the prototype provides its own restore method
					object = restore.call(object, Model, mutateAllowed);
				} else if (hasProto && mutateAllowed) {
					// the fast easy way
					// http://jsperf.com/setting-the-prototype
					object.__proto__ = prototype;
				} else {
					// create a new object with the correct prototype
					object = lang.delegate(prototype, object);
				}
			}
			return object;
		},

		create: function (properties) {
			// summary:
			//		This creates a new instance from the store's model.
			//	properties:
			//		The properties that are passed to the model constructor to
			//		be copied onto the new instance. Note, that should only be called
			//		when new objects are being created, not when existing objects
			//		are being restored from storage.
			return new this.Model(properties);
		},

		_createSubCollection: function (kwArgs) {
			var newCollection = lang.delegate(this.constructor.prototype);

			for (var i in this) {
				if (this._includePropertyInSubCollection(i, newCollection)) {
					newCollection[i] = this[i];
				}
			}

			return declare.safeMixin(newCollection, kwArgs);
		},

		_includePropertyInSubCollection: function (name, subCollection) {
			return !(name in subCollection) || subCollection[name] !== this[name];
		},

		// queryLog: __QueryLogEntry[]
		//		The query operations represented by this collection
		queryLog: [],	// NOTE: It's ok to define this on the prototype because the array instance is never modified

		filter: new QueryMethod({
			type: 'filter',
			normalizeArguments: function (filter) {
				var Filter = this.Filter;
				if (filter instanceof Filter) {
					return [filter];
				}
				return [new Filter(filter)];
			}
		}),

		Filter: Filter,

		sort: new QueryMethod({
			type: 'sort',
			normalizeArguments: function (property, descending) {
				var sorted;
				if (typeof property === 'function') {
					sorted = [ property ];
				} else {
					if (property instanceof Array) {
						sorted = property.slice();
					} else if (typeof property === 'object') {
						sorted = [].slice.call(arguments);
					} else {
						sorted = [{ property: property, descending: descending }];
					}

					sorted = arrayUtil.map(sorted, function (sort) {
						// copy the sort object to avoid mutating the original arguments
						sort = lang.mixin({}, sort);
						sort.descending = !!sort.descending;
						return sort;
					});
					// wrap in array because sort objects are a single array argument
					sorted = [ sorted ];
				}
				return sorted;
			}
		}),

		select: new QueryMethod({
			type: 'select'
		}),

		_getQuerierFactory: function (type) {
			var uppercaseType = type[0].toUpperCase() + type.substr(1);
			return this['_create' + uppercaseType + 'Querier'];
		}

/*====,
		get: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
		},
		put: function (object, directives) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for storing objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		add: function (object, directives) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for creating objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		remove: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
		},
		transaction: function () {
			// summary:
			//		Starts a new transaction.
			//		Note that a store user might not call transaction() prior to using put,
			//		delete, etc. in which case these operations effectively could be thought of
			//		as "auto-commit" style actions.
			// returns: dstore/Store.Transaction
			//		This represents the new current transaction.
		},
		getChildren: function (parent) {
			// summary:
			//		Retrieves the children of an object.
			// parent: Object
			//		The object to find the children of.
			// returns: dstore/Store.Collection
			//		A result set of the children of the parent object.
		}
====*/
	});
});


/*====
	var Collection = declare(null, {
		// summary:
		//		This is an abstract API for a collection of objects, which can be filtered,
		//		sorted, and sliced to create new collections. This is considered to be base
		//		interface for all stores and  query results in dstore. Note that the objects in the
		//		collection may not be immediately retrieved from the underlying data
		//		storage until they are actually accessed through forEach() or fetch().

		filter: function (query) {
			// summary:
			//		Filters the collection, returning a new subset collection
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// returns: Collection
		},
		sort: function (property, descending) {
			// summary:
			//		Sorts the current collection into a new collection, reordering the objects by the provided sort order.
			// property: String|Function
			//		The property to sort on. Alternately a function can be provided to sort with
			// descending?: Boolean
			//		Indicate if the sort order should be descending (defaults to ascending)
			// returns: Collection
		},
		fetchRange: function (kwArgs) {
			// summary:
			//		Retrieves a range of objects from the collection, returning a promise to an array.
			// kwArgs.start: Number
			//		The starting index of objects to return (0-indexed)
			// kwArgs.end: Number
			//		The exclusive end of objects to return
			// returns: Collection
		},
		forEach: function (callback, thisObject) {
			// summary:
			//		Iterates over the query results, based on
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach.
			//		Note that this may executed asynchronously (in which case it will return a promise),
			//		and the callback may be called after this function returns.
			// callback:
			//		Function that is called for each object in the query results
			// thisObject:
			//		The object to use as |this| in the callback.
			// returns:
			//		undefined|Promise
		},
		fetch: function () {
			// summary:
			//		This can be called to materialize and request the data behind this collection.
			//		Often collections may be lazy, and won't retrieve their underlying data until
			//		forEach or fetch is called. This returns an array, or for asynchronous stores,
			//		this will return a promise, resolving to an array of objects, once the
			//		operation is complete.
			//	returns Array|Promise
		},
		on: function (type, listener) {
			// summary:
			//		This registers a callback for notification of when data is modified in the query results.
			// type: String
			//		There are four types of events defined in this API:
			//		- add - A new object was added
			//		- update - An object was updated
			//		- delete - An object was deleted
			// listener: Function
			//		The listener function is called when objects in the query results are modified
			//		to affect the query result. The listener function is called with a single event object argument:
			//		| listener(event);
			//
			//		- The event object as the following properties:
			//		- type - The event type (of the four above)
			//		- target - This indicates the object that was create or modified.
			//		- id - If an object was removed, this indicates the object that was removed.
			//		The next two properties will only be available if array tracking is employed,
			//		which is usually provided by dstore/Trackable
			//		- previousIndex - The previousIndex parameter indicates the index in the result array where
			//		the object used to be. If the value is -1, then the object is an addition to
			//		this result set (due to a new object being created, or changed such that it
			//		is a part of the result set).
			//		- index - The inex parameter indicates the index in the result array where
			//		the object should be now. If the value is -1, then the object is a removal
			//		from this result set (due to an object being deleted, or changed such that it
			//		is not a part of the result set).

		}
	});

	Collection.SortInformation = declare(null, {
		// summary:
		//		An object describing what property to sort on, and the direction of the sort.
		// property: String
		//		The name of the property to sort on.
		// descending: Boolean
		//		The direction of the sort.  Default is false.
	});
	Store.Collection = Collection;

	Store.PutDirectives = declare(null, {
		// summary:
		//		Directives passed to put() and add() handlers for guiding the update and
		//		creation of stored objects.
		// id: String|Number?
		//		Indicates the identity of the object if a new object is created
		// beforeId: String?
		//		If the collection of objects in the store has a natural ordering,
		//		this indicates that the created or updated object should be placed before the
		//		object whose identity is specified as the value of this property. A value of null indicates that the
		//		object should be last.
		// parent: Object?,
		//		If the store is hierarchical (with single parenting) this property indicates the
		//		new parent of the created or updated object.
		// overwrite: Boolean?
		//		If this is provided as a boolean it indicates that the object should or should not
		//		overwrite an existing object. A value of true indicates that a new object
		//		should not be created, the operation should update an existing object. A
		//		value of false indicates that an existing object should not be updated, a new
		//		object should be created (which is the same as an add() operation). When
		//		this property is not provided, either an update or creation is acceptable.
	});

	Store.Transaction = declare(null, {
		// summary:
		//		This is an object returned from transaction() calls that represents the current
		//		transaction.

		commit: function () {
			// summary:
			//		Commits the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the commit.
		},
		abort: function (callback, thisObject) {
			// summary:
			//		Aborts the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the abort.
		}
	});

	var __QueryLogEntry = {
		type: String
			The query type
		arguments: Array
			The original query arguments
		normalizedArguments: Array
			The normalized query arguments
		querier: Function?
			A client-side implementation of the query that takes an item array and returns an item array
	};
====*/
;
define('dstore/QueryResults',['dojo/_base/lang', 'dojo/when'], function (lang, when) {
	function forEach(callback, instance) {
		return when(this, function(data) {
			for (var i = 0, l = data.length; i < l; i++){
				callback.call(instance, data[i], i, data);
			}
		});
	}
	return function (data, options) {
		var hasTotalLength = options && 'totalLength' in options;
		if(data.then) {
			data = lang.delegate(data);
			// a promise for the eventual realization of the totalLength, in
			// case it comes from the resolved data
			var totalLengthPromise = data.then(function (data) {
				// calculate total length, now that we have access to the resolved data
				var totalLength = hasTotalLength ? options.totalLength :
						data.totalLength || data.length;
				// make it available on the resolved data
				data.totalLength = totalLength;
				// don't return the totalLength promise unless we need to, to avoid
				// triggering a lazy promise
				return !hasTotalLength && totalLength;
			});
			// make the totalLength available on the promise (whether through the options or the enventual
			// access to the resolved data)
			data.totalLength = hasTotalLength ? options.totalLength : totalLengthPromise;
			// make the response available as well
			data.response = options && options.response;
		} else {
			data.totalLength = hasTotalLength ? options.totalLength : data.length;
		}

		data.forEach = forEach;

		return data;
	};
});

define('dstore/Promised',[
	'dojo/_base/declare',
	'dojo/Deferred',
	'./QueryResults',
	'dojo/when'
], function (declare, Deferred, QueryResults, when) {
	// module:
	//		this is a mixin that can be used to provide async methods,
	// 		by implementing their sync counterparts
	function promised(method, query) {
		return function() {
			var deferred = new Deferred();
			try {
				deferred.resolve(this[method].apply(this, arguments));
			} catch (error) {
				deferred.reject(error);
			}
			if (query) {
				// need to create a QueryResults and ensure the totalLength is
				// a promise.
				var queryResults = new QueryResults(deferred.promise);
				queryResults.totalLength = when(queryResults.totalLength);
				return queryResults;
			}
			return deferred.promise;
		};
	}
	return declare(null, {
		get: promised('getSync'),
		put: promised('putSync'),
		add: promised('addSync'),
		remove: promised('removeSync'),
		fetch: promised('fetchSync', true),
		fetchRange: promised('fetchRangeSync', true)
	});
});

define('dstore/SimpleQuery',[
	'dojo/_base/declare',
	'dojo/_base/array'
], function (declare, arrayUtil) {

	// module:
	//		dstore/SimpleQuery

	function makeGetter(property, queryAccessors) {
		if (property.indexOf('.') > -1) {
			var propertyPath = property.split('.');
			var pathLength = propertyPath.length;
			return function (object) {
				for (var i = 0; i < pathLength; i++) {
					object = object && (queryAccessors && object.get ? object.get(propertyPath[i]) : object[propertyPath[i]]);
				}
				return object;
			};
		}
		// else
		return function (object) {
			return object.get ? object.get(property) : object[property];
		};
	}

	var comparators = {
		eq: function (value, required) {
			return value === required;
		},
		'in': function(value, required) {
			// allow for a collection of data
			return arrayUtil.indexOf(required.data || required, value) > -1;
		},
		ne: function (value, required) {
			return value !== required;
		},
		lt: function (value, required) {
			return value < required;
		},
		lte: function (value, required) {
			return value <= required;
		},
		gt: function (value, required) {
			return value > required;
		},
		gte: function (value, required) {
			return value >= required;
		},
		match: function (value, required, object) {
			return required.test(value, object);
		},
		contains: function (value, required, object, key) {
			var collection = this;
			return arrayUtil.every(required.data || required, function (requiredValue) {
				if (typeof requiredValue === 'object' && requiredValue.type) {
					var comparator = collection._getFilterComparator(requiredValue.type);
					return arrayUtil.some(value, function (item) {
						return comparator.call(collection, item, requiredValue.args[1], object, key);
					});
				}
				return arrayUtil.indexOf(value, requiredValue) > -1;
			});
		}
	};

	return declare(null, {
		// summary:
		//		Mixin providing querier factories for core query types

		_createFilterQuerier: function (filter) {
			// create our matching filter function
			var queryAccessors = this.queryAccessors;
			var collection = this;
			var querier = getQuerier(filter);

			function getQuerier(filter) {
				var type = filter.type;
				var args = filter.args;
				var comparator = collection._getFilterComparator(type);
				if (comparator) {
					// it is a comparator
					var firstArg = args[0];
					var getProperty = makeGetter(firstArg, queryAccessors);
					var secondArg = args[1];
					if (secondArg && secondArg.fetchSync) {
						// if it is a collection, fetch the contents (for `in` and `contains` operators)
						secondArg = secondArg.fetchSync();
					}
					return function (object) {
						// get the value for the property and compare to expected value
						return comparator.call(collection, getProperty(object), secondArg, object, firstArg);
					};
				}
				switch (type) {
					case 'and': case 'or':
						for (var i = 0, l = args.length; i < l; i++) {
							// combine filters, using and or or
							var nextQuerier = getQuerier(args[i]);
							if (querier) {
								// combine the last querier with a new one
								querier = (function(a, b) {
									return type === 'and' ?
										function(object) {
											return a(object) && b(object);
										} :
										function(object) {
											return a(object) || b(object);

										};
								})(querier, nextQuerier);
							} else {
								querier = nextQuerier;
							}
						}
						return querier;
					case 'function':
						return args[0];
					case 'string':
						// named filter
						var filterFunction = collection[args[0]];
						if (!filterFunction) {
							throw new Error('No filter function ' + args[0] + ' was found in the collection');
						}
						return filterFunction;
					case undefined:
						return function () {
							return true;
						};
					default:
						throw new Error('Unknown filter operation "' + type + '"');
				}
			}
			return function (data) {
				return arrayUtil.filter(data, querier);
			};
		},

		_getFilterComparator: function (type) {
			// summary:
			//		Get the comparator for the specified type
			// returns: Function?

			return comparators[type] || this.inherited(arguments);
		},

		_createSelectQuerier: function (properties) {
			return function (data) {
				var l = properties.length;
				return arrayUtil.map(data, properties instanceof Array ?
					// array of properties
					function (object) {
						var selectedObject = {};
						for (var i = 0; i < l; i++) {
							var property = properties[i];
							selectedObject[property] = object[property];
						}
						return selectedObject;
					} :
					// single property
					function (object) {
						return object[properties];
					});
			};
		},

		_createSortQuerier: function (sorted) {
			var queryAccessors = this.queryAccessors;
			return function (data) {
				data = data.slice();
				data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
					for (var i = 0; i < sorted.length; i++) {
						var comparison;
						var sorter = sorted[i];
						if (typeof sorter == 'function') {
							comparison = sorter(a, b);
						} else {
							var getProperty = sorter.get || (sorter.get = makeGetter(sorter.property, queryAccessors));
							var descending = sorter.descending;
							var aValue = getProperty(a);
							var bValue = getProperty(b);

							aValue != null && (aValue = aValue.valueOf());
							bValue != null && (bValue = bValue.valueOf());

							comparison = aValue === bValue
								? 0
								: (!!descending === (aValue === null || aValue > bValue && bValue !== null) ? -1 : 1);
						}

						if (comparison !== 0) {
							return comparison;
						}
					}
					return 0;
				});
				return data;
			};
		}
	});
});

/** @module dstore/Memory **/
define('dstore/Memory',[
	'dojo/_base/declare',
	'dojo/_base/array',
	'./Store',
	'./Promised',
	'./SimpleQuery',
	'./QueryResults'
], function (declare, arrayUtil, Store, Promised, SimpleQuery, QueryResults) {
    /**
     * @class module:dstore/Memory
     */
	return declare([Store, Promised, SimpleQuery ], {
		constructor: function () {
			// summary:
			//		Creates a memory object store.
			// options: dstore/Memory
			//		This provides any configuration information that will be mixed into the store.
			//		This should generally include the data property to provide the starting set of data.

			// Add a version property so subcollections can detect when they're using stale data
			this.storage.version = 0;
		},

		postscript: function () {
			this.inherited(arguments);

			// Set the data in `postscript` so subclasses can override `data` in their constructors
			// (e.g., a LocalStorage store that retrieves its data from localStorage)
			this.setData(this.data || []);
		},

		// data: Array
		//		The array of all the objects in the memory store
		data: null,

		autoEmitEvents: false, // this is handled by the methods themselves

		getSync: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
			return this.storage.fullData[this.storage.index[id]];
		},
		putSync: function (object, options) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number

			options = options || {};

			var storage = this.storage,
				index = storage.index,
				data = storage.fullData;

			var Model = this.Model;
			if (Model && !(object instanceof Model)) {
				// if it is not the correct type, restore a
				// properly typed version of the object. Note that we do not allow
				// mutation here
				object = this._restore(object);
			}
			var id = this.getIdentity(object);
			if (id == null) {
				this._setIdentity(object, ('id' in options) ? options.id : Math.random());
				id = this.getIdentity(object);
			}
			storage.version++;

			var eventType = id in index ? 'update' : 'add',
				event = { target: object },
				previousIndex,
				defaultDestination;
			if (eventType === 'update') {
				if (options.overwrite === false) {
					throw new Error('Object already exists');
				} else {
					data.splice(previousIndex = index[id], 1);
					defaultDestination = previousIndex;
				}
			} else {
				defaultDestination = this.defaultNewToStart ? 0 : data.length;
			}

			var destination;
			if ('beforeId' in options) {
				var beforeId = options.beforeId;

				if (beforeId === null) {
					destination = data.length;
				} else {
					destination = index[beforeId];

					// Account for the removed item
					if (previousIndex < destination) {
						--destination;
					}
				}

				if (destination !== undefined) {
					event.beforeId = beforeId;
				} else {
					console.error('options.beforeId was specified but no corresponding index was found');
					destination = defaultDestination;
				}
			} else {
				destination = defaultDestination;
			}
			data.splice(destination, 0, object);

			// the fullData has been changed, so the index needs updated
			var i = isFinite(previousIndex) ? Math.min(previousIndex, destination) : destination;
			for (var l = data.length; i < l; ++i) {
				index[this.getIdentity(data[i])] = i;
			}

			this.emit(eventType, event);

			return object;
		},
		addSync: function (object, options) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number
			(options = options || {}).overwrite = false;
			// call put with overwrite being false
			return this.putSync(object, options);
		},
		removeSync: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
			// returns: Boolean
			//		Returns true if an object was removed, falsy (undefined) if no object matched the id
			var storage = this.storage;
			var index = storage.index;
			var data = storage.fullData;
			if (id in index) {
				var removed = data.splice(index[id], 1)[0];
				// now we have to reindex
				this._reindex();
				this._ignoreChangeEvents !==true && this.emit('delete', {id: id, target: removed});
				return true;
			}
		},
		setData: function (data) {
			// summary:
			//		Sets the given data as the source for this store, and indexes it
			// data: Object[]
			//		An array of objects to use as the source of data. Note that this
			//		array will not be copied, it is used directly and mutated as
			//		data changes.

			if (this.parse) {
				data = this.parse(data);
			}
			if (data.items) {
				// just for convenience with the data format ItemFileReadStore expects
				this.idProperty = data.identifier || this.idProperty;
				data = data.items;
			}
			var storage = this.storage;
			storage.fullData = this.data = data;
			this._reindex();
		},

		_reindex: function () {
			var storage = this.storage;
			var index = storage.index = {};
			var data = storage.fullData;
			var Model = this.Model;
			var ObjectPrototype = Object.prototype;
			for (var i = 0, l = data.length; i < l; i++) {
				var object = data[i];
				if (Model && !(object instanceof Model)) {
					var restoredObject = this._restore(object,
							// only allow mutation if it is a plain object
							// (which is generally the expected input),
							// if "typed" objects are actually passed in, we will
							// respect that, and leave the original alone
							object.__proto__ === ObjectPrototype);
					if (object !== restoredObject) {
						// a new object was generated in the restoration process,
						// so we have to update the item in the data array.
						data[i] = object = restoredObject;
					}
				}
				index[this.getIdentity(object)] = i;
			}
			storage.version++;
		},

		fetchSync: function () {
			var data = this.data;
			if (!data || data._version !== this.storage.version) {
				// our data is absent or out-of-date, so we requery from the root
				// start with the root data
				data = this.storage.fullData;
				var queryLog = this.queryLog;
				// iterate through the query log, applying each querier
				for (var i = 0, l = queryLog.length; i < l; i++) {
					data = queryLog[i].querier(data);
				}
				// store it, with the storage version stamp
				data._version = this.storage.version;
				this.data = data;
			}
			return new QueryResults(data);
		},

		fetchRangeSync: function (kwArgs) {
			var data = this.fetchSync(),
				start = kwArgs.start,
				end = kwArgs.end;
			return new QueryResults(data.slice(start, end), {
				totalLength: data.length
			});
		},

		_includePropertyInSubCollection: function (name) {
			return name !== 'data' && this.inherited(arguments);
		}
	});
});

define('xide/encoding/_base',[
	"dojo/_base/lang"

], function(lang){

	//	These functions are 32-bit word-based.  See _sha-64 for 64-bit word ops.
	var base = {};//lang.getObject("dojox.encoding.digests", true);

	base.outputTypes={
		// summary:
		//		Enumeration for input and output encodings.
		Base64:0, Hex:1, String:2, Raw:3
	};

	//	word-based addition
	base.addWords=function(/* word */a, /* word */b){
		// summary:
		//		add a pair of words together with rollover
		var l=(a&0xFFFF)+(b&0xFFFF);
		var m=(a>>16)+(b>>16)+(l>>16);
		return (m<<16)|(l&0xFFFF);	//	word
	};

	//	word-based conversion method, for efficiency sake;
	//	most digests operate on words, and this should be faster
	//	than the encoding version (which works on bytes).
	var chrsz=8;	//	16 for Unicode
	var mask=(1<<chrsz)-1;

	base.stringToWord=function(/* string */s){
		// summary:
		//		convert a string to a word array
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
		}
		return wa;	//	word[]
	};

	base.wordToString=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a string
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		}
		return s.join("");	//	string
	};

	base.wordToHex=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a hex tab
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");	//	string
	};

	base.wordToBase64=function(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	convert to UTF-8
	base.stringToUtf8 = function(input){
		var output = "";
		var i = -1;
		var x, y;

		while(++i < input.length){
			x = input.charCodeAt(i);
			y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
			if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF){
				x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
				i++;
			}

			if(x <= 0x7F)
				output += String.fromCharCode(x);
			else if(x <= 0x7FF)
				output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F), 0x80 | (x & 0x3F));
			else if(x <= 0xFFFF)
				output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
			else if(x <= 0x1FFFFF)
				output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07), 0x80 | ((x >>> 12) & 0x3F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
		}
		return output;
	};

	return base;
});

define('xide/encoding/MD5',["./_base"], function(base) {

/*	A port of Paul Johnstone's MD5 implementation
 *	http://pajhome.org.uk/crypt/md5/index.html
 *
 *	Copyright (C) Paul Johnston 1999 - 2002.
 *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * 	Distributed under the BSD License
 *
 *	Dojo port by Tom Trenka
 */

	var chrsz=8;

	//	MD5 rounds functions
	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function C(q,a,b,x,s,t){ return base.addWords(R(base.addWords(base.addWords(a, q), base.addWords(x, t)), s), b); }
	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }

	//	the core MD5 rounds method
	function core(x,len){
		x[len>>5]|=0x80<<((len)%32);
		x[(((len+64)>>>9)<<4)+14]=len;
		var a= 1732584193;
		var b=-271733879;
		var c=-1732584194;
		var d= 271733878;
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;

			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
			c=FF(c,d,a,b,x[i+10],17,-42063);
			b=FF(b,c,d,a,x[i+11],22,-1990404162);
			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
			d=FF(d,a,b,c,x[i+13],12,-40341101);
			c=FF(c,d,a,b,x[i+14],17,-1502002290);
			b=FF(b,c,d,a,x[i+15],22, 1236535329);

			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
			c=GG(c,d,a,b,x[i+11],14, 643717713);
			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
			d=GG(d,a,b,c,x[i+10],9 , 38016083);
			c=GG(c,d,a,b,x[i+15],14,-660478335);
			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
			b=GG(b,c,d,a,x[i+12],20,-1926607734);

			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
			c=HH(c,d,a,b,x[i+11],16, 1839030562);
			b=HH(b,c,d,a,x[i+14],23,-35309556);
			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
			b=HH(b,c,d,a,x[i+10],23,-1094730640);
			a=HH(a,b,c,d,x[i+13],4 , 681279174);
			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
			d=HH(d,a,b,c,x[i+12],11,-421815835);
			c=HH(c,d,a,b,x[i+15],16, 530742520);
			b=HH(b,c,d,a,x[i+ 2],23,-995338651);

			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
			c=II(c,d,a,b,x[i+14],15,-1416354905);
			b=II(b,c,d,a,x[i+ 5],21,-57434055);
			a=II(a,b,c,d,x[i+12],6 , 1700485571);
			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
			c=II(c,d,a,b,x[i+10],15,-1051523);
			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
			d=II(d,a,b,c,x[i+15],10,-30611744);
			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
			b=II(b,c,d,a,x[i+13],21, 1309151649);
			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
			d=II(d,a,b,c,x[i+11],10,-1120210379);
			c=II(c,d,a,b,x[i+ 2],15, 718787259);
			b=II(b,c,d,a,x[i+ 9],21,-343485551);

			a=base.addWords(a, olda);
			b=base.addWords(b, oldb);
			c=base.addWords(c, oldc);
			d=base.addWords(d, oldd);
		}
		return [a,b,c,d];
	}

	function hmac(data, key){
		var wa=base.stringToWord(key);
		if(wa.length>16){
			wa=core(wa, key.length*chrsz);
		}
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(base.stringToWord(data)), 512+data.length*chrsz);
		return core(r.concat(h), 640);
	}

	//	public function
	base.MD5=function(/* string */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=core(base.stringToWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.MD5._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	return base.MD5;
});

define('xide/data/_Base',[
    "dojo/_base/declare",
    'dstore/QueryResults',
    'xide/mixins/EventedMixin',
    'xide/encoding/MD5',
    'xdojo/has',
    'xide/lodash',
    'dojo/when',
    'dojo/Deferred'
], function (declare, QueryResults, EventedMixin, MD5, has, lodash, when, Deferred) {
    /**
     * Mixin in XIDE basics to dstore classes.
     * @class module:xide/data/_Base
     * @extends module:xide/mixins/EventedMixin
     * @lends module:dstore/Memory
     */
    return declare("xide/data/_Base",EventedMixin, {
        __all:null,
        allowCache:true,
        _find:function (query) {
            var result = lodash.filter(this.data,query);
            if(lodash.isArray(result)){
                return result;
            }else if(lodash.isObject(result)){
                return [result];
            }
            return [];
        },
        notify:function(){

        },
        _query:function(query){
            var dfd = new Deferred();
            var collection = this.filter(query);
            when(collection.fetch(), function (data) {
                dfd.resolve(data);
            });
            return dfd;
        },
        constructor: function () {
            var store = this;
            if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {

                this.queryEngine = function (query, options) {
                    options = options || {};

                    var filterQuerierFactory = store._getQuerierFactory('filter');
                    var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

                    var sortQuerierFactory = store._getQuerierFactory('sort');
                    var sort = passthrough;
                    if (sortQuerierFactory) {
                        sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
                            return {
                                property: criteria.attribute,
                                descending: criteria.descending
                            };
                        }));
                    }

                    var range = passthrough;
                    if (!isNaN(options.start) || !isNaN(options.count)) {
                        range = function (data) {
                            var start = options.start || 0,
                                count = options.count || Infinity;

                            var results = data.slice(start, start + count);
                            results.total = data.length;
                            return results;
                        };
                    }

                    return function (data) {
                        return range(sort(filter(data)));
                    };
                };
            }
            var objectStore = this;
            // we call notify on events to mimic the old dojo/store/Trackable
            store.on('add,update,delete', function (event) {
                var type = event.type;
                var target = event.target;
                objectStore.notify(
                    (type === 'add' || type === 'update') ? target : undefined,
                    (type === 'delete' || type === 'update') ?
                        ('id' in event ? event.id : store.getIdentity(target)) : undefined);
            });
        },
        /**
         * Override destroy to also call destroy an item's individual destroy function. Needed for temporary stores.
         * Then, delete query cache.
         * @returns {*}
         */
        destroy:function(){
            this._emit('destroy',this);
            _.each(this.query(), function (item) {
                if (item.destroyOnRemove === true) {
                    item.destroy && item.destroy();
                }
            });
            delete this._queryCache;
            this._queryCache=null;
        },
        refreshItem:function(item,property){
            this.emit('update',{
                target: item,
                property:property
            });
        },
        query: function (query, options,allowCache) {
            //no query, return all
            if(lodash.isEmpty(query)){
                var self = this;
                return _.map(this.data,function(item){
                    return self.getSync(item[self.idProperty]);
                },this);
            }else if(!_.some(query,function (value) { return value == null})){
                //no empty props in query, return lodash.filter
                //return this._find(query);
            }


            var hash = query ? MD5(JSON.stringify(query),1) : null;
            if(has('xcf-ui')) {
                if (hash && !has('host-node') && allowCache !== false) {
                    !this._queryCache && (this._queryCache = {});
                    if (this._queryCache[hash]) {
                        return this._queryCache[hash];
                    }
                }
            }
            /*
            if(!query && !options && allowCache!==false && this.allowCache){
                return this.data;
            }*/

            // summary:
            //		Queries the store for objects. This does not alter the store, but returns a
            //		set of data from the store.
            // query: String|Object|Function
            //		The query to use for retrieving objects from the store.
            // options: dstore/api/Store.QueryOptions
            //		The optional arguments to apply to the resultset.
            // returns: dstore/api/Store.QueryResults
            //		The results of the query, extended with iterative methods.
            //
            // example:
            //		Given the following store:
            //
            //	...find all items where "prime" is true:
            //
            //	|	store.query({ prime: true }).forEach(function(object){
            //	|		// handle each object
            //	|	});
            options = options || {};
            query = query || {};

            var results = this.filter(query);
            var queryResults;

            // Apply sorting
            var sort = options.sort;
            if (sort) {
                if (Object.prototype.toString.call(sort) === '[object Array]') {
                    var sortOptions;
                    while ((sortOptions = sort.pop())) {
                        results = results.sort(sortOptions.attribute, sortOptions.descending);
                    }
                } else {
                    results = results.sort(sort);
                }
            }

            var tracked;
            var _track = false;
            if (_track && results.track && !results.tracking) {
                // if it is trackable, always track, so that observe can
                // work properly.
                results = results.track();
                tracked = true;
            }
            if ('start' in options) {
                // Apply a range
                var start = options.start || 0;
                // object stores support sync results, so try that if available
                queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
                    start: start,
                    end: options.count ? (start + options.count) : Infinity
                });
                queryResults.total = queryResults.totalLength;
            }
            queryResults = queryResults || new QueryResults(results[results.fetchSync ? 'fetchSync' : 'fetch']());
            queryResults.observe = function (callback, includeObjectUpdates) {
                // translate observe to event listeners
                function convertUndefined(value) {
                    if (value === undefined && tracked) {
                        return -1;
                    }
                    return value;
                }

                var addHandle = results.on('add', function (event) {
                    callback(event.target, -1, convertUndefined(event.index));
                });
                var updateHandle = results.on('update', function (event) {
                    if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
                        callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
                    }
                });
                var removeHandle = results.on('delete', function (event) {
                    callback(event.target, convertUndefined(event.previousIndex), -1);
                });
                var handle = {
                    remove: function () {
                        addHandle.remove();
                        updateHandle.remove();
                        removeHandle.remove();
                    }
                };
                handle.cancel = handle.remove;
                return handle;
            };
            if(!has('xcf-ui') && hash && !has('host-node') && allowCache!==false){
                !this._queryCache && (this._queryCache={});
                this._queryCache[hash]=queryResults;
            }
            return queryResults;
        }
    });
});
/** @module xide/data/Memory **/
define('xide/data/Memory',[
    "dojo/_base/declare",
    'dstore/Memory',
    'xide/data/_Base'
], function (declare, Memory,_Base) {
    /**
     * Base memory class
     * @class module:xide/data/Memory
     * @extends module:xide/data/_Base
     * @extends module:dstore/Memory
     */
    return declare('xide.data.Memory',[Memory, _Base], {
        /**
         * XIDE specific override to ensure the _store property. This is because the store may not use dmodel in some
         * cases like running server-side but the _store property is expected to be there.
         * @param item {object}
         * @returns {*}
         */
        putSync:function(item){
            var self = this;
            item = this.inherited(arguments);
            item && !item._store && Object.defineProperty(item, '_store', {
                get: function () {
                    return self;
                }
            });
            return item;
        }
    });
});

define('dstore/Tree',[
	'dojo/_base/declare'
	/*=====, 'dstore/Store'=====*/
], function (declare /*=====, Store=====*/) {
	return declare(null, {
		constructor: function () {
			this.root = this;
		},

		mayHaveChildren: function (object) {
			// summary:
			//		Check if an object may have children
			// description:
			//		This method is useful for eliminating the possibility that an object may have children,
			//		allowing collection consumers to determine things like whether to render UI for child-expansion
			//		and whether a query is necessary to retrieve an object's children.
			// object:
			//		The potential parent
			// returns: boolean

			return 'hasChildren' in object ? object.hasChildren : true;
		},

		getRootCollection: function () {
			// summary:
			//		Get the collection of objects with no parents
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: null });
		},

		getChildren: function (object) {
			// summary:
			//		Get a collection of the children of the provided parent object
			// object:
			//		The parent object
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: this.getIdentity(object) });
		}
	});
});

/** @module xide/data/TreeMemory **/
define('xide/data/TreeMemory',[
    "dojo/_base/declare",
    'xide/data/Memory',
    'dstore/Tree',
    'dojo/Deferred',
    'dstore/QueryResults'
], function (declare, Memory, Tree, Deferred, QueryResults) {

    /**
     * @class module:xide/data/TreeMemory
     * @deprecated
     * @extends module:xide/data/_Base
     * @extends module:dstore/Tree
     */
    return declare('xide.data.TreeMemory', [Memory, Tree], {
        _state: {
            filter: null
        },
        parentProperty: 'parentId',
        reset: function () {
            this._state.filter = null;
            this.resetQueryLog();
        },
        resetQueryLog: function () {
            this.queryLog = [];
        },
        fetchRange: function () {
            // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
            // so we need to extend this as well.
            var results = this._fetchRange(arguments);
            return new QueryResults(results.then(function (data) {
                return data;
            }), {
                totalLength: results.then(function (data) {
                    return data.length;
                })
            });
        },
        filter: function (data) {
            var _res = this.inherited(arguments);
            this._state.filter = data;
            return _res;
        },
        _fetchRange: function (kwArgs) {
            var deferred = new Deferred();
            var _res = this.fetchRangeSync(kwArgs);
            if (this._state.filter) {
                //the parent query
                if (this._state.filter['parent']) {
                    var _item = this.getSync(this._state.filter[this.parentProperty]);
                    if (_item) {
                        this.reset();
                        var _query = {};
                        if (this.getChildrenSync) {
                            _res = this.getChildrenSync(_item);
                        } else {
                            _query[this.parentProperty] = _item[this.idProperty];
                            _res = this.root.query(_query);
                        }
                    }
                }


                //the group query
                if (this._state && this._state.filter && this._state.filter['group']) {
                    var _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res = _item.items;
                    }
                }
            }
            deferred.resolve(_res);
            return deferred;
        },
        getChildren: function (object) {
            var filter = {};
            filter[this.parentProperty] = this.getIdentity(object);
            return this.root.filter(filter);
        },
        children: function (parent) {
            var all = this.root.data, out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj[this.parentProperty] == parent[this.idProperty]) {
                    out.push(obj);
                }
            }
            return all;
        },
        mayHaveChildren: function (parent) {
            if (parent._mayHaveChildren === false) {
                return false;
            }
            return true;
        }
    });
});

/** @module xide/data/ObservableStore **/
define('xide/data/ObservableStore',[
    "dojo/_base/declare",
    "xide/mixins/EventedMixin",
    "xide/lodash"
], function (declare, EventedMixin, _) {
    /**
     * Mixin to deal with dmodel
     * @class module:xide/data/ObservableStore
     * @lends module:xide/data/_Base
     * @lends module:dstore/Store
     * @lends module:xide/data/Memory
     */
    return declare('xide/data/Observable', EventedMixin, {
        /**
         * @type {boolean} Toggle to mute notifications during batch operations.
         */
        _ignoreChangeEvents: true,
        /**
         * @type {Array<String>} List of default properties to be observed by dmodel.property.observe.
         */
        observedProperties: [],
        /**
         * Get/Set toggle to prevent notifications for mass store operations. Without there will be performance drops.
         * @param silent {boolean|null}
         */
        silent: function (silent) {
            if (silent === undefined) {
                return this._ignoreChangeEvents;
            }
            if (silent === true || silent === false && silent !== this._ignoreChangeEvents) {
                this._ignoreChangeEvents = silent;
            }
        },
        /**
         * XIDE Override and extend putSync for adding the _store property and observe a new item's properties.
         * @param item
         * @param publish
         * @returns {*}
         */
        putSync: function (item, publish) {
            this.silent(!publish);
            var res = this.inherited(arguments);
            var self = this;
            publish !== false && this.emit('added', res);
            res && !res._store && Object.defineProperty(res, '_store', {
                get: function () {
                    return self;
                }
            });
            this._observe(res);
            this.silent(false);
            return res;
        },
        /**
         * Extend and override removeSync to silence notifications during batch operations.
         * @param id {string}
         * @param silent {boolean|null}
         * @returns {*}
         */
        removeSync: function (id, silent) {
            this.silent(silent);
            var _item = this.getSync(id);
            _item && _item.onRemove && _item.onRemove();
            var res = this.inherited(arguments);
            this.silent(false);
            return res;
        },
        /**
         *
         * @param item
         * @param property
         * @param value
         * @param source
         * @private
         */
        _onItemChanged: function (item, property, value, source) {
            if (this._ignoreChangeEvents) {
                return;
            }
            var args = {
                target: item,
                property: property,
                value: value,
                source: source
            };
            this.emit('update', args);
            item.onItemChanged && item.onItemChanged(args);
        },
        /**
         * Observe an item's properties specified in this.observedProperties and item.observed, called upon putSync.
         * @param item {module:xide/data/Model}
         * @private
         */
        _observe: function (item) {
            var props = this.observedProperties;
            item.observed && (props = props.concat(item.observed));
            _.each(props, function (property) {
                item.property && item.property(property).observe(function (value) {
                    this._onItemChanged(item, property, value, this);
                }.bind(this));
            }.bind(this));
        },
        /**
         * Override setData to bring in dmodel's observe for new items.
         * @param data {object[]}
         * @returns {*}
         */
        setData: function (data) {
            var res = this.inherited(arguments);
            this.silent(true);
            data && _.each(data, this._observe, this);
            this.silent(false);
            return res;
        }
    });
});
define('dstore/Trackable',[
	'dojo/_base/lang',
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/when',
	'dojo/promise/all',
	'dojo/_base/array',
	'dojo/on'
	/*=====, './api/Store' =====*/
], function (lang, declare, aspect, when, whenAll, arrayUtil, on /*=====, Store =====*/) {

	// module:
	//		dstore/Trackable
	var revision = 0;

	function createRange(newStart, newEnd) {
		return {
			start: newStart,
			count: newEnd - newStart
		};
	}

	function registerRange(ranges, newStart, newEnd) {
		for (var i = ranges.length - 1; i >= 0; --i) {
			var existingRange = ranges[i],
				existingStart = existingRange.start,
				existingEnd = existingStart + existingRange.count;

			if (newStart > existingEnd) {
				// existing range completely precedes new range. we are done.
				ranges.splice(i + 1, 0, createRange(newStart, newEnd));
				return;
			} else if (newEnd >= existingStart) {
				// the ranges overlap and must be merged into a single range
				newStart = Math.min(newStart, existingStart);
				newEnd = Math.max(newEnd, existingEnd);
				ranges.splice(i, 1);
			}
		}

		ranges.unshift(createRange(newStart, newEnd));
	}

	function unregisterRange(ranges, start, end) {
		for (var i = 0, range; (range = ranges[i]); ++i) {
			var existingStart = range.start,
				existingEnd = existingStart + range.count;

			if (start <= existingStart) {
				if (end >= existingEnd) {
					// The existing range is within the forgotten range
					ranges.splice(i, 1);
				} else {
					// The forgotten range overlaps the beginning of the existing range
					range.start = end;
					range.count = existingEnd - range.start;

					// Since the forgotten range ends before the existing range,
					// there are no more ranges to update, and we are done
					return;
				}
			} else if (start < existingEnd) {
				if (end > existingStart) {
					// The forgotten range is within the existing range
					ranges.splice(i, 1, createRange(existingStart, start), createRange(end, existingEnd));

					// We are done because the existing range bounded the forgotten range
					return;
				} else {
					// The forgotten range overlaps the end of the existing range
					range.count = start - range.start;
				}
			}
		}
	}

	var trackablePrototype = {
		track: function () {
			var store = this.store || this;

			// monitor for updates by listening to these methods
			var handles = [];
			var eventTypes = {add: 1, update: 1, 'delete': 1};
			// register to listen for updates
			for (var type in eventTypes) {
				handles.push(
					this.on(type, (function (type) {
						return function (event) {
							notify(type, event);
						};
					})(type))
				);
			}

			function makeFetch() {
				return function () {
					var self = this;
					var fetchResults = this.inherited(arguments);
					when(fetchResults, function (results) {
						results = self._results = results.slice();
						if (self._partialResults) {
							// clean this up, as we don't need this anymore
							self._partialResults = null;
						}
						self._ranges = [];
						registerRange(self._ranges, 0, results.length);
					});
					return fetchResults;
				};
			}
			function makeFetchRange() {
				return function (kwArgs) {
					var self = this,
						start = kwArgs.start,
						end = kwArgs.end,
						fetchResults = this.inherited(arguments);
					// only use this if we don't have all the data
					if (!this._results) {
						when(fetchResults, function (results) {
							return when(results.totalLength, function (totalLength) {
								var partialResults = self._partialResults || (self._partialResults = []);
								end = Math.min(end, start + results.length);

								partialResults.length = totalLength;

								// copy the new ranged data into the parent partial data set
								var spliceArgs = [ start, end - start ].concat(results);
								partialResults.splice.apply(partialResults, spliceArgs);
								registerRange(self._ranges, start, end);

								return results;
							});
						});
					}
					return fetchResults;
				};
			}

			// delegate rather than call _createSubCollection because we are not ultimately creating
			// a new collection, just decorating an existing collection with item index tracking.
			// If we use _createSubCollection, it will return a new collection that may exclude
			// important, defining properties from the tracked collection.
			var observed = declare.safeMixin(lang.delegate(this), {
				_ranges: [],

				fetch: makeFetch(),
				fetchRange: makeFetchRange(),

				releaseRange: function (start, end) {
					if (this._partialResults) {
						unregisterRange(this._ranges, start, end);

						for (var i = start; i < end; ++i) {
							delete this._partialResults[i];
						}
					}
				},

				on: function (type, listener) {
					var self = this,
						inheritedOn = this.getInherited(arguments);
					return on.parse(observed, type, listener, function (target, type) {
						return type in eventTypes ?
							aspect.after(observed, 'on_tracked' + type, listener, true) :
							inheritedOn.call(self, type, listener);
					});
				},

				tracking: {
					remove: function () {
						while (handles.length > 0) {
							handles.pop().remove();
						}

						this.remove = function () {};
					}
				},
				// make sure track isn't called twice
				track: null
			});
			if (this.fetchSync) {
				// only add these if we extending a sync-capable store
				declare.safeMixin(observed, {
					fetchSync: makeFetch(),
					fetchRangeSync: makeFetchRange()
				});

				// we take the presence of fetchSync to indicate that the results can be
				// retrieved cheaply, and then we can just automatically fetch and start
				// tracking results
				observed.fetchSync();
			}

			// Create a function that applies all queriers in the query log
			// in order to determine whether a new or updated item belongs
			// in the results and at what position.
			var queryExecutor;
			arrayUtil.forEach(this.queryLog, function (entry) {
				var existingQuerier = queryExecutor,
					querier = entry.querier;

				if (querier) {
					queryExecutor = existingQuerier
						? function (data) { return querier(existingQuerier(data)); }
						: querier;
				}
			});

			var defaultEventProps = {
					'add': { index: undefined },
					'update': { previousIndex: undefined, index: undefined },
					'delete': { previousIndex: undefined }
				},
				findObject = function (data, id, start, end) {
					start = start !== undefined ? start : 0;
					end = end !== undefined ? end : data.length;
					for (var i = start; i < end; ++i) {
						if (store.getIdentity(data[i]) === id) {
							return i;
						}
					}
					return -1;
				};

			function notify(type, event) {

				revision++;
				var target = event.target;
				event = lang.delegate(event, defaultEventProps[type]);

				when(observed._results || observed._partialResults, function (resultsArray) {
					/* jshint maxcomplexity: 32 */

					function emitEvent() {
						// TODO: Eventually we will want to aggregate all the listener events
						// in an event turn, but we will wait until we have a reliable, performant queueing
						// mechanism for this (besides setTimeout)
						var method = observed['on_tracked' + type];
						method && method.call(observed, event);
					}

					if (!resultsArray) {
						// without data, we have no way to determine the indices effected by the change,
						// so just pass along the event and return.
						emitEvent();
						return;
					}

					var i, j, l, ranges = observed._ranges, range;
					/*if(++queryRevision != revision){
						throw new Error('Query is out of date, you must observe() the' +
						' query prior to any data modifications');
					}*/

					var targetId = 'id' in event ? event.id : store.getIdentity(target);
					var removedFrom = -1,
						removalRangeIndex = -1,
						insertedInto = -1,
						insertionRangeIndex = -1;
					if (type === 'delete' || type === 'update') {
						// remove the old one
						for (i = 0; removedFrom === -1 && i < ranges.length; ++i) {
							range = ranges[i];
							for (j = range.start, l = j + range.count; j < l; ++j) {
								var object = resultsArray[j];
								// often ids can be converted strings (if they are used as keys in objects),
								// so we do a coercive equality check
								/* jshint eqeqeq: false */
								if (store.getIdentity(object) == targetId) {
									removedFrom = event.previousIndex = j;
									removalRangeIndex = i;
									resultsArray.splice(removedFrom, 1);

									range.count--;
									for (j = i + 1; j < ranges.length; ++j) {
										ranges[j].start--;
									}

									break;
								}
							}
						}
					}

					if (type === 'add' || type === 'update') {
						if (queryExecutor) {
							// with a queryExecutor, we can determine the correct sorted index for the change

							if (queryExecutor([target]).length) {
								var begin = 0,
									end = ranges.length - 1,
									sampleArray,
									candidateIndex = -1,
									sortedIndex,
									adjustedIndex;
								while (begin <= end && insertedInto === -1) {
									// doing a binary search for the containing range
									i = begin + Math.round((end - begin) / 2);
									range = ranges[i];

									sampleArray = resultsArray.slice(range.start, range.start + range.count);

									if ('beforeId' in event) {
										candidateIndex = event.beforeId === null
											? sampleArray.length
											: findObject(sampleArray, event.beforeId);
									}

									if (candidateIndex === -1) {
										// If the original index came from this range, put back in the original slot
										// so it doesn't move unless it needs to (relying on a stable sort below)
										if (removedFrom >= Math.max(0, range.start - 1)
											&& removedFrom <= (range.start + range.count)) {
											candidateIndex = removedFrom;
										} else {
											candidateIndex = store.defaultNewToStart ? 0 : sampleArray.length;
										}
									}
									sampleArray.splice(candidateIndex, 0, target);

									sortedIndex = arrayUtil.indexOf(queryExecutor(sampleArray), target);
									adjustedIndex = range.start + sortedIndex;

									if (sortedIndex === 0 && range.start !== 0) {
										end = i - 1;
									} else if (sortedIndex >= (sampleArray.length - 1) &&
											adjustedIndex < resultsArray.length) {
										begin = i + 1;
									} else {
										insertedInto = adjustedIndex;
										insertionRangeIndex = i;
									}
								}
								if (insertedInto === -1 && begin > 0 && begin < ranges.length) {
									var betweenRanges = true;
								}
							}
						} else {
							// we don't have a queryExecutor, so we can't provide any information
							// about where it was inserted or moved to. If it is an update, we leave
							// its position alone. otherwise, we at least indicate a new object

							var range,
								possibleRangeIndex = -1;
							if ('beforeId' in event) {
								if (event.beforeId === null) {
									insertedInto = resultsArray.length;
									possibleRangeIndex = ranges.length - 1;
								} else {
									for (i = 0, l = ranges.length; insertionRangeIndex === -1 && i < l; ++i) {
										range = ranges[i];

										insertedInto = findObject(
											resultsArray,
											event.beforeId,
											range.start,
											range.start + range.count
										);

										if (insertedInto !== -1) {
											insertionRangeIndex = i;
										}
									}
								}
							} else {
								if (type === 'update') {
									insertedInto = removedFrom;
									insertionRangeIndex = removalRangeIndex;
								} else {
									if (store.defaultNewToStart) {
										insertedInto = 0;
										possibleRangeIndex = 0;
									} else {
										// default to the bottom
										insertedInto = resultsArray.length;
										possibleRangeIndex = ranges.length - 1;
									}
								}
							}

							if (possibleRangeIndex !== -1 && insertionRangeIndex === -1) {
								range = ranges[possibleRangeIndex];
								if (range && range.start <= insertedInto
									&& insertedInto <= (range.start + range.count)) {
									insertionRangeIndex = possibleRangeIndex;
								}
							}
						}

						// an item only truly has a known index if it is in a known range
						if (insertedInto > -1 && insertionRangeIndex > -1) {
							event.index = insertedInto;
							resultsArray.splice(insertedInto, 0, target);

							// update the count and start of the appropriate ranges
							ranges[insertionRangeIndex].count++;
							for (i = insertionRangeIndex + 1; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						} else if (betweenRanges) {
							// the begin index will be after the inserted item, and is
							// where we can begin incrementing start values
							event.beforeIndex = ranges[begin].start;
							for (i = begin; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						}
					}
					// update the total
					event.totalLength = resultsArray.length;

					emitEvent();
				});
			}

			return observed;
		}
	};

	var Trackable =  declare(null, trackablePrototype);

	Trackable.create = function (target, properties) {
		// create a delegate of an existing store with trackability functionality mixed in
		target = declare.safeMixin(lang.delegate(target), trackablePrototype);
		declare.safeMixin(target, properties);
		return target;
	};
	return Trackable;
});

define('xide/utils/ObjectUtils',[
    'xide/utils',
    'require',
    "dojo/Deferred",
    'xide/lodash'
], function (utils, require, Deferred, lodash) {
    var _debug = false;
    "use strict";

    utils.delegate = (function () {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {
        }

        return function (obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                lang._mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Loader utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.debounce = function (who, methodName, _function, delay, options, now, args) {
        var _place = who[methodName + '_debounced'];
        if (!_place) {
            _place = who[methodName + '_debounced'] = lodash.debounce(_function, delay, options);
        }
        if (now === true) {
            if (!who[methodName + '_debouncedFirst']) {
                who[methodName + '_debouncedFirst'] = true;
                _function.apply(who, args);
            }
        }
        return _place();
    };


    utils.pluck = function (items, prop) {
        return lodash.map(items, prop);
    };

    /**
     * Trigger downloadable file
     * @param filename
     * @param text
     */
    utils.download = function (filename, text) {
        var element = document.createElement('a');
        text = lodash.isString(text) ? text : JSON.stringify(text, null, 2);
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    /**
     * Ask require registry at this path
     * @param mixed
     * @returns {*}
     */
    utils.hasObject = function (mixed) {
        var result = null;
        var _re = require;
        try {
            result = _re(mixed);
        } catch (e) {
            console.error('error in utils.hasObject ', e);
        }
        return result;
    };
    /**
     * Safe require.toUrl
     * @param mid {string}
     */
    utils.toUrl = function (mid) {
        var _require = require;
        //make sure cache bust is off otherwise it appends ?time
        _require({
            cacheBust: null,
            waitSeconds: 5
        });
        return _require.toUrl(mid);
    }
    /**
     * Returns a module by module path
     * @param mixed {String|Object}
     * @param _default {Object} default object
     * @returns {Object|Promise}
     */
    utils.getObject = function (mixed, _default) {
        var result = null;
        if (utils.isString(mixed)) {
            var _re = require;
            try {
                result = _re(mixed);
            } catch (e) {
                _debug && console.warn('utils.getObject::require failed for ' + mixed);
            }
            //not a loaded module yet
            try {
                if (!result) {
                    var deferred = new Deferred();
                    //try loader
                    result = _re([
                        mixed
                    ], function (module) {
                        deferred.resolve(module);
                    });
                    return deferred.promise;
                }
            } catch (e) {
                _debug && console.error('error in requiring ' + mixed, e);
            }
            return result;

        } else if (utils.isObject(mixed)) {
            return mixed;//reflect
        }
        return result !== null ? result : _default;
    };


    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  True object utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.toArray = function (obj) {
        var result = [];
        for (var c in obj) {
            result.push({
                name: c,
                value: obj[c]
            });
        }
        return result;
    };
    /**
     * Array to object conversion
     * @param arr
     * @returns {Object}
     */
    utils.toObject = function (arr, lodash) {
        if (!arr) {
            return {};
        }
        if (lodash !== false) {
            return lodash.object(lodash.map(arr, lodash.values));
        } else {
            //CI related back compat hack
            if (utils.isObject(arr) && arr[0]) {
                return arr[0];
            }

            var rv = {};
            for (var i = 0; i < arr.length; ++i) {
                rv[i] = arr[i];
            }
            return rv;
        }
    };

    /**
     * Gets an object property by string, eg: utils.byString(someObj, 'part3[0].name');
     * @deprecated, see objectAtPath below
     * @param o {Object}    : the object
     * @param s {String}    : the path within the object
     * @param defaultValue {Object|String|Number} : an optional default value
     * @returns {*}
     */
    utils.byString = function (o, s, defaultValue) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, '');           // strip a leading dot
        var a = s.split('.');
        while (a.length) {
            var n = a.shift();
            if (n in o) {
                o = o[n];
            } else {
                return;
            }
        }
        return o;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Internals
     */

        //cache
    var toStr = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * @private
     * @param type
     * @returns {*}
     */
    function toString(type) {
        return toStr.call(type);
    }

    /**
     * @private
     * @param key
     * @returns {*}
     */
    function getKey(key) {
        var intKey = parseInt(key, 10);
        if (intKey.toString() === key) {
            return intKey;
        }
        return key;
    }

    /**
     * internal set value at path in object
     * @private
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    function set(obj, path, value, doNotReplace) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return set(obj, path.split('.').map(getKey), value, doNotReplace);
        }
        var currentPath = path[0];

        if (path.length === 1) {
            var oldVal = obj[currentPath];
            if (oldVal === void 0 || !doNotReplace) {
                obj[currentPath] = value;
            }
            return oldVal;
        }

        if (obj[currentPath] === void 0) {
            //check if we assume an array
            if (lodash.isNumber(path[1])) {
                obj[currentPath] = [];
            } else {
                obj[currentPath] = {};
            }
        }
        return set(obj[currentPath], path.slice(1), value, doNotReplace);
    }

    /**
     * deletes an property by a path
     * @param obj
     * @param path
     * @returns {*}
     */
    function del(obj, path) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return del(obj, path.split('.'));
        }

        var currentPath = getKey(path[0]);
        var oldVal = obj[currentPath];

        if (path.length === 1) {
            if (oldVal !== void 0) {
                if (lodash.isArray(obj)) {
                    obj.splice(currentPath, 1);
                } else {
                    delete obj[currentPath];
                }
            }
        } else {
            if (obj[currentPath] !== void 0) {
                return del(obj[currentPath], path.slice(1));
            }
        }
        return obj;
    }

    /**
     * Private helper class
     * @private
     * @type {{}}
     */
    var objectPath = {};

    objectPath.has = function (obj, path) {
        if (lodash.isEmpty(obj)) {
            return false;
        }
        if (lodash.isNumber(path)) {
            path = [path];
        } else if (lodash.isString(path)) {
            path = path.split('.');
        }

        if (lodash.isEmpty(path) || path.length === 0) {
            return false;
        }

        for (var i = 0; i < path.length; i++) {
            var j = path[i];
            if ((lodash.isObject(obj) || lodash.isArray(obj)) && _hasOwnProperty.call(obj, j)) {
                obj = obj[j];
            } else {
                return false;
            }
        }

        return true;
    };

    /**
     * Define private public 'ensure exists'
     * @param obj
     * @param path
     * @param value
     * @returns {*}
     */
    objectPath.ensureExists = function (obj, path, value) {
        return set(obj, path, value, true);
    };

    /**
     * Define private public 'set'
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    objectPath.set = function (obj, path, value, doNotReplace) {
        return set(obj, path, value, doNotReplace);
    };

    /**
     Define private public 'insert'
     * @param obj
     * @param path
     * @param value
     * @param at
     */
    objectPath.insert = function (obj, path, value, at) {
        var arr = objectPath.get(obj, path);
        at = ~~at;
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.splice(at, 0, value);
    };

    /**
     * Define private public 'empty'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.empty = function (obj, path) {
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        var value, i;
        if (!(value = objectPath.get(obj, path))) {
            return obj;
        }

        if (lodash.isString(value)) {
            return objectPath.set(obj, path, '');
        } else if (lodash.isBoolean(value)) {
            return objectPath.set(obj, path, false);
        } else if (lodash.isNumber(value)) {
            return objectPath.set(obj, path, 0);
        } else if (lodash.isArray(value)) {
            value.length = 0;
        } else if (lodash.isObject(value)) {
            for (i in value) {
                if (_hasOwnProperty.call(value, i)) {
                    delete value[i];
                }
            }
        } else {
            return objectPath.set(obj, path, null);
        }
    };

    /**
     * Define private public 'push'
     * @param obj
     * @param path
     */
    objectPath.push = function (obj, path /*, values */) {
        var arr = objectPath.get(obj, path);
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };

    /**
     * Define private public 'coalesce'
     * @param obj
     * @param paths
     * @param defaultValue
     * @returns {*}
     */
    objectPath.coalesce = function (obj, paths, defaultValue) {
        var value;
        for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
                return value;
            }
        }
        return defaultValue;
    };

    /**
     * Define private public 'get'
     * @param obj
     * @param path
     * @param defaultValue
     * @returns {*}
     */
    objectPath.get = function (obj, path, defaultValue) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            //lodash doesnt seem to work with html nodes
            if (obj && obj.innerHTML === null) {
                return defaultValue;
            }
        }
        if (lodash.isString(path)) {
            return objectPath.get(obj, path.split('.'), defaultValue);
        }
        var currentPath = getKey(path[0]);
        if (path.length === 1) {
            if (obj && obj[currentPath] === void 0) {
                return defaultValue;
            }
            if (obj) {
                return obj[currentPath];
            }
        }
        if (!obj) {
            return defaultValue;
        }
        return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
    };

    /**
     * Define private public 'del'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.del = function (obj, path) {
        return del(obj, path);
    };
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path public xide/utils mixin
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *  Returns a value by a give object path
     *
     *  //works also with arrays
     *    objectPath.get(obj, "a.c.1");  //returns "f"
     *    objectPath.get(obj, ["a","c","1"]);  //returns "f"
     *
     * @param obj {object}
     * @param path {string}
     * @param _default {object|null}
     * @returns {*}
     */
    utils.getAt = function (obj, path, _default) {
        return objectPath.get(obj, path, _default);
    };

    /**
     * Sets a value in an object/array at a given path.
     * @example
     *
     * utils.setAt(obj, "a.h", "m"); // or utils.setAt(obj, ["a","h"], "m");
     *
     * //set will create intermediate object/arrays
     * objectPath.set(obj, "a.j.0.f", "m");
     *
     * @param obj{Object|Array}
     * @param path {string}
     * @param value {mixed}
     * @returns {Object|Array}
     */
    utils.setAt = function (obj, path, value) {
        return objectPath.set(obj, path, value);
    };

    /**
     * Returns there is anything at given path within an object/array.
     * @param obj
     * @param path
     */
    utils.hasAt = function (obj, path) {
        return objectPath.has(obj, path);
    };

    /**
     * Ensures at given path, otherwise _default will be placed
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.ensureAt = function (obj, path, _default) {
        return objectPath.ensureExists(obj, path, _default);
    };
    /**
     * Deletes at given path
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.deleteAt = function (obj, path) {
        return objectPath.del(obj, path);
    };

    /**
     *
     * @param to
     * @param from
     * @returns {*}
     */
    utils.merge = function (to, from) {
        for (var n in from) {
            if (typeof to[n] != 'object') {
                to[n] = from[n];
            } else if (typeof from[n] == 'object') {
                to[n] = utils.merge(to[n], from[n]);
            }
        }

        return to;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Dojo's most wanted
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Clones objects (including DOM nodes) and all children.
     * Warning: do not clone cyclic structures.
     * @param src {*} The object to clone.
     * @returns {*}
     */
    utils.clone = function (src) {
        if (!src || typeof src != "object" || utils.isFunction(src)) {
            // null, undefined, any non-object, or function
            return src; // anything
        }
        if (src.nodeType && "cloneNode" in src) {
            // DOM Node
            return src.cloneNode(true); // Node
        }
        if (src instanceof Date) {
            // Date
            return new Date(src.getTime()); // Date
        }
        if (src instanceof RegExp) {
            // RegExp
            return new RegExp(src); // RegExp
        }
        var r, i, l;
        if (utils.isArray(src)) {
            // array
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
                if (i in src) {
                    r.push(utils.clone(src[i]));
                }
            }
            // we don't clone functions for performance reasons
            // }else if(d.isFunction(src)){
            // // function
            // r = function(){ return src.apply(this, arguments); };
        } else {
            // generic objects
            r = src.constructor ? new src.constructor() : {};
        }
        return utils._mixin(r, src, utils.clone);
    };

    /**
     * Copies/adds all properties of source to dest; returns dest.
     * @description All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
     * found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
     * delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
     * Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
     * @param dest {object} The object to which to copy/add all properties contained in source.
     * @param source {object} The object from which to draw all properties to copy into dest.
     * @param copyFunc {function} The process used to copy/add a property in source; defaults to the Javascript assignment operator.
     * @returns {object} dest, as modified
     * @private
     */
    utils._mixin = function (dest, source, copyFunc) {
        var name, s, i, empty = {};
        for (name in source) {
            // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
            // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
            // don't overwrite it with the toString() method that source inherited from Object.prototype
            s = source[name];
            if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                dest[name] = copyFunc ? copyFunc(s) : s;
            }
        }

        return dest; // Object
    };
    /**
     * Copies/adds all properties of one or more sources to dest; returns dest.
     * @param dest {object} The object to which to copy/add all properties contained in source. If dest is falsy, then
     * a new object is manufactured before copying/adding properties begins.
     *
     * @param sources One of more objects from which to draw all properties to copy into dest. sources are processed
     * left-to-right and if more than one of these objects contain the same property name, the right-most
     * value "wins".
     *
     * @returns {object} dest, as modified
     *
     * @example
     * make a shallow copy of an object
     * var copy = utils.mixin({}, source);
     *
     * @example
     *
     * many class constructors often take an object which specifies
     *        values to be configured on the object. In this case, it is
     *        often simplest to call `lang.mixin` on the `this` object:
     *        declare("acme.Base", null, {
    *			constructor: function(properties){
    *				//property configuration:
    *				lang.mixin(this, properties);
    *				console.log(this.quip);
    *			},
    *			quip: "I wasn't born yesterday, you know - I've seen movies.",
    *			* ...
    *		});
     *
     *        //create an instance of the class and configure it
     *        var b = new acme.Base({quip: "That's what it does!" });
     *
     */
    utils.mixin = function (dest, sources) {
        if (sources) {
            if (!dest) {
                dest = {};
            }
            var l = arguments.length;
            for (var i = 1; i < l; i++) {
                utils._mixin(dest, arguments[i]);
            }
            return dest; // Object
        }
        return dest;
    };

    /**
     * Clone object keys
     * @param defaults
     * @returns {{}}
     */
    utils.cloneKeys = function (defaults, skipEmpty) {
        var result = {};
        for (var _class in defaults) {
            if (skipEmpty === true && !(_class in defaults)) {
                continue;
            }
            result[_class] = defaults[_class];
        }
        return result;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  STD
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isArray = function (what) {
        return lodash.isArray(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isObject = function (what) {
        return lodash.isObject(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isString = function (what) {
        return lodash.isString(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isNumber = function (what) {
        return lodash.isNumber(what);
    };
    /**
     * Return true if it is a Function
     * @param it
     * @returns {*}
     */
    utils.isFunction = function (it) {
        return lodash.isFunction(it);
    };
    return utils;
});
define('xide/cache/Circular',[], function () {

    function CircularBuffer(capacity){
        if(!(this instanceof CircularBuffer))return new CircularBuffer(capacity);
        if(typeof capacity=="object"&&
            Array.isArray(capacity["_buffer"])&&
            typeof capacity._capacity=="number"&&
            typeof capacity._first=="number"&&
            typeof capacity._size=="number"){
            for(var prop in capacity){
                if(capacity.hasOwnProperty(prop))this[prop]=capacity[prop];
            }
        } else {
            if(typeof capacity!="number"||capacity%1!=0||capacity<1)
                throw new TypeError("Invalid capacity");
            this._buffer=new Array(capacity);
            this._capacity=capacity;
            this._first=0;
            this._size=0;
        }
    }
    CircularBuffer.prototype = {
        size: function () {
            return this._size;
        },
        capacity: function () {
            return this._capacity;
        },
        enq: function (value) {
            if (this._first > 0)this._first--; else this._first = this._capacity - 1;
            this._buffer[this._first] = value;
            if (this._size < this._capacity)this._size++;
        },
        push: function (value) {
            if (this._size == this._capacity) {
                this._buffer[this._first] = value;
                this._first = (this._first + 1) % this._capacity;
            } else {
                this._buffer[(this._first + this._size) % this._capacity] = value;
                this._size++;
            }
        },
        deq: function () {
            if (this._size == 0)throw new RangeError("dequeue on empty buffer");
            var value = this._buffer[(this._first + this._size - 1) % this._capacity];
            this._size--;
            return value;
        },
        pop: function () {
            return this.deq();
        },
        shift: function () {
            if (this._size == 0)throw new RangeError("shift on empty buffer");
            var value = this._buffer[this._first];
            if (this._first == this._capacity - 1)this._first = 0; else this._first++;
            this._size--;
            return value;
        },
        get: function (start, end) {
            if (this._size == 0 && start == 0 && (end == undefined || end == 0))return [];
            if (typeof start != "number" || start % 1 != 0 || start < 0)throw new TypeError("Invalid start");
            if (start >= this._size)throw new RangeError("Index past end of buffer: " + start);

            if (end == undefined)return this._buffer[(this._first + start) % this._capacity];

            if (typeof end != "number" || end % 1 != 0 || end < 0)throw new TypeError("Invalid end");
            if (end >= this._size)throw new RangeError("Index past end of buffer: " + end);

            if (this._first + start >= this._capacity) {
                //make sure first+start and first+end are in a normal range
                start -= this._capacity; //becomes a negative number
                end -= this._capacity;
            }
            if (this._first + end < this._capacity)
                return this._buffer.slice(this._first + start, this._first + end + 1);
            else
                return this._buffer.slice(this._first + start, this._capacity).concat(this._buffer.slice(0, this._first + end + 1 - this._capacity));
        },
        toarray: function () {
            if (this._size == 0)return [];
            return this.get(0, this._size - 1);
        }
    };

    return CircularBuffer;
});
/** @module xaction/Action **/
define('xaction/Action',[
    'dcl/dcl',
    'xide/model/Base',
    'xide/types',
    'xide/utils/ObjectUtils',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'xide/cache/Circular'
], function (dcl, Base, types, ObjectUtils, utils, EventedMixin, Circular) {

    var Cache = null;//new Circular(100);
    /***
     * Extend the core types for action visibility(main menu,...) options/enums:
     * 1. 'Main menu',
     * 2. 'Context menu'
     * 3. 'Action toolbar'
     * 4. 'Property view'
     */
    utils.mixin(types, {
        /**
         * ActionVisibility
         * @enum module:xide/types/ACTION_VISIBILITY
         * @memberOf module:xide/types
         */
        ACTION_VISIBILITY: {
            /**
             * Enable visibility in main menu, which does
             * render actions in a menu bar whereby 'sub' levels
             * are rendered as sub level menus.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            MAIN_MENU: 'MAIN_MENU',

            /**
             * Enable visivibilty in context menu.
             *
             * Different to the main menu, all actions
             * are 'flatted'. The action's group field
             * will auto-create separators among these
             * groups.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            CONTEXT_MENU: 'CONTEXT_MENU',

            QUICK_LAUNCH: 'QUICK_LAUNCH',

            /**
             * Enable visivibilty in primary action toolbar.
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            ACTION_TOOLBAR: 'ACTION_TOOLBAR',

            /**
             * Enable visibility in an item's property view (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            PROPERTY_VIEW: 'PROPERTY_VIEW',

            /**
             * Enable visibility the ribbon toolbar (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            RIBBON: 'RIBBON',

            /**
             * A mixin to be used whilst creating the widget
             * @type {object}
             */
            widgetArgs: null,

            /**
             * Util for the constructor yo create a visibilty. A visibility is a key/value store where the
             * key is ACTION_VISIBILITY
             * and its value is stored in this.ACTION_VISIBILITY_val ! Thus you'r accessing this store in a doc-friendly
             * and enum like function
             * @example
             *  this.getVisibility(types.ACTION_VISIBILITY.MAIN_MENU)'     *
             *
             * the returning value is of type {object}, or {integer(1|0)}
             * @type {function}
             * @returns {module:xide/types/ACTION_VISIBILITY}
             */
            factory: function () {

                var _in = arguments[1] || utils.clone(types.ACTION_VISIBILITY),
                    _args = arguments;

                //
                // A mode when we have the arguments like (1,1,1,2).
                //  This clones types.ACTION_VISIBILITY and blends in an integer mask

                if (_args[0].length > 0 && _.isNumber(_args[0][0])) {

                    var _FlagArgs = _args[0],
                        _val = null,
                        _index = 0;

                    //integer case, sets this[propIndex] to something
                    _.each(_in, function (index, prop) {
                        if (typeof _in[prop] !== 'function') {
                            if (_index < _FlagArgs.length) {
                                //set the value per key but preserve the actualy key by storing
                                //the value in a new key_val field
                                _in[prop + '_val'] = _FlagArgs[_index];
                            }
                        }
                        _index++;
                    });
                }

                // A modus when we have the arguments like (MAIN_MENU,something). set value in this.ENUM_val
                if (_.isString(_args[0][0])) {
                    if (_args[0][2] === true) {
                        utils.mixin(_in[_args[0][0] + '_val'], _args[0][2]);
                    } else {
                        _in[_args[0][0] + '_val'] = _args[0][1];
                        return _in;
                    }
                    return _args[1];
                }
                return _in;
            }
        }
    });
    types.ACTION_VISIBILITY_ALL = 'ACTION_VISIBILITY_ALL';
    /**
     * Basic model to represent an 'action'. Its just a structure
     * object with some factory methods and built-in store to have
     * versions of it self per 'ACTION_VISIBILITY' which may alter
     * rendering for such visibility.
     *
     * Please read {@link module:xide/types}
     *
     * @class module:xaction/Action
     * @augments xide/model/Base
     */
    var Module = dcl([Base.dcl, EventedMixin.dcl], {
        declaredClass: "xaction/Action",
        disabled: false,
        destroy: function () {
            if (Cache && Cache.size() < 100) {
                delete this._properties;
                delete this._visibility;
                delete this.keyboardMappings;
                delete this.group;
                delete this.tab;
                delete this.owner;
                delete this.item;
                delete this.icon;
                delete this.actionType;
                delete this.label;
                delete this.title;
                delete this.type;
                delete this.onCreate;
                delete this.onChange;
                delete this.addPermission;
                delete this._store;
                delete this.parameters;
                delete this.handler;
                Cache.push(this);
            }
        },
        /**
         * Turn on/off this action
         * @type {boolean}
         * @default true
         */
        enabled: true,
        /**
         * The object or bean we're up to. This is mostly the user's selection.
         * @type {Object|Object[]|Array}
         */
        object: null,
        /**
         * Show/hide this action in ui
         * @member show {boolean}
         */
        show: true,
        /**
         * A group for this action. This is being used in interface only.
         * @type {string|Object=}
         */
        group: '',
        /**
         * A comma separated list of bean types. This specifies on which bean types
         * this action can be applied
         * @type {string|Object=}
         */
        types: '',
        /**
         * A identifier of a command within a "bean action context". This should be human readable.
         * Remember, this is being used for populating menu items in toolbars.
         * @example "Edit/Copy", "Views/Log" and so forth
         * @type {string|integer}
         */
        command: null,
        /**
         * Icon class. You can use font-awesome, dijit icon classes or Elusive icons
         * @type {string}
         * @default fa-play
         */
        icon: 'fa-play',
        /**
         * An event key when the action is performed. This will be published automatically when this action
         * is performed.
         * @type {string|null}
         * @default null
         */
        event: null,
        /**
         * The function to be invoked
         * @type {function|null}
         */
        handler: null,
        /**
         * The tab (visual)
         * @type {string|null}
         * @default null
         */
        tab: null,

        /**
         * A store to override per visibility an action attributes like label, icon, renderer, handler
         * or whatever this action needs. This acts as store per VISIBILITY "Zone" as descried in the enumerations. Its
         * one simple object or single integer store.
         *
         * This storage must be fast as its used in mouse-over, don't use any dojo/dstore or whatever fancy stuff; the
         * operations in the consumer side are already heavy enough (loadash 'group' and 'sort' come up to 5000 calls for
         * just 10 actions)
         *
         * @see {module:xide/types/ACTION_VISIBILITY}
         * @type {xide/types/ACTION_VISIBILITY}
         * @augments {xide/types/ACTION_VISIBILITY}
         * @default null
         * @property
         * @member
         *
         * @example
         * {
         *      MAIN_MENU:"MAIN_MENU",
         *      MAIN_MENU_val:0
         *      //or MAIN_MENU_val:1
         *      ACTION_TOOLBAR:"ACTION_TOOLBAR",
         *      ACTION_TOOLBAR_val:{
         *          icon:"fa or el or dijit", //supports font-awesome, elusive or dojo/dijit
         *          label:"" // in some cases like an action bar you may override this per visibility to hide a label 
         *      }
         * }
         *
         */
        visibility_: null,
        /**
         * An action might contain a value. For instance the action might toggle
         * a checkbox...
         *
         * @type {object|*|null}
         */
        value: null,
        /**
         * Sets visibility options per visibility type.
         *
         * @param {mixed} arguments will blend a number of integers into a copy of
         * xide/types/ACTION_VISIBILITY. Be aware of the exact order!
         * @example
         *
         *
         //Example 1. : set the visibility per type
         setVisibility(1,1,0);// will result in:
         {
                 MAIN_MENU:1,
                 CONTEXT_MENU:1,
                 ACTION_TOOLBAR:0
         }

         //Example 2. : set the visibility per type. @TODO:specify merge filter bits
         setVisibility(types.ACTION_VISIBILITY.MAIN_MENU,{
                label:null  //don't show a label
            });

         */
        setVisibility: function () {
            if (arguments.length == 2 && _.isString(arguments[0]) && arguments[0] == types.ACTION_VISIBILITY_ALL) {
                var _obj = arguments[1],
                    _vis = types.ACTION_VISIBILITY,
                    thiz = this;

                //track vis key in all
                [_vis.MAIN_MENU, _vis.ACTION_TOOLBAR, _vis.CONTEXT_MENU, _vis.RIBBON].forEach(function (vis) {
                    thiz.setVisibility(vis, utils.cloneKeys(_obj, false));
                });
                return this;

            }
            var _args = _.isArray(arguments[0]) ? arguments[0] : arguments;
            this.visibility_ = types.ACTION_VISIBILITY.factory(_args, this.visibility_);
            return this;
        },
        /**
         * Visibility getter
         * @param key
         * @returns {module:xide/types/ACTION_VISIBILITY}
         */
        getVisibility: function (key) {
            if (!this.visibility_) {
                this.setVisibility(types.ACTION_VISIBILITY_ALL, {});
            }
            if (this.visibility_) {
                if (this.visibility_[key + '_val'] == null) {
                    this.visibility_[key + '_val'] = {
                        vis: key
                    };
                }
                return this.visibility_[key + '_val'];
            }
            return {};
        },
        /**
         *
         * @param _visibility
         * @param who
         * @param newItem
         * @returns {boolean}
         */
        shouldDestroyWidget: function (_visibility, who, newItem) {
            var visibility = this.getVisibility != null ? this.getVisibility(_visibility) : null;
            var destroy = true;
            if (visibility && visibility.permanent) {
                destroy = !(_.isFunction(visibility.permanent) ? visibility.permanent(this, who, newItem) : visibility.permanent);
            }
            return destroy;
        }

    });
    /**
     * Static factory
     * @param label {string}
     * @param icon
     * @param command
     * @param permanent
     * @param operation
     * @param btypes
     * @param group
     * @param visibility
     * @param register
     * @param handler
     * @param mixin
     * @static
     * @memberOf xaction/Action
     *
     * @example for queuing a clip board action:
     *
     *  var _copyAction  = Action.create('Copy', 'fa-copy', 'Edit/Copy', true, types.OPERATION_INT.CLIPBOARD_COPY, types.ITEM_TYPE.FILE, 'clipboard', null, true, _clipboardManager);
     *  _copy.accelKey = 'CTRL+C';
     *
     * @returns {module:xaction/Action}
     */
    Module.create = function (label, icon, command, permanent, operation, btypes, group, visibility, register, handler, mixin) {
        var _action = null;

        var _args = {
            permanent: permanent,
            command: command,
            icon: icon,
            label: label,
            owner: this,
            types: btypes,
            operation: operation,
            group: group,
            handler: handler,
            title: label
        };
        if (Cache && Cache.size()) {
            _action = Cache.deq(0);
            //console.log('re-use');
            utils.mixin(_action, _args);
        } else {
            //console.log('-create!');
            _action = new Module(_args);
        }
        /*
         var VISIBILITY = types.ACTION_VISIBILITY,
         VISIBILITIES = [
         VISIBILITY.ACTION_TOOLBAR,
         VISIBILITY.RIBBON,
         VISIBILITY.MAIN_MENU,
         VISIBILITY.CONTEXT_MENU
         ];
         */
        utils.mixin(_action, mixin);
        return _action;
    };
    /**
     * Simple wrapper for action.create
     * @param label {string}
     * @param icon
     * @param command
     * @param group
     * @param handler
     * @param mixin
     * @returns {module:xaction/Action}
     */
    Module.createDefault = function (label, icon, command, group, handler, mixin) {
        return Module.create(label, icon, command, false, null, null, group || 'nogroup', null, false, handler, mixin);
    };
    return Module;
});

define('xide/data/Model',[
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/aspect',
    'dojo/when',
    'xide/utils'
], function (dcl,Deferred, aspect, when,utils) {


    function getSchemaProperty(object, key) {
        // this function will retrieve the individual property definition
        // from the schema, for the provided object and key
        var definition = object.schema[key];
        if (definition !== undefined && !(definition instanceof Property)) {
            definition = new Property(definition);
            definition._parent = object;
        }
        if (definition) {
            definition.name = key;
        }
        return definition;
    }

    function validate(object, key) {
        /*
         // this performs validation, delegating validation, and coercion
         // handling to the property definitions objects.
         var hasOwnPropertyInstance,
         property = object.hasOwnProperty('_properties') && object._properties[key];

         hasOwnPropertyInstance = property;

         if (!property) {
         // or, if we don't our own property object, we inherit from the schema
         property = getSchemaProperty(object, key);
         if (property && property.validate) {
         property = lang.delegate(property, {
         _parent: object,
         key: key
         });
         }
         }

         if (property && property.validate) {
         return when(property.validate(), function (isValid) {
         if (!isValid) {
         // errors, so don't perform set
         if (!hasOwnPropertyInstance) {
         // but we do need to store our property
         // instance if we don't have our own
         (object.hasOwnProperty('_properties') ?
         object._properties :
         object._properties = new Hidden())[key] = property;
         }
         }
         return isValid;
         });
         }
         */
        return true;
    }

    function whenEach(iterator) {
        // this is responsible for collecting values from an iterator,
        // and waiting for the results if promises are returned, returning
        // a new promise represents the eventual completion of all the promises
        // this will consistently preserve a sync (non-promise) return value if all
        // sync values are provided
        var deferred;
        var remaining = 1;
        // start the iterator
        iterator(function (value, callback, key) {
            if (value && value.then) {
                // it is a promise, have to wait for it
                remaining++;
                if (!deferred) {
                    // make sure we have a deferred
                    deferred = new Deferred();
                }
                value.then(function (value) {
                    // result received, call callback, and then indicate another item is done
                    doneItem(callback(value, key));
                }).then(null, deferred.reject);
            } else {
                // not a promise, just a direct sync callback
                callback(value, key);
            }
        });
        if (deferred) {
            // if we have a deferred, decrement one more time
            doneItem();
            return deferred.promise;
        }
        function doneItem() {
            // called for each promise as it is completed
            remaining--;
            if (!remaining) {
                // all done
                deferred.resolve();
            }
        }
    }
    var slice = [].slice;
    var Model = dcl(null,{
        declaredClass:'xide/data/Model',
        //	summary:
        //		A base class for modelled data objects.

        //	schema: Object | dstore/Property
        //		A hash map where the key corresponds to a property definition.
        //		This can be a string corresponding to a JavaScript
        //		primitive values (string, number, boolean), a constructor, a
        //		null (to allow any type), or a Property object with more advanced
        //		definitions.
        schema: {},

        //	additionalProperties: boolean
        //		This indicates whether properties are allowed that are not
        //		defined in the schema.
        additionalProperties: true,

        //	_scenario: string
        //		The scenario that is used to determine which validators should
        //		apply to this model. There are two standard values for _scenario,
        //		"insert" and "update", but it can be set to any arbitrary value
        //		for more complex validation scenarios.
        _scenario: 'update',

        constructor: function (options) {
            this.init(options);
        },

        refresh:function(silent,property){
            var _store = this._store;
            _store && _store.refreshItem(this,silent,property);
        },
        getStore:function(){
            return this._store;
        },
        getParent:function(){
            return this._store.getSync(this[this._store['parentProperty']]);
        },
        init: function (values) {
            // if we are being constructed, we default to the insert scenario
            this._scenario = 'insert';
            // copy in the default values
            values = this._setValues(values);
            // set any defaults
            for (var key in this.schema) {
                var definition = this.schema[key];
                if (definition && typeof definition === 'object' && 'default' in definition &&
                    !values.hasOwnProperty(key)) {
                    var defaultValue = definition['default'];
                    values[key] = typeof defaultValue === 'function' ? defaultValue.call(this) : defaultValue;
                }
            }
        },

        _setValues: function (values) {
            return utils.mixin(this, values);
        },

        _getValues: function () {
            return this._values || this;
        },

        save: function (/*Object*/ options) {
            //	summary:
            //		Saves this object, calling put or add on the attached store.
            //	options.skipValidation:
            //		Normally, validation is performed to ensure that the object
            //		is not invalid before being stored. Set `skipValidation` to
            //		true to skip it.
            //	returns: any

            var object = this;
            return when((options && options.skipValidation) ? true : this.validate(), function (isValid) {
                if (!isValid) {
                    throw object.createValidationError(object.errors);
                }
                var scenario = object._scenario;
                // suppress any non-date from serialization output
                object.prepareForSerialization();
                return object._store && when(object._store[scenario === 'insert' ? 'add' : 'put'](object),
                        function (returned) {
                            // receive any updates from the server
                            object.set(returned);
                            object._scenario = 'update';
                            return object;
                        });
            });
        },

        remove: function () {
            var store = this._store;
            return store.remove(store.getIdentity(this));
        },

        prepareForSerialization: function () {
            //	summary:
            //		This method is responsible for cleaing up any properties on the instance
            //		object to ensure it can easily be serialized (by JSON.stringify at least)
            this._scenario = undefined;
            if (this._inherited) {
                this._inherited.toJSON = toJSONHidden;
            }
        },

        createValidationError: function (errors) {
            //	summary:
            //		This is called when a save is attempted and a validation error was found.
            //		This can be overriden with locale-specific messages
            //	errors:
            //		Errors that were found in validation
            return new Error('Validation error');
        },

        property: function (/*String...*/ key, nextKey) {
            //	summary:
            //		Gets a new reactive property object, representing the present and future states
            //		of the provided property. The returned property object gives access to methods for changing,
            //		retrieving, and observing the property value, any validation errors, and property metadata.
            //	key: String...
            //		The name of the property to retrieve. Multiple key arguments can be provided
            //		nested property access.

            // create the properties object, if it doesn't exist yet
            var properties = this.hasOwnProperty('_properties') ? this._properties :
                (this._properties = new Hidden());
            var property = properties[key];
            // if it doesn't exist, create one, delegated from the schema's property definition
            // (this gives an property instance, owning the current property value and listeners,
            // while inheriting metadata from the schema's property definitions)
            if (!property) {
                property = getSchemaProperty(this, key);
                // delegate, or just create a new instance if no schema definition exists
                property = properties[key] = property ? utils.delegate(property) : new Property();
                property.name = key;
                // give it the correct initial value
                property._parent = this;
            }
            if (nextKey) {
                // go to the next property, if there are multiple
                return property.property.apply(property, slice.call(arguments, 1));
            }
            return property;
        },

        get: function (/*string*/ key) {
            // TODO: add listener parameter back in
            //	summary:
            //		Standard get() function to retrieve the current value
            //		of a property, augmented with the ability to listen
            //		for future changes

            var property, definition = this.schema[key];
            // now we need to see if there is a custom get involved, or if we can just
            // shortcut to retrieving the property value
            definition = property || this.schema[key];
            if (definition && definition.valueOf &&
                (definition.valueOf !== simplePropertyValueOf || definition.hasCustomGet)) {
                // we have custom get functionality, need to create at least a temporary property
                // instance
                property = property || (this.hasOwnProperty('_properties') && this._properties[key]);
                if (!property) {
                    // no property instance, so we create a temporary one
                    property = utils.delegate(getSchemaProperty(this, key), {
                        name: key,
                        _parent: this
                    });
                }
                // let the property instance handle retrieving the value
                return property.valueOf();
            }
            // default action of just retrieving the property value
            return this._getValues()[key];
        },

        set: function (/*string*/ key, /*any?*/ value) {
            //	summary:
            //		Only allows setting keys that are defined in the schema,
            //		and remove any error conditions for the given key when
            //		its value is set.
            if (typeof key === 'object') {
                startOperation();
                try {
                    for (var i in key) {
                        value = key[i];
                        if (key.hasOwnProperty(i) && !(value && value.toJSON === toJSONHidden)) {
                            this.set(i, value);
                        }
                    }
                } finally {
                    endOperation();
                }
                return;
            }
            var definition = this.schema[key];
            if (!definition && !this.additionalProperties) {
                // TODO: Shouldn't this throw an error instead of just giving a warning?
                return console.warn('Schema does not contain a definition for', key);
            }
            var property = this.hasOwnProperty('_properties') && this._properties[key];
            if (!property &&
                // we need a real property instance if it is an object or if we have a custom put method
                ((value && typeof value === 'object') ||
                (definition && definition.put !== simplePropertyPut))) {
                property = this.property(key);
            }
            if (property) {
                // if the property instance exists, use this to do the set
                property.put(value);
            } else {
                if (definition && definition.coerce) {
                    // if a schema definition exists, and has a coerce method,
                    // we can use without creating a new instance
                    value = definition.coerce(value);
                }
                // we can shortcut right to just setting the object property
                this._getValues()[key] = value;
                // check to see if we should do validation
                if (definition && definition.validateOnSet !== false) {
                    validate(this, key);
                }
            }

            return value;
        },

        observe: function (/*string*/ key, /*function*/ listener, /*object*/ options) {
            //	summary:
            //		Registers a listener for any changes in the specified property
            //	key:
            //		The name of the property to listen to
            //	listener:
            //		Function to be called for each change
            //	options.onlyFutureUpdates
            //		If this is true, it won't call the listener for the current value,
            //		just future updates. If this is true, it also won't return
            //		a new reactive object
            return this.property(key).observe(listener, options);
        },

        validate: function (/*string[]?*/ fields) {
            //	summary:
            //		Validates the current object.
            //	fields:
            //		If provided, only the fields listed in the array will be
            //		validated.
            //	returns: boolean | dojo/promise/Promise
            //		A boolean or a promise that resolves to a boolean indicating whether
            //		or not the model is in a valid state.

            /*
             var object = this,
             isValid = true,
             errors = [],
             fieldMap;

             if (fields) {
             fieldMap = {};
             for (var i = 0; i < fields.length; i++) {
             fieldMap[i] = true;
             }
             }
             return when(whenEach(function (whenItem) {
             // iterate through the keys in the schema.
             // note that we will always validate every property, regardless of when it fails,
             // and we will execute all the validators immediately (async validators will
             // run in parallel)
             for (var key in object.schema) {
             // check to see if we are allowed to validate this key
             if (!fieldMap || (fieldMap.hasOwnProperty(key))) {
             // run validation
             whenItem(validate(object, key), function (isValid, key) {
             if (!isValid) {
             notValid(key);
             }
             }, key);
             }
             }
             }), function () {
             object.set('errors', isValid ? undefined : errors);
             // it wasn't async, so we just return the synchronous result
             return isValid;
             });
             function notValid(key) {
             // found an error, mark valid state and record the errors
             isValid = false;
             errors.push.apply(errors, object.property(key).errors);
             }
             */
        },

        isValid: function () {
            //	summary:
            //		Returns whether or not there are currently any errors on
            //		this model due to validation failures. Note that this does
            //		not run validation but merely returns the result of any
            //		prior validation.
            //	returns: boolean

            var isValid = true,
                key;

            for (key in this.schema) {
                var property = this.hasOwnProperty('_properties') && this._properties[key];
                if (property && property.errors && property.errors.length) {
                    isValid = false;
                }
            }
            return isValid;
        }
    });

    //xhack: make dstore happy
    Model.createSubclass=function(mixins, props){
        var sub = dcl([this].concat(mixins), props || {});
        sub.extend = function(props){
            utils.mixin(this.prototype,props);
            return this;
        }
        return sub;
    }
    // define the start and end markers of an operation, so we can
    // fire notifications at the end of the operation, by default
    function startOperation() {
        setCallDepth++;
    }
    function endOperation() {
        // if we are ending this operation, start executing the queue
        if (setCallDepth < 2 && onEnd) {
            onEnd();
            onEnd = null;
        }
        setCallDepth--;
    }
    var setCallDepth = 0;
    var callbackQueue;
    var onEnd;
    // the default nextTurn executes at the end of the current operation
    // The intent with this function is that it could easily be replaced
    // with something like setImmediate, setTimeout, or nextTick to provide
    // next turn handling
    (Model.nextTurn = function (callback) {
        // set the callback for the end of the current operation
        onEnd = callback;
    }).atEnd = true;

    var Reactive = dcl(Model, {
        //	summary:
        //		A reactive object is a data model that can contain a value,
        //		and notify listeners of changes to that value, in the future.
        observe: function (/*function*/ listener, /*object*/ options) {
            //	summary:
            //		Registers a listener for any changes in the current value
            //	listener:
            //		Function to be called for each change
            //	options.onlyFutureUpdates
            //		If this is true, it won't call the listener for the current value,
            //		just future updates. If this is true, it also won't return
            //		a new reactive object

            var reactive;
            if (typeof listener === 'string') {
                // a property key was provided, use the Model's method
                console.error('fff');
                return this.inherited(arguments);
            }
            if (!options || !options.onlyFutureUpdates) {
                // create a new reactive to contain the results of the execution
                // of the provided function
                reactive = new Reactive();
                if (this._has()) {
                    // we need to notify of the value of the present (as well as future)
                    reactive.value = listener(this.valueOf());
                }
            }
            // add to the listeners
            var handle = this._addListener(function (value) {
                var result = listener(value);
                if (reactive) {
                    // TODO: once we have a real notification API again, call that, instead
                    // of requesting a change
                    reactive.put(result);
                }
            });
            if (reactive) {
                reactive.remove = handle.remove;
                return reactive;
            } else {
                return handle;
            }
        },

        //	validateOnSet: boolean
        //		Indicates whether or not to perform validation when properties
        //		are modified.
        //		This can provided immediate feedback and on the success
        //		or failure of a property modification. And Invalid property
        //		values will be rejected. However, if you are
        //		using asynchronous validation, invalid property values will still
        //		be set.
        validateOnSet: false,

        //	validators: Array
        //		An array of additional validators to apply to this property
        validators: null,

        _addListener: function (listener) {
            // add a listener for the property change event
            return aspect.after(this, 'onchange', listener, true);
        },

        valueOf: function () {
            return this._get();
        },

        _get: function () {
            return this.value;
        },

        _has: function () {
            return this.hasOwnProperty('value');
        },
        setValue: function (value) {
            //	summary:
            //		This method is responsible for storing the value. This can
            //		be overriden to define a custom setter
            //	value: any
            //		The value to be stored
            //	parent: Object
            //		The parent object of this propery
            this.value = value;
        },

        put: function (/*any*/ value) {
            //	summary:
            //		Indicates a new value for this reactive object

            // notify all the listeners of this object, that the value has changed
            var oldValue = this._get();
            value = this.coerce(value);
            if (this.errors) {
                // clear any errors
                this.set('errors', undefined);
            }
            var property = this;
            // call the setter and wait for it
            startOperation();
            return when(this.setValue(value, this._parent), function (result) {
                if (result !== undefined) {
                    // allow the setter to change the value
                    value = result;
                }
                // notify listeners
                if (property.onchange) {
                    // queue the callback
                    property._queueChange(property.onchange, oldValue);
                }
                // if this was set to an object (or was an object), we need to notify.
                // update all the sub-property objects, so they can possibly notify their
                // listeners
                var key,
                    hasOldObject = oldValue && typeof oldValue === 'object' && !(oldValue instanceof Array),
                    hasNewObject = value && typeof value === 'object' && !(value instanceof Array);
                if (hasOldObject || hasNewObject) {
                    // we will iterate through the properties recording the changes
                    var changes = {};
                    if (hasOldObject) {
                        oldValue = oldValue._getValues ? oldValue._getValues() : oldValue;
                        for (key in oldValue) {
                            changes[key] = {old: oldValue[key]};
                        }
                    }
                    if (hasNewObject) {
                        value = value._getValues ? value._getValues() : value;
                        for (key in value) {
                            (changes[key] = changes[key] || {}).value = value[key];
                        }
                    }
                    property._values = hasNewObject && value;
                    for (key in changes) {
                        // now for each change, we can notify the property object
                        var change = changes[key];
                        var subProperty = property._properties && property._properties[key];
                        if (subProperty && subProperty.onchange) {
                            // queue the callback
                            subProperty._queueChange(subProperty.onchange, change.old);
                        }
                    }
                }
                if (property.validateOnSet) {
                    property.validate();
                }
                endOperation();
            });
        },

        coerce: function (value) {
            //	summary:
            //		Given an input value, this method is responsible
            //		for converting it to the appropriate type for storing on the object.

            var type = this.type;
            if (type) {
                if (type === 'string') {
                    value = '' + value;
                }
                else if (type === 'number') {
                    value = +value;
                }
                else if (type === 'boolean') {
                    // value && value.length check is because dijit/_FormMixin
                    // returns an array for checkboxes; an array coerces to true,
                    // but an empty array should be set as false
                    value = (value === 'false' || value === '0' || value instanceof Array && !value.length) ?
                        false : !!value;
                }
                else if (typeof type === 'function' && !(value instanceof type)) {
                    /* jshint newcap: false */
                    value = new type(value);
                }
            }
            return value;
        },

        addError: function (error) {
            //	summary:
            //		Add an error to the current list of validation errors
            //	error: String
            //		Error to add
            this.set('errors', (this.errors || []).concat([error]));
        },

        checkForErrors: function (value) {
            //	summary:
            //		This method can be implemented to simplify validation.
            //		This is called with the value, and this method can return
            //		an array of any errors that were found. It is recommended
            //		that you call this.inherited(arguments) to permit any
            //		other validators to perform validation
            //	value:
            //		This is the value to validate.
            var errors = [];
            if (this.type && !(typeof this.type === 'function' ? (value instanceof this.type) :
                    (this.type === typeof value))) {
                errors.push(value + ' is not a ' + this.type);
            }

            if (this.required && !(value != null && value !== '')) {
                errors.push('required, and it was not present');
            }
            return errors;
        },

        validate: function () {
            //	summary:
            //		This method is responsible for validating this particular
            //		property instance.
            var property = this;
            var model = this._parent;
            var validators = this.validators;
            var value = this.valueOf();
            var totalErrors = [];

            return when(whenEach(function (whenItem) {
                // iterator through any validators (if we have any)
                if (validators) {
                    for (var i = 0; i < validators.length; i++) {
                        whenItem(validators[i].checkForErrors(value, property, model), addErrors);
                    }
                }
                // check our own validation
                whenItem(property.checkForErrors(value, property, model), addErrors);
                function addErrors(errors) {
                    if (errors) {
                        // if we have an array of errors, add it to the total of all errors
                        totalErrors.push.apply(totalErrors, errors);
                    }
                }
            }), function () {
                if (totalErrors.length) {
                    // errors exist
                    property.set('errors', totalErrors);
                    return false;
                }
                // no errors, valid value, if there were errors before, remove them
                if(property.get('errors') !== undefined){
                    property.set('errors', undefined);
                }
                return true;
            });
        },
        _queueChange: function (callback, oldValue) {
            // queue up a notification callback
            if (!callback._queued) {
                // make sure we only queue up once before it is called by flagging it
                callback._queued = true;
                var reactive = this;
                // define a function for when it is called that will clear the flag
                // and provide the correct args
                var dispatch = function () {
                    callback._queued = false;
                    callback.call(reactive, reactive._get(), oldValue);
                };

                if (callbackQueue) {
                    // we already have a waiting queue of callbacks, add our callback
                    callbackQueue.push(dispatch);
                }
                if (!callbackQueue) {
                    // no waiting queue, check to see if we have a custom nextTurn
                    // or we are in an operation
                    if (!Model.nextTurn.atEnd || setCallDepth > 0) {
                        // create the queue (starting with this callback)
                        callbackQueue = [dispatch];
                        // define the callback executor for the next turn
                        Model.nextTurn(function () {
                            // pull out all the callbacks
                            for (var i = 0; i < callbackQueue.length; i++) {
                                // call each one
                                callbackQueue[i]();
                            }
                            // clear it
                            callbackQueue = null;
                        });
                    } else {
                        // no set call depth, so just immediately execute
                        dispatch();
                    }
                }
            }
        },
        toJSON: function () {
            return this._values || this;
        }
    });
    // a function that returns a function, to stop JSON serialization of an
    // object
    function toJSONHidden() {
        return toJSONHidden;
    }
    // An object that will be hidden from JSON serialization
    var Hidden = function () {};
    Hidden.prototype.toJSON = toJSONHidden;
    var Property = Model.Property = dcl(Reactive, {
        //	summary:
        //		A Property represents a time-varying property value on an object,
        //		along with meta-data. One can listen to changes in this value (through
        //		receive), as well as access and monitor metadata, like default values,
        //		validation information, required status, and any validation errors.

        //	value: any
        //		This represents the value of this property, which can be
        //		monitored for changes and validated

        init: function (options) {
            // handle simple definitions
            if (typeof options === 'string' || typeof options === 'function') {
                options = {type: options};
            }
            // and/or mixin any provided properties
            if (options) {
                utils.mixin(this, options);
            }
        },

        _get: function () {
            return this._parent._getValues()[this.name];
        },
        _has: function () {
            return this.name in this._parent._getValues();
        },
        setValue: function (value, parent) {
            parent._getValues()[this.name] = value;
        }
    });
    var simplePropertyValueOf = Property.prototype.valueOf;
    var simplePropertyPut = Property.prototype.put;
    return Model;
});
/** @module xide/data/Source **/
define('xide/data/Source',[
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/utils',
    'xide/lodash'
], function (dcl, declare, utils, lodash) {

    var _debug = true;
    /**
     * @class module:xide/data/Source
     * @augments module:xide/data/Model
     */
    var Implementation = {
        /**
         * @type {Array<module:xide/data/Reference>|null}
         */
        _references: null,
        /**
         * @type {module:xide/data/Reference|null}
         */
        _originReference: null,
        /**
         * @type {module:xide/data/_Base|null} The store.
         */
        _store: null,
        onReferenceUpdate: function () {
        },
        onReferenceRemoved: function () {
        },
        onReferenceDelete: function () {
        },
        updateReference: function () {
        },
        destroy: function () {
            this._references = null;
        },
        getReferences: function () {
            return this._references ? utils.pluck(this._references, 'item') : [];
        },
        hasReference: function (source) {
            return lodash.find(this._references, {item: source});
        },
        addReference: function (reference, settings, addSource) {
            !this._references && (this._references = []);
            if (this.hasReference(reference)) {
                _debug && console.warn('already have reference');
                return;
            }
            this._references.push({
                item: reference,
                settings: settings
            });
            if (settings && settings.onDelete) {
                if (reference._store) {
                    reference._store.on('delete', function (evt) {
                        if (evt.target == reference) {
                            this._store.removeSync(this[this._store.idProperty]);
                            this._references.remove(evt.target);
                        }
                    }.bind(this));
                }
            }
            if (addSource) {
                if (reference.addSource) {
                    reference.addSource(this, settings);
                }
            }
        },
        removeReference: function (Reference) {
            this._references && lodash.each(this._references, function (ref) {
                if (ref && ref.item == Reference) {
                    this._references && this._references.remove(ref);
                    return true;
                }
            }, this);
        },
        updateReferences: function (args) {
            var property = args.property,
                value = args.value;

            if (!this._references) {
                this._references = [];
            }
            for (var i = 0; i < this._references.length; i++) {
                var link = this._references[i],
                    item = link.item,
                    settings = link.settings,
                    store = item._store;

                if (this._originReference == item) {
                    continue;
                }
                if (args.property && settings.properties && settings.properties[args.property]) {
                    if (store) {
                        store.silent(true);
                    }
                    try {
                        if (item.onSourceChanged) {
                            item.onSourceChanged(property, value, args.type);
                        } else {
                            item.set(property, value);
                        }

                    } catch (e) {
                        _debug && console.error('error updating reference! ' + e, e);
                    }
                    if (store) {
                        store.silent(false);
                        store.emit('update', {target: item});
                    }
                }
            }
        },
        constructor: function (properties) {
            this._references = [];
            utils.mixin(this, properties);
        },
        onItemChanged: function (args) {
            this.updateReferences(args);
        }
    };
    //exports for declare & dcl
    var Module = declare('xgrid.data.Source', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    Module.Implementation = Implementation;
    return Module;
});

/** module:xaction/ActionModel **/
define('xaction/ActionModel',[
    "dcl/dcl",
    'xaction/Action',
    'xide/data/Model',
    "xide/data/Source",
    'xide/model/Path',
    'xide/utils'
], function (dcl, Action, Model, Source, Path, utils) {
    var debug = false;
    var count = 0;
    /**
     * @class module:xaction/ActionModel
     * @extends module:xide/data/Source
     * @extends module:xaction/Action
     * @extends module:xide/mixins/EventedMixin
     */
    return dcl([Action, Model, Source.dcl], {
        filterGroup: "item|view",
        keyboardMappings: null,
        bindWidgetProperties: [
            //2-way bindings for these props:
            'value',
            'icon',
            'disabled'
        ],
        items: null,
        onRemove: function () {
            _.invoke(this.getReferences(), 'destroy');
            this.keyboardMappings && _.invoke(this.keyboardMappings, "destroy");
            this.destroy();
        },
        shouldShow: function () {
            return true;
        },
        shouldDisable: function () {
            return false;
        },
        updateReference: function (selection, reference, visibility) {
            reference.set('disabled', this.shouldDisable(selection, reference, visibility));
            if (this.icon !== null && reference.icon !== null && this.icon !== reference.icon) {
                reference.set('icon', this.icon);
            }
            if (this.value !== null && reference.value !== null && this.value !== reference.value) {
                reference.set('value', this.value);
            }
        },
        refreshReferences: function (property, value) {
            _.each(this.getReferences(), function (ref) {
                ref.set(property, value);
            }, this);
        },
        refresh: function (selection) {
            this._emit('refresh', {
                action: this,
                selection: selection
            });
            _.each(this.getReferences(), function (ref) {
                this.updateReference(selection, ref, ref.visibility);
            }, this);
        },
        setProperty: function (key, value, updateReferences) {
            return this.set(key, value);
        },
        complete: function () {
            this.items = this.getChildren();
        },
        getParent: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return this._store.getSync(segments.slice(0, segments.length - 1).join('/'));
            }
        },
        getParentCommand: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return segments.slice(0, segments.length - 1).join('/');
            }
        },
        getSegments: function (command) {
            return command.split('/');
        },
        getRoot: function () {
            return this.command.split('/')[0];
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(utils.pluck(items, 'command'), false);
        },
        getChildren: function () {
            var children = this.getItemsAtBranch(this._store.getAll(), this.command),
                self = this;

            //return an action from both stores
            function getAction(command) {
                return self._store.getSync(command);
            }

            //command strings to actions
            function toActions(paths) {
                var result = [];
                _.each(paths, function (path) {
                    result.push(getAction(path));
                });
                return result;
            }

            /*
            return lodash.map(this.getItemsAtBranch(this._store.getAll(), this.command),function(paths){
                return lodash.map(paths,function(path){
                    this._store.getSync(path);
                },this)
            },this)
            */
            return toActions(children);
        },
        /**
         * @TODO: remove back compat
         * @param evt {object}
         * @param evt.parent {widget}
         * @param evt.widget {widget}
         * @param evt.visibility {string}
         * @private
         */
        _onWidgetCreated: function (evt) {
            if (evt.widget.addSource) {
                this.addReference(evt.widget, {
                    properties: {
                        "value": true
                    }
                }, true);
            } else {
                debug && console.warn('widget is not a reference! ', evt);
            }
        }
    });
});
/** @module xaction/ActionStore **/
define('xaction/ActionStore',[
    "xdojo/declare",
    'xide/data/TreeMemory',
    'xide/utils',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xaction/ActionModel'
], function (declare, TreeMemory, utils, ObservableStore, Trackable, ActionModel) {
    /**
     * Default properties to be observed (in ObservableStore)
     * @type {string[]}
     */
    var DEFAULT_ACTION_PROPERTIES = [
        "value",
        "icon",
        "disabled",
        "enabled"
    ];

    /**
     * Default factory
     * @param composer
     * @param bases
     * @param Model
     * @param defaults
     * @param mixin
     * @returns {*}
     */
    function createClass(composer, bases, Model, defaults, mixin) {
        /**
         * @class module:xaction/ActionStore
         */
        return (composer || declare)(bases || [TreeMemory, Trackable, ObservableStore], utils.mixin({
            idProperty: 'command',
            declaredClass: "xaction/ActionStore",
            Model: Model || ActionModel,
            renderers: null,
            observedProperties: defaults || DEFAULT_ACTION_PROPERTIES,
            getAll: function () {
                return this.data;
            },
            addRenderer: function (renderer) {
                !this.renderers && (this.renderers = []);
                !_.contains(this.renderers, renderer) && this.renderers.push(renderer);
            }
        }, mixin));
    }

    var Module = createClass(null, null, null, null, null);
    Module.createDefault = function (args) {
        return new Module(args);
    };
    Module.createClass = createClass;
    Module.DEFAULT_ACTION_PROPERTIES = DEFAULT_ACTION_PROPERTIES;
    return Module;
});

/** @module xide/Keyboard **/
define('xide/Keyboard',[
    'xdojo/declare',
    'dcl/dcl',
    'dojo/_base/lang',
    'xide/types',
    'xide/utils/ObjectUtils'    //possibly not loaded yet
], function (declare, dcl, lang, types, utils) {

    /**
     * First things first, mixin KEYBOARD_FLAGS into core types.
     */
    utils.mixin(types, {
        /**
         * KEYBOARD_EVENT describes all possible events a subscriber can listen to.
         *
         * @enum module:xide/types/KEYBOARD_EVENT
         * @memberOf module:xide/types
         */
        KEYBOARD_EVENT: {
            /**
             * Add a custom callback for a key-up event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            UP: 'on_keyup',
            /**
             * Add a custom callback for a key-dow event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            DOWN: 'on_keydown',
            /**
             * Add a custom callback for a release event. This is similar to keyup, but will fire once
             * when ALL of the keys of a combo have been released. If you're unsure, you probably want to
             * ignore this and use UP.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            RELEASE: 'on_release'
        }
    });

    /**
     * Define a public struct for a 'keyboard - mapping
     */
    utils.mixin(types, {

        /**
         * KEYBOARD_MAPPING
         *
         * Keys accepted in human readable format as 'shift s', see the full map:
         *
         _modifier_event_mapping =
         "cmd"   : "metaKey"
         "ctrl"  : "ctrlKey"
         "shift" : "shiftKey"
         "alt"   : "altKey"

         _keycode_alternate_names =
         "escape"        : "esc"
         "control"       : "ctrl"
         "command"       : "cmd"
         "break"         : "pause"
         "windows"       : "cmd"
         "option"        : "alt"
         "caps_lock"     : "caps"
         "apostrophe"    : "\'"
         "semicolon"     : ";"
         "tilde"         : "~"
         "accent"        : "`"
         "scroll_lock"   : "scroll"
         "num_lock"      : "num"

         _keycode_shifted_keys =
         "/"     : "?"
         "."     : ">"
         ","     : "<"
         "\'"    : "\""
         ";"     : ":"
         "["     : "{"
     "]"     : "}"
         "\\"    : "|"
         "`"     : "~"
         "="     : "+"
         "-"     : "_"
         "1"     : "!"
         "2"     : "@"
         "3"     : "#"
         "4"     : "$"
         "5"     : "%"
         "6"     : "^"
         "7"     : "&"
         "8"     : "*"
         "9"     : "("
         "0"     : ")"

         _keycode_dictionary =
         0   : "\\"          # Firefox reports this keyCode when shift is held
         8   : "backspace"
         9   : "tab"
         12  : "num"
         13  : "enter"
         16  : "shift"
         17  : "ctrl"
         18  : "alt"
         19  : "pause"
         20  : "caps"
         27  : "esc"
         32  : "space"
         33  : "pageup"
         34  : "pagedown"
         35  : "end"
         36  : "home"
         37  : "left"
         38  : "up"
         39  : "right"
         40  : "down"
         44  : "print"
         45  : "insert"
         46  : "delete"
         48  : "0"
         49  : "1"
         50  : "2"
         51  : "3"
         52  : "4"
         53  : "5"
         54  : "6"
         55  : "7"
         56  : "8"
         57  : "9"
         65  : "a"
         66  : "b"
         67  : "c"
         68  : "d"
         69  : "e"
         70  : "f"
         71  : "g"
         72  : "h"
         73  : "i"
         74  : "j"
         75  : "k"
         76  : "l"
         77  : "m"
         78  : "n"
         79  : "o"
         80  : "p"
         81  : "q"
         82  : "r"
         83  : "s"
         84  : "t"
         85  : "u"
         86  : "v"
         87  : "w"
         88  : "x"
         89  : "y"
         90  : "z"
         91  : "cmd"
         92  : "cmd"
         93  : "cmd"
         96  : "num_0"
         97  : "num_1"
         98  : "num_2"
         99  : "num_3"
         100 : "num_4"
         101 : "num_5"
         102 : "num_6"
         103 : "num_7"
         104 : "num_8"
         105 : "num_9"
         106 : "num_multiply"
         107 : "num_add"
         108 : "num_enter"
         109 : "num_subtract"
         110 : "num_decimal"
         111 : "num_divide"
         112 : "f1"
         113 : "f2"
         114 : "f3"
         115 : "f4"
         116 : "f5"
         117 : "f6"
         118 : "f7"
         119 : "f8"
         120 : "f9"
         121 : "f10"
         122 : "f11"
         123 : "f12"
         124 : "print"
         144 : "num"
         145 : "scroll"
         186 : ";"
         187 : "="
         188 : ","
         189 : "-"
         190 : "."
         191 : "/"
         192 : "`"
         219 : "["
         220 : "\\"
         221 : "]"
         222 : "\'"
         223 : "`"
         224 : "cmd"
         225 : "alt"
         # Opera weirdness
         57392   : "ctrl"
         63289   : "num"
         # Firefox weirdness
         59 : ";"
         61 : "-"
         173 : "="

         *
         * @class module:xide/types/KEYBOARD_MAPPING
         * @memberOf module:xide/types
         */

        /**
         * KEYBOARD_MAPPING is defines keyboard mapping struct:
         *
         * @memberOf module:xide/types
         * @class module:xide/types/KEYBOARD_EVENT
         *
         */
        KEYBOARD_MAPPING: {
            /**
             * @param keys {string|string[]} the key sequence (see below for the right codes ).
             * This option can be either an array of strings, or a single space separated string of key names that describe
             * the keys that make up the combo.
             */
            keys: null,
            /**
             * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
             * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
             * in the params
             */
            handler: null,
            /**
             * @param scope {Object|null} the scope in which the handler(s) are excecuted.
             */
            scope: null,
            /**
             * @param target {HTMLElement|null} the element on the listerner is bound to. Null means global!
             */
            target: null,
            /**
             * @param type {string|null} the keypress combo type, can be:
             * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
             * counting_combo(keys, on_count_callback); // Registers a counting combo
             * sequence_combo(keys, callback); // Registers a sequence combo
             * register_combo(combo_dictionary); // Registers a combo from a dictionary
             */
            type: null,
            /**
             * @param mixin to override the 'keypress' libraries internal setup for a listener
             * @default {

                prevent_repeat: false,
                prevent_default: false,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: false
            */
            params: null,
            /**
             *
             * @param mouse {Object|null|true|false} filter to setup an addtional trigger constraint for keyboard
             * sequence. Example: mouse.before='mousedown' and keys ='ctrl' will fire the handler when the mouse is hold whilst
             * ctrl key is hold. default:null.
             *
             */
            mouse: {
                brefore: null,//true
                after: null//false
            },
            eventArgs: null
        }

    });

    /**
     * Global array of keypress listeners
     * @type {Object[]}
     * @private
     */
    var listeners = [];
    var byNode = {};

    /**
     * Util to extend a keyboard mapping with control functions per listener. Keyboard mappings can
     * have multiple key sequences and this will take care about stop(), listen() and destroy().
     * @param mapping
     * @param listeners
     */
    var addListenerControls = function (mapping, listeners) {
        mapping.stop = function () {
            return;
            //if(listeners && listeners.length) {
            //    _.invoke(listeners, 'stop_listening');
            //}
        };
        mapping.listen = function () {
            _.invoke(listeners, 'listen');
        };
        mapping.destroy = function () {
            mapping.stop();
            _.each(listeners, function (listener) {
                listener.destroy();
                listeners.remove(listener);
                delete byNode[listener.targetId];
            });
        };
        return mapping;
    };

    /**
     * Safe link to keypress prototype
     * @type {Listener|keypress.Listener}
     * @private
     */
    var keypressProto = window ? window['keypress'] ? window.keypress.Listener : null : null;
    if (!keypressProto) {
        console.error('you need keypress.min.js installed to use xide/Keyboard');
    }

    var Implementation = {
        /**
         * @member listener {Object[]} all keypress listener instances
         */
        _keyboardListeners: null,
        /**
         * The default setup for a listener, this is 'keypress' specific.
         *
         * @returns {{prevent_repeat: boolean, prevent_default: boolean, is_unordered: boolean, is_counting: boolean, is_exclusive: boolean, is_solitary: boolean, is_sequence: boolean}}
         */
        keyPressDefault: function () {
            return {
                prevent_repeat: false,
                prevent_default: true,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: true
            };
        },
        /**
         * Private listener creation method, accepts multiple key sequences for the same handler.
         *
         * @param keys {string|string[]} the key sequence (see below for the right codes ).
         * This option can be either an array of strings, or a single space separated string of key names that describe
         * the keys that make up the combo.
         *
         * @param params {Object|null} an additional parameter structure to override the default 'keypress' setup.
         * See this.keyPressDefault
         *
         * @param scope {Object|null} the scope in which the handler(s) are excecuted, defaults to 'this' as we are
         * a mixin.
         *
         *
         * @param type {string|null} the keypress combo type, can be:
         * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
         * counting_combo(keys, on_count_callback); // Registers a counting combo
         * sequence_combo(keys, callback); // Registers a sequence combo
         * register_combo(combo_dictionary); // Registers a combo from a dictionary
         *
         * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
         * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
         * in the params

         * @param target {HTMLElement|null} the element on the listener is bound to. Null means global!
         *
         * @param eventArgs {array|null} Event arguments passed to the handler. Defaults to keyboard event.
         *
         * @public
         */
        addKeyboardListerner: function (keys, params, type, scope, handler, target, eventArgs) {
            // prepare keypress args
            var _defaults = lang.clone(this.keyPressDefault());
            //mixin override
            utils.mixin(_defaults, params);

            // defaults
            _defaults['this'] = _defaults['this'] || scope || this;

            // use simple_combo as default
            type = type || 'simple_combo';

            //normalize to array
            keys = !_.isArray(keys) ? [keys] : keys;

            var _listeners = [],
                ignore = ['ctrl s', 'ctrl l', 'ctrl r', 'ctrl w', 'ctrl f4', 'shift f4', 'alt tab', 'ctrl tab'];

            _.each(keys, function (key_seq) {
                var targetId = target && target.id ? target.id : 'global',
                    wasCached = target ? !!byNode[targetId] : false,
                    registered = false;

                var listener = byNode[targetId];
                if(listener && listener["_seq"+key_seq]){
                    registered = true;
                }

                if(!registered) {
                    if (!listener) {
                        listener = new keypressProto(target, _defaults);
                        listener.targetId = targetId;
                    }

                    listener["_seq" + key_seq] = true;
                    listener[type](key_seq, function (e) {
                        if (e._did) {
                            return;
                        }
                        e._did = true;
                        var className = e.target.className.toLowerCase();
                        //skip input fields
                        if (e.target.tagName!=='BUTTON' && className.indexOf('input') == -1 || className.indexOf('ace_text-input') != -1) {
                            if (handler && handler.apply) {
                                handler.apply(_defaults['this'], eventArgs || [e]);
                                if (ignore.indexOf(key_seq) !== -1) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        }
                    });
                    if (byNode[targetId]) {

                    } else {
                        byNode[targetId] = listener;
                    }

                    if (!wasCached) {
                        !this._keyboardListeners && (this._keyboardListeners = []);
                        //store in local
                        this._keyboardListeners.push(listener);
                        //store in global
                        _listeners.push(listener);
                    }
                }

            }, this);

            return _listeners;
        },
        /**
         * Public interface to register a keyboard mapping
         * @param mapping {xide/types/KEYBOARD_MAPPING}
         * @returns {xide/types/KEYBOARD_MAPPING}
         */
        registerKeyboardMapping: function (mapping) {
            var listeners = this.addKeyboardListerner(mapping.keys, mapping.params, null, mapping.scope, mapping.handler, mapping.target, mapping.eventArgs);
            mapping.listeners = listeners;
            return addListenerControls(mapping, listeners);
        },
        destroy:function(){
            this.inherited && this.inherited(arguments);
            var targetId = this.id;
            var listener = byNode[targetId];
            if(listener){
                listener.destroy();
                delete byNode[targetId];
            }
        }
    };

    /**
     * Generic keyboard handler, using the external 'keypress' Javascript library
     * which handles keyboard events a bit more elegant and robust, it does allow
     * registration of keyboard - sequences as 'shift s':
     * @example
     *
     * listener.simple_combo("shift s", function() {
     *  console.log("You pressed shift and s");
     * });
     *
     * @link http://dmauro.github.io/Keypress/
     * @link https://github.com/dmauro/Keypress/blob/master/keypress.coffee#L728-864
     */
    var _Keyboard = declare("xide/Keyboard", null, Implementation);
    /**
     * Static mapping factory
     * @param keys
     * @param params
     * @param type
     * @param scope
     * @param handler
     * @param target
     * @param eventArgs
     * @memberOf module:xide/Keyboard
     * @returns {xide/types/KEYBOARD_MAPPING}
     */
    _Keyboard.createMapping = function (keys, params, type, scope, handler, target, eventArgs) {
        var mapping = utils.clone(types.KEYBOARD_MAPPING);//@TODO: bad copy, uses a ctr followed by a lang.mixin
        function getHandler(__handler) {
            return _.isString(__handler) ? lang.hitch(scope, __handler) : __handler;
        }

        mapping.keys = keys;
        mapping.params = params || {};
        mapping.type = type;
        mapping.scope = scope;
        mapping.handler = getHandler(handler);
        mapping.target = target;
        mapping.eventArgs = eventArgs;
        mapping.setHandler = function (event, handler) {
            mapping.params[event] = getHandler(handler);
            return mapping;
        };
        return mapping;

    };

    _Keyboard.defaultMapping = function (keys, handler, params, node, who, args) {
        return _Keyboard.createMapping(keys, params, null, who, handler, node, args);
    };

    _Keyboard.dcl = dcl(null, Implementation);
    _Keyboard.byNode = byNode;
    _Keyboard.listeners = listeners;
    return _Keyboard;
});
/** @module xaction/DefaultActions **/
define('xaction/DefaultActions',[
    "dcl/dcl",
    'dcl/inherited',
    "xdojo/declare",
    'xide/types',
    'xide/utils',
    'xlang/i18'
], function (dcl,inherited,declare,types,utils,i18) {
    /**
     * @mixin module:xide/action/DefaultActions
     */
    var Module = declare("xaction/DefaultActions", null , {});
    /**
     *
     * @param title
     * @param command
     * @param group
     * @param icon
     * @param handler
     * @param accelKey
     * @param keyCombo
     * @param keyProfile
     * @param keyTarget
     * @param keyScope
     * @param mixin
     * @returns {{title: *, command: *, group: *, icon: *, handler: *, accelKey: *, keyCombo: *, keyProfile: *, keyTarget: *, keyScope: *}}
     */
    Module.createActionParameters=function(title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope,mixin){
        return {
            title:title,
            command: command,
            group: group,
            icon: icon,
            handler: handler,
            accelKey: accelKey,
            keyCombo: keyCombo,
            keyProfile: keyProfile,
            keyTarget: keyTarget,
            keyScope: keyScope,
            mixin:mixin
        };
    };
    /**
     *
     * @param label
     * @param command
     * @param icon
     * @param keycombo
     * @param tab
     * @param group
     * @param filterGroup
     * @param onCreate
     * @param handler
     * @param mixin
     * @param shouldShow
     * @param shouldDisable
     * @param container
     * @returns {*}
     */
    var createAction = function(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,container){
        if(keycombo) {
            if (_.isString(keycombo)) {
                keycombo = [keycombo];
            }
        }

        mixin = utils.mixin({
            filterGroup:filterGroup || "item|view",
            tab:tab||'File',
            onCreate: onCreate || function (action){},
            shouldShow:shouldShow||function(){return true;},
            shouldDisable:shouldDisable||function(){return false;}
        },mixin);

        var _action = Module.createActionParameters(
            label,
            command,
            group || 'File',//Group
            icon, handler || null, "", keycombo, null, container, null, mixin);

        utils.mixin(_action,mixin);

        return _action;
    };

    /**
     * Find action in permission
     * @param what
     * @returns {boolean}
     */
    function hasAction(permissions,what){
        return _.contains(permissions,what);
    }

    /**
     * After action default handler, trys:
     * - this::onAfterAction
     * - emit onAfterAction
     *
     * @param dfdResult
     * @param event
     * @param action
     * @private
     */
    function _afterAction(dfdResult,event,action) {
        var who = this;
        // call onAfterAction with this results
        var onAfterActionDfd = null;
        who.onAfterAction && (onAfterActionDfd = who.onAfterAction(action, dfdResult, event));

        who._emit && who._emit('onAfterAction', {
            action: action,
            result: dfdResult,
            source: who,
            afterAction: onAfterActionDfd
        });
    }
    /**
     * Default handler, does
     * - try this::runAction || action#handler
     * - call afterAction
     *
     * As last cal
     * @param action {module:xaction/ActionModel}
     * @param event
     */
    function defaultHandler(action,event){
        var actionDfd,
            who = this;

        who && who.onBeforeAction && who.onBeforeAction(action);
        if(who.runAction){
            actionDfd = who.runAction.apply(who,[action,null,event]);
        }else if(action.handler){
            actionDfd = action.handler.apply(who,[action,null,event]);
        }
        if(actionDfd && actionDfd.then){
            actionDfd.then(function(actionResult){
                _afterAction.apply(who,[actionResult,event,action]);
            });

        }else{
            _afterAction.apply(who,[actionDfd,event,action]);
        }
        return actionDfd;
    }

    /**
     *
     * @param permissions
     * @param grid
     * @param owner
     * @returns {Array}
     */
    function getDefaultActions(permissions,grid,owner){
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultEmptySelection(selection,reference,visibility){
            selection = selection || grid ? grid.getSelection() : [];

            if(!selection || !selection.length){
                return true;
            }
            return false;
        }
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultFileOnly(selection,reference,visibility){

            if(shouldDisableDefaultEmptySelection.apply(this,arguments)){
                return true;
            }
            selection = selection || grid ? grid.getSelection() : [];

            if(selection && selection[0].isDir === true){
                return true;
            }
            return false;
        }

        var root = 'File/',
            thiz = this,
            renderActions = [],
            VISIBILITY = types.ACTION_VISIBILITY,
            result = [],
            ACTION = types.ACTION,
            ACTION_ICON = types.ACTION_ICON,
            creator = owner || grid;

        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         */
        function addAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable){
            var action = null;
            mixin = mixin || {};
            utils.mixin(mixin,{owner:owner || grid});

            if(mixin.addPermission || hasAction(permissions,command)){

                handler = handler || defaultHandler;

                action = createAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,grid.domNode);

                if(action) {
                    if (owner && owner.addAction) {
                        owner.addAction(null, action);
                    }
                    result.push(action);
                }
            }
        }
        if(hasAction(permissions, ACTION.CLIPBOARD) && grid.getClipboardActions){
            result.push(creator.createAction({
                label: 'Clipboard',
                command: 'Edit/Clipboard',
                icon: 'fa-clipboard',
                tab: 'Edit',
                group: 'Clipboard',
                mixin:{
                    addPermission:true,
                    dynamic:true,
                    quick:true
                },
                onCreate:function(action){
                    action.setVisibility(VISIBILITY.RIBBON,{
                        expand:true,
                        tab:"File"
                    });
                }
            }));

            result = result.concat(grid.getClipboardActions(addAction));
        }

        result.push(creator.createAction({
            label: 'Show',
            command: 'View/Show',
            icon: 'fa-eye',
            tab: 'View',
            group: 'Show',
            mixin:{
                addPermission:true,
                dynamic:true
            },
            onCreate:function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }
        }));


        if(hasAction(permissions,ACTION.LAYOUT) && grid.getRendererActions){
            result = result.concat(grid.getRendererActions());
        }

        if(hasAction(permissions,ACTION.COLUMNS) && grid.getColumnHiderActions){
            result = result.concat(grid.getColumnHiderActions(permissions));
        }
        ///////////////////////////////////////
        //
        //  Open/Edit
        //
        //
        result.push(creator.createAction({
            label: 'Edit',
            command: 'File/Edit',
            icon: ACTION_ICON.EDIT,
            tab: 'Home',
            group: 'Open',
            keycombo: ['f4', 'enter','dblclick'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultFileOnly
        }));


        ///////////////////////////////////////
        //
        //  Organize
        //
        result.push(creator.createAction({
            label: 'Delete',
            command: 'File/Delete',
            icon: ACTION_ICON.DELETE,
            tab: 'Home',
            group: 'Organize',
            keycombo: ['f8','delete'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultEmptySelection
        }));

        addAction('Rename','File/Rename','fa-edit',['f2'],'Home','Organize','item',null,null,null,null,shouldDisableDefaultEmptySelection);

        result.push(creator.createAction({
            label: 'Reload',
            command: 'File/Reload',
            icon: ACTION_ICON.RELOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl l'],
            mixin:{
                quick:true
            }
        }));
        addAction('Create archive','File/Compress',ACTION_ICON.COMPRESS,['ctrl z'],'Home','Organize','item|view',null,null,null,null,shouldDisableDefaultEmptySelection);

        ///////////////////////////////////////
        //
        //  File
        //
        addAction('Extract','File/Extract',ACTION_ICON.EXTRACT,['ctrl e'],'Home','File','item|view',null,null,null,null,function(){
            return true;
            //return shouldDisableDefaultFileOnly.apply(this,arguments);
        });

        result.push(creator.createAction({
            label: 'Download',
            command: 'File/Download',
            icon: ACTION_ICON.DOWNLOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl down'],
            mixin:{
                quick:true
            }
        }));

        //////////////////////////////////////////
        //
        //  New
        //
        if(hasAction(permissions,ACTION.NEW_DIRECTORY)|| hasAction(permissions,ACTION.NEW_FILE)) {

            addAction('New','File/New','fa-magic',null,'Home','New','item|view',null,null,{},null,null);
/*
            result.push(creator.createAction({
                label: 'New',
                command: 'File/New',
                icon: 'fa-magic',
                tab: 'Home',
                group: 'File',
                keycombo: ['ctrl down'],
                mixin:{
                    quick:true
                }
            }));*/

        }
        addAction('New Folder',ACTION.NEW_DIRECTORY,'fa-folder',['f7'],'Home','New','item|view',null,null,{quick:true},null,null);
        addAction('New File',ACTION.NEW_FILE,'el-icon-file',['ctrl f4'],'Home','New','item|view',null,null,{quick:true},null,null);


        //////////////////////////////////////////
        //
        //  Preview
        //
        if(hasAction(permissions,ACTION.PREVIEW)) {
            result.push(creator.createAction({
                label: 'Preview',
                command: 'File/Preview',
                icon: 'fa-eye',
                tab: 'Home',
                group: 'Open',
                keycombo: ['f3'],
                mixin:{
                    quick:true
                },
                shouldDisable:shouldDisableDefaultFileOnly
            }));
        }

        ///////////////////////////////////////
        //
        //  Selection
        //
        if(hasAction(permissions,ACTION.SELECTION)) {
            result.push(createAction('Select', 'File/Select', 'fa-hand-o-up', null, 'Home', 'Select', 'item|view', function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }, null, null, null, null,grid.domNode));

            var _mixin = {
                    owner:owner || grid
                },
                container = grid.domNode;

            result.push(createAction('Select all', 'File/Select/All', 'fa-th', ['ctrl a'], 'Home', 'Select', 'item|view', null, function(){
                grid.selectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Select none', 'File/Select/None', 'fa-square-o', 'ctrl d', 'Home', 'Select', 'item|view', null, function(){
                grid.deselectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Invert selection', 'File/Select/Invert', 'fa-square', ['ctrl i'], 'Home', 'Select', 'item|view', null, function(){
                grid.invertSelection();
            }, _mixin, null, null,container));
        }
        return result;
    }

    Module.createAction = createAction;
    Module.hasAction = hasAction;
    Module.getDefaultActions = getDefaultActions;
    Module.defaultHandler = defaultHandler;

    return Module;
});
define('xaction/ActionProvider',[
    "xdojo/declare",
    'dcl/dcl',
    "xide/types",
    "xide/utils",
    "xide/model/Path",
    'xaction/ActionStore',
    'xaction/Action',
    'xide/Keyboard',
    'xide/mixins/EventedMixin',
    'xaction/DefaultActions',
    'xide/lodash'
], function (declare, dcl, types, utils, Path, ActionStore, Action, Keyboard, EventedMixin, DefaultActions,_) {

    var Implementation = {
        /**
         * @type module:xaction/ActionStore
         */
        actionStore: null,
        actions: null,
        allowActionOverride: true,
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (groupMap[a] != null && groupMap[b] != null) {
                    var orderA = groupMap[a];
                    var orderB = groupMap[b];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(_.map(items, 'command'), false);
        },
        /////////////////////////////////////////////////////
        //
        //  Store Based Extension -
        //
        /////////////////////////////////////////////////////
        /**
         * Update all actions referencing widgets
         */
        refreshActions: function () {
            var allActions = this.getActions();
            for (var i = 0; i < allActions.length; i++) {
                var action = allActions[i];
                if (action.refresh) {
                    action.refresh();
                }
            }
        },
        getAction: function (mixed) {
            if (_.isString(mixed)) {
                return this.getActionStore().getSync(mixed);
            }
            return mixed;
        },
        clearActions: function () {
            var store = this.getActionStore(),
                actions = store ? store.query() : [];

            _.each(actions, function (action) {
                action && store.removeSync(action.command);
            });
            store && store.setData([]);
        },
        destroy: function () {
            this.clearActions();
            return this.inherited(arguments);
        },
        /**
         *
         * @param title
         * @param command
         * @param group
         * @param icon
         * @param handler
         * @param accelKey
         * @param keyCombo
         * @param keyProfile
         * @param keyTarget
         * @param keyScope
         * @param mixin
         * @returns {xaction/Action}
         */
        __createAction: function (title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope, mixin) {
            icon = icon || types.ACTION_ICON[command];
            var args = {accelKey: accelKey};
            utils.mixin(args, mixin);
            var action = Action.createDefault(title, icon, command, group, handler, args);
            if (keyCombo) {
                var keyboardMappings;
                if (this.keyboardMappings) {
                    keyboardMappings = this.keyboardMappings;
                } else {
                    action.keyboardMappings = keyboardMappings = [];
                }
                var mapping = Keyboard.defaultMapping(keyCombo, handler, keyProfile || types.KEYBOARD_PROFILE.DEFAULT, keyTarget, keyScope, [action]);
                mapping = this.registerKeyboardMapping(mapping);
                keyboardMappings.push(mapping);
                action.keyboardMappings = keyboardMappings;
            }
            return action;
        },
        updateAction: function (action, what, value) {
            action = action || this.getAction(action);
            if (action) {
                action.set(what, value);
                setTimeout(function () {
                    action.getReferences().forEach(function (ref) {
                        ref.set(what, value);
                    });
                }, 100);
            }
        },
        _completeActions: function (actions) {
            var result = [];
            var keyTarget = this.getKeyTarget ? this.getKeyTarget() : null;
            for (var i = 0; i < actions.length; i++) {
                var config = actions[i],
                    action;

                if (!config) {
                    continue;
                }

                if (!(config instanceof Action)) {
                    action = this.__createAction(
                        config.title,
                        config.command,
                        config.group,
                        config.icon,
                        config.handler,
                        config.accelKey,
                        config.keyCombo,
                        config.keyProfile,
                        keyTarget || config.keyTarget,
                        config.keyScope,
                        config.mixin);

                    action.parameters = config;
                } else {
                    action = config;
                }
                this._addAction(result, action);
            }
            if (this.keyboardMappings) {
                console.error('have mappings');
            }
            _.each(this.keyboardMappings, function (mapping) {
                this.registerKeyboardMapping(mapping);
            }, this);
            return result;
        },
        createActionStore: function () {
            if (!this.actionStore) {
                var _actions = this._completeActions(this.actions || []);
                this.actionStore = new ActionStore({
                    id: utils.createUUID(),
                    data: _actions,
                    observedProperties: [
                        "value",
                        "icon",
                        "label"
                    ],
                    tabOrder: this.tabOrder,
                    groupOrder: this.groupOrder,
                    tabSettings: this.tabSettings,
                    menuOrder: this.menuOrder
                });
            }
            return this.actionStore;
        },
        /**
         * Get all actions via query from Action store
         * @param mixed
         * @param allowCache
         * @returns {*}
         */
        getActions: function (mixed, allowCache) {
            if (!mixed && allowCache !== false && this.__actions) {
                return this.__actions;
            }
            var query = mixed;
            //no query or function given
            if (!mixed) {
                query = {
                    command: /\S+/
                };
            }
            this.__actions = this.getActionStore().query(query);
            return this.__actions;

        },
        /**
         * Safe getter for action store
         * @returns {*}
         */
        getActionStore: function () {
            return this.createActionStore();
        },
        /**
         * Create action store upon construction
         */
        postMixInProperties: function () {
            this.inherited && this.inherited(arguments);
            this.createActionStore();
        },
        addActions: function (actions) {
            var store = this.getActionStore();
            if (!store['subscribedToUpdates_' + this.id]) {
                store['subscribedToUpdates_' + this.id] = true;
                this.addHandle('update', store.on('update', function (evt) {
                    var action = evt.target;
                    if (action._isCreating || !evt.property) {
                        return;
                    }
                    if (action && action.onChange) {
                        action.onChange(evt.property, evt.value, action);
                    }

                }));
            }
            var result = [];
            this._emit('onAddActions', {
                actions: actions,
                permissions: this.permissions,
                store: store
            });

            //remove existing
            this.allowActionOverride && _.each(actions, function (action) {
                if (action) {
                    var existing = store.getSync(action.command);
                    if (existing) {
                        store.removeSync(existing.command);
                    }
                }
            });
            actions = this._completeActions(actions);

            _.each(actions, function (action) {
                if (this.allowActionOverride && store.getSync(action.command)) {
                    store.removeSync(action.command);
                }
                var _action = store.putSync(action);
                result.push(_action);
                _action._isCreating = true;
                _action.onCreate && _action.onCreate(_action);
                this._emit('onAddAction', _action);
                _action._isCreating = false;
            }.bind(this));
            return result;

        },
        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param props
         * @param mixin
         * @returns {*}
         */
        createActionShort: function (label, command, icon, props, mixin) {
            return this.createAction(_.extend({
                label: label,
                command: command,
                icon: icon,
                mixin: props && props.mixin ? props.mixin : mixin
            }, props));
        },
        /**
         *
         * @param options
         * @returns {*}
         */
        createAction2: function (options) {
            var thiz = this,
                action = null,
                mixin = options.mixin || {},
                owner = options.owner || mixin.owner || thiz,
                permissions = options.permissions || this.permissions || [],
                command = options.command,
                keycombo = options.keycombo,
                label = options.label,
                icon = options.icon,
                tab = options.tab,
                group = options.group,
                filterGroup = options.filterGroup,
                onCreate = options.onCreate,
                handler = options.handler,
                container = options.container || thiz.domNode,
                shouldShow = options.shouldShow,
                shouldDisable = options.shouldDisable;

            utils.mixin(mixin, {
                owner: owner,
                onChange: options.onChange

            });

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {

                handler = handler || DefaultActions.defaultHandler;
                if (keycombo) {
                    if (_.isString(keycombo)) {
                        keycombo = [keycombo];
                    }
                    mixin.tooltip = keycombo.join('<br/>').toUpperCase();
                }

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);
                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        /**
         * Create Action
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         * @param permissions
         * @param container
         * @param owner
         * @returns {*}
         */
        createAction: function (label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, permissions, container, owner) {
            if (arguments.length == 1) {
                return this.createAction2(arguments[0]);
            }
            var thiz = this,
                action = null;

            mixin = mixin || {};
            utils.mixin(mixin, {owner: owner || thiz});

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {
                if (!handler) {
                    handler = function (action) {
                        this.runAction && this.runAction.apply(this, [action]);
                    };
                }
                keycombo && _.isString(keycombo) && (keycombo = [keycombo]);

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);

                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        addAction: function (where, action) {
            var actions = where || [];
            var eventCallbackResult = this._emit('addAction', action);
            if (eventCallbackResult === false) {
                return false;
            } else if (_.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        _addAction: function (where, action) {
            var actions = where || [],
                eventCallbackResult = this._emit('addAction', action);

            if (eventCallbackResult === false) {
                return false;
            } else if (utils.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        hasAction: function (action) {
            return DefaultActions.hasAction(this.permissions, action);
        }
    };

    /**
     * Provides tools to deal with 'actions' (xaction/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/EventedMixin) in a subclass.
     *
     * @class module:xide/mixins/ActionProvider
     * @extends module:xide/mixins/EventedMixin
     */
    var Module = declare("xaction/ActionProvider", [EventedMixin, Keyboard], Implementation);
    Module.dcl = dcl([EventedMixin.dcl, Keyboard.dcl], Implementation);
    return Module;
});

define('xide/console',[], function () {
    return typeof window !=='undefined' ? window.console : typeof global !=='undefined' ? global.console : {

    }
});
/** module xgrid/actions **/
define('xgrid/Actions',[
    "xdojo/declare",
    'xide/types',
    'xaction/ActionProvider',
    'xaction/DefaultActions',
    'xide/lodash',
    'xide/$',
    'xide/console'
], function (declare, types, ActionProvider, DefaultActions, _, $, console) {
    var _debug = false;
    /**
     * @class module:xgrid/Actions
     * @lends module:xide/mixins/EventedMixin
     *
     * All about actions:
     * 1. implements std before and after actions:
     * 1.1 on onAfterAction its restoring focus and selection automatically
     * 2. handles and forwards click, contextmenu and onAddActions     *
     */
    var Implementation = {
        _ActionContextState: null,
        onActivateActionContext: function (context, e) {
            return;
            /*
            var state = this._ActionContextState;
            if (this._isRestoring) {
                return;
            }
            this._isRestoring = true;
            if (e != null && e.selection && state) {
                state.selection = e != null ? e.selection : state.selection;
            }
            var self = this;
            _debug && console.log('onActivateActionContext', e);
            //@TODO Fixme

                var dfd = self._restoreSelection(state, 0, false, 'onActivateActionContext');
                if (dfd && dfd.then) {
                    dfd.then(function (e) {
                        self._isRestoring = false;
                    });
                } else {
                    self._isRestoring = false;
                }

                */
        },
        onDeactivateActionContext: function (context, event) {
            //_debug && console.log('onDeactivateActionContext ' + this.id, event);
            //this._ActionContextState = this._preserveSelection();
        },
        /**
         * Callback when action is performed:before (xide/widgets/_MenuMixin)
         * @param action {module:xaction/Action}
         */
        onBeforeAction: function (action) {
        },
        /**
         * Callback when action is performed: after (xide/widgets/_MenuMixin)
         *
         * @TODO Run the post selection only when we are active!
         *
         *
         * @param action {module:xaction/Action}
         */
        onAfterAction: function (action, actionDfdResult) {
            action = this.getAction(action);
            _debug && console.log('on after ' + action.command, actionDfdResult);
            if (actionDfdResult != null) {
                if (_.isObject(actionDfdResult)) {
                    // post work: selection & focus
                    var select = actionDfdResult.select,
                        focus = actionDfdResult.focus || true;
                    if (select) {
                        var options = {
                            append: actionDfdResult.append,
                            focus: focus,
                            delay: actionDfdResult.delay || 1,
                            expand: actionDfdResult.expand
                        };
                        //focus == true ? null : this.focus();
                        return this.select(select, null, true, options);
                    }
                }
            }
            this._emit(types.EVENTS.ON_AFTER_ACTION, action);
        },
        hasPermission: function (permission) {
            return DefaultActions.hasAction(this.permissions, permission);
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        addAction: function (where, action) {
            if (action.keyCombo && _.isArray(action.keyCombo)) {
                if (action.keyCombo.indexOf('dblclick') !== -1) {
                    var thiz = this;
                    function handler(e) {
                        var row = thiz.row(e);
                        row && thiz.runAction(action, row.data);
                    }
                    this.addHandle('dbclick', this.on('dblclick', handler));
                }
            }
            return this.inherited(arguments);
        },
        /**
         * Callback when selection changed, refreshes all actions
         * @param evt
         * @private
         */
        _onSelectionChanged: function (evt) {
            this.inherited(arguments);
            this.refreshActions();
        },
        ////////////////////////////////////////////////////////////////////////////
        //
        //  Original ActionMixin
        //
        ///////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param provider
         * @param target
         */
        updateActions: function (provider, target) {
            var actions,
                actionsFiltered,
                selection = this.getSelection();

            if (provider && target) {
                actions = provider.getItemActions();
                actionsFiltered = this._filterActions(selection, actions, provider);
                target.setItemActions({}, actionsFiltered);
            }
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var thiz = this;
            thiz.domNode.tabIndex = -1;
            function clickHandler(evt) {
                //container
                if (evt && evt.target) {
                    var $target = $(evt.target);
                    if ($target.hasClass('dgrid-content') || $target.hasClass('dgrid-extra')) {
                        thiz.select([], null, false);
                        thiz.deselectAll();
                        if (evt.type !== 'contextmenu') {
                            setTimeout(function () {
                                thiz.domNode.focus();
                                document.activeElement = thiz.domNode;
                                $(thiz.domNode).focus();
                            }, 1);
                        }
                    }
                }
            }
            this.on("contextmenu", clickHandler.bind(this));
            this._on('selectionChanged', function (evt) {
                this._onSelectionChanged(evt);
            }.bind(this));

            this._on('onAddActions', function (evt) {
                var actions = evt.actions,
                    action = types.ACTION.HEADER;

                if (!thiz.getAction(action)) {
                    actions.push(thiz.createAction({
                        label: 'Header',
                        command: action,
                        icon: 'fa-hdd-o',
                        tab: 'View',
                        group: 'Show',
                        mixin: {
                            actionType: 'multiToggle'
                        },
                        onCreate: function (action) {
                            action.set('value', thiz.showHeader);
                        },
                        onChange: function (property, value) {
                            thiz._setShowHeader(value);
                            thiz.showHeader = value;
                            thiz.onAfterAction(types.ACTION.HEADER);
                        }
                    }));
                }
            });
            return this.inherited(arguments);
        }
    };
    //package via declare
    var _class = declare('xgrid.Actions', ActionProvider, Implementation);
    _class.Implementation = Implementation;
    return _class;
});
/** @module xgrid/types **/
define('xgrid/typesLite',[
    "xdojo/declare",
    'xide/types',
    'xgrid/Selection',
    'xgrid/Keyboard',
    'xgrid/ColumnHider',
    'xide/mixins/EventedMixin',
    'dgrid/OnDemandGrid',
    'xgrid/Defaults',
    'xgrid/Layout',
    'xgrid/Focus',
    'xgrid/ListRenderer',
    'xgrid/Clipboard',
    'xgrid/Actions',
    'xlang/i18'
], function (declare,types,
             Selection,_GridKeyboardSelection,ColumnHider,
             EventedMixin, OnDemandGrid,Defaults,Layout,Focus,
             ListRenderer,
             Clipboard,Actions,i18)
{
    /**
     * Grid Bases
     * @enum module:xgrid/types/GRID_BASES
     * @memberOf module:xgrid/types
     */
    types.GRID_BASES = {
        GRID: OnDemandGrid,
        LAYOUT:Layout,
        DEFAULTS: Defaults,
        RENDERER: ListRenderer,
        EVENTED: EventedMixin,
        FOCUS:Focus,
        i18:i18
    };
    /**
     * Default Grid Options
     * @deprecated
     * @enum module:xgrid/types/DEFAULT_GRID_OPTIONS
     * @memberOf module:xgrid/types
     */
    types.DEFAULT_GRID_OPTIONS = {
        /**
         * Instruct the grid to add jQuery theme classes
         * @default true
         * @type {bool}
         * @constant
         */
        USE_JQUERY_CSS: false,
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {bool}
         * @constant
         */
        DESELECT_SELECTED: true,
        /**
         * Behaviour flag to clear selection when clicked on the container node
         * @default true
         * @type {bool}
         * @constant
         */
        CLEAR_SELECTION_ON_CLICK: true,
        /**
         * Item actions
         * @default true
         * @type {object}
         * @constant
         */
        ITEM_ACTIONS: {},
        /**
         * Grid actions (sort, hide column, layout)
         * @default true
         * @type {object}
         * @constant
         */
        GRID_ACTIONS: {},
        /**
         * Publish selection change globally
         * @default true
         * @type {boolean}
         * @constant
         */
        PUBLISH_SELECTION: false
    };
    /**
     * Grid option keys
     * @enum module:xgrid/types/GRID_OPTION
     * @memberOf module:xgrid/types
     */
    types.GRID_OPTION = {
        /**
         * Instruct the grid to add jQuery theme classes
         * @default true
         * @type {string}
         * @constant
         */
        USE_JQUERY_CSS: 'USE_JQUERY_CSS',
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {string}
         * @constant
         */
        DESELECT_SELECTED: 'DESELECT_SELECTED',
        /**
         * Behaviour flag to deselect an item when its already selected
         * @default true
         * @type {string}
         * @constant
         */
        CLEAR_SELECTION_ON_CLICK:'CLEAR_SELECTION_ON_CLICK',
        /**
         * Actions
         * @default true
         * @type {string}
         * @constant
         */
        ITEM_ACTIONS:'ITEM_ACTIONS',
        /**
         * Actions
         * @default true
         * @type {string}
         * @constant
         */
        GRID_ACTIONS:'GRID_ACTIONS'
    };
    /**
     * All grid default features
     * @enum module:xgrid/types/GRID_DEFAULT_FEATURES
     * @memberOf module:xgrid/types
     */
    types.DEFAULT_GRID_FEATURES_LITE = {
        SELECTION: {
            CLASS: Selection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        KEYBOARD_SELECTION: {
            CLASS: _GridKeyboardSelection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        COLUMN_HIDER: {
            CLASS: ColumnHider,
            IMPLEMENTATION: {},
            CLASSES: null
        }

    };
    /**
     * All Grid Features for easy access
     * @enum module:xgrid/types/GRID_FEATURES
     * @memberOf module:xgrid/types
     */
    types.GRID_FEATURES_LITE = {
        SELECTION: {
            CLASS: Selection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        KEYBOARD_SELECTION: {
            CLASS: _GridKeyboardSelection,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        ACTIONS: {
            CLASS: Actions,
            IMPLEMENTATION: {},
            CLASSES: null
        },
        CLIPBOARD:{
            CLASS:Clipboard,
            IMPLEMENTATION:{},
            CLASSES:null
        },
        COLUMN_HIDER: {
            CLASS: ColumnHider,
            IMPLEMENTATION: {},
            CLASSES: null
        }
    };
    return declare(null,[],{});
});
/** @module xgrid/Base **/
define('xgrid/BaseLite',[
    "xdojo/declare",
    'xide/types',
    'xgrid/typesLite',
    'xide/utils/ObjectUtils',   //possibly not loaded yet
    'xide/utils',
    'dgrid/OnDemandGrid',
    'xgrid/Defaults',
    'xgrid/Layout',
    'xgrid/Focus',
    'xgrid/ListRenderer',
    'xgrid/ThumbRenderer',
    'xgrid/TreeRenderer',
    'dgrid/util/misc'
], function (declare,types,
             xTypes,ObjectUtils,utils,
             OnDemandGrid,Defaults,Layout,Focus,
             ListRenderer,ThumbRenderer,TreeRenderer,
             miscUtil){

    var BASE_CLASSES = ['EVENTED','GRID','EDITOR','RENDERER','DEFAULTS','LAYOUT','FOCUS','i18'];
    var DEFAULT_GRID_FEATURES = types.DEFAULT_GRID_FEATURES_LITE;
    var GRID_BASES = types.GRID_BASES;
    var DEFAULT_GRID_OPTIONS = types.DEFAULT_GRID_OPTIONS;

    /**
     * Short hand version of declare.classFactory for our base grid
     * @param name
     * @param bases
     * @param extraClasses
     * @param implementation
     * @private
     * @returns {*}
     */
    function classFactory(name, bases, extraClasses,implementation) {
        return declare.classFactory(name, bases, extraClasses, implementation,GRID_BASES);
    }
    /**
     * Default implementation
     * @class module:xgrid/Base
     * @extends module:dgrid/List
     * @extends module:xide/mixins/EventedMixin
     */
    var Implementation = {
        _isHighlighting:false,
        _featureMap:{},
        options: utils.clone(types.DEFAULT_GRID_OPTIONS),
        getContextMenu:function(){},
        getToolbar:function(){},
        /**
         * Returns true if there is anything rendered.
         * @param item {obj|null}
         * @returns {boolean}
         */
        isRendered:function(item){
            if(!item){
                return this.bodyNode!=null;
            }
            item = this._normalize(item);
            var collection = this.collection;
            if(item){
                var itemData = item.data;
                var idProp = collection['idProperty'];
                var nodes = this.getRows(true);
                if(nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        var row = this.row(node);
                        if (row && row.data && row.data && itemData && row.data[idProp] === itemData[idProp]) {
                            return true;
                        }
                    }
                }

            }
            return false;
        },
        /**
         * highlightRow in dgrid/List leaks and is anyway not needed.
         */
        highlightRow:function(){},
        getParent:function(){
            return this._parent;
        },
        get:function(what){
            var parent = this.getParent();
            if(what==='iconClass') {
                //docker:
                if (parent && parent.icon) {
                    return parent.icon();
                }
            }
            return this.inherited(arguments);
        },
        set:function(what,value){
            var parent = this.getParent();
            if(what==='iconClass'){
                var _set = parent.set;
                if(_set) {
                    _set.apply(parent, [what, value]);
                }else if(parent && parent.icon){
                    parent.icon(value);
                    return true;
                }
            }
            if(what==='title' && value && parent){
                var _set = parent.set;
                if(_set){
                    _set.apply(parent,[what,value]);
                }else if(parent && parent.title){
                    parent.title(value);
                }
            }

            if(what==='loading'){            
                this.__loading = value;
                if(parent){
                    //docker:
                    if(parent.startLoading) {
                        var icon = parent._options.icon;
                        if (value === true) {
                            parent.startLoading('', 0.5);
                            parent.icon('fa-spinner fa-spin');
                        } else {
                            parent.finishLoading();
                            parent.icon(icon);
                        }
                        return true;
                    }else if(parent.set){
                        parent.set('loading',value);
                    }
                }
            }
            return this.inherited(arguments);
        },
        runAction:function(action){
            if(action.command==types.ACTION.HEADER){
                this._setShowHeader(!this.showHeader);
            }
            return this.inherited(arguments);
        },
        highlight:function(highlight){
            var node = $(this.domNode.parentNode);
            if(highlight){
                if(this._isHighlighting){
                    return;
                }
                this._isHighlighting = true;
                node.addClass('highlight');
            }else{

                this._isHighlighting=false;
                node.removeClass('highlight');
            }
        },
        getState:function(state) {
            state = this.inherited(arguments) || {};
            state.showHeader = this.showHeader;
            return state;
        },
        postMixInProperties: function () {
            var state = this.state;
            if (state) {
                this.showHeader = state.showHeader;
            }
            return this.inherited(arguments);
        },
        renderArray:function(array){
            if(this.__loading){
                return [];
            }
            this._lastData = array;            
            return this.inherited(arguments);
        },
        getData:function(){
            return this._lastData;
        },
        refreshItem:function(item,silent){
            if (silent) {
                this._muteSelectionEvents = true;
            }
            this.collection.emit('update', {
                target: item
            });
            if (silent) {
                this._muteSelectionEvents = false;
            }
        },
        onShow:function(){
            this._emit(types.EVENTS.ON_VIEW_SHOW,this);
            return this.inherited(arguments);
        },
        isActive:function(testNode){
            return utils.isDescendant(this.domNode,testNode || document.activeElement);
        },
        _showHeader:function(show){
            $(this.domNode).find('.dgrid-header').each(function(i,el){
                $(el).css('display',show ? '' : 'none' );
            });

            $(this.domNode).find('.dgrid-scroller').each(function(i,el){
                $(el).css('margin-top',show ? 26 : 0 );
            });

        },
        destroy:function(){
            this._emit('destroy',this);
            return this.inherited(arguments);
        },
        hasFeature:function(name){
            return _contains(['name'],_.keys(this._featureMap));
        },
        /**
         * Return current row's elements or data
         * @param domNodes {boolean} return dom instead of data. Default false.
         * @param filterFunction
         * @returns {*}
         */
        getRows:function(domNodes,filterFunction){
            var result = [],
                self = this;
            var nodes = $(self.domNode).find('.dgrid-row');
            _.each(nodes,function(node){
                var _row = self.row(node);
                if(_row && _row.element){
                    result.push(_row[domNodes ? 'element' : 'data']);
                }
            });
            if (filterFunction) {
                return result.filter(filterFunction);
            }
            return result;
        },
        startup:function(){
            var result = this.inherited(arguments);
            if(this.columns) {
                _.each(this.columns,function(column){
                    if (column.width) {
                        this.styleColumn(parseInt(column.id), 'width:' + column.width);
                    }
                },this);
            }

            var self = this;
            this.showExtraSpace && this.on('dgrid-refresh-complete',function(){
                var rows = self.getRows();
                var _extra = $(self.contentNode).find('.dgrid-extra');
                if(!rows.length){
                    return;
                }

                if(!_extra.length){
                    _extra = $('<div class="dgrid-extra" style="width:100%;height:80px"></div>');
                    $(self.contentNode).append(_extra);
                    _extra.on('click',function(){
                        self.deselectAll();
                    });
                    _extra.on('contextmenu',function(){
                        self.deselectAll();
                    })
                }
            });

            return result;
        },
        removeRow:function(){
            var res = this.inherited(arguments);
            var self = this;
            if(this.showExtraSpace) {
                var rows = self.getRows();
                var _extra = $(self.contentNode).find('.dgrid-extra');
                if (!rows.length) {
                    _extra.remove();
                }
            }
            return res;
        }
    };
    /**
     * Create root class with declare and default implementation
     */
    var _default = declare('xgrid.DefaultLite', null, Implementation);

    /**
     * 2-dim array search
     * @param left {string[]}
     * @param keys {string[]}
     * @returns {boolean}
     * @private
     */
    function _contains(left, keys) {
        return keys.some(function (v) {
            return left.indexOf(v) >= 0;
        });
    }

    /**
     * Find default keys in a feature struct and recompse user feature
     * @param feature {object} feature struct
     * @param defaultFeature {object}
     * @returns {object} recomposed feature
     */
    function getFeature(feature, defaultFeature) {
        //is new feature, return the mix of default props and customized version
        if (_contains(['CLASS','CLASSES','IMPLEMENTATION'],_.keys(feature))) {
            return utils.mixin(utils.cloneKeys(defaultFeature),feature);
        }
        return defaultFeature;
    }

    /**
     * Grid class factory
     * @param name {string} A name for the class created
     * @param baseClass {object} the actual implementation (default root class, declared above)
     * @param features {object} the feature map override
     * @param gridClasses {object} the base grid classes map override
     * @param args {object} root class override
     * @param _defaultBases {object}
     * @memberOf module:xgrid/Base
     * @returns {module:xgrid/Base}
     */
    function createGridClass(name, baseClass, features, gridClasses, args,_defaultBases) {
        var _isNewBaseClass = false;
        baseClass = baseClass || _default;
        //simple case, no base class and no features
        if (!baseClass && !features) {
            return _default;
        }
        if (baseClass) {
            _isNewBaseClass = _contains(BASE_CLASSES,_.keys(gridClasses));
            var defaultBases = utils.cloneKeys(_defaultBases || GRID_BASES);
            if (_isNewBaseClass) {
                utils.mixin(defaultBases, gridClasses);
                //remove empty
                defaultBases = _.pick(defaultBases, _.identity);
            }
            //recompose base class
            baseClass = classFactory(name, defaultBases, [_default], baseClass);
        }

        var newFeatures = [],
            featureMap = {};

        //case: base class and features
        if (baseClass && features) {
            var _defaultFeatures = utils.cloneKeys(DEFAULT_GRID_FEATURES);
            utils.mixin(_defaultFeatures, features);

            for (var featureName in _defaultFeatures) {
                var feature = _defaultFeatures[featureName];
                if (!_defaultFeatures[featureName]) {
                    continue;
                }
                var newFeature = null;
                if (feature === true) {
                    //is a base feature
                    newFeature = DEFAULT_GRID_FEATURES[featureName];
                } else if (DEFAULT_GRID_FEATURES[featureName]) {
                    //is new/extra feature
                    newFeature = getFeature(feature, DEFAULT_GRID_FEATURES[featureName]);
                } else {
                    //go on
                    newFeature = feature;
                }
                if (newFeature) {
                    var featureClass = classFactory(featureName, newFeature['CLASSES'] || [], [newFeature['CLASS']], newFeature['IMPLEMENTATION']);
                    newFeatures.push(featureClass);
                    featureMap[featureName]=featureClass;
                }
            }
            //recompose
            if (newFeatures.length > 0) {
                baseClass = classFactory(name, [baseClass], newFeatures, args);
            }
            //complete
            baseClass.prototype._featureMap = featureMap;
        }
        return baseClass;
    }


    var Module = createGridClass('xgrid/Base',{
            options: utils.clone(DEFAULT_GRID_OPTIONS)
        },
        //features
        {
            SELECTION: true,
            KEYBOARD_SELECTION: true,
            PAGINATION: false,
            COLUMN_HIDER: false
        },
        //bases, no modification
        null,
        {

        });

    Module.createGridClass = createGridClass;

    //track defaults on module
    Module.classFactory = classFactory;
    Module.DEFAULT_GRID_FEATURES = DEFAULT_GRID_FEATURES;
    Module.DEFAULT_GRID_BASES = GRID_BASES;
    Module.DEFAULT_GRID_OPTIONS = DEFAULT_GRID_OPTIONS;
    Module.DEFAULT_GRID_OPTION_KEYS = types.DEFAULT_GRID_OPTION_KEYS;

    return Module;

});
/** @module xgrid/Grid **/
define('xgrid/GridLite',[
    'dojo/_base/declare',
    'xide/types',
    './BaseLite'
],function (declare,types,Base) {
    /**
     *
     * Please read {@link module:xgrid/types}
     *
     * @class module:xgrid/Grid
     * @augments module:xgrid/Base
     */
    var grid = declare('xgrid/Grid',Base,{});

    grid.createGridClass = Base.createGridClass;

    //track defaults on module
    grid.classFactory = Base.classFactory;
    grid.DEFAULT_GRID_FEATURES = types.DEFAULT_GRID_FEATURES_LITE;
    grid.DEFAULT_GRID_BASES = Base.DEFAULT_GRID_BASES;
    grid.DEFAULT_GRID_OPTIONS = types.DEFAULT_GRID_OPTIONS;
    grid.DEFAULT_GRID_OPTION_KEYS = types.DEFAULT_GRID_OPTION_KEYS;

    return grid;
});
/** @module xgrid/MultiRenderer **/
define('xgrid/MultiRenderer',[
    "xdojo/declare",
    'xide/types',
    'xgrid/Renderer',
    'dojo/_base/kernel'
], function (declare, types, Renderer,dojo) {
    /**
     * @class module:xgrid/MultiRenderer
     * @extends module:xgrid/Renderer
     */
    var Implementation = {
        renderers: null,
        selectedRenderer: null,
        lastRenderer: null,
        rendererActionRootCommand: 'View/Layout',
        runAction:function(action){
            action = this.getAction(action);
            if(action.command.indexOf(this.rendererActionRootCommand)!==-1){
                var parentAction = action.getParent ?  action.getParent() : null;
                action._originEvent = 'change';
                this.setRenderer(action.value);
                if(parentAction) {
                    parentAction.set('icon', action.get('icon'));
                    var rendererActions = parentAction.getChildren();
                    _.each(rendererActions, function (child) {
                        child._oldIcon && child.set('icon', child._oldIcon);
                    });
                }
                action.set && action.set('icon', 'fa-check');
                return true;
            }
            return this.inherited(arguments);
        },
        /**
         * Impl. set state
         * @param state
         * @returns {object|null}
         */
        setState:function(state){
            var renderer = state.selectedRenderer ? dojo.getObject(state.selectedRenderer) : null;
            if(renderer){
                this.setRenderer(renderer);
                this.set('collection',this.collection.getDefaultCollection());

            }
            return this.inherited(arguments);
        },
        /**
         * Impl. get state
         * @param state
         * @returns {object}
         */
        getState:function(state){
            state = this.inherited(arguments) || {};
            if(this.selectedRenderer) {
                state.selectedRenderer = this.getSelectedRenderer.declaredClass;
            }
            return state;
        },
        getRendererActions: function (_renderers, actions) {
            var root = this.rendererActionRootCommand,
                thiz = this,
                renderActions = [],
                renderers = _renderers || this.getRenderers(),
                VISIBILITY = types.ACTION_VISIBILITY,
                index = 1;

            actions = actions || [];

            //root
            renderActions.push(this.createAction({
                label: 'Layout',
                command: root,
                icon: 'fa-laptop',
                tab: 'View',
                group: 'Layout',
                mixin:{
                    closeOnClick:false
                },
                onCreate:function(action){
                    action.value = thiz.selectedRenderer;

                    action.setVisibility(VISIBILITY.ACTION_TOOLBAR, false).
                    setVisibility(VISIBILITY.RIBBON,{expand:true});
                }
            }));
            /**
             *
             * @param col
             * @private
             */
            function createEntry(label, icon, Renderer) {
                var selected = Renderer == thiz.selectedRenderer;
                /*
                var mapping = {
                    "change":{
                        //action to widget mapping
                        input:ActionValueWidget.createTriggerSetting('value','checked',function(event,value,mapping){
                            //return this.actionValue;
                            return value;
                        }),

                        //widget to action mapping
                        output:utils.mixin(ActionValueWidget.createTriggerSetting('checked','value',function(){
                            return this.actionValue;
                        }),{
                            ignore:function(event,value){
                                return value === false;
                            }
                        })
                    }
                };
                */

                /*
                var widgetArgs = {
                    actionValue:Renderer,
                    mapping:mapping,
                    checked: selected,
                    label:label
                };
                */

                var keycombo = 'shift f' + index;
                index++;

                var _renderer = Renderer;
                var _action = null;
                var ACTION = null;

                _action = thiz.createAction({
                    label: label,
                    command: root + '/' + label,
                    icon: icon,
                    tab: 'View',
                    group: 'Layout',
                    mixin:{
                        value:Renderer,
                        addPermission:true,
                        closeOnClick:false
                    },
                    keycombo:[keycombo],
                    onCreate:function(action){
                        action._oldIcon = icon;
                        action.actionType = types.ACTION_TYPE.SINGLE_TOGGLE;
                        //action.set('value',Renderer);
                        action.value = Renderer;
                        /*
                        var _visibilityMixin = {
                            widgetArgs: {
                                actionValue:Renderer,
                                mapping:mapping,
                                group: thiz.id+'_renderer_all',
                                checked: selected,
                                label:label,
                                iconClass: null,
                                title:'test'
                            }
                        };
                        action.setVisibility(types.ACTION_VISIBILITY_ALL,_visibilityMixin);
                        */

                    }
                });
                renderActions.push(_action);
                return renderActions;
            }

            _.each(renderers,function (Renderer) {
                var impl = Renderer.Implementation || Renderer.prototype;
                if (impl._getLabel) {
                    createEntry(impl._getLabel(), impl._getIcon(), Renderer);
                }
            });
            return renderActions;
        },
        getSelectedRenderer:function(){
            return this.selectedRenderer.prototype;
        },
        startup: function () {
            var thiz = this;
            this._on('onAddGridActions', function (evt) {
                var renderActions = thiz.getRendererActions(thiz.getRenderers(), evt.actions);
                renderActions.forEach(function (action) {
                    evt.actions.push(action);
                });
            });
            this.inherited(arguments);
            //add new root class
            this.selectedRenderer && $(this.domNode).addClass(this.getSelectedRenderer()._getLabel());
        },
        getRenderers: function () {
            return this.renderers;
        },
        setRenderer: function (renderer,_focus) {
            //track focus and selection
            var self = this,
                selection = self.getSelection(),
                focused = self.getFocused(),
                selected = self.getSelectedRenderer();

            var args = {
                'new': renderer,
                'old': self.selectedRenderer
            };
            var node$ = $(this.domNode);
            //remove renderer root css class
            node$.removeClass(selected._getLabel());
            //call renderer API
            selected.deactivateRenderer.apply(this, args);

            //tell everyone
            this._emit('onChangeRenderer', args);

            //update locals
            this.lastRenderer = this.selectedRenderer;
            this.selectedRenderer = renderer;

            //?
            this.selectedRendererClass = renderer.prototype.declaredClass;

            //add new root class
            node$.addClass(renderer.prototype._getLabel());

            //call  API
            renderer.prototype.activateRenderer.apply(this, args);

            //reset store
            this.collection.reset();

            //refresh, then restore sel/focus
            var refresh = this.refresh();

            refresh && refresh.then && refresh.then(function(){
                self._emit('onChangedRenderer', args);
            });
            return refresh;
        }
    };


    /**
     * Forward custom renderer method
     * @param who
     * @param method
     */
    function forward(who,method){
        Implementation[method]=function(){
            var parent = this.getSelectedRenderer();
            if (parent[method]) {
                return parent[method].apply(this, arguments);
            }
            return this.inherited(arguments);
        };
    }

    //@TODO: this should be all public methods in dgrid/List ?
    _.each(['row','removeRow','renderRow','insertRow','activateRenderer','deactivateRenderer'],function(method){
        forward(Implementation,method);
    });


    //package via declare
    var _class = declare('xgrid.MultiRenderer', null, Implementation);
    _class.Implementation = Implementation;

    return _class;
});
define('xide/editor/Registry',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/factory',
    'xide/types',
    'xide/data/Memory'
], function (dcl,declare, factory, types,Memory) {

    //exported mixin
    var editorMixin;

    //singleton store
    var store;

    var debug=false;

    editorMixin = dcl(null, {
        declaredClass:"xide.editor.Registry",
        delegate: null,
        editors: null,
        _started: false,
        startup: function () {
            this.subscribe(types.EVENTS.REGISTER_EDITOR, function (data) {
                editorMixin.onRegisterEditor(data);
            });
        }
    });

    editorMixin.editors = [];

    var editors = editorMixin.editors;

    editorMixin.getStore = function(){
        if(!store){
            store = new Memory({
                idProperty:'name'
            })
        }
        return store;
    };

    editorMixin.getExtension = function (fname) {
        if (fname != null) {
            return fname.substr((~-fname.lastIndexOf(".") >>> 0) + 2);
        }
        return "";
    };

    editorMixin._hasEditor = function (name,extensions) {
        return _.find(editorMixin.editors,{
            name:name,
            extensions:extensions
        });
    };

    editorMixin.unregisterEditor = function (name) {
        var _store = editorMixin.getStore();
        var editors = _store._find({
            name:name
        });
        function unregister(editor){
            _store.removeSync(editor.name);
            _.each(editors,function(_editor){
                if(_editor && _editor.name === editor.name){
                    editors.remove(_editor);
                }
            });
        }
        _.each(editors,unregister);
    };

    editorMixin.onRegisterEditor = function (eventData) {
        var _store = editorMixin.getStore();
        var allEditors = _store._find({
            name:eventData.name
        });
       if(allEditors.length>0){
           debug && console.warn('Editor already registered',eventData);
           _.each(allEditors,function(editor){
               _store.removeSync(editor.name);
               editorMixin.unregisterEditor(editor.name);
           });
        }
        _store.putSync(eventData);
        if (!editorMixin._hasEditor(eventData.name,eventData.extensions)) {
            editors.push(eventData);
        }
    };

    editorMixin.getDefaultEditor = function (item) {
        var editors = editorMixin.getEditors(item);
        if (!editors) {
            return null;
        }

        for (var i = 0; i < editors.length; i++) {
            var obj = editors[i];
            if (obj.isDefault === true) {
                return obj;
            }
        }
        return null;
    };

    editorMixin.getEditor = function(name){
        return _.find(editors,{
            name:name
        });
    };

    editorMixin.getEditors = function (item) {
        if(!item){
            return editors;
        }
        var extension = editorMixin.getExtension(item.path);
        if (extension != null && extension.length == 0) {
            return null;
        }
        extension=extension.toLowerCase();
        var result = [];
        if (!editorMixin.editors) {
            return null;
        }

        var store = editorMixin.getStore();
        var _defaultEditor = store._find({
            defaultEditor:true
        });

        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (editor) {
                //check multiple extensions
                if (editor.extensions.indexOf('|') != -1) {
                    var supportedPluginExtensions = editor.extensions.split('|');
                    for (var j = 0; j < supportedPluginExtensions.length; j++) {
                        var supportedPluginExtension = supportedPluginExtensions[j];
                        if (supportedPluginExtension === extension) {
                            result.push(editor);
                        }
                    }
                } else {
                    //otherwise single extension match
                    if (editor.extensions === extension) {
                        result.push(editor);
                    }
                }
            }
        }

        if(_defaultEditor.length==1){
            result.push(_defaultEditor[0]);
        }

        if (result.length > 0) {
            return result;
        }
        return null;
    };

    return editorMixin;
});

define('xide/editor/Default',[
    'xdojo/declare',
    'xide/utils',
    'xdojo/has!xace?xace/views/Editor'
],function (declare,utils,Editor){

    var debug = false;
    /**
    * A default editor, using ACE!
     */
    var Implementation = {
        ctx:null,
        /**
         *
         * @param item
         * @param where
         * @param mixin
         * @returns {Editor}
         */
        open:function(item,where,mixin,select,owner){

            if(!Editor){
                debug && console.error('have no xace! abort opening default editor!');
            }

            if(!item){
                debug && console.error('invalid item!');
                return null;
            }

            if(!item.getPath().match(/^(.*\.(?!(zip|tar|gz|bzip2)$))?[^.]*$/i)) {
                return null;
            }

            var mime = item.mime,
                mediaTypes = ["image/png","image/jpg"];

            if(mime){
                if(mediaTypes.indexOf(mime)!==-1||
                    mime.indexOf('video')!==-1||
                    mime.indexOf('audio')!==-1 ||
                    mime.indexOf('image')!==-1)
                {
                    return null;
                }
            }

            var thiz=this,
                ctx = thiz.ctx,
                mainView = ctx ? ctx.mainView : null,
                title = utils.toString(item.name) ||  (utils.pathinfo(item.path,'PATHINFO_FILENAME') + '.'+ utils.pathinfo(item.path,'PATHINFO_EXTENSION')),
                docker = mainView ? mainView.getDocker() : null,
                registerInWindowManager = owner && owner.registerEditors===true ? true : false,
                container  = where || mainView.layoutCenter,
                root = null;

            mixin = mixin || {}

            if(!where) {
                root = mixin.attachTo || docker.addTab(null, {
                    title: title,
                    target: container ? container._parent : null,
                    icon: 'fa-code'
                });
            }else{
                root = container;
            }

            var args = {

                item:item,
                style:'padding:0px;',
                iconClass:'fa-code',
                options:utils.mixin(mixin,{
                    filePath:item.path,
                    fileName:item.name
                }),
                ctx:ctx,
                /***
                 * Provide a text editor store delegate
                 */
                storeDelegate:{
                    getContent:function(onSuccess,_item){
                        var file = _item || item;
                        return thiz.ctx.getFileManager().getContent(file.mount,file.path,onSuccess);
                    },
                    saveContent:function(value,onSuccess,onError){
                        return thiz.ctx.getFileManager().setContent(item.mount,item.path,value,onSuccess);
                    }
                },
                title:title
            };

            utils.mixin(args,mixin);

            var editor = utils.addWidget(Editor,args,this,root,true,null,null,select);

            root.resize && root.resize() && editor.resize();

            select!==false && root.selectChild && root.selectChild(editor);

            docker.resize();

            registerInWindowManager && ctx.getWindowManager().registerView(editor,false);

            return editor;
        }
    };

    //package via declare
    var _class = declare('xide.editor.Default',null,Implementation);
    _class.Implementation = Implementation;
    return _class;

});
define('xide/_Popup',[
    'dcl/dcl'
],function (dcl){

    var zIndexStart = 200;

    var Module = dcl(null,{});

    Module.nextZ = function(incr){
        zIndexStart++;
        if(incr){
            zIndexStart+=incr;
        }
        return zIndexStart;
    }

    if(typeof window !=='undefined'){
        window['__nextZ'] = Module.nextZ;
    }

    Module.setStartIndex=function(index){
        zIndexStart = index;
    }

    return Module;
});
/** @module xgrid/Base **/
define('xide/views/_Dialog',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    'dojo/Deferred',
    'xide/_Popup'

], function (dcl,types,
             utils, EventedMixin,
             _Widget,Deferred,_Popup
) {



    var ctx = window.sctx,
        root;

    var _BootstrapDialog  = typeof BootstrapDialog !=='undefined' ? BootstrapDialog : {};

    var Module = dcl([_Widget.dcl,EventedMixin.dcl],{
        declaredClass:'xide/views/_Dialog',
        //message: null,
        cssClass:'bootstrap3-dialog',
        containerClass:'',
        type: types.DIALOG_TYPE.WARNING,
        size: types.DIALOG_SIZE.SIZE_WIDE,
        //defaultOptions:_BootstrapDialog.defaultOptions,
        dlg:null,
        bodyCSS:null,
        okButtonClass:'btn-danger',
        startDfd:null,
        _ready:false,
        getData:function(){
            return null;
        },
        getInstance:function(args){

            this.defaultOptions  = typeof BootstrapDialog !=='undefined' ? BootstrapDialog.defaultOptions : {};

            if(this.dlg){
                return this.dlg;
            }

            args = this.buildArgs(args);

            var instance = new _BootstrapDialog(args),
                oldRealize = instance.realize,
                self = this;

            if(!instance){
                console.error('BootstrapDialog not loaded, abort');
                return;
            }

            instance.realize = function(){
                oldRealize.apply(instance,null);
                self.buildRendering(instance);
                $.each(args.buttons, function (index, button) {
                    var $button = instance.getButton(button.id);
                    if($button && button.focus==true){
                        $button.addClass('active');
                    }
                });

                $(instance.$modalDialog).draggable({ handle: ".modal-header" });
            }

            instance.owner = this;


            this.dlg = instance;

            return instance;

        },
        buildRendering:function(dlg){
            this.containerNode= this.domNode = dlg.$modalBody[0];
            dlg.$modalBody.addClass(this.containerClass);
            this.bodyCSS && dlg.$modalBody.css(this.bodyCSS);
        },
        onshown:function(dlg){
            dlg.owner.resize();
            dlg.owner.onShow.apply(dlg.owner,[]);
            var zIndexBackdrop = window.__nextZ ? window.__nextZ(1) : 1040;
            var zIndexModal = window.__nextZ ? window.__nextZ() : 1050;

            dlg.$modal.css('z-index',zIndexBackdrop);
            dlg.$modalDialog.css('z-index',zIndexModal);

            this._ready = true;
        },
        onReady:function(){
            var self = this;
            setTimeout(function(){
                self._ready = true;
            },100);

        },
        startup:function(){
            var dlg = this.getInstance();
        },
        destroy:function(){
            this.dlg && this.dlg.close();
        },
        show:function(args){

            var self=this;

            if(!this.startDfd){
                this.startDfd = new Deferred();
                this.startDfd.then(function(){
                    self.onReady();
                });
            }

            var dlg = this.getInstance(args);

            dlg.open();

            setTimeout(function(){
                self._ready=true;
            },1000);

            return this.startDfd;

        },

        getButtons:function(){

            var thiz = this;

            var buttons = [{
                icon: 'fa-check',
                label: thiz.localize('Ok'),
                cssClass: thiz.okButtonClass || 'btn-primary',
                hotkey: 13, // Enter.
                autospin: false,
                focus:true,
                id:utils.createUUID(),
                action: function(dialogRef) {
                    if(!thiz._ready){
                        return;
                    }
                    dialogRef.close(false);
                    dialogRef.owner.onOk(thiz.getData());
                }
            },
            {
                icon: 'glyphicon glyphicon-check',
                label: thiz.localize('CANCEL'),
                cssClass: 'btn-info',
                autospin: false,
                id:utils.createUUID(),
                action: function (dialogRef) {
                    dialogRef.close();
                    dialogRef.owner.onCancel();
                }

            }
            ];

            return buttons;

        },
        buildArgs:function(args){
            args = args || this.defaultOptions || {};
            utils.mixin(args,{
                type: this.type,
                size: this.size,
                message:this.message,
                title:this.title,
                buttons:this.buttons,
                onOk:this.onOk,
                onCancel:this.onCancel,
                onShow:this.onShow,
                onshown:this.onshown
                //defaultOptions:_BootstrapDialog.defaultOptions,
            });
            args.title = this.localize(args.title)
            return args;
        },
        constructor:function(args){
            this.buttons = this.getButtons();
            utils.mixin(this,args);
        },
        onOk:function(){},
        onCancel:function(){}
    });

    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");


    return Module;

});
/** @module xfile/views/FileOperationDialog **/
define('xfile/views/FileOperationDialog',[
    "dcl/dcl",
    'xide/types',
    "xide/views/_Dialog"
], function (dcl, types, _Dialog) {


    var Module = dcl(_Dialog, {

        title: '',
        type: types.DIALOG_TYPE.INFO,
        size: types.DIALOG_SIZE.SIZE_SMALL,
        bodyCSS: {},
        failedText: ' Failed!',
        successText: ': Success!',
        showSpinner: true,
        spinner: '  <span class="fa-spinner fa-spin"/>',
        notificationMessage: null,
        doOk: function (dfd) {

            this.onBeforeOk && this.onBeforeOk();

            var msg = this.showMessage(),
                thiz = this;

            dfd.then(function (result) {
                thiz._onSuccess(result);
            }, function (err) {
                thiz._onError();
            });

        },
        _onSuccess: function (title, suffix, message) {

            title = title || this.title;
            message = message || this.notificationMessage;

            message && message.update({
                message: title + this.successText + (suffix ? '<br/>' + suffix : ''),
                type: 'info',
                actions: false,
                duration: 1500
            });

            this.onSuccess && this.onSuccess();
        },
        _onError: function (title, suffix, message) {

            title = title || this.title;

            message = message || this.notificationMessage;

            message && message.update({
                message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                type: 'error',
                actions: false,
                duration: 15000
            });


            this.onError && this.onError(suffix);

        },
        onOk: function () {

            var msg = this.showMessage(),
                thiz = this;
            this.doOk(this.getOkDfd());
        },
        showMessage: function (title) {

            if (this.notificationMessage) {
                return this.notificationMessage;
            }
            title = title || this.title;

            var msg = this.ctx.getNotificationManager().postMessage({
                message: title + (this.showSpinner ? this.spinner : ''),
                type: 'info',
                showCloseButton: true,
                duration: 4500
            });

            this.notificationMessage = msg;

            return msg;
        }

    });

    return Module;

});
define('dijit/registry',[
    "xide/registry"
], function(registry){
	return registry;
});

define('xfile/views/FilePreview',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    "dojo/cache",
    "dojo/Deferred",
    "dijit/registry",
    "xide/editor/Default",
    "xaction/DefaultActions"
], function (dcl, types,
             utils, EventedMixin,
             _Widget, cache, Deferred, registry, Default, DefaultActions) {

    var plugins = [
        /**
         * Images preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var mimes = ['image/jpeg', 'image/png', 'image/gif'],
                preview = ql.preview;

            // what kind of images we can display
            $.each(navigator.mimeTypes, function (i, o) {
                var mime = o.type;

                if (mime.indexOf('image/') === 0 && $.inArray(mime, mimes)) {
                    mimes.push(mime);
                }
            });

            preview.bind('update', function (e) {
                var file = e.file,
                    img;
                if (!ql.opened()) {
                    return;
                }

                if ($.inArray(file.mime, mimes) !== -1) {
                    // this is our file - stop event propagation
                    e.stopImmediatePropagation();
                    var params = null;
                    if (ql.resizeToPreview) {
                        params = {
                            width: preview.width()
                        }
                    }
                    img = $('<img/>')
                        .hide()
                        .appendTo(preview)
                        .load(function () {
                            // timeout - because of strange safari bug -
                            // sometimes cant get image height 0_o
                            setTimeout(function () {
                                var prop = (img.width() / img.height()).toFixed(2);
                                preview.bind('changesize', function () {
                                    var pw = parseInt(preview.width()),
                                        ph = parseInt(preview.height()),
                                        w, h;

                                    if (prop < (pw / ph).toFixed(2)) {
                                        h = ph;
                                        w = Math.floor(h * prop);
                                    } else {
                                        w = pw;
                                        h = Math.floor(w / prop);
                                    }
                                    img.width(w).height(h).css('margin-top', h < ph ? Math.floor((ph - h) / 2) : 0);

                                }).trigger('changesize');

                                // hide info/icon
                                ql.hideinfo();
                                //show image
                                img.fadeIn(100);

                            }, 1)
                        });
                    img.attr('src', ql.fm.url(file, null, params));
                }
            });
        },

        /**
         * HTML preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var mimes = ['text/html', 'application/xhtml+xml'],
                preview = ql.preview,
                fm = ql.fm;
            preview.bind('update', function (e) {
                var file = e.file, jqxhr;

                if (!ql.opened()) {
                    return;
                }

                if ($.inArray(file.mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    var ctx = ql.ctx;
                    var fm = ctx.getFileManager();
                    fm.getContent(file.mount, file.path, function (content) {
                        ql.hideinfo();
                        doc = $('<iframe class="elfinder-quicklook-preview-html"/>').appendTo(preview)[0].contentWindow.document;
                        doc.open();
                        doc.write(content);
                        doc.close();
                    });
                }
            })
        },

        /**
         * Texts preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                preview = ql.preview;


            var mimes = [
                'application/x-empty',
                'application/javascript',
                'application/xhtml+xml',
                'audio/x-mp3-playlist',
                'application/x-web-config',
                'application/docbook+xml',
                'application/x-php',
                'application/x-perl',
                'application/x-awk',
                'application/x-config',
                'application/x-csh',
                'application/xml',
                'application/x-empty',
                'text/html',
                'text/x-c',
                'text/x-php',
                'text/plain',
                'text/x-c++',
                'text/x-lisp'
            ];

            preview.bind('update', function (e) {
                var file = e.file,
                    mime = file.mime,
                    jqxhr;

                if (!ql.opened()) {
                    return;
                }
                if (mime.indexOf('text/') === 0 || $.inArray(mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    if (ql.useAce) {
                        ql.hideinfo();
                        var _node = $('<div class="elfinder-quicklook-preview-text-wrapper"></div>');

                        _node.appendTo(preview);

                        var editor = ql._editor,
                            wasCached = editor;

                        if (editor) {

                        } else {
                            editor = Default.Implementation.open(file, _node[0], ql.editorOptions, false, ql);
                            ql._editor = editor;
                            //add to _widgets
                            ql.add(editor, null, false);

                            if (DefaultActions.hasAction(ql.editorOptions.permissions, types.ACTION.TOOLBAR)) {
                                var toolbar = editor.getToolbar();
                                if (toolbar) {
                                    $(toolbar.domNode).addClass('bg-opaque');
                                }
                            }
                        }
                        if (wasCached) {
                            _node.append(editor.domNode);
                            editor.set('item', file);
                        }

                        preview.bind('changesize', function () {
                            var pw = parseInt(preview.width()),
                                ph = parseInt(preview.height());
                            utils.resizeTo(editor.domNode, preview[0], true, true);
                            editor.resize();
                        });
                    }
                }
            });
        },
        /**
         * PDF preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                mime = 'application/pdf',
                preview = ql.preview,
                active = false;

            active = false;
            var isActive = false;
            if (isActive) {
                active = true;
            } else {
                $.each(navigator.plugins, function (i, plugins) {
                    $.each(plugins, function (i, plugin) {
                        if (plugin.type == mime) {
                            return !(active = true);
                        }
                    });
                });
            }
            active && preview.bind('update', function (e) {
                var file = e.file, node;
                if (!ql.opened()) {
                    return;
                }

                if (file.mime == mime) {
                    e.stopImmediatePropagation();
                    preview.one('change', function () {
                        node.unbind('load').remove();
                    });

                    node = $('<iframe class="elfinder-quicklook-preview-pdf"/>')
                        .hide()
                        .appendTo(preview)
                        .load(function () {
                            ql.hideinfo();
                            node.show();
                        })
                        .attr('src', ql.fm.url(file));
                }
            })
        },

        /**
         * Flash preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var fm = ql.fm,
                mime = 'application/x-shockwave-flash',
                preview = ql.preview,
                active = false;

            $.each(navigator.plugins, function (i, plugins) {
                $.each(plugins, function (i, plugin) {
                    if (plugin.type == mime) {
                        return !(active = true);
                    }
                });
            });

            active && preview.bind('update', function (e) {
                var file = e.file,
                    node;
                if (!ql.opened()) {
                    return;
                }
                if (file.mime == mime) {
                    e.stopImmediatePropagation();
                    ql.hideinfo();
                    preview.append((node = $('<embed class="elfinder-quicklook-preview-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" src="' + fm.url(file) + '" quality="high" type="application/x-shockwave-flash" />')));
                }
            });
        },
        /**
         * HTML5 audio preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var preview = ql.preview,
                autoplay = !!ql.options['autoplay'],
                mimes = {
                    'audio/mpeg': 'mp3',
                    'audio/mpeg3': 'mp3',
                    'audio/mp3': 'mp3',
                    'audio/x-mpeg3': 'mp3',
                    'audio/x-mp3': 'mp3',
                    'audio/x-wav': 'wav',
                    'audio/wav': 'wav',
                    'audio/x-m4a': 'm4a',
                    'audio/aac': 'm4a',
                    'audio/mp4': 'm4a',
                    'audio/x-mp4': 'm4a',
                    'audio/ogg': 'ogg'
                },
                node;

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    type = mimes[file.mime];

                if (ql.support.audio[type]) {
                    e.stopImmediatePropagation();

                    node = $('<audio class="elfinder-quicklook-preview-audio" controls preload="auto" autobuffer><source src="' + ql.fm.url(file) + '" /></audio>')
                        .appendTo(preview);
                    autoplay && node[0].play();
                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node[0].pause();
                    node.remove();
                    node = null;
                }
            });
        },

        /**
         * HTML5 video preview plugin
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {

            var preview = ql.preview,
                autoplay = !!ql.options['autoplay'],
                mimes = {
                    'video/mp4': 'mp4',
                    'video/x-m4v': 'mp4',
                    'video/ogg': 'ogg',
                    'application/ogg': 'ogg',
                    'video/webm': 'webm'
                },
                node;

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    type = mimes[file.mime];

                if (ql.support.video[type]) {
                    e.stopImmediatePropagation();

                    ql.hideinfo();
                    node = $('<video class="elfinder-quicklook-preview-video" controls preload="auto" autobuffer><source src="' + ql.fm.url(file) + '" /></video>').appendTo(preview);
                    autoplay && node[0].play();

                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node[0].pause();
                    node.remove();
                    node = null;
                }
            });
        },
        /**
         * Audio/video preview plugin using browser plugins
         *
         * @param elFinder.commands.quicklook
         **/
            function (ql) {
            var preview = ql.preview,
                mimes = [],
                node;

            if (!ql.opened()) {
                return;
            }

            $.each(navigator.plugins, function (i, plugins) {
                $.each(plugins, function (i, plugin) {
                    (plugin.type.indexOf('audio/') === 0 || plugin.type.indexOf('video/') === 0) && mimes.push(plugin.type);
                });
            });

            preview.bind('update', function (e) {
                if (!ql.opened()) {
                    return;
                }
                var file = e.file,
                    mime = file.mime,
                    video;
                if ($.inArray(file.mime, mimes) !== -1) {
                    e.stopImmediatePropagation();
                    (video = mime.indexOf('video/') === 0) && ql.hideinfo();
                    node = $('<embed src="' + ql.fm.url(file) + '" type="' + mime + '" class="elfinder-quicklook-preview-' + (video ? 'video' : 'audio') + '"/>')
                        .appendTo(preview);
                }
            }).bind('change', function () {
                if (node && node.parent().length) {
                    node.remove();
                    node = null;
                }
            });
        }
    ];
    /**
     * window closed state
     *
     * @type Number
     **/
    var closed = 0,
        /**
         * window opened state
         *
         * @type Number
         **/
        opened = 2,
        /**
         * window animated state
         *
         * @type Number
         **/
        animated = 1;

    var previewClass = dcl([_Widget.dcl, EventedMixin.dcl], {
        resizeToPreview: true,
        useAce: true,
        registerEditors: false,
        editorPermissions: [],
        container: null,
        destroy: function () {
            this.window.empty();
            utils.destroy(this.window[0]);
            this.inherited(arguments);
        },
        /**
         * Init command.
         * Add default plugins and init other plugins
         *
         * @return Object
         **/
        init: function () {
            this.options = {
                autoplay: true,
                jplayer: "extensions/jplayer",
                ui: 'button'
            };
            var o = this.options,
                self = this,
                win = this.window,
                preview = this.preview,
                container = this.container,
                i, p;

            width = o.width > 0 ? parseInt(o.width) : 450;
            height = o.height > 0 ? parseInt(o.height) : 300;
            if (!container) {
                win.appendTo('body').zIndex(20);
            }
            // close window on escape
            $(document).keydown(function (e) {
                e.keyCode == 27 && self.opened() && win.trigger('close')
            });

            if (!container && $.fn.resizable) {
                win.resizable({
                    handles: 'se',
                    minWidth: 350,
                    minHeight: 120,
                    resize: function () {
                        // use another event to avoid recursion in fullscreen mode
                        // may be there is clever solution, but i cant find it :(
                        preview.trigger('changesize');
                    }
                });
            }
            $.each(plugins || [], function (i, plugin) {
                if (typeof(plugin) == 'function') {
                    new plugin(self)
                }
            });

            preview.bind('update', function () {
                self.info.show();
            });
        },
        buildRenderingEmbedded: function () {
            var self = this,
                navicon = this.navicon,
                container = this.container ? $(this.container) : null,
                title = $('<div class="elfinder-quicklook-title" style="display: none">' + self.title + '</div>'),
                icon = $('<div/>'),
                info = $('<div class="elfinder-quicklook-info"/>');//.hide(),


            self.openDfd = new Deferred();

            self.fsicon = $('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrows-alt"/>')
                .mousedown(function (e) {
                    var win = self.window,
                        full = win.is('.' + self.fullscreen),
                        scroll = "scroll.elfinder-finder",
                        $window = $(window);

                    e.stopPropagation();

                    if (full) {
                        win.css(win.data('position')).unbind('mousemove');
                        $window.unbind(scroll).trigger(self.resize).unbind(self.resize);
                        self.navbar.unbind('mouseenter').unbind('mousemove');
                    } else {

                        win.data('position', {
                            left: win.css('left'),
                            top: win.css('top'),
                            width: win.width(),
                            height: win.height()
                        }).css({
                            width: '100%',
                            height: '100%'
                        });

                        $(window).bind(scroll, function () {
                                win.css({
                                    left: parseInt($(window).scrollLeft()) + 'px',
                                    top: parseInt($(window).scrollTop()) + 'px'
                                })
                            })
                            .bind(self.resize, function (e) {
                                self.preview.trigger('changesize');
                            })
                            .trigger(scroll)
                            .trigger(self.resize);

                        win.bind('mousemove', function (e) {
                                self.navbar.stop(true, true).show().delay(3000).fadeOut('slow');
                            })
                            .mousemove();

                        self.navbar.mouseenter(function () {
                                self.navbar.stop(true, true).show();
                            })
                            .mousemove(function (e) {
                                e.stopPropagation();
                            });
                    }

                    self.navbar.attr('style', '').draggable(full ? 'destroy' : {});
                    win.toggleClass(self.fullscreen);
                    $(this).toggleClass(navicon + '-fullscreen-off');
                    if (!parent) {
                        parent = $('.xapp');
                    }
                });

            self.navbar = $('<div class="" style="display: none;"/>');
            self.preview = $('<div class="elfinder-quicklook-preview ui-helper-clearfix"/>')
            // clean info/icon
                .bind('change', function (e) {
                    self.info.attr('style', '').hide();
                    icon.removeAttr('class').attr('style', '');
                    info.html('');

                })
                // update info/icon
                .bind('update', function (e) {
                    var fm = self.fm,
                        preview = self.preview,
                        file = e.file,
                        tpl = '<div class="elfinder-quicklook-info-data">{value}</div>',
                        tmb;

                    if (file) {
                        !file.read && e.stopImmediatePropagation();
                        //self.window.data('hash', file.path);
                        self.preview.unbind('changesize').trigger('change').children().remove();
                        self.info.delay(100).fadeIn(10);

                    } else {
                        e.stopImmediatePropagation();
                    }
                });


            self.info = $('<div class="elfinder-quicklook-info-wrapper"/>')
                .append(icon)
                .append(info);


            self.window = $('<div id="' + self.id + '" class="ui-helper-reset ui-widget elfinder-quicklook widget bg-opaque" style=""/>')
                .click(function (e) {
                    e.stopPropagation();
                })
                .append(self.preview)
                .append(self.info.hide())
                .bind('open', function (e) {
                    self._open = true;
                    var win = self.window,
                        file = self.value,
                        node = self.node;

                    if (self.closed()) {
                        self.update(1, self.value);
                        self.navbar.attr('style', '');
                        self.state = animated;
                        node && node.trigger('scrolltoview');
                        win.css(self.closedCss(node))
                            .show()
                            .animate(self.openedCss(), 550, function () {
                                self.state = opened;
                                self.update(2, self.value);
                                self.openDfd.resolve();
                            });
                    }
                })
                .bind('close', function (e) {
                    var win = self.window,
                        preview = self.preview.trigger('change'),
                        file = self.value,
                        node = {},
                        close = function () {
                            self._open = false;
                            self.state = closed;
                            win.hide();
                            preview.children().remove();
                            self.update(0, self.value);

                        };

                    if (self.opened()) {
                        state = animated;
                        win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                        node.length
                            ? win.animate(self.closedCss(node), 500, close)
                            : close();
                    }
                });

            if (container) {
                container.append(self.window);
            }
            var support = this.supportTest;
            self.support = {

                audio: {
                    ogg: support('audio/ogg; codecs="vorbis"'),
                    mp3: support('audio/mpeg;'),
                    wav: support('audio/wav; codecs="1"'),
                    m4a: support('audio/x-m4a;') || support('audio/aac;')
                },
                video: {
                    ogg: support('video/ogg; codecs="theora"'),
                    webm: support('video/webm; codecs="vp8, vorbis"'),
                    mp4: support('video/mp4; codecs="avc1.42E01E"') || support('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')
                }
            };


        },
        buildRendering: function () {
            var self = this,
                navicon = this.navicon,
                container = this.container ? $(this.container) : null,
                title = $('<div class="elfinder-quicklook-title">' + self.title + '</div>'),
                icon = $('<div/>'),
                info = $('<div class="elfinder-quicklook-info"/>');//.hide(),


            self.openDfd = new Deferred();

            self.fsicon = $('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrows-alt"/>')
                .mousedown(function (e) {
                    var win = self.window,
                        full = win.is('.' + self.fullscreen),
                        scroll = "scroll.elfinder-finder",
                        $window = $(window);

                    e.stopPropagation();

                    if (full) {
                        win.css(win.data('position')).unbind('mousemove');
                        $window.unbind(scroll).trigger(self.resize).unbind(self.resize);
                        self.navbar.unbind('mouseenter').unbind('mousemove');
                    } else {

                        win.data('position', {
                            left: win.css('left'),
                            top: win.css('top'),
                            width: win.width(),
                            height: win.height()
                        }).css({
                            width: '100%',
                            height: '100%'
                        });

                        $(window).bind(scroll, function () {
                                win.css({
                                    left: parseInt($(window).scrollLeft()) + 'px',
                                    top: parseInt($(window).scrollTop()) + 'px'
                                })
                            })
                            .bind(self.resize, function (e) {
                                self.preview.trigger('changesize');
                            })
                            .trigger(scroll)
                            .trigger(self.resize);

                        win.bind('mousemove', function (e) {
                                self.navbar.stop(true, true).show().delay(3000).fadeOut('slow');
                            })
                            .mousemove();

                        self.navbar.mouseenter(function () {
                                self.navbar.stop(true, true).show();
                            })
                            .mousemove(function (e) {
                                e.stopPropagation();
                            });
                    }

                    self.navbar.attr('style', '').draggable(full ? 'destroy' : {});
                    win.toggleClass(self.fullscreen);
                    $(this).toggleClass(navicon + '-fullscreen-off');
                    if (!parent) {
                        parent = $('.xapp');
                    }
                });


            self.navbar = $('<div class="elfinder-quicklook-navbar"/>')
                .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-left"/>').mousedown(function () {
                    self.navtrigger(37);
                }))
                .append(self.fsicon)
                .append($('<div class="' + navicon + ' ' + navicon + ' fa-2x fa-arrow-right"/>').mousedown(function () {
                    self.navtrigger(39);
                }))
                .append('<div class="elfinder-quicklook-navbar-separator"/>')
                .append($('<div class="' + navicon + ' ' + navicon + '-close"/>').mousedown(function () {
                    self.window.trigger('close');
                }));


            self.preview = $('<div class="elfinder-quicklook-preview ui-helper-clearfix"/>')
            // clean info/icon
                .bind('change', function (e) {
                    self.info.attr('style', '').hide();
                    icon.removeAttr('class').attr('style', '');
                    info.html('');
                })
                // update info/icon
                .bind('update', function (e) {
                    var fm = self.fm,
                        preview = self.preview,
                        file = e.file,
                        tpl = '<div class="elfinder-quicklook-info-data">{value}</div>',
                        tmb;

                    if (file) {
                        !file.read && e.stopImmediatePropagation();
                        //self.window.data('hash', file.path);
                        self.preview.unbind('changesize').trigger('change').children().remove();
                        self.info.delay(100).fadeIn(10);

                    } else {
                        e.stopImmediatePropagation();
                    }
                });

            self.info = $('<div class="elfinder-quicklook-info-wrapper"/>')
                .append(icon)
                .append(info);


            self.window = $('<div id="' + self.id + '" class="ui-helper-reset ui-widget elfinder-quicklook widget bg-opaque" style="position:absolute"/>')
                .click(function (e) {
                    e.stopPropagation();
                })
                .append(
                    $('<div class="elfinder-quicklook-titlebar"/>')
                        .append(title)
                        .append($('<span class="fa-close" style="margin-left: 4px; color: white; font-size: 16px; text-align: center; position: absolute; left: 0px; top: 2px;"/>').mousedown(function (e) {
                                e.stopPropagation();
                                self.window.trigger('close');
                            }
                            )
                        )
                )
                .append(self.preview.add(self.navbar))
                .append(self.info.hide())
                .draggable({handle: 'div.elfinder-quicklook-titlebar'})
                .bind('open', function (e) {

                    self._open = true;

                    var win = self.window,
                        file = self.value,
                        node = self.node;

                    if (self.closed()) {
                        self.update(1, self.value);
                        self.navbar.attr('style', '');
                        self.state = animated;
                        node.trigger('scrolltoview');
                        win.css(self.closedCss(node))
                            .show()
                            .animate(self.openedCss(), 550, function () {
                                self.state = opened;
                                self.update(2, self.value);
                                self.openDfd.resolve();
                            });
                    }
                })
                .bind('close', function (e) {

                    var win = self.window,
                        preview = self.preview.trigger('change'),
                        file = self.value,
                        node = {},
                        close = function () {
                            self._open = false;
                            self.state = closed;
                            win.hide();
                            preview.children().remove();
                            self.update(0, self.value);

                        };

                    if (self.opened()) {
                        state = animated;
                        win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                        node.length
                            ? win.animate(self.closedCss(node), 500, close)
                            : close();
                    }
                });


            if (container) {
                container.append(self.window);
            }
            var support = this.supportTest;
            self.support = {

                audio: {
                    ogg: support('audio/ogg; codecs="vorbis"'),
                    mp3: support('audio/mpeg;'),
                    wav: support('audio/wav; codecs="1"'),
                    m4a: support('audio/x-m4a;') || support('audio/aac;')
                },
                video: {
                    ogg: support('video/ogg; codecs="theora"'),
                    webm: support('video/webm; codecs="vp8, vorbis"'),
                    mp4: support('video/mp4; codecs="avc1.42E01E"') || support('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')
                }
            };


        },
        constructor: function (args) {
            utils.mixin(this, args);
        },
        editorOptions: {
            permissions: [
                types.ACTION.TOOLBAR,
                types.ACTION.RELOAD,
                'Editor/Settings',
                'View/Increase Font Size',
                'View/Decrease Font Size',
                'View/Themes',
                'File/Search'
            ]
        },
        title: 'Preview',
        /**
         * Opened window width (from config)
         *
         * @type Number
         **/
        width: 450,
        /**
         * Opened window height (from config)
         *
         * @type Number
         **/
        height: 300,
        fm: null,
        /**
         * window state
         *
         * @type Number
         **/
        state: 0,
        /**
         * navbar icon class
         *
         * @type Number
         **/
        navicon: 'elfinder-quicklook-navbar-icon',
        /**
         * navbar "fullscreen" icon class
         *
         * @type Number
         **/
        fullscreen: 'elfinder-quicklook-fullscreen',
        /**
         * elFinder node
         *
         * @type jQuery
         **/
        parent: null,
        /**
         * elFinder current directory node
         *
         * @type jQuery
         **/

        cwd: null,
        resize: "resize.elfinder-finder",
        /**
         * This command cannot be disable by backend
         *
         * @type Boolean
         **/
        alwaysEnabled: true,
        /**
         * Selected file
         *
         * @type Object
         **/
        value: null,
        handlers: {
            // save selected file
            select: function () {
                this.update(void(0), this.fm.selectedFiles()[0]);
            },
            error: function () {
                self.window.is(':visible') && self.window.data('hash', '').trigger('close');
            },
            'searchshow searchhide': function () {
                this.opened() && this.window.trigger('close');
            }
        },
        shortcuts: [
            {
                pattern: 'space'
            }
        ],
        /**
         * Triger keydown/keypress event with left/right arrow key code
         *
         * @param  Number  left/right arrow key code
         * @return void
         **/
        navtrigger: function (code) {
            $(document).trigger($.Event('keydown', {
                keyCode: code,
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false
            }));
        },
        /**
         * Return css for closed window
         *
         * @param  jQuery  file node in cwd
         * @return void
         **/
        closedCss: function (node) {
            return {
                opacity: 0,
                width: 20,//node.width(),
                height: 20,
                top: node ? node.offset().top + 'px' : 0,
                left: node ? node.offset().left + 'px' : 0
            }
        },
        /**
         * Return css for opened window
         *
         * @return void
         **/
        openedCss: function () {

            var container = this.container ? $(this.container) : null,
                win = container || $(window);

            var w = container ? "100%" : Math.min(this.width, win.   width() - 10);
            var h = container ? "100%" : Math.min(this.height, win.height() - 80);
            return {
                opacity: 1,
                width: w,
                height: h,
                top: parseInt((win.height() - h - 60) / 2 + win.scrollTop()),
                left: parseInt((win.width() - w) / 2 + win.scrollLeft())
            }
        },
        supportTest: function (codec) {
            var media = document.createElement(codec.substr(0, codec.indexOf('/'))),
                value = false;

            try {
                value = media.canPlayType && media.canPlayType(codec);
            } catch (e) {

            }

            return value && value !== '' && value != 'no';
        },
        changeView: function (item) {
            if (this.currentView) {
                utils.destroy(this.currentView);
                if (this.currentView.destroy) {
                    this.currentView.destroy();
                }
            }
        },
        update: function (state) {
            this._open = state;
            this._emit('changeState', state);
            if (state == animated && this.onAnimate) {
                this.onAnimate();
            }
            if (state == opened && this.onOpened) {
                this.onOpened();
            }
            if (state == closed && this.onClosed) {
                this.onClosed();
            }
        },
        /**
         * Return true if quickLoock window is visible and not animated
         *
         * @return Boolean
         **/
        closed: function () {
            return this.state == closed;
        },
        /**
         * Return true if quickLoock window is hidden
         *
         * @return Boolean
         **/
        opened: function () {
            return this.state == opened;
        },
        /**
         * Attach listener to events
         * To bind to multiply events at once, separate events names by space
         *
         * @param  String  event(s) name(s)
         * @param  Object  event handler
         * @return elFinder
         */
        bind: function (event, callback) {
            var i;
            if (typeof(callback) == 'function') {
                event = ('' + event).toLowerCase().split(/\s+/);

                for (i = 0; i < event.length; i++) {
                    if (listeners[event[i]] === void(0)) {
                        listeners[event[i]] = [];
                    }
                    listeners[event[i]].push(callback);
                }
            }
            return this;
        },
        one: function (event, callback) {
            var self = this,
                h = $.proxy(callback, function (event) {
                    setTimeout(function () {
                        self.unbind(event.type, h);
                    }, 3);
                    return callback.apply(this, arguments);
                });
            return this.bind(event, h);
        },
        open: function (e) {
            var self = this,
                win = self.window,
                file = self.value,
                node = self.node;
            self._open = true;
            self.openDfd = new Deferred();
            if (self.closed()) {

                self.navbar.attr('style', '');
                self._open = true;
                self.state = animated;
                node && node.trigger('scrolltoview');
                win.css(self.closedCss(node))
                    .show()
                    .animate(self.openedCss(), 550, function () {
                        self.state = opened;
                        self.update(1, self.value);
                        self.openDfd.resolve();
                    });
            } else {
                self.openDfd.resolve();
            }
            return self.openDfd;
        },
        close: function (e) {
            this._open = false;
            var self = this,
                win = self.window,
                preview = self.preview.trigger('change'),
                file = self.value,
                node = self.node,
                close = function () {
                    self.state = closed;
                    win.hide();
                    preview.children().remove();
                    self.update(0, self.value);
                    self.closeDfd && self.closeDfd.resolve();
                };

            if (self.opened()) {
                self.state = animated;
                win.is('.' + self.fullscreen) && self.fsicon.mousedown();
                node && node.length
                    ? win.animate(self.closedCss(node), 500, close)
                    : close();
            }


            return self.closeDfd;
        },
        getstate: function () {
            return this.state == opened ? 1 : 0;
        },

        exec: function () {
            this.window.trigger(this.opened() ? 'close' : 'open');
        },
        hideinfo: function () {
            this.info.stop(true).hide();
        }
    });
    var filePreviewClass = dcl(previewClass, {
        destroy: function () {
            this.close();
            this.preview.trigger($.Event('update', {file: null}));
            this.inherited(arguments);
            utils.destroy(this._editor);
            utils.destroy(this.preview);
            utils.destroy(this.window);

        },
        onOpened: function () {
            var self = this;
            self.fm = {
                url: function (what, cache, params) {
                    return self.delegate.getImageUrl(what, cache, params);
                }
            }
            self.preview.trigger($.Event('update', {file: self.item}));
        },
        onClosed: function () {
        },
        onAnimate: function () {
        }
    });

    var editorClass = dcl(filePreviewClass, {
        resize: function () {
            this.preview.trigger('changesize');
        },
        constructor: function (args) {
            this.parent = $(args._parent.containerNode);
            this.container = args._parent.containerNode;
            this.resizeToParent = true;
            this.delegate = args.ctx.getFileManager();
            this.item = args.item;
            this.buildRenderingEmbedded();
            console.log('this',this);
            this.domNode = this.info[0];
        },
        openItem: function (item) {
            this.id = utils.createUUID();
            registry.add(this);
            this.item = item || this.item;

            this.init();
            this.exec();
            this.window.css({
                height: '100%',
                width: '100%'
            });
            this._parent.add(this, null, false);
            this.preview.trigger($.Event('update', {file: this.item}));
            this._parent.resize();
            this.resize();
        }
    });

    filePreviewClass.EditorClass = editorClass;
    return filePreviewClass;

});
/** @module xide/container/_ContainerBase **/
define('xide/container/_PaneBase',[
    "xdojo/has",
    "dcl/dcl",
    'xide/utils',
    "xide/_base/_Widget"
], function (has,dcl,utils,_Widget) {

    var Module = dcl(_Widget,{
        templateString:'<div/>',
        isContainer:true,
        declaredClass:'xide/container/_PaneBase',
        panelNode:null,
        selected:false,
        $toggleNode:null,
        $toggleButton:null,
        lazy:true,
        add:dcl.superCall(function(sup) {
            return function (mixed,options,parent,startup) {
                if(this.lazy && (mixed.allowLazy!==false && (options ? options.allowLazy!==false : true))){
                    startup = false;
                }
                return sup.apply(this, [mixed,options,parent,startup]);
            }
        }),
        addChild:function(what,mixed,startup){
            this.add(what,mixed);
            what.domNode && utils.addChild(this.containerNode,what.domNode);
            if(startup!==false && !what._started && what.startup){
                what.startup();
            }
        },
        unselect:function(){
            this.$toggleButton && this.$toggleButton.removeClass('active');
            this.$selectorNode && this.$selectorNode.removeClass('active');
            this.$containerNode && this.$containerNode.removeClass('active');
            this.selected = false;
        },
        select:function(){
            this.$toggleButton && this.$toggleButton.addClass('active');
            this.$selectorNode && this.$selectorNode.addClass('active');
            this.$containerNode && this.$containerNode.addClass('active');
            this._onShown();
            this.onSelect && this.onSelect();
        },
        destroy:function(){
            utils.destroy(this.$toggleButton[0]);
            utils.destroy(this.$containerNode[0]);
        },
        _checkWidgets:function(){},
        _onShown:function(){
            this.selected = true;
            this._startWidgets();
            this.resize();
            this.onShow();
            this.onSelect && this.onSelect();
            var thiz = this;
            setTimeout(function(){
                thiz.owner && thiz.owner.onShowTab(thiz);
            },1);
            this._emit('show',this);
        },
        _onShow:function(){
            this.selected = true;
            this.resize();
        },
        shouldResizeWidgets:function(){
            return this.selected;
        },
        _onHide:function(){
            this.selected = false;
            this.open = false;
            this.onHide();
        },
        _onHided:function(){
            this.open = false;
            this._emit('hide',{
                view:this
            });
        },
        hide:function(){
            var container = $(this.containerRoot),
                toggleNode= $(this.toggleNode);

            toggleNode.addClass('collapsed');
            toggleNode.attr('aria-expanded',false);
            container.removeClass('collapse in');
            container.addClass('collapse');
            container.attr('aria-expanded',false);
            this.open = false;
        },
        show:function(){
            var container = $(this.containerRoot),
                toggleNode = $(this.toggleNode);

            toggleNode.removeClass('collapsed');
            toggleNode.attr('aria-expanded',true);
            container.removeClass('collapse');
            container.addClass('collapse in');
            container.attr('aria-expanded',true);
            this.open = true;
        },
        getChildren:function(){
            //xmaqadd
            !this._widgets && (this._widgets = []);
            return this._widgets;
        },
        postMixInProperties:function(){
            var active = this.selected ? 'active' : '';
            this.templateString = '<div attachTo="containerNode" style="height:100%;width:100%;position:relative;" class="tab-pane ' + active + '"></div>';
        },
        __init:function(){
            var panel = this.$toggleNode;
            this.__addHandler(panel,'hidden.bs.tab','_onHided');
            this.__addHandler(panel,'hide.bs.tab','_onHide');
            this.__addHandler(panel,'shown.bs.tab','_onShown');
            this.__addHandler(panel,'show.bs.tab','_onShow');
        }
    });

    dcl.chainAfter(Module, "postMixInProperties");
    dcl.chainAfter(Module, "resize");
    dcl.chainAfter(Module, "show");

    return Module;

});
/** @module xide/layout/_TabContainer **/
define('xide/layout/_TabContainer',[
    'dcl/dcl',
    'xide/utils',
    'xide/_base/_Widget',
    'xide/container/_PaneBase',
    'xide/$',
    'xide/lodash'
], function (dcl, utils, _Widget, _PaneBase, $, _) {
    var TabPaneClass = dcl(_PaneBase, {
        declaredClass: 'xide/layout/_TabPane',
        postMixInProperties: function () {
            this.templateString = '<div attachTo="containerNode" style="height:inherit;width:inherit;position:relative;" class="tab-pane ' + (this.selected ? 'active' : '') + '"></div>';
        },
        __init: function () {
            var panel = this.$toggleNode;
            this.__addHandler(panel, 'hidden.bs.tab', '_onHided');
            this.__addHandler(panel, 'hide.bs.tab', '_onHide');
            this.__addHandler(panel, 'shown.bs.tab', '_onShown');
            this.__addHandler(panel, 'show.bs.tab', '_onShow');
        }
    });

    var TabContainer = dcl(_Widget, {
        declaredClass: 'xide/layout/_TabContainer',
        tabClass: TabPaneClass,
        tabs: null,
        tabBar: null,
        tabContentNode: null,
        padding: '0px',
        containerCSSClass: '',
        direction: 'above',
        navBarClass: '',
        templateString: '<div class="${!containerCSSClass} tabbable tabs-${!direction}" style="height: inherit;" attachTo="containerNode">' +
        '<ul attachTo="tabBar" class="nav nav-tabs" role="tablist" />' +
        '<div attachTo="tabContentNode" style="width: inherit; height: 100%;" class="tab-content"/>' +
        '</div>',
        getTab: function (name) {
            return _.find(this._widgets, {
                title: name
            });
        },
        _unselectAll: function () {
            _.each(this._widgets, function (tab) {
                tab.unselect();
            });
        },
        onShowTab: function (tab) {
            this._emit('selectChild', tab);
        },
        getSelected: function () {
            for (var i = 0; i < this.tabs.length; i++) {
                var obj = this.tabs[i];
                if (obj.pane.selected) {
                    return obj.pane;
                }
            }
        },
        selectChild: function (mixed) {
            var tab = mixed;
            if (mixed !== null) {
                if (_.isString(mixed)) {
                    tab = this.getTab(mixed);
                } else if (_.isNumber(mixed)) {
                    tab = this._widgets[0];
                }
                if (tab && tab.select) {
                    this._unselectAll();
                    tab.select();
                }
            }
            return tab;
        },
        addWidget: function (widgetProto, ctrArgsIn, delegate, parent, startup, cssClass, baseClasses, select, classExtension) {
            var target = parent;
            if (!widgetProto.isContainer) {
                target = this._createTab(this.tabClass, {
                    title: ctrArgsIn.title,
                    icon: ctrArgsIn.icon,
                    selected: ctrArgsIn.selected,
                    ignoreAddChild: true
                });
            }
            return target;
        },
        resize: function () {
            if (this.tabBar) {
                switch (this.direction) {
                    case 'left':
                    case 'right': {
                        this.$tabContentNode.css('width', '');
                        break;
                    }
                    case 'above':
                    case 'below': {
                        if (this.$containerNode && this.resizeContainer !== false) {
                            this.$tabContentNode.css('height', this.$containerNode.height() - this.$tabBar.height());
                        }
                        break;
                    }
                }
            }
            _.each(this._widgets, function (w) {
                w.resize();
            });
        },
        _createTab: function (tabClass, options) {
            !this.tabs && (this.tabs = []);
            var active = this.tabs.length == 0 ? 'active' : '',
                icon = options.icon || '',
                title = options.title || '',
                selected = options.selected != null ? options.selected : this.tabs.length == 0;

            var pane = utils.addWidget(tabClass || this.tabClass, {
                title: title,
                icon: icon,
                selected: selected,
                owner: this
            }, null, this.tabContentNode, true);

            var tabId = pane.id,
                iconStr = icon ? ' ' + icon : '',
                toggleNodeStr = '<li class="' + active + '"><a href="#' + tabId + '" data-toggle="tab"><span class="' + iconStr + '"/> ' + title + '</a></li>',
                tabButton = $(toggleNodeStr);

            $(this.tabBar).append(tabButton);
            pane.$toggleNode = tabButton.find('a[data-toggle="tab"]');
            pane.$selectorNode = tabButton.find('li');
            pane.$toggleButton = tabButton;
            pane.__init();
            this.tabs.push({
                id: tabId,
                pane: pane,
                button: tabButton[0]
            });
            this.add(pane, null, false);
            return pane;
        },
        removeChild: function (tab, selectNew) {
            tab = _.isString(tab) ? this.getTab(tab) : tab;
            if (!tab) {
                console.error('invalid child !');
                return;
            }
            //@TODO: no no no:
            tab.destroy();
            if (!this._widgets) {
                this._widgets = [];
            }
            this._widgets.remove(tab);
            if (selectNew !== false) {
                var newTab = this._widgets[this._widgets.length - 1];
                if (newTab) {
                    this.resize();
                    this.selectChild(newTab);
                }
            }
        },
        empty: function () {
            while (this._widgets.length) {
                this.removeChild(this._widgets[0], false);
            }
        },
        postMixInProperties: function () {
            if (this.direction === 'below') {
                this.templateString = '<div class="${!containerCSSClass} tabbable tabs-${!direction}" style="height: inherit;" attachTo="containerNode">' +
                    '<div attachTo="tabContentNode" style="width: inherit; padding:${!padding}; height: 100%;" class="tab-content"/>' +
                    '<ul attachTo="tabBar" class="nav nav-tabs" role="tablist" />' +
                    '</div>';
            }
        },
        createTab: function (title, icon, selected, tabClass, mixin) {
            return this._createTab(tabClass, utils.mixin({
                icon: icon,
                selected: selected,
                title: title
            }, mixin));
        }
    });
    TabContainer.tabClass = TabPaneClass;
    dcl.chainAfter(TabContainer, "postMixInProperties");
    dcl.chainAfter(TabContainer, "resize");
    dcl.chainAfter(TabContainer, "destroy");
    return TabContainer;

});
define('xide/views/CIViewMixin',[
    "dcl/dcl",
    "xdojo/declare",
    "dojo/Stateful",
    'xide/utils',
    'xide/factory',
    'xide/mixins/EventedMixin',
    'xide/layout/_TabContainer',
    'xide/widgets/_Widget',
    'dojo/Deferred',
    "dojo/promise/all",
    'dojo/when'
], function (dcl,declare, Stateful, utils, factory, EventedMixin,_TabContainer,_Widget,Deferred,all,when) {
    var _debug = false;
    var Module = null;
    var Implementation = {
        declaredClass:'xide.views.CIViewMixin',
        widgets: null,
        delegate: null,
        helpNodes: null,
        store: null,
        groups: null,
        groupContainer: null,
        cssClass: 'CIView',
        ciSort:true,
        options: {
        },
        tabContainer: null,
        viewStyle: '',
        tabs: null,
        tabContainerClass:_TabContainer,
        _didRenderCIS:false,
        typeMap:null,
        containerArgs:null,
        getWidgetByType: function (type) {
            for (var i = 0; i < this.widgets.length; i++) {
                var widget = this.widgets[i];
                if (widget.userData.type === type) {
                    return widget;
                }
            }
            return null;
        },
        updateWidget:function(id,prop,value){
            var widget = this.getWidgetById(id);
            if(prop && widget && widget.set){
                widget.set(prop,value);
            }
        },
        getWidgetById: function (id) {
            var result = null;
            _.each(this.widgets,function(widget){
                if (widget.userData && widget.userData.id === id){
                    result=widget;
                }
            });
            return result;
        },
        constructor:function(args){
            utils.mixin(this,args);
        },
        onValueChanged:function(evt){
            this._emit('valueChanged',evt);
        },
        createGroupContainer: function () {
            if (this.tabContainer) {
                return this.tabContainer;
            }
            var tabContainer = utils.addWidget(this.tabContainerClass || _TabContainer,utils.mixin({
                direction:'left',
                style: "min-width:450px;",
                _parent:this,
                resizeToParent:true
            },this.containerArgs),null,this,true);
            this.tabContainer = tabContainer;
            this.add(tabContainer);
            return tabContainer;
        },
        getGroupContainer: function () {
            if (this.groupContainer) {
                return this.groupContainer;
            }
            this.groupContainer = this.createGroupContainer();
            return this.groupContainer;
        },
        createGroupView: function (groupContainer, group,icon,selected) {
            return groupContainer.createTab(group,icon,selected,this.tabContainerClass.tabClass ||  _TabContainer.tabClass);
        },
        attachWidgets: function (data, dstNode,view) {
            var thiz = this;
            dstNode = dstNode || this.domNode;
            var isSingle = !dstNode;
            if(!dstNode && this.tabContainer){
                dstNode = this.tabContainer.containerNode;
            }
            if (!dstNode) {
                console.error('have no parent dstNode!');
                return;
            }
            data = data.reverse();
            for (var i = 0; i < data.length; i++) {
                var widget = data[i];
                widget.delegate = this.owner || this;
                dstNode.appendChild(widget.domNode);
                var ci = widget.userData;
                _debug && console.log('attach widget ',widget);
                if(view && view.lazy===true) {
                    widget._startOnShow = true;
                }else{
                    try {
                        !widget._started && widget.startup();
                    }catch(e){
                        logError(e,'Error starting widget');
                    }
                }
                widget._on('valueChanged',function(evt){
                    evt.view = view;
                    evt.widget = widget;
                    thiz.onValueChanged(evt);
                });
                !widget.__emitted && this._emit('widget',{
                    widget:widget,
                    ci:ci
                });
                widget.__emitted = true;
                this.widgets.indexOf(widget)==-1 && this.widgets.push(widget);
                widget.userData.view=view;
                widget.onAttached && widget.onAttached(view);
                if(view && view.add && view.add(widget)){

                }else{
                    _debug && console.error('view has no add',view);
                    this.add(widget);
                }
            }
        },
        empty: function (destroyHandles) {
            _.each(this.helpNodes,utils.destroy);
            _.each(this.widgets,utils.destroy);
            destroyHandles !==false && this._destroyHandles();
            this.tabs = [];
            this.widgets = [];
        },
        toArray: function (obj) {
            var result = [];
            for (var c in obj) {
                result.push({
                    name: c,
                    value: obj[c]
                });
            }
            return result;
        },
        onRendered:function(){
            var container = this.getGroupContainer();
            if(this.options.select) {
                container.selectChild(this.options.select);
            }else{
                container.selectChild(0);
            }
            container.resize();
        },
        getTypeMap:function(){
        },
        renderGroup:function(container,title,data){
            var view = this.createGroupView(container, title);
            this.tabs.push(view);
            if(this.ciSort) {
                data = data.sort(function (left, right) {
                    var a = left.order || 0;
                    var b = right.order || 0;
                    return a > b ? -1 : 1;
                });
            }
            var groupDfd = factory.createWidgetsFromArray(data, this, null, false,this.getTypeMap(),!this.ciSort),
                thiz  = this;

            when(groupDfd,function(widgets){
                if (widgets) {
                    _debug && console.log('render group : ' + title,[data,widgets]);
                    thiz.attachWidgets(widgets,view.containerNode,view);
                }
            });

            return groupDfd;
        },
        renderGroups: function (groups) {
            var groupContainer = this.getGroupContainer(),
                _array = groups,
                thiz = this,
                dfd = new Deferred(),
                promises = [];

            this.widgets=[];
            this.helpNodes = [];
            for (var i = 0; i < _array.length; i++) {
                try {
                    var groupDfd = this.renderGroup(groupContainer,_array[i].name,_array[i].value);
                    promises.push(groupDfd);
                } catch (e) {
                    logError(e);
                }
            }
            all(promises).then(function(){
                groupContainer.resize();
                thiz.onRendered();
                dfd.resolve();
            });
            return dfd;
        },
        getCIS: function () {
            return this.data;
        },
        initWithCIS: function (data) {
            if(this._didRenderCIS){
                return null;
            }
            this._didRenderCIS = true;
            this.empty(false);
            data = data || this.cis;
            data = utils.flattenCIS(data);
            this.data = data;
            var head = null,
                thiz = this,
                groups = _.groupBy(data,function(obj){
                    return obj.group;
                }),
                groupOrder = this.options.groupOrder || {};

            var groupsToRender = [];
            groups = this.toArray(groups);

            //filter groups for visible CIs
            _.each(groups,function(group){
                _.find(group.value,{visible:true}) && groupsToRender.push(group);
            });
            groups = groupsToRender;
            var grouped = _.sortByOrder(groups, function(obj){
                return groupOrder[obj.name] || 100;
            });

            if (grouped != null && grouped.length > 1) {
                head = this.renderGroups(grouped);
            } else {
                head = factory.createWidgetsFromArray(data, thiz, null, false,this.getTypeMap(),!this.ciSort);
                when(head,function(widgets){
                    thiz.widgets = widgets;
                    _debug && console.log('attach widgets',widgets);
                    if (widgets) {
                        thiz.attachWidgets(widgets);
                    }
                });
            }
            head.then(function(){
                _.invoke(thiz.widgets,'onDidRenderWidgets',thiz,thiz.widgets);
            });
            return head;
        },
        destroy:function(){
            Module.release(this.cis);
            delete this.helpNodes;
            this.delegate = null;
            this.cis=null;
            this.data=null;
            this.groupContainer=null;
            this.tabContainer=null;
            delete this.tabs;
            this.owner = null;
            this.storeItem = null;
            this.storeDelegate = null;

        }
    };
    Module = declare("xide.views.CIViewMixin", [_Widget,EventedMixin],Implementation);
    Module.dcl = dcl([_Widget.dcl,EventedMixin.dcl],Implementation);
    Module.release = function(cis){
        cis = _.map(cis, function (ci) {
            ci.view = null;
            ci._widget = null;
            ci.options = null;
            delete ci.view;
            delete ci._widget;
            delete ci.options;
            return ci;
        });
        return cis;
    }
    return Module;
});
define('xide/views/CIView',[
    "dcl/dcl",
    'xide/views/CIViewMixin',
    'xide/_base/_Widget'
], function (dcl,CIViewMixin,_Widget) {
    var Module = dcl([_Widget, CIViewMixin.dcl], {
        templateString:'<div class="CIView"></div>',
        data: null,
        widgets: null,
        delegate: null,
        helpNodes: null,
        store: null,
        groups: null,
        groupContainer: null,
        cssClass: 'CIView',
        options: null,
        tabContainerStyle: null,
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (a.name && b.name && groupMap[a.name] != null && groupMap[b.name] != null) {
                    var orderA = groupMap[a.name];
                    var orderB = groupMap[b.name];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        getElements: function (data, group) {
            var res = [];

            for (var i = 0; i < data.length; i++) {
                var obj = data[i];
                if (obj.group === group) {
                    res.push(obj);
                }
            }
            return res;
        },
        startup: function () {
            if (this.cis) {
                this.startDfd = this.initWithCIS(this.cis);
            }
        }
    });

    Module.release = CIViewMixin.release;
    return Module;
});
/** @module xgrid/Base **/
define('xide/views/_CIDialog',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/views/_Dialog',
    'xide/views/CIView'

], function (dcl,types,utils,_Dialog,CIView) {

    var Module =dcl(_Dialog, {
        declaredClass:'xide/views/_CIDialog',
        type: types.DIALOG_TYPE.INFO,
        size: types.DIALOG_SIZE.SIZE_NORMAL,
        bodyCSS: {
            'height': 'auto',
            'min-height': '200px',
            'padding': '8px',
            'margin-right': '16px'
        },
        cssClass:'bootstrap3-dialog CIDialog',
        failedText:' Failed!',
        successText:': Success!',
        showSpinner:true,
        spinner:'  <span class="fa-spinner fa-spin"/>',
        notificationMessage:null,
        cisView:null,
        getData:function(){
            var cis = this.cisView.getCIS();
            for (var i = 0; i < cis.length; i++) {
                var obj = cis[i];
                if (obj._widget) {
                    delete obj['_widget'];
                }
            }
            return cis;
        },
        getField:function(name){
            var cis = this.cisView.cis,
                ci = utils.getCIByChainAndName(cis,0,name),
                value = ci ? ci.value :null,
                invalid = null;
                if(ci){
                    invalid = ci.invalid == true;
                }
            return invalid ? null : value;
        },
        onShow:function(dlg){
            var cisView = this.cisView,
                self = this;
            cisView.startup();
            this.resize();
            this.startDfd.resolve();
        },
        onReady:function(){},
        message:function(dlg){
            var thiz = dlg.owner;
            //if(!thiz.cis){}
            var cisView = thiz.initWithCIS(thiz.cis);
            thiz.cisView = cisView;
            return $(cisView.domNode);
        },
        initWithCIS: function (cis) {

            cis = cis || [];

            var viewArgs = {
                delegate: this,
                options: {},
                cis: cis.inputs || cis,
                style: 'height:inherit',
                tabContainerStyle: 'height:inherit',
                resizeToParent:true

            },self = this;
            utils.mixin(viewArgs, this.viewArgs);
            var view = utils.addWidget(CIView, viewArgs, this.containerNode, null, false);

            self.onCIValueChanged && view._on('valueChanged',function(e){
                self.onCIValueChanged(e.ci, e.newValue, e.oldValue);
            });

            view._on('widget',function(e){
                self._emit('widget',e);
            });

            this.add(view);
            return view;
        }

    });


    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");
    dcl.chainAfter(Module, "onCIValueChanged");
    dcl.chainAfter(Module, "onShow");


    return Module;

});
/** @module xgrid/Base **/
define('xide/views/_Panel',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    "xide/mixins/EventedMixin",
    "xide/widgets/_Widget",
    'dojo/Deferred',
    'xide/_Popup',
    'xide/registry'
], function (dcl, types, utils, EventedMixin, _Widget, Deferred, _Popup, registry) {

    var Module = dcl([_Widget.dcl, EventedMixin.dcl], {
        containerClass: '',
        type: types.DIALOG_TYPE.WARNING,
        size: types.DIALOG_SIZE.SIZE_WIDE,
        titleBarClass: '',
        panel: null,
        bodyCSS: null,
        startDfd: null,
        _ready: false,
        title: 'No Title',
        /**
         * jsPanelOptions
         * @link http://beta.jspanel.de/api/#defaults
         * @type {object}
         */
        options: null,
        getContentSize: function () {
            return {
                width: '600px',
                height: '500px'
            }
        },
        getDefaultOptions: function (mixin) {
            var self = this;
            var options = {
                "contentSize": this.getContentSize(),
                footerToolbar: [
                    {
                        item: "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event: "click",
                        btnclass: "btn btn-danger btn-sm",
                        btntext: " Cancel",
                        callback: function (event) {
                            event.data.close();
                            self.onCancel();
                        }
                    },
                    {
                        item: "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event: "click",
                        btnclass: "btn btn-primary btn-sm",
                        btntext: " Ok",
                        callback: function (event) {
                            self.onOk();
                            event.data.close();
                        }
                    }
                ]
            };
            utils.mixin(options, mixin);
            return options;
        },
        getInstance: function (args) {
            if (this.panel) {
                return this.panel;
            }
            _Popup.nextZ(3);
            var self = this;
            this.panel = $.jsPanel(utils.mixin({
                zi: _Popup.nextZ(),
                position: {
                    left: 200,
                    top: 100
                },
                title: self.title || 'jsPanel theme info',
                theme: self.theme || 'bootstrap-default',
                onmaximized: function () {
                    self.resize();
                },
                onnormalized: function () {
                    self.resize();
                },
                onbeforeclose: function () {
                    self.destroy(false);
                },
                callback: function (panel) {
                    self.domNode = this.content[0];
                    var thiz = this;
                    self.onshown(this, this.content[0]).then(function () {
                        thiz.content.addClass(self.containerClass);
                        thiz.content.css('tabIndex', 1);
                        thiz.header.addClass(self.type);
                        thiz.footer.addClass('modal-footer');
                        var newZ = _Popup.nextZ();
                        panel.css("z-index", newZ);
                        panel.attr('tabIndex', 1);
                        panel.keyup(function (event) {
                            if (event.which === 27) {
                                self.destroy(true);
                            }
                        });
                        panel.focus();
                    });
                }
            }, args));
            this.panel.on("resize", function () {
                self.resize();
            });
            return this.panel;
        },
        onshown: function (panelInstance, content) {
            var self = this,
                head = new Deferred();
            if (this.onShow) {
                var result = this.onShow(panelInstance, content, this);
                function ready(what) {
                    self.startDfd.resolve(what);
                    self._ready = true;
                    self.resize();
                    head.resolve(what);
                }
                if (result && result.then) {
                    result.then(ready);
                } else if (_.isArray(result)) {
                    _.each(result, function (widget) {
                        self.add(widget, null, false);
                    });
                    ready(result);
                }
            }
            return head;
        },
        onReady: function () {
            var self = this;
            setTimeout(function () {
                self._ready = true;
            }, 100);
        },
        destroy: function (destroyPanel) {
            try {
                destroyPanel !== false && this.panel && this.panel.close();
                registry.remove(this.panel.id);
                //destroy
                if (this.headDfd) {
                    this.headDfd.resolve(false);
                }
            } catch (e) {
                logError(e, 'panel close');
            }
        },
        show: function (options) {
            var self = this;
            this.headDfd = new Deferred();
            if (!this.startDfd) {
                this.startDfd = new Deferred();
                this.startDfd.then(function () {
                    self.onReady();
                });
            }
            this.panel = this.getInstance(options || this.options);
            return this.headDfd;
        },
        constructor: function (args) {
            args = args || {};
            this.options = args.options || this.options || this.getDefaultOptions();
            utils.mixin(this, args);
        },
        onOk: function () {
            this.headDfd.resolve(true);
        },
        onCancel: function () {
            this.headDfd.resolve(false);
        }
    });


    dcl.chainAfter(Module, "onReady");
    dcl.chainAfter(Module, "onOk");
    dcl.chainAfter(Module, "onCancel");
    dcl.chainAfter(Module, "resize");

    return Module;

});
/** @module xgrid/Base **/
define('xide/views/_PanelDialog',[
    "dcl/dcl",
    'xide/utils',
    'xide/views/_Panel'
], function (dcl,utils,_Panel,CIView) {

    var Module = dcl(_Panel,{
        containerClass:'CIDialog',
        getDefaultOptions:function(mixin){
            var self = this;
            var options = {
                "contentSize": this.contentSize,
                footerToolbar:[
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-danger btn-sm",
                        btntext:  " Cancel",
                        callback: function( event ){
                            event.data.close();
                            self.onCancel();
                        }
                    },
                    {
                        item:     "<button style='margin-left:5px;' type='button'><span class='...'></span></button>",
                        event:    "click",
                        btnclass: "btn btn-primary btn-sm",
                        btntext:  " Ok",
                        callback: function( event ){
                            self.onOk(self.changedCIS);
                            event.data.close();
                        }
                    }
                ]
            };
            utils.mixin(options,mixin);
            return options;
        },
        onShow:function(panel,contentNode,instance){

        }
    });

    dcl.chainAfter(Module,"onShow");
    return Module;
});
define('wcDocker/types',["xide/types","xide/utils"], function (types,utils) {

    //stub
    var wcDocker = {};

    /**
     * Enumerated Docking positions.
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {String} module:wcDocker.DOCK
     */
    wcDocker.DOCK = {
        /** A floating panel that blocks input until closed */
        MODAL: 'modal',
        /** A floating panel */
        FLOAT: 'float',
        /** Docks to the top of a target or window */
        TOP: 'top',
        /** Docks to the left of a target or window */
        LEFT: 'left',
        /** Docks to the right of a target or window */
        RIGHT: 'right',
        /** Docks to the bottom of a target or window */
        BOTTOM: 'bottom',
        /** Docks as another tabbed item along with the target */
        STACKED: 'stacked'
    };

    /**
     * Enumerated Layout wcDocker.
     * @memberOf module:wcDocker
     * @version 3.0.0
     * @enum {String} module:wcDocker.LAYOUT
     */
    wcDocker.LAYOUT = {
        /** Contains a single div item without management using a {@link module:wcLayoutSimple}, it is up to you to populate it however you wish. */
        SIMPLE: 'wcLayoutSimple',
        /** Manages a table grid layout using {@link module:wcLayoutTable}, this is the default layout used if none is specified. **/
        TABLE: 'wcLayoutTable'
    };

    /**
     * Enumerated Internal events
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {String} module:wcDocker.EVENT
     */
    wcDocker.EVENT = {
        /** When the panel is initialized */
        INIT: 'panelInit',
        /** When all panels have finished loading */
        LOADED: 'dockerLoaded',
        /** When the panel is updated */
        UPDATED: 'panelUpdated',
        /**
         * When the panel has changed its visibility<br>
         * This event is called with the current visibility state as the first parameter.
         */
        VISIBILITY_CHANGED: 'panelVisibilityChanged',
        /** When the user begins moving any panel from its current docked position */
        BEGIN_DOCK: 'panelBeginDock',
        /** When the user finishes moving or docking a panel */
        END_DOCK: 'panelEndDock',
        /** When the user brings any panel within a tabbed frame into focus */
        GAIN_FOCUS: 'panelGainFocus',
        /** When the user leaves focus on any panel within a tabbed frame */
        LOST_FOCUS: 'panelLostFocus',
        /** When the panel is about to be closed, but before it closes. If any event handler returns a falsey value, the close action will be canceled. */
        CLOSING: 'panelClosing',
        /** When the panel is being closed */
        CLOSED: 'panelClosed',
        /** When a persistent panel is being hidden */
        PERSISTENT_CLOSED: 'panelPersistentClosed',
        /** When a persistent panel is being shown */
        PERSISTENT_OPENED: 'panelPersistentOpened',
        /** When a custom button is clicked, See [wcPanel.addButton]{@link module:wcPanel~addButton} */
        BUTTON: 'panelButton',
        /** When the panel has moved from floating to a docked position */
        ATTACHED: 'panelAttached',
        /** When the panel has moved from a docked position to floating */
        DETACHED: 'panelDetached',
        /**
         * When the user has started moving the panel (top-left coordinates changed)<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVE_STARTED: 'panelMoveStarted',
        /**
         * When the user has finished moving the panel<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVE_ENDED: 'panelMoveEnded',
        /**
         * When the top-left coordinates of the panel has changed<br>
         * This event is called with an object of the current {x, y} position as the first parameter.
         */
        MOVED: 'panelMoved',
        /**
         * When the user has started resizing the panel (width or height changed)<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZE_STARTED: 'panelResizeStarted',
        /**
         * When the user has finished resizing the panel<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZE_ENDED: 'panelResizeEnded',
        /**
         * When the panels width or height has changed<br>
         * This event is called with an object of the current {width, height} size as the first parameter.
         */
        RESIZED: 'panelResized',
        /** This only happens with floating windows when the order of the windows have changed. */
        ORDER_CHANGED: 'panelOrderChanged',
        /** When the contents of the panel has been scrolled */
        SCROLLED: 'panelScrolled',
        /** When the layout is being saved, See [wcDocker.save]{@link module:wcDocker#save} */
        SAVE_LAYOUT: 'layoutSave',
        /** When the layout is being restored, See [wcDocker.restore]{@link module:wcDocker#restore} */
        RESTORE_LAYOUT: 'layoutRestore',
        /** When the current tab on a custom tab widget associated with this panel has changed, See {@link module:wcTabFrame} */
        CUSTOM_TAB_CHANGED: 'customTabChanged',
        /** When a tab has been closed on a custom tab widget associated with this panel, See {@link module:wcTabFrame} */
        CUSTOM_TAB_CLOSED: 'customTabClosed',
        BEGIN_FLOAT_RESIZE: 'beginFloatResize',
        END_FLOAT_RESIZE: 'endFloatResize',
        BEGIN_RESIZE:"beginResize",
        END_RESIZE:"endResize"
    };

    /**
     * The name of the placeholder panel.
     * @private
     * @memberOf module:wcDocker
     * @constant {String} module:wcDocker.PANEL_PLACEHOLDER
     */
    wcDocker.PANEL_PLACEHOLDER = '__wcDockerPlaceholderPanel';

    /**
     * Used when [adding]{@link module:wcDocker#addPanel} or [moving]{@link module:wcDocker#movePanel} a panel to designate the target location as collapsed.<br>
     * Must be used with [docking]{@link module:wcDocker.DOCK} positions LEFT, RIGHT, or BOTTOM only.
     * @memberOf module:wcDocker
     * @constant {String} module:wcDocker.COLLAPSED
     */
    wcDocker.COLLAPSED = '__wcDockerCollapsedPanel';

    /**
     * Used for the splitter bar orientation.
     * @version 3.0.0
     * @memberOf module:wcDocker
     * @enum {Boolean} module:wcDocker.ORIENTATION
     */
    wcDocker.ORIENTATION = {
        /** Top and Bottom panes */
        VERTICAL: false,
        /** Left and Right panes */
        HORIZONTAL: true
    };
    /**
     * Used to determine the position of tabbed widgets for stacked panels.<br>
     * <b>Note:</b> Not supported on IE8 or below.
     * @version 3.0.0
     * @enum {String} module:wcDocker.TAB
     * @memberOf module:wcDocker
     */
    wcDocker.TAB = {
        /** The default, puts tabs at the top of the frame */
        TOP: 'top',
        /** Puts tabs on the left side of the frame */
        LEFT: 'left',
        /** Puts tabs on the right side of the frame */
        RIGHT: 'right',
        /** Puts tabs on the bottom of the frame */
        BOTTOM: 'bottom'
    };

    if(!types.DOCKER){
        types.DOCKER=wcDocker;
    }

    return wcDocker;

});
/** @module wcBase */
define('wcDocker/base',[
    "dcl/dcl",
    "xide/utils"
], function (dcl, utils) {
    /**
     * Base class for all docker classes
     * @class module:wcBase
     */
    return dcl(null, {
        _saveProp: function (what, args) {
            var who = this;
            who['__' + what] = _.isFunction(who[what]) ? who[what]() : who[what];
            args && who[what]!=null && who[what].apply && who[what].apply(who, args);
        },
        _restoreProp: function (what, call) {

            var who = this;

            //this prop also exists
            if (who['_' + what]) {
                who['_' + what] = who['__' + what];
            }
            var _args = who['__' + what];
            if (call !== false) {
                return _.isFunction(who[what]) ? who[what].apply(who, [_args]) : who[what];
            } else {
                return _args;
            }
        },
        debounce: function (methodName, _function, delay, options, now) {
            return utils.debounce(this, methodName, _function, delay, options, now);
        },
        /**
         * Returns this or the docker's options
         * @TODO: better looking through the parents?
         * @function module:wcBase#getOptions
         * @returns {Object|null}
         */
        getOptions: function () {
            return this._options || this.docker()._options || {};
        },

        /**
         * Return an option found in this or in the docker.
         * @function module:wcBase#option
         * @param name
         * @param _default {Object|null}
         * @returns {Object|null}
         */
        option: function(name,_default) {
            return this.getOptions()[name] || _default;
        },

        /**
         * Return a module (dcl) by class name.
         * @param name {string} the class name, for instance "wcPanel", "wcSplitter" and so forth. Please see in wcDocker#defaultClasses for available class names.
         * @returns {object} the dcl module found in options
         * @private
         */
        __getClass: function (name) {
            return this.getOptions()[name + 'Class'];
        },

        /**
         * Class eq function
         * @function module:wcBase#instanceOf
         * @param {string} what
         * @param {object} [who]
         * @returns {boolean}
         */
        instanceOf: function (what, who) {
            who = who || this;
            return !!(who && (who.declaredClass.indexOf(what) != -1));
        },
        /**
         * Retrieves the main [docker]{@link module:wcDocker} instance.
         * @function module:wcBase#docker
         * @returns {module:wcDocker} - The top level docker object.
         */
        docker: function (startNode) {
            var parent = startNode || this._parent;
            while (parent && !(parent.instanceOf('wcDocker'))) {
                parent = parent._parent;
            }
            return parent;
        },
        /**
         * Search upwards for a parent by class string or module
         * @todo get rid of declared class in xDocker
         * @param className {string|Object}
         * @returns {*}
         * @private
         */
        _parentByClass: function(className) {
            var parent = this._parent;
            if(_.isString(className)) {
                while (parent && !(parent.declaredClass.indexOf(className)!==-1)) {
                    parent = parent._parent;
                }
            }
            return parent;
        }
    });
});

/** @module wcPanel */
define('wcDocker/panel',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {
    /**
     * @class module:wcPanel
     * The public interface for the docking panel, it contains a number of convenience
     * functions and layout that manages the contents of the panel.
     */
    var Module = dcl(base, {
        declaredClass: 'wcPanel',
        /**
         * Std API
         */
        select:function(){
            var frame = this.getFrame();
            if (frame) {
                frame.panel(frame.panelIndex(this));
                this._startWidgets();
                this.onShow();
            }
        },
        /**
         * Helper to return parent splitter
         * @returns {*}
         */
        getSplitter:function(){
            return this._parentByClass('Splitter');
        },
        /**
         * Helper to return parent frame
         * @returns {*}
         */
        getFrame:function(){
            return this._parentByClass('Frame');
        },
        /**
         * Std API
         */
        resize: function () {
            this.__update();
            this.__trigger(wcDocker.EVENT.RESIZED);
        },

        /**
         * @memberOf module:wcPanel
         * <b><i>PRIVATE</i> - Use [wcDocker.addPanel]{@link module:wcDocker#addPanel}, [wcDocker.removePanel]{@link module:wcDocker#removePanel}, and
         * [wcDocker.movePanel]{@link module:wcDocker#movePanel} to manage panels, <u>this should never be constructed directly
         * by the user.</u></b>
         * @param {module:wcBase} parent - The parent.
         * @param {String} type - The name identifier for the panel.
         * @param {module:wcPanel~options} [options] - An options object passed from registration of the panel.
         */
        constructor: function (parent, type, options) {
            /**
             * An options object for the [panel]{@link module:wcPanel} constructor.
             * @typedef module:wcPanel~options
             * @property {String} [icon] - A CSS classname that represents the icon that should display on this panel's tab widget.
             * @property {String} [faicon] - An icon name using the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
             * @property {String|Boolean} [title] - A custom title to display for this panel, if false, title bar will not be shown.
             * @property {Number|String} [detachToWidth=600] - Determines the new width when the panel is detached (0 = Don't change). Can be a pixel value, or a string with a 'px' or '%' suffix.
             * @property {Number|String} [detachToHeight=400] - Determines the new height when the panel is detached (0 = Don't change).  Can be a pixel value, or a string with a 'px' or '%' suffix.
             */

            /**
             * The outer container element of the panel.
             * @member {external:jQuery~Object}
             */
            this.$container = null;
            this._parent = parent;
            this.$icon = null;
            this.$closeIcon = null;
            this.$title = null;
            this.$titleText = null;
            this.$loading = null;

            this._panelObject = null;
            this._initialized = false;
            this._collapseDirection = undefined;

            this._type = type;
            this._title = type;
            this._titleVisible = true;

            this._options = options;

            this._layout = null;

            this._buttonList = [];

            this._actualPos = {
                x: 0.5,
                y: 0.5
            };

            this._actualSize = {
                x: 0,
                y: 0
            };

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._pos = {
                x: 0.5,
                y: 0.5
            };

            this._moveData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._size = {
                x: -1,
                y: -1
            };

            this._minSize = {
                x: 100,
                y: 50
            };

            this._maxSize = {
                x: Infinity,
                y: Infinity
            };

            this._scroll = {
                x: 0,
                y: 0
            };

            this._scrollable = {
                x: true,
                y: true
            };

            this._collapsible = true;
            this._overflowVisible = false;
            this._moveable = true;
            this._detachable = true;
            this._closeable = true;
            this._resizeVisible = true;
            this._isVisible = false;
            this._events = {};
            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Gets, or Sets the title for this panel.
         * Titles appear in the tab widget associated with the panel.
         * @function module:wcPanel#title
         * @param {String|Boolean} title - If supplied, sets the new title (this can be html text). If false, the title bar will be removed.
         * @returns {String|Boolean} - The current title.
         */
        title: function (title) {
            if (typeof title !== 'undefined') {
                if (title === false) {
                    this._titleVisible = false;
                    this.$titleText.html(this._type);
                } else {
                    this._title = title;
                    this.$titleText.html(title);
                }

                if (this.$icon) {
                    this.$titleText.prepend(this.$icon);
                }

                if (this.$closeIcon) {
                    this.$titleText.append(this.$closeIcon);
                    this.$closeIcon[0].__panel= this;
                }


                if (this._parent && this._parent.instanceOf('wcFrame')) {
                    this._parent.__updateTabs();
                }
            }
            return this._title;
        },

        /**
         * Retrieves the registration info of the panel as declared from
         * [wcDocker.registerPanelType]{@link module:wcDocker#registerPanelType};
         * @function module:wcPanel#info
         * @returns {module:wcDocker~registerOptions} - Registered options of the panel type.
         * @see [wcDocker.panelTypeInfo]{@link module:wcDocker#panelTypeInfo}.
         */
        info: function () {
            return this.docker().panelTypeInfo(this._type);
        },

        /**
         * Retrieves the layout instance.
         * @function module:wcPanel#layout
         * @returns {module:wcLayoutSimple|wcLayoutTable} - The layout instance.
         */
        layout: function () {
            return this._layout;
        },

        /**
         * Brings this panel into focus. If it is floating, it will be moved to the front of all other panels.
         * @function module:wcPanel#focus
         * @param {Boolean} [flash] - If true, in addition to bringing the panel into focus, it will also flash for the user.
         */
        focus: function (flash) {
            var docker = this.docker();
            if (docker) {
                docker.__focus(this._parent, flash);
                for (var i = 0; i < this._parent._panelList.length; ++i) {
                    if (this._parent._panelList[i] === this && this._parent._curTab !== i) {
                        this._parent.panel(i);
                        break;
                    }
                }
            }
        },

        /**
         * @callback wcPanel~CollapseDirection
         * @see module:wcPanel#collapseDirection
         * @param {module:wcDocker~Bounds} bounds - The bounds of this panel relative to the wcDocker container.
         * @returns {module:wcDocker.DOCK} - A collapse direction to use, must only be LEFT, RIGHT, or BOTTOM
         */

        /**
         * Gets, or Sets the collapse direction for this panel.
         * @function module:wcPanel#collapseDirection
         * @param {module:wcPanel~CollapseDirection|wcDocker.DOCK} direction - The collapse direction to use for this panel.<br>If this value is omitted, the default collapse direction will be used.
         */
        collapseDirection: function (direction) {
            this._collapseDirection = direction;
        },

        /**
         * Retrieves whether this panel can be seen by the user.
         * @function module:wcPanel#isVisible
         * @returns {Boolean} - Visibility state.
         */
        isVisible: function () {
            return this._isVisible;
        },

        /**
         * Retrieves whether this panel is floating.
         * @function module:wcPanel#isFloating
         * @returns {Boolean}
         */
        isFloating: function () {
            if (this._parent && this._parent.instanceOf('wcFrame')) {
                return this._parent._isFloating;
            }
            return false;
        },

        /**
         * Retrieves whether this panel is in focus.
         * @function module:wcPanel#isInFocus
         * @return {Boolean}
         */
        isInFocus: function () {
            var docker = this.docker();
            if (docker && this._parent && this._parent.instanceOf('wcFrame')) {
                return this._parent === docker._focusFrame;
            }
            return false;
        },

        /**
         * Creates a new custom button that will appear in the title bar when the panel is active.
         * @function module:wcPanel#addButton
         * @param {String} name               - The name of the button, to identify it later.
         * @param {String} className          - A CSS class name to apply to the button.
         * @param {String} text               - Text to apply to the button.
         * @param {String} tip                - Tooltip text for the user.
         * @param {Boolean} [isTogglable]     - If true, will make the button toggle on and off per click.
         * @param {String} [toggleClassName]  - If this button is toggleable, you can designate an optional CSS class name that will replace the original class name.
         */
        addButton: function (name, className, text, tip, isTogglable, toggleClassName) {
            this._buttonList.push({
                name: name,
                className: className,
                toggleClassName: toggleClassName,
                text: text,
                tip: tip,
                isTogglable: isTogglable,
                isToggled: false
            });

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__update();
            }
        },

        /**
         * Removes a custom button from the panel.
         * @function module:wcPanel#removeButton
         * @param {String} name - The name identifier for the button to remove.
         * @returns {Boolean} - Success or failure.
         */
        removeButton: function (name) {
            for (var i = 0; i < this._buttonList.length; ++i) {
                if (this._buttonList[i].name === name) {
                    this._buttonList.splice(i, 1);
                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__onTabChange();
                    }

                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__update();
                    }

                    return true;
                }
            }
            return false;
        },

        /**
         * Gets, or Sets the current toggle state of a custom button that was
         * added using [wcPanel.addButton]{@link module:wcPanel#addButton}.
         * @function module:wcPanel#buttonState
         * @param {String} name - The name identifier of the button.
         * @param {Boolean} [toggleState] - If supplied, will assign a new toggle state to the button.
         * @returns {Boolean} - The current toggle state of the button.
         */
        buttonState: function (name, toggleState) {
            for (var i = 0; i < this._buttonList.length; ++i) {
                if (this._buttonList[i].name === name) {
                    if (typeof toggleState !== 'undefined') {
                        this._buttonList[i].isToggled = toggleState;
                        if (this._parent && this._parent.instanceOf('wcFrame')) {
                            this._parent.__onTabChange();
                        }
                    }

                    if (this._parent && this._parent.instanceOf('wcFrame')) {
                        this._parent.__update();
                    }

                    return this._buttonList[i].isToggled;
                }
            }
            return false;
        },

        /**
         * Gets, or Sets the default position of the panel if it is floating. <b>Warning: after the panel has been initialized, this value no longer reflects the current position of the panel.</b>
         * @function module:wcPanel#initPos
         * @param {Number|String} [x] - If supplied, sets the horizontal position of the floating panel. Can be a percentage position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the vertical position of the floating panel. Can be a percentage position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Coordinate} - The current default position of the panel.
         */
        initPos: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._pos.x = docker.__stringToPercent(x, docker.$container.width());
                } else {
                    this._pos.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._pos.y = docker.__stringToPercent(y, docker.$container.height());
                } else {
                    this._pos.y = y;
                }
            }

            return {x: this._pos.x, y: this._pos.y};
        },

        /**
         * Gets, or Sets the desired size of the panel. <b>Warning: after the panel has been initialized, this value no longer reflects the current size of the panel.</b>
         * @function module:wcPanel#initSize
         * @param {Number|String} [x] - If supplied, sets the desired initial horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired initial vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current initial size of the panel.
         */
        initSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._size.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._size.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._size.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._size.y = y;
                }
            }
            return {x: this._size.x, y: this._size.y};
        },

        /**
         * Gets, or Sets the minimum size constraint of the panel.
         * @function module:wcPanel#minSize
         * @param {Number|String} [x] - If supplied, sets the desired minimum horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired minimum vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current minimum size.
         */
        minSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._minSize.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._minSize.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._minSize.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._minSize.y = y;
                }
            }
            return {x: this._minSize.x, y: this._minSize.y};
        },

        /**
         * Gets, or Sets the maximum size constraint of the panel.
         * @function module:wcPanel#maxSize
         * @param {Number|String} [x] - If supplied, sets the desired maximum horizontal size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [y] - If supplied, sets the desired maximum vertical size of the panel. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {module:wcDocker~Size} - The current maximum size.
         */
        maxSize: function (x, y) {
            if (typeof x !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._maxSize.x = docker.__stringToPixel(x, docker.$container.width());
                } else {
                    this._maxSize.x = x;
                }
            }
            if (typeof y !== 'undefined') {
                var docker = this.docker();
                if (docker) {
                    this._maxSize.y = docker.__stringToPixel(y, docker.$container.height());
                } else {
                    this._maxSize.y = y;
                }
            }
            return {x: this._maxSize.x, y: this._maxSize.y};
        },

        /**
         * Retrieves the width of the panel contents.
         * @function module:wcPanel#width
         * @returns {Number} - Panel width.
         */
        width: function () {
            if (this.$container) {
                return this.$container.width();
            }
            return 0.0;
        },

        /**
         * Retrieves the height of the panel contents.
         * @function module:wcPanel#height
         * @returns {Number} - Panel height.
         */
        height: function () {
            if (this.$container) {
                return this.$container.height();
            }
            return 0.0;
        },

        /**
         * Sets the icon for the panel, shown in the panels tab widget. Must be a css class name that contains the icon.
         * @function module:wcPanel#icon
         * @param {String} icon - The icon class name.
         */
        icon: function (icon) {
            if (!this.$icon) {
                this.$icon = $('<div>');
                this.$titleText.prepend(this.$icon);
            }

            this.$icon.removeClass();
            this.$icon.addClass('wcTabIcon ' + icon);

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__updateTabs();
            }

            this._icon = icon;

        },

        /**
         * Sets the icon for the panel, shown in the panels tab widget,
         * to an icon defined from the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
         * @function module:wcPanel#faicon
         * @param {String} icon - The font-awesome icon name.
         */
        faicon: function (icon) {
            if (!this.$icon) {
                this.$icon = $('<div>');
                this.$titleText.prepend(this.$icon);
            }

            this.$icon.removeClass();
            this.$icon.addClass('wcTabIcon fa fa-fw fa-' + icon);

            if (this._parent && this._parent.instanceOf('wcFrame')) {
                this._parent.__updateTabs();
            }
        },

        /**
         * Gets, or Sets whether the window is scrollable.
         * @function module:wcPanel#scrollable
         * @param {Boolean} [x] - If supplied, assigns whether the window is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the window is scrollable in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scrollable status.
         */
        scrollable: function (x, y) {
            if (typeof x !== 'undefined') {
                this._scrollable.x = !!x;
                this._scrollable.y = !!y;
            }

            return {x: this._scrollable.x, y: this._scrollable.y};
        },

        /**
         * Gets, or Sets the scroll position of the panel's contents if it is scrollable; See [wcPanel.scrollable]{@link module:wcPanel#scrollable}).
         * @function module:wcPanel#scroll
         * @param {Number} [x]        - If supplied, sets the scroll horizontal position of the panel.
         * @param {Number} [y]        - If supplied, sets the scroll vertical position of the panel.
         * @param {Number} [duration] - If supplied, will animate the scroll movement with the supplied duration (in milliseconds).
         * @returns {module:wcDocker~Coordinate} The current scroll position.
         */
        scroll: function (x, y, duration) {
            if (!this.$container) {
                return {x: 0, y: 0};
            }

            if (typeof x !== 'undefined') {
                if (duration) {
                    this.$container.parent().stop().animate({
                        scrollLeft: x,
                        scrollTop: y
                    }, duration);
                } else {
                    this.$container.parent().scrollLeft(x);
                    this.$container.parent().scrollTop(y);
                }
            }

            return {
                x: this.$container.parent().scrollLeft(),
                y: this.$container.parent().scrollTop()
            };
        },

        /**
         * Gets, or Sets whether this panel can be collapsed to the side or bottom.<br>
         * This only works if the collapse feature is enabled {@link module:wcDocker~Options}.
         * @function module:wcPanel#collapsible
         * @param {Boolean} [enabled] - If supplied, assigns whether collapsing is enabled.
         * @returns {Boolean} - The current collapsible enabled state.
         */
        collapsible: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._collapsible = !!enabled;
            }

            return this._collapsible;
        },

        /**
         * Gets, or Sets whether overflow on this panel is visible.
         * Use this if a child element within this panel is intended to 'popup' and be visible outside of its parent area.
         * @function module:wcPanel#overflowVisible
         * @param {Boolean} [visible] - If supplied, assigns whether overflow is visible.
         * @returns {Boolean} - The current overflow visibility.
         */
        overflowVisible: function (visible) {
            if (typeof visible !== 'undefined') {
                this._overflowVisible = !!visible;
            }

            return this._overflowVisible;
        },

        /**
         * Gets, or Sets whether the contents of the panel are visible on resize.
         * Use this if the panel has extremely expensive contents which take a long time to resize.
         * @function module:wcPanel#resizeVisible
         * @param {Boolean} [visible] - If supplied, assigns whether panel contents are visible during resize.
         * @returns {Boolean} - The current resize visibility.
         */
        resizeVisible: function (visible) {
            if (typeof visible !== 'undefined') {
                this._resizeVisible = !!visible;
            }

            return this._resizeVisible;
        },

        /**
         * Sets, or Gets the moveable status of the window.
         * Note: Other panels can not dock beside a non-moving panel as doing so could cause it to move.
         * @function module:wcPanel#moveable
         * @param {Boolean} [enabled] - If supplied, assigns whether this panel can be moved.
         * @returns {Boolean} - Whether the panel is moveable.
         */
        moveable: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._moveable = !!enabled;
                this.$title.toggleClass('wcNotMoveable', !this._moveable);
            }

            return this._moveable;
        },

        /**
         * Sets, or Gets whether this panel can be detached into a floating panel.
         * @function module:wcPanel#detachable
         * @param {Boolean} [enabled] - If supplied, assigns whether this panel can be detached.
         * @returns {Boolean} - Whether this panel can detach.
         */
        detachable: function(enabled) {
            if (typeof enabled !== 'undefined') {
                this._detachable = !!enabled;
            }

            return this._detachable;
        },

        /**
         * Gets, or Sets whether this dock window can be closed by the user.
         * Note: The panel can still be closed programmatically.
         * @function module:wcPanel#closeable
         * @param {Boolean} [enabled] - If supplied, toggles whether it can be closed.
         * @returns {Boolean} the current closeable status.
         */
        closeable: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this._closeable = !!enabled;
                if (this._closeable) {
                    if(!this.$closeIcon) {
                        this.$closeIcon = $('<div class="wcPanelCloseIcon fa fa-close"/>');
                        this.$titleText.append(this.$closeIcon);
                    }
                }else{
                    this.$closeIcon && this.$closeIcon.remove();
                    this.$closeIcon = null;
                }
                if (this._parent) {
                    this._parent.__update();
                }
            }
            return this._closeable;
        },

        /**
         * Forces the window to close.
         * @function module:wcPanel#close
         */
        close: function () {
            var docker = this.docker();
            if (docker) {
                docker.__closePanel(this);
            }
        },

        /**
         * Shows the loading screen.
         * @function module:wcPanel#startLoading
         * @param {String} [label] - An optional label to display.
         * @param {Number} [opacity=0.4] - If supplied, assigns a custom opacity value to the loading screen.
         * @param {Number} [textOpacity=1] - If supplied, assigns a custom opacity value to the loading icon and text displayed.
         */
        startLoading: function (label, opacity, textOpacity) {
            if (!this.$loading) {
                var markup = '<div class="container-fluid center-block" style="opacity: 1;position: absolute;top:50%;">'+
                    '<div class="">'+
                        '<div class="offset3 span6 centering center-block">'+
                            '<div class="fa fa-3x fa-spinner fa-spin "/>' +
                        '</div>' +
                    '</div>' +
                '</div>';
                this.$loading = $(markup);
                this.$container.append(this.$loading);
                /*

                this.$loading = $('<div class="wcLoadingContainer"></div>');
                this.$container.append(this.$loading);

                var $background = $('<div class="wcLoadingBackground"></div>');
                if (typeof opacity !== 'number') {
                    opacity = 0.4;
                }

                this.$loading.append($background);

                var $icon = $('<div class="wcLoadingIconContainer"><i class="wcLoadingIcon ' + this.docker()._options.loadingClass + '"></i></div>');
                this.$loading.append($icon);

                if (label) {
                    var $label = $('<span class="wcLoadingLabel">' + label + '</span>');
                    this.$loading.append($label);
                }

                if (typeof textOpacity !== 'number') {
                    textOpacity = 1;
                }

                // Override opacity values if the global loading screen is active.
                if (this.docker().$loading) {
                    opacity = 0;
                    textOpacity = 0;
                }

                $background.css('opacity', opacity);
                $icon.css('opacity', textOpacity);

                if ($label) {
                    $label.css('opacity', textOpacity);
                }
                */
            }
        },

        /**
         * Hides the loading screen.
         * @function module:wcPanel#finishLoading
         * @param {Number} [fadeDuration=0] - If supplied, assigns a fade out duration for the loading screen.
         */
        finishLoading: function (fadeDuration) {
            if (this.$loading) {
                if (fadeDuration > 0) {
                    var self = this;
                    this.$loading.fadeOut(fadeDuration, function () {
                        self.$loading.remove();
                        self.$loading = null;
                        self.docker().__testLoadFinished();
                    });
                } else {
                    this.$loading.remove();
                    this.$loading = null;
                    this.docker().__testLoadFinished();
                }

            }
        },

        /**
         * Registers an [event]{@link module:wcDocker.EVENT} associated with this panel.
         * @function module:wcPanel#on
         * @param {String} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {module:wcDocker#onEvent} handler - An event handler function to be called when the event is fired.
         * @returns {Boolean} - Event registration success or failure.
         */
        on: function (eventType, handler) {
            if (!eventType) {
                return false;
            }

            if (!this._events[eventType]) {
                this._events[eventType] = [];
            }

            if (this._events[eventType].indexOf(handler) !== -1) {
                return false;
            }

            this._events[eventType].push(handler);
            return true;
        },

        /**
         * Unregisters an [event]{@link module:wcDocker.EVENT} associated with this panel.
         * @function module:wcPanel#off
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} [handler] - The handler function registered with the event. If omitted, all events registered to the event type are unregistered.
         */
        off: function (eventType, handler) {
            if (typeof eventType === 'undefined') {
                this._events = {};
            } else {
                if (this._events[eventType]) {
                    if (typeof handler === 'undefined') {
                        this._events[eventType] = [];
                    } else {
                        for (var i = 0; i < this._events[eventType].length; ++i) {
                            if (this._events[eventType][i] === handler) {
                                this._events[eventType].splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },

        /**
         * Triggers an [event]{@link module:wcDocker.EVENT} of a given type to all panels, including itself.
         * @function module:wcPanel#trigger
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link module:wcDocker.EVENT}.
         * @param {Object} [data] - A custom data object to pass into all handlers.
         * @returns {Object[]} results - Returns an array with all results returned by event handlers.
         */
        trigger: function (eventType, data) {
            var docker = this.docker();
            if (docker) {
                return docker.trigger(eventType, data);
            }
            return [];
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            var layoutClass = (this._options && this._options.layout) || 'wcLayoutTable';
            this._layout = new (this.docker().__getClass(layoutClass))(this.$container, this);
            this.$title = $('<div class="wcPanelTab">');
            this.$titleText = $('<div>' + this._title + '</div>');
            this.$title.append(this.$titleText);

            if (this._options.hasOwnProperty('title')) {
                this.title(this._options.title);
            }

            if (this._options.icon) {
                this.icon(this._options.icon);
            }
            if (this._options.faicon) {
                this.faicon(this._options.faicon);
            }
        },

        // Updates the size of the layout.
        __update: function () {
            var docker = this.docker();
            if (!docker) return;

            this._layout.__update();
            if (!this.$container) {
                return;
            }

            if (this._resizeVisible) {
                this._parent.$frame.removeClass('wcHideOnResize');
            } else {
                this._parent.$frame.addClass('wcHideOnResize');
            }

            if (!this._initialized) {
                this._initialized = true;
                var self = this;
                setTimeout(function () {
                    self.__trigger(wcDocker.EVENT.INIT);

                    docker.__testLoadFinished();
                }, 0);
            } else {
                this.__trigger(wcDocker.EVENT.UPDATED);
            }

            var width = this.$container.width();
            var height = this.$container.height();
            if (this._actualSize.x !== width || this._actualSize.y !== height) {
                this._resizeData.time = new Date();
                if (!this._resizeData.timeout) {
                    this._resizeData.timeout = true;
                    setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                    this.__trigger(wcDocker.EVENT.RESIZE_STARTED, {width: this._actualSize.x, height: this._actualSize.y});
                }

                this._actualSize.x = width;
                this._actualSize.y = height;
                this.__trigger(wcDocker.EVENT.RESIZED, {width: this._actualSize.x, height: this._actualSize.y});
            }

            var offset = this.$container.offset();
            if (this._actualPos.x !== offset.left || this._actualPos.y !== offset.top) {
                this._moveData.time = new Date();
                if (!this._moveData.timeout) {
                    this._moveData.timeout = true;
                    setTimeout(this.__moveEnd.bind(this), this._moveData.delta);
                    this.__trigger(wcDocker.EVENT.MOVE_STARTED, {x: this._actualPos.x, y: this._actualPos.y});
                }

                this._actualPos.x = offset.left;
                this._actualPos.y = offset.top;
                this.__trigger(wcDocker.EVENT.MOVED, {x: this._actualPos.x, y: this._actualPos.y});
            }
        },

        __resizeEnd: function () {
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
                this.__trigger(wcDocker.EVENT.RESIZE_ENDED, {width: this._actualSize.x, height: this._actualSize.y});
            }
        },

        __moveEnd: function () {
            if (new Date() - this._moveData.time < this._moveData.delta) {
                setTimeout(this.__moveEnd.bind(this), this._moveData.delta);
            } else {
                this._moveData.timeout = false;
                this.__trigger(wcDocker.EVENT.MOVE_ENDED, {x: this._actualPos.x, y: this._actualPos.y});
            }
        },

        __isVisible: function (inView) {
            if (this._isVisible !== inView) {
                this._isVisible = inView;

                this.__trigger(wcDocker.EVENT.VISIBILITY_CHANGED, this._isVisible);
            }
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.type = 'wcPanel';
            if (this._icon) {
                data.icon = this._icon;
            }else{
                console.log('have no icon');
            }
            data.panelType = this._type;
            // data.title = this._title;
            data.size = {
                x: this._size.x,
                y: this._size.y
            };
            // data.minSize = {
            //   x: this._minSize.x,
            //   y: this._minSize.y,
            // };
            // data.maxSize = {
            //   x: this._maxSize.x,
            //   y: this._maxSize.y,
            // };
            // data.scrollable = {
            //   x: this._scrollable.x,
            //   y: this._scrollable.y,
            // };
            // data.moveable = this._moveable;
            // data.closeable = this._closeable;
            // data.resizeVisible = this.resizeVisible();
            data.customData = {};
            this.__trigger(wcDocker.EVENT.SAVE_LAYOUT, data.customData);
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data) {
            // this._title = data.title;
            if (data.size) {
                this._size.x = data.size.x;
                this._size.y = data.size.y;
            }
            // this._minSize.x = data.minSize.x;
            // this._minSize.y = data.minSize.y;
            // this._maxSize.x = data.maxSize.x;
            // this._maxSize.y = data.maxSize.y;
            // this._scrollable.x = data.scrollable.x;
            // this._scrollable.y = data.scrollable.y;
            // this._moveable = data.moveable;
            // this._closeable = data.closeable;
            // this.resizeVisible(data.resizeVisible);
            this.__trigger(wcDocker.EVENT.RESTORE_LAYOUT, data.customData);

            data.icon && this.icon(data.icon);
            var docker = this.docker();
            if(docker){
                docker._emit('restorePanel',data.customData);
            }else{
                console.error('restorePanel : failed, have no docker');
            }

        },

        // Triggers an event of a given type onto this current panel.
        // Params:
        //    eventType     The event to trigger.
        //    data          A custom data object to pass into all handlers.
        __trigger: function (eventType, data) {
            if (!eventType) {
                return false;
            }

            var results = [];
            if (this._events[eventType]) {
                var events = this._events[eventType].slice(0);
                for (var i = 0; i < events.length; ++i) {
                    results.push(events[i].call(this, data));
                }
            }

            return results;
        },

        // Retrieves the bounding rect for this widget.
        __rect: function () {
            var offset = this.$container.offset();
            var width = this.$container.width();
            var height = this.$container.height();

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }
            this.$container = $container;
            if (this.$container) {
                this._layout.__container(this.$container);
                if (this.$loading) {
                    this.$container.append(this.$loading);
                }
            } else {
                this._layout.__container(null);
                this.finishLoading();
            }
            if(this.$container) {
                this.$container[0].id = this.id;
            }
            return this.$container;
        },
        // Destroys this panel.
        __destroy: function () {
            this._panelObject = null;
            if(this.$closeIcon) {
                this.$closeIcon.__panel = null;
            };
            this.off();

            this.__container(null);
            this._parent = null;
        }
    });

    dcl.chainAfter(Module,"resize");
    return Module;
});

/** @module wcGhost **/
define('wcDocker/ghost',[
    "dcl/dcl",
    "wcDocker/types"
], function (dcl, wcDocker) {

    /**
     * @class module:wcGhost
     * A ghost object that follows the mouse around during dock movement.
     */
    var Module = dcl(null, {
        declaredClass: 'wcGhost',
        
        /**
         * @memberOf module:wcGhost
         * @param {module:wcDocker~Rect} rect - A rectangle area to begin the ghost highlighting.
         * @param {module:wcDocker~Coordinate} mouse - The mouse position.
         * @param {module:wcDocker} docker - The docker object.
         */
        constructor: function (rect, mouse, docker) {
            this.$ghost = null;
            this._rect;
            this._anchorMouse = false;
            this._anchor = null;
            this._docker = docker;

            this._outer = docker.__findInner();
            if (this._outer && this._outer.instanceOf('wcSplitter')) {
                this._inner = this._outer.right();
            }

            this.__init(rect, mouse);
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Updates the ghost based on the given screen position.
         * @function module:wcGhost#update
         * @param {module:wcDocker~Coordinate} position - The mouse position.
         * @param {Boolean} [disableFloating] - If true, the ghost will not float.
         */
        update: function (position, disableFloating) {
            this.__move(position);

            for (var i = 0; i < this._docker._floatingList.length; ++i) {
                var rect = this._docker._floatingList[i].__rect();
                if (position.x > rect.x && position.y > rect.y
                    && position.x < rect.x + rect.w && position.y < rect.y + rect.h) {

                    if (!this._docker._floatingList[i].__checkAnchorDrop(position, false, this, true, undefined, true)) {
                        if (!disableFloating) {
                            this.anchor(position, null);
                        }
                    } else {
                        this._anchor.panel = this._docker._floatingList[i].panel();
                    }
                    return;
                }
            }

            for (var i = 0; i < this._docker._frameList.length; ++i) {
                var rect = this._docker._frameList[i].__rect();
                if (position.x > rect.x && position.y > rect.y
                    && position.x < rect.x + rect.w && position.y < rect.y + rect.h) {

                    if (!this._docker._frameList[i].__checkAnchorDrop(position, false, this, true, undefined, true)) {
                        if (!disableFloating) {
                            this.anchor(position, null);
                        }
                    } else {
                        this._anchor.panel = this._docker._frameList[i].panel();
                    }
                    return;
                }
            }
        },

        /**
         * Get, or Sets the ghost's anchor.
         * @function module:wcGhost#anchor
         * @param {module:wcDocker~Coordinate} [mouse] - If supplied with the anchor, .
         * @param {module:wcDocker~Anchor} [anchor] - If supplied, assigns a new anchor.
         */
        anchor: function (mouse, anchor) {
            if (typeof mouse === 'undefined') {
                return this._anchor;
            }

            if (anchor && this._anchor && anchor.loc === this._anchor.loc && anchor.item === this._anchor.item) {
                return;
            }

            var rect = {
                x: parseInt(this.$ghost.css('left')),
                y: parseInt(this.$ghost.css('top')),
                w: parseInt(this.$ghost.css('width')),
                h: parseInt(this.$ghost.css('height'))
            };

            this._anchorMouse = {
                x: rect.x - mouse.x,
                y: rect.y - mouse.y
            };

            this._rect.x = -this._anchorMouse.x;
            this._rect.y = -this._anchorMouse.y;

            if (!anchor) {
                if (!this._anchor) {
                    return;
                }

                if (this._docker._draggingFrame && this._docker._draggingFrame.$container) {
                    var detachToWidth = this._docker._draggingFrame._panelList[0]._options.detachToWidth || this._docker._options.detachToWidth || this._rect.w;
                    var detachToHeight = this._docker._draggingFrame._panelList[0]._options.detachToHeight || this._docker._options.detachToHeight || this._rect.h;
                    this._rect.w = this._docker.__stringToPixel(detachToWidth, this._docker.$container.width());
                    this._rect.h = this._docker.__stringToPixel(detachToHeight, this._docker.$container.height());
                }

                this._anchor = null;
                this.$ghost.show();
                this.$ghost.stop().animate({
                    opacity: 0.3,
                    'margin-left': this._rect.x - this._rect.w / 2 + 'px',
                    'margin-top': this._rect.y - 10 + 'px',
                    width: this._rect.w + 'px',
                    height: this._rect.h + 'px'
                }, 150);
                return;
            }

            this._anchor = anchor;
            var opacity = 0.8;
            if (anchor.self && anchor.loc === wcDocker.DOCK.STACKED) {
                opacity = 0;
                this.$ghost.hide();
            } else {
                this.$ghost.show();
            }
            this.$ghost.stop().animate({
                opacity: opacity,
                'margin-left': '2px',
                'margin-top': '2px',
                border: '0px',
                left: anchor.x + 'px',
                top: anchor.y + 'px',
                width: anchor.w + 'px',
                height: anchor.h + 'px'
            }, 150);
        },

        /**
         * Retrieves the rectangle area of the ghost's anchor.
         * @function module:wcGhost#rect
         * @returns {module:wcDocker~AnchorRect} - The rectangle area of the anchor.
         */
        rect: function () {
            return {
                x: this.$ghost.offset().left,
                y: this.$ghost.offset().top,
                w: parseInt(this.$ghost.css('width')),
                h: parseInt(this.$ghost.css('height')),
                tabOrientation: this._anchor && this._anchor.tab
            };
        },

        /**
         * Destroys the instance of the ghost.
         * @function module:wcGhost#destroy
         */
        destroy: function () {
            this.__destroy();
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function (rect, mouse) {
            this.$ghost = $('<div class="wcGhost">')
                .css('opacity', 0)
                .css('top', rect.y + 'px')
                .css('left', rect.x + 'px')
                .css('width', rect.w + 'px')
                .css('height', rect.h + 'px');

            this._anchorMouse = {
                x: rect.x - mouse.x,
                y: rect.y - mouse.y
            };

            this._rect = {
                x: -this._anchorMouse.x,
                y: -this._anchorMouse.y,
                w: rect.w,
                h: rect.h
            };

            $('body').append(this.$ghost);

            this.anchor(mouse, rect);
        },

        // Updates the size of the layout.
        __move: function (mouse) {
            if (this._anchor) {
                return;
            }

            var x = parseInt(this.$ghost.css('left'));
            var y = parseInt(this.$ghost.css('top'));

            x = mouse.x + this._anchorMouse.x;
            y = mouse.y + this._anchorMouse.y;

            this.$ghost.css('left', x + 'px');
            this.$ghost.css('top', y + 'px');
        },

        // Gets the original size of the moving widget.
        __rect: function () {
            return this._rect;
        },

        // Exorcise the ghost.
        __destroy: function () {
            this.$ghost.stop().animate({
                opacity: 0.0
            }, {
                duration: 175,
                complete: function () {
                    $(this).remove();
                }
            });
        }
    });
    return Module;

});

/** @module wcSplitter */
define('wcDocker/splitter',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class module:wcSplitter
     * Splits an area in two, dividing it with a resize-able splitter bar. This is the same class
     * used throughout [docker]{@link module:wcDocker} to organize the docking interface, but it can also
     * be used inside a panel as a custom widget.
     * <b>Note:</b> The container needs to be positioned in either absolute or relative coordinates in css.
     */
    var Module = dcl(base, {

        declaredClass: 'wcSplitter',

        /**
         * @memberOf module:wcSplitter
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this splitter.
         * @param {wcLayout|wcSplitter|wcDocker} parent   - The splitter's parent object.
         * @param {module:wcDocker.ORIENTATION} orientation      - The orientation of the splitter bar.
         */
        constructor:function(container, parent, orientation) {
            this.$container = $(container);
            this._parent = parent;
            this._orientation = orientation;

            this._pane = [false, false];
            /**
             * An array of two elements representing each side of the splitter.
             * Index 0 is always either top or left depending on [orientation]{@link module:wcDocker.ORIENTATION}.
             * @member
             * @type {external:jQuery~Object[]}
             */
            this.$pane = [];
            this.$bar = null;
            this._pos = 0.5;
            this._posTarget = 0.5;
            this._pixelPos = -1;
            this._findBestPos = false;
            this._anim = 0;

            this._boundEvents = [];

            this.__init();

            this.docker()._splitterList.push(this);
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Initializes the two [panes]{@link module:wcSplitter#$pane} of the splitter with its own layouts.<br>
         * This should be used to initialize the splitter when creating one for use inside your panel.
         * @function module:wcSplitter#initLayouts
         * @param {module:wcDocker.LAYOUT} [topLeftLayout=wcDocker.LAYOUT.TABLE] - The type of layout to use for the top or left pane.
         * @param {module:wcDocker.LAYOUT} [bottomRightLayout=wcDocker.LAYOUT.TABLE] - The type of layout to use for the bottom or right pane.
         */
        initLayouts: function (topLeftLayout, bottomRightLayout) {
            var layoutClass = topLeftLayout || 'wcLayoutTable';
            var layout0 = new (this.docker().__getClass(layoutClass))(this.$pane[0], this);

            layoutClass = bottomRightLayout || 'wcLayoutTable';
            var layout1 = new (this.docker().__getClass(layoutClass))(this.$pane[1], this);

            this.pane(0, layout0);
            this.pane(1, layout1);
        },

        /**
         * Gets, or Sets the orientation of the splitter.
         * @function module:wcSplitter#orientation
         * @param {module:wcDocker.ORIENTATION} orientation - The new orientation of the splitter.
         */
        orientation: function (orientation) {
            if (typeof orientation === 'undefined') {
                return this._orientation;
            }

            if (this._orientation != orientation) {
                this._orientation = orientation;

                if (this._orientation) {
                    // this.$pane[0].removeClass('wcWide').addClass('wcTall');
                    // this.$pane[1].removeClass('wcWide').addClass('wcTall');
                    this.$bar.removeClass('wcWide').removeClass('wcSplitterBarH').addClass('wcTall').addClass('wcSplitterBarV');
                } else {
                    // this.$pane[0].removeClass('wcTall').addClass('wcWide');
                    // this.$pane[1].removeClass('wcTall').addClass('wcWide');
                    this.$bar.removeClass('wcTall').removeClass('wcSplitterBarV').addClass('wcWide').addClass('wcSplitterBarH');
                }

                this.$pane[0].css('top', '').css('left', '').css('width', '').css('height', '');
                this.$pane[1].css('top', '').css('left', '').css('width', '').css('height', '');
                this.$bar.css('top', '').css('left', '').css('width', '').css('height', '');
                this.__update();

                if (this._parent && this._parent.instanceOf('wcPanel')) {
                    this._parent.__trigger(wcDocker.EVENT.UPDATED);
                }
            }
        },

        /**
         * Gets the minimum size constraint of the outer splitter area.
         * @function module:wcSplitter#minSize
         * @returns {module:wcDocker~Size} The minimum size.
         */
        minSize: function () {
            var minSize1;
            var minSize2;
            if (this._pane[0] && typeof this._pane[0].minSize === 'function') {
                minSize1 = this._pane[0].minSize();
            }

            if (this._pane[1] && typeof this._pane[1].minSize === 'function') {
                minSize2 = this._pane[1].minSize();
            }

            if (minSize1 && minSize2) {
                if (this._orientation) {
                    minSize1.x += minSize2.x;
                    minSize1.y = Math.max(minSize1.y, minSize2.y);
                } else {
                    minSize1.y += minSize2.y;
                    minSize1.x = Math.max(minSize1.x, minSize2.x);
                }
                return minSize1;
            } else if (minSize1) {
                return minSize1;
            } else if (minSize2) {
                return minSize2;
            }

            return false;
        },

        /**
         * Gets the maximum size constraint of the outer splitter area.
         * @function module:wcSplitter#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var maxSize1;
            var maxSize2;
            if (this._pane[0] && typeof this._pane[0].maxSize === 'function') {
                maxSize1 = this._pane[0].maxSize();
            }

            if (this._pane[1] && typeof this._pane[1].maxSize === 'function') {
                maxSize2 = this._pane[1].maxSize();
            }

            if (maxSize1 && maxSize2) {
                if (this._orientation) {
                    maxSize1.x += maxSize2.x;
                    maxSize1.y = Math.min(maxSize1.y, maxSize2.y);
                } else {
                    maxSize1.y += maxSize2.y;
                    maxSize1.x = Math.min(maxSize1.x, maxSize2.x);
                }
                return maxSize1;
            } else if (maxSize1) {
                return maxSize1;
            } else if (maxSize2) {
                return maxSize2;
            }

            return false;
        },

        /**
         * Get, or Set the current splitter position.
         * @function module:wcSplitter#pos
         * @param {Number} [value] - If supplied, assigns a new splitter position. Value must be a percentage value between 0 and 1.
         * @returns {Number} - The current position.
         */
        pos: function (value) {

            if (typeof value !== 'undefined') {

                if(Math.abs(value) < 0.1 && value!==0){
                    return;
                }
                this._pos = this._posTarget = value;
                this.__update();

                if (this._parent && this._parent.instanceOf('wcPanel')) {
                    this._parent.__trigger(wcDocker.EVENT.UPDATED);
                }
            }

            return this._posTarget;
        },

        /**
         * Animates to a given splitter position.
         * @function module:wcSplitter#animPos
         * @param {Number} value - Assigns the target splitter position. Value must be a percentage between 0 and 1.
         * @param {module:wcSplitter~onFinished} - A finished event handler.
         */
        animPos: function (value, callback) {
            this._posTarget = value;
            var self = this;
            this.$bar.queue(function (next) {
                if (self._anim) {
                    clearInterval(self._anim);
                }
                self._anim = setInterval(function () {
                    if (self._pos > self._posTarget) {
                        self._pos -= (self._pos - self._posTarget) / 5;
                        if (self._pos <= self._posTarget + 0.01) {
                            self._pos = self._posTarget;
                        }
                    }

                    if (self._pos < self._posTarget) {
                        self._pos += (self._posTarget - self._pos) / 5;
                        if (self._pos >= self._posTarget - 0.01) {
                            self._pos = self._posTarget;
                        }
                    }

                    self.__update();
                    if (self._pos == self._posTarget) {
                        callback && callback();
                        next();
                        clearInterval(self._anim);
                        self._anim = 0;
                    }
                }, 5);
            });
            this.$bar.dequeue();
        },

        /**
         * Gets, or Sets the element associated with a pane.
         * @function module:wcSplitter#pane
         * @param {Number} index - The index of the pane, only 0 and 1 are valid.
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        pane: function (index, item) {
            if (index >= 0 && index < 2) {
                if (typeof item === 'undefined') {
                    return this._pane[index];
                } else {
                    if (item) {
                        this._pane[index] = item;
                        item._parent = this;
                        item.__container(this.$pane[index]);

                        if (this._pane[0] && this._pane[1]) {
                            this.__update();
                        }
                        return item;
                    } else if (this._pane[index]) {
                        this._pane[index].__container(null);
                        this._pane[index] = false;
                    }
                }
            }
            // this.__update();
            return false;
        },

        /**
         * Gets, or Sets the element associated with the left side pane (for horizontal layouts).
         * @function module:wcSplitter#left
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        left: function (item) {
            return this.pane(0, item);
        },

        /**
         * Gets, or Sets the element associated with the right side pane (for horizontal layouts).
         * @function module:wcSplitter#right
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        right: function (item) {
            return this.pane(1, item);
        },

        /**
         * Gets, or Sets the element associated with the top pane (for vertical layouts).
         * @function module:wcSplitter#top
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        top: function (item) {
            return this.pane(0, item);
        },

        /**
         * Gets, or Sets the element associated with the bottom pane (for vertical layouts).
         * @function module:wcSplitter#bottom
         * @param {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter} [item] - If supplied, the pane will be replaced with this item.
         * @returns {module:wcLayout|module:wcPanel|module:wcFrame|wcSplitter|Boolean} - The current object assigned to the pane, or false.
         */
        bottom: function (item) {
            return this.pane(1, item);
        },

        /**
         * Gets, or Sets whether a pane can be scrolled via scroll bars.
         * By default, scrolling is enabled in both directions.
         * @function module:wcSplitter#scrollable
         * @param {Number} index - The index of the pane, only 0 and 1 are valid.
         * @param {Boolean} [x] - Whether to allow scrolling in the horizontal direction.
         * @param {Boolean} [y] - Whether to allow scrolling in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scroll state for each direction.
         */
        scrollable: function (index, x, y) {
            if (typeof x !== 'undefined') {
                this.$pane[index].toggleClass('wcScrollableX', x);
            }
            if (typeof y !== 'undefined') {
                this.$pane[index].toggleClass('wcScrollableY', y);
            }

            return {
                x: this.$pane[index].hasClass('wcScrollableX'),
                y: this.$pane[index].hasClass('wcScrollableY')
            };
        },

        /**
         * Destroys the splitter.
         * @function module:wcSplitter#destroy
         * @param {Boolean} [destroyPanes=true] - If true, both panes attached will be destroyed as well. Use false if you plan to continue using the objects assigned to each pane, or make sure to remove them first before destruction.
         */
        destroy: function (destroyPanes) {
            var docker = this.docker();
            if (docker) {
                var index = this.docker()._splitterList.indexOf(this);
                if (index > -1) {
                    this.docker()._splitterList.splice(index, 1);
                }
            }

            if (destroyPanes === undefined || destroyPanes) {
                this.__destroy();
            } else {
                this.__container(null);
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$pane.push($('<div class="wcLayoutPane wcScrollableX wcScrollableY">'));
            this.$pane.push($('<div class="wcLayoutPane wcScrollableX wcScrollableY">'));
            this.$bar = $('<div class="wcSplitterBar">');

            if (this._orientation) {
                // this.$pane[0].addClass('wcTall');
                // this.$pane[1].addClass('wcTall');
                this.$bar.addClass('wcTall').addClass('wcSplitterBarV');
            } else {
                // this.$pane[0].addClass('wcWide');
                // this.$pane[1].addClass('wcWide');
                this.$bar.addClass('wcWide').addClass('wcSplitterBarH');
            }

            this.__container(this.$container);

            if (this._parent && this._parent.instanceOf('wcPanel')) {
                this._boundEvents.push({event: wcDocker.EVENT.UPDATED, handler: this.__update.bind(this)});
                this._boundEvents.push({event: wcDocker.EVENT.CLOSED, handler: this.destroy.bind(this)});

                for (var i = 0; i < this._boundEvents.length; ++i) {
                    this._parent.on(this._boundEvents[i].event, this._boundEvents[i].handler);
                }
            }
        },

        // Updates the size of the splitter.
        __update: function (opt_dontMove) {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var minSize = this.__minPos();
            var maxSize = this.__maxPos();

            if (this._findBestPos) {
                this._findBestPos = false;

                var size1;
                var size2;
                if (this._pane[0] && typeof this._pane[0].initSize === 'function') {
                    size1 = this._pane[0].initSize();
                    if (size1) {
                        if (size1.x < 0) {
                            size1.x = width / 2;
                        }
                        if (size1.y < 0) {
                            size1.y = height / 2;
                        }
                    }
                }

                if (this._pane[1] && typeof this._pane[1].initSize === 'function') {
                    size2 = this._pane[1].initSize();
                    if (size2) {
                        if (size2.x < 0) {
                            size2.x = width / 2;
                        }
                        if (size2.y < 0) {
                            size2.y = height / 2;
                        }

                        size2.x = width - size2.x;
                        size2.y = height - size2.y;
                    }
                }

                var size;
                if (size1 && size2) {
                    size = {
                        x: Math.min(size1.x, size2.x),
                        y: Math.min(size1.y, size2.y)
                    };
                } else if (size1) {
                    size = size1;
                } else if (size2) {
                    size = size2;
                }

                if (size) {
                    if (this._orientation) {
                        this._pos = size.x / width;
                    } else {
                        this._pos = size.y / height;
                    }
                }
            }

            this.$bar.toggleClass('wcSplitterBarStatic', this.__isStatic());

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                var barBorder = parseInt(this.$bar.css('border-top-width')) + parseInt(this.$bar.css('border-bottom-width'));
                if (opt_dontMove) {
                    var offset = this._pixelPos - (this.$container.offset().left + parseInt(this.$container.css('border-left-width'))) - this.$bar.outerWidth() / 2;
                    this._pos = offset / (width - this.$bar.outerWidth());
                }

                this._pos = Math.min(Math.max(this._pos, 0), 1);
                var size = (width - this.$bar.outerWidth()) * this._pos + barSize;
                if (minSize) {
                    size = Math.max(minSize.x, size);
                }
                if (maxSize) {
                    size = Math.min(maxSize.x, size);
                }

                var top = 0;
                var bottom = 0;
                if (this._parent && this._parent.declaredClass === 'wcCollapser') {
                    var $outer = this.docker().$container;
                    var $inner = this._parent.$container;

                    top = $inner.offset().top - $outer.offset().top;
                    bottom = ($outer.offset().top + $outer.outerHeight()) - ($inner.offset().top + $inner.outerHeight());
                }

                // Bar is top to bottom
                this.$bar.css('left', size - barSize);
                this.$bar.css('top', top);
                this.$bar.css('height', height - barBorder - bottom);
                this.$pane[0].css('width', size - barSize);
                this.$pane[0].css('left', '0px');
                this.$pane[0].css('right', '');
                this.$pane[0].css('top', top);
                this.$pane[0].css('bottom', bottom);
                this.$pane[1].css('left', '');
                this.$pane[1].css('right', '0px');
                this.$pane[1].css('width', width - size - barSize - parseInt(this.$container.css('border-left-width')) * 2);
                this.$pane[1].css('top', top);
                this.$pane[1].css('bottom', bottom);

                this._pixelPos = this.$bar.offset().left + barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                var barBorder = parseInt(this.$bar.css('border-left-width')) + parseInt(this.$bar.css('border-right-width'));
                if (opt_dontMove) {
                    var offset = this._pixelPos - (this.$container.offset().top + parseInt(this.$container.css('border-top-width'))) - this.$bar.outerHeight() / 2;
                    this._pos = offset / (height - this.$bar.outerHeight());
                }

                this._pos = Math.min(Math.max(this._pos, 0), 1);
                var size = (height - this.$bar.outerHeight()) * this._pos + barSize;
                if (minSize) {
                    size = Math.max(minSize.y, size);
                }
                if (maxSize) {
                    size = Math.min(maxSize.y, size);
                }

                var left = 0;
                var right = 0;
                if (this._parent && this._parent.declaredClass === 'wcCollapser') {
                    var $outer = this.docker().$container;
                    var $inner = this._parent.$container;

                    left = $inner.offset().left - $outer.offset().left;
                    right = ($outer.offset().left + $outer.outerWidth()) - ($inner.offset().left + $inner.outerWidth());
                }

                // Bar is left to right
                this.$bar.css('top', size - barSize);
                this.$bar.css('left', left);
                this.$bar.css('width', width - barBorder - bottom);
                this.$pane[0].css('height', size - barSize);
                this.$pane[0].css('top', '0px');
                this.$pane[0].css('bottom', '');
                this.$pane[0].css('left', left);
                this.$pane[0].css('right', right);
                this.$pane[1].css('top', '');
                this.$pane[1].css('bottom', '0px');
                this.$pane[1].css('height', height - size - barSize - parseInt(this.$container.css('border-top-width')) * 2);
                this.$pane[1].css('left', left);
                this.$pane[1].css('right', right);

                this._pixelPos = this.$bar.offset().top + barSize;
            }

            if (opt_dontMove === undefined) {
                opt_dontMove = true;
            }
            this._pane[0] && this._pane[0].__update(opt_dontMove);
            this._pane[1] && this._pane[1].__update(opt_dontMove);
            //console.log('pos ' + this.pos());
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            // If this is a collapser splitter, do not save it, skip to the children.
            if (this._pane[0] && this._pane[0].declaredClass === 'wcCollapser') {
                return this._pane[1].__save();
            }
            if (this._pane[1] && this._pane[1].declaredClass === 'wcCollapser') {
                return this._pane[0].__save();
            }

            var data = {};
            data.type = 'wcSplitter';
            data.horizontal = this._orientation;
            data.isDrawer = this.$bar.hasClass('wcDrawerSplitterBar');
            data.pane0 = this._pane[0] ? this._pane[0].__save() : null;
            data.pane1 = this._pane[1] ? this._pane[1].__save() : null;
            data.pos = this._pos;
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._pos = data.pos;
            if (data.isDrawer) {
                this.$bar.addClass('wcDrawerSplitterBar');
            }
            if (data.pane0) {
                this._pane[0] = docker.__create(data.pane0, this, this.$pane[0]);
                this._pane[0].__restore(data.pane0, docker);
            }
            if (data.pane1) {
                this._pane[1] = docker.__create(data.pane1, this, this.$pane[1]);
                this._pane[1].__restore(data.pane1, docker);
            }
        },

        // Attempts to find the best splitter position based on
        // the contents of each pane.
        __findBestPos: function () {
            this._findBestPos = false;
        },

        // Moves the slider bar based on a mouse position.
        // Params:
        //    mouse       The mouse offset position.
        __moveBar: function (mouse) {
            var offset = this.$container.offset();
            mouse.x -= offset.left;
            mouse.y -= offset.top;

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var width = this.$container.outerWidth() - this.$bar.outerWidth();
                mouse.x += 1 - parseInt(this.$container.css('border-left-width')) - (this.$bar.outerWidth() / 2);
                this.pos(mouse.x / width);
            } else {
                var height = this.$container.outerHeight() - this.$bar.outerHeight();
                mouse.y += 1 - parseInt(this.$container.css('border-top-width')) - (this.$bar.outerHeight() / 2);
                this.pos(mouse.y / height);
            }
        },

        // Gets the minimum position of the splitter divider.
        __minPos: function () {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var minSize;
            if (this._pane[0] && typeof this._pane[0].minSize === 'function') {
                minSize = this._pane[0].minSize();
            } else {
                minSize = {x: 50, y: 50};
            }

            var maxSize;
            if (this._pane[1] && typeof this._pane[1].maxSize === 'function') {
                maxSize = this._pane[1].maxSize();
            } else {
                maxSize = {x: width, y: height};
            }

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                minSize.x += barSize;
                width -= barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                minSize.y += barSize;
                height -= barSize;
            }

            maxSize.x = width - Math.min(maxSize.x, width);
            maxSize.y = height - Math.min(maxSize.y, height);

            minSize.x = Math.max(minSize.x, maxSize.x);
            minSize.y = Math.max(minSize.y, maxSize.y);

            return minSize;
        },

        // Gets the maximum position of the splitter divider.
        __maxPos: function () {
            var width = this.$container.outerWidth();
            var height = this.$container.outerHeight();

            var maxSize;
            if (this._pane[0] && typeof this._pane[0].maxSize === 'function') {
                maxSize = this._pane[0].maxSize();
            } else {
                maxSize = {x: width, y: height};
            }

            var minSize;
            if (this._pane[1] && typeof this._pane[1].minSize === 'function') {
                minSize = this._pane[1].minSize();
            } else {
                minSize = {x: 50, y: 50};
            }

            if (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) {
                var barSize = this.$bar.outerWidth() / 2;
                maxSize.x += barSize;
                width -= barSize;
            } else {
                var barSize = this.$bar.outerHeight() / 2;
                maxSize.y += barSize;
                height -= barSize;
            }

            minSize.x = width - minSize.x;
            minSize.y = height - minSize.y;

            maxSize.x = Math.min(minSize.x, maxSize.x);
            maxSize.y = Math.min(minSize.y, maxSize.y);
            return maxSize;
        },

        // Retrieves whether the splitter is static (not moveable).
        __isStatic: function () {
            var attr = this._orientation === wcDocker.ORIENTATION.HORIZONTAL ? 'x' : 'y';
            for (var i = 0; i < 2; ++i) {
                if (this._pane[i] && this._pane[i].minSize && this._pane[i].maxSize &&
                    this._pane[i].maxSize()[attr] - this._pane[i].minSize()[attr] === 0) {
                    return true;
                }
            }

            return false;
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;

            if (this.$container) {
                this.$container.append(this.$pane[0]);
                this.$container.append(this.$pane[1]);
                this.$container.append(this.$bar);
            } else {
                this.$pane[0].remove();
                this.$pane[1].remove();
                this.$bar.remove();
            }
            return this.$container;
        },

        // Removes a child from this splitter.
        // Params:
        //    child         The child to remove.
        __removeChild: function (child) {
            if (this._pane[0] === child) {
                this._pane[0] = false;
            } else if (this._pane[1] === child) {
                this._pane[1] = false;
            } else {
                return;
            }

            if (child) {
                child.__container(null);
                child._parent = null;
            }
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            // Stop any animations.
            if (this._anim) {
                clearInterval(this._anim);
                this._anim = 0;
            }
            this.$bar.clearQueue();

            // Remove all registered events.
            while (this._boundEvents.length) {
                this._parent.off(this._boundEvents[0].event, this._boundEvents[0].handler);
                this._boundEvents.shift();
            }

            if (this._pane[0]) {
                this._pane[0].__destroy();
                this._pane[0] = null;
            }
            if (this._pane[1]) {
                this._pane[1].__destroy();
                this._pane[1] = null;
            }

            this.__container(null);
            this._parent = false;
        }
    });

    // window['wcSplitter'] = Module;

    return Module;
});

/**
 * A callback function that is called when an action is finished.
 *
 * @callback wcSplitter~onFinished
 */
;
/** @module wcFrame */
define('wcDocker/frame',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class module:wcFrame
     * The frame is a [panel]{@link module:wcPanel} container.
     * Each panel appears as a tabbed item inside a frame.
     */
    var Module = dcl(base, {
        declaredClass: 'wcFrame',
        LEFT_TAB_BUFFER: 15,
        /**
         * <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
         * @memberOf module:wcFrame
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this frame.
         * @param {module:wcSplitter|wcDocker} parent - The frames parent object.
         * @param {Boolean} isFloating - If true, the frame will be a floating window.
         */
        constructor: function (container, parent, isFloating) {
            /**
             * The container that holds the frame.
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;
            this._isFloating = isFloating;

            /**
             * The outer frame element.
             * @member {external:jQuery~Object}
             */
            this.$frame = null;
            this.$title = null;
            this.$titleBar = null;
            this.$tabBar = null;
            this.$tabScroll = null;
            this.$center = null;
            this.$tabLeft = null;
            this.$tabRight = null;
            this.$close = null;
            this.$collapse = null;
            this.$top = null;
            this.$bottom = null;
            this.$left = null;
            this.$right = null;
            this.$corner1 = null;
            this.$corner2 = null;
            this.$corner3 = null;
            this.$corner4 = null;
            this.$buttonBar = null;

            this.$shadower = null;
            this.$modalBlocker = null;

            this._titleVisible = true;
            this._canScrollTabs = false;
            this._tabOrientation = wcDocker.TAB.TOP;
            this._tabScrollPos = 0;
            this._curTab = -1;
            this._panelList = [];
            this._buttonList = [];

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            this._pos = {
                x: 0.5,
                y: 0.5
            };

            this._size = {
                x: 400,
                y: 400
            };

            this._lastSize = {
                x: 400,
                y: 400
            };

            this._anchorMouse = {
                x: 0,
                y: 0
            };

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Gets, or Sets the position of the frame.
         * @function module:wcFrame#pos
         * @param {Number} [x]        - If supplied, assigns a new horizontal position.
         * @param {Number} [y]        - If supplied, assigns a new vertical position.
         * @param {Boolean} [pixels]  - If true, the coordinates passed in will be treated as a pixel position rather than a percentage.
         * @returns {module:wcDocker~Coordinate} - The current position of the frame. If the pixel parameter was true, the position will be in pixels.
         */
        pos: function (x, y, pixels) {
            var width = this.$container.width();
            var height = this.$container.height();

            if (typeof x === 'undefined') {
                if (pixels) {
                    return {x: this._pos.x * width, y: this._pos.y * height};
                } else {
                    return {x: this._pos.x, y: this._pos.y};
                }
            }

            if (pixels) {
                this._pos.x = x / width;
                this._pos.y = y / height;
            } else {
                this._pos.x = x;
                this._pos.y = y;
            }
        },

        /**
         * Gets the initially desired size of the panel.
         * @function module:wcFrame#initSize
         * @returns {module:wcDocker~Size} - The initially desired size.
         */
        initSize: function () {
            var size = {
                x: -1,
                y: -1
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                if (size.x < this._panelList[i].initSize().x) {
                    size.x = this._panelList[i].initSize().x;
                }
                if (size.y < this._panelList[i].initSize().y) {
                    size.y = this._panelList[i].initSize().y;
                }
            }

            if (size.x < 0 || size.y < 0) {
                return false;
            }
            return size;
        },

        /**
         * Gets the minimum size of the frame.
         * @function module:wcFrame#minSize
         * @returns {module:wcDocker~Size} - The minimum size of the frame.
         */
        minSize: function () {
            var size = {
                x: 0,
                y: 0
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                size.x = Math.max(size.x, this._panelList[i].minSize().x);
                size.y = Math.max(size.y, this._panelList[i].minSize().y);
            }
            return size;
        },

        /**
         * Gets the maximum size of the frame.
         * @function module:wcFrame#maxSize
         * @returns {module:wcDocker~Size} - The maximum size of the frame.
         */
        maxSize: function () {
            var size = {
                x: Infinity,
                y: Infinity
            };

            for (var i = 0; i < this._panelList.length; ++i) {
                size.x = Math.min(size.x, this._panelList[i].maxSize().x);
                size.y = Math.min(size.y, this._panelList[i].maxSize().y);
            }
            return size;
        },

        /**
         * Gets, or Sets the tab orientation for the frame. This puts the tabbed widgets visually on any side of the frame.
         * @version 3.0.0
         * @function module:wcFrame#tabOrientation
         * @param {module:wcDocker.TAB} [orientation] - Assigns the orientation of the tab items displayed.
         * @returns {module:wcDocker.TAB} - The current orientation.
         */
        tabOrientation: function (orientation) {
            if (orientation !== undefined) {
                if (this._tabOrientation !== orientation && this.docker()._canOrientTabs) {
                    this._tabOrientation = orientation;

                    this.__updateTabs();
                    this.__updateTabs();
                }
            }

            return this._tabOrientation
        },

        /**
         * Adds a given panel as a new tab item to the frame.
         * @function module:wcFrame#addPanel
         * @param {module:wcPanel} panel         - The panel to add.
         * @param {Number} [index]        - Insert index.
         */
        addPanel: function (panel, index) {
            var found = this._panelList.indexOf(panel);
            if (found !== -1) {
                this._panelList.splice(found, 1);
            }

            if (typeof index === 'undefined') {
                this._panelList.push(panel);
            } else {
                this._panelList.splice(index, 0, panel);
            }

            if (this._curTab === -1 && this._panelList.length) {
                if (!this.isCollapser()) {
                    this._curTab = 0;
                }
                this._size = this.initSize();
            }

            this.__updateTabs();
        },

        /**
         * Removes a given panel from the frame.
         * @function module:wcFrame#removePanel
         * @param {module:wcPanel} panel - The panel to remove.
         * @returns {Boolean} - True if any panels still remain after the removal.
         */
        removePanel: function (panel) {
            for (var i = 0; i < this._panelList.length; ++i) {
                if (this._panelList[i] === panel) {
                    if (this.isCollapser()) {
                        this._curTab = -1;
                    } else if (this._curTab >= i) {
                        this._curTab--;
                    }

                    // Only null out the container if it is still attached to this frame.
                    if (this._panelList[i]._parent === this) {
                        this._panelList[i].__container(null);
                        this._panelList[i]._parent = null;
                    }

                    this._panelList.splice(i, 1);
                    panel._isVisible = false;
                    break;
                }
            }

            if (this._curTab === -1) {
                if (!this.collapse() && this._panelList.length) {
                    this._curTab = 0;
                }
            }

            this.__updateTabs();
            return this._panelList.length > 0;
        },

        /**
         * Gets, or Sets the currently visible panel.
         * @function module:wcFrame#panel
         * @param {Number} [tabIndex] - If supplied, sets the current panel index.
         * @param {Boolean} [autoFocus] - If true, this tab will be focused (brought to front).
         * @returns {module:wcPanel} - The currently visible panel.
         */
        panel: function (tabIndex, autoFocus) {
            if (typeof tabIndex !== 'undefined') {
                if (this.isCollapser() && tabIndex === this._curTab) {
                    this.collapse();
                    tabIndex = -1;
                }
                if (tabIndex < this._panelList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    if (this._curTab !== tabIndex) {
                        this.collapse();
                    }
                    this._curTab = tabIndex;
                    if (tabIndex > -1) {
                        this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + tabIndex + '"]').addClass('wcPanelTabActive');
                        this.$center.children('.wcPanelTabContent[id="' + tabIndex + '"]').removeClass('wcPanelTabContentHidden');
                        this.expand();
                    }
                    this.__updateTabs(autoFocus);
                }
            }

            if (this._curTab > -1 && this._curTab < this._panelList.length) {
                return this._panelList[this._curTab];
            } else if (this.isCollapser() && this._panelList.length) {
                return this._panelList[0];
            }
            return false;
        },

        /**
         * Gets whether this frame is inside a collapser.
         * @function module:wcFrame#isCollapser
         * @returns {Boolean} - Whether this frame is inside a collapser.
         */
        isCollapser: function () {
            return (this._parent && this._parent.declaredClass === 'wcDrawer');
        },

        /**
         * Collapses the frame, if it is a collapser.
         * @function module:wcFrame#collapse
         * @param {Boolean} [instant] - If true, collapses without animating.
         */
        collapse: function (instant) {
            if (this.isCollapser()) {
                this._parent.collapse(instant);
                return true;
            }
            return false;
        },

        /**
         * Expands the frame, if it is a collapser.
         * @function module:wcFrame#expand
         */
        expand: function () {
            if (this.isCollapser()) {
                this._parent.expand();
                return true;
            }
            return false;
        },

        /**
         * Gets whether the frame is expanded, if it is a collapser.
         * @function module:wcFrame#isExpanded
         * @returns {Boolean|undefined} - The current expanded state, or undefined if it is not a collapser.
         */
        isExpanded: function () {
            if (this.isCollapser()) {
                return this._parent.isExpanded();
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$frame = $('<div class="wcFrame wcWide wcTall">');
            this.$title = $('<div class="wcFrameTitle">');
            this.$titleBar = $('<div class="wcFrameTitleBar wcFrameTopper">');
            this.$tabBar = $('<div class="wcFrameTitleBar">');
            this.$tabScroll = $('<div class="wcTabScroller">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><div class="fa fa-close"></div>X</div>');

            this.$collapse = $('<div class="wcFrameButton" title="Collapse the active panel"><div class="fa fa-download"></div>C</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');
            this.$tabButtonBar = $('<div class="wcFrameButtonBar">');

            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$tabButtonBar);
            this.$frame.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);
            this.$buttonBar.append(this.$collapse);
            this.$frame.append(this.$center);

            if (this._isFloating) {
                this.$top = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('top', '-6px').css('left', '0px').css('right', '0px');
                this.$bottom = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('bottom', '-6px').css('left', '0px').css('right', '0px');
                this.$left = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('left', '-6px').css('top', '0px').css('bottom', '0px');
                this.$right = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('right', '-6px').css('top', '0px').css('bottom', '0px');
                this.$corner1 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('top', '-6px').css('left', '-6px');
                this.$corner2 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('top', '-6px').css('right', '-6px');
                this.$corner3 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('bottom', '-6px').css('right', '-6px');
                this.$corner4 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('bottom', '-6px').css('left', '-6px');

                this.$frame.append(this.$top);
                this.$frame.append(this.$bottom);
                this.$frame.append(this.$left);
                this.$frame.append(this.$right);
                this.$frame.append(this.$corner1);
                this.$frame.append(this.$corner2);
                this.$frame.append(this.$corner3);
                this.$frame.append(this.$corner4);
            }

            this.__container(this.$container);

            if (this._isFloating) {
                this.$frame.addClass('wcFloating');
            }

            this.$center.scroll(this.__scrolled.bind(this));
        },

        // Updates the size of the frame.
        __update: function () {
            var width = this.$container.width();
            var height = this.$container.height();

            // Floating windows manage their own sizing.
            if (this._isFloating) {
                var left = (this._pos.x * width) - this._size.x / 2;
                var top = (this._pos.y * height) - this._size.y / 2;

                if (top < 0) {
                    top = 0;
                }

                if (left + this._size.x / 2 < 0) {
                    left = -this._size.x / 2;
                }

                if (left + this._size.x / 2 > width) {
                    left = width - this._size.x / 2;
                }

                if (top + parseInt(this.$center.css('top')) > height) {
                    top = height - parseInt(this.$center.css('top'));
                }

                this.$frame.css('left', left + 'px');
                this.$frame.css('top', top + 'px');
                this.$frame.css('width', this._size.x + 'px');
                this.$frame.css('height', this._size.y + 'px');
            }

            if (width !== this._lastSize.x || height !== this._lastSize.y) {
                this._lastSize.x = width;
                this._lastSize.y = height;

                this._resizeData.time = new Date();
                if (!this._resizeData.timeout) {
                    this._resizeData.timeout = true;
                    setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                }
            }
            // this.__updateTabs();
            this.__onTabChange();
        },

        __resizeEnd: function () {
            this.__updateTabs(null,true);
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
            }
        },

        // Triggers an event exclusively on the docker and none of its panels.
        // Params:
        //    eventName   The name of the event.
        //    data        A custom data parameter to pass to all handlers.
        __trigger: function (eventName, data) {
            for (var i = 0; i < this._panelList.length; ++i) {
                this._panelList[i].__trigger(eventName, data);
            }
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.type = 'wcFrame';
            data.floating = this._isFloating;
            data.isFocus = this.$frame.hasClass('wcFloatingFocus');
            data.tabOrientation = this._tabOrientation;
            data.pos = {
                x: this._pos.x,
                y: this._pos.y
            };
            data.size = {
                x: this._size.x,
                y: this._size.y
            };
            data.tab = this._curTab;
            data.panels = [];
            for (var i = 0; i < this._panelList.length; ++i) {
                data.panels.push(this._panelList[i].__save());
            }
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._isFloating = data.floating;
            this._tabOrientation = data.tabOrientation || wcDocker.TAB.TOP;
            this._pos.x = data.pos.x;
            this._pos.y = data.pos.y;
            this._size.x = data.size.x;
            this._size.y = data.size.y;
            this._curTab = data.tab;
            for (var i = 0; i < data.panels.length; ++i) {
                var panel = docker.__create(data.panels[i], this, this.$center);
                panel.__restore(data.panels[i], docker);
                this._panelList.push(panel);
            }

            this.__update();

            if (data.isFocus) {
                this.$frame.addClass('wcFloatingFocus');
            }
        },

        __updateTabs: function (autoFocus,isResize) {
            this.$tabScroll.empty();
            var getOffset = function ($item) {
                switch (this._tabOrientation) {
                    case wcDocker.TAB.BOTTOM:
                        return $item.offset().left;
                    case wcDocker.TAB.TOP:
                        return $item.offset().left;
                    case wcDocker.TAB.LEFT:
                        return $item.offset().top;
                    case wcDocker.TAB.RIGHT:
                        return $item.offset().top;
                }
            }.bind(this);

            var visibilityChanged = [];
            var tabPositions = [];
            var totalWidth = 0;
            var parentLeft = getOffset(this.$tabScroll);
            var showTabs = this._panelList.length > 1 || this._isFloating || this.isCollapser();
            var self = this;

            if (this.isCollapser()) {
                // this.$titleBar.addClass('wcNotMoveable');
                this.$tabBar.addClass('wcNotMoveable');
            } else {
                this.$titleBar.removeClass('wcNotMoveable');
                this.$tabBar.removeClass('wcNotMoveable');
            }

            this.$center.children('.wcPanelTabContent').each(function () {
                $(this).addClass('wcPanelTabContentHidden wcPanelTabUnused');
            });

            this._titleVisible = true;
            this.$title.html('');



            // Determine if the title and tabs are visible based on the panels inside.
            for (var i = 0; i < this._panelList.length; ++i) {

                var panel = this._panelList[i];

                var $tab = null;
                if (showTabs) {
                    $tab = panel.$title;
                    panel.$title.attr('id', i);
                    this.$tabScroll.append(panel.$title);
                }

                if (!panel.moveable()) {
                    this.$titleBar.addClass('wcNotMoveable');
                    this.$tabBar.addClass('wcNotMoveable');
                }

                if (!panel._titleVisible) {
                    this._titleVisible = false;
                }

                var $tabContent=null;
                //if(isResize!==true) {
                    $tabContent = this.$center.children('.wcPanelTabContent[id="' + i + '"]');
                    if (!$tabContent.length) {
                        $tabContent = $('<div class="wcPanelTabContent wcPanelTabContentHidden" id="' + i + '">');
                        this.$center.append($tabContent);
                    }
                    panel.__container($tabContent);
                //}

                panel._parent = this;

                var isVisible = this._curTab === i;
                if (panel.isVisible() !== isVisible) {
                    visibilityChanged.push({
                        panel: panel,
                        isVisible: isVisible
                    });
                }

                $tabContent && $tabContent.removeClass('wcPanelTabUnused');

                if (isVisible) {
                    $tab && $tab.addClass('wcPanelTabActive active');
                    $tabContent && $tabContent.removeClass('wcPanelTabContentHidden');
                    this.$title.html(panel.title());
                    if (panel.$icon) {
                        var $icon = panel.$icon.clone();
                        this.$title.prepend($icon);
                    }
                }

                if ($tab) {
                    totalWidth = getOffset($tab) - parentLeft;
                    tabPositions.push(totalWidth);

                    totalWidth += $tab.outerWidth();
                }
            }

            var $topBar = this.$titleBar;
            var tabWidth = 0;
            if (this._titleVisible) {
                if (!this.$frame.parent()) {
                    this.$center.css('top', '');
                }
                switch (this._tabOrientation) {
                    case wcDocker.TAB.TOP:
                        this.$frame.prepend(this.$tabBar);
                        this.$titleBar.remove();
                        this.$tabBar.addClass('wcTabTop').removeClass('wcTabLeft wcTabRight wcTabBottom');
                        // this.$tabBar.css('margin-top', '');
                        if (showTabs) {
                            this.$title.remove();
                        } else {
                            this.$tabBar.prepend(this.$title);
                        }
                        $topBar = this.$tabBar;
                        this.$center.css('left', 0).css('right', 0).css('bottom', 0);
                        tabWidth = this.$center.width();
                        break;
                    case wcDocker.TAB.BOTTOM:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabBottom').removeClass('wcTabTop wcTabLeft wcTabRight');
                            // this.$tabBar.css('margin-top', '');

                            this.$center.css('left', 0).css('right', 0).css('bottom', titleSize);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.width();
                        break;

                    case wcDocker.TAB.LEFT:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabLeft').removeClass('wcTabTop wcTabRight wcTabBottom');
                            // this.$tabBar.css('margin-top', titleSize);

                            this.$center.css('left', titleSize).css('right', 0).css('bottom', 0);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.height();
                        break;

                    case wcDocker.TAB.RIGHT:
                        this.$frame.prepend(this.$titleBar);
                        this.$titleBar.append(this.$title);

                        if (showTabs) {
                            var titleSize = this.$titleBar.height();
                            this.$frame.append(this.$tabBar);
                            this.$tabBar.addClass('wcTabRight').removeClass('wcTabTop wcTabLeft wcTabBottom');
                            // this.$tabBar.css('margin-top', titleSize);

                            this.$center.css('left', 0).css('right', titleSize).css('bottom', 0);
                        } else {
                            this.$tabBar.remove();
                        }
                        tabWidth = this.$center.height();
                        break;
                }
                if (!showTabs) {
                    this.$center.css('left', 0).css('right', 0).css('bottom', 0);
                }
            } else {
                this.$titleBar.remove();
                this.$tabBar.remove();
                this.$center.css('top', 0).css('left', 0).css('right', 0).css('bottom', 0);
            }

            // Now remove all unused panel tabs.
            this.$center.children('.wcPanelTabUnused').each(function () {
                $(this).remove();
            });

            if (this._titleVisible) {
                var buttonSize = this.__onTabChange();

                if (autoFocus) {
                    for (var i = 0; i < tabPositions.length; ++i) {
                        if (i === this._curTab) {
                            var left = tabPositions[i];
                            var right = totalWidth;
                            if (i + 1 < tabPositions.length) {
                                right = tabPositions[i + 1];
                            }

                            var scrollPos = -parseInt(this.$tabScroll.css('left'));
                            var titleWidth = tabWidth - buttonSize;

                            // If the tab is behind the current scroll position.
                            if (left < scrollPos) {
                                this._tabScrollPos = left - this.LEFT_TAB_BUFFER;
                                if (this._tabScrollPos < 0) {
                                    this._tabScrollPos = 0;
                                }
                            }
                            // If the tab is beyond the current scroll position.
                            else if (right - scrollPos > titleWidth) {
                                this._tabScrollPos = right - titleWidth + this.LEFT_TAB_BUFFER;
                            }
                            break;
                        }
                    }
                }

                this._canScrollTabs = false;
                if (totalWidth > tabWidth - buttonSize) {
                    this._canScrollTabs = this._titleVisible;
                    if (this._canScrollTabs) {
                        this.$tabButtonBar.append(this.$tabRight);
                        this.$tabButtonBar.append(this.$tabLeft);
                        buttonSize += this.$tabRight.outerWidth();
                        buttonSize += this.$tabLeft.outerWidth();
                    }

                    var scrollLimit = totalWidth - (tabWidth - buttonSize) / 2;
                    // If we are beyond our scroll limit, clamp it.
                    if (this._tabScrollPos > scrollLimit) {
                        var children = this.$tabScroll.children();
                        for (var i = 0; i < children.length; ++i) {
                            var $tab = $(children[i]);

                            totalWidth = getOffset($tab) - parentLeft;
                            if (totalWidth + $tab.outerWidth() > scrollLimit) {
                                this._tabScrollPos = totalWidth - this.LEFT_TAB_BUFFER;
                                if (this._tabScrollPos < 0) {
                                    this._tabScrollPos = 0;
                                }
                                break;
                            }
                        }
                    }
                } else {
                    this._tabScrollPos = 0;
                    this.$tabLeft.remove();
                    this.$tabRight.remove();
                }

                //this.$tabScroll.stop().animate({left: -this._tabScrollPos + 'px'}, 'fast');

                // Update visibility on panels.
                for (var i = 0; i < visibilityChanged.length; ++i) {
                    visibilityChanged[i].panel.__isVisible(visibilityChanged[i].isVisible);
                }
            }
        },

        __onTabChange: function () {
            var buttonSize = 0;
            var tabButtonSize = 0;
            var panel = this.panel();
            this.$tabLeft.remove();
            this.$tabRight.remove();
            this.$close.hide();
            this.$collapse.hide();

            while (this._buttonList.length) {
                this._buttonList.pop().remove();
            }

            if (panel) {
                var scrollable = panel.scrollable();
                this.$center.toggleClass('wcScrollableX', scrollable.x);
                this.$center.toggleClass('wcScrollableY', scrollable.y);
                this.$frame.toggleClass('wcOverflowVisible', panel.overflowVisible());
                this.$center.toggleClass('wcOverflowVisible', panel.overflowVisible());

                if (!this.isCollapser() || this.isExpanded()) {
                    if (panel.closeable()) {
                        this.$close.show();
                        buttonSize += this.$close.outerWidth();
                    }

                    var docker = this.docker();
                    if (docker.isCollapseEnabled() && panel.moveable() && panel.collapsible() && !this._isFloating && !panel._isPlaceholder) {
                        if (this.isCollapser()) {
                            // Un-collapse
                            var $icon = this.$collapse.children('div');
                            $icon[0].className = 'fa fa-sign-out';
                            switch (this._parent._position) {
                                case wcDocker.DOCK.LEFT:
                                    $icon.addClass('wcCollapseLeft');
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    $icon.addClass('wcCollapseRight');
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    $icon.addClass('wcCollapseBottom');
                                    break;
                            }
                            $icon.addClass('wcCollapsed');
                            this.$collapse.show();
                            this.$collapse.attr('title', 'Dock this collapsed panel back into the main layout.');
                            buttonSize += this.$collapse.outerWidth();
                        } else {
                            var direction = wcDocker.DOCK.BOTTOM;
                            if (panel._collapseDirection === wcDocker.DOCK.LEFT ||
                                panel._collapseDirection === wcDocker.DOCK.RIGHT ||
                                panel._collapseDirection === wcDocker.DOCK.BOTTOM) {
                                // Static collapse direction.
                                direction = panel._collapseDirection;
                            } else {
                                // Determine the direction to collapse based on the frame center.
                                var $inner = docker.$container;
                                if (!$.isEmptyObject(docker._collapser) && docker._collapser.hasOwnProperty(wcDocker.DOCK.RIGHT)) {
                                    // Get the inner contents element not taken up by the collapsible drawers.
                                    $inner = docker._collapser[wcDocker.DOCK.RIGHT]._parent.$pane[0];
                                }

                                var outer = $inner.offset();
                                var bounds = this.$container.offset();
                                bounds.right = (bounds.left + this.$container.width() - outer.left) / $inner.width();
                                bounds.bottom = (bounds.top + this.$container.height() - outer.top) / $inner.height();
                                bounds.top = (bounds.top - outer.top) / $inner.height();
                                bounds.left = (bounds.left - outer.left) / $inner.width();

                                if (typeof panel._collapseDirection === 'function') {
                                    // Custom collapse handler.
                                    direction = panel._collapseDirection(bounds);
                                } else {
                                    // Default collapse calculation.
                                    if (bounds.top > 0.5 && bounds.bottom > 0.95) {
                                        direction = wcDocker.DOCK.BOTTOM;
                                    } else if (bounds.left <= 0.05) {
                                        direction = wcDocker.DOCK.LEFT;
                                    } else if (bounds.right >= 0.95) {
                                        direction = wcDocker.DOCK.RIGHT;
                                    } else if (bounds.bottom > 0.95) {
                                        direction = wcDocker.DOCK.BOTTOM;
                                    }
                                }
                            }

                            var directionLabel = '';
                            var directionClass = '';
                            switch (direction) {
                                case wcDocker.DOCK.LEFT:
                                    directionLabel = 'left side.';
                                    directionClass = 'wcCollapseLeft';
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    directionLabel = 'right side.';
                                    directionClass = 'wcCollapseRight';
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    directionLabel = 'bottom.';
                                    directionClass = 'wcCollapseBottom';
                                    break;
                            }

                            if (directionLabel) {
                                var $icon = this.$collapse.children('div');
                                $icon[0].className = 'fa fa-sign-in';
                                $icon.addClass(directionClass);
                                $icon.addClass('wcCollapsible');
                                this.$collapse.show();
                                this.$collapse.attr('title', 'Collapse this panel into the ' + directionLabel);
                                buttonSize += this.$collapse.outerWidth();
                            }
                        }
                    }

                    for (var i = 0; i < panel._buttonList.length; ++i) {
                        var buttonData = panel._buttonList[i];
                        var $button = $('<div>');
                        var buttonClass = buttonData.className;
                        $button.addClass('wcFrameButton');
                        if (buttonData.isTogglable) {
                            $button.addClass('wcFrameButtonToggler');

                            if (buttonData.isToggled) {
                                $button.addClass('wcFrameButtonToggled');
                                buttonClass = buttonData.toggleClassName || buttonClass;
                            }
                        }
                        $button.attr('title', buttonData.tip);
                        $button.data('name', buttonData.name);
                        $button.text(buttonData.text);
                        if (buttonClass) {
                            $button.prepend($('<div class="' + buttonClass + '">'));
                        }

                        this._buttonList.push($button);
                        this.$buttonBar.append($button);
                        buttonSize += $button.outerWidth();
                    }
                }

                if (this._canScrollTabs) {
                    this.$tabButtonBar.append(this.$tabRight);
                    this.$tabButtonBar.append(this.$tabLeft);

                    tabButtonSize += this.$tabRight.outerWidth() + this.$tabLeft.outerWidth();
                }

                if (this._titleVisible) {
                    this.$buttonBar.css('right', '');
                    switch (this._tabOrientation) {
                        case wcDocker.TAB.RIGHT:
                            this.$buttonBar.css('right', this.$tabBar.height());
                        case wcDocker.TAB.LEFT:
                            this.$tabBar.css('width', this.$center.height() + this.$tabBar.height());
                            break;
                        case wcDocker.TAB.TOP:
                        case wcDocker.TAB.BOTTOM:
                            this.$tabBar.css('width', this.$center.width());
                            break;
                        default:
                            break;
                    }
                }

                panel.__update();

                this.$center.scrollLeft(panel._scroll.x);
                this.$center.scrollTop(panel._scroll.y);
            }

            this.$buttonBar.css('min-width', buttonSize).css('width', buttonSize);
            this.$tabButtonBar.css('min-width', tabButtonSize).css('width', tabButtonSize);

            if (this._tabOrientation === wcDocker.TAB.TOP) {
                this.$tabButtonBar.css('right', buttonSize);
                return buttonSize + tabButtonSize;
            } else {
                this.$tabButtonBar.css('right', 0);
                return tabButtonSize;
            }
        },

        // Handles scroll notifications.
        __scrolled: function () {
            var panel = this.panel();
            panel._scroll.x = this.$center.scrollLeft();
            panel._scroll.y = this.$center.scrollTop();

            panel.__trigger(wcDocker.EVENT.SCROLLED);
        },

        // Brings the frame into focus.
        // Params:
        //    flash     Optional, if true will flash the window.
        __focus: function (flash) {
            if (flash) {
                var $flasher = $('<div class="wcFrameFlasher">');
                this.$frame.append($flasher);
                $flasher.animate({
                    opacity: 1
                }, 100)
                    .animate({
                        opacity: 0.0
                    }, 100)
                    .animate({
                        opacity: 0.6
                    }, 50)
                    .animate({
                        opacity: 0.0
                    }, 50)
                    .queue(function (next) {
                        $flasher.remove();
                        next();
                    });
            }
        },

        // Moves the panel based on mouse dragging.
        // Params:
        //    mouse     The current mouse position.
        __move: function (mouse) {
            var width = this.$container.width();
            var height = this.$container.height();

            this._pos.x = (mouse.x + this._anchorMouse.x) / width;
            this._pos.y = (mouse.y + this._anchorMouse.y) / height;
        },

        // Sets the anchor position for moving the panel.
        // Params:
        //    mouse     The current mouse position.
        __anchorMove: function (mouse) {
            var width = this.$container.width();
            var height = this.$container.height();

            this._anchorMouse.x = (this._pos.x * width) - mouse.x;
            this._anchorMouse.y = (this._pos.y * height) - mouse.y;
        },

        // Moves a tab from a given index to another index.
        // Params:
        //    fromIndex     The current tab index to move.
        //    toIndex       The new index to move to.
        // Returns:
        //    element       The new element of the moved tab.
        //    false         If an error occurred.
        __tabMove: function (fromIndex, toIndex) {
            if (fromIndex >= 0 && fromIndex < this._panelList.length &&
                toIndex >= 0 && toIndex < this._panelList.length) {
                var panel = this._panelList.splice(fromIndex, 1);
                this._panelList.splice(toIndex, 0, panel[0]);

                // Preserve the currently active tab.
                if (this._curTab === fromIndex) {
                    this._curTab = toIndex;
                }

                this.__updateTabs();

                return this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + toIndex + '"]')[0];
            }
            return false;
        },

        // Checks if the mouse is in a valid anchor position for docking a panel.
        // Params:
        //    mouse       The current mouse position.
        //    same        Whether the moving frame and this one are the same.
        //    ghost       The ghost object.
        //    canSplit    Whether the frame can be split
        //    isTopper    Whether the user is dragging the topper (top title bar).
        //    allowEdges  Whether to allow edge docking.
        __checkAnchorDrop: function (mouse, same, ghost, canSplit, isTopper, allowEdges) {
            var panel = this.panel();
            if (panel && panel.moveable()) {
                return panel.layout().__checkAnchorDrop(mouse, same && this._tabOrientation, ghost, (!this._isFloating && !this.isCollapser() && canSplit), this.$frame, panel.moveable() && panel.title(), isTopper, this.isCollapser() ? this._tabOrientation : undefined, allowEdges);
            }
            return false;
        },

        // Resizes the panel based on mouse dragging.
        // Params:
        //    edges     A list of edges being moved.
        //    mouse     The current mouse position.
        __resize: function (edges, mouse) {
            var width = this.$container.width();
            var height = this.$container.height();
            var offset = this.$container.offset();

            mouse.x -= offset.left;
            mouse.y -= offset.top;

            var minSize = this.minSize();
            var maxSize = this.maxSize();

            var pos = {
                x: (this._pos.x * width) - this._size.x / 2,
                y: (this._pos.y * height) - this._size.y / 2
            };

            for (var i = 0; i < edges.length; ++i) {
                switch (edges[i]) {
                    case 'top':
                        this._size.y += pos.y - mouse.y - 2;
                        pos.y = mouse.y + 2;
                        if (this._size.y < minSize.y) {
                            pos.y += this._size.y - minSize.y;
                            this._size.y = minSize.y;
                        }
                        if (this._size.y > maxSize.y) {
                            pos.y += this._size.y - maxSize.y;
                            this._size.y = maxSize.y;
                        }
                        break;
                    case 'bottom':
                        this._size.y = mouse.y - 4 - pos.y;
                        if (this._size.y < minSize.y) {
                            this._size.y = minSize.y;
                        }
                        if (this._size.y > maxSize.y) {
                            this._size.y = maxSize.y;
                        }
                        break;
                    case 'left':
                        this._size.x += pos.x - mouse.x - 2;
                        pos.x = mouse.x + 2;
                        if (this._size.x < minSize.x) {
                            pos.x += this._size.x - minSize.x;
                            this._size.x = minSize.x;
                        }
                        if (this._size.x > maxSize.x) {
                            pos.x += this._size.x - maxSize.x;
                            this._size.x = maxSize.x;
                        }
                        break;
                    case 'right':
                        this._size.x = mouse.x - 4 - pos.x;
                        if (this._size.x < minSize.x) {
                            this._size.x = minSize.x;
                        }
                        if (this._size.x > maxSize.x) {
                            this._size.x = maxSize.x;
                        }
                        break;
                }

                this._pos.x = (pos.x + this._size.x / 2) / width;
                this._pos.y = (pos.y + this._size.y / 2) / height;
            }
        },

        // Turn off or on a shadowing effect to signify this widget is being moved.
        // Params:
        //    enabled       Whether to enable __shadow mode.
        __shadow: function (enabled) {
            if (enabled) {
                if (!this.$shadower) {
                    this.$shadower = $('<div class="wcFrameShadower">');
                    this.$frame.append(this.$shadower);
                    this.$shadower.animate({
                        opacity: 0.5
                    }, 300);
                }
            } else {
                if (this.$shadower) {
                    var self = this;
                    this.$shadower.animate({
                        opacity: 0.0
                    }, 300)
                        .queue(function (next) {
                            self.$shadower.remove();
                            self.$shadower = null;
                            next();
                        });
                }
            }
        },

        // Retrieves the bounding rect for this frame.
        __rect: function () {
            if (this.isCollapser()) {
                return this._parent.__rect();
            }

            var offset = this.$frame.offset();
            var width = this.$frame.width();
            var height = this.$frame.height();

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            this._curTab = -1;
            for (var i = 0; i < this._panelList.length; ++i) {
                this._panelList[i].__destroy();
            }

            while (this._panelList.length) this._panelList.pop();
            if (this.$modalBlocker) {
                this.$modalBlocker.remove();
                this.$modalBlocker = null;
            }
            this.__container(null);
            this._parent = null;
        }
    });
    return Module;
});


/** @module wcDrawer */
define('wcDocker/drawer',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/frame",
    "wcDocker/base"
], function (dcl, wcDocker, wcFrame, base) {
    /**
     * A docker container for carrying its own arrangement of docked panels as a slide out drawer.
     * @class module:wcDrawer
     * A collapsable container for carrying panels.<br>
     *
     * @version 3.0.0
     * @description <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
     */
    var Module = dcl(base,{
        declaredClass: 'wcDrawer',
        /**
         * @memberOf module:wcDrawer
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this drawer.
         * @param {wcSplitter|wcDocker} parent - The drawer's parent object.
         * @param {module:wcDocker.DOCK} position - A docking position to place this drawer.
         */
        constructor:function (container, parent, position) {
            this.$container = $(container);
            this.$frame = null;
            this._position = position;
            this._parent = parent;
            this._frame = null;
            this._closeSize = 0;
            this._expanded = false;
            this._sliding = false;
            this._orientation = (this._position === wcDocker.DOCK.LEFT || this._position === wcDocker.DOCK.RIGHT) ? wcDocker.ORIENTATION.HORIZONTAL : wcDocker.ORIENTATION.VERTICAL;
            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Collapses the drawer to its respective side wall.
         * @function module:wcDrawer#collapse
         */
        collapse: function (instant) {
            if (this._expanded) {
                // Collapse happens before the tab is de-selected, so record the
                // current size and assign it to the current panel.
                var panel = this._frame.panel();
                if (panel) {
                    var size = this._parent.pos();
                    if (this._position !== wcDocker.DOCK.LEFT) {
                        size = 1.0 - size;
                    }

                    var max;
                    if (this._position === wcDocker.DOCK.BOTTOM) {
                        max = this.docker().$container.height();
                        panel._size.y = size * max;
                    } else {
                        max = this.docker().$container.width();
                        panel._size.x = size * max;
                    }
                }

                this._expanded = false;
                if (instant) {
                    switch (this._position) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            this._parent.pos(0);
                            break;
                        case wcDocker.DOCK.RIGHT:
                        case wcDocker.DOCK.BOTTOM:
                            this._parent.pos(1);
                            break;
                    }
                } else {
                    this._sliding = true;

                    var self = this;
                    var fin = function () {
                        self._sliding = false;
                        self._parent.__update();
                    };

                    switch (this._position) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            this._parent.animPos(0, fin);
                            break;
                        case wcDocker.DOCK.RIGHT:
                        case wcDocker.DOCK.BOTTOM:
                            this._parent.animPos(1, fin);
                            break;
                    }
                }
            }
        },

        /**
         * Expands the drawer.
         * @function module:wcDrawer#expand
         */
        expand: function () {
            if (!this._expanded) {
                this._expanded = true;
                this._sliding = true;

                var panel = this._frame.panel();
                if (panel) {
                    // Determine the size to expand the drawer based on the size of the panel.
                    var size, max;
                    if (this._position === wcDocker.DOCK.BOTTOM) {
                        size = panel._size.y;
                        max = this.docker().$container.height();
                    } else {
                        size = panel._size.x;
                        max = this.docker().$container.width();
                    }

                    if (this._position !== wcDocker.DOCK.LEFT) {
                        size = max - size;
                    }

                    size = size / max;
                    var self = this;
                    this._parent.animPos(size, function () {
                        self._sliding = false;
                        self._parent.__update();
                    });
                }
            }
        },

        /**
         * Gets whether the drawer is expanded.
         * @function module:wcDrawer#isExpanded
         * @returns {Boolean} - The current expanded state.
         */
        isExpanded: function () {
            return this._expanded;
        },

        /**
         * The minimum size constraint for the drawer area.
         * @function module:wcDrawer#minSize
         * @returns {module:wcDocker~Size} - The minimum size.
         */
        minSize: function () {
            if (this._expanded) {
                if (this._root && typeof this._root.minSize === 'function') {
                    return this._root.minSize();
                } else {
                    return {x: 100, y: 50};
                }
            }
            this.__adjustCollapsedSize();
            return {x: this._closeSize, y: this._closeSize};
        },

        /**
         * The maximum size constraint for the drawer area.
         * @function module:wcDrawer#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var isHorizontal = (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) ? true : false;
            if (this._expanded || this._sliding) {
                if (this._root && typeof this._root.maxSize === 'function') {
                    return {
                        x: (isHorizontal ? this._root.maxSize().x : Infinity),
                        y: (!isHorizontal ? this._root.maxSize().y : Infinity)
                    };
                } else {
                    return {x: Infinity, y: Infinity};
                }
            }
            this.__adjustCollapsedSize();
            return {
                x: (isHorizontal ? this._closeSize : Infinity),
                y: (!isHorizontal ? this._closeSize : Infinity)
            };
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        __init: function () {
            this.$frame = $('<div class="wcCollapserFrame">');
            this.__container(this.$container);

            this._frame = new (this.docker().__getClass('wcFrame'))(this.$frame, this, false);
            this._frame.tabOrientation(this._position);
        },

        // Updates the size of the collapser.
        __update: function (opt_dontMove) {
            this.__adjustCollapsedSize();
            this._frame.__update();
        },

        // Adjusts the size of the collapser when it is closed.
        __adjustCollapsedSize: function () {
            if (this._frame._panelList.length) {
                this._closeSize = this._frame.$tabBar.outerHeight();
                this._parent.$bar.removeClass('wcSplitterHidden');
            } else {
                this._closeSize = 0;
                this._parent.$bar.addClass('wcSplitterHidden');
            }
        },

        // Retrieves the bounding rect for this collapser.
        __rect: function () {
            var offset = this.$frame.offset();
            var width = this.$frame.width();
            var height = this.$frame.height();

            var panel = this._frame.panel();
            if (panel) {
                // Determine the size to expand the drawer based on the size of the panel.
                if (this._position === wcDocker.DOCK.BOTTOM) {
                    height = panel._size.y;
                    width = width / 3;
                } else {
                    width = panel._size.x;
                    height = height / 3;
                }
            }

            return {
                x: offset.left,
                y: offset.top,
                w: width,
                h: height
            };
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {

            var data = {};
            data.closeSize = this._closeSize;
            data.frame = this._frame.__save();
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._closeSize = data.closeSize;
            this._frame.__restore(data.frame, docker);
            this.__adjustCollapsedSize();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            if (this._frame) {
                this._frame.__destroy();
                this._frame = null;
            }

            this.__container(null);
            this._parent = null;
        }
    });

    return Module;
});
/** @module wcCollapser */
define('wcDocker/collapser',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/splitter",
    "wcDocker/drawer",
    "wcDocker/base"
], function (dcl, wcDocker, wcSplitter, wcDrawer, base) {

    /**
     * A collapsable container for carrying panels.<br>
     *
     * @class module:wcCollapser
     * @version 3.0.0
     * @description A docker container for carrying its own arrangement of docked panels as a slide out drawer.<br/>
     * <b><i>PRIVATE<i> - Handled internally by [docker]{@link module:wcDocker} and <u>should never be constructed by the user.</u></b>
     */
    var Module = dcl(base, {
        declaredClass:'wcCollapser',
        /**
         * @memberOf module:wcCollapser
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this drawer.
         * @param {module:wcSplitter|wcDocker} parent  - The drawer's parent object.
         * @param {module:wcDocker.DOCK} position      - A docking position to place this drawer.
         */
        constructor: function (container, parent, position) {

            this.$container = $(container);
            this.$frame = null;

            this._position = position;
            this._parent = parent;
            this._splitter = null;
            this._drawer = null;
            this._size = 0;
            this._orientation = (this._position === wcDocker.DOCK.LEFT || this._position === wcDocker.DOCK.RIGHT) ? wcDocker.ORIENTATION.HORIZONTAL : wcDocker.ORIENTATION.VERTICAL;

            this.__init();
        },
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Collapses the drawer to its respective side wall.
         * @function module:wcCollapser#collapse
         */
        collapse: function (instant) {
            this._drawer.collapse();
        },

        /**
         * Expands the drawer.
         * @function module:wcCollapser#expand
         */
        expand: function () {
            this._drawer.expand();
        },

        /**
         * Gets whether the drawer is expanded.
         * @function module:wcCollapser#isExpanded
         * @returns {Boolean} - The current expanded state.
         */
        isExpanded: function () {
            return this._drawer.isExpanded();
        },

        /**
         * The minimum size constraint for the side bar area.
         * @function module:wcCollapser#minSize
         * @returns {module:wcDocker~Size} - The minimum size.
         */
        minSize: function () {
            return {x: this._size, y: this._size};
        },

        /**
         * The maximum size constraint for the side bar area.
         * @function module:wcCollapser#maxSize
         * @returns {module:wcDocker~Size} - The maximum size.
         */
        maxSize: function () {
            var isHorizontal = (this._orientation === wcDocker.ORIENTATION.HORIZONTAL) ? true : false;
            return {
                x: (isHorizontal ? this._size : Infinity),
                y: (!isHorizontal ? this._size : Infinity)
            };
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Private Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        __init: function () {
            this.$frame = $('<div class="wcCollapserFrame">');
            this.__container(this.$container);

            var docker = this.docker();
            this._splitter = new (this.docker().__getClass('wcSplitter'))(docker.$container, this, this._orientation);
            this._drawer = new (this.docker().__getClass('wcDrawer'))(docker.$transition, this._splitter, this._position);
            switch (this._position) {
                case wcDocker.DOCK.LEFT:
                    this._splitter.pane(0, this._drawer);
                    this._splitter.$pane[1].remove();
                    this._splitter.$pane[0].addClass('wcDrawer');
                    this._splitter.pos(0);
                    break;
                case wcDocker.DOCK.RIGHT:
                case wcDocker.DOCK.BOTTOM:
                    this._splitter.pane(1, this._drawer);
                    this._splitter.$pane[0].remove();
                    this._splitter.$pane[1].addClass('wcDrawer');
                    this._splitter.pos(1);
                    break;
            }

            this._parent.$bar.addClass('wcSplitterHidden');
        },

        // Updates the size of the collapser.
        __update: function (opt_dontMove) {
            this._splitter.__update();
            this.__adjustSize();
        },

        // Adjusts the size of the collapser based on css
        __adjustSize: function () {
            if (this._drawer._frame._panelList.length) {
                this._size = this._drawer._frame.$tabBar.outerHeight();
            } else {
                this._size = 0;
            }
        },

        // Retrieves the bounding rect for this collapser.
        __rect: function () {
            return this._drawer.__rect();
        },

        // Saves the current panel configuration into a meta
        // object that can be used later to restore it.
        __save: function () {
            var data = {};
            data.size = this._size;
            data.drawer = this._drawer.__save();
            return data;
        },

        // Restores a previously saved configuration.
        __restore: function (data, docker) {
            this._size = data.size;
            this._drawer.__restore(data.drawer, docker);
            this.__adjustSize();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;

            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            if (this._splitter) {
                this._splitter.__destroy();
                this._splitter = null;
                this._frame = null;
            }

            this.__container(null);
            this._parent = null;
        }
    });

    return Module;

});

/** @module wcLayout */
define('wcDocker/layout',[
    "dcl/dcl",
    "wcDocker/types"
], function (dcl, wcDocker) {

    /**
     * @class
     * The base class for all panel layouts. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} contain these to organize their contents.
     */
    var Module = dcl(null, {
        declaredClass: 'wcLayout',

        /**
         * @memberOf module:wcLayout
         * <b><i>PRIVATE</i> - <u>This should never be constructed directly by the user</u></b>
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this layout.
         * @param {wcLayout|wcSplitter|wcDocker} parent - The layout's parent object.
         */
        constructor: function (container, parent) {
            /**
             * The outer container element of the panel.
             *
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;

            /**
             * The table DOM element for the layout.
             *
             * @member {external:jQuery~Object}
             */
            this.$elem = null;

            this.__init();
        },

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, appending it to the main element.
         * @function module:wcLayout#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         */
        addItem: function (item) {
            // Should be implemented by a sub-class.
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayout#clear
         */
        clear: function () {
            // Should be implemented by a sub-class.
        },

        /**
         * Retrieves the main element.
         * @function module:wcLayout#scene
         * @returns {external:jQuery~Object} - The div item that makes this layout scene.
         */
        scene: function () {
            return this.$elem;
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            // Should be implemented by a sub-class.
        },

        // Updates the size of the layout.
        __update: function () {
            // Should be implemented by a sub-class.
        },

        // Checks if the mouse is in a valid anchor position for nesting another widget.
        // Params:
        //    mouse                 The current mouse position.
        //    same                  Whether we are hovering over the same panel that is being moved.
        //    ghost                 An instance to the ghost object.
        //    canSplit              Whether the original panel can be split.
        //    $elem                 The container element for the target panel.
        //    title                 Whether the panel has a title bar visible.
        //    isTopper              Whether the item being dragged is the top title bar, as apposed to dragging a side or bottom tab/bar.
        //    forceTabOrientation   Force a specific tab orientation.
        //    allowEdges            Whether to allow edge docking.
        __checkAnchorDrop: function (mouse, same, ghost, canSplit, $elem, title, isTopper, forceTabOrientation, allowEdges) {
            var docker = this._parent.docker();
            var width = $elem.outerWidth();
            var height = $elem.outerHeight();
            var offset = $elem.offset();
            var titleSize = $elem.find('.wcFrameTitleBar').height();
            if (!title) {
                titleSize = 0;
            }

            function __getAnchorSizes(value, w, h) {
                if (typeof value === 'number' || (typeof value === 'string' && value.indexOf('px', value.length - 2) !== -1)) {
                    // Pixel sizing.
                    value = parseInt(value);
                    return {
                        x: value,
                        y: value
                    };
                } else if (typeof value === 'string' && value.indexOf('%', value.length - 1) !== -1) {
                    value = parseInt(value) / 100;
                    // Percentage sizing.
                    return {
                        x: w * value,
                        y: h * value
                    };
                } else {
                    // Invalid value.
                    return {x: 0, y: 0};
                }
            }

            var edgeAnchor = __getAnchorSizes(docker._options.edgeAnchorSize, docker.$container.outerWidth(), docker.$container.outerHeight());
            var panelAnchor = __getAnchorSizes(docker._options.panelAnchorSize, width, height);

            // If the target panel has a title, hovering over it (on all sides) will cause stacking
            // and also change the orientation of the tabs (if enabled).
            if (title) {
                // Top title bar
                if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.TOP) &&
                    mouse.y >= offset.top && mouse.y <= offset.top + titleSize &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {

                    // Stacking with top orientation.
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: titleSize - 2,
                        loc: wcDocker.DOCK.STACKED,
                        tab: wcDocker.TAB.TOP,
                        item: this,
                        self: same === wcDocker.TAB.TOP || (isTopper && same)
                    });
                    return true;
                }
                // Any other tab orientation is only valid if tab orientation is enabled.
                else if (docker._canOrientTabs) {
                    // Bottom bar
                    if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.BOTTOM) &&
                        mouse.y >= offset.top + height - titleSize && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left && mouse.x <= offset.left + width) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left - 2,
                            y: offset.top + height - titleSize - 2,
                            w: width,
                            h: titleSize,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.BOTTOM,
                            item: this,
                            self: same === wcDocker.TAB.BOTTOM
                        });
                        return true;
                    }
                    // Left bar
                    else if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.LEFT) &&
                        mouse.y >= offset.top && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left && mouse.x <= offset.left + titleSize) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left - 2,
                            y: offset.top - 2,
                            w: titleSize - 2,
                            h: height,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.LEFT,
                            item: this,
                            self: same === wcDocker.TAB.LEFT
                        });
                        return true;
                    }
                    // Right bar
                    else if ((!forceTabOrientation || forceTabOrientation === wcDocker.TAB.RIGHT) &&
                        mouse.y >= offset.top && mouse.y <= offset.top + height &&
                        mouse.x >= offset.left + width - titleSize && mouse.x <= offset.left + width) {

                        // Stacking with bottom orientation.
                        ghost.anchor(mouse, {
                            x: offset.left + width - titleSize - 2,
                            y: offset.top - 2,
                            w: titleSize,
                            h: height,
                            loc: wcDocker.DOCK.STACKED,
                            tab: wcDocker.TAB.RIGHT,
                            item: this,
                            self: same === wcDocker.TAB.RIGHT
                        });
                        return true;
                    }
                }
            }

            // Test for edge anchoring.
            if (allowEdges && ghost._outer && ghost._inner) {
                var outerWidth = ghost._outer.$container.outerWidth();
                var outerHeight = ghost._outer.$container.outerHeight();
                var outerOffset = ghost._outer.$container.offset();

                // Left edge
                if (mouse.y >= outerOffset.top && mouse.y <= outerOffset.top + outerHeight &&
                    mouse.x >= outerOffset.left + titleSize && mouse.x <= outerOffset.left + titleSize + edgeAnchor.x) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth / 3,
                        h: outerHeight,
                        loc: wcDocker.DOCK.LEFT,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Right edge
                else if (mouse.y >= outerOffset.top && mouse.y <= outerOffset.top + outerHeight &&
                    mouse.x >= outerOffset.left + outerWidth - edgeAnchor.x - titleSize && mouse.x <= outerOffset.left + outerWidth - titleSize) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left + outerWidth - (outerWidth / 3) - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth / 3,
                        h: outerHeight,
                        loc: wcDocker.DOCK.RIGHT,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Top edge
                else if (mouse.y >= outerOffset.top + titleSize && mouse.y <= outerOffset.top + titleSize + edgeAnchor.y &&
                    mouse.x >= outerOffset.left && mouse.x <= outerOffset.left + outerWidth) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top - 2,
                        w: outerWidth,
                        h: outerHeight / 3,
                        loc: wcDocker.DOCK.TOP,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
                // Bottom edge
                else if (mouse.y >= outerOffset.top + outerHeight - titleSize - edgeAnchor.y && mouse.y <= outerOffset.top + outerHeight - titleSize &&
                    mouse.x >= outerOffset.left && mouse.x <= outerOffset.left + outerWidth) {
                    ghost.anchor(mouse, {
                        x: outerOffset.left - 2,
                        y: outerOffset.top + outerHeight - (outerHeight / 3) - 2,
                        w: outerWidth,
                        h: outerHeight / 3,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: ghost._inner,
                        self: false
                    });
                    return true;
                }
            }

            if (!canSplit) {
                return false;
            }

            // Check for placeholder.
            if (this._parent && this._parent.instanceOf('wcPanel') && this._parent._isPlaceholder) {
                ghost.anchor(mouse, {
                    x: offset.left - 2,
                    y: offset.top - 2,
                    w: width,
                    h: height,
                    loc: wcDocker.DOCK.TOP,
                    item: this,
                    self: false
                });
                return true;
            }

            if (width < height) {
                // Top docking.
                if (mouse.y >= offset.top && mouse.y <= offset.top + titleSize + panelAnchor.y &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.TOP,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Bottom side docking.
                if (mouse.y >= offset.top + height - panelAnchor.y - titleSize && mouse.y <= offset.top + height &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top + (height - height * 0.5) - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }

            // Left side docking
            if (mouse.y >= offset.top && mouse.y <= offset.top + height) {
                if (mouse.x >= offset.left && mouse.x <= offset.left + panelAnchor.x + titleSize) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width * 0.5,
                        h: height,
                        loc: wcDocker.DOCK.LEFT,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Right side docking
                if (mouse.x >= offset.left + width - panelAnchor.x - titleSize && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left + width * 0.5 - 2,
                        y: offset.top - 2,
                        w: width * 0.5,
                        h: height,
                        loc: wcDocker.DOCK.RIGHT,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }

            if (width >= height) {
                // Top docking.
                if (mouse.y >= offset.top && mouse.y <= offset.top + panelAnchor.y + titleSize &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.TOP,
                        item: this,
                        self: false
                    });
                    return true;
                }

                // Bottom side docking.
                if (mouse.y >= offset.top + height - panelAnchor.y - titleSize && mouse.y <= offset.top + height &&
                    mouse.x >= offset.left && mouse.x <= offset.left + width) {
                    ghost.anchor(mouse, {
                        x: offset.left - 2,
                        y: offset.top + (height - height * 0.5) - 2,
                        w: width,
                        h: height * 0.5,
                        loc: wcDocker.DOCK.BOTTOM,
                        item: this,
                        self: false
                    });
                    return true;
                }
            }
            return false;
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$elem);
            } else {
                this.$elem.remove();
            }
            return this.$container;
        },

        // Destroys the layout.
        __destroy: function () {
            this.__container(null);
            this._parent = null;
            this.clear();

            this.$elem.remove();
            this.$elem = null;
        }
    });

    return Module;
});


/** @module wcLayoutSimple */
define('wcDocker/layoutsimple',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/layout"
], function (dcl, wcDocker, wcLayout) {

    /**
     * @class
     * A simple layout for containing elements in a panel. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} can optionally contain these instead of the default {@link wcLayoutTable}.
     */
    var Module = dcl(wcLayout, {
        declaredClass: 'wcLayoutSimple',

///////////////////////////////////////////////////////////////////////////////////////////////////////
// Public Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, appending it to the main element.
         * @function module:wcLayoutSimple#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         */
        addItem: function (item) {
            this.$elem.append(item);
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayoutSimple#clear
         */
        clear: function () {
            this.$elem.remove();
            this.$elem = null;
            this.__init();
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$elem = $('<div class="wcLayout wcWide wcTall"></div>');
            this.__container(this.$container);
        },

        // Updates the size of the layout.
        __update: function () {
        }
    });

    return Module;
});


/** @module wcLayoutTable */
define('wcDocker/layouttable',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/layout"
], function (dcl, wcDocker, wcLayout) {

    /**
     * @class module:wcLayoutTable
     * A gridded layout for arranging elements. [Panels]{@link wcPanel}, [splitter widgets]{@link wcSplitter}
     * and [tab widgets]{@link wcTabFrame} contain these by default to handle their contents.
     */
    var Module = dcl(wcLayout, {
        declaredClass: 'wcLayoutTable',

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Adds an item into the layout, expanding the grid size if necessary.
         * @function module:wcLayoutTable#addItem
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} item - A DOM element to add.
         * @param {Number} [x=0] - The horizontal grid position to place the element.
         * @param {Number} [y=0] - The vertical grid position to place the element.
         * @param {Number} [w=1] - The number of horizontal cells this item will take within the grid.
         * @param {Number} [h=1] - The number of vertical cells this item will take within the grid.
         * @returns {module:wcLayoutTable~tableItem|Boolean} The table data element of the cell that contains the item, or false if there was a problem.
         */
        addItem: function (item, x, y, w, h) {
            if (typeof x === 'undefined' || x < 0) {
                x = 0;
            }
            if (typeof y === 'undefined' || y < 0) {
                y = 0;
            }
            if (typeof w === 'undefined' || w <= 0) {
                w = 1;
            }
            if (typeof h === 'undefined' || h <= 0) {
                h = 1;
            }

            this.__resizeGrid(x + w - 1, y + h - 1);
            if (w > 1 || h > 1) {
                if (!this.__mergeGrid(x, y, w, h)) {
                    return false;
                }
            }

            this._grid[y][x].$el.append($(item));
            return this.item(x, y);
        },

        /**
         * Retrieves the table item at a given grid position, if it exists.
         * Note, if an item spans multiple cells, only the top-left most
         * cell will actually contain the table item.
         * @function module:wcLayoutTable#item
         * @param {Number} x - The horizontal grid position.
         * @param {Number} y - The vertical grid position.
         * @returns {module:wcLayoutTable~tableItem|Boolean} - The table item, or false if none was found.
         */
        item: function (x, y) {
            if (y >= this._grid.length) {
                return false;
            }

            if (x >= this._grid[y].length) {
                return false;
            }

            // Some cells are a merging of multiple cells. If this cell is
            // part of a merge for another cell, use that cell instead.
            // if (this._grid[y][x].x < 0 || this._grid[y][x].y < 0) {
            //   var grid = this._grid[y][x];
            //   x -= grid.x;
            //   y -= grid.y;
            // }

            var self = this;
            /**
             * The table item is an object that represents one cell in the layout table, it contains
             * convenient methods for cell alteration and supports chaining. Its purpose is
             * to remove the need to alter &lt;tr&gt; and &lt;td&gt; elements of the table directly.
             * @version 3.0.0
             * @example myPanel.addItem(domNode).css('text-align', 'right').css('border', '1px solid black').stretch('100%', '100%');
             * @typedef module:wcLayoutTable#tableItem
             * @property {jQuery~Object} $ - If you truely need the table cell [jQuery object]{@link jQuery~Object}, here it is.
             * @property {module:wcLayoutTable~tableItem_css} css - Wrapper to alter [jQuery's css]{@link http://api.jquery.com/css/} function.
             * @property {module:wcLayoutTable~tableItem_stretch} stretch - More reliable method for setting the table item width/height values.
             */
            var myItem = {
                $: self._grid[y][x].$el,

                /**
                 * <small><i>This function is found in {@link module:wcLayoutTable~tableItem}.</small></i><br>
                 * A wrapper for [jQuery's css]{@link http://api.jquery.com/css/} function.
                 * <b>Note:</b> It is recommended that you use [stretch]{@link wcLayoutTable~stretch} if you intend to alter width or height styles.
                 * @version 3.0.0
                 * @function module:wcLayoutTable#tableItem_css
                 * @param {String} style - The style attribute to alter.
                 * @param {String} [value] - The value of the attribute. If omitted, the current value of the attribute is returned instead of the [tableItem]{@link module:wcLayoutTable~tableItem} instance.
                 * @returns {module:wcLayoutTable~tableItem|String} - Self, for chaining, unless the value parameter was omitted.
                 */
                css: function (style, value) {
                    if (self._grid[y][x].$el) {
                        if (value === undefined) {
                            return self._grid[y][x].$el.css(style);
                        }

                        self._grid[y][x].$el.css(style, value);
                    }
                    return myItem;
                },

                /**
                 * <small><i>This function is found in {@link module:wcLayoutTable~tableItem}.</small></i><br>
                 * Sets the stretch amount for the current table item. This is more reliable than
                 * assigning width and height style attributes directly on the table item.
                 * @version 3.0.0
                 * @function module:wcLayoutTable#tableItem_stretch
                 * @param {Number|String} [sx] - The horizontal stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
                 * @param {Number|String} [sy] - The vertical stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
                 * @returns {module:wcLayoutTable~tableItem} - Self, for chaining.
                 */
                stretch: function (width, height) {
                    self.itemStretch(x, y, width, height);
                    return myItem;
                }
            };
            return myItem;
        },

        /**
         * Sets the stretch amount for a given table item. This is more reliable than
         * assigning width and height style attributes directly on the table item.
         * @version 3.0.0
         * @function module:wcLayoutTable#itemStretch
         * @param {Number} x - The horizontal grid position.
         * @param {Number} y - The vertical grid position.
         * @param {Number|String} [sx] - The horizontal stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @param {Number|String} [sy] - The vertical stretch for this grid. Use empty string to clear current value. Can be a pixel position, or a string with a 'px' or '%' suffix.
         * @returns {Boolean} - Success or failure. A failure generally means your grid position was a merged grid cell.
         */
        itemStretch: function (x, y, sx, sy) {
            var wasBatched = this._batchProcess;

            this._batchProcess = true;
            this.__resizeGrid(x, y);

            var grid = this._grid[y][x];
            if (grid.x < 0 || grid.y < 0) {
                return false;
            }

            if (sx !== undefined) {
                grid.sx = sx;
            }
            if (sy !== undefined) {
                grid.sy = sy;
            }

            this._batchProcess = wasBatched;
            if (!wasBatched) {
                this.__resizeGrid(0, 0);
            }

            return true;
        },

        /**
         * Clears the contents of the layout and squashes all rows and columns from the grid.
         * @function module:wcLayoutTable#clear
         */
        clear: function () {
            var showGrid = this.showGrid();
            var spacing = this.gridSpacing();
            var alternate = this.gridAlternate();

            this.$elem.remove();
            this.__init();

            this.showGrid(showGrid);
            this.gridSpacing(spacing);
            this.gridAlternate(alternate);

            this._grid = [];
        },

        /**
         * Begins a batch operation.  Basically it refrains from constructing
         * the layout grid, which causes a reflow, on each item added.  Instead,
         * The grid is only generated at the end once [wcLayoutTable.finishBatch]{@link wcLayoutTable#finishBatch} is called.
         * @function module:wcLayoutTable#startBatch
         */
        startBatch: function () {
            this._batchProcess = true;
        },

        /**
         * Ends a batch operation.
         * @See module:wcLayoutTable#startBatch
         * @function module:wcLayoutTable#finishBatch
         */
        finishBatch: function () {
            this._batchProcess = false;
            this.__resizeGrid(0, 0);
        },

        /**
         * Gets, or Sets whether the layout grid cells should draw an outline.
         * @function module:wcLayoutTable#showGrid
         * @param {Boolean} [enabled] - If supplied, will set the grid cell border visibility.
         * @returns {Boolean} - The current visibility state of the grid cells.
         */
        showGrid: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this.$elem.toggleClass('wcLayoutGrid', enabled);
            }

            return this.$elem.hasClass('wcLayoutGrid');
        },

        /**
         * Gets, or Sets the spacing between cell borders.
         * @function module:wcLayoutTable#gridSpacing
         * @param {Number} [size] - If supplied, sets the pixel size of the spacing between cells.
         * @returns {Number} - The current cell spacing in pixels.
         */
        gridSpacing: function (size) {
            if (typeof size !== 'undefined') {
                this.$elem.css('border-spacing', size + 'px');
            }

            return parseInt(this.$elem.css('border-spacing'));
        },

        /**
         * Gets, or Sets whether the table rows alternate in color based on the theme.
         * @function module:wcLayoutTable#gridAlternate
         * @params {Boolean} [enabled] - If supplied, will set whether the grid alternates in color.
         * @returns {Boolean} - Whether the grid alternates in color.
         */
        gridAlternate: function (enabled) {
            if (typeof enabled !== 'undefined') {
                this.$elem.toggleClass('wcLayoutGridAlternate', enabled);
            }

            return this.$elem.hasClass('wcLayoutGridAlternate');
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$elem = $('<table class="wcLayout wcWide wcTall"></table>');
            this.$elem.append($('<tbody></tbody>'));
            this._grid = [];
            this.__container(this.$container);
        },

        // Updates the size of the layout.
        __update: function () {
        },

        // Resizes the grid to fit a given position.
        // Params:
        //    width     The width to expand to.
        //    height    The height to expand to.
        __resizeGrid: function (width, height) {
            for (var y = 0; y <= height; ++y) {
                if (this._grid.length <= y) {
                    var row = [];
                    row.$row = $('<tr>');
                    this._grid.push(row);
                }

                for (var x = 0; x <= width; ++x) {
                    if (this._grid[y].length <= x) {
                        this._grid[y].push({
                            $el: $('<td>'),
                            x: 0,
                            y: 0,
                            sx: '',
                            sy: ''
                        });
                    }
                }
            }

            if (!this._batchProcess) {
                var $oldBody = this.$elem.find('tbody');
                $('.wcDockerTransition').append($oldBody);

                var $newBody = $('<tbody>');
                for (var y = 0; y < this._grid.length; ++y) {
                    var $row = null;

                    for (var x = 0; x < this._grid[y].length; ++x) {
                        var item = this._grid[y][x];
                        if (item.$el) {
                            if (!$row) {
                                $row = this._grid[y].$row;
                                $newBody.append($row);
                            }

                            item.$el.css('width', item.sx);
                            item.$el.css('height', item.sy);
                            $row.append(item.$el);
                        }
                    }
                }

                this.$elem.append($newBody);
                $oldBody.remove();
            }
        },

        // Merges cells in the layout.
        // Params:
        //    x, y      Cell position to begin merge.
        //    w, h      The width and height to merge.
        // Returns:
        //    true      Cells were merged succesfully.
        //    false     Merge failed, either because the grid position was out of bounds
        //              or some of the cells were already merged.
        __mergeGrid: function (x, y, w, h) {
            // Make sure each cell to be merged is not already merged somewhere else.
            for (var yy = 0; yy < h; ++yy) {
                for (var xx = 0; xx < w; ++xx) {
                    var item = this._grid[y + yy][x + xx];
                    if (!item.$el || item.x !== 0 || item.y !== 0) {
                        return false;
                    }
                }
            }

            // Now merge the cells here.
            var item = this._grid[y][x];
            if (w > 1) {
                item.$el.attr('colspan', '' + w);
                item.x = w - 1;
            }
            if (h > 1) {
                item.$el.attr('rowspan', '' + h);
                item.y = h - 1;
            }

            for (var yy = 0; yy < h; ++yy) {
                for (var xx = 0; xx < w; ++xx) {
                    if (yy !== 0 || xx !== 0) {
                        var item = this._grid[y + yy][x + xx];
                        item.$el.remove();
                        item.$el = null;
                        item.x = -xx;
                        item.y = -yy;
                    }
                }
            }
            return true;
        }
    });

    return Module;
});

/** @module wcTabFrame */
define('wcDocker/tabframe',[
    "dcl/dcl",
    "wcDocker/types",
    "wcDocker/base"
], function (dcl, wcDocker, base) {

    /**
     * @class
     * A tab widget container, usable inside a panel to break up multiple elements into separate tabbed pages.
     */
    var Module = dcl(base, {
        declaredClass: 'wcTabFrame',

        LEFT_TAB_BUFFER: 15,

        /**
         * @memberOf module:wcTabFrame
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element for this layout.
         * @param {module:wcPanel} parent - The parent panel object for this widget.
         */
        constructor: function(container, parent) {
            /**
             * The outer container element of the widget.
             * @member {external:jQuery~Object}
             */
            this.$container = $(container);
            this._parent = parent;

            this.$frame = null;
            this.$tabBar = null;
            this.$tabScroll = null;
            this.$center = null;
            this.$tabLeft = null;
            this.$tabRight = null;
            this.$close = null;

            this._tabOrientation = wcDocker.TAB.TOP;
            this._canScrollTabs = false;
            this._tabScrollPos = 0;
            this._curTab = -1;
            this._layoutList = [];
            this._moveable = true;

            this._boundEvents = [];

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Manually update the contents of this tab frame.
         * @function module:wcTabFrame#update
         */
        update: function () {
            var scrollTop = this.$center.scrollTop();
            this.__updateTabs();
            this.$center.scrollTop(scrollTop);
        },

        /**
         * Destroys the widget.
         * @function module:wcTabFrame#destroy
         */
        destroy: function () {
            this.__destroy();
        },

        /**
         * Gets the total number of tabs in this frame.
         * @version 3.0.0
         * @function module:wcTabFrame#tabCount
         * @returns {Number}
         */
        tabCount: function () {
            return this._layoutList.length;
        },

        /**
         * Gets, or Sets the tab orientation for the frame. This puts the tabbed widgets visually on any side of the tab frame.
         * @version 3.0.0
         * @function module:wcTabFrame#tabOrientation
         * @param {module:wcDocker.TAB} [orientation] - Assigns the orientation of the tab items displayed.
         * @returns {module:wcDocker.TAB} - The current orientation.
         */
        tabOrientation: function (orientation) {
            if (orientation !== undefined) {
                if (this._tabOrientation !== orientation && this.docker()._canOrientTabs) {
                    this._tabOrientation = orientation;

                    this.__updateTabs();
                    this.__updateTabs();
                }
            }

            return this._tabOrientation
        },

        /**
         * Adds a new tabbed page into the widget.
         * @function module:wcTabFrame#addTab
         * @param {String} name - The name of the new tab page.
         * @param {Number} [index] - If supplied and above -1, will insert the new tab page at the given tab index, otherwise the new tab is appended to the end.
         * @param {module:wcDocker.LAYOUT} [layout] - If supplied, will set the type of layout to use for this tab.
         * @returns {module:wcLayoutSimple|wcLayoutTable} - The layout of the newly created tab page.
         */
        addTab: function (name, index, layout) {
            var layoutClass = layout || 'wcLayoutTable';
            var newLayout = new (this.docker().__getClass(layoutClass))('.wcDockerTransition', this._parent);
            newLayout.name = name;
            newLayout._scrollable = {
                x: true,
                y: true
            };
            newLayout._scroll = {
                x: 0,
                y: 0
            };
            newLayout._closeable = false;
            newLayout._overflowVisible = false;

            if (typeof index === 'undefined' || index <= -1) {
                this._layoutList.push(newLayout);
            } else {
                this._layoutList.splice(index, 0, newLayout);
            }

            if (this._curTab === -1 && this._layoutList.length) {
                this._curTab = 0;
            }

            this.__updateTabs();

            return newLayout;
        },

        /**
         * Removes a tab page from the widget.
         * @function module:wcTabFrame#removeTab
         * @param {Number} index - The tab page index to remove.
         * @returns {Boolean} - Success or failure.
         */
        removeTab: function (index) {
            if (index > -1 && index < this._layoutList.length) {
                var name = this._layoutList[index].name;
                this._layoutList[index].__destroy();
                this._layoutList.splice(index, 1);

                if (this._curTab >= index) {
                    this._curTab--;

                    if (this._curTab < 0) {
                        this._curTab = 0;
                    }
                }

                this.__updateTabs();
                this._parent.__trigger(wcDocker.EVENT.CUSTOM_TAB_CLOSED, {obj: this, name: name, index: index});
                return true;
            }
            return false;
        },

        /**
         * Gets, or Sets the currently visible tab page.
         * @function module:wcTabFrame#tab
         * @param {Number} [index] - If supplied, sets the current tab page index.
         * @param {Boolean} [scrollTo] - If true, will auto scroll the tab bar until the selected tab is visible.
         * @returns {Number} - The index of the currently visible tab page.
         */
        tab: function (index, scrollTo) {
            if (typeof index !== 'undefined') {
                if (index > -1 && index < this._layoutList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    this._curTab = index;
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + index + '"]').addClass('wcPanelTabActive');
                    this.$center.children('.wcPanelTabContent[id="' + index + '"]').removeClass('wcPanelTabContentHidden');
                    this.__updateTabs(scrollTo);

                    var name = this._layoutList[this._curTab].name;
                    this._parent.__trigger(wcDocker.EVENT.CUSTOM_TAB_CHANGED, {obj: this, name: name, index: index});
                }
            }

            return this._curTab;
        },

        /**
         * Retrieves the layout for a given tab page.
         * @function module:wcTabFrame#layout
         * @param {Number} index - The tab page index to retrieve.
         * @returns {module:wcLayoutSimple|wcLayoutTable|Boolean} - The layout of the found tab page, or false.
         */
        layout: function (index) {
            if (index > -1 && index < this._layoutList.length) {
                return this._layoutList[index];
            }
            return false;
        },

        /**
         * Moves a tab page from a given index to another index.
         * @function module:wcTabFrame#moveTab
         * @param {Number} fromIndex - The current tab page index to move from.
         * @param {Number} toIndex - The new tab page index to move to.
         * @returns {external:jQuery~Object} - The new element of the moved tab, or false if an error occurred.
         */
        moveTab: function (fromIndex, toIndex) {
            if (fromIndex >= 0 && fromIndex < this._layoutList.length &&
                toIndex >= 0 && toIndex < this._layoutList.length) {
                var panel = this._layoutList.splice(fromIndex, 1);
                this._layoutList.splice(toIndex, 0, panel[0]);

                // Preserve the currently active tab.
                if (this._curTab === fromIndex) {
                    this._curTab = toIndex;
                }

                this.__updateTabs();

                return this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + toIndex + '"]')[0];
            }
            return false;
        },

        /**
         * Gets, or Sets whether the tabs can be reordered by the user.
         * @function module:wcTabFrame#moveable
         * @param {Boolean} [moveable] - If supplied, assigns whether tab pages can be reordered.
         * @returns {Boolean} - Whether tab pages are currently moveable.
         */
        moveable: function (moveable) {
            if (typeof moveable !== 'undefined') {
                this._moveable = moveable;
            }
            return this._moveable;
        },

        /**
         * Gets, or Sets whether a tab can be closed (removed) by the user.
         * @function module:wcTabFrame#closeable
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [closeable] - If supplied, assigns whether the tab page can be closed.
         * @returns {Boolean} - Whether the tab page can be closed.
         */
        closeable: function (index, closeable) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (typeof closeable !== 'undefined') {
                    layout._closeable = closeable;
                }

                return layout._closeable;
            }
            return false;
        },

        /**
         * Gets, or Sets whether a tab page area is scrollable.
         * @function module:wcTabFrame#scrollable
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [x] - If supplied, assigns whether the tab page is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the tab page is scrollable in the vertical direction.
         * @returns {module:wcDocker~Scrollable} - The current scrollable status of the tab page.
         */
        scrollable: function (index, x, y) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                var changed = false;
                if (typeof x !== 'undefined') {
                    layout._scrollable.x = x;
                    changed = true;
                }
                if (typeof y !== 'undefined') {
                    layout._scrollable.y = y;
                    changed = true;
                }

                if (changed) {
                    this.__onTabChange();
                }

                return {
                    x: layout._scrollable.x,
                    y: layout._scrollable.y
                };
            }
            return false;
        },

        /**
         * Gets, or Sets whether overflow on a tab area is visible.<br>
         * Use this if a child element within this panel is intended to 'popup' and be visible outside of its parent area.
         * @function module:wcTabFrame#overflowVisible
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [visible] - If supplied, assigns whether overflow is visible.
         * @returns {Boolean} - The current overflow visiblity status of the tab page.
         */
        overflowVisible: function (index, visible) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (typeof overflow !== 'undefined') {
                    layout._overflowVisible = overflow;
                    this.__onTabChange();
                }
                return layout._overflowVisible;
            }
            return false;
        },

        /**
         * Gets, or Sets whether the tab frame should fit to its contents.
         * @version 3.0.0
         * @function module:wcTabFrame#fitContents
         * @param {Number} index - The index of the tab page.
         * @param {Boolean} [x] - If supplied, assigns whether the tab page is scrollable in the horizontal direction.
         * @param {Boolean} [y] - If supplied, assigns whether the tab page is scrollable in the vertical direction.
         * @returns {module:wcDocker~FitContents} - The current scrollable status of the tab page.
         */
        fitContents: function (index, x, y) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.hasOwnProperty('_fitContents')) {
                    layout._fitContents = {
                        x: false,
                        y: false
                    };
                }

                var changed = false;
                if (typeof x !== 'undefined') {
                    layout._fitContents.x = x;
                    changed = true;
                }
                if (typeof y !== 'undefined') {
                    layout._fitContents.y = y;
                    changed = true;
                }

                if (changed) {
                    this.__onTabChange();
                }

                return {
                    x: layout._fitContents.x,
                    y: layout._fitContents.y
                };
            }
            return false;
        },

        /**
         * Sets the icon for a tab item.
         * @function module:wcTabFrame#icon
         * @param {Number} index - The index of the tab item.
         * @param {String} icon - A CSS class name that represents the icon.
         */
        icon: function (index, icon) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.$icon) {
                    layout.$icon = $('<div>');
                }

                layout.$icon.removeClass();
                layout.$icon.addClass('wcTabIcon ' + icon);
            }
        },

        /**
         * Sets the icon for a tab item using the [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} library.
         * @function module:wcTabFrame#faicon
         * @param {Number} index - The index of the tab item.
         * @param {String} icon - A [Font-Awesome]{@link http://fortawesome.github.io/Font-Awesome/} icon name (without the 'fa fa-' prefix).
         */
        faicon: function (index, icon) {
            if (index > -1 && index < this._layoutList.length) {
                var layout = this._layoutList[index];

                if (!layout.$icon) {
                    layout.$icon = $('<div>');
                }

                layout.$icon.removeClass();
                layout.$icon.addClass('fa fa-fw fa-' + icon);
            }
        },


///////////////////////////////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////////////////////////////

        // Initialize
        __init: function () {
            this.$frame = $('<div class="wcCustomTab wcWide wcTall">');
            this.$tabBar = $('<div class="wcFrameTitleBar wcCustomTabTitle wcWide">');
            this.$tabScroll = $('<div class="wcTabScroller">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><span class="fa fa-close"></span>X</div>');

            //this.$maximize = $('<div class="wcFrameButton" title="Close the currently active panel tab"><span class="fa fa-expand"></span>X</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');


            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);

            //this.$buttonBar.append(this.$maximize);

            this.$frame.append(this.$center);
            this.$frame.append(this.$tabBar);

            this.__container(this.$container);

            this._boundEvents.push({event: wcDocker.EVENT.UPDATED, handler: this.update.bind(this)});
            this._boundEvents.push({event: wcDocker.EVENT.CLOSED, handler: this.destroy.bind(this)});

            for (var i = 0; i < this._boundEvents.length; ++i) {
                this._parent.on(this._boundEvents[i].event, this._boundEvents[i].handler);
            }

            var docker = this.docker();
            if (docker) {
                docker._tabList.push(this);
            }
        },

        __updateTabs: function (scrollTo) {

            //this.$tabScroll.empty();

            var getOffset = function ($item) {
                switch (this._tabOrientation) {
                    case wcDocker.TAB.BOTTOM:
                        return $item.offset().left;
                    case wcDocker.TAB.TOP:
                        return $item.offset().left;
                    case wcDocker.TAB.LEFT:
                        return $item.offset().top;
                    case wcDocker.TAB.RIGHT:
                        return $item.offset().top;
                }
            }.bind(this);

            var tabPositions = [];
            var totalWidth = 0;
            var parentLeft = getOffset(this.$tabScroll);
            var self = this;

            this.$center.children('.wcPanelTabContent').each(function () {
                $(this).addClass('wcPanelTabContentHidden wcPanelTabUnused');
            });

            for (var i = 0; i < this._layoutList.length; ++i) {
                var $tab = $('<div id="' + i + '" class="wcPanelTab"><div>' + this._layoutList[i].name + '</div></div>');
                if (this._moveable) {
                    $tab.addClass('wcCustomTabMoveable');
                }
                this.$tabScroll.append($tab);
                if (this._layoutList[i].$icon) {
                    $tab.find('div').prepend(this._layoutList[i].$icon);
                }

                var $tabContent = this.$center.children('.wcPanelTabContent[id="' + i + '"]');
                if (!$tabContent.length) {
                    $tabContent = $('<div class="wcPanelTabContent wcPanelTabContentHidden" id="' + i + '">');
                    this.$center.append($tabContent);
                }

                this._layoutList[i].__container($tabContent);
                this._layoutList[i]._parent = this;

                var isVisible = this._curTab === i;

                $tabContent.removeClass('wcPanelTabUnused');

                if (isVisible) {
                    $tab.addClass('wcPanelTabActive');
                    $tabContent.removeClass('wcPanelTabContentHidden');
                }

                totalWidth = getOffset($tab) - parentLeft;
                tabPositions.push(totalWidth);

                totalWidth += $tab.outerWidth();
            }

            var tabWidth = 0;
            var titleSize = this.$tabBar.height();
            switch (this._tabOrientation) {
                case wcDocker.TAB.TOP:
                    this.$tabBar.addClass('wcTabTop').removeClass('wcTabLeft wcTabRight wcTabBottom');
                    this.$center.css('top', titleSize).css('left', 0).css('right', 0).css('bottom', 0);
                    tabWidth = this.$center.width();
                    break;
                case wcDocker.TAB.BOTTOM:
                    this.$tabBar.addClass('wcTabBottom').removeClass('wcTabTop wcTabLeft wcTabRight');
                    this.$center.css('top', 0).css('left', 0).css('right', 0).css('bottom', titleSize);
                    tabWidth = this.$center.width();
                    break;

                case wcDocker.TAB.LEFT:
                    this.$tabBar.addClass('wcTabLeft').removeClass('wcTabTop wcTabRight wcTabBottom');
                    this.$center.css('top', 0).css('left', titleSize).css('right', 0).css('bottom', 0);
                    tabWidth = this.$center.height();
                    break;

                case wcDocker.TAB.RIGHT:
                    this.$tabBar.addClass('wcTabRight').removeClass('wcTabTop wcTabLeft wcTabBottom');
                    this.$center.css('top', 0).css('left', 0).css('right', titleSize).css('bottom', 0);
                    tabWidth = this.$center.height();
                    break;
            }

            // Now remove all unused panel tabs.
            this.$center.children('.wcPanelTabUnused').each(function () {
                $(this).remove();
            });

            var buttonSize = this.__onTabChange();

            if (scrollTo) {
                for (var i = 0; i < tabPositions.length; ++i) {
                    if (i === this._curTab) {
                        var left = tabPositions[i];
                        var right = totalWidth;
                        if (i + 1 < tabPositions.length) {
                            right = tabPositions[i + 1];
                        }

                        var scrollPos = -parseInt(this.$tabScroll.css('left'));
                        var titleWidth = tabWidth - buttonSize;

                        // If the tab is behind the current scroll position.
                        if (left < scrollPos) {
                            this._tabScrollPos = left - this.LEFT_TAB_BUFFER;
                            if (this._tabScrollPos < 0) {
                                this._tabScrollPos = 0;
                            }
                        }
                        // If the tab is beyond the current scroll position.
                        else if (right - scrollPos > titleWidth) {
                            this._tabScrollPos = right - titleWidth + this.LEFT_TAB_BUFFER;
                        }
                        break;
                    }
                }
            }

            this._canScrollTabs = false;
            if (totalWidth > tabWidth - buttonSize) {
                this._canScrollTabs = true;
                this.$buttonBar.append(this.$tabRight);
                this.$buttonBar.append(this.$tabLeft);
                buttonSize += this.$tabRight.outerWidth();
                buttonSize += this.$tabLeft.outerWidth();

                var scrollLimit = totalWidth - (tabWidth - buttonSize) / 2;
                // If we are beyond our scroll limit, clamp it.
                if (this._tabScrollPos > scrollLimit) {
                    var children = this.$tabScroll.children();
                    for (var i = 0; i < children.length; ++i) {
                        var $tab = $(children[i]);

                        totalWidth = getOffset($tab) - parentLeft;
                        if (totalWidth + $tab.outerWidth() > scrollLimit) {
                            this._tabScrollPos = totalWidth - this.LEFT_TAB_BUFFER;
                            if (this._tabScrollPos < 0) {
                                this._tabScrollPos = 0;
                            }
                            break;
                        }
                    }
                }
            } else {
                this._tabScrollPos = 0;
                this.$tabLeft.remove();
                this.$tabRight.remove();
            }

            this.$tabScroll.stop().animate({left: -this._tabScrollPos + 'px'}, 'fast');
        },

        __onTabChange: function () {
            var buttonSize = 0;
            var layout = this.layout(this._curTab);
            if (layout) {
                this.$center.toggleClass('wcScrollableX', layout._scrollable.x);
                this.$center.toggleClass('wcScrollableY', layout._scrollable.y);
                this.$center.toggleClass('wcOverflowVisible', layout._overflowVisible);

                this.$tabLeft.remove();
                this.$tabRight.remove();

                if (layout._closeable) {
                    this.$close.show();
                    buttonSize += this.$close.outerWidth();
                } else {
                    this.$close.hide();
                }

                if (this._canScrollTabs) {
                    this.$tabBar.append(this.$tabRight);
                    this.$tabBar.append(this.$tabLeft);

                    buttonSize += this.$tabRight.outerWidth() + this.$tabLeft.outerWidth();
                }

                var fit = this.fitContents(this._curTab);
                if (fit.x) {
                    var w = layout.scene().outerWidth();
                    if (this._tabOrientation === wcDocker.TAB.LEFT || this._tabOrientation === wcDocker.TAB.RIGHT) {
                        w += this.$tabScroll.height();
                    }
                    this.$container.css('width', w);
                } else {
                    this.$container.css('width', '');
                }

                if (fit.y) {
                    var h = layout.scene().outerHeight();
                    if (this._tabOrientation === wcDocker.TAB.TOP || this._tabOrientation === wcDocker.TAB.BOTTOM) {
                        h += this.$tabScroll.height();
                    }
                    this.$container.css('height', h);
                } else {
                    this.$container.css('height', '');
                }

                switch (this._tabOrientation) {
                    case wcDocker.TAB.RIGHT:
                    case wcDocker.TAB.LEFT:
                        this.$tabBar.css('width', this.$center.height() || '100%');
                        break;
                    case wcDocker.TAB.TOP:
                    case wcDocker.TAB.BOTTOM:
                        this.$tabBar.css('width', this.$center.width() || '100%');
                    default:
                        break;
                }

                this.$center.scrollLeft(layout._scroll.x);
                this.$center.scrollTop(layout._scroll.y);
            }

            this.$buttonBar.css('min-width', buttonSize).css('width', buttonSize);
            return buttonSize;
        },

        // Handles scroll notifications.
        __scrolled: function () {
            var layout = this.layout(this._curTab);
            layout._scroll.x = this.$center.scrollLeft();
            layout._scroll.y = this.$center.scrollTop();
        },

        // Gets, or Sets a new container for this layout.
        // Params:
        //    $container          If supplied, sets a new container for this layout.
        //    parent              If supplied, sets a new parent for this layout.
        // Returns:
        //    JQuery collection   The current container.
        __container: function ($container) {
            if (typeof $container === 'undefined') {
                return this.$container;
            }

            this.$container = $container;
            if (this.$container) {
                this.$container.append(this.$frame);
            } else {
                this.$frame.remove();
            }
            return this.$container;
        },

        // Disconnects and prepares this widget for destruction.
        __destroy: function () {
            var docker = this.docker();
            if (docker) {
                var index = docker._tabList.indexOf(this);
                if (index > -1) {
                    docker._tabList.splice(index, 1);
                }
            }

            // Remove all registered events.
            while (this._boundEvents.length) {
                this._parent.off(this._boundEvents[0].event, this._boundEvents[0].handler);
                this._boundEvents.shift();
            }

            this._curTab = -1;
            for (var i = 0; i < this._layoutList.length; ++i) {
                this._layoutList[i].__destroy();
            }

            while (this._layoutList.length) this._layoutList.pop();
            this.__container(null);
            this._parent = null;
        }
    });

    // window['wcTabFrame'] = Module;

    return Module;
});

define('wcDocker/docker',[
    "dcl/dcl",
    "wcDocker/types",
    'wcDocker/panel',
    'wcDocker/ghost',
    'wcDocker/splitter',
    'wcDocker/frame',
    'wcDocker/collapser',
    'wcDocker/layoutsimple',
    'wcDocker/layouttable',
    'wcDocker/tabframe',
    'wcDocker/drawer',
    'wcDocker/base'
], function (dcl, wcDocker, wcPanel, wcGhost, wcSplitter, wcFrame, wcCollapser, wcLayoutSimple, wcLayoutTable, wcTabFrame, wcDrawer, base) {

    /**
     * Default class name to module mapping, being used for default options
     */
    var defaultClasses = {
        'wcPanel': wcPanel,
        'wcGhost': wcGhost,
        'wcSplitter': wcSplitter,
        'wcFrame': wcFrame,
        'wcCollapser': wcCollapser,
        'wcLayoutSimple': wcLayoutSimple,
        'wcLayoutTable': wcLayoutTable,
        'wcDrawer': wcDrawer,
        'wcTabFrame': wcTabFrame
    };

    /**
     * @class
     *
     * The main docker instance.  This manages all of the docking panels and user input.
     * There should only be one instance of this, although it is not enforced.<br>
     * See {@tutorial getting-started}
     */
    var Module = dcl(base, {
        declaredClass: 'wcDocker',
        /**
         *
         * @memberOf module:wcDocker
         * @param {external:jQuery~selector|external:jQuery~Object|external:domNode} container - A container element to store the contents of wcDocker.
         * @param {module:wcDocker~Options} [options] - Options for constructing the instance.
         */
        constructor: function (container, options) {

            this.$outer = $(container);
            this.$container = $('<div class="wcDocker">');
            this.$transition = $('<div class="wcDockerTransition">');
            this.$loading = null;

            this.$outer.append(this.$container);
            this.$container.append(this.$transition);

            this._canOrientTabs = true;

            this._events = {};

            this._root = null;
            this._frameList = [];
            this._floatingList = [];
            this._modalList = [];
            this._persistentList = [];
            this._focusFrame = null;
            this._placeholderPanel = null;
            this._contextTimer = 0;
            this._dirty = false;
            this._dirtyDontMove = false;

            this._splitterList = [];
            this._tabList = [];
            this._collapser = {};

            this._dockPanelTypeList = [];

            this._creatingPanel = false;
            this._draggingSplitter = null;
            this._draggingFrame = null;
            this._draggingFrameSizer = null;
            this._draggingFrameTab = null;
            this._draggingFrameTopper = false;
            this._draggingCustomTabFrame = null;
            this._ghost = null;
            this._menuTimer = 0;
            this._mouseOrigin = {x: 0, y: 0};

            this._resizeData = {
                time: -1,
                timeout: false,
                delta: 150
            };

            var defaultOptions = {
                themePath: 'Themes',
                theme: 'default',
                loadingClass: 'fa fa-spinner fa-pulse',
                allowContextMenu: true,
                hideOnResize: false,
                allowCollapse: true,
                responseRate: 10,
                moveStartDelay: 300,
                edgeAnchorSize: 50,
                panelAnchorSize: '15%',
                detachToWidth: '50%',
                detachToHeight: '50%'
            };

            this._options = {};

            //replay default classes into default options
            for (var prop in defaultClasses) {
                defaultOptions[prop + 'Class'] = defaultClasses[prop];
            }

            for (var prop in defaultOptions) {
                this._options[prop] = defaultOptions[prop];
            }

            for (var prop in options) {
                this._options[prop] = options[prop];
            }

            this.__init();
        },

        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Public Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Retrieves whether panel collapsers are enabled.
         * @function module:wcDocker#isCollapseEnabled
         * @version 3.0.0
         * @returns {Boolean} - Collapsers are enabled.
         */
        isCollapseEnabled: function () {
            return (this._canOrientTabs && this._options.allowCollapse);
        },

        /**
         * Registers a new docking panel type to be used later.
         * @function module:wcDocker#registerPanelType
         * @version 3.0.0
         * @param {String} name - The name identifier for the new panel type.
         * @param {module:wcDocker~registerOptions} options  An options object for describing the panel type.
         * @param {Boolean} [isPrivate] - <b>DEPRECATED:</b> Use [options.isPrivate]{@link wcDocker~registerOptions} instead.
         * @returns {Boolean} - Success or failure. Failure usually indicates the type name already exists.
         */
        registerPanelType: function (name, optionsOrCreateFunc, isPrivate) {
            var options = optionsOrCreateFunc;
            if (typeof options === 'function') {
                options = {
                    onCreate: optionsOrCreateFunc
                };
                console.log("WARNING: Passing in the creation function directly to wcDocker.registerPanelType parameter 2 is now deprecated and will be removed in the next version!  Please use the preferred options object instead.");
            }

            if (typeof isPrivate != 'undefined') {
                options.isPrivate = isPrivate;
                console.log("WARNING: Passing in the isPrivate flag to wcDocker.registerPanelType parameter 3 is now deprecated and will be removed in the next version!  Please use the preferred options object instead.");
            }

            if (_.isEmpty(options)) {
                options = null;
            }

            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name === name) {
                    return false;
                }
            }
            this._dockPanelTypeList.push({
                name: name,
                options: options
            });
            return true;
        },

        /**
         * Retrieves a list of all currently registered panel types.
         * @function module:wcDocker#panelTypes
         * @param {Boolean} includePrivate - If true, panels registered as private will also be included with this list.
         * @returns {String[]} - A list of panel type names.
         */
        panelTypes: function (includePrivate) {
            var result = [];
            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (includePrivate || !this._dockPanelTypeList[i].options.isPrivate) {
                    result.push(this._dockPanelTypeList[i].name);
                }
            }
            return result;
        },

        /**
         * Retrieves the options data associated with a given panel type when it was registered.
         * @function module:wcDocker#panelTypeInfo
         * @param {String} typeName - The name identifier of the panel.
         * @returns {module:wcDocker~registerOptions} - Registered options of the panel type, or false if the panel was not found.
         */
        panelTypeInfo: function (typeName) {
            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name == typeName) {
                    return this._dockPanelTypeList[i].options;
                }
            }
            return false;
        },

        /**
         * Add a new docked panel to the docker instance.<br>
         * <b>Note:</b> It is best to use {@link wcDocker.COLLAPSED} after you have added your other docked panels, as it may ensure proper placement.
         * @function module:wcDocker#addPanel
         * @param {String} typeName - The name identifier of the panel to create.
         * @param {module:wcDocker.DOCK} location - The docking location to place this panel.
         * @param {module:wcPanel|module:wcDocker.COLLAPSED} [targetPanel] - A target panel to dock relative to, or use {@link wcDocker.COLLAPSED} to collapse it to the side or bottom.
         * @param {module:wcDocker~PanelOptions} [options] - Other options for panel placement.
         * @returns {module:wcPanel|Boolean} - The newly created panel object, or false if no panel was created.
         */
        addPanel: function (typeName, location, targetPanel, options) {
            function __addPanel(panel) {
                if (location === wcDocker.DOCK.STACKED) {
                    this.__addPanelGrouped(panel, targetPanel, options);
                } else {
                    this.__addPanelAlone(panel, location, targetPanel, options);
                }

                if (this._placeholderPanel && panel.moveable() &&
                    location !== wcDocker.DOCK.FLOAT &&
                    location !== wcDocker.DOCK.MODAL) {
                    if (this.removePanel(this._placeholderPanel)) {
                        this._placeholderPanel = null;
                    }
                }
                this.__forceUpdate();
            }

            // Find out if we have a persistent version of this panel type first.
            for (var a = 0; a < this._persistentList.length; ++a) {
                if (this._persistentList[a]._type === typeName) {
                    var panel = this._persistentList.splice(a, 1)[0];
                    __addPanel.call(this, panel);
                    panel.__trigger(wcDocker.EVENT.PERSISTENT_OPENED);
                    return panel;
                }
            }


            for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                if (this._dockPanelTypeList[i].name === typeName) {
                    var panelType = this._dockPanelTypeList[i];

                    var panel = new (this.__getClass('wcPanel'))(this, typeName, panelType.options);
                    panel.__container(this.$transition);
                    var panelOptions = (panelType.options && panelType.options.options) || options || {};
                    panel._panelObject = new panelType.options.onCreate(panel, panelOptions);

                    __addPanel.call(this, panel);
                    return panel;
                }
            }
            return false;
        },

        /**
         * Removes a docked panel from the window.
         * @function module:wcDocker#removePanel
         * @param {module:wcPanel} panel - The panel to remove.
         * @param {Boolean} dontDestroy - If true, the panel itself will not be destroyed.
         * @returns {Boolean} - Success or failure.
         */
        removePanel: function (panel, dontDestroy) {
            if (!panel) {
                return false;
            }

            // Do not remove if this is the last moveable panel.
            var lastPanel = this.__isLastPanel(panel);

            var parentFrame = panel._parent;
            if (parentFrame && parentFrame.instanceOf('wcFrame')) {
                // Trigger the closing event, if any explicitely returned false, we cancel the close event.
                var results = panel.__trigger(wcDocker.EVENT.CLOSING);
                for (var i = 0; i < results.length; ++i) {
                    if (!results[i]) {
                        return false;
                    }
                }

                if (dontDestroy) {
                    // Keep the panel in a hidden transition container so as to not
                    // destroy any event handlers that may be on it.
                    panel.__container(this.$transition);
                    panel._parent = null;
                } else {
                    panel.__trigger(wcDocker.EVENT.CLOSED);
                }

                // If no more panels remain in this frame, remove the frame.
                if (!parentFrame.removePanel(panel) && !parentFrame.isCollapser()) {
                    // If this is the last frame, create a dummy panel to take up
                    // the space until another one is created.
                    if (lastPanel) {
                        this.__addPlaceholder(parentFrame);

                        if (!dontDestroy) {
                            panel.__destroy();
                        } else {
                            panel.__trigger(wcDocker.EVENT.PERSISTENT_CLOSED);
                        }
                        return true;
                    }

                    var index = this._floatingList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._floatingList.splice(index, 1);
                    }
                    index = this._frameList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._frameList.splice(index, 1);
                    }
                    index = this._modalList.indexOf(parentFrame);
                    if (index !== -1) {
                        this._modalList.splice(index, 1);
                    }

                    if (this._modalList.length) {
                        this.__focus(this._modalList[this._modalList.length - 1]);
                    } else if (this._floatingList.length) {
                        this.__focus(this._floatingList[this._floatingList.length - 1]);
                    }

                    var parentSplitter = parentFrame._parent;
                    if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                        parentSplitter.__removeChild(parentFrame);

                        var other;
                        if (parentSplitter.pane(0)) {
                            other = parentSplitter.pane(0);
                            parentSplitter._pane[0] = null;
                        } else {
                            other = parentSplitter.pane(1);
                            parentSplitter._pane[1] = null;
                        }

                        // Keep the panel in a hidden transition container so as to not
                        // destroy any event handlers that may be on it.
                        other.__container(this.$transition);
                        other._parent = null;

                        index = this._splitterList.indexOf(parentSplitter);
                        if (index !== -1) {
                            this._splitterList.splice(index, 1);
                        }

                        var parent = parentSplitter._parent;
                        var parentContainer = parentSplitter.__container();
                        parentSplitter.__destroy();

                        if (parent && parent.instanceOf('wcSplitter')) {
                            parent.__removeChild(parentSplitter);
                            if (!parent.pane(0)) {
                                parent.pane(0, other);
                            } else {
                                parent.pane(1, other);
                            }
                        } else if (parent === this) {
                            this._root = other;
                            other._parent = this;
                            other.__container(parentContainer);
                        }
                        this.__update();
                    } else if (parentFrame === this._root) {
                        this._root = null;
                    }

                    if (this._focusFrame === parentFrame) {
                        this._focusFrame = null;
                    }

                    parentFrame.__destroy();
                }

                if (!dontDestroy) {
                    panel.__destroy();
                } else {
                    panel.__trigger(wcDocker.EVENT.PERSISTENT_CLOSED);
                }
                return true;
            }
            return false;
        },

        /**
         * Moves a docking panel from its current location to another.
         * @function module:wcDocker#movePanel
         * @param {module:wcPanel} panel - The panel to move.
         * @param {module:wcDocker.DOCK} location - The new docking location of the panel.
         * @param {module:wcPanel|wcDocker.COLLAPSED} [targetPanel] - A target panel to dock relative to, or use {@link wcDocker.COLLAPSED} to collapse it to the side or bottom.
         * @param {module:wcDocker~PanelOptions} [options] - Other options for panel placement.
         * @returns {module:wcPanel|Boolean} - The panel that was created, or false on failure.
         */
        movePanel: function (panel, location, targetPanel, options) {
            var lastPanel = this.__isLastPanel(panel);

            var $elem = panel.$container;
            if (panel._parent && panel._parent.instanceOf('wcFrame')) {
                $elem = panel._parent.$frame;
            }
            var offset = $elem.offset();
            var width = $elem.width();
            var height = $elem.height();

            var parentFrame = panel._parent;
            var floating = false;
            if (parentFrame && parentFrame.instanceOf('wcFrame')) {
                floating = parentFrame._isFloating;
                // Remove the panel from the frame.
                for (var i = 0; i < parentFrame._panelList.length; ++i) {
                    if (parentFrame._panelList[i] === panel) {
                        if (parentFrame.isCollapser()) {
                            parentFrame._curTab = -1;
                        } else if (parentFrame._curTab >= i) {
                            parentFrame._curTab--;
                        }

                        // Keep the panel in a hidden transition container so as to not
                        // destroy any event handlers that may be on it.
                        panel.__container(this.$transition);
                        panel._parent = null;

                        parentFrame._panelList.splice(i, 1);
                        break;
                    }
                }

                if (!parentFrame.isCollapser() && parentFrame._curTab === -1 && parentFrame._panelList.length) {
                    parentFrame._curTab = 0;
                }

                parentFrame.__updateTabs();
                parentFrame.collapse();

                // If no more panels remain in this frame, remove the frame.
                if (!parentFrame.isCollapser() && parentFrame._panelList.length === 0) {
                    // If this is the last frame, create a dummy panel to take up
                    // the space until another one is created.
                    if (lastPanel) {
                        this.__addPlaceholder(parentFrame);
                    } else {
                        var index = this._floatingList.indexOf(parentFrame);
                        if (index !== -1) {
                            this._floatingList.splice(index, 1);
                        }
                        index = this._frameList.indexOf(parentFrame);
                        if (index !== -1) {
                            this._frameList.splice(index, 1);
                        }

                        var parentSplitter = parentFrame._parent;
                        if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                            parentSplitter.__removeChild(parentFrame);

                            var other;
                            if (parentSplitter.pane(0)) {
                                other = parentSplitter.pane(0);
                                parentSplitter._pane[0] = null;
                            } else {
                                other = parentSplitter.pane(1);
                                parentSplitter._pane[1] = null;
                            }

                            if (targetPanel === parentSplitter) {
                                targetPanel._shift = other;
                            }

                            // Keep the item in a hidden transition container so as to not
                            // destroy any event handlers that may be on it.
                            other.__container(this.$transition);
                            other._parent = null;

                            index = this._splitterList.indexOf(parentSplitter);
                            if (index !== -1) {
                                this._splitterList.splice(index, 1);
                            }

                            var parent = parentSplitter._parent;
                            var parentContainer = parentSplitter.__container();
                            parentSplitter.__destroy();

                            if (parent && parent.instanceOf('wcSplitter')) {
                                parent.__removeChild(parentSplitter);
                                if (!parent.pane(0)) {
                                    parent.pane(0, other);
                                } else {
                                    parent.pane(1, other);
                                }
                            } else if (parent === this) {
                                this._root = other;
                                other._parent = this;
                                other.__container(parentContainer);
                            }
                            this.__update();
                        }

                        if (this._focusFrame === parentFrame) {
                            this._focusFrame = null;
                        }

                        parentFrame.__destroy();
                    }
                }
            }

            panel.initSize(width, height);
            if (location === wcDocker.DOCK.STACKED) {
                this.__addPanelGrouped(panel, targetPanel, options);
            } else {
                this.__addPanelAlone(panel, location, targetPanel, options);
            }

            if (targetPanel == this._placeholderPanel) {
                this.removePanel(this._placeholderPanel);
                this._placeholderPanel = null;
            }

            var frame = panel._parent;
            if (frame && frame.instanceOf('wcFrame')) {
                if (frame._panelList.length === 1) {
                    frame.pos(offset.left + width / 2 + 20, offset.top + height / 2 + 20, true);
                }
            }

            this.__update(true);

            if (frame && frame.instanceOf('wcFrame')) {
                if (floating !== frame._isFloating) {
                    if (frame._isFloating) {
                        panel.__trigger(wcDocker.EVENT.DETACHED);
                    } else {
                        panel.__trigger(wcDocker.EVENT.ATTACHED);
                    }
                }
            }

            panel.__trigger(wcDocker.EVENT.MOVED);
            return panel;
        },

        /**
         * Finds all instances of a given panel type.
         * @function module:wcDocker#findPanels
         * @param {String} [typeName] - The name identifier for the panel. If not supplied, all panels are retrieved.
         * @returns {module:wcPanel[]} - A list of all panels found of the given type.
         */
        findPanels: function (typeName) {
            var result = [];
            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    if (!typeName || panel._type === typeName) {
                        result.push(panel);
                    }
                }
            }
            return result;
        },

        /**
         * Shows the loading screen.
         * @function module:wcDocker#startLoading
         * @param {String} [label] - An optional label to display.
         * @param {Number} [opacity=0.4] - If supplied, assigns a custom opacity value to the loading screen.
         * @param {Number} [textOpacity=1] - If supplied, assigns a custom opacity value to the loading icon and text displayed.
         */
        startLoading: function (label, opacity, textOpacity) {
            if (!this.$loading) {
                this.$loading = $('<div class="wcLoadingContainer"></div>');
                this.$outer.append(this.$loading);
                var $background = $('<div class="wcLoadingBackground"></div>');
                if (typeof opacity !== 'number') {
                    opacity = 0.4;
                }

                $background.css('opacity', opacity);
                this.$loading.append($background);

                var $icon = $('<div class="wcLoadingIconContainer"><i class="wcLoadingIcon ' + this._options.loadingClass + '"></i></div>');
                this.$loading.append($icon);

                if (label) {
                    var $label = $('<span class="wcLoadingLabel">' + label + '</span>');
                    this.$loading.append($label);
                }

                if (typeof textOpacity !== 'number') {
                    textOpacity = 1;
                }

                $icon.css('opacity', textOpacity);
                if ($label) {
                    $label.css('opacity', textOpacity);
                }
            }
        },
        /**
         * Hides the loading screen.
         * @function module:wcDocker#finishLoading
         * @param {Number} [fadeDuration=0] - The fade out duration for the loading screen.
         */
        finishLoading: function (fadeDuration) {
            if (this.$loading) {
                if (fadeDuration > 0) {
                    var self = this;
                    this.$loading.fadeOut(fadeDuration, function () {
                        self.$loading.remove();
                        self.$loading = null;
                    });
                } else {
                    this.$loading.remove();
                    this.$loading = null;
                }
            }
        },
        /**
         * Registers a global [event]{@link wcDocker.EVENT}.
         * @function module:wcDocker#on
         * @param {module:wcDocker.EVENT} eventType        - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} handler  - A handler function to be called for the event.
         * @returns {Boolean} Success or failure that the event has been registered.
         */
        on: function (eventType, handler) {
            if (!eventType) {
                return false;
            }

            if (!this._events[eventType]) {
                this._events[eventType] = [];
            }

            if (this._events[eventType].indexOf(handler) !== -1) {
                return false;
            }

            this._events[eventType].push(handler);
            return true;
        },

        /**
         * Unregisters a global [event]{@link wcDocker.EVENT}.
         * @function module:wcDocker#off
         * @param {module:wcDocker.EVENT} eventType          - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {module:wcDocker~event:onEvent} [handler]  - The handler function registered with the event. If omitted, all events registered to the event type are unregistered.
         */
        off: function (eventType, handler) {
            if (typeof eventType === 'undefined') {
                this._events = {};
            } else {
                if (this._events[eventType]) {
                    if (typeof handler === 'undefined') {
                        this._events[eventType] = [];
                    } else {
                        for (var i = 0; i < this._events[eventType].length; ++i) {
                            if (this._events[eventType][i] === handler) {
                                this._events[eventType].splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },

        /**
         * Trigger an [event]{@link wcDocker.EVENT} on all panels.
         * @function module:wcDocker#trigger
         * @fires wcDocker~event:onEvent
         * @param {module:wcDocker.EVENT} eventType - The event type, can be a custom event string or a [predefined event]{@link wcDocker.EVENT}.
         * @param {Object} [data] - A custom data object to be passed along with the event.
         * @returns {Object[]} results - Returns an array with all results returned by event handlers.
         */
        trigger: function (eventName, data) {
            if (!eventName) {
                return false;
            }

            var results = [];

            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    results = results.concat(panel.__trigger(eventName, data));
                }
            }

            return results.concat(this.__trigger(eventName, data));
        },
        /**
         * Saves the current panel configuration into a serialized
         * string that can be used later to restore it.
         * @function module:wcDocker#save
         * @returns {String} - A serialized string that describes the current panel configuration.
         */
        save: function () {
            var data = {};

            data.floating = [];
            for (var i = 0; i < this._floatingList.length; ++i) {
                data.floating.push(this._floatingList[i].__save());
            }

            data.root = this._root.__save();

            if (!_.isEmpty(this._collapser)) {
                data.collapsers = {
                    left: this._collapser[wcDocker.DOCK.LEFT].__save(),
                    right: this._collapser[wcDocker.DOCK.RIGHT].__save(),
                    bottom: this._collapser[wcDocker.DOCK.BOTTOM].__save()
                };
            }

            return JSON.stringify(data, function (key, value) {
                if (value == Infinity) {
                    return "Infinity";
                }
                return value;
            });
        },

        /**
         * Restores a previously saved configuration.
         * @function module:wcDocker#restore
         * @param {String} dataString - A previously saved serialized string, See [wcDocker.save]{@link wcDocker#save}.
         */
        restore: function (dataString) {
            var data = JSON.parse(dataString, function (key, value) {
                if (value === 'Infinity') {
                    return Infinity;
                }
                return value;
            });

            this.clear();

            this._emit('beginRestore');

            this._root = this.__create(data.root, this, this.$container);
            this._root.__restore(data.root, this);

            for (var i = 0; i < data.floating.length; ++i) {
                var panel = this.__create(data.floating[i], this, this.$container);
                panel.__restore(data.floating[i], this);
            }

            this.__forceUpdate(false);

            if (!_.isEmpty(data.collapsers) && this.isCollapseEnabled()) {
                this.__initCollapsers();

                this._collapser[wcDocker.DOCK.LEFT].__restore(data.collapsers.left, this);
                this._collapser[wcDocker.DOCK.RIGHT].__restore(data.collapsers.right, this);
                this._collapser[wcDocker.DOCK.BOTTOM].__restore(data.collapsers.bottom, this);

                var self = this;
                setTimeout(function () {
                    self.__forceUpdate();
                });
            }
            this._emit('endRestore');
        },

        /**
         * Clears all contents from the docker instance.
         * @function module:wcDocker#clear
         */
        clear: function () {
            this._root = null;

            // Make sure we notify all panels that they are closing.
            this.trigger(wcDocker.EVENT.CLOSED);

            for (var i = 0; i < this._splitterList.length; ++i) {
                this._splitterList[i].__destroy();
            }

            for (var i = 0; i < this._frameList.length; ++i) {
                this._frameList[i].__destroy();
            }

            if (!_.isEmpty(this._collapser)) {
                this._collapser[wcDocker.DOCK.LEFT].__destroy();
                this._collapser[wcDocker.DOCK.RIGHT].__destroy();
                this._collapser[wcDocker.DOCK.BOTTOM].__destroy();
                this._collapser = {};
            }

            while (this._frameList.length) this._frameList.pop();
            while (this._floatingList.length) this._floatingList.pop();
            while (this._splitterList.length) this._splitterList.pop();

            this.off();
        },


        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // Private Functions
        ///////////////////////////////////////////////////////////////////////////////////////////////////////

        __init: function () {
            var self = this,
                body = $('body'),
                container = this.$outer;


            this._root = null;
            this.__eventHandles = [];
            this.__addPlaceholder();
            //self.__on($(window), 'resize', this.__resize.bind(this));
            //self.__on(body, 'contextmenu', '.wcSplitterBar', __onContextDisable);

            // $('body').on('selectstart', '.wcFrameTitleBar, .wcPanelTab, .wcFrameButton', function(event) {
            //   event.preventDefault();
            // });

            // Hovering over a panel creation context menu.
            self.__on(body, 'mouseenter', '.wcMenuCreatePanel', __onEnterCreatePanel);
            self.__on(body, 'mouseleave', '.wcMenuCreatePanel', __onLeaveCreatePanel);


            // Mouse move will allow you to move an object that is being dragged.
            self.__on(body, 'mousemove', __onMouseMove);
            //self.__on(body, 'touchmove', __onMouseMove);

            // A catch all on mouse down to record the mouse origin position.
            self.__on(body, 'mousedown', __onMouseDown);
            //self.__on(body, 'touchstart', __onMouseDown);

            self.__on(body, 'mousedown', '.wcModalBlocker', __onMouseDownModalBlocker);

            //self.__on(body, 'touchstart', '.wcModalBlocker', __onMouseDownModalBlocker);
            // On some browsers, clicking and dragging a tab will drag it's graphic around.
            // Here I am disabling this as it interferes with my own drag-drop.
            self.__on(body, 'mousedown', '.wcPanelTab', __onPreventDefault);
            //self.__on(body, 'touchstart', '.wcPanelTab', __onPreventDefault);
            self.__on(body, 'mousedown', '.wcFrameButtonBar > .wcFrameButton', __onMouseSelectionBlocker);
            //self.__on(body, 'touchstart', '.wcFrameButtonBar > .wcFrameButton', __onMouseSelectionBlocker);
            // Mouse down on a frame title will allow you to move them.
            self.__on(body, 'mousedown', '.wcFrameTitleBar', __onMouseDownFrameTitle);
            //self.__on(body, 'touchstart', '.wcFrameTitleBar', __onMouseDownFrameTitle);
            // Mouse down on a splitter bar will allow you to resize them.
            self.__on(body, 'mousedown', '.wcSplitterBar', __onMouseDownSplitter);
            //self.__on(body, 'touchstart', '.wcSplitterBar', __onMouseDownSplitter);
            // Middle mouse button on a panel tab to close it.
            self.__on(body, 'mousedown', '.wcPanelTab', __onMouseDownPanelTab);
            //self.__on(body, 'touchstart', '.wcPanelTab', __onMouseDownPanelTab);
            // Middle mouse button on a panel tab to close it.
            self.__on(body, 'mouseup', '.wcPanelTab', __onReleasePanelTab);
            //self.__on(body, 'touchend', '.wcPanelTab', __onReleasePanelTab);
            // Mouse down on a panel will put it into focus.
            self.__on(body, 'mousedown', '.wcLayout', __onMouseDownLayout);
            //self.__on(body, 'touchstart', '.wcLayout', __onMouseDownLayout);
            // Floating frames have resizable edges.
            self.__on(body, 'mousedown', '.wcFrameEdge', __onMouseDownResizeFrame);
            //self.__on(body, 'touchstart', '.wcFrameEdge', __onMouseDownResizeFrame);
            // Create new panels.
            self.__on(body, 'mousedown', '.wcCreatePanel', __onMouseDownCreatePanel);
            //self.__on(body, 'touchstart', '.wcCreatePanel', __onMouseDownCreatePanel);
            // Mouse released
            self.__on(body, 'mouseup', __onMouseUp);
            //self.__on(body, 'touchend', __onMouseUp);

            // Clicking on a custom tab button.
            self.__on(body, 'click', '.wcCustomTab .wcFrameButton', __onClickCustomTabButton);
            // Clicking on a panel frame button.
            self.__on(body, 'click', '.wcFrameButtonBar > .wcFrameButton', __onClickPanelButton);

            // Escape key to cancel drag operations.
            self.__on(body, 'keyup', __onKeyup);

            // on mousedown
            function __onMouseDown(event) {
                var mouse = self.__mouse(event);
                self._mouseOrigin.x = mouse.x;
                self._mouseOrigin.y = mouse.y;
            }

            // on mouseup
            function __onMouseUp(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                $('body').removeClass('wcDisableSelection');
                if (self._draggingFrame) {
                    for (var i = 0; i < self._frameList.length; ++i) {
                        self._frameList[i].__shadow(false);
                    }
                }

                if(self._draggingFrameSizer){
                    self.trigger(wcDocker.EVENT.END_FLOAT_RESIZE);
                }
                
                if (self._ghost && (self._draggingFrame || self._creatingPanel)) {
                    var anchor = self._ghost.anchor();

                    if (self._draggingFrame) {
                        if (!anchor) {
                            if (!self._draggingFrameTab) {
                                self._draggingFrame.panel(0);
                            }

                            var panel = self._draggingFrame.panel(parseInt($(self._draggingFrameTab).attr('id')));
                            self.movePanel(panel, wcDocker.DOCK.FLOAT, null, self._ghost.__rect());
                            // Dragging the entire frame.
                            if (!self._draggingFrameTab) {
                                var count = self._draggingFrame._panelList.length;
                                if (count > 1 || self._draggingFrame.panel() !== self._placeholderPanel) {
                                    for (var i = 0; i < count; ++i) {
                                        self.movePanel(self._draggingFrame.panel(), wcDocker.DOCK.STACKED, panel, {tabOrientation: self._draggingFrame._tabOrientation});
                                    }
                                }
                            }

                            var frame = panel._parent;
                            if (frame && frame.instanceOf('wcFrame')) {
                                frame.pos(mouse.x, mouse.y + self._ghost.__rect().h / 2 - 10, true);

                                frame._size.x = self._ghost.__rect().w;
                                frame._size.y = self._ghost.__rect().h;
                            }

                            frame.__update();
                            self.__focus(frame);
                        } else if (!anchor.self && anchor.loc !== undefined) {
                            // Changing tab location on the same frame.
                            if (anchor.tab && anchor.item._parent._parent == self._draggingFrame) {
                                self._draggingFrame.tabOrientation(anchor.tab);
                            } else {
                                var index = 0;
                                if (self._draggingFrameTab) {
                                    index = parseInt($(self._draggingFrameTab).attr('id'));
                                } else {
                                    self._draggingFrame.panel(0);
                                }
                                var panel;
                                if (anchor.item) {
                                    panel = anchor.item._parent;
                                }
                                // If we are dragging a tab to split its own container, find another
                                // tab item within the same frame and split from there.
                                if (self._draggingFrame._panelList.indexOf(panel) > -1) {
                                    // Can not split the frame if it is the only panel inside.
                                    if (self._draggingFrame._panelList.length === 1) {
                                        return;
                                    }
                                    for (var i = 0; i < self._draggingFrame._panelList.length; ++i) {
                                        if (panel !== self._draggingFrame._panelList[i]) {
                                            panel = self._draggingFrame._panelList[i];
                                            index--;
                                            break;
                                        }
                                    }
                                }
                                var movingPanel = null;
                                if (self._draggingFrameTab) {
                                    movingPanel = self._draggingFrame.panel(parseInt($(self._draggingFrameTab).attr('id')));
                                } else {
                                    movingPanel = self._draggingFrame.panel();
                                }
                                panel = self.movePanel(movingPanel, anchor.loc, panel, self._ghost.rect());
                                panel._parent.panel(panel._parent._panelList.length - 1, true);
                                // Dragging the entire frame.
                                if (!self._draggingFrameTab) {
                                    var rect = self._ghost.rect();
                                    if (!rect.tabOrientation) {
                                        rect.tabOrientation = self._draggingFrame.tabOrientation();
                                    }
                                    var count = self._draggingFrame._panelList.length;
                                    if (count > 1 || self._draggingFrame.panel() !== self._placeholderPanel) {
                                        for (var i = 0; i < count; ++i) {
                                            self.movePanel(self._draggingFrame.panel(), wcDocker.DOCK.STACKED, panel, rect);
                                        }
                                    }
                                } else {
                                    var frame = panel._parent;
                                    if (frame && frame.instanceOf('wcFrame')) {
                                        index = index + frame._panelList.length;
                                    }
                                }

                                var frame = panel._parent;
                                if (frame && frame.instanceOf('wcFrame')) {
                                    frame.panel(index);
                                }
                                self.__focus(frame);
                            }
                        }
                    } else if (self._creatingPanel) {
                        var loc = wcDocker.DOCK.FLOAT;
                        var target = null;
                        if (anchor) {
                            loc = anchor.loc;
                            if (anchor.item) {
                                target = anchor.item._parent;
                            } else {
                                target = anchor.panel;
                            }
                        }
                        self.addPanel(self._creatingPanel, loc, target, self._ghost.rect());
                    }

                    self._ghost.destroy();
                    self._ghost = null;

                    self.trigger(wcDocker.EVENT.END_DOCK);
                    self.__update();
                }

                if (self._draggingSplitter) {
                    self._draggingSplitter.$pane[0].removeClass('wcResizing');
                    self._draggingSplitter.$pane[1].removeClass('wcResizing');
                }

                self._draggingSplitter = null;
                self._draggingFrame = null;
                self._draggingFrameSizer = null;
                self._draggingFrameTab = null;
                self._draggingFrameTopper = false;
                self._draggingCustomTabFrame = null;
                self._removingPanel = null;
                return true;
            }

            // on mousemove
            var lastMouseMove = new Date().getTime();
            var lastMouseEvent = null;
            var moveTimeout = 0;
            var lastLButtonDown = 0;

            function __onMouseMove(event) {

                lastMouseEvent = event;
                var mouse = self.__mouse(event);
                if (mouse.which === 3 || (
                    !self._draggingSplitter && !self._draggingFrameSizer && !self._draggingCustomTabFrame && !self._ghost && !self._draggingFrame && !self._draggingFrameTab)) {
                    return true;
                }

                var t = new Date().getTime();
                if (t - lastMouseMove < self._options.responseRate) {
                    if (!moveTimeout) {
                        moveTimeout = setTimeout(function () {
                            lastMouseMove = 0;
                            moveTimeout = 0;
                            __onMouseMove(lastMouseEvent);
                        }, self._options.responseRate);
                    }
                    return true;
                }
                lastMouseMove = new Date().getTime();

                if (self._draggingSplitter) {
                    self._draggingSplitter.__moveBar(mouse);
                } else if (self._draggingFrameSizer) {
                    var offset = self.$container.offset();
                    mouse.x += offset.left;
                    mouse.y += offset.top;
                    self._draggingFrame.__resize(self._draggingFrameSizer, mouse);
                    self._draggingFrame.__update();
                } else if (self._draggingCustomTabFrame) {
                    if (self._draggingCustomTabFrame.moveable()) {
                        var $hoverTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if (self._draggingFrameTab && $hoverTab && $hoverTab.length && self._draggingFrameTab !== event.target) {
                            self._draggingFrameTab = self._draggingCustomTabFrame.moveTab(parseInt($(self._draggingFrameTab).attr('id')), parseInt($hoverTab.attr('id')));
                        }
                    }
                } else if (self._ghost) {
                    if (self._draggingFrame) {
                        self._ghost.__move(mouse);
                        var forceFloat = !(self._draggingFrame._isFloating || mouse.which === 1);
                        var found = false;

                        // Check anchoring with self.
                        if (!self._draggingFrame.__checkAnchorDrop(mouse, true, self._ghost, self._draggingFrame._panelList.length > 1 && self._draggingFrameTab, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame))) {
                            // Introduce a delay before a panel begins movement to a new docking position.
                            if (new Date().getTime() - lastLButtonDown < self._options.moveStartDelay) {
                                return;
                            }
                            self._draggingFrame.__shadow(true);
                            self.__focus();
                            if (!forceFloat) {
                                for (var i = 0; i < self._frameList.length; ++i) {
                                    if (self._frameList[i] !== self._draggingFrame) {
                                        if (self._frameList[i].__checkAnchorDrop(mouse, false, self._ghost, true, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame))) {
                                            self._draggingFrame.__shadow(true);
                                            return;
                                        }
                                    }
                                }
                            }

                            if (self._draggingFrame.panel().detachable()) {
                                self._ghost.anchor(mouse, null);
                            }
                        } else {
                            self._draggingFrame.__shadow(false);
                            var $target = $(document.elementFromPoint(mouse.x, mouse.y));
                            var $hoverTab = $target.hasClass('wcPanelTab') ? $target : $target.parents('.wcPanelTab');
                            if (self._draggingFrameTab && $hoverTab.length && self._draggingFrameTab !== $hoverTab[0]) {
                                self._draggingFrameTab = self._draggingFrame.__tabMove(parseInt($(self._draggingFrameTab).attr('id')), parseInt($hoverTab.attr('id')));
                            }
                        }
                    } else if (self._creatingPanel) {
                        self._ghost.update(mouse, !self._creatingPanelNoFloating);
                    }
                } else if (self._draggingFrame && !self._draggingFrameTab) {
                    self._draggingFrame.__move(mouse);
                    self._draggingFrame.__update();
                    self.trigger(wcDocker.EVENT.MOVE_STARTED);
                }
                return true;
            }

            // on mouseenter for .wcMenuCreatePanel
            function __onEnterCreatePanel() {
                if (self._ghost) {
                    self._ghost.$ghost.stop().fadeIn(200);
                }
            }

            // on mouseleave for .wcMenuCreatePanel
            function __onLeaveCreatePanel() {
                if (self._ghost) {
                    self._ghost.$ghost.stop().fadeOut(200);
                }
            }

            // on mousedown for .wcModalBlocker
            function __onMouseDownModalBlocker(event) {
                // for (var i = 0; i < self._modalList.length; ++i) {
                //   self._modalList[i].__focus(true);
                // }
                if (self._modalList.length) {
                    self._modalList[self._modalList.length - 1].__focus(true);
                }
            }

            // on mousedown for .wcPanelTab
            function __onPreventDefault(event) {
                event.preventDefault();
                event.returnValue = false;
            }

            // on mousedown for .wcFrameButtonBar > .wcFrameButton
            function __onMouseSelectionBlocker() {
                $('body').addClass('wcDisableSelection');
            }

            // on click for .wcCustomTab .wcFrameButton
            function __onClickCustomTabButton(event) {
                $('body').removeClass('wcDisableSelection');
                for (var i = 0; i < self._tabList.length; ++i) {
                    var customTab = self._tabList[i];
                    if (customTab.$close[0] === this) {
                        var tabIndex = customTab.tab();
                        customTab.removeTab(tabIndex);
                        event.stopPropagation();
                        return;
                    }

                    if (customTab.$tabLeft[0] === this) {
                        customTab._tabScrollPos -= customTab.$tabBar.width() / 2;
                        if (customTab._tabScrollPos < 0) {
                            customTab._tabScrollPos = 0;
                        }
                        customTab.__updateTabs();
                        event.stopPropagation();
                        return;
                    }
                    if (customTab.$tabRight[0] === this) {
                        customTab._tabScrollPos += customTab.$tabBar.width() / 2;
                        customTab.__updateTabs();
                        event.stopPropagation();
                        return;
                    }
                }
            }

            // on click for .wcFrameButtonBar > .wcFrameButton
            function __onClickPanelButton() {
                $('body').removeClass('wcDisableSelection');
                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$close[0] === this) {
                        self.__closePanel(frame.panel());
                        return;
                    }
                    if (frame.$collapse[0] === this) {
                        var $icon = frame.$collapse.children('div');
                        var position = wcDocker.DOCK.BOTTOM;
                        if ($icon.hasClass('wcCollapseLeft')) {
                            position = wcDocker.DOCK.LEFT;
                        } else if ($icon.hasClass('wcCollapseRight')) {
                            position = wcDocker.DOCK.RIGHT;
                        }
                        if (frame.isCollapser()) {
                            // Un-collapse
                            // var target;
                            var opts = {};
                            switch (position) {
                                case wcDocker.DOCK.LEFT:
                                    // target = frame._parent._parent.right();
                                    opts.w = frame.$frame.width();
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    // target = frame._parent._parent.left();
                                    opts.w = frame.$frame.width();
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    // target = frame._parent._parent.top();
                                    opts.h = frame.$frame.height();
                                    break;
                            }
                            var target = self._collapser[wcDocker.DOCK.LEFT]._parent.right();
                            frame.collapse(true);
                            self.movePanel(frame.panel(), position, target, opts);
                        } else {
                            // collapse.
                            self.movePanel(frame.panel(), position, wcDocker.COLLAPSED);
                        }
                        self.__update();
                        return;
                    }
                    if (frame.$tabLeft[0] === this) {
                        frame._tabScrollPos -= frame.$tabBar.width() / 2;
                        if (frame._tabScrollPos < 0) {
                            frame._tabScrollPos = 0;
                        }
                        frame.__updateTabs();
                        return;
                    }
                    if (frame.$tabRight[0] === this) {
                        frame._tabScrollPos += frame.$tabBar.width() / 2;
                        frame.__updateTabs();
                        return;
                    }

                    for (var a = 0; a < frame._buttonList.length; ++a) {
                        if (frame._buttonList[a][0] === this) {
                            var $button = frame._buttonList[a];
                            var result = {
                                name: $button.data('name'),
                                isToggled: false
                            };

                            if ($button.hasClass('wcFrameButtonToggler')) {
                                $button.toggleClass('wcFrameButtonToggled');
                                if ($button.hasClass('wcFrameButtonToggled')) {
                                    result.isToggled = true;
                                }
                            }

                            var panel = frame.panel();
                            panel.buttonState(result.name, result.isToggled);
                            panel.__trigger(wcDocker.EVENT.BUTTON, result);
                            return;
                        }
                    }
                }
            }

            // on mouseup for .wcPanelTab
            function __onReleasePanelTab(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 2) {
                    return;
                }

                var index = parseInt($(this).attr('id'));

                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$tabBar[0] === $(this).parents('.wcFrameTitleBar')[0]) {
                        var panel = frame._panelList[index];
                        if (self._removingPanel === panel) {
                            self.removePanel(panel);
                            self.__update();
                        }
                        return;
                    }
                }
            }

            // on mousedown for .wcSplitterBar
            function __onMouseDownSplitter(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 1) {
                    return true;
                }

                $('body').addClass('wcDisableSelection');
                for (var i = 0; i < self._splitterList.length; ++i) {
                    if (self._splitterList[i].$bar[0] === this) {
                        self._draggingSplitter = self._splitterList[i];
                        self._draggingSplitter.$pane[0].addClass('wcResizing');
                        self._draggingSplitter.$pane[1].addClass('wcResizing');
                        event.preventDefault();
                        break;
                    }
                }
                return true;
            }

            // on mousedown for .wcFrameTitleBar
            function __onMouseDownFrameTitle(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                // Skip frame buttons, they are handled elsewhere (Buttons may also have a child image or span so we check parent as well);
                if ($(event.target).hasClass('wcFrameButton') || $(event.target).parents('.wcFrameButton').length) {
                    return true;
                }

                if ($(event.target).hasClass('wcPanelCloseIcon')) {
                    return self.__closePanel(event.target.__panel);
                }

                lastLButtonDown = new Date().getTime();

                $('body').addClass('wcDisableSelection');
                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i].$titleBar[0] == this ||
                        self._frameList[i].$tabBar[0] == this) {
                        self._draggingFrame = self._frameList[i];

                        self._draggingFrame.__anchorMove(mouse);

                        var $panelTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if ($panelTab && $panelTab.length) {
                            var index = parseInt($panelTab.attr('id'));
                            self._draggingFrame.panel(index, true);
                            self._draggingFrameTab = $panelTab[0];
                            $(window).focus();
                        }

                        // If the window is able to be docked, give it a dark shadow tint and begin the movement process
                        var shouldMove = true;
                        if (self._draggingFrameTab) {
                            if ($panelTab.hasClass('wcNotMoveable')) {
                                shouldMove = false;
                            }
                        } else {
                            if (self._draggingFrame._isFloating && mouse.which === 1) {
                                shouldMove = false;
                            }
                        }

                        // if (((!$panelTab.hasClass('wcNotMoveable') && self._draggingFrameTab) ||
                        //     !(self._draggingFrame.$titleBar.hasClass('wcNotMoveable') || self._draggingFrame.$tabBar.hasClass('wcNotMoveable'))) &&
                        //     (!self._draggingFrame._isFloating || mouse.which !== 1 || self._draggingFrameTab)) {
                        if (shouldMove) {
                            // Special case to allow users to drag out only a single collapsed tab even by dragging the title bar (which normally would drag out the entire frame).
                            if (!self._draggingFrameTab && self._draggingFrame.isCollapser()) {
                                self._draggingFrameTab = self._draggingFrame.panel();
                            }
                            self._draggingFrameTopper = $(event.target).parents('.wcFrameTopper').length > 0;
                            var rect = self._draggingFrame.__rect();
                            self._ghost = new (self.__getClass('wcGhost'))(rect, mouse, self);
                            self._draggingFrame.__checkAnchorDrop(mouse, true, self._ghost, true, self._draggingFrameTopper, !self.__isLastFrame(self._draggingFrame));
                            self.trigger(wcDocker.EVENT.BEGIN_DOCK);
                        }
                        break;
                    }
                }
                for (var i = 0; i < self._tabList.length; ++i) {
                    if (self._tabList[i].$tabBar[0] == this) {
                        self._draggingCustomTabFrame = self._tabList[i];

                        var $panelTab = $(event.target).hasClass('wcPanelTab') ? $(event.target) : $(event.target).parents('.wcPanelTab');
                        if ($panelTab && $panelTab.length) {
                            var index = parseInt($panelTab.attr('id'));
                            self._draggingCustomTabFrame.tab(index, true);
                            self._draggingFrameTab = $panelTab[0];
                        }
                        break;
                    }
                }
                if (self._draggingFrame) {
                    self.__focus(self._draggingFrame);
                    //extra
                    var focusFrame = self._focusFrame;
                    var cPanel = focusFrame.currentPanel ? focusFrame.currentPanel() : null;
                    if (cPanel) {
                        cPanel._emit('ON_VIEW_SELECT');
                    }
                }
                return true;
            }

            // on mousedown for .wcLayout
            function __onMouseDownLayout(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i].panel() && self._frameList[i].panel().layout().scene()[0] == this) {
                        setTimeout(function () {
                            self.__focus(self._frameList[i]);
                        }, 10);
                        break;
                    }
                }
                return true;
            }

            // on mousedown for .wcFrameEdge
            function __onMouseDownResizeFrame(event) {
                var mouse = self.__mouse(event);
                if (mouse.which === 3) {
                    return true;
                }
                $('body').addClass('wcDisableSelection');

                for (var i = 0; i < self._frameList.length; ++i) {
                    if (self._frameList[i]._isFloating) {
                        if (self._frameList[i].$top[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top'];
                            break;
                        } else if (self._frameList[i].$bottom[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom'];
                            break;
                        } else if (self._frameList[i].$left[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['left'];
                            break;
                        } else if (self._frameList[i].$right[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['right'];
                            break;
                        } else if (self._frameList[i].$corner1[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top', 'left'];
                            break;
                        } else if (self._frameList[i].$corner2[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['top', 'right'];
                            break;
                        } else if (self._frameList[i].$corner3[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom', 'right'];
                            break;
                        } else if (self._frameList[i].$corner4[0] == this) {
                            self._draggingFrame = self._frameList[i];
                            self._draggingFrameSizer = ['bottom', 'left'];
                            break;
                        }
                    }
                }
                if (self._draggingFrame) {
                    self.__focus(self._draggingFrame);
                }

                if(self._draggingFrameSizer){
                    self.trigger(wcDocker.EVENT.BEGIN_FLOAT_RESIZE);
                }

                return true;
            }

            // on mousedown for .wcCreatePanel
            function __onMouseDownCreatePanel(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 1) {
                    return true;
                }


                var panelType = $(this).data('panel');
                var info = self.panelTypeInfo(panelType);
                if (info) {
                    var rect = {
                        x: mouse.x - 250,
                        y: mouse.y,
                        w: 500,
                        h: 500
                    };
                    $('body').addClass('wcDisableSelection');
                    self._ghost = new (self.__getClass('wcGhost'))(rect, mouse, self);
                    self._ghost.update(mouse);
                    self._ghost.anchor(mouse, self._ghost.anchor());
                    self._creatingPanel = panelType;
                    self.__focus();
                    self.trigger(wcDocker.EVENT.BEGIN_DOCK);
                }
            }

            // on mousedown for .wcPanelTab
            function __onMouseDownPanelTab(event) {
                var mouse = self.__mouse(event);
                if (mouse.which !== 2) {
                    return true;
                }

                var index = parseInt($(this).attr('id'));

                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    if (frame.$tabBar[0] === $(this).parents('.wcFrameTitleBar')[0]) {
                        var panel = frame._panelList[index];
                        if (panel && panel.closeable()) {
                            self._removingPanel = frame._panelList[index];
                        }
                        return true;
                    }
                }
                return true;
            }

            // on keyup
            function __onKeyup(event) {
                if (event.keyCode == 27) {
                    if (self._ghost) {
                        self._ghost.destroy();
                        self._ghost = false;
                        self.trigger(wcDocker.EVENT.END_DOCK);

                        if (self._draggingFrame) {
                            self._draggingFrame.__shadow(false);
                        }
                        self._creatingPanel = false;
                        self._draggingSplitter = null;
                        self._draggingFrame = null;
                        self._draggingFrameSizer = null;
                        self._draggingFrameTab = null;
                        self._draggingFrameTopper = false;
                        self._draggingCustomTabFrame = null;
                        self._removingPanel = null;
                    }
                }
            }

            this._started = true;

            this.setupActions();

        },

        // Test for load completion.
        __testLoadFinished: function () {
            for (var i = 0; i < this._frameList.length; ++i) {
                var frame = this._frameList[i];
                for (var a = 0; a < frame._panelList.length; ++a) {
                    var panel = frame._panelList[a];
                    // Skip if any panels are not initialized yet.
                    if (panel._isVisible && !panel._initialized) {
                        return;
                    }

                    // Skip if any panels still have a loading screen.
                    if (panel.$loading) {
                        return;
                    }
                }
            }

            // If we reach this point, all existing panels are initialized and loaded!
            var self = this;
            setTimeout(function () {
                self.trigger(wcDocker.EVENT.LOADED);

                // Now unregister all loaded events so they do not fire again.
                self.off(wcDocker.EVENT.LOADED);
                for (var i = 0; i < self._frameList.length; ++i) {
                    var frame = self._frameList[i];
                    for (var a = 0; a < frame._panelList.length; ++a) {
                        var panel = frame._panelList[a];
                        panel.off(wcDocker.EVENT.LOADED);
                    }
                }
            }, 0);
        },
        /*
         * Searches docked panels and splitters for a container that is within any static areas.
         */
        __findInner: function () {
            function isPaneStatic(pane) {
                return !!(pane && (pane.instanceOf('wcFrame') && pane.panel() && !pane.panel().moveable()) || (pane.instanceOf('wcCollapser')));
            }

            var parent = this._root;
            while (parent) {
                if (parent.instanceOf('wcSplitter')) {
                    var pane0 = isPaneStatic(parent._pane[0]);
                    var pane1 = isPaneStatic(parent._pane[1]);
                    if (pane0 && !pane1) {
                        parent = parent._pane[1];
                    } else if (pane1 && !pane0) {
                        parent = parent._pane[0];
                    } else if (!pane0 && !pane1) {
                        break;
                    }
                } else {
                    break;
                }
            }

            return parent;
        },

        /*
         * Sets up the collapsers for the panel.<br>
         * <b>Note: </b> This should be called AFTER you have initialized your panel layout, but BEFORE you add
         * any static panels that you do not wish to be overlapped by the collapsers (such as file menu panels).
         */
        __initCollapsers: function () {
            // Initialize collapsers if it is enabled and not already initialized.
            if (!this.isCollapseEnabled() || !_.isEmpty(this._collapser)) {
                return;
            }

            var parent = this.__findInner();

            function __createCollapser(location) {
                this._collapser[location] = this.__addCollapser(location, parent);
                parent = this._collapser[location]._parent;
                this._frameList.push(this._collapser[location]._drawer._frame);
            }

            __createCollapser.call(this, wcDocker.DOCK.LEFT);
            __createCollapser.call(this, wcDocker.DOCK.RIGHT);
            __createCollapser.call(this, wcDocker.DOCK.BOTTOM);

            var self = this;
            setTimeout(function () {
                self.__update();
            });
        },

        // Updates the sizing of all panels inside this window.
        __update: function (opt_dontMove) {
            this._dirty = true;
            this._dirtyDontMove = opt_dontMove;
        },

        // Forces an update, regardless of the response rate.
        __forceUpdate: function (opt_dontMove) {
            this._dirty = false;
            if (this._root) {
                this._root.__update(opt_dontMove);
            }

            for (var i = 0; i < this._floatingList.length; ++i) {
                this._floatingList[i].__update();
            }
        },

        __orderPanels: function () {
            if (this._floatingList.length === 0) {
                return;
            }

            var from = this._floatingList.indexOf(this._focusFrame);
            var to = this._floatingList.length - 1;

            this._floatingList.splice(to, 0, this._floatingList.splice(from, 1)[0]);

            var length = this._floatingList.length;
            var start = 10;
            var step = 5;
            var index = 0;
            var panel;

            for (var i = 0; i < this._floatingList.length; ++i) {
                panel = this._floatingList[i];
                if (panel) {
                    var layer = start + (i * step);
                    panel.$frame.css('z-index', layer);
                    panel.__trigger(wcDocker.EVENT.ORDER_CHANGED, layer);
                }
            }
        },

        // Retrieve mouse or touch position.
        __mouse: function (event) {
            if (event.originalEvent && (event.originalEvent.touches || event.originalEvent.changedTouches)) {
                var touch = event.originalEvent.touches[0] || event.originalEvent.changedTouches[0];
                return {
                    x: touch.clientX,
                    y: touch.clientY,
                    which: 1
                };
            }

            return {
                x: event.clientX || event.pageX,
                y: event.clientY || event.pageY,
                which: event.which || 1
            };
        },

        // On window resized event.
        __resize: function (event) {
            this._resizeData.time = new Date();
            if (!this._resizeData.timeout) {
                this._resizeData.timeout = true;
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
                this.__trigger(wcDocker.EVENT.RESIZE_STARTED);
            }
            this.__trigger(wcDocker.EVENT.RESIZED);
            this.__update(false);
        },

        // On window resize event ended.
        __resizeEnd: function () {
            if (new Date() - this._resizeData.time < this._resizeData.delta) {
                setTimeout(this.__resizeEnd.bind(this), this._resizeData.delta);
            } else {
                this._resizeData.timeout = false;
                this.__trigger(wcDocker.EVENT.RESIZE_ENDED);
            }
        },

        // Brings a floating window to the top.
        // Params:
        //    frame     The frame to focus.
        //    flash     Whether to flash the frame.
        __focus: function (frame, flash) {
            var differentFrames = this._focusFrame != frame;
            if (this._focusFrame) {
                if (this._focusFrame._isFloating) {
                    this._focusFrame.$frame.removeClass('wcFloatingFocus');
                }

                var oldFocusFrame = this._focusFrame;
                this._focusFrame = null;

                oldFocusFrame.__trigger(wcDocker.EVENT.LOST_FOCUS);
                if (oldFocusFrame.isCollapser() && differentFrames) {
                    oldFocusFrame.collapse();
                    oldFocusFrame.panel(-1);
                }
            }

            this._focusFrame = frame;
            if (this._focusFrame) {
                if (this._focusFrame._isFloating) {
                    this._focusFrame.$frame.addClass('wcFloatingFocus');

                    if (differentFrames) {
                        $('body').append(this._focusFrame.$frame);
                    }
                }
                this._focusFrame.__focus(flash);

                this._focusFrame.__trigger(wcDocker.EVENT.GAIN_FOCUS);
            }

            this.__orderPanels();
        },

        // Triggers an event exclusively on the docker and none of its panels.
        // Params:
        //    eventName   The name of the event.
        //    data        A custom data parameter to pass to all handlers.
        __trigger: function (eventName, data) {
            if (!eventName) {
                return;
            }

            var results = [];

            if (this._events[eventName]) {
                var events = this._events[eventName].slice(0);
                for (var i = 0; i < events.length; ++i) {
                    results.push(events[i].call(this, data));
                }
            }

            return results;
        },

        // Checks a given panel to see if it is the final remaining
        // moveable panel in the docker.
        // Params:
        //    panel     The panel.
        // Returns:
        //    true      The panel is the last.
        //    false     The panel is not the last.
        __isLastPanel: function (panel) {
            for (var i = 0; i < this._frameList.length; ++i) {
                var testFrame = this._frameList[i];
                if (testFrame._isFloating || testFrame.isCollapser()) {
                    continue;
                }
                for (var a = 0; a < testFrame._panelList.length; ++a) {
                    var testPanel = testFrame._panelList[a];
                    if (testPanel !== panel && testPanel.moveable()) {
                        return false;
                    }
                }
            }

            return true;
        },

        // Checks a given frame to see if it is the final remaining
        // moveable frame in the docker.
        // Params:
        //    frame     The frame.
        // Returns:
        //    true      The panel is the last.
        //    false     The panel is not the last.
        __isLastFrame: function (frame) {
            for (var i = 0; i < this._frameList.length; ++i) {
                var testFrame = this._frameList[i];
                if (testFrame._isFloating || testFrame === frame || testFrame.isCollapser()) {
                    continue;
                }
                for (var a = 0; a < testFrame._panelList.length; ++a) {
                    var testPanel = testFrame._panelList[a];
                    if (testPanel.moveable()) {
                        return false;
                    }
                }
            }

            return true;
        },

        // For restore, creates the appropriate object type.
        __create: function (data, parent, $container) {
            switch (data.type) {
                case 'wcSplitter':
                    var splitter = new (this.__getClass('wcSplitter'))($container, parent, data.horizontal);
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    return splitter;

                case 'wcFrame':
                    var frame = new (this.__getClass('wcFrame'))($container, parent, data.floating);
                    this._frameList.push(frame);
                    if (data.floating) {
                        this._floatingList.push(frame);
                    }
                    return frame;

                case 'wcPanel':
                    if (data.panelType === wcDocker.PANEL_PLACEHOLDER) {
                        if (!this._placeholderPanel) {
                            this._placeholderPanel = new (this.__getClass('wcPanel'))(parent, wcDocker.PANEL_PLACEHOLDER, {});
                            this._placeholderPanel._isPlaceholder = true;
                            this._placeholderPanel.__container(this.$transition);
                            this._placeholderPanel._panelObject = new function (myPanel) {
                                myPanel.title(false);
                                myPanel.closeable(false);
                            }(this._placeholderPanel);
                            this._placeholderPanel.__container($container);
                        }
                        return this._placeholderPanel;
                    } else {
                        for (var i = 0; i < this._dockPanelTypeList.length; ++i) {
                            if (this._dockPanelTypeList[i].name === data.panelType) {
                                var panel = new (this.__getClass('wcPanel'))(parent, data.panelType, this._dockPanelTypeList[i].options);
                                panel.__container(this.$transition);
                                var options = (this._dockPanelTypeList[i].options && this._dockPanelTypeList[i].options.options) || {};
                                panel._panelObject = new this._dockPanelTypeList[i].options.onCreate(panel, options);
                                panel.__container($container);
                                break;
                            }
                        }
                        return panel;
                    }
            }

            return null;
        },

        // Attempts to insert a given dock panel into an already existing frame.
        // If insertion is not possible for any reason, the panel will be
        // placed in its own frame instead.
        // Params:
        //    panel         The panel to insert.
        //    targetPanel   An optional panel to 'split', if not supplied the
        //                  new panel will split the center window.
        __addPanelGrouped: function (panel, targetPanel, options) {
            var frame = targetPanel;
            if (frame && frame.instanceOf('wcPanel')) {
                frame = targetPanel._parent;
            }

            if (frame && frame.instanceOf('wcFrame')) {
                if (options && options.tabOrientation) {
                    frame.tabOrientation(options.tabOrientation);
                }

                frame.addPanel(panel);
                return;
            }

            // If we did not manage to find a place for this panel, last resort is to put it in its own frame.
            this.__addPanelAlone(panel, wcDocker.DOCK.LEFT, targetPanel, options);
        },

        // Creates a new frame for the panel and then attaches it
        // to the window.
        // Params:
        //    panel         The panel to insert.
        //    location      The desired location for the panel.
        //    targetPanel   An optional panel to 'split', if not supplied the
        //                  new panel will split the center window.
        __addPanelAlone: function (panel, location, targetPanel, options) {
            if (targetPanel && targetPanel._shift) {
                var target = targetPanel;
                targetPanel = targetPanel._shift;
                target._shift = undefined;
            }

            if (options) {
                var width = this.$container.width();
                var height = this.$container.height();

                if (options.hasOwnProperty('x')) {
                    options.x = this.__stringToPixel(options.x, width);
                }
                if (options.hasOwnProperty('y')) {
                    options.y = this.__stringToPixel(options.y, height);
                }
                if (!options.hasOwnProperty('w')) {
                    options.w = panel.initSize().x;
                }
                if (!options.hasOwnProperty('h')) {
                    options.h = panel.initSize().y;
                }
                options.w = this.__stringToPixel(options.w, width);
                options.h = this.__stringToPixel(options.h, height);

                panel._size.x = options.w;
                panel._size.y = options.h;
            }

            // If we are collapsing the panel, put it into the collapser.
            if (targetPanel === wcDocker.COLLAPSED) {
                this.__initCollapsers();
                if (this._collapser[location]) {
                    targetPanel = this._collapser[location]._drawer._frame.addPanel(panel);
                    var self = this;
                    setTimeout(function () {
                        self.__update();
                    });
                    return panel;
                } else {
                    console.log('ERROR: Attempted to collapse panel "' + panel._type + '" to invalid location: ' + location);
                    return false;
                }
            }

            // Floating windows need no placement.
            if (location === wcDocker.DOCK.FLOAT || location === wcDocker.DOCK.MODAL) {
                var frame = new (this.__getClass('wcFrame'))(this.$container, this, true);
                if (options && options.tabOrientation) {
                    frame.tabOrientation(options.tabOrientation);
                }
                this._frameList.push(frame);
                this._floatingList.push(frame);
                this.__focus(frame);
                frame.addPanel(panel);
                frame.pos(panel._pos.x, panel._pos.y, false);

                if (location === wcDocker.DOCK.MODAL) {
                    frame.$modalBlocker = $('<div class="wcModalBlocker"></div>');
                    frame.$frame.prepend(frame.$modalBlocker);

                    panel.moveable(false);
                    frame.$frame.addClass('wcModal');
                    this._modalList.push(frame);
                }

                if (options) {
                    var pos = frame.pos(undefined, undefined, true);
                    if (options.hasOwnProperty('x')) {
                        pos.x = options.x + options.w / 2;
                    }
                    if (options.hasOwnProperty('y')) {
                        pos.y = options.y + options.h / 2;
                    }
                    frame.pos(pos.x, pos.y, true);
                    frame._size = {
                        x: options.w,
                        y: options.h
                    };
                }

                this.__orderPanels();
                return;
            }

            if (targetPanel) {
                var parentSplitter = targetPanel._parent;

                var splitterChild = targetPanel;

                while (parentSplitter && !(parentSplitter.instanceOf('wcSplitter') || parentSplitter.instanceOf('wcDocker'))) {
                    splitterChild = parentSplitter;
                    parentSplitter = parentSplitter._parent;
                }

                if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                    var splitter;
                    var left = parentSplitter.pane(0);
                    var right = parentSplitter.pane(1);
                    var size = {
                        x: -1,
                        y: -1
                    };
                    if (left === splitterChild) {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[0].width();
                        size.y = parentSplitter.$pane[0].height();
                        parentSplitter.pane(0, splitter);
                    } else {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[1].width();
                        size.y = parentSplitter.$pane[1].height();
                        parentSplitter.pane(1, splitter);
                    }

                    if (splitter) {
                        splitter.scrollable(0, false, false);
                        splitter.scrollable(1, false, false);

                        if (!options) {
                            options = {
                                w: panel._size.x,
                                h: panel._size.y
                            };
                        }

                        if (options) {
                            if (options.w < 0) {
                                options.w = size.x / 2;
                            }
                            if (options.h < 0) {
                                options.h = size.y / 2;
                            }

                            switch (location) {
                                case wcDocker.DOCK.LEFT:
                                    splitter.pos(options.w / size.x);
                                    break;
                                case wcDocker.DOCK.RIGHT:
                                    splitter.pos(1.0 - (options.w / size.x));
                                    break;
                                case wcDocker.DOCK.TOP:
                                    splitter.pos(options.h / size.y);
                                    break;
                                case wcDocker.DOCK.BOTTOM:
                                    splitter.pos(1.0 - (options.h / size.y));
                                    break;
                            }
                        } else {
                            splitter.pos(0.5);
                        }

                        frame = new (this.__getClass('wcFrame'))(this.$transition, splitter, false);
                        this._frameList.push(frame);
                        if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                            splitter.pane(0, frame);
                            splitter.pane(1, splitterChild);
                        } else {
                            splitter.pane(0, splitterChild);
                            splitter.pane(1, frame);
                        }

                        frame.addPanel(panel);
                    }
                    return;
                }
            }

            var parent = this;
            var $container = this.$container;
            var frame = new (this.__getClass('wcFrame'))(this.$transition, parent, false);
            this._frameList.push(frame);

            if (!parent._root) {
                parent._root = frame;
                frame.__container($container);
            } else {
                var splitter = new (this.__getClass('wcSplitter'))($container, parent, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                if (splitter) {
                    frame._parent = splitter;
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    var size = {
                        x: $container.width(),
                        y: $container.height()
                    };

                    if (!options) {
                        splitter.__findBestPos();
                    } else {
                        if (options.w < 0) {
                            options.w = size.x / 2;
                        }
                        if (options.h < 0) {
                            options.h = size.y / 2;
                        }

                        switch (location) {
                            case wcDocker.DOCK.LEFT:
                                splitter.pos(options.w / size.x);
                                break;
                            case wcDocker.DOCK.RIGHT:
                                splitter.pos(1.0 - (options.w / size.x));
                                break;
                            case wcDocker.DOCK.TOP:
                                splitter.pos(options.h / size.y);
                                break;
                            case wcDocker.DOCK.BOTTOM:
                                splitter.pos(1.0 - (options.h / size.y));
                                break;
                        }
                    }

                    if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                        splitter.pane(0, frame);
                        splitter.pane(1, parent._root);
                    } else {
                        splitter.pane(0, parent._root);
                        splitter.pane(1, frame);
                    }

                    parent._root = splitter;
                }
            }

            frame.addPanel(panel);
        },

        __addCollapser: function (location, parent) {
            var collapser = null;
            if (parent) {
                var parentSplitter = parent._parent;
                var splitterChild = parent;
                while (parentSplitter && !(parentSplitter.instanceOf('wcSplitter') || parentSplitter.instanceOf('wcDocker'))) {
                    splitterChild = parentSplitter;
                    parentSplitter = parentSplitter._parent;
                }

                var splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);

                if (parentSplitter && parentSplitter.instanceOf('wcDocker')) {
                    this._root = splitter;
                    splitter.__container(this.$container);
                }

                if (parentSplitter && parentSplitter.instanceOf('wcSplitter')) {
                    var left = parentSplitter.left();
                    var right = parentSplitter.right();
                    var size = {
                        x: -1,
                        y: -1
                    };
                    if (left === splitterChild) {
                        size.x = parentSplitter.$pane[0].width();
                        size.y = parentSplitter.$pane[0].height();
                        parentSplitter.pane(0, splitter);
                    } else {
                        splitter = new (this.__getClass('wcSplitter'))(this.$transition, parentSplitter, location !== wcDocker.DOCK.BOTTOM && location !== wcDocker.DOCK.TOP);
                        size.x = parentSplitter.$pane[1].width();
                        size.y = parentSplitter.$pane[1].height();
                        parentSplitter.pane(1, splitter);
                    }
                }


                if (splitter) {
                    splitter.scrollable(0, false, false);
                    splitter.scrollable(1, false, false);
                    collapser = new (this.__getClass('wcCollapser'))(this.$transition, splitter, location);
                    switch (location) {
                        case wcDocker.DOCK.TOP:
                        case wcDocker.DOCK.LEFT:
                            splitter.pos(0);
                            break;
                        case wcDocker.DOCK.BOTTOM:
                        case wcDocker.DOCK.RIGHT:
                            splitter.pos(1);
                            break;
                    }

                    if (location === wcDocker.DOCK.LEFT || location === wcDocker.DOCK.TOP) {
                        splitter.pane(0, collapser);
                        splitter.pane(1, splitterChild);
                    } else {
                        splitter.pane(0, splitterChild);
                        splitter.pane(1, collapser);
                    }
                }
            }
            return collapser;
        },

        // Adds the placeholder panel as needed
        __addPlaceholder: function (targetPanel) {
            if (this._placeholderPanel) {
                console.log('WARNING: wcDocker creating placeholder panel when one already exists');
            }

            this._placeholderPanel = new (this.__getClass('wcPanel'))(this, wcDocker.PANEL_PLACEHOLDER, {});
            this._placeholderPanel._isPlaceholder = true;
            this._placeholderPanel.__container(this.$transition);
            this._placeholderPanel._panelObject = new function (myPanel) {
                myPanel.title(false);
                myPanel.closeable(false);
            }(this._placeholderPanel);

            if (targetPanel) {
                this.__addPanelGrouped(this._placeholderPanel, targetPanel);
            } else {
                this.__addPanelAlone(this._placeholderPanel, wcDocker.DOCK.TOP);
            }

            this.__update();
        },

        __closePanel: function (panel) {
            // If the panel is persistent, instead of destroying it, add it to a persistent list instead.
            var dontDestroy = false;
            var panelOptions = this.panelTypeInfo(panel._type);
            if (panelOptions && panelOptions.isPersistent) {
                dontDestroy = true;
                this._persistentList.push(panel);
            }
            this.removePanel(panel, dontDestroy);
            this.__update();
        },

        // Converts a potential string value to a percentage.
        __stringToPercent: function (value, size) {
            if (typeof value === 'string') {
                if (value.indexOf('%', value.length - 1) !== -1) {
                    return parseFloat(value) / 100;
                } else if (value.indexOf('px', value.length - 2) !== -1) {
                    return parseFloat(value) / size;
                }
            }
            return parseFloat(value);
        },

        // Converts a potential string value to a pixel value.
        __stringToPixel: function (value, size) {
            if (typeof value === 'string') {
                if (value.indexOf('%', value.length - 1) !== -1) {
                    return (parseFloat(value) / 100) * size;
                } else if (value.indexOf('px', value.length - 2) !== -1) {
                    return parseFloat(value);
                }
            }
            return parseFloat(value);
        }
    });


    //merge types into module
    for (var prop in wcDocker) {
        Module[prop] = wcDocker[prop];
    }

    //track and expose default classes
    Module.defaultClasses = defaultClasses;

    return Module;
});
/** @module xdocker/Panel2 */
define('xdocker/Panel2',[
    "dcl/dcl",
    "dcl/inherited",
    'xide/types',
    'xide/utils',
    'wcDocker/panel',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'wcDocker/types',
    'xide/widgets/_Widget'
], function (dcl,inherited,types,utils,panel,EventedMixin,registry,wcDocker,_Widget) {

    /**
     * @class module:xdocker/Panel2
     * @extends module:wcDocker/panel
     */
    return dcl([panel,_Widget.dcl,EventedMixin.dcl], {
        selected:false,
        _isVisible:function(){
            var node = $(this.containerNode);
            if(!node.length){
                return false;
            }
            if(node[0].offsetHeight === 0){
                return false;
            }else if(node.css("display") == "none"){
                return false;
            }else if((node.css("visibility") == "hidden")){
                return false;
            }
            return true;
        },
        next:function(direction){
            var frame = this.getFrame();
            if(!frame){
                return;
            }
            var pos = parseInt(frame._curTab,10);
            return frame.panelAt(pos + direction);
        },
        set:function(key,value){
            if(key==='changed'){
                if(this.$title){
                    value ? this.$title.addClass('changed') : this.$title.removeClass('changed');
                }
                return true;
            }
            if(key==='loading'){
                value ? this.startLoading() : this.finishLoading();
            }
            if(key==='height'){
                var parent = $(this.containerNode);
                parent.css('height', value+ 'px');
                this._maxSize.y = value;
                this._minSize.y = value;
                this._actualSize.y = value;
                return true;
            }
            return this.inherited(arguments);
        },
        isExpanded:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return true;
            }
            return splitter.isExpanded();
        },
        isCollapsed:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            return splitter.isCollapsed();
        },
        expand:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            splitter.expand();
            return _.invoke(this._findWidgets,'onShow');
        },
        collapse:function(){
            var splitter = this.getSplitter();
            if(!splitter){
                return false;
            }
            splitter.collapse(splitter._pane[0].panelIndex(this) == -1 ? 1 : 0);
            return _.invoke(this._findWidgets,'onHide');
        },
        // stub
        onSaveLayout:function(e){
            this._emit('onSaveLayout',e);
        },
        onRestoreLayout:function(e){
            this._emit('onRestoreLayout',e);
        },
        // Initialize
        __init: function () {
            this.on(wcDocker.EVENT.SAVE_LAYOUT,function(data){
                data.title = this.title();
            });
            this.on(wcDocker.EVENT.RESTORE_LAYOUT,function(data){
                data.title && this.title(data.title);
            });
            var layoutClass = (this._options && this._options.layout) || 'wcLayoutTable';
            this._layout = new (this.docker().__getClass(layoutClass))(this.$container, this);
            this.$title = $('<li class="wcPanelTab">');
            this.$titleText = $('<a>' + this._title + '</a>');
            this.$title.append(this.$titleText);

            if (this._options.hasOwnProperty('title')) {
                this.title(this._options.title);
            }

            if (this._options.icon) {
                this.icon(this._options.icon);
                this._icon = this._options.icon;
            }
            if (this._options.faicon) {
                this.faicon(this._options.faicon);
            }

            if(!this.id){
                this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
            }

            utils.mixin(this,this._options.mixin);
            registry.add(this);
        },
        /**
         * Returns all dojo/dijit widgets in this node
         * @param startNode
         * @returns {_WidgetBase[]}
         * @private
         */
        _findWidgets:function(startNode){
            var result = [],
                node = startNode || this.containerNode || ( this.$container ? this.$container[0] : null);

            if(node) {
                _.each(node.children, function (child) {
                    if (child.id) {
                        var _widget = registry.byId(child.id);
                        if (_widget) {
                            result.push(_widget);
                        }
                    }
                });
            }
            this._widgets && (result = result.concat(this._widgets));
            return result;
        },

        __onShow:function(){
            _.each(this._findWidgets(), function (widget) {});
        },

        /**
         * Std API
         */
        destroy: function (removeFromDocker) {
            this.inherited(arguments);
            if(removeFromDocker!==false) {
                var _docker = this.docker();
                _docker && _docker.removePanel(this);
            }
            registry.remove(this.id);
        },
        __destroy: function () {
            this._emit('destroy');
            _.each(this._findWidgets(),function(w){
                if(w && w.destroy && !w._destroyed){
                    w.destroy();
                }
            });
            this.inherited(arguments);
            this._destroyHandles();
            this.off();
        }
    });
});
define('xdocker/Frame2',[
    "dcl/dcl",
    "wcDocker/frame"
], function (dcl,frame) {

    var Module = dcl([frame],{
        _showTitlebar:true,
        panel: function (tabIndex, autoFocus) {
            if (typeof tabIndex !== 'undefined') {
                if (this.isCollapser() && tabIndex === this._curTab) {
                    this.collapse();
                    tabIndex = -1;
                }
                if (tabIndex < this._panelList.length) {
                    this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + this._curTab + '"]').removeClass('wcPanelTabActive active');
                    this.$center.children('.wcPanelTabContent[id="' + this._curTab + '"]').addClass('wcPanelTabContentHidden');
                    if (this._curTab !== tabIndex) {
                        this.collapse();
                    }
                    this._curTab = tabIndex;
                    if (tabIndex > -1) {
                        this.$tabBar.find('> .wcTabScroller > .wcPanelTab[id="' + tabIndex + '"]').addClass('wcPanelTabActive active');
                        this.$center.children('.wcPanelTabContent[id="' + tabIndex + '"]').removeClass('wcPanelTabContentHidden');
                        this.expand();
                    }
                    this.__updateTabs(autoFocus);
                }
            }

            if (this._curTab > -1 && this._curTab < this._panelList.length) {
                return this._panelList[this._curTab];
            } else if (this.isCollapser() && this._panelList.length) {
                return this._panelList[0];
            }
            return false;
        },
        __init: function () {
            this.$frame = $('<div class="wcFrame wcWide wcTall widget">');
            this.$title = $('<div class="wcFrameTitle">');
            this.$titleBar = $('<div class="wcFrameTitleBar wcFrameTopper">');
            this.$tabBar = $('<header class="wcFrameTitleBar">');
            this.$tabScroll = $('<ul class="wcTabScroller nav nav-tabs">');
            this.$center = $('<div class="wcFrameCenter wcPanelBackground">');
            this.$tabLeft = $('<div class="wcFrameButton" title="Scroll tabs to the left."><span class="fa fa-arrow-left"></span>&lt;</div>');
            this.$tabRight = $('<div class="wcFrameButton" title="Scroll tabs to the right."><span class="fa fa-arrow-right"></span>&gt;</div>');
            this.$close = $('<div class="wcFrameButton" title="Close the currently active panel tab"><div class="fa fa-close"></div>X</div>');
            this.$collapse = $('<div class="wcFrameButton" title="Collapse the active panel"><div class="fa fa-download"></div>C</div>');
            this.$buttonBar = $('<div class="wcFrameButtonBar">');
            this.$tabButtonBar = $('<div class="wcFrameButtonBar">');

            this.$tabBar.append(this.$tabScroll);
            this.$tabBar.append(this.$tabButtonBar);
            this.$frame.append(this.$buttonBar);
            this.$buttonBar.append(this.$close);
            this.$buttonBar.append(this.$collapse);
            this.$frame.append(this.$center);

            if (this._isFloating) {
                this.$top = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('top', '-6px').css('left', '0px').css('right', '0px');
                this.$bottom = $('<div class="wcFrameEdgeH wcFrameEdge"></div>').css('bottom', '-6px').css('left', '0px').css('right', '0px');
                this.$left = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('left', '-6px').css('top', '0px').css('bottom', '0px');
                this.$right = $('<div class="wcFrameEdgeV wcFrameEdge"></div>').css('right', '-6px').css('top', '0px').css('bottom', '0px');
                this.$corner1 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('top', '-6px').css('left', '-6px');
                this.$corner2 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('top', '-6px').css('right', '-6px');
                this.$corner3 = $('<div class="wcFrameCornerNW wcFrameEdge"></div>').css('bottom', '-6px').css('right', '-6px');
                this.$corner4 = $('<div class="wcFrameCornerNE wcFrameEdge"></div>').css('bottom', '-6px').css('left', '-6px');

                this.$frame.append(this.$top);
                this.$frame.append(this.$bottom);
                this.$frame.append(this.$left);
                this.$frame.append(this.$right);
                this.$frame.append(this.$corner1);
                this.$frame.append(this.$corner2);
                this.$frame.append(this.$corner3);
                this.$frame.append(this.$corner4);
            }
            this.__container(this.$container);
            if (this._isFloating) {
                this.$frame.addClass('wcFloating');
            }
            this.$center.scroll(this.__scrolled.bind(this));
        },
        /**
         * Get/Set for 'show title bar'
         * @param show {boolean}
         * @returns {boolean}
         */
        showTitlebar:function(show){
            if(show!=null) {
                var prop = show ? 'inherit' : 'none',
                    what = 'display',
                    who = this;

                who.$titleBar.css(what, prop);
                who.$tabBar.css(what, prop);
                who.$center.css('top', show ? 30 : 0);
                this._showTitlebar = show;
            }
            return this._showTitlebar
        },
        currentPanel:function(){
            return this._panelList[this._curTab];
        },
        __widgets:function(){
            return this._panelList;
        },
        panels:function(){
            return this._panelList;
        },
        panelAt:function(index){
            return this._panelList[index];
        },
        panelIndex:function(panel) {
            return _.findIndex(this._panelList,panel);
        }
    });    
    return Module;
});
define('xdocker/Splitter2',[
    "dcl/dcl",
    'wcDocker/splitter',
    'xide/mixins/EventedMixin'
], function (dcl,wcSplitter,EventedMixin) {



    /**
     * Function to set a wcFrame's tab bar elements
     * @param frame
     * @param hide
     */
    function hideFrameTabBar(frame,hide){
        _.invoke(frame.$tabBar, frame.$buttonBar,'css',['display',hide ===true ? 'none' : 'inherit']);
    }
    /**
     * Function to preserve a wcFrame's most important properties before collapse:
     *  - minSize
     *  - pos
     *  - all child panel's minSize
     *  - all child panel's titles
     *
     * @param frame
     * @param hide
     */
    function setFramePropsMin(frame,hide){

        frame._saveProp('minSize',[0,0]);
        frame._saveProp('pos');
        frame._saveProp('showTitlebar',[]);//call with undefined

        hide!==false && hideFrameTabBar(frame,hide);

        frame._panelList && _.each(frame._panelList,function(panel){
            //save title & min size
            panel._saveProp('minSize',[0,0]);
            panel._saveProp('title');
        });
        hide && frame.showTitlebar && frame.showTitlebar(false);
    }
    /**
     * Function to restore wcFrame properties: minSize, title, showTitlebar
     * @param frame
     */
    function restoreFrameProps(frame){
        hideFrameTabBar(frame,false);
        _.each(frame._panelList,function(panel){
            var ms = panel._restoreProp('minSize',false);
            ms && panel.minSize(ms.x, ms.y);
            panel._restoreProp('title');
        });
        frame._restoreProp('showTitlebar');
    }

    /**
     * Extend splitter for evented and collapse functions
     */
    return dcl([wcSplitter,EventedMixin.dcl], {
        _lastCollapsed:null,
        _isCollapsed:false,
        // Updates the size of the splitter.
        isExpanded:function(){
            return this._lastCollapsed ==null;
        },
        isCollapsed:function(){
            return this._lastCollapsed !=null;
        },
        collapse:function(side,pos){
            this._isCollapsed = true;
            this._saveProp('pos');
            setFramePropsMin(this._pane[0],side==0);
            setFramePropsMin(this._pane[1],side==1);
            this._lastCollapsed = side;
            this.pos( pos!=null ? pos : 1);
        },
        expand:function(){
            this._isCollapsed = false;
            restoreFrameProps(this._pane[0]);
            this._restoreProp('pos');
            restoreFrameProps(this._pane[1]);
            this._lastCollapsed = null;
        }
    });
});
define('xide/mixins/ActionMixin',[
    "dcl/dcl",
    "xdojo/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    var Implementation = {
        store:null,
        getActionStore:function(){
            return this.store;
        },
        setActionStore:function(store){
            return this.store = store;
        },
        /**
         * Sort
         * @param groups
         * @param groupMap
         * @returns {*}
         */
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (a.label && b.label && groupMap[a.label] != null && groupMap[b.label] != null) {
                    var orderA = groupMap[a.label];
                    var orderB = groupMap[b.label];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        /**
         * The visibility filter. There are the events "REGISTER_ACTION" and "SET_ITEM_ACTIONS" a sub-class might listening too.
         * When receiving a new set of actions, in most cases any income action needs to be filtered agains this value.         *
         * Please @see {model:xide/action/Action for more}.
         *
         * @member visibility {module:xide/types/ACTION_VISIBILITY}
         * @type {string|null}
         */
        visibility: null,
        /**
         * All actions, there is also _incomingActions for the last set
         * type {xide/action/Action[]}
         */
        _actions: [],
        /**
         *
         * @param visibility {string|null}
         */
        clearActions: function (visibility,_store) {
            visibility = visibility || this.visibility;
            var store = _store || this.getActionStore(),
                actions = store.data;

            if(!store){
                return;
            }
            actions && _.each(actions,function(action){
                var actionVisibility = action.getVisibility!= null ? action.getVisibility(visibility) : null;
                if(actionVisibility){
                    var widget = actionVisibility.widget;
                    if(widget){
                        //remove action reference widget
                        action.removeReference && action.removeReference(widget);
                        widget.destroy();
                        this.setVisibilityField(action, 'widget', null);
                    }
                }
            },this);
        },
        /**
         * computeList modifies a set of actions in that way:
         *
         * 1. prepare the incoming list of 'actions' by grouping them using the actions.command first path element.
         * 2. order the inner branches created above, using the action's 'order', 'group' and 'command' field
         * 3. composite the the entire tree by overriding each top level's 'item' attribute
         *
         * @param items {xide/action/Action[]}
         * @returns {xide/action/Action[]} the modified version of the input
         * @private
         */
        _computeList: function (items, add) {
            return this._actions;
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField:function(action,field,_default){
            var actionVisibility = action.getVisibility !=null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !=null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField:function(action,field,value){
            var _default = {};
            if(action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction:function(action){
            if(this.getVisibilityField(action,'show')==false){
                return false;
            }else if(action.getVisibility && action.getVisibility(this.visibility)==null){
                return false;
            }
            return true;
        }
    }

    /**
     * Provides tools to deal with 'actions' (xide/action/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/_MenuMixin) in a subclass.
     *
     * @mixin module:xide/mixins/ActionMixin
     */
    var Module = declare("xide/mixins/ActionMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});

/**
 * @module xide/views/History
 */
define('xide/views/History',[
    'dcl/dcl',
    'xide/utils'
], function (dcl,utils) {
    /**
     * @class module:xide/views/History
     */
    return dcl(null, {
        declaredClass: "xide.views.History",
        duplicates:false,
        _history: null,
        _index: 0,
        constructor: function (options) {
            this._history = [];
            utils.mixin(this,options);
        },

        destroy:function(){
            delete this._history;
        },
        set: function (data) {
            this._history = data;
            this._index = this.length();
        },
        pop: function () {
            this._history.pop();
            this._index = this.length();
        },
        push: function (cmd) {
            if (this._history.indexOf(cmd) == -1 || this.duplicates===true) {
                this._history.push(cmd);
                this._index = this.length();
            }
        },
        length: function () {
            if(this._history) {
                return this._history.length;
            }
        },
        getNext: function () {
            this._index += 1;
            var cmd = this._history[this._index] || "";
            this._index = Math.min(this.length(), this._index);
            return cmd;
        },
        getPrev: function () {
            this._index = Math.max(0, this._index - 1);
            return this._history[this._index];
        },
        remove:function(what){
            this._history && this._history.remove(what);
            this._index = Math.min(this.length(), this._index);
        },
        getNow: function () {
            var index = Math.max(0, this._index - 1);
            if(this._history) {
                return this._history[index];
            }
        },
        setNow: function (what) {
            if(this._history) {
                this._history.remove(what);
                this._history.push(what);
            }
        },
        indexOf:function(what){
            if(this._history) {
                return this._history.indexOf(what);
            }
            return -1;
        }
    });
});
define('xaction/ActionContext',[
    "dcl/dcl",
    "xdojo/declare",
    'xide/types',
    'dojo/aspect',
    'xide/views/History'
], function (dcl, declare, types, aspect, History) {
    var _debug = false;
    /**
     * Mixin to handle different action contexts.
     *
     * @mixin module:xaction/ActionContext
     */
    var Implementation = {
        currentActionEmitter: null,
        _history: null,
        isEmpty: function () {
            var _emitter = this.getCurrentEmitter();
            if (_emitter) {
                return _emitter.getActionStore().getAll().length == 0;
            }
            return true;
        },
        getCurrentEmitter: function () {
            return this.currentActionEmitter;
        },
        _onRemoveEmitter: function (emitter) {
            this._history.remove(emitter);
            var _next = this._history.getNow();
            var cEmitter = this.currentActionEmitter;
            if (cEmitter == emitter) {
                this.currentActionEmitter = null;
            }
            var _last = _next;
            if (_last) {
                this.setActionEmitter(_last);
            }
        },
        refreshActions: function (actions) {
            var _self = this;
            _.each(actions, function (action) {
                if (_self.renderAction) {
                    _self.renderAction(action, null, null, null, null);
                } else {
                    console.error('renderAction not implemented for refresh actions ' + _self.declaredClass);
                }
            });
        },
        setActionEmitter: function (emitter, what, event) {
            if (emitter && emitter.getActionStore && !emitter.getActionStore()) {
                _debug && console.warn('setActionEmitter: emitter returns null action store! abort ' + emitter.declaredClass, emitter);
                return;
            }
            if (this.currentActionEmitter == emitter) {
                if (!emitter) {
                    this.setActionStore(null);
                }
                return;
            }
            _debug && console.log('setActionEmitter ' + this.id + ' ' + this.declaredClass + ' for : ' + what + ' emitter : ' + emitter.id);
            try {
                var cEmitter = this.currentActionEmitter;
                if (cEmitter) {
                    if (cEmitter.getActionStore) {
                        var store = cEmitter.getActionStore();
                        if (store) {
                            store._all = null;
                        } else {
                            _debug && console.warn('setActionEmitter no store');
                        }
                        this.clearActions();
                    } else {
                        _debug && console.warn('setActionEmitter current emitter has no getActionStore', cEmitter);
                    }
                    cEmitter && cEmitter.onDeactivateActionContext && cEmitter.onDeactivateActionContext(this, event);
                }
            } catch (e) {
                logError(e, 'setActionEmitter crash');
            }
            if (emitter && !emitter.getActionStore) {
                _debug && console.error('not an action emitter ' + emitter.declaredClass);
                return;
            }
            this.currentActionEmitter = emitter;
            if (!emitter) {
                this.setActionStore(null);
                return;
            }
            var newEmitterStore = emitter.getActionStore();
            if (!newEmitterStore) {
                _debug && console.error('new emitter has no action store ! ' + emitter.declaredClass);
                return;
            }

            newEmitterStore.__all = null;
            emitter && emitter.onUseActionStore && emitter.onUseActionStore(newEmitterStore, emitter);
            this.setActionStore(newEmitterStore, emitter);
            newEmitterStore.addRenderer(this);
            emitter && emitter.onActivateActionContext && emitter.onActivateActionContext(this, event);
            this._emit('setActionEmitter', {
                emitter: emitter
            });
            !this._history && (this._history = new History());
            this._history.setNow(emitter);
        },
        _registerActionEmitter: function (emitter) {
            if(this[this.id +'_emitter_'+emitter.id]){
                return;
            }
            this[this.id +'_emitter_'+emitter.id]=true;
            if (emitter && !emitter.getActionStore) {
                _debug && console.error('_registerActionEmitter: is not an action provider');
                return;
            }
            if (!emitter || !emitter.on) {
                _debug && console.warn('register action emitter : emitter = null');
                return false;
            }
            var thiz = this,
                handler = function (what, e) {
                    thiz.setActionEmitter(emitter, what, e);
                },
                _handle = emitter._on('selectionChanged', function (e) {
                    var type = e.why == 'clear' ? 'selectionCleared' : 'selectionChanged';
                    handler(type, e);
                });

            emitter.on('click', function (e) {
                var doHandler = true;
                if (emitter.handleActionClick) {
                    doHandler = emitter.handleActionClick(e);
                }
                doHandler && handler('click', e);
            });
            !this._history && (this._history = new History());
            emitter._on(types.EVENTS.ON_VIEW_SHOW, function (view) {
                if (thiz._history.indexOf(view)) {
                    view.view && (view = view.view);
                    thiz.setActionEmitter(view, types.EVENTS.ON_VIEW_SHOW, view);
                }
            });
        },
        destroy: function () {
            this.inherited && this.inherited(arguments);
            this._history && this._history.destroy() && delete this._history;
        },
        addActionEmitter: function (emitter) {
            if (!emitter) {
                _debug && console.warn('addActionEmitter::emitter is null');
                return;
            }
            var thiz = this;
            !this._history && (this._history = new History());
            if (!emitter.getActionStore) {
                _debug && console.error('invalid emitter ', emitter);
                return;
            }

            this._history.push(emitter);
            thiz._registerActionEmitter(emitter);
            function remove(emitter) {
                thiz._onRemoveEmitter(emitter);
            }

            aspect.after(emitter, 'destroy', function () {
                remove(emitter);
            }, true);

            emitter._on('destroy', function () {
                try {
                    remove(emitter);
                } catch (e) {
                    logError(e, 'addActionEmitter');
                }
            }, true);
        }
    };
    //package via declare
    var Module = declare('xaction/ActionContext', null, Implementation);
    //package via dcl
    Module.dcl = dcl(null, Implementation);
    return Module;
});
define('dijit/Viewport',[
	"dojo/Evented",
    "dojo/window" // getBox()
], function(Evented, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;


	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		return box;
	};

	return Viewport;
});

define('dijit/main',[
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

define('dijit/place',[
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

/** @module xide/popup **/
define('xide/popup',[
    "dojo/dom-geometry", // domGeometry.isBodyLtr
    "dojo/dom-style", // domStyle.set
    "dojo/_base/lang", // lang.hitch
    "dijit/place",
    "xide/$",
    "dcl/dcl"
], function (domGeometry, domStyle,lang,place,$,dcl) {
    /**
     * jQuery port of dijit/popup and deals with native HTML elements only.
     * @class module:xide/popup
     */
    var instance = null;
    var Module = dcl(null, {
        // _stack: dijit/_WidgetBase[]
        //		Stack of currently popped up widgets.
        //		(someone opened _stack[0], and then it opened _stack[1], etc.)
        _stack: [],
        // _beginZIndex: Number
        //		Z-index of the first popup.   (If first popup opens other
        //		popups they get a higher z-index.)
        _beginZIndex: 1000,
        _idGen: 1,
        _repositionAll: function(){
            // summary:
            //		If screen has been scrolled, reposition all the popups in the stack.
            //		Then set timer to check again later.

            if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
                var oldPos = this._firstAroundPosition,
                    newPos = domGeometry.position(this._firstAroundNode, true),
                    dx = newPos.x - oldPos.x,
                    dy = newPos.y - oldPos.y;

                if(dx || dy){
                    this._firstAroundPosition = newPos;
                    for(var i = 0; i < this._stack.length; i++){
                        var style = this._stack[i].wrapper.style;
                        style.top = (parseFloat(style.top) + dy) + "px";
                        if(style.right == "auto"){
                            style.left = (parseFloat(style.left) + dx) + "px";
                        }else{
                            style.right = (parseFloat(style.right) - dx) + "px";
                        }
                    }
                }

                this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
            }
        },
        /**
         * Initialization for widgets that will be used as popups.
         * Puts widget inside a wrapper DIV (if not already in one),and returns pointer to that wrapper DIV.
         * @param node
         * @returns {HTMLElement}
         * @private
         */
        _createWrapper: function(node,args){
            var wrapper = $(node).data('_popupWrapper');
            var owner = $(node).data('owner') || (_.isObject(args) && args.owner ? args.owner : null);
            if(!wrapper){
                var $wrapper = $("<div class='xPopup' style='display:none' role='region'></div>" );
                $('body').append(wrapper);
                $wrapper.append($(node));
                wrapper = $wrapper[0];
                var s = node.style;
                s.display = "";
                s.visibility = "";
                s.position = "";
                s.top = "0px";
                if(owner){
                    if(owner._on){
                        owner._on('destroy',function(e){
                            $wrapper.remove();
                        });
                    }
                }
                $(node).data('_popupWrapper',wrapper);
            }
            return wrapper;
        },
        /**
         * Moves the popup widget off-screen.
         * Do not use this method to hide popups when not in use, because
         * that will create an accessibility issue: the offscreen popup is
         * still in the tabbing order.
         * @param node {HTMLElement}
         * @returns {*}
         */
        moveOffScreen: function(node,args){
            // Create wrapper if not already there
            var wrapper = this._createWrapper(node,args);
            // Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
            var ltr = true,
                style = {
                    visibility: "hidden",
                    top: "-9999px",
                    display: ""
                };
            style[ltr ? "left" : "right"] = "-9999px";
            style[ltr ? "right" : "left"] = "auto";
            $(wrapper).css(style);
            return wrapper;
        },
        /**
         * Hide this popup widget (until it is ready to be shown).
         * Initialization for widgets that will be used as popups.
         * Also puts widget inside a wrapper DIV (if not already in one)
         * If popup widget needs to layout it should
         * do so when it is made visible, and popup._onShow() is called.
         * @param widget {HTMLElement}
         */
        hide: function(widget,args){
            // Create wrapper if not already there
            var wrapper = this._createWrapper(widget,args);
            $(wrapper).css({
                display: "none",
                height: "auto",			// Open() may have limited the height to fit in the viewport,
                overflowY: "visible",	// and set overflowY to "auto".
                border: ""			// Open() may have moved border from popup to wrapper.
            });
            // Open() may have moved border from popup to wrapper.  Move it back.
            var node = widget;
            if("_originalStyle" in node){
                node.style.cssText = node._originalStyle;
            }
        },
        getTopPopup: function(){
            // summary:
            //		Compute the closest ancestor popup that's *not* a child of another popup.
            //		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
            var stack = this._stack;
            for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
                /* do nothing, just trying to get right value for pi */
            }
            return stack[pi];
        },
        /**
         * Popup the widget at the specified position
         * example:
         *   opening at the mouse position
         *      popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
         *
         * example:
         *  opening the widget as a dropdown
         *      popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
         *
         *  Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
         *  (fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
         * @param args
         * @returns {*}
         */
        open: function(args){
            // summary:
            //		Popup the widget at the specified position
            //

            var last = null;



            var isLTR = true;
            var self = this,
                stack = this._stack,
                widget = args.popup,
                node = args.popup,
                orient = args.orient || ["below", "below-alt", "above", "above-alt"],
                ltr = args.parent ? args.parent.isLeftToRight() : isLTR,
                around = args.around,
                owner = $(node).data('owner'),
                extraClass = args.extraClass || "",
                id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

            // If we are opening a new popup that isn't a child of a currently opened popup, then
            // close currently opened popup(s).   This should happen automatically when the old popups
            // gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
            while(stack.length && (!args.parent || $.contains(args.parent.domNode,stack[stack.length - 1].widget.domNode))){
                this.close(stack[stack.length - 1].widget);
            }

            // Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
            // off screen) so we can do sizing calculations.
            var wrapper = this.moveOffScreen(widget,args);
            var $wrapper = $(wrapper);
            // Limit height to space available in viewport either above or below aroundNode (whichever side has more
            // room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
            // dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
            var maxHeight, popupSize = domGeometry.position(node);
            if("maxHeight" in args && args.maxHeight != -1){
                maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
            }else{
                var viewport = {
                    t:0,
                    l:0,
                    h:$(window).height(),
                    w:$(window).width()
                };
                var aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
                maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
            }
            //maxHeight = 300;
            if(popupSize.h > maxHeight){
                // Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
                // and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
                var cs = domStyle.getComputedStyle(node),
                    borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;

                $wrapper.css({
                    'overflow-y': "scroll",
                    height: maxHeight + "px",
                    border: borderStyle	// so scrollbar is inside border
                });
                node._originalStyle = node.style.cssText;
                node.style.border = "none";
            }
            $wrapper.attr({
                id: id,
                "class": "xPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup" + ' ' + (args.css ? args.css : ""),
                dijitPopupParent: args.parent ? args.parent.id : ""
            });
            $wrapper.css('z-index',this._beginZIndex + stack.length);
            if(stack.length === 0 && around){
                // First element on stack. Save position of aroundNode and setup listener for changes to that position.
                this._firstAroundNode = around;
                //this._firstAroundPosition = domGeometry.position(around, true);
                var offset = $(around).offset();
                this._firstAroundPosition = {
                    w:$(around).width(),
                    h:$(around).height(),
                    x:offset.left,
                    y:offset.top
                };
                //this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
                this._aroundMoveListener = setTimeout(function(){
                    self._repositionAll();
                }, 50);
            }

            // position the wrapper node and make it visible
            var layoutFunc = null ; //widget.orient ? lang.hitch(widget, "orient") : null;
            var best = around ?
                place.around(wrapper, around, orient, ltr, layoutFunc) :
                place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
                    layoutFunc);

            wrapper.style.visibility = "visible";
            node.style.visibility = "visible";	// counteract effects from _HasDropDown


            var handlers = [];
            $(wrapper).on('keydown',function(evt){
                if(evt.keyCode == 27 && args.onCancel){//esape
                    evt.stopPropagation();
                    evt.preventDefault();
                    args.onCancel();
                }else if(evt.keyCode == 9){//tab
                    evt.stopPropagation();
                    evt.preventDefault();
                    var topPopup = self.getTopPopup();
                    if(topPopup && topPopup.onCancel){
                        topPopup.onCancel();
                    }
                }
            });
            // watch for cancel/execute events on the popup and notify the caller
            // (for a menu, "execute" means clicking an item)
            if(widget.onCancel && args.onCancel){
                handlers.push(widget.on("cancel", args.onCancel));
            }

            $(node).css('display','block');
            /*
             handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
             var topPopup = this.getTopPopup();
             if(topPopup && topPopup.onExecute){
             topPopup.onExecute();
             }
             })));
             */
            stack.push({
                widget: widget,
                wrapper: wrapper,
                parent: args.parent,
                onExecute: args.onExecute,
                onCancel: args.onCancel,
                onClose: args.onClose,
                handlers: handlers
            });
            if(widget.onOpen){
                // TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
                widget.onOpen(best);
            }
            $(wrapper).addClass(extraClass);
            return best;
        },
        close: function(/*Widget?*/ popup){
            // summary:
            //		Close specified popup and any popups that it parented.
            //		If no popup is specified, closes all popups.
            var stack = this._stack;
            // Basically work backwards from the top of the stack closing popups
            // until we hit the specified popup, but IIRC there was some issue where closing
            // a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
            // closing C might close B indirectly and then the while() condition will run where stack==[A]...
            // so the while condition is constructed defensively.
            while((popup && _.some(stack, function(elem){
                return elem.widget == popup;
            })) ||

            (!popup && stack.length)){
                var top = stack.pop(),
                    widget = top.widget,
                    onClose = top.onClose;

                if(widget.onClose){
                    widget.onClose();
                }

                var h;

                while(h = top.handlers.pop()){
                    h.remove();
                }

                // Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
                if(widget && widget){
                    this.hide(widget);
                }
                if(onClose){
                    onClose();
                }
            }

            $(popup).css('display','none');

            if(stack.length === 0 && this._aroundMoveListener){
                clearTimeout(this._aroundMoveListener);
                this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
            }
        }
    });
    instance  = new Module();
    return instance;
});
/** @module xide/widgets/_MenuMixin **/
define('xide/widgets/_MenuMixin4',[
    'dcl/dcl',
    'xide/types',
    'xide/utils',
    'xide/registry',
    'xaction/Action',
    'xaction/DefaultActions',
    "xide/popup"
], function (dcl, types, utils, registry, Action, DefaultActions,popup) {

    var createCallback = function (func, menu, item) {
        return function (event) {
            /*
            if(item) {

                var _parent = item.parent();
                _parent.data('open', false);
                _parent[0] && popup.close(_parent[0]);

            }
            */
            return func(event, menu, item);
        };
    };

    var ACTION = types.ACTION;
    var _debug = false;
    var _debugWidgets = false;
    /**
     * Mixin which provides utils for menu & action related render tasks.
     * @mixin module:xide/widgets/_MenuMixin
     */
    var _Module = dcl(null, {
        actionStores: null,
        correctSubMenu: false,
        _didInit: null,
        actionFilter: null,
        hideSubsFirst: false,
        collapseSmallGroups: 0,
        containerClass: '',
        lastTree:null,
        onActionAdded: function (actions) {
            this.setActionStore(this.getActionStore(), actions.owner || this, false, true, actions);
        },
        onActionRemoved: function (evt) {
            this.clearAction(evt.target);
        },
        clearAction: function (action) {
            var self = this;
            if (action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    widget && action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        removeCustomActions: function () {
            var oldStore = this.store;
            var oldActions = oldStore._find({
                    custom: true
                });

            var menuData = this.menuData;
            _.each(oldActions, function (action) {
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData, {
                    command: action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField: function (action, field, _default) {
            var actionVisibility = action.getVisibility !== null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !== null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField: function (action, field, value) {
            var _default = {};
            if (action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction: function (action) {
            if (this.getVisibilityField(action, 'show') === false) {
                return false;
            } else if (action.getVisibility && action.getVisibility(this.visibility) == null) {
                return false;
            }
            return true;
        },
        addActionStore: function (store) {
            if (!this.actionStores) {
                this.actionStores = [];
            }
            if (this.actionStores.indexOf(store) == -1) {
                this.actionStores.push(store);
            }
        },
        /**

         tree structure :

         {
            root: {
                Block:{
                    grouped:{
                        Step:[action,action]
                    }
                }
            },
            rootActions: string['File','Edit',...],

            allActionPaths: string[command],

            allActions:[action]
         }

         * @param store
         * @param owner
         * @returns {{root: {}, rootActions: Array, allActionPaths: *, allActions: *}}
         */
        constructor: function (options, node) {
            this.target = node;
            utils.mixin(this, options);
        },
        onClose: function (e) {
            this._rootMenu && this._rootMenu.parent().removeClass('open');
        },
        onOpen: function () {
            this._rootMenu && this._rootMenu.parent().addClass('open');
        },
        isLeftToRight: function () {
            return false;
        },
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });
            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            this.__on(root, 'mouseenter', '.dropdown-submenu', function (e) {
                try {
                    var _root = $(e.currentTarget);
                    var $sub = _root.find('.dropdown-context-sub:first');
                    var didPopup = false;
                    if ($sub.length === 0) {
                        $sub = _root.data('sub');
                        if ($sub) {
                            didPopup = true;
                        } else {
                            return;
                        }
                    }
                    var data = $sub.data('data');
                    var level = data ? data[0].level : 0;
                    var isFirst = level === 1;
                    if (self.menu) {
                        if (!$.contains(self.menu[0], _root[0])) {
                            return;
                        }
                    }

                    var _disabled = _root.hasClass('disabled');
                    if (_disabled) {
                        $sub.css('display', 'none');
                        return;
                    } else {
                        $sub.css('display', 'block');
                    }

                    if (isFirst) {
                        $sub.css('display', 'initial');
                        $sub.css('position', 'initial');
                        function close() {
                            var _wrapper = $sub.data('_popupWrapper');
                            popup.close({
                                domNode: $sub[0],
                                _popupWrapper: _wrapper
                            });
                        }

                        if (!didPopup) {
                            _root.data('sub', $sub);
                            $sub.data('owner', self);
                            $sub.on('mouseleave', function () {
                                close();
                            });
                            _root.on('mouseleave', function () {
                            });
                        }

                        popup.open({
                            //parent: self,
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                close();
                            },
                            onClose: function () {
                                //console.log('close');
                                //domAttr.set(self._popupStateNode, "popupActive", false);
                                //domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                                //self._set("_opened", false);	// use set() because _CssStateMixin is watching
                            }
                        });
                        return;
                    } else {
                        if (!$sub.data('didSetup')) {
                            $sub.data('didSetup', true);
                            _root.on('mouseleave', function () {
                                $sub.css('display', '');
                            });
                        }
                    }

                    //reset top
                    $sub.css({
                        top: 0
                    });

                    var autoH = $sub.height() + 0;
                    var totalH = $('html').height();
                    var pos = $sub.offset();
                    var overlapYDown = totalH - (pos.top + autoH);
                    if ((pos.top + autoH) > totalH) {
                        $sub.css({
                            top: overlapYDown - 30
                        }).fadeIn(options.fadeSpeed);
                    }
                    ////////////////////////////////////////////////////////////
                    var subWidth = $sub.width(),
                        subLeft = $sub.offset().left,
                        collision = (subWidth + subLeft) > window.innerWidth;

                    if (collision) {
                        $sub.addClass('drop-left');
                    }
                } catch (e) {
                    logError(e);
                }
            });
        },
        getDefaultOptions: function () {
            return {
                fadeSpeed: 0,
                above: 'auto',
                left: 'auto',
                preventDoubleContext: false,
                compress: true
            };
        },
        buildMenuItems: function ($menu, data, id, subMenu, addDynamicTag) {
            //this._debugMenu && console.log('build - menu items ', arguments);
            var linkTarget = '',
                self = this,
                visibility = this.visibility;

            for (var i = 0; i < data.length; i++) {
                var item = data[i],
                    $sub,
                    widget = item.widget;

                if (typeof item.divider !== 'undefined' && !item.widget) {
                    var divider = '<li class="divider';
                    divider += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    divider += '"></li>';
                    item.widget = divider;
                    $menu.append(divider);
                    divider.data('item',item);

                } else if (typeof item.header !== 'undefined' && !item.widget) {
                    var header = item.vertical ? '<li class="divider-vertical' : '<li class="nav-header testClass';
                    header += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    header += '">' + item.header + '</li>';
                    header = $(header);
                    item.widget = header;
                    $menu.append(header);
                    header.data('item',item);

                } else if (typeof item.menu_item_src !== 'undefined') {

                } else {

                    if (!widget && typeof item.target !== 'undefined') {
                        linkTarget = ' target="' + item.target + '"';
                    }
                    if (typeof item.subMenu !== 'undefined' && !widget) {
                        var sub_menu = '<li tabindex="-1" class="dropdown-submenu ' + this.containerClass;
                        sub_menu += (addDynamicTag) ? ' dynamic-menu-item' : '';
                        sub_menu += '"><a>';

                        if (typeof item.icon !== 'undefined') {
                            sub_menu += '<span class="icon ' + item.icon + '"></span> ';
                        }
                        sub_menu += item.text + '';
                        sub_menu += '</a></li>';
                        $sub = $(sub_menu);

                    } else {
                        if (!widget) {
                            if (item.render) {
                                $sub = item.render(item, $menu);
                            } else {
                                var element = '<li tabindex="-1" class="" ';
                                element += (addDynamicTag) ? ' class="dynamic-menu-item"' : '';
                                element += '><a >';
                                if (typeof data[i].icon !== 'undefined') {
                                    element += '<span class="' + item.icon + '"></span> ';
                                }
                                element += item.text + '</a></li>';
                                $sub = $(element);
                                if (item.postRender) {
                                    item.postRender($sub);
                                }
                            }
                        }
                    }

                    if (typeof item.action !== 'undefined' && !item.widget) {
                        if (item.addClickHandler && item.addClickHandler() === false) {
                        } else {
                            var $action = item.action;
                            if ($sub && $sub.find) {
                                var trigger = $sub.find('a');
                                trigger.addClass('context-event');
                                var handler = createCallback($action, item, $sub);
                                trigger.data('handler',handler).on('click',handler);
                            }
                        }
                    }

                    if ($sub && !widget) {

                        item.widget = $sub;
                        $sub.menu = $menu;
                        $sub.data('item', item);

                        item.$menu = $menu;
                        item.$sub = $sub;

                        item._render = function () {
                            if (item.index === 0) {
                                this.$menu.prepend(this.$sub);
                            } else {
                                this.$menu.append(this.$sub);
                            }
                        };
                        if (!item.lazy) {
                            item._render();
                        }
                    }

                    if ($sub) {
                        $sub.attr('level', item.level);
                    }

                    if (typeof item.subMenu != 'undefined' && !item.subMenuData) {
                        var subMenuData = self.buildMenu(item.subMenu, id, true);
                        $menu.subMenuData = subMenuData;
                        item.subMenuData = subMenuData;
                        $menu.find('li:last').append(subMenuData);
                        subMenuData.attr('level', item.subMenu.level);
                        if (self.hideSubsFirst) {
                            subMenuData.css('display', 'none');
                        }
                        $menu.data('item', item);
                    } else {
                        if (item.subMenu && item.subMenuData) {
                            this.buildMenuItems(item.subMenuData, item.subMenu, id, true);
                        }
                    }
                }

                if (!$menu._didOnClick) {
                    $menu.on('click', '.dropdown-menu > li > input[type="checkbox"] ~ label, .dropdown-menu > li > input[type="checkbox"], .dropdown-menu.noclose > li', function (e) {
                        e.stopPropagation();
                    });
                    $menu._didOnClick = true;
                }

            }
            return $menu;
        },
        buildMenu: function (data, id, subMenu) {
            var subClass = (subMenu) ? (' dropdown-context-sub ' + this.containerClass ) : ' scrollable-menu ';
            var $menu = $('<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>');
            if (!subMenu) {
                this._rootMenu = $menu;
            }
            var result = this.buildMenuItems($menu, data, id, subMenu);
            $menu.data('data', data);
            return result;
        },
        createNewAction: function (command) {
            var segments = command.split('/');
            var lastSegment = segments[segments.length - 1];
            var action = new Action({
                command: command,
                label: lastSegment,
                group: lastSegment,
                dynamic: true
            });
            return action;
        },
        findAction: function (command) {
            var stores = this.actionStores,
                action = null;
            _.each(stores, function (store) {
                var _action = store ? store.getSync(command) : null;
                if (_action) {
                    action = _action;
                }
            });

            return action;
        },
        getAction: function (command, store) {
            store = store || this.store;
            var action = null;
            if (store) {
                action = this.findAction(command);
                if (!action) {
                    action = this.createNewAction(command);
                }
            }
            return action;
        },
        getActions: function (query) {
            var result = [];
            var stores = this.actionStores,
                visibility = this.visibility;

            query = query || this.actionFilter;
            _.each(stores, function (store) {
                store && (result = result.concat(store._find(query)));
                //store && (result2= result2.concat(store._find(query)));
            });
            result = result.filter(function (action) {
                var actionVisibility = action.getVisibility != null ? action.getVisibility(visibility) : {};
                return !(action.show === false || actionVisibility === false || actionVisibility.show === false);
            });
            /*
            console.log('action: ',[result,result2]);
            */
            return result;
        },
        toActions: function (commands, store) {
            var result = [],
                self = this;
            _.each(commands, function (path) {
                var _action = self.getAction(path, store);
                _action && result.push(_action);
            });
            return result;
        },
        onRunAction: function (action, owner, e) {
            var command = action.command;
            action = this.findAction(command);
            return DefaultActions.defaultHandler.apply(action.owner || owner, [action, e]);
        },
        getActionProperty: function (action, visibility, prop) {
            var value = prop in action ? action[prop] : null;
            if (visibility && prop in visibility) {
                value = visibility[prop];
            }
            return value;
        },
        toMenuItem: function (action, owner, label, icon, visibility, showKeyCombo, lazy) {
            var self = this,
                labelLocalized = self.localize(label),
                actionType = visibility.actionType || action.actionType;

            var item = {
                text: labelLocalized,
                icon: icon,
                data: action,
                owner: owner,
                command: action.command,
                lazy: lazy,
                addClickHandler: function () {
                    return actionType !== types.ACTION_TYPE.MULTI_TOGGLE;

                },
                render: function (data, $menu) {
                    if (self.renderItem) {
                        return self.renderItem(this, data, $menu, this.data, owner, label, icon, visibility, showKeyCombo, lazy);
                    }
                    var action = this.data;
                    var parentAction = action.getParent ? action.getParent() : null;
                    var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
                    var keyComboString = ' \n';
                    var element = null;
                    if (action.keyboardMappings && showKeyCombo !== false) {
                        var mappings = action.keyboardMappings;
                        var keyCombos = mappings[0].keys;
                        if (keyCombos && keyCombos.length) {
                            keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                        }
                    }

                    if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                        element = '<li tabindex="-1" class="" >';
                        var id = action._store.id + '_' + action.command + '_' + self.id;
                        var checked = action.get('value');
                        //checkbox-circle
                        element += '<div class="action-checkbox checkbox checkbox-success ">';
                        element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                        element += '<label for="' + id + '">';
                        element += self.localize(data.text);
                        element += '</label>';
                        element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                        element += '</li>';

                        $menu.addClass('noclose');
                        var result = $(element);
                        var checkBox = result.find('INPUT');
                        checkBox.on('change', function (e) {
                            action._originReference = data;
                            action._originEvent = e;
                            action.set('value', checkBox[0].checked);
                            action._originReference = null;
                        });
                        self.setVisibilityField(action, 'widget', data);
                        return result;
                    }
                    closeOnClick === false && $menu.addClass('noclose');
                    if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                        var value = action.value || action.get('value');
                        var parentValue = parentAction.get('value');
                        if (value == parentValue) {
                            icon = 'fa fa-check';
                        }
                    }

                    var title = data.text || labelLocalized || self.localize(action.title);


                    //default:
                    element = '<li tabindex="-1"><a title="' + title + ' ' + keyComboString + '">';
                    var _icon = data.icon || icon;

                    //icon
                    if (typeof _icon !== 'undefined') {
                        //already html string
                        if (/<[a-z][\s\S]*>/i.test(_icon)) {
                            element += _icon;
                        } else {
                            element += '<span class="icon ' + _icon + '"/> ';
                        }
                    }
                    element += data.text;
                    element += '<span style="max-width:100px" class="text-muted pull-right ellipsis keyboardShortCut">' + (showKeyCombo ? keyComboString : "") + '</span></a></li>';
                    self.setVisibilityField(action, 'widget', data);
                    return $(element);
                },
                get: function (key) {
                },
                set: function (key, value) {
                    //_debugWidgets && _.isString(value) && console.log('set ' + key + ' ' + value);
                    var widget = this.widget;

                    function updateCheckbox(widget, checked) {
                        var what = widget.find("input[type=checkbox]");
                        if (what) {
                            if (checked) {
                                what.prop("checked", true);
                            } else {
                                what.removeAttr('checked');
                            }
                        }
                    }

                    if (widget) {
                        if (key === 'disabled') {
                            if (widget.toggleClass) {
                                widget.toggleClass('disabled', value);
                            }
                        }
                        if (key === 'icon') {
                            var _iconNode = widget.find('.icon');
                            if (_iconNode) {
                                _iconNode.attr('class', 'icon');
                                this._lastIcon = this.icon;
                                this.icon = value;
                                _iconNode.addClass(value);
                            }
                        }
                        if (key === 'value') {
                            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE ||
                                actionType === types.ACTION_TYPE.SINGLE_TOGGLE) {
                                updateCheckbox(widget, value);
                            }
                        }
                    }
                },
                action: function (e, data, menu) {
                    _debug && console.log('menu action', data);
                    return self.onRunAction(data.data, owner, e);
                },
                destroy: function () {
                    if (this.widget) {
                        this.widget.remove();
                    }
                }
            };
            return item;
        },
        attach: function (selector, data) {
            this.target = selector;
            this.menu = this.addContext(selector, data);
            this.domNode = this.menu[0];
            this.id = this.domNode.id;
            registry.add(this);
            return this.menu;
        },
        addReference: function (action, item) {
            if (action.addReference) {
                action.addReference(item, {
                    properties: {
                        "value": true,
                        "disabled": true,
                        "enabled": true
                    }
                }, true);
            }
        },
        onDidRenderActions: function (store, owner) {
            if (owner && owner.refreshActions) {
                owner.refreshActions();
            }
        },
        getActionData: function (action) {
            var actionVisibility = action.getVisibility != null ? action.getVisibility(this.visibility) : {};
            return {
                label: actionVisibility.label != null ? actionVisibility.label : action.label,
                icon: actionVisibility.icon != null ? actionVisibility.icon : action.icon,
                command: actionVisibility.command != null ? actionVisibility.command : action.command,
                visibility: actionVisibility,
                group: actionVisibility.group != null ? actionVisibility.group : action.group,
                tab: actionVisibility.tab != null ? actionVisibility.tab : action.tab,
                expand: actionVisibility.expand != null ? actionVisibility.expand : false,
                widget: actionVisibility.widget
            };
        },
        _clearAction: function (action) {

        },
        _findParentData: function (oldMenuData, parentCommand) {
            var parent = _.find(oldMenuData, {
                command: parentCommand
            });
            if (parent) {
                return parent;
            }
            for (var i = 0; i < oldMenuData.length; i++) {
                var data = oldMenuData[i];
                if (data.subMenu) {
                    var found = this._findParentData(data.subMenu, parentCommand);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        },
        _clear: function () {
            var actions = this.getActions();
            var store = this.store;
            if (store) {
                this.actionStores.remove(store);
            }
            var self = this;
            actions = actions.concat(this._tmpActions);
            _.each(actions, function (action) {
                if (action) {
                    var actionVisibility = action.getVisibility != null ? action.getVisibility(self.visibility) : {};
                    if (actionVisibility) {
                        var widget = actionVisibility.widget;
                        action.removeReference && action.removeReference(widget);
                        if (widget && widget.destroy) {
                            widget.destroy();
                        }
                        delete actionVisibility.widget;
                        actionVisibility.widget = null;
                    }
                }
            });
            this.$navBar && this.$navBar.empty();
        },
        buildActionTree: function (store, owner) {
            var self = this,
                allActions = self.getActions(),
                visibility = self.visibility;

            self.wireStore(store, function (evt) {
                if (evt.type === 'update') {
                    var action = evt.target;
                    if (action.refreshReferences) {
                        action.refreshReferences(evt.property, evt.value);
                    }
                }
            });

            //return all actions with non-empty tab field
            var tabbedActions = allActions.filter(function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),

                //group all tabbed actions : { Home[actions], View[actions] }
                groupedTabs = _.groupBy(tabbedActions, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),
                //now flatten them
                _actionsFlattened = [];


            _.each(groupedTabs, function (items) {
                _actionsFlattened = _actionsFlattened.concat(items);
            });

            var rootActions = [];
            _.each(tabbedActions, function (action) {
                var rootCommand = action.getRoot();
                rootActions.indexOf(rootCommand) == -1 && rootActions.push(rootCommand);
            });

            //owner sort of top level
            store.menuOrder && (rootActions = owner.sortGroups(rootActions, store.menuOrder));

            var tree = {};
            //stats to count groups per tab
            var biggestTab = rootActions[0];
            var nbGroupsBiggest = 0;

            _.each(rootActions, function (level) {
                // collect all actions at level (File/View/...)
                var menuActions = owner.getItemsAtBranch(allActions, level);
                // convert action command strings to Action references
                var grouped = self.toActions(menuActions, store);

                // expand filter -------------------
                var addedExpanded = [];
                var toRemove = [];
                _.each(grouped, function (action) {
                    var actionData = self.getActionData(action);
                    if (actionData.expand) {
                        var children = action.getChildren();
                        children && children.length && (addedExpanded = addedExpanded.concat(children));
                        toRemove.push(action);
                    }
                });
                grouped = grouped.concat(addedExpanded);
                grouped = grouped.filter(function (action) {
                    return toRemove.indexOf(action) == -1;
                });
                // expand filter ---------------    end

                // group all actions by group
                var groupedActions = _.groupBy(grouped, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.group || action.group;
                    }
                });

                var _actions = [];
                _.each(groupedActions, function (items, level) {
                    if (level !== 'undefined') {
                        _actions = _actions.concat(items);
                    }
                });

                //flatten out again
                menuActions = _.pluck(_actions, 'command');
                menuActions.grouped = groupedActions;
                tree[level] = menuActions;

                //update stats
                if (self.collapseSmallGroups) {
                    var nbGroups = _.keys(menuActions.grouped).length;
                    if (nbGroups > nbGroupsBiggest) {
                        nbGroupsBiggest = nbGroups;
                        biggestTab = level;
                    }
                }
            });

            //now move over any tab with less than 2 groups to the next bigger tab
            this.collapseSmallGroups && _.each(tree, function (actions, level) {
                if (_.keys(actions.grouped).length < self.collapseSmallGroups) {
                    //append tab groups of the biggest tab
                    tree[biggestTab] && _.each(actions.grouped, function (group, name) {
                        tree[biggestTab].grouped[name] = group;
                    });
                    //copy manually commands to that tab
                    tree[biggestTab] && _.each(actions, function (action) {
                        tree[biggestTab].push(action);
                    });
                    tree[biggestTab] && delete tree[level];
                }
            });
            var result = {
                root: tree,
                rootActions: rootActions,
                allActionPaths: _.pluck(allActions, 'command'),
                allActions: allActions
            };

            this.lastTree = result;
            return result;
        }
    });
    var Module = dcl(null, {
        actionStores: null,
        correctSubMenu: false,
        _didInit: null,
        actionFilter: null,
        hideSubsFirst: false,
        collapseSmallGroups: 0,
        containerClass: '',
        lastTree:null,
        ITEM_TAG : "li",
        CONTAINER_TAG : "ul",
        ITEM_CLASS : "actionItem",
        onActionAdded: function (actions) {
            this.setActionStore(this.getActionStore(), actions.owner || this, false, true, actions);
        },
        onActionRemoved: function (evt) {
            this.clearAction(evt.target);
        },
        clearAction: function (action) {
            var self = this;
            if (action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    widget && action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        removeCustomActions: function () {
            var oldStore = this.store;
            var oldActions = oldStore._find({
                custom: true
            });

            var menuData = this.menuData;
            _.each(oldActions, function (action) {
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData, {
                    command: action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        /**
         * Return a field from the object's given visibility store
         * @param action
         * @param field
         * @param _default
         * @returns {*}
         */
        getVisibilityField: function (action, field, _default) {
            var actionVisibility = action.getVisibility !== null ? action.getVisibility(this.visibility) : {};
            return actionVisibility[field] !== null ? actionVisibility[field] : action[field] || _default;
        },
        /**
         * Sets a field in the object's given visibility store
         * @param action
         * @param field
         * @param value
         * @returns {*}
         */
        setVisibilityField: function (action, field, value) {
            var _default = {};
            if (action.getVisibility) {
                var actionVisibility = action.getVisibility(this.visibility) || _default;
                actionVisibility[field] = value;
            }
            return actionVisibility;
        },
        shouldShowAction: function (action) {
            if (this.getVisibilityField(action, 'show') === false) {
                return false;
            } else if (action.getVisibility && action.getVisibility(this.visibility) == null) {
                return false;
            }
            return true;
        },
        addActionStore: function (store) {
            if (!this.actionStores) {
                this.actionStores = [];
            }
            if (this.actionStores.indexOf(store) == -1) {
                this.actionStores.push(store);
            }
        },
        /**

         tree structure :

         {
            root: {
                Block:{
                    grouped:{
                        Step:[action,action]
                    }
                }
            },
            rootActions: string['File','Edit',...],

            allActionPaths: string[command],

            allActions:[action]
         }

         * @param store
         * @param owner
         * @returns {{root: {}, rootActions: Array, allActionPaths: *, allActions: *}}
         */
        constructor: function (options, node) {
            this.target = node;
            utils.mixin(this, options);
        },
        onClose: function (e) {
            this._rootMenu && this._rootMenu.parent().removeClass('open');
        },
        onOpen: function () {
            this._rootMenu && this._rootMenu.parent().addClass('open');
        },
        isLeftToRight: function () {
            return false;
        },
        init: function (opts) {
            if (this._didInit) {
                return;
            }
            this._didInit = true;
            var options = this.getDefaultOptions();
            options = $.extend({}, options, opts);
            var self = this;
            var root = $(document);
            this.__on(root, 'click', null, function (e) {
                if (!self.isOpen) {
                    return;
                }
                self.isOpen = false;
                self.onClose(e);
                $('.dropdown-context').css({
                    display: ''
                }).find('.drop-left').removeClass('drop-left');
            });
            if (options.preventDoubleContext) {
                this.__on(root, 'contextmenu', '.dropdown-context', function (e) {
                    e.preventDefault();
                });
            }
            this.__on(root, 'mouseenter', '.dropdown-submenu', function (e) {
                try {
                    var _root = $(e.currentTarget);
                    var $sub = _root.find('.dropdown-context-sub:first');
                    var didPopup = false;
                    if ($sub.length === 0) {
                        $sub = _root.data('sub');
                        if ($sub) {
                            didPopup = true;
                        } else {
                            return;
                        }
                    }
                    var data = $sub.data('data');
                    var level = data ? data[0].level : 0;
                    var isFirst = level === 1;
                    if (self.menu) {
                        if (!$.contains(self.menu[0], _root[0])) {
                            return;
                        }
                    }

                    var _disabled = _root.hasClass('disabled');
                    if (_disabled) {
                        $sub.css('display', 'none');
                        return;
                    } else {
                        $sub.css('display', 'block');
                    }

                    if (isFirst) {
                        $sub.css('display', 'initial');
                        $sub.css('position', 'initial');
                        function close() {
                            var _wrapper = $sub.data('_popupWrapper');
                            popup.close({
                                domNode: $sub[0],
                                _popupWrapper: _wrapper
                            });
                        }

                        if (!didPopup) {
                            _root.data('sub', $sub);
                            $sub.data('owner', self);
                            $sub.on('mouseleave', function () {
                                close();
                            });
                            _root.on('mouseleave', function () {
                            });
                        }

                        popup.open({
                            //parent: self,
                            popup: $sub[0],
                            around: _root[0],
                            orient: ['below', 'above'],
                            maxHeight: -1,
                            owner: self,
                            onExecute: function () {
                                self.closeDropDown(true);
                            },
                            onCancel: function () {
                                close();
                            },
                            onClose: function () {
                                //console.log('close');
                                //domAttr.set(self._popupStateNode, "popupActive", false);
                                //domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                                //self._set("_opened", false);	// use set() because _CssStateMixin is watching
                            }
                        });
                        return;
                    } else {
                        if (!$sub.data('didSetup')) {
                            $sub.data('didSetup', true);
                            _root.on('mouseleave', function () {
                                $sub.css('display', '');
                            });
                        }
                    }

                    //reset top
                    $sub.css({
                        top: 0
                    });

                    var autoH = $sub.height() + 0;
                    var totalH = $('html').height();
                    var pos = $sub.offset();
                    var overlapYDown = totalH - (pos.top + autoH);
                    if ((pos.top + autoH) > totalH) {
                        $sub.css({
                            top: overlapYDown - 30
                        }).fadeIn(options.fadeSpeed);
                    }
                    ////////////////////////////////////////////////////////////
                    var subWidth = $sub.width(),
                        subLeft = $sub.offset().left,
                        collision = (subWidth + subLeft) > window.innerWidth;

                    if (collision) {
                        $sub.addClass('drop-left');
                    }
                } catch (e) {
                    logError(e);
                }
            });
        },
        getDefaultOptions: function () {
            return {
                fadeSpeed: 0,
                above: 'auto',
                left: 'auto',
                preventDoubleContext: false,
                compress: true
            };
        },
        buildMenuItems: function ($menu, data, id, subMenu, addDynamicTag) {
            //this._debugMenu && console.log('build - menu items ', arguments);
            var linkTarget = '',
                self = this,
                visibility = this.visibility;

            var ITEM_TAG_START = '<' + this.ITEM_TAG + ' ';
            var ITEM_TAG_END = '</' + this.ITEM_TAG + '>';
            var ITEM_CLASS = this.ITEM_CLASS;
            for (var i = 0; i < data.length; i++) {
                var item = data[i],
                    $sub,
                    widget = item.widget;

                if (typeof item.divider !== 'undefined' && !item.widget) {
                    var divider = ITEM_TAG_START + 'class="divider';
                    divider += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    divider += '">' + ITEM_TAG_END;
                    item.widget = divider;
                    $menu.append(divider);
                    divider.data('item',item);

                } else if (typeof item.header !== 'undefined' && !item.widget) {
                    var header = item.vertical ? '<li class="divider-vertical' : '<li class="nav-header testClass';
                    header += (addDynamicTag) ? ' dynamic-menu-item' : '';
                    header += '">' + item.header + '</li>';
                    header = $(header);
                    item.widget = header;
                    $menu.append(header);
                    header.data('item',item);

                } else if (typeof item.menu_item_src !== 'undefined') {



                } else {

                    if (!widget && typeof item.target !== 'undefined') {
                        linkTarget = ' target="' + item.target + '"';
                    }

                    if (typeof item.subMenu !== 'undefined' && !widget) {
                        var sub_menu = ITEM_TAG_START + 'tabindex="-1" class="dropdown-submenu ' + ITEM_CLASS + this.containerClass;
                        sub_menu += (addDynamicTag) ? ' dynamic-menu-item' : '';
                        sub_menu += '"><a>';

                        if (typeof item.icon !== 'undefined') {
                            sub_menu += '<span class="icon ' + item.icon + '"></span> ';
                        }
                        sub_menu += item.text + '';
                        sub_menu += '</a>'+ITEM_TAG_END;
                        $sub = $(sub_menu);

                    } else {
                        if (!widget) {
                            if (item.render) {
                                $sub = item.render(item, $menu);
                            } else {
                                var element = ITEM_TAG_START + ' tabindex="-1" ';
                                element += (addDynamicTag) ? ' class="dynamic-menu-item"' : '';
                                element += '><a >';
                                if (typeof data[i].icon !== 'undefined') {
                                    element += '<span class="' + item.icon + '"></span> ';
                                }
                                element += item.text + '</a>' + ITEM_TAG_END;
                                $sub = $(element);
                                if (item.postRender) {
                                    item.postRender($sub);
                                }
                            }
                        }
                    }

                    if (typeof item.action !== 'undefined' && !item.widget) {
                        if (item.addClickHandler && item.addClickHandler() === false) {
                        } else {
                            var $action = item.action;
                            if ($sub && $sub.find) {
                                var trigger = $sub.find('a');
                                trigger.addClass('context-event');
                                var handler = createCallback($action, item, $sub);
                                trigger.data('handler',handler).on('click',handler);
                                //trigger.data('handler',handler).on('click',function(e){
                                    //return func(event, menu, item);
                                //});

                                /*
                                trigger.data('handler',handler).on('click',function(e){
                                    handler();
                                    var _parent = $sub.parent();
                                    _parent.data('open',false);
                                    _parent[0] && popup.close(_parent[0]);
                                });
                                */
                            }
                        }
                    }

                    if ($sub && !widget) {
                        item.widget = $sub;
                        $sub.menu = $menu;
                        $sub.data('item', item);
                        item.$menu = $menu;
                        item.$sub = $sub;
                        item._render = function () {
                            if (item.index === 0) {
                                this.$menu.prepend(this.$sub);
                            } else {
                                this.$menu.append(this.$sub);
                            }
                        };
                        if (!item.lazy) {
                            item._render();
                        }
                    }
                    if ($sub) {
                        $sub.attr('level', item.level);
                    }
                    if (typeof item.subMenu != 'undefined' && !item.subMenuData) {
                        var subMenuData = self.buildMenu(item.subMenu, id, true);
                        $menu.subMenuData = subMenuData;
                        item.subMenuData = subMenuData;
                        $menu.find(this.ITEM_TAG +':last').append(subMenuData);
                        subMenuData.attr('level', item.subMenu.level);
                        if (self.hideSubsFirst) {
                            subMenuData.css('display', 'none');
                        }
                        $menu.data('item', item);
                    } else {
                        if (item.subMenu && item.subMenuData) {
                            this.buildMenuItems(item.subMenuData, item.subMenu, id, true);
                        }
                    }
                }

                if (!$menu._didOnClick) {
                    $menu.on('click', '.dropdown-menu > li > input[type="checkbox"] ~ label, .dropdown-menu > li > input[type="checkbox"], .dropdown-menu.noclose > li', function (e) {
                        e.stopPropagation();
                    });
                    $menu._didOnClick = true;
                }

            }
            return $menu;
        },
        buildMenu: function (data, id, subMenu) {
            var subClass = (subMenu) ? (' dropdown-context-sub ' + this.containerClass ) : ' scrollable-menu ';
            var $menu = $('<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>');
            if (!subMenu) {
                this._rootMenu = $menu;
            }
            var result = this.buildMenuItems($menu, data, id, subMenu);
            $menu.data('data', data);
            return result;
        },
        createNewAction: function (command) {
            var segments = command.split('/');
            var lastSegment = segments[segments.length - 1];
            var action = new Action({
                command: command,
                label: lastSegment,
                group: lastSegment,
                dynamic: true
            });
            return action;
        },
        findAction: function (command) {
            var stores = this.actionStores,
                action = null;
            _.each(stores, function (store) {
                var _action = store ? store.getSync(command) : null;
                if (_action) {
                    action = _action;
                }
            });

            return action;
        },
        getAction: function (command, store) {
            store = store || this.store;
            var action = null;
            if (store) {
                action = this.findAction(command);
                if (!action) {
                    action = this.createNewAction(command);
                }
            }
            return action;
        },
        getActions: function (query) {
            var result = [];
            var stores = this.actionStores,
                visibility = this.visibility;

            query = query || this.actionFilter;
            _.each(stores, function (store) {
                store && (result = result.concat(store._find(query)));
                //store && (result2= result2.concat(store._find(query)));
            });
            result = result.filter(function (action) {
                var actionVisibility = action.getVisibility != null ? action.getVisibility(visibility) : {};
                return !(action.show === false || actionVisibility === false || actionVisibility.show === false);

            });

            return result;
        },
        toActions: function (commands, store) {
            var result = [],
                self = this;
            _.each(commands, function (path) {
                var _action = self.getAction(path, store);
                _action && result.push(_action);
            });
            return result;
        },
        onRunAction: function (action, owner, e) {
            var command = action.command;
            action = this.findAction(command);
            return DefaultActions.defaultHandler.apply(action.owner || owner, [action, e]);
        },
        getActionProperty: function (action, visibility, prop) {
            var value = prop in action ? action[prop] : null;
            if (visibility && prop in visibility) {
                value = visibility[prop];
            }
            return value;
        },
        toMenuItem: function (action, owner, label, icon, visibility, showKeyCombo, lazy) {
            var self = this,
                labelLocalized = self.localize(label),
                actionType = visibility.actionType || action.actionType;

            var ITEM_CLASS = this.ITEM_CLASS;
            var ITEM_TAG_START = '<' + this.ITEM_TAG + ' class="'+ ITEM_CLASS + '" ';
            var ITEM_TAG_END = '</' + this.ITEM_TAG + '>';

            var item = {
                text: labelLocalized,
                icon: icon,
                data: action,
                owner: owner,
                command: action.command,
                lazy: lazy,
                addClickHandler: function () {
                    return actionType !== types.ACTION_TYPE.MULTI_TOGGLE;

                },
                render: function (data, $menu) {
                    if (self.renderItem) {
                        return self.renderItem(this, data, $menu, this.data, owner, label, icon, visibility, showKeyCombo, lazy);
                    }
                    var action = this.data;
                    var parentAction = action.getParent ? action.getParent() : null;
                    var closeOnClick = self.getActionProperty(action, visibility, 'closeOnClick');
                    var keyComboString = ' \n';
                    var element = null;
                    if (action.keyboardMappings && showKeyCombo !== false) {
                        var mappings = action.keyboardMappings;
                        var keyCombos = mappings[0].keys;
                        if (keyCombos && keyCombos.length) {
                            keyComboString += '' + keyCombos.join(' | ').toUpperCase() + '';
                        }
                    }

                    if (actionType === types.ACTION_TYPE.MULTI_TOGGLE) {
                        element = ITEM_TAG_START + 'tabindex="-1" class="" >';
                        var id = action._store.id + '_' + action.command + '_' + self.id;
                        var checked = action.get('value');
                        //checkbox-circle
                        element += '<div class="action-checkbox checkbox checkbox-success ">';
                        element += '<input id="' + id + '" type="checkbox" ' + (checked === true ? 'checked' : '') + '>';
                        element += '<label for="' + id + '">';
                        element += self.localize(data.text);
                        element += '</label>';
                        element += '<span style="max-width:100px;margin-right:20px" class="text-muted pull-right ellipsis keyboardShortCut">' + keyComboString + '</span>';
                        element += ITEM_TAG_END;

                        $menu.addClass('noclose');
                        var result = $(element);
                        var checkBox = result.find('INPUT');
                        checkBox.on('change', function (e) {
                            action._originReference = data;
                            action._originEvent = e;
                            action.set('value', checkBox[0].checked);
                            action._originReference = null;
                        });
                        self.setVisibilityField(action, 'widget', data);
                        return result;
                    }
                    closeOnClick === false && $menu.addClass('noclose');
                    if (actionType === types.ACTION_TYPE.SINGLE_TOGGLE && parentAction) {
                        var value = action.value || action.get('value');
                        var parentValue = parentAction.get('value');
                        if (value == parentValue) {
                            icon = 'fa fa-check';
                        }
                    }

                    var title = data.text || labelLocalized || self.localize(action.title);

                    //default:
                    element = ITEM_TAG_START +  'class="'+ITEM_CLASS + '" ' +  'tabindex="-1"><a title="' + title + ' ' + keyComboString + '">';
                    var _icon = data.icon || icon;

                    //icon
                    if (typeof _icon !== 'undefined') {
                        //already html string
                        if (/<[a-z][\s\S]*>/i.test(_icon)) {
                            element += _icon;
                        } else {
                            element += '<span class="icon ' + _icon + '"/> ';
                        }
                    }
                    element += data.text;
                    element += '<span style="max-width:100px" class="text-muted pull-right ellipsis keyboardShortCut">' + (showKeyCombo ? keyComboString : "") + '</span></a>'+ITEM_TAG_END;
                    self.setVisibilityField(action, 'widget', data);
                    return $(element);
                },
                get: function (key) {
                },
                set: function (key, value) {
                    //_debugWidgets && _.isString(value) && console.log('set ' + key + ' ' + value);
                    var widget = this.widget;

                    function updateCheckbox(widget, checked) {
                        var what = widget.find("input[type=checkbox]");
                        if (what) {
                            if (checked) {
                                what.prop("checked", true);
                            } else {
                                what.removeAttr('checked');
                            }
                        }
                    }

                    if (widget) {
                        if (key === 'disabled') {
                            if (widget.toggleClass) {
                                widget.toggleClass('disabled', value);
                            }
                        }
                        if (key === 'icon') {
                            var _iconNode = widget.find('.icon');
                            if (_iconNode) {
                                _iconNode.attr('class', 'icon');
                                this._lastIcon = this.icon;
                                this.icon = value;
                                _iconNode.addClass(value);
                            }
                        }
                        if (key === 'value') {
                            if (actionType === types.ACTION_TYPE.MULTI_TOGGLE ||
                                actionType === types.ACTION_TYPE.SINGLE_TOGGLE) {
                                updateCheckbox(widget, value);
                            }
                        }
                    }
                },
                action: function (e, data, menu) {
                    return self.onRunAction(data.data, owner, e);
                },
                destroy: function () {
                    if (this.widget) {
                        this.widget.remove();
                    }
                }
            };
            return item;
        },
        attach: function (selector, data) {
            this.target = selector;
            this.menu = this.addContext(selector, data);
            this.domNode = this.menu[0];
            this.id = this.domNode.id;
            registry.add(this);
            return this.menu;
        },
        addReference: function (action, item) {
            if (action.addReference) {
                action.addReference(item, {
                    properties: {
                        "value": true,
                        "disabled": true,
                        "enabled": true
                    }
                }, true);
            }
        },
        onDidRenderActions: function (store, owner) {
            if (owner && owner.refreshActions) {
                owner.refreshActions();
            }
        },
        getActionData: function (action) {
            var actionVisibility = action.getVisibility != null ? action.getVisibility(this.visibility) : {};
            return {
                label: actionVisibility.label != null ? actionVisibility.label : action.label,
                icon: actionVisibility.icon != null ? actionVisibility.icon : action.icon,
                command: actionVisibility.command != null ? actionVisibility.command : action.command,
                visibility: actionVisibility,
                group: actionVisibility.group != null ? actionVisibility.group : action.group,
                tab: actionVisibility.tab != null ? actionVisibility.tab : action.tab,
                expand: actionVisibility.expand != null ? actionVisibility.expand : false,
                widget: actionVisibility.widget
            };
        },
        _clearAction: function (action) {

        },
        _findParentData: function (oldMenuData, parentCommand) {
            var parent = _.find(oldMenuData, {
                command: parentCommand
            });
            if (parent) {
                return parent;
            }
            for (var i = 0; i < oldMenuData.length; i++) {
                var data = oldMenuData[i];
                if (data.subMenu) {
                    var found = this._findParentData(data.subMenu, parentCommand);
                    if (found) {
                        return found;
                    }
                }
            }
            return null;
        },
        _clear: function () {
            var actions = this.getActions();
            var store = this.store;
            if (store) {
                this.actionStores.remove(store);
            }
            var self = this;
            actions = actions.concat(this._tmpActions);
            _.each(actions, function (action) {
                if (action) {
                    var actionVisibility = action.getVisibility != null ? action.getVisibility(self.visibility) : {};
                    if (actionVisibility) {
                        var widget = actionVisibility.widget;
                        action.removeReference && action.removeReference(widget);
                        if (widget && widget.destroy) {
                            widget.destroy();
                        }
                        delete actionVisibility.widget;
                        actionVisibility.widget = null;
                    }
                }
            });
            this.$navBar && this.$navBar.empty();
        },
        buildActionTree: function (store, owner) {
            var self = this,
                allActions = self.getActions(),
                visibility = self.visibility;

            self.wireStore(store, function (evt) {
                if (evt.type === 'update') {
                    var action = evt.target;
                    if (action.refreshReferences) {
                        action.refreshReferences(evt.property, evt.value);
                    }
                }
            });

            //return all actions with non-empty tab field
            var tabbedActions = allActions.filter(function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),

                //group all tabbed actions : { Home[actions], View[actions] }
                groupedTabs = _.groupBy(tabbedActions, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.tab || action.tab;
                    }
                }),
                //now flatten them
                _actionsFlattened = [];


            _.each(groupedTabs, function (items) {
                _actionsFlattened = _actionsFlattened.concat(items);
            });

            var rootActions = [];
            _.each(tabbedActions, function (action) {
                var rootCommand = action.getRoot();
                rootActions.indexOf(rootCommand) == -1 && rootActions.push(rootCommand);
            });

            //owner sort of top level
            store.menuOrder && (rootActions = owner.sortGroups(rootActions, store.menuOrder));

            var tree = {};
            //stats to count groups per tab
            var biggestTab = rootActions[0];
            var nbGroupsBiggest = 0;

            _.each(rootActions, function (level) {
                // collect all actions at level (File/View/...)
                var menuActions = owner.getItemsAtBranch(allActions, level);
                // convert action command strings to Action references
                var grouped = self.toActions(menuActions, store);

                // expand filter -------------------
                var addedExpanded = [];
                var toRemove = [];
                _.each(grouped, function (action) {
                    var actionData = self.getActionData(action);
                    if (actionData.expand) {
                        var children = action.getChildren();
                        children && children.length && (addedExpanded = addedExpanded.concat(children));
                        toRemove.push(action);
                    }
                });
                grouped = grouped.concat(addedExpanded);
                grouped = grouped.filter(function (action) {
                    return toRemove.indexOf(action) == -1;
                });
                // expand filter ---------------    end

                // group all actions by group
                var groupedActions = _.groupBy(grouped, function (action) {
                    var _vis = (action.visibility_ || {})[visibility + '_val'] || {};
                    if (action) {
                        return _vis.group || action.group;
                    }
                });

                var _actions = [];
                _.each(groupedActions, function (items, level) {
                    if (level !== 'undefined') {
                        _actions = _actions.concat(items);
                    }
                });

                //flatten out again
                menuActions = _.pluck(_actions, 'command');
                menuActions.grouped = groupedActions;
                tree[level] = menuActions;

                //update stats
                if (self.collapseSmallGroups) {
                    var nbGroups = _.keys(menuActions.grouped).length;
                    if (nbGroups > nbGroupsBiggest) {
                        nbGroupsBiggest = nbGroups;
                        biggestTab = level;
                    }
                }
            });

            //now move over any tab with less than 2 groups to the next bigger tab
            this.collapseSmallGroups && _.each(tree, function (actions, level) {
                if (_.keys(actions.grouped).length < self.collapseSmallGroups) {
                    //append tab groups of the biggest tab
                    tree[biggestTab] && _.each(actions.grouped, function (group, name) {
                        tree[biggestTab].grouped[name] = group;
                    });
                    //copy manually commands to that tab
                    tree[biggestTab] && _.each(actions, function (action) {
                        tree[biggestTab].push(action);
                    });
                    tree[biggestTab] && delete tree[level];
                }
            });
            var result = {
                root: tree,
                rootActions: rootActions,
                allActionPaths: _.pluck(allActions, 'command'),
                allActions: allActions
            };

            this.lastTree = result;
            return result;
        }
    });
    dcl.chainAfter(Module, 'destroy');
    return Module;
});



define('xide/widgets/_MenuKeyboard',[
    "dcl/dcl",
    "xide/$",
    "xide/lodash",
    "xide/mixins/EventedMixin"
], function (dcl, $, _, EventedMixin) {

    var skip = [
        '.divider',
        '.nav-header',
        '.disabled'
    ];

    var Module = dcl(EventedMixin.dcl, {
        owner: null,
        /**
         *
         * @param owner
         */
        setup: function (owner) {
            this.owner = owner;
        },
        /**
         * Return parent action container for an element
         * @param $el {jQuery}
         * @param $max {jQuery}
         * @param dataIdentifier {string} The data identifier to find some object in $el
         * @returns {jQuery|null}
         */
        findNavigationContainerElement: function ($el, $max, dataIdentifier) {
            if (!$el || !$el[0]) {
                return null;
            }
            if ($el && $max && $el[0] == $max[0]) {
                return $el;
            }

            var data = $el.data(dataIdentifier || 'data');
            if (data && data != null) {
                return $el;
            }
            return this.findNavigationContainerElement($el.parent(), $max, dataIdentifier);
        },
        /**
         *
         * @param $el
         * @param $max
         * @param dataIdentifier
         * @returns {jQuery|null}
         */
        findNavigationElement: function ($el, $max, dataIdentifier) {
            if (!$el || !$el[0]) {
                return null;
            }
            if ($el && $max && $el[0] == $max[0]) {
                return $el;
            }
            var data = $el.data(dataIdentifier || 'item') || $el.data(dataIdentifier || 'data');
            if (data && !_.isEmpty(data)) {
                return $el;
            }
            return this.findNavigationElement($el.parent());
        },
        /**
         *
         * @param $el {jQuery}
         * @param $max {jQuery}
         * @param dataIdentifier {string} The data identifier to find some object in $el
         * @param findParent
         * @returns {{element: Object, data: (*|{}), parent: *}}
         */
        toNavigationData: function ($el, $max, dataIdentifier, findParent) {
            var element = this.findNavigationElement($el, $max, dataIdentifier);
            if (element) {
                var data = element.data(dataIdentifier || 'item') || element.data(dataIdentifier || 'data');
                if (data) {
                    return {
                        element: element,
                        data: data,
                        parent: findParent !== false ? this.findNavigationContainerElement($el, $max, dataIdentifier) : null
                    };
                }
            }
        },
        /**
         *
         * @param $parent
         * @param $origin
         * @param direction
         * @returns {*}
         */
        next: function ($parent, $origin, direction) {
            if ($origin) {
                var result = $origin[direction == 1 ? 'next' : 'prev']();
                if (!this.canSelect(result)) {
                    return this.next($parent, result, direction);
                } else {
                    return result;
                }
            }
        },
        /**
         * Return valid children
         * @param $el{jQuery}
         * @returns {*}
         */
        canSelect: function ($el) {
            return $($el).is(skip.join(',')) == false;
        },
        /**
         *
         * @param $parent{jQuery}
         * @param all {boolean}
         * @returns {HTMLElement[]}
         */
        children: function ($parent, all) {
            var self = this;
            return $parent.children('LI').filter(function (i, child) {
                if (all !== true) {
                    return self.canSelect(child);
                } else {
                    return child;
                }
            });
        },
        /**
         *
         * @param $el {jQuery}
         */
        close: function ($el) {
            var _parent = $el.parent();
            var _parentParent = $el.parent().parent();
            _parent.css('display', '');
            _parent.removeClass('open');
            $el.removeClass('open');
            $el.removeClass('focus');
            $el.removeClass('active');
            _parentParent.removeClass('open');
            _parentParent.focus();
        },
        /**
         * Opens the very root menu by a given origin
         * @param $el
         * @param $next
         * @param direction {init} left = -1, right = 1
         * @returns {*}
         */
        openRoot: function ($el, $next, direction) {
            var _next = $next || this.topMost($el).parent()[direction === -1 ? 'prev' : 'next']();
            var _trigger = $(_next.find('A')[0]);
            _trigger.trigger('click');
            var _navData = this.toNavigationData($(_next.find('UL')[0]), this.owner.getRootContainer());
            if (_navData) {
                return this.activate($(this.children(_navData.element)[0]), _navData.element, true);
            }

        },
        destroy: function () {
            delete this.owner;
        },
        /**
         *
         * @param $el {jQuery}
         */
        open: function ($el) {
            $el.css('display', 'block');
            var _navData = this.toNavigationData($el, this.owner.getRootContainer(), 'data', null, null);
            var firstInner = this.children(_navData.parent)[0];
            if (firstInner) {
                _navData = this.toNavigationData($(firstInner), this.owner.getRootContainer());
                this.activate(_navData.element, _navData.parent, true);
            }
        },
        topMost: function ($el) {
            if ($el) {
                var data = $el.data();
                if (data.item || data.data) {
                    var next = $el.parent();
                    var parentData = next.data();
                    if (next && next[0] && (parentData.item || parentData.data)) {
                        return this.topMost(next);
                    }
                    return $el;
                }
            }
        },
        keyboardHandler: function (event, $parent) {
            var origin = $parent.data('currentTarget');
            if (event.keyCode === 13) {
                var trigger = origin.find("A");
                var handler = trigger.data('handler');
                if (handler) {
                    var actionResult = handler();
                    if (actionResult && actionResult.then) {
                        actionResult.then(function () {
                            origin.focus();
                        });
                    }
                    return;
                }
                //perform action
                origin.find("A").click();
                origin.focus();
                return;
            }

            var vertical = event.keyCode == 38 || event.keyCode == 40 || event.keyCode == 36 || event.keyCode == 35;
            var horizontal = event.keyCode == 37 || event.keyCode == 39;
            var direction = vertical ? (event.keyCode == 38 || event.keyCode == 36) ? -1 : 1 : (event.keyCode == 37 ? -1 : 1 );
            var max = !!(event.keyCode == 36 || event.keyCode == 35 );

            var nextElement = null;
            var nextData = {};
            var navData = null;
            if (vertical) {
                nextElement = max ? direction == 1 ? $(_.last(this.children($parent))) : $(_.first(this.children($parent))) : this.next($parent, origin, direction);
                nextElement && (nextData = nextElement.data('item'));
            }
            if (horizontal) {
                var data = origin.data('item');
                if (data) {
                    if (direction > 0) {
                        //sub - items?, open them
                        if (data.subMenuData) {
                            var isOpen = data.subMenuData.css('display') === 'block';
                            if (!isOpen) {
                                return this.open(data.subMenuData);
                            } else {
                                //root bounce
                                if (this.openRoot(origin, null, 1)) {
                                    return;
                                }
                            }
                        } else {
                            //root bounce
                            if (this.openRoot(origin, null, 1)) {
                                return;
                            }
                        }
                    } else {
                        //left
                        this.close(origin);
                        navData = this.toNavigationData(origin, this.owner.getRootContainer());
                        //root bounce
                        if (_.isEmpty(navData.parent.parent().data())) {
                            return this.openRoot(origin, null, -1);
                        }
                        return;
                    }
                }
            }
            if (nextElement && nextData) {
                navData = this.toNavigationData(nextElement, this.owner.getRootContainer());
                this.activate(navData.element, navData.parent, true);
            }
        },
        initContainer: function ($container) {
            var self = this;
            if (!$container.data('didSetup')) {
                $container.data('didSetup', true);
                this.__on($container, 'keydown', null, function (evt) {
                    if (($(evt.target).parent()[0] == $container[0])) {
                        self.keyboardHandler(evt, $container);
                    }
                });
            }
        },
        activate: function ($next, $parent, clear) {
            if ($parent) {
                this.initContainer($parent);
            }
            if (clear && $parent) {
                this.children($parent, true).each(function (i, c) {
                    $(c).removeClass('focus');
                    $(c).removeClass('open');
                    $(c).removeClass('active');
                    var _s = $(c).find('.dropdown-context-sub');
                    if (_s[0] && _s.css('display') === 'block') {
                        _s.css('display', '');
                        _s.removeClass('open');
                        _s.removeClass('active');
                    }
                });
            }
            $next.addClass('focus');
            $next.addClass('active');
            $next.focus();
            $parent.addClass('open');
            $parent.data('currentTarget', $next);
            return true;
        },
        clear: function ($parent) {
            this.children($parent, true).each(function (i, c) {
                $(c).removeClass('focus');
                $(c).removeClass('open');
                $(c).removeClass('active');
                var _s = $(c).find('.dropdown-context-sub');
                if (_s[0] && _s.css('display') === 'block') {
                    _s.css('display', '');
                    _s.removeClass('open');
                }
            });
        }
    });
    return Module;
});
define('xide/widgets/ContextMenu',[
    'dcl/dcl',
    'xide/types',
    'xlang/i18',
    "xide/widgets/_Widget",
    'xide/_base/_Widget',
    "xide/mixins/ActionMixin",
    'xaction/ActionContext',
    "xide/widgets/_MenuMixin4",
    "xide/model/Path",
    "xide/_Popup",
    "xide/$",
    "xide/lodash",
    "xide/widgets/_MenuKeyboard"
], function (dcl, types, i18, _Widget, _XWidget, ActionMixin, ActionContext, MenuMixinClass, Path, _Popup, $, _, _MenuKeyboard) {
    var ActionRendererClass = dcl(null, {
        renderTopLevel: function (name, where) {
            where = where || $(this.getRootContainer());
            var item = $('<li class="dropdown">' +
                '<a href="#" class="dropdown-toggle" data-toggle="dropdown">' + i18.localize(name) + '<b class="caret"></b></a>' +
                '</li>');
            where.append(item);
            return item;

        },
        getRootContainer: function () {
            return this.navBar;
        }
    });
    var _debugTree = false;
    var _debugMenuData = false;
    var _debugOldMenuData = false;
    var KeyboardControl = _MenuKeyboard;

    var ContextMenu = dcl([_Widget.dcl, ActionContext.dcl, ActionMixin.dcl, ActionRendererClass, MenuMixinClass, _XWidget.StoreMixin], {
        target: null,
        openTarget: null,
        visibility: types.ACTION_VISIBILITY.CONTEXT_MENU,
        correctSubMenu: true,
        limitTo: null,
        declaredClass: 'xide.widgets.ContextMenu',
        menuData: null,
        addContext: function (selector, data) {
            this.menuData = data;
            var id,
                $menu,
                self = this,
                target = this.openTarget ? this.openTarget : $(self.target);

            if (typeof data.id !== 'undefined' && typeof data.data !== 'undefined') {
                id = data.id;
                $menu = $('body').find('#dropdown-' + id)[0];
                if (typeof $menu === 'undefined') {
                    $menu = self.buildMenu(data.data, id);
                    selector.append($menu);
                }
            } else {
                var d = new Date();
                id = d.getTime();
                $menu = self.buildMenu(data, id);
                selector.append($menu);
            }

            var options = this.getDefaultOptions();

            this.keyboardController = new KeyboardControl();
            this.keyboardController.setup(this);

            function mouseEnterHandlerSubs(e) {
                var navigationData = this.keyboardController.toNavigationData($(e.target), this.getRootContainer());
                if (!navigationData) {
                    return;
                }
                this.keyboardController.clear(navigationData.parent);
                this.menu.focus();
                navigationData.element.focus();
                this.menu.data('currentTarget', navigationData.element);

            }

            function setupContainer($container) {
                self.__on($container, 'mouseenter', 'LI', mouseEnterHandlerSubs.bind(self));
            }

            function constextMenuHandler(e) {
                if (self.limitTo) {
                    var $target = $(e.target);
                    $target = $target.parent();
                    if (!$target.hasClass(self.limitTo)) {
                        return;
                    }
                }
                self.openEvent = e;
                self.isOpen = true;
                this.lastFocused = document.activeElement;
                self.onOpen(e);
                e.preventDefault();
                e.stopPropagation();
                $('.dropdown-context:not(.dropdown-context-sub)').hide();

                var $dd = $('#dropdown-' + id);
                $dd.css('zIndex', _Popup.nextZ(1));
                if (!$dd.data('init')) {
                    $dd.data('init', true);
                    setupContainer($dd);
                    self.keyboardController.initContainer($dd);
                }

                if (typeof options.above == 'boolean' && options.above) {
                    $dd.css({
                        top: e.pageY - 20 - $('#dropdown-' + id).height(),
                        left: e.pageX - 13
                    }).fadeIn(options.fadeSpeed);

                } else if (typeof options.above == 'string' && options.above == 'auto') {
                    $dd.removeClass('dropdown-context-up');
                    var autoH = $dd.height() + 0;
                    if ((e.pageY + autoH) > $('html').height()) {
                        var top = e.pageY - 20 - autoH;
                        if (top < 0) {
                            top = 20;
                        }
                        $dd.css({
                            top: top + 20,
                            left: e.pageX - 13
                        }).fadeIn(options.fadeSpeed);

                    } else {
                        $dd.css({
                            top: e.pageY - 10,
                            left: e.pageX - 13
                        }).fadeIn(options.fadeSpeed);
                    }
                }

                if (typeof options.left == 'boolean' && options.left) {
                    $dd.addClass('dropdown-context-left').css({
                        left: e.pageX - $dd.width()
                    }).fadeIn(options.fadeSpeed);
                } else if (typeof options.left == 'string' && options.left == 'auto') {
                    $dd.removeClass('dropdown-context-left');
                    var autoL = $dd.width() - 12;
                    if ((e.pageX + autoL) > $('html').width()) {
                        $dd.addClass('dropdown-context-left').css({
                            left: e.pageX - $dd.width() + 13
                        });
                    }
                }
                this.keyboardController.activate($(this.keyboardController.children($dd)[0]), $dd);
            }

            this.__on(target, 'contextmenu', null, constextMenuHandler.bind(this));

            this.__on($menu, 'keydown', function (e) {
                if (e.keyCode == 27) {
                    var navData = this.keyboardController.toNavigationData($(e.target), this.getRootContainer());
                    navData && navData.element && this.keyboardController.close(navData.element);
                    $(this.lastFocused).focus();
                }
            }.bind(this));

            return $menu;
        },
        onRootAction: function () {
            return null;
        },
        buildMenu: function (data, id, subMenu, update) {
            var subClass = (subMenu) ? ' dropdown-context-sub' : ' scrollable-menu ',
                menuString = '<ul tabindex="-1" aria-expanded="true" role="menu" class="dropdown-menu dropdown-context' + subClass + '" id="dropdown-' + id + '"></ul>',
                $menu = update ? (this._rootMenu || $(menuString)) : $(menuString);

            if (!subMenu) {
                this._rootMenu = $menu;
                this._rootMenu.addClass('contextMenu')
            }
            $menu.data('data', data);
            return this.buildMenuItems($menu, data, id, subMenu);
        },
        onActionAdded: function (actions) {
            this.setActionStore(this.getActionStore(), this, false, true, actions);
        },
        clearAction: function (action) {
            var self = this;
            if (action) {
                var actionVisibility = action.getVisibility !== null ? action.getVisibility(self.visibility) : {};
                if (actionVisibility) {
                    var widget = actionVisibility.widget;
                    action.removeReference && action.removeReference(widget);
                    if (widget && widget.destroy) {
                        widget.destroy();
                    }
                    delete actionVisibility.widget;
                    actionVisibility.widget = null;
                }
            }
        },
        onActionRemoved: function (evt) {
            this.clearAction(evt.target);
        },
        removeCustomActions: function () {
            var oldStore = this.store;
            if (!oldStore) {
                console.warn('removeCustomActions : have no store');
                return;
            }
            var oldActions = oldStore._find({
                custom: true
            });
            var menuData = this.menuData;
            _.each(oldActions, function (action) {
                oldStore.removeSync(action.command);
                var oldMenuItem = _.find(menuData, {
                    command: action.command
                });
                oldMenuItem && menuData.remove(oldMenuItem);
            });
        },
        setActionStore: function (store, owner, subscribe, update, itemActions) {
            if (!update) {
                if(this.store==store){
                    return;
                }
                this._clear();
                this.addActionStore(store);
            }

            var self = this,
                visibility = self.visibility,
                rootContainer = $(self.getRootContainer());

            this.store = store;
            if(!store){
                return;
            }
            var tree = update ? self.lastTree : self.buildActionTree(store, owner);
            var allActions = tree.allActions,
                rootActions = tree.rootActions,
                allActionPaths = tree.allActionPaths,
                oldMenuData = self.menuData;
            var data = [];
            if (subscribe !== false) {
                if (!this['_handleAdded_' + store.id]) {
                    this.addHandle('added', store._on('onActionsAdded', function (actions) {
                        self.onActionAdded(actions);
                    }));

                    this.addHandle('delete', store.on('delete', function (evt) {
                        self.onActionRemoved(evt);
                    }));
                    this['_handleAdded_' + store.id] = true;
                }
            }
            if (!update) {
                _.each(tree.root, function (menuActions, level) {
                    var root = self.onRootAction(level, rootContainer),
                        lastGroup = '',
                        lastHeader = {
                            header: ''
                        },
                        groupedActions = menuActions.grouped;

                    _.each(menuActions, function (command) {
                        var action = self.getAction(command, store),
                            isDynamicAction = false;

                        if (!action) {
                            isDynamicAction = true;
                            action = self.createAction(command);
                        }
                        if (action) {
                            var renderData = self.getActionData(action);
                            var icon = renderData.icon,
                                label = renderData.label,
                                visibility = renderData.visibility,
                                group = renderData.group;

                            if (visibility.widget) {
                                return;
                            }
                            if (!isDynamicAction && group && groupedActions[group] && groupedActions[group].length >= 1) {
                                if (lastGroup !== group) {
                                    var name = groupedActions[group].length >= 2 ? i18.localize(group) : "";
                                    lastHeader = {header: name};
                                    data.push(lastHeader);
                                    lastGroup = group;
                                }
                            }
                            var item = self.toMenuItem(action, owner, label, icon, visibility || {}, true);
                            data.push(item);
                            visibility.widget = item;
                            self.addReference(action, item);
                            function parseChildren(command, parent) {
                                var childPaths = new Path(command).getChildren(allActionPaths, false),
                                    isContainer = childPaths.length > 0,
                                    childActions = isContainer ? self.toActions(childPaths, store) : null;
                                if (childActions) {
                                    var subs = [];
                                    _.each(childActions, function (child) {
                                        var _renderData = self.getActionData(child);
                                        var _item = self.toMenuItem(child, owner, _renderData.label, _renderData.icon, _renderData.visibility, true);
                                        self.addReference(child, _item);
                                        subs.push(_item);

                                        var _childPaths = new Path(child.command).getChildren(allActionPaths, false),
                                            _isContainer = _childPaths.length > 0;
                                        if (_isContainer) {
                                            parseChildren(child.command, _item);
                                        }
                                    });
                                    parent.subMenu = subs;
                                }
                            }
                            parseChildren(command, item);
                        }
                    });
                });
                self.attach($('body'), data);
                self.onDidRenderActions(store, owner);
            } else {
                if (itemActions || !_.isEmpty(itemActions)) {
                    _.each(itemActions, function (newAction) {
                        if (newAction) {
                            var action = self.getAction(newAction.command);
                            if (action) {
                                var renderData = self.getActionData(action),
                                    icon = renderData.icon,
                                    label = renderData.label,
                                    aVisibility = renderData.visibility,
                                    group = renderData.group,
                                    item = self.toMenuItem(action, owner, label, icon, aVisibility || {}, null, false);

                                aVisibility.widget = item;

                                self.addReference(newAction, item);

                                var parentCommand = action.getParentCommand();
                                var parent = self._findParentData(oldMenuData, parentCommand);
                                if (parent && parent.subMenu) {
                                    parent.lazy = true;
                                    parent.subMenu.push(item);
                                } else {
                                    oldMenuData.splice(0, 0, item);
                                }
                            } else {
                                console.error('cant find action ' + newAction.command);
                            }
                        }
                    });
                    self.buildMenu(oldMenuData, self.id, null, update);
                }
            }
        }
    });
    return ContextMenu;
});
/** @module xDocker/Docker2 */
define('xdocker/Docker2',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'wcDocker/docker',
    'xdocker/Panel2',
    'xdocker/Frame2',
    'xdocker/Splitter2',
    'xide/mixins/EventedMixin',
    'xide/registry',
    'wcDocker/types',
    'wcDocker/base',
    'xaction/ActionProvider',
    'xide/widgets/_Widget',
    'xide/widgets/ContextMenu',
    'require'
], function (dcl,types,utils,wcDocker,Panel2,Frame2,Splitter2,EventedMixin,registry,dTypes,base,ActionProvider,_CWidget,ContextMenu,require) {
    /**
     * @class module:xDocker/Docker2
     * @extends module:wcDocker/docker
     */
    var Module = dcl([wcDocker,base,ActionProvider.dcl,_CWidget.dcl,EventedMixin.dcl],{
        isResizing:false,
        _last:null,
        _lastResize:null,
        _needResize:false,
        _lastResizeTimer:null,
        _declaredClass:'xdocker.Docker2',
        __eventHandles:[],
        contextMenu:null,
        contextMenuEventTarget:null,
        contextMenuPanelId:null,
        setupActions:function(_mixin){
            this.__on(this._root.$container,'contextmenu', '.wcPanelTab', function(e){
                self.contextMenuEventTarget  = e.target;
                self.contextMenuPanelId = e.target.parentNode ?  e.target.parentNode.id : null;
            });

            var self = this,
                //default action mixin
                mixin = {
                    addPermission: true
                },
                defaultProps = {
                    group:'Misc',
                    tab:'View',
                    mixin:_mixin || mixin
                },
                _actions = [],
                action = function(label,command,icon){
                    return self.createAction(_.extend({
                        label:label,
                        command:command,
                        icon:icon
                    },defaultProps));
                },
                actions = this.addActions([
                    action('Close','View/Close','fa-close'),
                    action('Close others','View/Close Others','fa-close'),
                    action('Close all in group','View/Close all group','fa-close'),
                    action('Split Horizontal','View/Split Horizontal','fa-columns'),
                    action('Split Vertical','View/Split Vertical','fa-columns')]
                ),
                node = this._root.$container[0],
                contextMenu = new ContextMenu({
                    owner:this,
                    delegate:this,
                    limitTo:'wcPanelTab',
                    openTarget:node
                },node);

            contextMenu.init({preventDoubleContext: false});
            contextMenu.setActionEmitter(this,types.EVENTS.ON_VIEW_SHOW,this);
            this.contextMenu = contextMenu;
            this.add(contextMenu,null,false);

            return actions;
        },
        runAction:function(action,type,event){

            var DOCKER_TYPES = types.DOCKER,
                _panel = this.contextMenuEventTarget ? this.__panel(this.contextMenuEventTarget) : null,
                self = this,
                frame = _panel ? _panel.getFrame(): null,
                panels = frame ? frame.panels() : null;

            if(action.command ==='View/Close') {
                if (_panel) {
                    this.removePanel(_panel);
                }
            }

            if(action.command ==='View/Close all group' && _panel) {
                if(frame){
                    var toRemove = [];
                    _.each(panels,function(panel){
                        if(panel && panel._moveable && panel._closeable){
                            toRemove.push(panel);
                        }
                    });
                    _.each(toRemove,function(panel){
                        self.removePanel(panel);
                    })
                }

            }
            if(action.command ==='View/Close Others' && _panel) {
                frame && _.each(panels,function(panel){
                        if(panel && panel!=_panel  && panel._moveable && panel._closeable){
                            self.removePanel(panel);
                        }
                    });

                _panel.select();
            }

            function split(direction){
                var otherPanel = _panel.next(-1) || _panel.next(1);
                if(otherPanel && _panel !=otherPanel){

                    self.movePanel(otherPanel,direction == DOCKER_TYPES.ORIENTATION.HORIZONTAL ?
                        DOCKER_TYPES.DOCK.BOTTOM : DOCKER_TYPES.DOCK.RIGHT,_panel,direction);

                    var splitter = otherPanel.getSplitter();
                    splitter && splitter.pos(0.5);
                }
            }

            if(action.command ==='View/Split Horizontal' && _panel) {
                split(DOCKER_TYPES.ORIENTATION.HORIZONTAL);
            }
            if(action.command ==='View/Split Vertical' && _panel) {
                split(DOCKER_TYPES.ORIENTATION.VERTICAL);
            }
        },
        __panel:function(el){

            var panels = this.getPanels();
            var frame = null,
                self = this;

            _.each(this._frameList,function(_frame){
                if($.contains(_frame.$container[0],el)){
                    frame = _frame;
                }
            });

            var id = self.contextMenuPanelId;
            this.contextMenuEventTarget = null;
            this.contextMenuPanelId = null;
            if(frame && id!==null){
                var _panel = frame.panel(id);
                if(_panel){
                    return _panel;
                }
            }
        },
        /**********************************************************************/
        allPanels:function(){
            var result = [];
            _.each(this._frameList,function(frame){
                _.each(frame._panelList,function(panel){
                    result.push(panel);
                });
            });
            return result;
        },
        destroy:function(){
            registry.remove(this.id);
            this.__destroy();
        },
        /**
         * Collect wcDocker's body event handles
         * @param element {HTMLElement}
         * @param type {string} event type
         * @param selector {string|null|function}
         * @param handler {function|null}
         * @private
         */
        __on:function(element,type,selector,handler){

            if(typeof selector =='function' && !handler){
                //no selector given, swap arg[3] with arg[2]
                handler = selector;
                selector = null;
            }

            element.on(type,selector,handler);

            this.__eventHandles.push({
                element:element,
                type:type,
                selector:selector,
                handler:handler
            });
        },
        __destroy:function(){
            var self = this;
            //docker handles
            _.each(self.__eventHandles,function(handle){
                handle && handle.element && handle.element.off(handle.type,handle.selector,handle.handler);
                self.__eventHandles.remove(handle);
            });

            //xide handles
            _.each(self._events,function(handles,type){
                _.each(handles,function(handler){
                    self.off(type,handler);
                });
            });

            self.clear();
            delete self._events;
            delete self.__eventHandles;
            self._updateId && clearTimeout(self._updateId);
        },
        resize: function (force,noob,why) {
            if(why==='deselected'){
                return;
            }
            var self = this;
            function _resize(){
                if(self.$container) {
                    var h = self.$container.height();
                    var w = self.$container.width();
                    if(h<110 || w<110){
                        return;
                    }
                }
                self._dirty = true;
                self._root && self._root.__update(true);
                _.invoke(self._floatingList,'__update');
            }
            return this.debounce('resize',_resize.bind(this),100,null);
        },
        /**
         * Helper
         * @returns {xdocker/Panel[]}
         */
        getPanels:function(){
            var result = [];
            _.each(this._frameList,function(frame){
                _.each(frame._panelList,function(panel){
                    result.push(panel);
                });
            });
            return result;
        },
        /**
         * Returns a default panel
         * @returns {xdocker/Panel}
         */
        getDefaultPanel:function(){
            return _.find(this.getPanels(),{
                isDefault:true
            });
        },
        /**
         * Std API
         * @todo convert to addChild
         * @param mixed {string|object}
         * @param options {object}
         * @param options.title {string|null}
         * @param options.tabOrientation {string|null}
         * @param options.location {string|null}
         * @param options.select {boolean}
         * @param options.target {object}
         * @returns {*}
         */
        addTab: function (mixed, options) {

            var panel = null,
                thiz = this;

            options = options || {};
            mixed = mixed || 'DefaultTab';

            /**
             * Complete options to default
             * @param options
             */
            function completeOptions(options) {

                if (!('tabOrientation' in options)) {
                    options.tabOrientation = types.DOCKER.TAB.TOP
                }

                if (!('location' in options)) {
                    options.location = types.DOCKER.DOCK.STACKED;
                }

                if (!('target' in options)) {
                    options.target = thiz.getDefaultPanel();
                }

                if (!('select' in options)) {
                    options.select = true;
                }

                if (!('title' in options)) {
                    options.title = ' ';
                }
            }
            completeOptions(options);

            if (_.isString(mixed)) {
                panel = this.addPanel(mixed, options.location, options.target, options);
            } else if (_.isObject(mixed)) {
                panel = mixed;
            }
            function applyOptions(who, what) {
                for (var option in what) {
                    if (_.isFunction(who[option])) {
                        who[option](what[option]);
                    }
                }
            }
            applyOptions(panel, options);
            if (options.select === true) {
                panel.select();
            }
            return panel;
        }
    });
    /**
     * Registration of a panel type
     * @todo typos & API
     * @static
     * @param label
     * @param iconClass
     * @param closable
     * @param collapsible
     * @param movable
     * @param onCreate
     * @returns {{faicon: *, closeable: *, title: *, onCreate: Function}}
     */
    Module.defaultPaneType = function (label, iconClass, closable, collapsible, moveable, onCreate,isPrivate) {

        return {
            isPrivate: isPrivate!==null ? isPrivate : false,
            faicon: iconClass,
            closeable: closable,
            title: label,
            moveable:moveable,
            onCreate: function (panel, options) {

                var docker = panel.docker();

                utils.mixin(panel._options,options);

                panel.on(wcDocker.EVENT.ATTACHED,function(){
                    docker._emit(wcDocker.EVENT.ATTACHED,panel);
                });

                panel.on(wcDocker.EVENT.DETACHED,function(){
                    docker._emit(wcDocker.EVENT.DETACHED,panel);
                });

                panel.on(wcDocker.EVENT.CLOSED,function(){
                    docker._emit(wcDocker.EVENT.CLOSED,panel);
                });

                if (closable !== null) {
                    panel.closeable(closable);
                }

                if (collapsible !== null && panel.collapsible) {
                    panel.collapsible(collapsible);
                }

                if (moveable !== null) {
                    panel.moveable(moveable);
                }

                if (options) {
                    panel.title(options.title);
                    if (options.closeable) {
                        panel.closeable(options.closeable);
                    }
                }

                var parent = $('<div style="height: 100%;width: 100%;overflow: hidden;" class="panelParent"/>');
                panel.layout().addItem(parent).stretch('100%', '100%');
                panel.containerNode = parent[0];
                utils.mixin(panel,options.mixin);

                function resize(panel,parent,why){
                    var extraH = 0;

                    var resizeToChildren = panel.resizeToChildren;
                    panel.onResize && panel.onResize();
                    if(resizeToChildren){
                        var totalHeight = utils.getHeight(panel._findWidgets()),
                            panelParent = panel._parent.$container;

                        extraH = panelParent.outerHeight() - panelParent.height();
                        if(extraH){
                            totalHeight+=extraH;
                        }
                        parent.css('width', panel._actualSize.x + 'px');
                        panel.set('height',totalHeight);

                    }else {
                        parent.css('height', panel._actualSize.y + 'px');
                        parent.css('width', panel._actualSize.x + 'px');
                        //transfer size and resize on widgets
                        _.each(panel.containerNode.children, function (child) {
                            if (child.id) {

                                var _widget = registry.byId(child.id);
                                var doResize = true;
                                if (_widget && _widget.resizeToParent === false) {
                                    doResize = false;
                                }

                                if (doResize) {
                                    //update
                                    $(child).css('height', panel._actualSize.y - extraH + 'px');
                                    $(child).css('width', panel._actualSize.x + 'px');
                                }
                                if (_widget) {
                                    _widget.resize && _widget.resize(null, null, why);
                                } else {
                                    console.warn('cant get widget : ' + child.id);
                                }
                            }
                        });
                    }
                }


                function select(selected,reason){
                    //console.log(reason + ' : select ' +panel.title() +' selected:'+ selected + ' visible:' + panel.isVisible() + ' p#selected:' + panel.selected + ' __isVisible'+panel.isVisible());

                    if(panel.selected && selected){
                        return true;
                    }
                    panel.selected = selected;
                    selected && (docker._lastSelected = panel);
                    resize(panel,parent,selected ?  'selected' : 'deselected');

                    var apiMethod = selected ? 'onShow'  : 'onHide';
                    panel[apiMethod] && panel[apiMethod]();




                    //tell widgets
                    _.each(panel._findWidgets(), function (widget) {
                        if(!widget){
                            return;
                        }
                        if(selected){
                            if(!widget._started){
                                widget.startup && widget.startup();
                            }
                        }
                        //call std API
                        if (widget[apiMethod]) {
                            widget[apiMethod]();
                        }
                        //forward
                        if (widget._emit) {
                            widget._emit(selected ? types.EVENTS.ON_VIEW_SHOW :types.EVENTS.ON_VIEW_HIDE , widget);
                        }

                        //forward
                        if (widget.setFocused) {
                            widget.setFocused(selected);
                        }
                    });
                }

                panel.on(types.DOCKER.EVENT.VISIBILITY_CHANGED, function (visible) {
                    panel.silent!==true && select(visible,'vis changed');
                });
                panel._on(types.DOCKER.EVENT.SELECT, function (what) {
                    panel.silent!==true && select(true,'select');

                });

                panel._on(types.DOCKER.EVENT.MOVE_STARTED, function () {
                    docker.trigger(types.DOCKER.EVENT.MOVE_STARTED,panel);
                });

                panel._on(types.DOCKER.EVENT.MOVE_ENDED, function () {
                    docker.trigger(types.DOCKER.EVENT.MOVE_ENDED,panel);
                });

                panel.on(types.DOCKER.EVENT.SAVE_LAYOUT, function (customData) {


                    panel.onSaveLayout({
                        data:customData,
                        panel:panel
                    });

                    if(!customData.widgets){
                        customData.widgets = [];
                    }

                    _.each(panel._findWidgets(),function(w){
                        if(!w){
                            console.warn('SAVE_LAYOUT : invalid widget');
                            return;
                        }
                        w._emit && w._emit(types.EVENTS.SAVE_LAYOUT,{
                            panel:panel,
                            data:customData
                        });
                        w.onSaveLayout && w.onSaveLayout({
                            data:customData,
                            owner:panel
                        })
                    });
                });
                panel.on(types.DOCKER.EVENT.RESTORE_LAYOUT, function (customData) {
                    
                    var eventData = {
                        data:customData,
                        panel:panel
                    };
                    panel.onRestoreLayout(eventData);
                    //console.log('restore layout');
                    //docker.trigger('restorePanel',eventData);
                });

                panel.on(types.DOCKER.EVENT.RESIZE_STARTED, function () {
                    panel.onResizeBegin(arguments);
                    docker.trigger(types.DOCKER.EVENT.BEGIN_RESIZE,panel);
                });
                panel.on(types.DOCKER.EVENT.RESIZE_ENDED, function () {
                    panel.onResizeEnd(arguments);
                    resize(panel,parent);
                    docker.trigger(types.DOCKER.EVENT.END_RESIZE,panel);
                });
                panel.on(types.DOCKER.EVENT.RESIZED, function () {
                    resize(panel,parent);
                });
                utils.mixin(panel,options.mixin);

                if (onCreate) {
                    onCreate(panel);
                }
            }
        }
    };
    /**
     * Register default panel types on docker
     * @static
     * @param docker
     */
    Module.registerDefaultTypes = function(docker){
        docker.registerPanelType('DefaultFixed',Module.defaultPaneType('','',false,false,true,null,true));
        docker.registerPanelType('DefaultTab',Module.defaultPaneType('','',true,false,true,null,true));
        docker.registerPanelType('Collapsible',Module.defaultPaneType('','',false,true,true,null,true));
    };

    /**
     * Creates a default docker
     * @static
     * @param container
     * @param options
     */
    Module.createDefault=function(container,options){
        require({cacheBust: null});
        options = options || {};

        //get or create new docker variant
        var _class = Module;
        options.extension && ( _class = dcl([Module,options.extension],{}));
        var docker = new _class($(container),utils.mixin({
            allowCollapse: true,
            responseRate: 100,
            allowContextMenu: false,
            themePath: require.toUrl('xdocker') + '/Themes/',
            theme: 'transparent2',
            wcPanelClass:Panel2,
            wcFrameClass:Frame2,
            wcSplitterClass:Splitter2
        },options || {}));

        Module.registerDefaultTypes(docker);

        function hideFrames(hide){
            var frame = $('#xIFrames');
            frame.css('display', hide ? 'none' : 'block');
            frame.children().css('display',hide ? 'none' : 'block');
        }

        docker.on(wcDocker.EVENT.BEGIN_DOCK,_.partial(hideFrames,true));
        docker.on(wcDocker.EVENT.END_DOCK,_.partial(hideFrames,false));
        docker.on(wcDocker.EVENT.RESIZE_STARTED,_.partial(hideFrames,true));
        docker.on(wcDocker.EVENT.RESIZED,_.partial(hideFrames,false));
        if(!docker.id){
            docker.id = registry.getUniqueId(docker._declaredClass.replace(/\./g, "_"));
            docker.$container.attr('id',docker.id);
        }
        registry.add(docker);
        return docker;
    };

    Module.DOCK = wcDocker.DOCK;
    Module.EVENT = wcDocker.EVENT;
    Module.LAYOUT = wcDocker.LAYOUT;
    Module.ORIENTATION = wcDocker.ORIENTATION;

    return Module;
});
/** @module xfile/Breadcrumb **/
define('xfile/Breadcrumb',[
    "dcl/dcl",
    'xide/widgets/TemplatedWidgetBase',
    'xide/model/Path',
    'xide/_base/_Widget'
], function (dcl,TemplatedWidgetBase,Path,_Widget) {

    return dcl(_Widget,{
        templateString:"<ul attachTo='root' style='-webkit-app-region:drag' class='breadcrumb'></ul>",
        grid:null,
        destroy:function(){
            this.clear();
            this.grid = null;
        },
        setSource:function(src){

            /*
            if(!src || (!src.getBreadcrumbPath || !src.collection)){
                return;
            }
            */

            if(this.grid==src){
                return;
            }

            this.grid = src;
            var collection = src.collection
            this.clear();

            var customPath = src.getBreadcrumbPath ? src.getBreadcrumbPath():null;
            if(customPath===false){
                return;
            }
            if(customPath){
                this.setPath(customPath.root, null, customPath, null);
            }else if(collection && src.getCurrentFolder){

                var store = collection,
                    cwdItem = src.getCurrentFolder(),
                    cwd = cwdItem ? cwdItem.path : '';

                this.setPath('.', store.getRootItem(), cwd, store);
            }

        },
        setPath : function(rootLabel,rootItem,path,store,_init){

            this.clear();
            rootItem && rootLabel && this.addSegment(rootLabel, true, rootItem);
            var _path = new Path(path);
            var segs = _path.getSegments();
            var _last = _init || '.';
            _.each(segs, function (seg) {
                var segPath = _last + '/' + seg;
                this.addSegment(seg, true, store ? store.getSync(segPath) : null);
                _last = segPath;
            },this);
        },
        /**
         * Event delegation
         * @param label
         * @param e
         * @param el
         */
        onClick:function(label,e,el){
            this._emit('click',{
                element:el,
                event:e,
                label:label,
                data:el.data
            });
        },
        /**
         * Add a new breadcrumb item
         * @param label
         * @param active
         * @param data
         * @returns {*|jQuery|HTMLElement}
         */
        addSegment:function(label,active,data){

            if(data && this.has(data)){
                return null;
            }

            var _class = active ? 'active' : '',
                self = this,
                el = $("<li class='" +_class + "'><a href='#'>" + label + "</a></li>");

            //clear active state of all previous elements
            _.each(this.all(),function(e){
                e.el.removeClass('active');
            });

            $(this.domNode).append(el);

            if(data) {
                el.on('click', function (e) {
                    self.grid && self.grid.openFolder(data);
                });
                el[0].data = data;
            }

            return el;
        },
        /**
         * Remove last breadcrumb item
         */
        pop:function(){
            this.last().remove();
        },
        /**
         * Return last breadcrumb item
         * @returns {*|jQuery}
         */
        last:function(){
            return $(this.root).children().last();
        },
        /**
         * Returns true when data is found
         * @param data
         * @returns {boolean}
         */
        has:function(data){

            var all = this.all();
            for (var i = 0; i < all.length; i++) {
                if(all[i].data.path === data.path){
                    return true;
                }
            }
            return false;
        },
        /**
         * Return all breadcrumb items
         * @returns {Array}
         */
        all:function(){

            var result = [];

            _.each(this.$root.children(),function(el){
                result.push({
                    el:$(el),
                    label:el.outerText,
                    data:el.data
                })
            });

            return result;

        },
        clear:function(){

            var all = this.all();
            while(all.length){
                var item =all[all.length-1];
                item.el.remove();
                item.data = null;
                all.remove(item);
            }
        },
        /**
         * Removes all breadcrumb items from back to beginning, until data.path matches
         * @param data
         */
        unwind:function(data){
            var rev = this.all().reverse();
            _.each(rev,function(e){
                if(e.data && e.data.path !== (data && data.path) && e.data.path!=='.'){
                    this.pop();
                }
            },this);
        },
        startup:function(){

            this._on('click',function(e){

                var data = e.element[0].data,
                    grid = this.grid;

                if(data) {
                    this.unwind(data);
                    grid && grid.openFolder(data);
                }

            }.bind(this));
        }
    });
});
/** @module xfile/views/FilePicker **/
define('xfile/views/FilePicker',[
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/factory',
    'module',
    'xide/_base/_Widget',
    'xdocker/Docker2',
    'xfile/ThumbRenderer',
    'dojo/promise/all',
    'xfile/Breadcrumb'
], function (dcl, types, utils, factory,
             module, _Widget, Docker2, ThumbRenderer, all, Breadcrumb) {

    var ACTION = types.ACTION;
    var Module = dcl(_Widget, {
        declaredClass:'xfile.views.FilePicker',
        templateString: '<div class="FilePicker"></div>',
        resizeToParent: true,
        docker: null,
        dockerOptions : {
            resizeToParent: true
        },
        breadcrumb: null,
        leftStore: null,
        rightStore: null,

        storeOptionsMixin: null,
        storeOptions: null,

        leftGrid: null,
        leftGridArgs: null,

        rightGrid: null,
        rightGridArgs: null,
        removePermissions:[
            ACTION.OPEN_IN_TAB
        ],
        defaultGridArgs: {
            registerEditors: false,
            _columns: {
                "Name": true,
                "Path": false,
                "Size": false,
                "Modified": false
            }
        },
        selection:null,
        mount: 'root',
        _selection:null,
        getDocker:function(){
            if(this.docker){
                return this.docker;
            }
            var dockerOptions = this.dockerOptions || {
                resizeToParent: true
            };
            var docker = this.docker || Docker2.createDefault(this.domNode, dockerOptions);
            docker.resizeToParent = true;
            this.add(docker, null, false);

            this.docker = docker;
            return docker;
        },
        createLayout: function () {
            var docker = this.getDocker();
            this.layoutTop = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.TOP, null, {
                h: 50,
                title: false
            });
            this.layoutTop._minSize.y = 50;
            this.layoutTop._maxSize.y = 50;
            this.layoutTop._scrollable = {
                x: false,
                y: false
            };
            this.breadcrumb = utils.addWidget(Breadcrumb, {}, null, this.layoutTop, true);
            this.layoutLeft = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.BOTTOM, null, {
                w: 100,
                title: false
            });
            this.layoutLeft._minSize.x = 150;
            this.layoutLeft.moveable(true);
            this.layoutMain = docker.addPanel('DefaultFixed', types.DOCKER.DOCK.RIGHT, this.layoutLeft, {
                w: '70%',
                title: false
            });
            this.layoutTop.initSize(100,'100%');
            this.layoutLeft.initSize('100%',150);
            docker.resize();
        },
        setSelection:function(selection){
            this._selection=selection;
        },
        connectGrids:function(src,target){

            var self = this;

            target._on('selectionChanged', function (event) {
                if(event.why !=='deselect') {
                    var selection = target.getSelection(),
                        item = target.getSelectedItem();

                    if(item){
                        self.setSelection(selection);
                    }
                }
            });
            src._on('selectionChanged', function (event) {
                var selection = src.getSelection(),
                    item = src.getSelectedItem();
                if (!item) {
                    item = src.getCurrentFolder();
                }
                if(!item){
                    return;
                }
                var targetFolder = null;
                if (item.directory) {
                    targetFolder = item;
                } else {
                    if(!item.getParent){
                        console.error('item has no item.getParent!');
                    }
                    targetFolder = item.getParent ? item.getParent() : null;
                }
                if (targetFolder) {
                    target.openFolder(targetFolder.path, false);
                }

                if(item){
                    self.setSelection(selection);
                }
            });

        },
        createFileGrid: function (store, parent, args) {
            var GridClass = this.Module /*|| FileGrid*/;
            return GridClass.createDefault(this.ctx, args, parent, false, true, store);
        },
        onLeftGridReady:function(grid){},
        onRightGridReady:function(grid){},
        onError:function(err,where){
            //console.error('File Picker Error: '+ where + ' : ' + err,err);
        },
        startGrids:function(left,right){
            var self = this,
                srcStore = left.collection,
                targetStore = right.collection,
                _selectArgs = {
                    focus: true,
                    append: false
                },
                both = [left.refresh(), right.refresh()];
            var selected = this.selection;// './AA/xfile_last/Selection_002.png';
            var pathInfo = utils.pathinfo(selected, types.PATH_PARTS.ALL);
            var path = pathInfo.dirname || "";
            if(path==='.'){
                path = selected;
            }
            left.showStatusbar && left.showStatusbar(false);

            left._on('changeSource',function(mountdata){
                right.changeSource(mountdata,true);
            });
            left._on('changedSource',function(mountdata){
                left.select([0],null,true,_selectArgs);
            });
            right._on('changeSource',function(mountdata){
                left.changeSource(mountdata,true);
            });
            right._on('changedSource',function(mountdata){
                left.select([0],null,true,_selectArgs);
            });

            all(both).then(function () {
                self.onLeftGridReady(left);
                self.onRightGridReady(right);
                self.getDocker().resize();
                //load the selected item in the store
                all([srcStore.getItem(path, true), targetStore.getItem(path, true)]).then(function (what) {
                    //when loaded, open that folder!
                    all(_.invoke([left], 'openFolder', path)).then(function () {
                        //when opened, select the selected item
                        all(_.invoke([left,right], 'select', [selected], null, true, _selectArgs)).then(function () {
                            //when selected, complete grids
                            selected._selection = selected;
                            self.connectGrids(left, right);
                            //self.setupBreadcrumb(left, right,selected);
                        },function(err){
                            self.onError(err,'selecting items');
                        });

                    },function(err){
                        self.onError(err,'open folder');
                    });
                },function(err){
                    self.onError(err,'loading items');
                });
            },function(error){
                self.onError(err,'refresh grid');
            });
        },
        /**
         * Function called right after left & right grid is ready (opened folders,...)
         * @param src
         * @param target
         */
        setupBreadcrumb:function(src,target,openPath){
            
            var breadcrumb = this.breadcrumb,
                cwd = src.getCurrentFolder(),
                srcStore = src.collection,
                targetStore = target.collection;
            breadcrumb.setSource(src);

            function _onChangeFolder(store,item,grid){
                if(breadcrumb.grid!=grid){
                    breadcrumb.setSource(grid);
                }
                breadcrumb.clear();
                breadcrumb.setPath('.',srcStore.getRootItem(),item.getPath(),store);
            }

            this.addHandle('click',src.on('click',function(){
                breadcrumb.setSource(src);
            }));
            this.addHandle('click',target.on('click',function(){
                breadcrumb.setSource(target);
            }));
            src._on('openFolder', function (evt) {
                _onChangeFolder(srcStore,evt.item,src);
            });
            target._on('openFolder', function (evt) {
                _onChangeFolder(targetStore,evt.item,target);
            });

        },
        destroy:function(){          
            utils.destroy(this.leftStore);
            utils.destroy(this.rightStore);
            utils.destroy(this.leftGrid);
            utils.destroy(this.rightGrid);
            utils.destroy(this.breadcrumb);
            utils.destroy(this.docker);            
        },
        startup: function () {
            this.createLayout();
            var leftParent = this.layoutLeft;
            var rightParent = this.layoutMain;
            var self = this,
                ctx = self.ctx,
                config = ctx.config;

            /**
             * File Stores
             */
            var mount = this.mount || 'root';
            var storeOptions = this.storeOptions;
            var storeOptionsMixin = this.storeOptionsMixin || {
                    "includeList": "*.jpg,*.png",
                    "excludeList": "*"
                };

            var leftStore = this.leftStore || factory.createFileStore(mount, storeOptions, config, storeOptionsMixin, ctx);
            var rightStore = this.rightStore || factory.createFileStore(mount, storeOptions, config, storeOptionsMixin, ctx);
            var newTabTarget = this.layoutMain;
            var defaultGridArgs = utils.mixin({},utils.clone(this.defaultGridArgs));
            var removePermissions = this.removePermissions;
            /**
             *  Left - Grid :
             */
            var leftGridArgs = utils.mixin(defaultGridArgs, this.leftGridArgs || {
                    newTarget: newTabTarget
                });
            _.remove(leftGridArgs.permissions, function (permission) {
                return _.indexOf(removePermissions, permission) !== -1;
            });
            //eg: leftGridArgs.permissions.remove(types.ACTION.STATUSBAR);
            var gridLeft = this.leftGrid || this.createFileGrid(leftStore, leftParent, leftGridArgs);
            this.leftGrid = gridLeft;
            /**
             *  Right - Grid :
             */
            var rightGridArgs = utils.mixin(defaultGridArgs,this.rightGridArgs || {
                    selectedRenderer: ThumbRenderer
                });
            _.remove(rightGridArgs.permissions, function (permission) {
                return _.indexOf(removePermissions, permission) !== -1;
            });
            var gridMain = this.rightGrid || this.createFileGrid(rightStore, rightParent, rightGridArgs);
            this.rightGrid = gridMain;
            return this.startGrids(gridLeft,gridMain);
        }
    });

    return Module;

});

/** module:xfile/FileActions **/
define('xfile/FileActions',[
    'dcl/dcl',
    'xdojo/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/factory',
    'xide/model/Path',
    'xaction/DefaultActions',
    'xide/editor/Registry',
    'xide/editor/Default',
    'dojo/aspect',
    'xfile/views/FileOperationDialog',
    'xfile/views/FilePreview',
    'xide/views/_CIDialog',
    "xide/views/_Dialog",
    "xide/views/_PanelDialog",
    'xfile/views/FilePicker'
], function (dcl, declare, has,Deferred, utils, types, factory, Path, DefaultActions, Registry, Default, aspect, FileOperationDialog, FilePreview, _CIDialog, _Dialog, _PanelDialog,FilePicker) {

    var ACTION = types.ACTION;
    var _debug = false;
    var Module = null;

    function defaultCopyOptions() {
        /***
         * gather options
         */
        var result = {
                includes: ['*', '.*'],
                excludes: [],
                mode: 1501
            },
            flags = 4;

        switch (flags) {

            case 1 << 2:
            {
                result.mode = 1502;//all
                break;
            }
            case 1 << 4:
            {
                result.mode = 1501;//none
                break;
            }
            case 1 << 8:
            {
                result.mode = 1504;//newer
                break;
            }
            case 1 << 16:
            {
                result.mode = 1503;//size
                break;
            }
        }

        return result;
    }

    /**
     *
     * @param owner
     * @param inValue
     * @param callback
     * @param title
     * @param permissions
     * @param pickerOptions
     * @param dfd
     * @param Module
     * @returns {*}
     */
    function createFilePicker(owner,inValue,callback,title,permissions,pickerOptions,dfd,Module){
        var dlg = new _PanelDialog({
            size: types.DIALOG_SIZE.SIZE_NORMAL,
            bodyCSS: {
                'height': 'auto',
                'min-height': '500px',
                'padding': '8px',
                'margin-right': '16px'
            },
            picker: null,
            title:title,
            onOk: function () {
                var selected = this.picker._selection;
                if (selected && selected[0]) {
                    callback(selected[0]);
                    dfd && dfd.resolve(selected[0],selected,this.picker);
                }
            },
            onShow:function(panel,contentNode){
                var picker = utils.addWidget(FilePicker,utils.mixin({
                    ctx: owner.ctx,
                    owner: owner,
                    selection: inValue || './AA/xfile_last/data/su.jpg',
                    resizeToParent: true,
                    storeOptionsMixin: {
                        "includeList": "*,.*",
                        "excludeList": ""
                    },
                    Module: Module,
                    permissions: permissions||utils.clone(types.DEFAULT_FILE_GRID_PERMISSIONS)
                },pickerOptions),this,contentNode,true);

                this.picker = picker;
                this.add(picker);
                this.startDfd.resolve();
                return [this.picker];

            }
        });
        dlg.show();
        return dfd;
    }
    
    function openFilePicker(dlg, fileWidget) {

        var inValue = fileWidget.userData.value || './AA/xfile_last/data/su.jpg';
        var dfd = new Deferred(),
            self = this;

        var result = new _PanelDialog({
            size: types.DIALOG_SIZE.SIZE_NORMAL,
            bodyCSS: {
                'height': 'auto',
                'min-height': '500px',
                'padding': '8px',
                'margin-right': '16px'
            },
            picker: null,
            title:fileWidget.title,
            onOk: function () {
                var selected = this.picker._selection;
                if (selected && selected[0]) {
                    fileWidget.set('value', selected[0].path);
                    dfd.resolve(selected[0].path);
                    result.value = selected[0].path;
                }

            },
            onShow:function(panel,contentNode){
                var picker = utils.addWidget(FilePicker,{
                    ctx: self.ctx,
                    owner: self,
                    selection: inValue || './AA/xfile_last/data/su.jpg',
                    resizeToParent: true,
                    mount:self.collection.mount,
                    storeOptionsMixin: {
                        "includeList": "*,.*",
                        "excludeList": ""
                    },
                    Module: self.Module,
                    permissions: utils.clone(self.Module.DEFAULT_PERMISSIONS)
                },this,contentNode,true);

                this.picker = picker;
                this.add(picker,null,false);
                this.startDfd.resolve();
                return [this.picker];

            }
        });
        result.show();
        return dfd;

    }

    /**
     * XFile actions
     * @class module:xfile/FileActions
     * @augments module:xfile/views/FileGrid
     */
    var Implementation = {
        __loading:true,
        /**
         * mkdir version:
         *
         *    1. open dialog with input box (value = currentItem)
         *
         * @TODO : remove leaks
         */
        touch: function () {
            
            var dfd = new Deferred();
            try {
                var self = this,
                    currentItem = this.getSelectedItem(),
                    currentFolder = this.getCurrentFolder(),
                    startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                    collection = this.collection;

                var CIS = {
                        inputs: [
                            utils.createCI('Name', 13, startValue, {
                                widget: {
                                    instant: true,
                                    validator: function (value) {
                                        if(currentFolder) {
                                            return collection.getSync(currentFolder.path + '/' + value) == null &&
                                                value.length > 0;
                                        }else{
                                            return true;
                                        }
                                    }
                                }
                            })
                        ]
                    },
                    defaultDfdArgs = {
                        select: currentItem,
                        focus: true,
                        append: false
                    };

                var dlg = new _CIDialog({
                    cis: CIS,
                    title: 'Create new File',
                    ctx: this.ctx,
                    size: types.DIALOG_SIZE.SIZE_SMALL,
                    bodyCSS: {
                        'height': 'auto',
                        'min-height': '80px'

                    },
                    _onError: function (title, suffix, message) {
                        title = title || this.title;
                        message = message || this.notificationMessage;
                        message && message.update({
                            message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                            type: 'error',
                            actions: false,
                            duration: 15000
                        });
                        this.onError && this.onError(suffix);
                    },
                    onCancel: function () {
                        dfd.resolve();
                    },
                    onOk: function () {
                        var val = this.getField('name');
                        if (val == null) {
                            dfd.resolve(defaultDfdArgs);
                            return;
                        }
                        var currentFolder = self.getCurrentFolder() || {path:'.'},
                            newFolder = currentFolder.path + '/' + val;

                        var fileDfd = self.ctx.getFileManager().mkfile(collection.mount, newFolder, {
                            checkErrors: true,
                            returnProm: false
                        });

                        // call server::mkdir, then reload, then resolve dfd with new newFolder as selection
                        fileDfd.then(function (data) {
                            self.runAction(ACTION.RELOAD).then(function () {
                                collection.getSync(newFolder) && dfd.resolve({
                                    select: newFolder,
                                    append: false,
                                    focus: true
                                });
                            });
                        }, function (e) {
                            dfd.resolve(defaultDfdArgs);
                            logError(e, 'error creating directory');
                        });
                    }
                });
                dlg.show();
            } catch (e) {
                logError(e, 'error creating dialog');
            }
            return dfd;

        },
        newTabArgs: null,
        openInOS:function(item){
            var thiz = this,
                ctx = thiz.ctx,
                resourceManager = ctx.getResourceManager(),
                vfsConfig = resourceManager.getVariable('VFS_CONFIG') || {};

            var mount = item.mount.replace('/','');
            if(!vfsConfig[mount]){
                console.error('open in os failed: have no VFS config for ' + mount);
                return;
            }

            var _require = window['eRequire'];
            if(!_require){
                console.error('have no electron');
            }


            var os = _require('os');
            var shell = _require('electron').shell;
            var path = _require("path");

            mount = vfsConfig[mount];
            mount = utils.replaceAll(' ','',mount);

            var itemPath = item.path.replace('./','/');
            itemPath = utils.replaceAll('/',path.sep,itemPath);
            var realPath = path.resolve(mount + path.sep + itemPath);
            realPath = utils.replaceAll(' ','',realPath);
            if(os.platform()!=='win32') {
                shell.openItem(realPath);
            }else{
                shell.openItem('file:///' + realPath);
            }

            console.log('open in system ' + mount +':'+ itemPath + ' = ' + realPath,vfsConfig);

        },
        getFileActions: function (permissions) {
            permissions = permissions || this.permissions;
            var result = [],
                ACTION = types.ACTION,
                ACTION_ICON = types.ACTION_ICON,
                VISIBILITY = types.ACTION_VISIBILITY,
                thiz = this,
                ctx = thiz.ctx,
                container = thiz.domNode,
                resourceManager = ctx.getResourceManager(),
                vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') : {},//possibly resourceManager not there in some builds
                actionStore = thiz.getActionStore();

            ///////////////////////////////////////////////////
            //
            //  misc
            //
            ///////////////////////////////////////////////////
            result.push(thiz.createAction({
                label: 'Go up',
                command: ACTION.GO_UP,
                icon: ACTION_ICON.GO_UP,
                tab: 'Home',
                group: 'Navigation',
                keycombo: ['backspace'],
                mixin:{
                    quick:true
                }
            }));

            result.push(thiz.createAction({
                label: 'Copy',
                command: ACTION.COPY,
                icon: 'fa-paste',
                tab: 'Home',
                group: 'Organize',
                keycombo: ['f5'],
                shouldDisable: function () {
                    return thiz.getSelectedItem() == null;
                }
            }));

            result.push(thiz.createAction({
                label: 'Close',
                command: ACTION.CLOSE,
                icon: 'fa-close',
                tab: 'View',
                group: 'Organize',
                keycombo: ['ctrl 0']
            }));

            result.push(thiz.createAction({
                label: 'Move',
                command: ACTION.MOVE,
                icon: 'fa-long-arrow-right',
                tab: 'Home',
                group: 'Organize',
                keycombo: ['f6'],
                shouldDisable: function () {
                    return thiz.getSelectedItem() == null;
                }
            }));

            if( (location.href.indexOf('electron=true')!==-1 || has('electronx') && has('electron')) && vfsConfig){
                result.push(thiz.createAction({
                    label: 'Open with System',
                    command: 'File/OpenInOS',
                    icon: 'fa-share',
                    tab: 'Home',
                    group: 'Open',
                    keycombo: ['shift f4'],
                    mixin: {
                        addPermission: true,
                        quick:true
                    },
                    shouldDisable: function () {
                        var item = thiz.getSelectedItem();
                        if(!item){
                            return;
                        }
                        return false;
                    }
                }));
            }

            result.push(this.createAction('Open In New Tab', 'File/OpenInNewTab', 'fa-share', ['alt enter'], 'Home', 'Open', 'item', null, null, {quick:true}, null, function () {
                    var item = thiz.getSelectedItem();
                    if (item && item.isDir) {
                        return false;
                    }
                    return true;
                }, permissions, container, thiz
            ));


            if (ctx && ctx.getMountManager && DefaultActions.hasAction(permissions, ACTION.SOURCE)) {
                permissions.push(ACTION.SOURCE);
                var mountManager = ctx.getMountManager(),
                    mountData = mountManager.getMounts(),
                    i = 0;

                if (mountData && mountData.length > 0) {
                    var currentValue = thiz.collection.mount;
                    result.push(this.createAction({
                        label: 'Source',
                        command: ACTION.SOURCE,
                        icon: 'fa-hdd-o',
                        keyCombo: ['ctrl f1'],
                        tab: 'Home',
                        group: 'Navigation',
                        mixin:{
                            data:mountData,
                            addPermission:true,
                            quick:true
                        },
                        onCreate:function(action){
                            action.set('value',currentValue);
                        }
                    }));

                    function createSourceAction(item) {
                        var label = item.label;
                        permissions.push(ACTION.SOURCE + '/' + label);
                        var _sourceAction = thiz.createAction({
                            label: label,
                            command: ACTION.SOURCE + '/' + label,
                            icon: 'fa-hdd-o',
                            keyCombo: ['alt f' + i],
                            tab: 'Home',
                            group: 'Navigation',
                            mixin:{
                                data:mountData,
                                item: item,
                                closeOnClick:false,
                                quick:true
                            },
                            onCreate:function(action){
                                action.set('value',item.name);
                                action._oldIcon = this.icon;
                                action.actionType = types.ACTION_TYPE.SINGLE_TOGGLE;
                            }
                        });
                        result.push(_sourceAction);
                        i++;
                    }
                    _.each(mountData, createSourceAction);
                }
            }

            return result.concat(this.getEditorActions(permissions));
        },
        rename: function (item) {
            var dfd = new Deferred();
            var self = this,
                currentItem = item || this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).basename : '',
                collection = this.collection,
                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            var CIS = {
                inputs: [
                    utils.createCI('name', types.ECIType.STRING, startValue, {
                        widget: {
                            instant: true,
                            title: 'New Name',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            };
            var dlg = new _CIDialog({
                cis: CIS,
                title: 'Rename',
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                bodyCSS: {
                    'height': 'auto',
                    'min-height': '80px',
                    'width':'100%',
                     'min-width':'400px'
                },
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {
                    var val = this.getField('name');
                    if (val == null) {
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }
                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().rename(currentItem.mount, currentItem.path, val, {
                            checkErrors: true,
                            returnProm: false
                        });

                    fileDfd.then(function (data) {

                        self.runAction(ACTION.RELOAD).then(function () {
                            defaultDfdArgs.select = currentFolder.path + '/' + val;
                            dfd.resolve(defaultDfdArgs);
                        });

                    }, function (e) {
                        logError(e, '__error renaming file!');
                        dfd.resolve(defaultDfdArgs);
                    });
                }
            });
            dlg.show();

            return dfd;

        },
        move: function (items) {

            var dfd = new Deferred();
            var self = this,
                currentItem = this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                collection = this.collection,

                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            //file selected
            if (!currentItem.directory) {
                var _parent = currentItem.getParent();
                if (_parent) {
                    currentItem = _parent;
                    startValue = currentItem ? currentItem.path : './';
                }
            }
            var fileWidgetValue = currentItem.path;
            var CIS = {
                inputs: [
                    utils.createCI('Name', types.ECIType.FILE, fileWidgetValue, {
                        widget: {
                            instant: true,
                            title: 'Target',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            }

            var dlg = new _CIDialog({
                cis: CIS,
                title: self.localize('Move'),
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {

                    var val = this.getField('name');

                    if (val == null) {
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }

                    var serverArgs = self._buildServerSelection(selection);
                    var dstPathItem = self.collection.getSync(val);
                    var dstPath = dstPathItem ? utils.normalizePath(dstPathItem.mount + '/' + dstPathItem.path) : '';

                    if (dstPathItem) {
                        serverArgs.dstPath = dstPath;
                    }

                    var options = defaultCopyOptions();
                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().moveItem(serverArgs.selection, serverArgs.dstPath, options.includes, options.excludes, options.mode, {
                            checkErrors: true,
                            returnProm: false
                        });

                    fileDfd.then(function (data) {
                        self.runAction(ACTION.RELOAD).then(function () {
                            dfd.resolve(defaultDfdArgs);
                        });

                    }, function (e) {
                        logError(e, '__error creating file!');
                        dfd.resolve(defaultDfdArgs);
                    })
                }
            });
            dlg._on('widget', function (e) {
                e.widget._onSelect = function (w) {
                    return openFilePicker.apply(self, [dlg, w]);
                }
            });
            dlg.show();
            return dfd;
        },
        copy: function (items) {

            var dfd = new Deferred();
            var self = this,
                currentItem = this.getSelectedItem(),
                selection = this.getSelection(),
                currentFolder = this.getCurrentFolder(),
                startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                collection = this.collection,
                defaultDfdArgs = {
                    select: selection,
                    focus: true,
                    append: false
                };

            //file selected
            if (!currentItem.directory) {
                var _parent = currentItem.getParent();
                if (_parent) {
                    currentItem = _parent;
                    startValue = currentItem ? currentItem.path : './';
                }
            }
            var fileWidgetValue = currentItem.path;
            var CIS = {
                inputs: [
                    utils.createCI('Name', types.ECIType.FILE, fileWidgetValue, {
                        widget: {
                            instant: true,
                            title: 'Target',
                            validator: function (value) {
                                return collection.getSync(currentFolder.path + '/' + value) == null &&
                                    value.length > 0;
                            }
                        }
                    })
                ]
            }
            var dlgClass = dcl([FileOperationDialog, _CIDialog], {});
            var dlg = new dlgClass({
                cis: CIS,
                title: self.localize('Copy'),
                ctx: this.ctx,
                size: types.DIALOG_SIZE.SIZE_NORMAL,
                bodyCSS: {
                    'height': 'auto',
                    'min-height': '80px',
                    'width':'100%',
                    'min-width':'400px'
                },
                onCancel: function () {
                    dfd.resolve(defaultDfdArgs);
                },
                onOk: function () {

                    var val= this.getField('name');
                    if(val==null){
                        dfd.resolve(defaultDfdArgs);
                        return;
                    }
                    var msg = this.showMessage(),
                        thiz = this,
                        serverArgs = self._buildServerSelection(selection),
                        dstPathItem  = self.collection.getSync(val),
                        dstPath = dstPathItem ? utils.normalizePath(dstPathItem.mount + '/' + dstPathItem.path) : '';

                    if(dstPathItem) {
                        serverArgs.dstPath = dstPath;
                    }else{
                        serverArgs.dstPath = utils.normalizePath(currentItem.mount + '/' + val);
                    }

                    var currentFolder = self.getCurrentFolder(),
                        newFolder = val,
                        fileDfd = self.ctx.getFileManager().copyItem(serverArgs.selection,serverArgs.dstPath,defaultCopyOptions(),{
                            checkErrors:true,
                            returnProm:false
                        });

                    fileDfd.then(function (result) {
                        thiz._onSuccess(result);
                    }, function (err) {
                        thiz._onError();
                    });

                    fileDfd.then(function(data){
                        self.runAction(ACTION.RELOAD).then(function(){
                            dfd.resolve(defaultDfdArgs);
                        });

                    },function(e){
                        logError(e,'__error creating file!');
                        dfd.resolve(defaultDfdArgs);
                    })
                }
            });
            dlg._on('widget', function (e) {
                e.widget._onSelect = function (w) {
                    return openFilePicker.apply(self, [dlg, w]);
                };
            });
            dlg.show();
            return dfd;


        },
        clipboardPaste: function () {
            var dfd = new Deferred();
            var isCut = this.currentCutSelection,
                items = isCut ? this.currentCutSelection : this.currentCopySelection,
                serverParams = this._buildServerSelection(items),
                serverFunction = isCut ? 'moveItem' : 'copyItem',
                self = this,
                defaultDfdArgs = {
                    select: items,
                    focus: true,
                    append: false
                };
            if (!items) {
                dfd.resolve();
                return dfd;
            }
            var options = defaultCopyOptions();
            self.ctx.getFileManager()[serverFunction](serverParams.selection, serverParams.dstPath, {
                include: options.includes,
                exclude: options.excludes,
                mode: options.mode
            }).then(function (data) {
                self.runAction(types.ACTION.RELOAD).then(function () {
                    dfd.resolve(defaultDfdArgs);
                });
            }, function (err) {
                dfd.resolve(defaultDfdArgs);
            }, function (progress) {
                dfd.resolve(defaultDfdArgs);
            });
            return dfd;
        },
        /**
         * mkdir version:
         *
         *    1. open dialog with input box (value = currentItem)
         *
         * @TODO : remove leaks
         */
        mkdir: function () {

            var dfd = new Deferred();
            try {
                var self = this,
                    currentItem = this.getSelectedItem(),
                    currentFolder = this.getCurrentFolder(),
                    startValue = currentItem ? utils.pathinfo(currentItem.path, types.PATH_PARTS.ALL).filename : '',
                    collection = this.collection;

                var CIS = {
                        inputs: [
                            utils.createCI('Name', 13, startValue, {
                                widget: {
                                    instant: true,
                                    validator: function (value) {
                                        if(currentFolder) {
                                            return collection.getSync(currentFolder.path + '/' + value) == null &&
                                                value.length > 0;
                                        }else{
                                            return true;
                                        }
                                    }
                                }
                            })
                        ]
                    },
                    defaultDfdArgs = {
                        select: currentItem,
                        focus: true,
                        append: false
                    };

                var dlg = new _CIDialog({
                    cis: CIS,
                    title: 'Create new Directory',
                    ctx: this.ctx,
                    size: types.DIALOG_SIZE.SIZE_NORMAL,
                    bodyCSS: {
                        'height': 'auto',
                        'min-height': '80px',
                        'width':'100%',
                        'min-width':'400px'
                    },
                    _onError: function (title, suffix, message) {
                        title = title || this.title;
                        message = message || this.notificationMessage;
                        message && message.update({
                            message: title + this.failedText + (suffix ? '<br/>' + suffix : ''),
                            type: 'error',
                            actions: false,
                            duration: 15000
                        });
                        this.onError && this.onError(suffix);
                    },
                    onCancel: function () {
                        dfd.resolve();
                    },
                    onOk: function () {

                        var val = this.getField('name');
                        if (val == null) {
                            dfd.resolve(defaultDfdArgs);
                            return;
                        }

                        var currentFolder = self.getCurrentFolder() || {path:'.'},
                            newFolder = currentFolder.path + '/' + val;

                        var fileDfd = self.ctx.getFileManager().mkdir(collection.mount, newFolder, {
                            checkErrors: true,
                            returnProm: false
                        });

                        // call server::mkdir, then reload, then resolve dfd with new newFolder as selection
                        fileDfd.then(function (data) {
                            self.runAction(ACTION.RELOAD).then(function () {
                                collection.getSync(newFolder) && dfd.resolve({
                                    select: newFolder,
                                    append: false,
                                    focus: true
                                });
                            });
                        }, function (e) {
                            dfd.resolve(defaultDfdArgs);
                            logError(e, 'error creating directory');
                        })
                    }
                });

                dlg.show();

            } catch (e) {
                logError(e, 'error creating dialog');
            }
            return dfd;

        },
        _buildServerSelection: function (items, dst) {

            !dst && (dst = this.getCurrentFolder());

            //normalize
            if (dst && !dst.directory) {
                dst = dst.getParent();
            }

            if (!_.isArray(items)) {
                items = [items];
            }

            //basics
            var selection = [],
                store = items[0].getStore(),
                dstPath = dst ? utils.normalizePath(dst.mount + '/' + dst.path) : '';

            //build selection
            _.each(items, function (item) {
                var _storeItem = store.getSync(item.path);
                if (_storeItem) {
                    selection.push(utils.normalizePath(item.mount + '/' + item.path));
                }
            });


            //compose output
            return {
                selection: selection,
                store: items[0]._S,
                dstPath: '/' + dstPath + '/',
                firstItem: items[0],
                parent: dst
            }
        },
        openPreview: function (item, parent) {

            var row = this.row(item);

            var el = row.element,
                self = this,
                dfd = new Deferred();

            if (this._preview) {
                this._preview.item = item;
                var _dfd = this._preview.open().then(function () {
                    self._preview.preview.trigger($.Event('update', {file: item}));
                });

                return _dfd;
            }


            var _prev = new FilePreview({
                node: $(el),
                item: item,
                delegate: this.ctx.getFileManager(),
                parent: $(el),
                ctx: self.ctx,
                container: parent ? parent.containerNode : null
            });

            parent ? _prev.buildRenderingEmbedded() : _prev.buildRendering();
            _prev.init();
            _prev.exec();
            this._preview = _prev;
            this._preview.handler = this;
            self._on('selectionChanged', function (e) {
                var _item = self.getSelectedItem();
                if (_item) {

                    _prev.item = _item;
                    _prev.preview.trigger($.Event('update', {file: _item}));
                }
            });

            this.add(_prev, null, false);
            _prev._emit('changeState', function (state) {
                if (state === 0) {
                    dfd.resolve({
                        select: item,
                        focus: true,
                        append: false
                    });
                }
            });

            return dfd;

        },
        deleteSelection: function (selection) {
            selection = selection || this.getSelection();
            var dfd = new Deferred(),
                _next = this.getNext(selection[0], null, true),
                _prev = this.getPrevious(selection[0], null, true),

                next = _next || _prev,
                serverParams = this._buildServerSelection(selection),
                dlgClass = FileOperationDialog,
                title = 'Delete ' + serverParams.selection.length + ' ' + 'items',
                thiz = this;

            var dlg = new dlgClass({
                ctx: thiz.ctx,
                notificationMessage: null,
                title: title,
                type: types.DIALOG_TYPE.DANGER,
                onBeforeOk: function () {

                },
                getOkDfd: function () {
                    var thiz = this;
                    return this.ctx.getFileManager().deleteItems(serverParams.selection, {
                        hints: [1]
                    }, {
                        checkErrors: false,
                        returnProm: false,
                        onError: function (err) {
                            thiz._onError(null, err.message);
                        }
                    });
                },
                onCancel: function () {
                    dfd.resolve({
                        select: selection,
                        focus: true,
                        append: false
                    });
                },
                onSuccess: function () {
                    thiz.runAction(types.ACTION.RELOAD).then(function () {
                        dfd.resolve({
                            select: next,
                            focus: true,
                            append: false
                        });
                    });
                }
            });
            dlg.show();
            return dfd;
        },
        /**
         *
         * @param item {module:xfile/model/File}
         */
        goUp: function (item) {
            item = this._history.getNow();
            _debug && console.log('go up ' + item);
            item = _.isString(item) ? this.collection.getSync(item) : item;
            var dfd = new Deferred(),
                self = this;
            var history = this.getHistory();
            var prev = history.getNow();


            if (!item) {
                var rows = this.getRows();
                if (rows[0] && rows[0]._S) {
                    var _parent = rows[0]._S.getParent(rows[0]);
                    if (_parent) {
                        _parent = _parent._S.getParent(_parent);
                        if (_parent) {
                            item = _parent;
                        }
                    }
                }
            }

            if (item) {
                //current folder:
                var _parent = item._S.getParent(item);
                if (_parent) {
                    var _dfd = this.openFolder(_parent, true, false);
                    _dfd && _dfd.then && _dfd.then(function () {
                        if (prev) {
                            //history.pop();
                            var select = self.collection.getSync(prev);
                            if (select) {
                                dfd.resolve({
                                    select: select,
                                    focus: true,
                                    delay: 1
                                });
                            } else {

                                console.warn('cant find back item ' + prev);
                            }
                        } else {
                            console.warn('cant find back item ' + prev + ' ' + item.path);
                        }
                    });
                }
            } else {
                if (prev) {
                    var select = this.collection.getSync(prev);
                    if (select) {
                        this.select([select], null, true, {
                            focus: true,
                            delay: 1
                        });
                    }
                } else {
                    var rows = this.getRows();
                    if (rows[0] && rows[0]._S) {
                        var _parent = rows[0]._S.getParent(rows[0]);
                        if (_parent) {
                            _parent = _parent._S.getParent(_parent);
                            if (_parent) {
                                this.openFolder(_parent, true);
                            }
                        }
                    }
                }
            }
            return dfd;
        },
        reload: function (item) {
            var dfd = new Deferred(),
                selection = this.getSelection();

            item = item || this.getRows()[0];

            //item could be a non-store item:
            var cwd = /*item.getParent ? item.getParent() : */this.getCurrentFolder() || {path:'.'},
                self = this;

            if(cwd.isBack){
                cwd = this.collection.getSync(cwd.rPath);
            }
            var expanded = false;
            if (this.isExpanded && this.expand && item) {
                expanded = this._isExpanded(item);
                if (expanded) {
                    this.expand(item, null, false);
                }
            }
            self.collection.resetQueryLog();
            this.collection.loadItem(cwd, true).then(function (what) {

                if (cwd === '.') {
                    self.collection.resetQueryLog();
                }

                self.refresh().then(function () {
                    var _dfd = self.openItem(cwd, false, false);
                    if (_dfd && _dfd.then) {
                        _dfd.then(function () {
                            dfd.resolve({
                                select: selection,
                                append: false,
                                focus: true,
                                delay: 1
                            });
                            return;
                        });
                    }
                    self.deselectAll();
                    dfd.resolve({
                        select: selection,
                        append: false,
                        focus: true,
                        delay: 2
                    });
                });
            });

            return dfd;
        },
        /**
         * Opens folder
         * @param item {module:xfile.model.File}
         * @param isBack
         */
        toHistory: function (item) {
            var FolderPath = item.getFolder ? new Path(item.getFolder()) : new Path('.');
            var segs = FolderPath.getSegments();
            var addDot = this.collection.addDot;
            var root = this.collection.rootSegment;
            //var _last = addDot ? '.' : "";
            var _last = root;
            if(segs && segs[0]==='.'){
                segs[0] = root;
            }
            var out = [];

            _.each(segs, function (seg) {
                var segPath = seg!==_last ? _last + (_last.endsWith("/") ? "" : "/" ) + seg : seg;
                out.push(segPath);
                _last = segPath;
            });

            return out;

        },
        openFolder: function (item, isBack, select) {
            var cwd = this.getCurrentFolder(),
                store = this.collection,
                history = this.getHistory(),
                now = history.getNow(),
                prev = history.getNow(),
                self = this;

            if (_.isString(item)) {
                item = store.getSync(item);
            } else {
                item = store.getSync(item.path) || item;
            }

            if (!item) {
                console.warn('openFolder: no item! set to root:');
                item = store.getRootItem();
            }

            _debug && console.log('open folder ' + item.path + ' cwd : ' + this.getCurrentFolder().path);
            var _hItems = self.toHistory(item);

            _debug && console.log('history:\n' + _hItems.join('\n'));
            history.set(_hItems);
            if (!item) {
                return this.setQueryEx(store.getRootItem());
            }

            if (cwd && item && isBack && cwd.path === item.path || !item) {

                return;
            }

            this.deselectAll();
            var row = this.row(item),
                node = row ? row.element : null,
                loaded = item._S.isItemLoaded(item),
                iconNode;
            if (!loaded) {
                var _els = $(node).find("span.fa");
                if (_els && _els[0]) {
                    iconNode = $(_els[0]);
                }
                if (iconNode) {
                    iconNode.removeClass('fa fa-folder');
                    iconNode.addClass('fa-spinner fa-spin');

                }
            }
            var head = new Deferred();
            this._emit('openFolder', {
                item: item,
                back: isBack
            });

            var dfd = this.setQueryEx(item, null);
            dfd && dfd.then(function () {
                //remove spinner
                if (iconNode) {
                    iconNode.addClass('fa fa-folder');
                    iconNode.removeClass('fa-spinner fa-spin');
                }
                head.resolve({
                    select: select !== false ? ( isBack ? item : self.getRows()[0]) : null,
                    focus: true,
                    append: false,
                    delay: 1
                });
                self._emit('openedFolder', {
                    item: item,
                    back: isBack
                });
            });

            return head;
        },
        changeSource: function (mountData, silent) {

            var dfd = new Deferred(),
                thiz = this,
                ctx = thiz.ctx || ctx,
                fileManager = ctx.getFileManager(),
                store = factory.createFileStore(mountData.name, null, fileManager.config,null,ctx),
                oldStore = this.collection,
                sourceAction = this.getAction(ACTION.SOURCE),
                label = mountData.label || mountData.name,
                mountAction = this.getAction(ACTION.SOURCE + '/' + label);

            oldStore.destroy();

            silent !== true && this._emit('changeSource', mountData);
            this.set('loading', true);
            this.set('collection', store.getDefaultCollection());
            sourceAction.set('value',mountData.name);
            thiz.set('title','Files ('+mountData.label+')');
            var sourceActions = sourceAction.getChildren();
            _.each(sourceActions, function (child) {
                child.set('icon', child._oldIcon);
            });

            sourceAction.set('label',label);
            mountAction && mountAction.set('icon','fa-spinner fa-spin');
            this.refresh().then(function () {
                thiz.set('loading', false);
                thiz.set('collection', store.getDefaultCollection());
                mountAction && mountAction.set('icon','fa-check');
                silent !== true && thiz._emit('changedSource', mountData);
                thiz.select([0], null, true, {
                    append: false,
                    focus: true
                }).then(function () {
                    dfd.resolve();
                });
            });
            return dfd;

        },
        openInNewTab: function (item) {
            var thiz = this,
                ctx = thiz.ctx,
                wManager = ctx.getWindowManager(),
                dfd = new Deferred(),
                tab = null;

            if (_.isFunction(this.newTarget)) {
                tab = this.newTarget({
                    title: item.name,
                    icon: 'fa-folder',
                    target:thiz._parent,
                    location:null,
                    tabOrientation:null
                });

            } else {
                tab = wManager.createTab(item.name, 'fa-folder', this.newTarget || this);
            }
            var _store = this.collection;
            if(!item.isDir){
                item = this.getCurrentFolder();
            }
            var store = factory.createFileStore(_store.mount,_store.options,_store.config,null,ctx);
            var args = utils.mixin({
                    showToolbar: this.showToolbar,
                    collection: store,
                    selectedRenderer: this.selectedRenderer,
                    showHeader: this.showHeader,
                    newTarget: this.newTarget,
                    style: this.style,
                    options: utils.clone(this.options),
                    permissions: this.permissions,
                    _columns: this._columns,
                    attachDirect: true,
                    registerEditors: this.registerEditors
                }, this.newTabArgs || {}),

                grid = utils.addWidget(this.getClass(), args, null, tab, false);

            dfd.resolve();
            grid.set('loading',true);
            store.initRoot().then(function(d){
                //console.profileEnd('0');
                var _dfd = store.getItem(item.path,true);
                _dfd && _dfd.then(function(){
                        grid.startup();
                        grid.openItem(item).then(function(){
                            grid.set('loading',false);
                            grid.select([0], null, true, {
                                focus: true,
                                append: false,
                                delay:1
                            });
                            
                        });
                        wManager.registerView(grid, true);
                });
            });
            return dfd;
        },
        openItem: function (item, isBack, select) {
            if (!item) {
                var _rows = this.getRows();
                if (_rows[0] && _rows[0].isBack) {
                    item = _rows[0];
                }
            }

            if (item && item.isBack) {
                item._S = null;
                return this.goUp();
            }

            item = _.isString(item) ? this.collection.getSync(item) : item;
            if (!item) {
                return;
            }
            if (item.directory === true) {
                return this.openFolder(item, isBack, select);
            } else {
                var editors = Registry.getEditors(item);
                var defaultEditor = _.find(editors, function (editor) {
                    return editor.isDefault === true;
                });
                if (defaultEditor) {
                    return defaultEditor.onEdit(item, this);
                }
                return this.ctx.getWindowManager().openItem(item, this.newTarget || this, {
                    register: true
                });

            }
        },
        getSelectedItem: function () {
            return this.getSelection()[0];
        },
        openDefaultEditor: function (item) {
            return Default.Implementation.open(item);
        },
        close:function(){
            var panel = this._parent;
            if(panel){
                var docker  = panel.docker();
                if(docker){
                    this.onAfterAction = null;
                    docker.removePanel(panel);
                }
            }
            return false;
        },
        compress:function(items){
            items = items || this.getSelection();
            var thiz = this;
            var serverParams = this._buildServerSelection(items);
            if (serverParams && serverParams.store && serverParams.selection){
                thiz.ctx.getFileManager().compressItem(serverParams.firstItem.mount,serverParams.selection,'zip').then(function (args) {
                    thiz.reload();
                });
            }

        },
        runAction: function (action, _item) {
            _.isString(action) && (action = this.getAction(action));
            if (!action || !action.command) {
                console.warn('invalid action');
                return;
            }
            var ACTION_TYPE = types.ACTION,
                item = this.getSelectedItem() || _item,
                sel = this.getSelection();

            if (action.command.indexOf(ACTION.SOURCE) != -1) {
                return this.changeSource(action.item);
            }
            switch (action.command) {

                case 'File/Compress':
                {
                    return this.compress(sel);
                }
                case ACTION_TYPE.PREVIEW:
                {
                    return this.openPreview(item);
                }
                case 'File/OpenInNewTab':
                {
                    return this.openInNewTab(item || this.collection.getRootItem());
                }
                case ACTION_TYPE.EDIT:
                {
                    return this.openItem(item);
                }
                case ACTION_TYPE.NEW_FILE:
                {
                    return this.touch(item);
                }
                case ACTION_TYPE.NEW_DIRECTORY:
                {
                    return this.mkdir(item);
                }
                case ACTION_TYPE.RELOAD:
                {
                    return this.reload(item);
                }
                case ACTION_TYPE.RENAME:
                {
                    return this.rename(item);
                }
                case ACTION_TYPE.GO_UP:
                {
                    return this.goUp(null);
                }
                case ACTION_TYPE.COPY:
                {
                    return this.copy(null);
                }
                case ACTION_TYPE.MOVE:
                {
                    return this.move(null);
                }
                case ACTION_TYPE.DELETE:
                {
                    return this.deleteSelection(null);
                }
                case ACTION_TYPE.OPEN_IN + '/Default Editor':
                {
                    return this.openDefaultEditor(item);
                }
                case ACTION_TYPE.DOWNLOAD:
                {
                    return this.ctx.getFileManager().download(item);
                }
                case ACTION_TYPE.CLOSE:
                {
                    return this.close();
                }
                case 'File/OpenInOS':
                {
                    return this.openInOS(item);
                }
            }

            if (action.command.indexOf(ACTION_TYPE.OPEN_IN + '/') != -1) {
                return action.editor.onEdit(item);
            }

            return this.inherited(arguments);
        },

        getEditorActions: function (permissions) {
                permissions = permissions || this.permissions;
                var result = [],
                    ACTION = types.ACTION,
                    ACTION_ICON = types.ACTION_ICON,
                    VISIBILITY = types.ACTION_VISIBILITY,
                    thiz = this,
                    ctx = thiz.ctx,
                    container = thiz.domNode,
                    actionStore = thiz.getActionStore(),
                    openInAction = null,
                    openInActionModel = null,
                    dirty = false,
                    selHandle = null;

                function getItem() {
                    return thiz.getSelection()[0];
                }

                function selHandler(event){

                    var selection = event.selection;
                    if(!selection || !selection[0] ){
                        return;
                    }
                    var item = selection[0];
                    var permissions = this.permissions;
                    var ACTION = types.ACTION,
                        ACTION_ICON = types.ACTION_ICON,
                        VISIBILITY = types.ACTION_VISIBILITY,
                        thiz = this,
                        container = thiz.domNode,
                        actionStore = thiz.getActionStore(),
                        contextMenu = this.getContextMenu ? this.getContextMenu() : null;

                    function _wireEditor(editor, action) {
                        action.handler = function () {
                            editor.onEdit(thiz.getSelection()[0]);
                        };
                    }
                    function getEditorActions(item){
                        var editors = Registry.getEditors(item) || [],
                            result = [];

                        for (var i = 0; i < editors.length; i++) {
                            var editor = editors[i];
                            if(editor.name ==='Default Editor'){
                                continue;
                            }
                            var editorAction = thiz.createAction(editor.name, ACTION.OPEN_IN + '/' + editor.name, editor.iconClass, null, 'Home', 'Open', 'item', null,
                                function () {
                                },
                                {
                                    addPermission: true,
                                    tab: 'Home',
                                    editor:editor,
                                    custom:true,
                                    quick:true
                                }, null, null, permissions, container, thiz
                            );
                            _wireEditor(editor, editorAction);
                            result.push(editorAction);
                        }
                        return result;
                    }
                    if (event.why == 'deselect') {
                        return;
                    }
                    var action = actionStore.getSync(types.ACTION.OPEN_IN);
                    var editorActions = thiz.addActions(getEditorActions(item));

                    if(this._lastEditorActions){
                        _.each(this._lastEditorActions,function(action){
                            actionStore.removeSync(action.command);
                        });
                        delete this._lastEditorActions;
                    }

                    contextMenu && contextMenu.removeCustomActions();

                    if(editorActions.length>0) {
                        var newStoredActions = this.addActions(editorActions);
                        actionStore._emit('onActionsAdded', newStoredActions);
                        this._lastEditorActions = newStoredActions;
                    }else{

                    }
                }

                if (!this._selHandle) {
                    this._selHandle = this._on('selectionChanged',function(evt){
                        selHandler.apply(thiz,[evt]);
                    });
                }
                openInAction = this.createAction('Open In', ACTION.OPEN_IN, ACTION_ICON.EDIT, null, 'Home', 'Open', 'item',
                    null,
                    function () {
                    },
                    {
                        addPermission: true,
                        tab: 'Home',
                        quick:true
                    }, null, DefaultActions.shouldDisableDefaultFileOnly, permissions, container, thiz
                );

                result.push(openInAction);
                var e = thiz.createAction('Default Editor', ACTION.OPEN_IN + '/Default Editor', 'fa-code', null, 'Home', 'Open', 'item', null,
                    function () {
                    },
                    {
                        addPermission: true,
                        tab: 'Home',
                        forceSubs: true,
                        quick:true

                    }, null, null, permissions, container, thiz
                );
                result.push(e);
                return result;
            }
    };

    //package via declare
    var _class = declare('xfile.FileActions', null, Implementation);
    _class.Implementation = Implementation;    
    _class.createFilePicker = createFilePicker;    
    return _class;

});
/** module:xide/views/_LayoutMixin **/
define('xide/views/_LayoutMixin',[
    "xdojo/declare",
    "dcl/dcl",
    "xide/types",
    'xdocker/Docker2',
    "xide/utils",
    "xide/layout/_TabContainer"
], function (declare,dcl,types,Docker,utils,_TabContainer) {
    /**
     * @class module:xide/views/_LayoutMixin
     */
    var Implementation = {
        _docker:null,
        _parent:null,
        __right:null,
        __bottom:null,
        __masterPanel:null,
        __bottomTabContainer:null,
        defaultPanelOptions:null,
        defaultPanelType:'DefaultFixed',
        reparent:true,
        getTop:function(){
          return this._parent;
        },
        resize:function(){
            if(this._docker){
                this._docker.resize();
            }
            if(this.inherited) {
                return this.inherited(arguments);
            }
        },
        getDockerTargetNode:function(){
            return null;
        },
        /**
         * @param container {HTMLElement|module:xide/widgets/_Widget}
         * @returns {module:xdocker/Docker2}
         */
        getDocker:function(container){
            var thiz = this;
            if(!this._docker){
                var _node = this._domNode || this.domNode;
                var _dst = this.getDockerTargetNode() || container || _node.parentNode;
                thiz._docker = Docker.createDefault(_dst);
                thiz._oldParent = thiz._parent;
                var defaultOptions  = this.defaultPanelOptions || {
                        w: '100%',
                        title:false
                    };

                var parent = thiz._docker.addPanel(this.defaultPanelType, types.DOCKER.TOP, null,defaultOptions);
                this.reparent && dojo.place(_node,parent.containerNode);
                this.reparent && thiz._docker.$container.css('top',0);
                thiz._parent = parent;
                thiz.__masterPanel = parent;
                !defaultOptions.title && parent._parent.showTitlebar(false);
                _node.id = this.id;
                thiz.add(thiz._docker);
            }
            return thiz._docker;
        },
        getPanelSplitPosition:function(type){
            if(type == types.DOCKER.DOCK.RIGHT && this.__right){
                var splitter = this.__right.getSplitter();
                if(splitter){
                    return splitter.pos();
                }
            }
            return false;
        },
        setPanelSplitPosition:function(type,position){
            var right = this.__right;
            if(type == types.DOCKER.DOCK.RIGHT && right){
                var splitter = right.getSplitter();
                if(position==1) {
                    splitter._isToggledMin = true;
                    splitter._isToggledMax = true;
                }else if(position<1 && position >0){
                    splitter._isToggledMin = false;
                    splitter._isToggledMax = false;
                }
                splitter.pos(position);
            }
        },
        openRight:function(open){
            var thiz = this,
                rightSplitPosition=thiz.getPanelSplitPosition(types.DOCKER.DOCK.RIGHT);
            if(!open && rightSplitPosition<1){
                //panel is open: close it
                thiz.setPanelSplitPosition(types.DOCKER.DOCK.RIGHT,1);
            }else if(open && rightSplitPosition==1){
                //closed, open it and show properties
                thiz.setPanelSplitPosition(types.DOCKER.DOCK.RIGHT,0.6);
            }
        },
        _getRight:function(){
            return this.__right;
        },
        _getBottom:function(){
            return this.__bottom;
        },
        getBottomTabContainer:function(create){
            if(this.__bottomTabContainer){
                return this.__bottomTabContainer;
            }else if(create!==false){
                this. __bottomTabContainer = utils.addWidget(_TabContainer, {
                    direction: 'below'
                }, null,this.getBottomPanel(false, 0.2), true);

            }
            return this.__bottomTabContainer;
        },
        _addPanel:function(props,location,title,startPosition,type,target){
            var docker = this.getDocker();
            var panel = docker.addPanel(type || 'DefaultFixed', location , target ===false ? null : (target || this._parent), props || {
                w: '30%',
                h:'30%',
                title:title||false
            });
            if(!title) {
                panel._parent.showTitlebar(false);
            }
            if(startPosition){
                var splitter = panel.getSplitter();
                if(startPosition==1 || startPosition==0) {
                    splitter.pos(startPosition);
                }else {
                    splitter.pos(0.6);
                }
            }
            return panel;
        },
        getBottomPanel:function(title,startPosition,type,mixin,target){
            if(this.__bottom || this._getBottom()){
                return this.__bottom || this._getBottom();
            }
            var create = true;
            if(create!==false) {
                this.__bottom = this._addPanel(utils.mixin({
                    w: '30%',
                    title: title || '  '
                },mixin), types.DOCKER.DOCK.BOTTOM, title,startPosition,type,target);
            }
            return this.__bottom;
        },
        getRightPanel:function(title,startPosition,type,props){
            if(this.__right || this._getRight()){
                return this.__right || this._getRight();
            }
            props = utils.mixin({
                w: '30%',
                title:title || '  '
            },props);
            var panel = this._addPanel(props,types.DOCKER.DOCK.RIGHT,title,null,type,props.target);
            this.__right = panel;
            return panel;
        }
    };
    //package via declare
    var _class = declare("xide/views/_LayoutMixin",null,Implementation);
    _class.Implementation = Implementation;
    _class.dcl = dcl(null,Implementation);
    return _class;
});

define('xgrid/KeyboardNavigation',[
	"xdojo/declare", // declare
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // hitch
	"dojo/on",
	"xide/utils"
], function(declare, keys, lang, on, utils){

	//@TODO: port hitch
	var hitch = lang.hitch;
	//@TODO: port utils.find
	var find = utils.find;
	
	return declare('xgrid/KeyboardNavigation',null, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: ".dgrid-row",
		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: function reference
			// delay: Optional number (defaults to 0)
			// tags:
			//		protected.
			var timer = setTimeout(hitch(this,
					function(){
						timer = null;
						if(!this._destroyed){
							hitch(this, fcn)();
						}
					}),
				delay || 0
			);
			return {
				remove:	function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		},
		buildRendering:function(){
			this.inherited(arguments);
			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			//domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.UP_ARROW] = hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string" ? this.childSelector : hitch(this, "childSelector"),
				node = this.domNode;

			this.__on(node, "keypress",null,hitch(this, "_onContainerKeypress"));
			this.__on(node, "keydown",null,hitch(this, "_onContainerKeydown"));
		},
		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		___focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},
		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.deselectAll();
				this.select([this.row(item).data],null,true,{
					focus:true,
					delay:10,
					append:true
				})
			}
		},
		getSearchableText:function(data){
			return data.message || data.name  || '';
		},
		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			var element = item;
			if(item && !item.data){
				var row= this.row(item);
				if(row){
					item['data']=row.data;
				}
			}

			//var text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "";
			var text = item ? item.data ? this.getSearchableText(item.data) : '' : '';
			if(text) {
				text = text.toLowerCase();
				//try starts with first:
				var currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();
				var res = (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default

				var contains = text.replace(/^\s+/, '').indexOf(searchString.toLowerCase())!=-1;
				if(res==0 && searchString.length>1 && contains){
					return 1;
				}
				return res;
			}
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			if((evt.target && evt.target.className.indexOf('input') != -1)){
				return;
			}

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop _HasDropDown from processing the SPACE as well
				evt.preventDefault(); // stop default actions like page scrolling on SPACE, but also keypress unfortunately
				on.emit(this.domNode, "keypress", {
					charCode: keys.SPACE,
					cancelable: true,
					bubbles: true
				});
			}
		},

		_onContainerKeypress: function(evt){
			if(this.editing){
				return;
			}
			if((evt.target && evt.target.className.indexOf('input') != -1)){
				return;
			}
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			if(evt.charCode < 32){
				// Avoid duplicate events on firefox (this is an arrow key that will be handled by keydown handler)
				return;
			}

			if(evt.ctrlKey || evt.altKey){
				return;
			}

			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';

					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChildNode ||this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					var idx=0;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				}),
				keyChar = String.fromCharCode(evt.charCode).toLowerCase();


			evt.preventDefault();
			evt.stopPropagation();
			search();

			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){
						break;
					}
				}else{
					if(child && child.node){
						var innerNode = utils.find('.dgrid-cell',child.node,true);
						if(innerNode){
							child=innerNode;
						}
					}
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue){
					return child;
				}
			}while(child != wrappedValue);
		},

		_getFirst: function(){
			var innerNode = utils.find('.dgrid-row', this.domNode,true);
			if(innerNode){
				var innerNode0 = utils.find('.dgrid-cell', innerNode,true);
				if(innerNode0){
					return innerNode0;
				}
			}
			return innerNode;
		},

		_getLast: function(){
			var innerNode = utils.find('.dgrid-row', this.domNode,false);
			if(innerNode){
				var innerNode0 = utils.find('.dgrid-cell', innerNode,true);
				if(innerNode0){
					return innerNode0;
				}
			}
			return null;
		},
		_getPrev: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			if(child){
				var w= this.up(child,1,true);
				if(w){
					var data = null;
					if(w.data){
						data= w.data;
					}

					if(w.element){
						w= w.element;
					}
					var innerNode = utils.find('.dgrid-cell', w,true);
					if(innerNode){
						if(!innerNode.data){
							innerNode['data']=data;
						}
						return innerNode;
					}
					return w;
				}
			}
		},
		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension
			if(child){
				var w= this.down(child,1,true);
				if(w){
					if(w.element){
						w= w.element;
					}
					var innerNode = utils.find('.dgrid-cell', w,true);
					if(innerNode){
						return innerNode;
					}
					return w;
				}
			}
		}
	});
});

/** @module xide/mixins/_State**/
define('xide/mixins/_State',[
    "xdojo/declare"
], function (declare) {
    /**
     * Generic state implementation
     * @class module:xide/mixins/_State
     */
    return declare("xide/mixins/_State",null, {
        getState:function(){
            return this.inherited(arguments) || {};
        },
        setState:function(state){
            return this.inherited(arguments);
        }
    });
});
/** @module xgrid/Base **/
define('xfile/views/GridLight',[
    "xdojo/declare",
    'xide/types',
    'xgrid/ListRenderer',
    'xfile/ThumbRenderer',
    'xgrid/TreeRenderer',
    'xgrid/GridLite',
    'xgrid/MultiRenderer',
    'xfile/FileActions',
    'xide/views/_LayoutMixin',
    'xgrid/KeyboardNavigation',
    'xgrid/Selection',
    'xide/mixins/_State',
    "xide/widgets/_Widget"
], function (declare, types,ListRenderer, ThumbRenderer, TreeRenderer,Grid, MultiRenderer,FileActions,_LayoutMixin,KeyboardNavigation,Selection,_State,_Widget) {
    
    /**
     * A grid feature
     * @class module:xgrid/GridActions
     */
    var Implementation = {

        },
        renderers = [ListRenderer,ThumbRenderer,TreeRenderer],
        multiRenderer = declare.classFactory('multiRenderer',{},renderers,MultiRenderer.Implementation);

    var GridClass = Grid.createGridClass('xfile.views.GridLight', Implementation, {
            SELECTION: {
                CLASS:Selection
            },
            KEYBOARD_SELECTION: true,
            COLUMN_HIDER: true,
            COLUMN_REORDER: false,
            ACTIONS:types.GRID_FEATURES_LITE.ACTIONS,
            ITEM_ACTIONS: {
                CLASS:FileActions
            },
            SPLIT:{
                CLASS:_LayoutMixin
            },
            KEYBOARD_NAVIGATION:{
                CLASS:KeyboardNavigation
            },
            STATE:{
                CLASS:_State
            },
            WIDGET:{
                CLASS:_Widget
            }

        },
        {
            RENDERER: multiRenderer
        },
        {
            renderers: renderers,
            selectedRenderer: TreeRenderer
        }
    );
    GridClass.DEFAULT_RENDERERS = renderers;
    GridClass.DEFAULT_MULTI_RENDERER = multiRenderer;
    return GridClass;

});
/** @module xide/mixins/ReloadMixin **/
define('xide/mixins/ReloadMixin',[
    "xdojo/declare",
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (declare,dcl,types, utils,EventedMixin) {

    /**
     * Mixin which adds functions for module reloading to the consumer. All functions
     * of the reloaded module will be overridden with the re-loaded module's version.
     * Recommended: turn off web-cache and use turn on 'cacheBust' in your Dojo-Config.
     *
     *
     *  <b>Usage</b> :
     *  1. call initReload manually (subscribes to types.EVENTS.ON_MODULE_RELOADED which is triggered by module:xide/manager/Context )
     *  2. that's it actually.
     *  3. optionally add a function 'onReloaded' to your sub class and refresh yourself, ie: re-create widgets or simply test
     *  a piece of code
     *
     *
     * @mixin module:xide/mixins/ReloadMixin
     * @requires module:xide/mixins/EventedMixin
     */
    var Impl = {
        /**
         *
         * Not used yet, but at @TODO: some flags to describe the hot-replace for reloaded modules
         *
         */
        _mergeFunctions: true,
        _mergeMissingVariables: true,
        /**
         * Cross instanceOf equal check, tries:
         *
         *  1. native
         *  2. Dojo::isInstanceOf
         *  3. baseClasses
         *
         * @param cls {Object}
         * @returns {boolean}
         */
        isInstanceOf_: function (cls) {

            try {

                //Try native and then Dojo declare's _Stateful::isInstanceOf
                if (!!this instanceof cls
                    || (this.isInstanceOf && this.isInstanceOf(cls))) {

                    return true;

                }else{

                    //manual lookup, browse all base classes and their superclass
                    var bases = utils.getAt(this, 'constructor._meta.bases', []),//save get, return base::at[path] or empty array
                        _clsClass = cls.prototype.declaredClass;    //cache

                    //save space
                    return _.findWhere(bases, function (_base) {

                        return _base == cls    //direct cmp
                        || utils.getAt(_base, 'superclass.declaredClass') === _clsClass   //mostly here
                        || utils.getAt(_base, 'prototype.declaredClass') === _clsClass;    //sometimes

                    });

                }

            } catch (e) {
                //may crash, no idea why!
                console.log('ReloadMixin :: this.isInstanceOf_ crashed ' + e);
            }

            return false;

        },
        /**
         * @TODO: use flag guarded mixin
         *
         * @param target
         * @param source
         */
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (_.isFunction(source[i])) {
                    target[i] = null;//be nice
                    target[i] = source[i];//override
                }
                //support missing properties
                if (_.isArray(source[i])) {
                    if (target[i] == null) {
                        target[i] = source[i];
                    }
                }
            }
        },
        /**
         * Event callback for xide/types/EVENTS/ON_MODULE_RELOADED when a module has been reloaded.
         * @member
         * @param evt
         */
        onModuleReloaded: function (evt) {
            //console.log('on module reloaded');
            var newModule = evt.newModule;
            if (!newModule || !newModule.prototype || evt._processed) {
                return;
            }
            var moduleProto = newModule.prototype,
                moduleClass = moduleProto.declaredClass,
                matchedByClass = false,
                thisClass = this.declaredClass,
                thiz=this;

            if(!moduleClass){
                return;
            }
            if (moduleClass && thisClass) {
                //determine by dotted normalized declaredClass
                matchedByClass = utils.replaceAll('/', '.', thisClass) === utils.replaceAll('/', '.', moduleClass);
            }
            if (matchedByClass) {
                thiz.mergeFunctions(thiz, moduleProto);
                if (thiz.onReloaded) {
                    evt._processed = true;
                    thiz.onReloaded(newModule);
                }
            } else if (evt.module && utils.replaceAll('//', '/', evt.module) === thisClass) {//not sure this needed left
                //dcl module!
                thiz.mergeFunctions(thiz, moduleProto);
            }
        },
        /**
         * Public entry; call that in your sub-class to init this functionality!
         */
        initReload: function () {
            this.subscribe(types.EVENTS.ON_MODULE_RELOADED);
        }
    };

    //package via declare
    var _class = declare(null,Impl);

    //static access to Impl.
    _class.Impl = Impl;

    _class.dcl = dcl(EventedMixin.dcl,Impl);

    return _class;

});
define('xide/rpc/AdapterRegistry',["dojo/_base/kernel", "dojo/_base/lang"], function (dojo, lang) {
    var AdapterRegistry = dojo.AdapterRegistry = function (/*Boolean?*/ returnWrappers) {
        // summary:
        //		A registry to make contextual calling/searching easier.
        // description:
        //		Objects of this class keep list of arrays in the form [name, check,
        //		wrap, directReturn] that are used to determine what the contextual
        //		result of a set of checked arguments is. All check/wrap functions
        //		in this registry should be of the same arity.
        // example:
        //	|	// create a new registry
        //	|	require(["dojo/AdapterRegistry"],
        //	|	function(AdapterRegistry){
        //	|		var reg = new AdapterRegistry();
        //	|		reg.register("handleString",
        //	|			function(str){
        //	|				return typeof val == "string"
        //	|			},
        //	|			function(str){
        //	|				// do something with the string here
        //	|			}
        //	|		);
        //	|		reg.register("handleArr",
        //	|			dojo.isArray,
        //	|			function(arr){
        //	|				// do something with the array here
        //	|			}
        //	|		);
        //	|
        //	|		// now we can pass reg.match() *either* an array or a string and
        //	|		// the value we pass will get handled by the right function
        //	|		reg.match("someValue"); // will call the first function
        //	|		reg.match(["someValue"]); // will call the second
        //	|	});

        this.pairs = [];
        this.returnWrappers = returnWrappers || false; // Boolean
    };

    lang.extend(AdapterRegistry, {
        register: function (/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override) {
            // summary:
            //		register a check function to determine if the wrap function or
            //		object gets selected
            // name:
            //		a way to identify this matcher.
            // check:
            //		a function that arguments are passed to from the adapter's
            //		match() function.  The check function should return true if the
            //		given arguments are appropriate for the wrap function.
            // directReturn:
            //		If directReturn is true, the value passed in for wrap will be
            //		returned instead of being called. Alternately, the
            //		AdapterRegistry can be set globally to "return not call" using
            //		the returnWrappers property. Either way, this behavior allows
            //		the registry to act as a "search" function instead of a
            //		function interception library.
            // override:
            //		If override is given and true, the check function will be given
            //		highest priority. Otherwise, it will be the lowest priority
            //		adapter.
            this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
        },

        match: function (/* ... */) {
            // summary:
            //		Find an adapter for the given arguments. If no suitable adapter
            //		is found, throws an exception. match() accepts any number of
            //		arguments, all of which are passed to all matching functions
            //		from the registered pairs.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[1].apply(this, arguments)) {
                    if ((pair[3]) || (this.returnWrappers)) {
                        return pair[2];
                    } else {
                        return pair[2].apply(this, arguments);
                    }
                }
            }
            throw new Error("No match found");
        },

        unregister: function (name) {
            // summary:
            //		Remove a named adapter from the registry
            // name: String
            //		The name of the adapter.
            // returns: Boolean
            //		Returns true if operation is successful.
            //		Returns false if operation fails.

            // FIXME: this is kind of a dumb way to handle this. On a large
            // registry this will be slow-ish and we can use the name as a lookup
            // should we choose to trade memory for speed.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[0] == name) {
                    this.pairs.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
    });

    return AdapterRegistry;
});

define('xide/rpc/Service',[
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/xhr",
    "dojo/_base/declare",
    "xide/rpc/AdapterRegistry",
    "dojo/_base/url",
    "xide/utils",
    "xide/lodash"
], function(dojo,lang,xhr,declare,AdapterRegistry,url,utils,_){
    var transportRegistry = new AdapterRegistry(true);
    var envelopeRegistry = new AdapterRegistry(true);
    var _nextId  = 1;
    var _sync = false;

    function getTarget(smd, method){
        var dest=smd._baseUrl;
        if(smd.target){
            dest = new dojo._Url(dest,smd.target) + '';
        }
        if(method.target){
            dest = new dojo._Url(dest,method.target) + '';
        }
        return dest;
    }

    function toOrdered(parameters, args){
        if(dojo.isArray(args)){ return args; }
        var data=[];
        for(var i=0;i<parameters.length;i++){
            data.push(args[parameters[i].name]);
        }
        return data;
    }

    var service = declare("xide.rpc.Service", null, {
        constructor: function(smd, options){

            // summary:
            //		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
            //		as a definition for the service
            // description:
            //		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
            //		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
            //		a "No match found" error.
            // smd: object
            //		Takes a number of properties as kwArgs for defining the service.  It also
            //		accepts a string.  When passed a string, it is treated as a url from
            //		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
            //		object.  It accepts serviceUrl, to manually define a url for the rpc service
            //		allowing the rpc system to be used without an smd definition. strictArgChecks
            //		forces the system to verify that the # of arguments provided in a call
            //		matches those defined in the smd.  smdString allows a developer to pass
            //		a jsonString directly, which will be converted into an object or alternatively
            //		smdObject is accepts an smdObject directly.

            var url;
            var self = this;
            var singleton = options ? options.singleton : false;
            function processSmd(smd){
                smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
                self._smd = smd;
                if(options && options.services==='methods'){
                    smd.services = smd.methods;
                    delete smd.methods;
                    smd.transport = "POST";
                    if(options.mixin){
                        lang.mixin(smd,options.mixin);
                    }
                    options = null;
                }

                //generate the methods
                for(var serviceName in self._smd.services){
                    var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
                    var current = self;
                    for(var i=0; i< pieces.length-1; i++){
                        // create or reuse each object as we go down the chain
                        current = current[pieces[i]] || (current[pieces[i]] = {});
                    }
                    current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
                }
            }
            if(smd){
                //ifthe arg is a string, we assume it is a url to retrieve an smd definition from
                if( (_.isString(smd)) || (smd instanceof dojo._Url)){
                    if(smd instanceof dojo._Url){
                        url = smd + "";
                    }else{
                        url = smd;
                    }

                    this.__init = xhr.getText(url);
                    var self = this;
                    this.__init.then(function(data){
                        processSmd(utils.fromJson(data));
                    });
                    /*

                    if(!text){
                        throw new Error("Unable to load SMD from " + smd);
                    }else{
                        processSmd(utils.fromJson(text));
                    }
                    */

                }else{
                    processSmd(smd);
                }
            }
            this._options = (options ? options : {});
            this._requestId = 0;
        },

        _generateService: function(serviceName, method){
            if(this[method]){
                throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
            }
            method.name = serviceName;

            var func = dojo.hitch(this, "_executeMethod",method);

            var transport = transportRegistry.match(method.transport || this._smd.transport);
            if(transport.getExecutor){
                func = transport.getExecutor(func,method,this);
            }
            var schema = method.returns || (method._schema = {}); // define the schema
            var servicePath = '/' + serviceName +'/';
            // schemas are minimally used to track the id prefixes for the different services
            schema._service = func;
            func.servicePath = servicePath;
            func._schema = schema;
            func.id = _nextId++;
            return func;
        },
        _getRequest: function(method,args){
            var smd = this._smd;
            var envDef = envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || []).concat(smd.parameters || []);
            if(envDef.namedParams){
                // the serializer is expecting named params
                if((args.length==1) && dojo.isObject(args[0])){
                    // looks like we have what we want
                    args = args[0];
                }else{
                    // they provided ordered, must convert
                    var data={};
                    for(var i=0;i<method.parameters.length;i++){
                        if(typeof args[i] != "undefined" || !method.parameters[i].optional){
                            data[method.parameters[i].name]=args[i];
                        }
                    }
                    args = data;
                }
                if(method.strictParameters||smd.strictParameters){
                    //remove any properties that were not defined
                    for(i in args){
                        var found=false;
                        for(var j=0; j<parameters.length;j++){
                            if(parameters[j].name==i){ found=true; }
                        }
                        if(!found){
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for(i=0; i< parameters.length; i++){
                    var param = parameters[i];
                    if(!param.optional && param.name && !args[param.name]){
                        if(param["default"]){
                            args[param.name] = param["default"];
                        }else if(!(param.name in args)){
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            }else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
                // looks like named params, we will convert
                if(envDef.namedParams === false){
                    // the serializer is expecting ordered params, must be ordered
                    args = toOrdered(parameters, args);
                }else{
                    // named is ok
                    args = args[0];
                }
            }

            if(dojo.isObject(this._options)){
                args = dojo.mixin(args, this._options);
            }
            delete args['mixin'];

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: _sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function(method){
            var args = [];
            var i;
            for(i=1; i< arguments.length; i++){
                args.push(arguments[i]);
            }
            var request = this._getRequest(method,args);
            var deferred = transportRegistry.match(request.transport).fire(request);

            deferred.addBoth(function(results){
                return request._envDef.deserialize.call(this,results);
            });
            return deferred;
        }
});

    service.transportRegistry = transportRegistry;
    service.envelopeRegistry = envelopeRegistry;
    service._nextId = _nextId;
    service.getTarget = getTarget;
    service.toOrdered= toOrdered;
    service._sync = _sync;
    envelopeRegistry.register("URL", function(str){ return str == "URL"; },{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	});
    envelopeRegistry.register("JSON",function(str){ return str == "JSON"; },{
        serialize: function(smd, method, data){
            var d = dojo.toJson(data);

            return {
                data: d,
                handleAs: 'json',
                contentType : 'application/json'
            };
        },
        deserialize: function(results){
            return results;
        }
    });
    envelopeRegistry.register("PATH",function(str){ return str == "PATH"; },{
        serialize:function(smd, method, data){
			var i;
			var target = getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}
			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	});
    //post is registered first because it is the default;
    transportRegistry.register("POST",function(str){ return str == "POST"; },{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	});
    transportRegistry.register("GET",function(str){ return str == "GET"; },{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return xhr.get(r);
		}
	});
    //only works ifyou include dojo.io.script
    /*
    transportRegistry.register("JSONP",function(str){ return str == "JSONP"; },{
        fire: function(r){
            r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
            r.callbackParamName = r.callbackParamName || "callback";
            return dojo.io.script.get(r);
        }
    });*/
    if(dojo._contentHandlers) {
        dojo._contentHandlers.auto = function (xhr) {
            // automatically choose the right handler based on the returned content type
            var handlers = dojo._contentHandlers;
            var retContentType = xhr.getResponseHeader("Content-Type");
            var results = !retContentType ? handlers.text(xhr) :
                retContentType.match(/\/.*json/) ? handlers.json(xhr) :
                    retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
                        retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
            return results;
        };
    }
    return service;
});

/** @module xide/utils/StringUtils
 *  @description All string related functions
 */
define('xide/utils/StringUtils',[
    'xide/utils',
    'xide/types',
    'dojo/json',
    'xide/lodash'
], function (utils, types, json, _) {
    "use strict";

    /**
     *
     * @param replacer
     * @param cycleReplacer
     * @returns {Function}
     */
    function serializer(replacer, cycleReplacer) {
        var stack = [], keys = [];

        if (cycleReplacer == null) cycleReplacer = function (key, value) {
            if (stack[0] === value) return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
        };

        return function (key, value) {
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this);
                ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
                ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
                if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
            }
            else stack.push(value);

            return replacer == null ? value : replacer.call(this, key, value)
        }
    }

    /**
     *
     * @param obj
     * @returns {*}
     */
    utils.stringify = function (obj) {
        return JSON.stringify(obj, serializer(), 2);
    };

    function stringify(obj, replacer, spaces, cycleReplacer) {
        return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }

    /**
     * Takes a number and returns a rounded fixed digit string.
     * Returns an empty string if first parameter is NaN, (-)Infinity or not of type number.
     * If parameter trailing is set to true trailing zeros will be kept.
     *
     * @param {number} num the number
     * @param {number} [digits=3] digit count
     * @param {boolean} [trailing=false] keep trailing zeros
     * @memberOf module:xide/utils/StringUtils
     *
     * @example
     *
     test(fsuxx(-6.8999999999999995), '-6.9');
     test(fsuxx(0.020000000000000004), '0.02');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 1), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     test(fsuxx('muh'), '');
     test(fsuxx(false), '');
     test(fsuxx(null), '');
     test(fsuxx(), '');
     test(fsuxx(NaN), '');
     test(fsuxx(Infinity), '');
     test(fsuxx({bla: 'blub'}), '');
     test(fsuxx([1,2,3]), '');
     test(fsuxx(6.8999999999999995), '6.9');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     *
     *
     * @returns {string}
     *
     */
    utils.round = function (num, digits, trailing) {

        if (typeof num !== 'number' || isNaN(num) || num === Infinity || num === -Infinity) return '';

        digits = ((typeof digits === 'undefined') ? 3 : (parseInt(digits, 10) || 0));

        var f = Math.pow(10, digits);
        var res = (Math.round(num * f) / f).toFixed(digits);

        // remove trailing zeros and cast back to string
        if (!trailing) res = '' + (+res);

        return res;
    };




    /**
     *
     * @param bytes
     * @param si
     * @returns {string}
     */
    utils.humanFileSize = function (bytes, si) {
        var thresh = si ? 1000 : 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = si
            ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1) + ' ' + units[u];
    };

    if (typeof String.prototype.startsWith != 'function') {
        // see below for better implementation!
        String.prototype.startsWith = function (str) {
            return this.indexOf(str) === 0;
        };
    }

    if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
            return this.substring( this.length - str.length, this.length ) === str;
        }
    }

    /**
     *
     * @param str
     * @returns {boolean}
     */
    utils.isNativeEvent = function (str) {
        var _foo = null,//just for having an optimized object map for a native event lookup below
            _nativeEvents = {
                "onclick": _foo,
                "ondblclick": _foo,
                "onmousedown": _foo,
                "onmouseup": _foo,
                "onmouseover": _foo,
                "onmousemove": _foo,
                "onmouseout": _foo,
                "onkeypress": _foo,
                "onkeydown": _foo,
                "onkeyup": _foo,
                "onfocus": _foo,
                "onblur": _foo,
                "onchange": _foo
            };

        if (str in _nativeEvents) {
            return true;
        }
        _nativeEvents = {
            "click": _foo,
            "dblclick": _foo,
            "mousedown": _foo,
            "mouseup": _foo,
            "mouseover": _foo,
            "mousemove": _foo,
            "mouseout": _foo,
            "keypress": _foo,
            "keydown": _foo,
            "keyup": _foo,
            "focus": _foo,
            "blur": _foo,
            "change": _foo
        };

        return str in _nativeEvents;

    };
    /**
     *
     * @param str
     * @returns {boolean}
     *
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isSystemEvent = function (str) {
        for (var t in types.EVENTS) {
            if (types.EVENTS[t] === str) {
                return true;
            }
        }
        return false;
    };

    /**
     *
     * @param arr
     * @param val
     * @returns {number}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.contains = function (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === val) {
                return i;
            }
        }
        return -1;
    };
    /**
     *
     * @param obj
     * @param val
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getObjectKeyByValue = function (obj, val) {
        if (obj && val) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] === val)
                        return prop;
                }
            }
        }
        return null;
    };

    /**
     *
     * @param url
     * @param parameter
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.removeURLParameter = function (url, parameter) {
        //prefer to use l.search if you have a location/link object
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {

            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);

            //reverse iteration as may be destructive
            for (var i = pars.length; i-- > 0;) {
                //idiom for string.startsWith
                if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                    pars.splice(i, 1);
                }
            }

            url = urlparts[0] + '?' + pars.join('&');
            return url;
        } else {
            return url;
        }
    };

    /**
     *
     * @param url
     * @param paramName
     * @param paramValue
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceUrlParam = function (url, paramName, paramValue) {
        if (url.indexOf(paramName) == -1) {
            url += (url.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue;
            return url;
        }
        var pattern = new RegExp('(' + paramName + '=).*?(&|$)');
        var newUrl = url.replace(pattern, '$1' + paramValue + '$2');
        if (newUrl == url) {
            newUrl = newUrl + (newUrl.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue
        }
        return newUrl
    };

    /**
     *
     * @param mount
     * @param path
     * @param encode
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.buildPath = function (mount, path, encode) {

        //fix mount
        var _mount = '' + mount;
        _mount = utils.replaceAll('/', '', mount);
        var _path = '' + path;
        _path = _path.replace('./', '/').replace(/^\/|\/$/g, '');

        var _res = _mount + '://' + _path;
        if (encode === true) {
            return encodeURIComponent(_res);
        }
        return _res;
    };

    /**
     *
     * @param string
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     *
     */
    utils.isImage = function (string) {
        return string.toLowerCase().match(/\.(jpeg|jpg|gif|png)$/) != null;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag3 = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param enumValue
     * @param field
     * @returns {int|*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.disableFlag = function (enumValue, field) {
        enumValue &= ~(1 << field);
        return enumValue;
    };
    /**
     * XApp specific url string cleaner
     * @param string
     * @returns {*}
     */
    utils.cleanUrl = function (string) {
        if (string) {
            string = string.replace('//', '/');
            string = string.replace('./', '/');
            string = string.replace('http:/', 'http://');
            string = string.replace('./', '/');
            string = string.replace('////', '/');
            string = string.replace('///', '/');
            return string;
        }
        return string;
    };
    /**
     * Return data from JSON
     * @param inData
     * @param validOnly
     * @param imit
     * @memberOf module:xide/utils/StringUtils
     * @returns {*}
     */
    utils.getJson = function (inData, validOnly, ommit) {
        try {
            return _.isString(inData) ? json.parse(inData, false) : validOnly === true ? null : inData;
        } catch (e) {
            ommit !== false && console.error('error parsing json data ' + inData + ' error = ' + e);
        }
        return null;
    };

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.fromJson = function (js) {
        if (!_.isString(js)) {
            return js;
        }
        var res = null;
        var didFail = false;
        try {
            res = eval("(" + js + ")", {});
        } catch (e) {
            didFail = true;
        }
        if (didFail) {
            js = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                res = eval("(" + js + ")", {});
            } catch (e) {
                throw new Error(js);
            }
        }
        return res;
    };

    /**
     * String Replace which works with multiple found items. Native aborts on the first needle.
     * @param find
     * @param replace
     * @param str
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceAll = function (find, replace, str) {
        return str ? str.split(find).join(replace) : '';
    };

    /**
     * CI compatible string check for null and length>0
     * @param input
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isValidString = function (input) {
        return input != null && input.length != null && input.length > 0 && input != "undefined"; //Boolean
    };

    /**
     * Dojo style template replacer
     * @param template
     * @param obj
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.substituteString = function (template, obj) {
        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key) {
            return obj[key];
        });
    };

    /**
     *
     * @param expression
     * @param delimiters
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.findOcurrences = function (expression, delimiters) {
        var d = {
            begin: utils.escapeRegExp(delimiters.begin),
            end: utils.escapeRegExp(delimiters.end)
        };
        return expression.match(new RegExp(d.begin + "([^" + d.end + "]*)" + d.end, 'g'));
    };

    /**
     * Escape regular expressions in a string
     * @param string
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.escapeRegExp = function (string) {
        var special = ["[", "]", "(", ")", "{", "}", "*", "+", ".", "|", "||"];
        for (var n = 0; n < special.length; n++) {
            string = string.replace(special[n], "\\" + special[n]);
        }

        return string;
    };
    /**
     *
     * @param str {string} haystack
     * @param hash {Object}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.multipleReplace = function (str, hash) {
        //to array
        var a = [];
        for (var key in hash) {
            a[a.length] = key;
        }
        return str.replace(new RegExp(a.join('\\b|\\b'), 'g'), function (m) {
            return hash[m] || hash["\\" + m];
        });
    };

    /**
     * Flexible replacer, supports multiple replace and safe replace
     *
     * @param str {string} the haystack

     * @param needle {string|null} optional, only needed for simple cases, otherwise its using the 'what' map
     *
     * @param what {string|Object}. When string, its replacing 'needle' with 'what'. If its a hash-map:
     * variable:value, its replacing occurrences of all variables in 'haystack'. In such case, you can specify
     * delimiters to make sure that 'unresolved' variables will be stripped of in the result.
     *
     * @param delimiters {Object} Delimiters to identify variables. This is used to eliminate unresolved variables from
     * the result.
     *
     * @param delimiters.begin {string}
     * @param delimiters.end {string}
     *
     * @returns {string}
     *
     *
     * @example:
     *
     * 1. simple case: replace all '/' with ''
     *
     * return utils.replace('/foo/','/','') //returns 'foo'
     *
     * 2. simple case with multiple variables:
     *
     * return utils.replace('darling, i miss you so much',null,{'miss':'kiss','much':'little'})
     * # darling, i kiss you so little
     *
     * @memberOf module:xide/utils
     * @extends xide/utils
     */
    utils.replace = function (str, needle, what, delimiters) {
        if (!str) {
            return '';
        }
        if (what && _.isObject(what) || _.isArray(what)) {
            if (delimiters) {
                var ocurr = utils.findOcurrences(str, delimiters),
                    replaceAll = utils.replaceAll;
                if (ocurr) {

                    for (var i = 0, j = ocurr.length; i < j; i++) {
                        var el = ocurr[i];

                        //strip off delimiters
                        var _variableName = replaceAll(delimiters.begin, '', el);
                        _variableName = replaceAll(delimiters.end, '', _variableName);
                        str = replaceAll(el, what[_variableName], str);
                    }
                } else {
                    return str;
                }
            } else {
                //fast case
                return utils.multipleReplace(str, what)
            }
            return str;
        }
        //fast case
        return utils.replaceAll(needle, what, str);
    };

    /**
     * Capitalize
     * @param word
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.capitalize = function (word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1);
    };

    /**
     * vsprintf impl. of PHP
     * @param format
     * @param args
     * @example
     // example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1]);
     // returns 1: '1988-08-01'
     * @memberOf module:xide/utils/StringUtils
     */
    utils.vsprintf = function (format, args) {
        return utils.sprintf.apply(this, [format].concat(args));
    };
    /**
     * PHP.js version of sprintf
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @link http://kevin.vanzonneveld.net
     */
    utils.sprintf = function () {
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        var a = arguments,
            i = 0,
            format = a[i++];

        // pad()
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        };

        // justify()
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };

        // formatBaseX()
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {
                    '2': '0b',
                    '8': '0',
                    '16': '0x'
                }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };

        // formatString()
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };

        // doFormat()
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;

            if (substring === '%%') {
                return '%';
            }

            // parse flags
            var leftJustify = false,
                positivePrefix = '',
                zeroPad = false,
                prefixBaseX = false,
                customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                    case ' ':
                        positivePrefix = ' ';
                        break;
                    case '+':
                        positivePrefix = '+';
                        break;
                    case '-':
                        leftJustify = true;
                        break;
                    case "'":
                        customPadChar = flags.charAt(j + 1);
                        break;
                    case '0':
                        zeroPad = true;
                        break;
                    case '#':
                        prefixBaseX = true;
                        break;
                }
            }

            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth === '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }

            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
            } else if (precision === '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }

            // grab value using valueIndex if required?
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
                case 's':
                    return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
                case 'c':
                    return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
                case 'b':
                    return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'o':
                    return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'x':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'X':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
                case 'u':
                    return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'i':
                case 'd':
                    number = +value || 0;
                    number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
                    prefix = number < 0 ? '-' : positivePrefix;
                    value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad);
                case 'e':
                case 'E':
                case 'f': // Should handle locales (as per setlocale)
                case 'F':
                case 'g':
                case 'G':
                    number = +value;
                    prefix = number < 0 ? '-' : positivePrefix;
                    method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                    textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                    value = prefix + Math.abs(number)[method](precision);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                default:
                    return substring;
            }
        };

        return format.replace(regex, doFormat);
    };
    /***
     *
     * @param str
     * @returns {string | null}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.cleanString = function (str) {
        if (!str) {
            return null;
        }
        str = str.replace(/[\r]/g, '')
            .replace(/[\b]/g, '')
            .replace(/[\f]/g, '')
            .replace(/[\n]/g, '')
            .replace(/\\/g, '');
        return str;
    };
    /***
     *
     * @param str {string}
     * @returns {string | null}
     */
    utils.normalizePath = function (str) {
        if (!str) {
            return null;
        }
        str = utils.cleanString(str);//control characters
        str = str.replace('./', '');//file store specifics
        str = str.replace('/.', '');//file store specifics
        str = str.replace(/([^:]\/)\/+/g, "$1");//double slashes
        return str;
    };

    /**
     *
     * @enum
     * @global
     * @memberOf module:xide/types
     */
    types.PATH_PARTS = {
        'DIRNAME': 1,
        'BASENAME': 2,
        'EXTENSION': 4,
        'FILENAME': 8,
        'PATHINFO_ALL': 0
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix {string}
     * @example
     //   example 1: basename('/www/site/home.htm', '.htm');
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1');
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/');
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext');
     //   returns 4: 'path_ext'
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     * @link http://phpjs.org/functions/basename/
     */
    utils.basename = function (path, suffix) {
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1);
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) == suffix) {
            b = b.substr(0, b.length - suffix.length);
        }
        return b;
    };

    /**
     *
     * @param path
     * @param options
     * @example
     //   example 1: pathinfo('/www/htdocs/index.html', 1);
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME');
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION');
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME');
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4);
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL');
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html');
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     * @returns {object}
     * @link http://phpjs.org/functions/pathinfo/
     * @memberOf module:xide/utils/StringUtils
     */
    utils.pathinfo = function (path, options) {
        //  discuss at:
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //        note: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //        note: The way the bitwise arguments are handled allows for greater flexibility
        //        note: & compatability. We might even standardize this code and use a similar approach for
        //        note: other bitwise PHP functions
        //        note: php.js tries very hard to stay away from a core.js file with global dependencies, because we like
        //        note: that you can just take a couple of functions and be on your way.
        //        note: But by way we implemented this function, if you want you can still declare the PATHINFO_*
        //        note: yourself, and then you can use: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //        note: which makes it fully compliant with PHP syntax.
        //  depends on: basename
        var opt = '',
            real_opt = '',
            optName = '',
            optTemp = 0,
            tmp_arr = {},
            cnt = 0,
            i = 0;
        var have_basename = false,
            have_extension = false,
            have_filename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false;
        }
        if (!options) {
            options = 'PATHINFO_ALL';
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName];
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]];
                }
            }
            options = optTemp;
        }

        // Internal Functions
        var __getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : '';
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path.replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmp_arr.dirname = dirName === path ? '.' : dirName;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            tmp_arr.basename = have_basename;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false !== have_extension) {
                tmp_arr.extension = have_extension;
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false === have_filename) {
                have_filename = have_basename.slice(0, have_basename.length - (have_extension ? have_extension.length + 1 :
                        have_extension === false ? 0 : 1));
            }

            tmp_arr.filename = have_filename;
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmp_arr) {
            if (tmp_arr.hasOwnProperty(opt)) {
                cnt++;
                real_opt = opt;
            }
        }
        if (cnt === 1) {
            return tmp_arr[real_opt];
        }

        // Return full-blown array
        return tmp_arr;
    };

    /**
     * PHP.js version of parse_url
     * @param str {string}
     * @param component {string} enum
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.parse_url = function (str, component) {
        //       discuss at: http://phpjs.org/functions/parse_url/
        //      improved by: Brett Zamir (http://brett-zamir.me)
        //             note: original by http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: blog post at http://blog.stevenlevithan.com/archives/parseuri
        //             note: demo at http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: Does not replace invalid characters with '_' as in PHP, nor does it return false with
        //             note: a seriously malformed URL.
        //             note: Besides function name, is essentially the same as parseUri as well as our allowing
        //             note: an extra slash after the scheme/protocol (to allow file:/// as in PHP)
        //        example 1: parse_url('http://username:password@hostname/path?arg=value#anchor');
        //        returns 1: {scheme: 'http', host: 'hostname', user: 'username', pass: 'password', path: '/path', query: 'arg=value', fragment: 'anchor'}
        var query, key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port',
                'relative', 'path', 'directory', 'file', 'query', 'fragment'
            ],
            ini = (this.php_js && this.php_js.ini) || {},
            mode = (ini['phpjs.parse_url.mode'] &&
                ini['phpjs.parse_url.mode'].local_value) || 'php',
            parser = {
                php: /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // Added one optional slash to post-scheme to catch file:/// (should restrict this)
            };

        var m = parser[mode].exec(str),
            uri = {},
            i = 14;
        while (i--) {
            if (m[i]) {
                uri[key[i]] = m[i];
            }
        }

        if (component) {
            return uri[component.replace('PHP_URL_', '')
                .toLowerCase()];
        }
        if (mode !== 'php') {
            var name = (ini['phpjs.parse_url.queryKey'] &&
                ini['phpjs.parse_url.queryKey'].local_value) || 'queryKey';
            parser = /(?:^|&)([^&=]*)=?([^&]*)/g;
            uri[name] = {};
            query = uri[key[12]] || '';
            query.replace(parser, function ($0, $1, $2) {
                if ($1) {
                    uri[name][$1] = $2;
                }
            });
        }
        delete uri.source;
        return uri;
    };

    /***
     *
     * @deprecated
     */
    utils.getMimeTable = function () {
        return {};
    };

    /***
     * @deprecated
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getMimeTable2 = function () {
        return {
            "mid": "fa-file-audio-o",
            "txt": "fa-file-text-o",
            "sql": "fa-cube",
            "js": "fa-cube",
            "gif": "fa-file-picture-o",
            "jpg": "fa-file-picture-o",
            "html": "fa-cube",
            "htm": "fa-cube",
            "rar": "fa-file-zip-o",
            "gz": "fa-file-zip-o",
            "tgz": "fa-file-zip-o",
            "z": "fa-file-zip-o",
            "ra": "fa-file-movie-o",
            "ram": "fa-file-movie-o",
            "rm": "fa-file-movie-o",
            "pl": "source_pl.png",
            "zip": "fa-file-zip-o",
            "wav": "fa-file-audio-o",
            "php": "fa-cube",
            "php3": "fa-cube",
            "phtml": "fa-cube",
            "exe": "fa-file-o",
            "bmp": "fa-file-picture-o",
            "png": "fa-file-picture-o",
            "css": "fa-cube",
            "mp3": "fa-file-audio-o",
            "m4a": "fa-file-audio-o",
            "aac": "fa-file-audio-o",
            "xls": "fa-file-excel-o",
            "xlsx": "fa-file-excel-o",
            "ods": "fa-file-excel-o",
            "sxc": "fa-file-excel-o",
            "csv": "fa-file-excel-o",
            "tsv": "fa-file-excel-o",
            "doc": "fa-file-word-o",
            "docx": "fa-file-word-o",
            "odt": "fa-file-word-o",
            "swx": "fa-file-word-o",
            "rtf": "fa-file-word-o",
            "md": "fa-file-word-o",
            "ppt": "fa-file-powerpoint-o",
            "pps": "fa-file-powerpoint-o",
            "odp": "fa-file-powerpoint-o",
            "sxi": "fa-file-powerpoint-o",
            "pdf": "fa-file-pdf-o",
            "mov": "fa-file-movie-o",
            "avi": "fa-file-movie-o",
            "mpg": "fa-file-movie-o",
            "mpeg": "fa-file-movie-o",
            "mp4": "fa-file-movie-o",
            "m4v": "fa-file-movie-o",
            "ogv": "fa-file-movie-o",
            "webm": "fa-file-movie-o",
            "wmv": "fa-file-movie-o",
            "swf": "fa-file-movie-o",
            "flv": "fa-file-movie-o",
            "tiff": "fa-file-picture-o",
            "tif": "fa-file-picture-o",
            "svg": "fa-file-picture-o",
            "psd": "fa-file-picture-o",
            "ers": "horo.png"
        };
    };
    /***
     *
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     */
    utils.getIconTable = function () {
        return {};
    };


    /**
     *
     * @param string
     * @param overwrite
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     * @deprecated
     */
    utils.urlDecode = function (string, overwrite) {
        if (!string || !string.length) {
            return {}
        }
        var obj = {};
        var pairs = string.split("&");
        var pair, name, value;
        for (var i = 0, len = pairs.length; i < len; i++) {
            pair = pairs[i].split("=");
            name = decodeURIComponent(pair[0]);
            value = decodeURIComponent(pair[1]);
            if (value != null && value === 'true') {
                value = true;
            } else if (value === 'false') {
                value = false;
            }
            if (overwrite !== true) {
                if (typeof obj[name] == "undefined") {
                    obj[name] = value
                } else {
                    if (typeof obj[name] == "string") {
                        obj[name] = [obj[name]];
                        obj[name].push(value)
                    } else {
                        obj[name].push(value)
                    }
                }
            } else {
                obj[name] = value
            }
        }
        return obj;
    };
    /**
     *
     * @param string {string}
     * @returns {object}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getUrlArgs = function (string) {
        var args = {};
        if (string && (string.indexOf('?') != -1 || string.indexOf('&') != -1)) {

            var query = string.substr(string.indexOf("?") + 1) || location.search.substring(1);
            var pairs = query.split("&");
            for (var i = 0; i < pairs.length; i++) {
                var pos = pairs[i].indexOf("=");
                var name = pairs[i].substring(0, pos);
                var value = pairs[i].substring(pos + 1);
                value = decodeURIComponent(value);
                args[name] = value;
            }
        }
        return args;
    };

    /**
     *
     * @param url {string}
     * @returns {object}
     * @deprecated
     */
    utils.urlArgs = function (url) {
        var query = utils.getUrlArgs(url);
        var map = {};
        for (var param in query) {
            var value = query[param],
                options = utils.findOcurrences(value, {
                    begin: "|",
                    end: "|"
                }),
                parameterOptions = null;

            if (options && options.length) {
                //clean value:
                value = value.replace(options[0], '');
                //parse options
                var optionString = options[0].substr(1, options[0].length - 2),
                    optionSplit = optionString.split(','),
                    optionsData = {};

                for (var i = 0; i < optionSplit.length; i++) {

                    var keyValue = optionSplit[i],
                        pair = keyValue.split(':');

                    optionsData[pair[0]] = pair[1];
                }
                parameterOptions = optionsData;
            }

            if (value && value.length) {
                map[param] = {
                    value: value,
                    options: parameterOptions
                }
            }
        }
        return map;
    };

    /**
     *
     * @param fileName {string}
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIcon = function (fileName) {
        if (!fileName) {
            return 'txt2.png';
        }
        var extension = utils.getFileExtension(fileName);
        if (extension) {
            var mime = utils.getMimeTable();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'txt2.png';
    };
    /**
     *
     * @param fileName
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIconClass = function (fileName) {
        if (!fileName) {
            return 'fa-file-o';
        }
        var extension = utils.getFileExtension(fileName);
        if (types.customMimeIcons[extension]) {
            return types.customMimeIcons[extension];
        }
        if (extension) {
            var mime = utils.getMimeTable2();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'fa-file-o';
    };
    /**
     * File extension
     * @deprecated
     * @param fileName {string}
     * @returns {string}
     */
    utils.getFileExtension = function (fileName) {
        if (!fileName || fileName == "") return "";
        var split = utils.getBaseName(fileName).split('.');
        if (split.length > 1) return split[split.length - 1].toLowerCase();
        return '';
    };
    /**
     * Create a basic UUID via with Math.Random
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.createUUID = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4()); //String
    };
    /**
     * Basename
     * @param fileName {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getBaseName = function (fileName) {
        if (fileName == null) return null;
        var separator = "/";
        if (fileName.indexOf("\\") !==-1)
            separator = "\\";
        return fileName.substr(fileName.lastIndexOf(separator) + 1, fileName.length);
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @example

     //   example 1: basename('/www/site/home.htm', '.htm')
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1')
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/')
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext')
     //   returns 4: 'path_ext'

     * @memberOf module:xide/utils/StringUtils
     */
    utils.basename = function basename(path, suffix) {
        //  discuss at: http://locutus.io/php/basename/
        // original by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Ash Searle (http://hexmen.com/blog/)
        // improved by: Lincoln Ramsay
        // improved by: djmix
        // improved by: Dmitry Gorelenkov
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1)
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) === suffix) {
            b = b.substr(0, b.length - suffix.length)
        }

        return b
    };
    /**
     *
     * @param path {string}
     * @param options
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     *
     * @example
     *
     //   example 1: pathinfo('/www/htdocs/index.html', 1)
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME')
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION')
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME')
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4)
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL')
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html')
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     */
    utils.pathinfo = function (path, options) {
        //  discuss at: http://locutus.io/php/pathinfo/
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //      note 1: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //      note 1: The way the bitwise arguments are handled allows for greater flexibility
        //      note 1: & compatability. We might even standardize this
        //      note 1: code and use a similar approach for
        //      note 1: other bitwise PHP functions
        //      note 1: Locutus tries very hard to stay away from a core.js
        //      note 1: file with global dependencies, because we like
        //      note 1: that you can just take a couple of functions and be on your way.
        //      note 1: But by way we implemented this function,
        //      note 1: if you want you can still declare the PATHINFO_*
        //      note 1: yourself, and then you can use:
        //      note 1: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //      note 1: which makes it fully compliant with PHP syntax.


        var basename = utils.basename;
        var opt = '';
        var realOpt = '';
        var optName = '';
        var optTemp = 0;
        var tmpArr = {};
        var cnt = 0;
        var i = 0;
        var haveBasename = false;
        var haveExtension = false;
        var haveFilename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false
        }
        if (!options) {
            options = 'PATHINFO_ALL'
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName]
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]]
                }
            }
            options = optTemp
        }

        // Internal Functions
        var _getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : ''
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path
                .replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmpArr.dirname = dirName === path ? '.' : dirName
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            tmpArr.basename = haveBasename
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveExtension !== false) {
                tmpArr.extension = haveExtension
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveFilename === false) {
                haveFilename = haveBasename.slice(0, haveBasename.length - (haveExtension
                            ? haveExtension.length + 1
                            : haveExtension === false
                            ? 0
                            : 1
                    )
                )
            }

            tmpArr.filename = haveFilename
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmpArr) {
            if (tmpArr.hasOwnProperty(opt)) {
                cnt++;
                realOpt = opt
            }
        }
        if (cnt === 1) {
            return tmpArr[realOpt]
        }

        // Return full-blown array
        return tmpArr
    };

    /**
     *
     * @param input {string}
     * @param allowed {string}
     * @example
     //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>');
     //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
     //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>');
     //   returns 2: '<p>Kevin van Zonneveld</p>'
     //   example 3: strip_tags("<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>", "<a>");
     //   returns 3: "<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>"
     //   example 4: strip_tags('1 < 5 5 > 1');
     //   returns 4: '1 < 5 5 > 1'
     //   example 5: strip_tags('1 <br/> 1');
     //   returns 5: '1  1'
     //   example 6: strip_tags('1 <br/> 1', '<br>');
     //   returns 6: '1 <br/> 1'
     //   example 7: strip_tags('1 <br/> 1', '<br><br/>');
     //   returns 7: '1 <br/> 1'
     * @returns {string}
     */
    utils.strip_tags = function (input, allowed) {
        //  discuss at: http://phpjs.org/functions/strip_tags/
        allowed = (((allowed || '') + '')
            .toLowerCase()
            .match(/<[a-z][a-z0-9]*>/g) || [])
            .join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,
            commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
        return input.replace(commentsAndPhpTags, '')
            .replace(tags, function ($0, $1) {
                return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
            });
    };
    return utils;
});

define('xide/rpc/JsonRPC',[
	"./Service",
    "dojo/errors/RequestError",
	"xide/utils/StringUtils"
], function(Service, RequestError,utils){
	function jsonRpcEnvelope(version){
		return {
			serialize: function(smd, method, data, options){
				//not converted to json it self. This  will be done, if
				//appropriate, at the transport level
	
				var d = {
					id: this._requestId++,
					method: method.name,
					params: data
				};
				if(version){
					d.jsonrpc = version;
				}
				return {
					data: JSON.stringify(d),
					handleAs:'json',
					contentType: 'application/json',
					transport:"POST"
				};
			},
			deserialize: function(obj){
				if ('Error' == obj.name // old xhr
					|| obj instanceof RequestError // new xhr
				){
					obj = utils.fromJson(obj.responseText);
				}
				if(obj.error) {
					var e = new Error(obj.error.message || obj.error);
					e._rpcErrorObject = obj.error;
					return e;
				}
				return obj.result;
			}
		};
	}
    Service.envelopeRegistry.register(
		"JSON-RPC-1.0",
		function(str){
			return str == "JSON-RPC-1.0";
		},
		utils.mixin({namedParams:false}, jsonRpcEnvelope()) // 1.0 will only work with ordered params
	);
    Service.envelopeRegistry.register(
		"JSON-RPC-2.0",
		function(str){
			return str == "JSON-RPC-2.0";
		},
        utils.mixin({namedParams:true }, jsonRpcEnvelope("2.0")) // 2.0 supports named params
	);

});

define('xide/encoding/SHA1',["./_base"], function(base){

	var chrsz=8,	//	change to 16 for unicode.
		mask=(1<<chrsz)-1;

	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function FT(t,b,c,d){
		if(t<20){ return (b&c)|((~b)&d); }
		if(t<40){ return b^c^d; }
		if(t<60){ return (b&c)|(b&d)|(c&d); }
		return b^c^d;
	}
	function KT(t){ return (t<20)?1518500249:(t<40)?1859775393:(t<60)?-1894007588:-899497514; }

	function core(x,len){
		x[len>>5]|=0x80<<(24-len%32);
		x[((len+64>>9)<<4)+15]=len;

		var w=new Array(80), a=1732584193, b=-271733879, c=-1732584194, d=271733878, e=-1009589776;
		for(var i=0; i<x.length; i+=16){
			var olda=a, oldb=b, oldc=c, oldd=d, olde=e;
			for(var j=0;j<80;j++){
				if(j<16){ w[j]=x[i+j]; }
				else { w[j]=R(w[j-3]^w[j-8]^w[j-14]^w[j-16],1); }
				var t = base.addWords(base.addWords(R(a,5),FT(j,b,c,d)),base.addWords(base.addWords(e,w[j]),KT(j)));
				e=d; d=c; c=R(b,30); b=a; a=t;
			}
			a=base.addWords(a,olda);
			b=base.addWords(b,oldb);
			c=base.addWords(c,oldc);
			d=base.addWords(d,oldd);
			e=base.addWords(e,olde);
		}
		return [a, b, c, d, e];
	}

	function hmac(data, key){
		var wa=toWord(key);
		if(wa.length>16){ wa=core(wa, key.length*chrsz); }

		var ipad=new Array(16), opad=new Array(16);
		for(var i=0;i<16;i++){
			ipad[i]=wa[i]^0x36363636;
			opad[i]=wa[i]^0x5c5c5c5c;
		}

		var hash=core(ipad.concat(toWord(data)),512+data.length*chrsz);
		return core(opad.concat(hash), 512+160);
	}

	function toWord(s){
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(32-chrsz-i%32);
		}
		return wa;	//	word[]
	}

	function toHex(wa){
		//	slightly different than the common one.
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((3-i%4)*8+4))&0xF), h.charAt((wa[i>>2]>>((3-i%4)*8))&0xF));
		}
		return s.join("");	//	string
	}

	function _toString(wa){
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(32-chrsz-i%32))&mask));
		}
		return s.join("");	//	string
	}

	function toBase64(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(3-i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*(3-(i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*(3-(i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	public function
	base.SHA1=function(/* String */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		Computes the SHA1 digest of the data, and returns the result according to output type.
		var out=outputType||base.outputTypes.Base64;
		var wa=core(toWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.SHA1._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	return base.SHA1;
});

define('xide/manager/RPCService',[
    'dojo/_base/declare',
    'dojo/_base/kernel',
    'dojo/_base/lang',
    'xide/rpc/Service',
    'xide/rpc/JsonRPC',
    'dojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xide/encoding/SHA1'
], function (declare,dojo,lang, Service, JsonRPC, has, Deferred,utils,types,EventedMixin,SHA1) {
    /**
     * Provides tools to deal with 'persistence' (open files, editors, ..etc to be restored). It also acts as interface.
     * @class module:xide/manager/RPCService
     * @extends module:xide/mixins/EventedMixin
     *
     **/
    return declare("xide.manager.RPCService", [Service,EventedMixin], {
        extraArgs: null,
        signatureField: 'sig',
        signatureToken: null,
        correctTarget: true,
        sync: false,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            var struct = {
                error: err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },
        prepareCall: function () {
            var params = {};
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;

                    this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred();
            options = options || this.defaultOptions;

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this,
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data) {
                deferred.resolve(data);
            };

            var promise = service[serviceClass][method](args);
            promise.then(function (res) {

                //the server has some messages for us
                if (options.checkMessages) {
                    if (res && res.error && res.error.code == 3) {
                        thiz.onMessages(res.error);
                    }
                }

                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (res && res.error && res.error && res.error.code != 0) {
                        thiz.onError(res.error);
                        deferred.reject(res.error);
                        return;
                    }
                }

                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }


                //final delivery
                resolve(res);


            }, function (err) {
                thiz.onError(err);
            });

            return deferred;
        },
        getParameterMap: function (serviceClass, serviceClassMethod) {

            var services = this._smd.services;
            var smd = services[serviceClass + '.' + serviceClassMethod];
            if (smd && smd.parameters) {
                return smd.parameters;
            }
            return [];
        },
        _getRequest: function (method, args) {
            var smd = this._smd;
            var envDef = Service.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || method.params || []).concat(smd.parameters || []);

            if (envDef.namedParams) {
                // the serializer is expecting named params
                if ((args.length == 1) && lang.isObject(args[0])) {
                    // looks like we have what we want
                    args = args[0];
                } else {
                    // they provided ordered, must convert
                    var data = {};
                    var params = method.parameters || method.params;
                    for (var i = 0; i < params.length; i++) {
                        if (typeof args[i] != "undefined" || !params[i].optional) {
                            data[params[i].name] = args[i];
                        }
                    }
                    args = data;
                }
                if (method.strictParameters || smd.strictParameters) {
                    //remove any properties that were not defined
                    for (i in args) {
                        var found = false;
                        for (var j = 0; j < parameters.length; j++) {
                            if (parameters[i].name == i) {
                                found = true;
                            }
                        }
                        if (!found) {
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for (i = 0; i < parameters.length; i++) {
                    var param = parameters[i];
                    if (!param.optional && param.name && args != null && !args[param.name]) {
                        if (param["default"]) {
                            args[param.name] = param["default"];
                        } else if (!(param.name in args)) {
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            } else if (parameters && parameters[0] && parameters[0].name && (args.length == 1) && dojo.isObject(args[0])) {
                // looks like named params, we will convert
                if (envDef.namedParams === false) {
                    // the serializer is expecting ordered params, must be ordered
                    args = Service.toOrdered(parameters, args);
                } else {
                    // named is ok
                    args = args[0];
                }
            }

            if (lang.isObject(this._options)) {
                args = dojo.mixin(args, this._options);
            }

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: this.sync,//dojox.rpc._sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || Service.getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function (method) {
            var args = [];
            var i;
            if (arguments.length == 2 && lang.isArray(arguments[1])) {
                args = arguments[1];
            } else {
                for (i = 1; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            var request = this._getRequest(method, args);
            if (this.correctTarget) {
                request.target = this._smd.target;
            }


            if (this.extraArgs) {
                var index = 0;
                for (var key in this.extraArgs) {

                    request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                    request.target += key + '=' + this.extraArgs[key];
                }
            }
            if (this.signatureToken) {
                request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                var signature = SHA1._hmac(request.data, this.signatureToken, 1);

                /*                  var aParams = {
                 "service": serviceClass + ".get",
                 "path":path,
                 "callback":"asdf",
                 "raw":"html",
                 "attachment":"0",
                 "send":"1",
                 "user":this.config.RPC_PARAMS.rpcUserValue
                 };

                 var pStr  =  dojo.toJson(aParams);
                 var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);

                 console.error('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature);
                 */
                //var pStr  =  dojo.toJson(request.data);

                var signature = SHA1._hmac(request.data, this.signatureToken, 1);
                //console.error('sign ' + request.data + ' with ' +  this.signatureToken + ' to ' + signature);
                request.target += this.signatureField + '=' + signature;
            }

            var deferred = Service.transportRegistry.match(request.transport).fire(request);
            deferred.addBoth(function (results) {
                return request._envDef.deserialize.call(this, results);
            });
            return deferred;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {

            var _service = this,
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.hasMethod(method,serviceClass) && omit === true) {
                debugger;
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },


        /************************************************
         *
         * @param data
         * @returns {*}
         */
        base64_encode: function (data) {
            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        callMethodEx: function (serviceClass, method, args, readyCB, errorCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */

            var thiz = this;
            if (!this[serviceClass] || this[serviceClass][method] == null) {
                if (omitError === true && errorCB) {
                    errorCB({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method + ' in class' + serviceClass]
                    });
                }
                return null;
            }

            /***
             * Build signature
             */
            var params = {};


            /**
             * Mixin mandatory fields
             */
            if (this.config && this.config.RPC_PARAMS) {
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.extraArgs = params;
                this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            }


            this[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }

                if (res && res.error && res.error && res.error.code != 0 && errorCB) {
                    errorCB(res.error);
                    return;
                }
                if (omitError == true) {

                }

            }, function (err) {
                errorCB(err);
            });
        },
        callMethod: function (serviceClass, method, args, readyCB, errorCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            try {
                var thiz = this;
                if (this[serviceClass][method] == null) {
                    if (omitError === true && errorCB) {
                        debugger;
                        errorCB({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                this[serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        console.dir(e);

                    }
                    if (res && res.error && res.error && res.error.code == 1 && errorCB) {
                        errorCB(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        //thiz.publish(types.EVENTS.STATUS,struct ,this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });
            } catch (e) {
                console.error('crash! ' + e);
            }
        }

    });
});
/** @module xide/manager/ManagerBase **/
define('xide/manager/ManagerBase',[
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'xide/utils',
    "dojo/_base/xhr",
    "dojo/_base/kernel"
], function (dcl,EventedMixin,Base,utils,xhr,dojo) {
    /**
     * @class module:xide/manager/ManagerBase
     * @augments module:dojo/Stateful
     * @augments module:xide/mixins/EventedMixin
     * @interface
     */
    var Module =dcl([Base.dcl,EventedMixin.dcl],{
        declaredClass:"xide.manager.ManagerBase",
        /**
         * @type module:xide/manager/ContextBase
         * @member ctx A pointer to a xide context
         */
        ctx: null,
        init: function () {
            this.initReload && this.initReload();
        },
        /**
         *
         * @param title
         * @param scope
         * @param parent
         * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        _getText: function (url,options) {
            var result;
            options = utils.mixin({
                url: url,
                sync: true,
                handleAs: 'text',
                load: function (text) {
                    result = text;
                }
            },options);

            var def = xhr.get(options);
            if(!options.sync){
                return def;
            }
            return '' + result + '';
        },
        /**
         * Return context
         * @returns {module:xcf/manager/Context}
         */
        getContext:function(){
            return this.ctx;
        }
    });

    dcl.chainAfter(Module,'init');
    return Module;
});
/** @module xide/manager/ServerActionBase */
define('xide/manager/ServerActionBase',[
    'dcl/dcl',
    'dojo/_base/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/manager/RPCService',
    'xide/manager/ManagerBase',
    'xide/types',
    'xide/utils'
], function (dcl, declare, has, Deferred, RPCService, ManagerBase, types, utils) {
    var Singleton = null;
    /**
     * Class dealing with JSON-RPC-2, used by most xide managers
     * @class module:xide.manager.ServerActionBase
     * @augments {module:xide/manager/ManagerBase}
     */
    var Implementation = {
        declaredClass: "xide.manager.ServerActionBase",
        serviceObject: null,
        serviceUrl: null,
        singleton: true,
        serviceClass: null,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        base64_encode: function (data) {

            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var self = this;
            if (this.serviceObject.__init) {
                if (this.serviceObject.__init.isResolved()) {
                    return self._runDeferred(serviceClassIn, method, args, options);
                }
                var dfd = new Deferred();
                this.serviceObject.__init.then(function () {
                    self._runDeferred(serviceClassIn, method, args, options).then(function () {
                        dfd.resolve(arguments);
                    });
                });
                return dfd;
            }
            return self._runDeferred(serviceClassIn, method, args, options);
        },
        /**
         * Public main entry, all others below are deprecated
         * @param serviceClassIn
         * @param method
         * @param args
         * @param options
         * @returns {Deferred}
         */
        _runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred(),
                promise;
            options = options || this.defaultOptions;
            //check we the RPC method is in the SMD
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this.getService(),
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data, error) {
                var dfd = deferred;
                if (options.returnProm) {
                    dfd = promise;
                }
                dfd._data = data;
                if (error) {
                    if (options.onError) {
                        return options.onError(error);
                    }
                }
                dfd.resolve(data);
            };

            promise = service[serviceClass][method](args);
            promise.then(function (res) {
                res = res || {};
                var error = res.error || {};
                //the server has some messages for us
                if (options.checkMessages) {
                    if (error && error.code == 3) {
                        thiz.onMessages(error);
                    }
                }
                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (error.code == 1) {
                        options.displayError && thiz.onError(error, serviceClass + '::' + method);
                        deferred.reject(error);
                        return;
                    }
                } else {
                    if (error.code == 1 && options.displayError) {
                        thiz.onError(error, serviceClass + '::' + method);
                    }
                    if (error && error.code && error.code !== 0) {
                        resolve(res, error);
                        return;
                    }
                }
                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }
                resolve(res);
            }, function (err) {
                thiz.onError(err);
            });

            if (options.returnProm) {
                return promise;
            }
            return deferred;
        },
        getService: function () {
            return this.serviceObject;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method, serviceClass) {
            var _service = this.getService(),
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        findServiceUrl: function (declaredClass) {
            var config = window['xFileConfig'];
            if (config && config.mixins) {
                for (var i = 0; i < config.mixins.length; i++) {
                    var obj = config.mixins[i];
                    if (obj.declaredClass === declaredClass && obj.mixin && obj.mixin.serviceUrl) {
                        return decodeURIComponent(obj.mixin.serviceUrl);
                    }
                }
            }
            return null;
        },
        init: function () {
            this.check();
        },
        _initService: function () {
            var thiz = this;
            if (!has('host-browser')) {
                return false;
            }
            try {
                var obj = Singleton;
                if (this.singleton) {
                    if (obj && obj.serviceObject) {
                        this.serviceObject = obj.serviceObject;
                        return;
                    }
                    if (!this.options) {
                        this.options = {};
                    }
                    this.options.singleton = this.singleton;
                }
                if (!this.serviceObject) {
                    if (!this.serviceUrl) {
                        console.error('have no service url : ' + this.declaredClass);
                        return;
                    }
                    var url = decodeURIComponent(this.serviceUrl);
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl), this.options);

                    this.serviceObject.runDeferred = function () {
                        return thiz.runDeferred.apply(thiz, arguments);
                    };


                    this.serviceObject.sync = this.sync;

                    if (this.singleton) {
                        obj.serviceObject = this.serviceObject;
                    }
                    if (this.config) {
                        obj.serviceObject.config = this.config;
                    }
                    !this.ctx.serviceObject && (this.ctx.serviceObject = this.serviceObject);
                }
            } catch (e) {
                console.error('error in rpc service creation : ' + e);
                logError(e);
            }
        },
        check: function () {
            if (!this.serviceObject) {
                this._initService();
            }
        },
        onError: function (err, suffix) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            if (suffix) {
                err.message = suffix + ' -> ' + err.message;
            }
            this.publish(types.EVENTS.ERROR, {
                error: err
            }, this);
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.getService()) {
                return false;
            }
            if (!this.hasMethod(method, serviceClass) && omit === true) {
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },
        prepareCall: function () {
            var params = {};
            //Mixin mandatory fields
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.serviceObject.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                    this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        callMethodEx: function (serviceClassIn, method, args, readyCB, omitError) {
            serviceClassIn = serviceClassIn || this.serviceClass;
            if (!serviceClassIn) {
                console.error('have no service class! ' + this.declaredClass, this);
            }
            //init smd
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            var thiz = this;
            return this.serviceObject[this.getServiceClass(serviceClassIn)][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClassIn);
                    logError(e, 'server method failed ' + e);

                }
                //rpc batch results
                if (res && res.error && res.error.code == 3) {
                    thiz.onMessages(res.error);
                }

                if (res && res.error && res.error && res.error.code != 0) {
                    thiz.onError(res.error);
                    return;
                }
                if (omitError == true) {
                    thiz.publish(types.EVENTS.STATUS, {message: 'Ok!'}, this);
                }

            }, function (err) {
                thiz.onError(err);
            });
        },
        callMethodEx2: function (serverClassIn, method, args, readyCB, omitError) {
            this.check();
            //check this method exists
            if (!this.checkCall(serverClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            return this.serviceObject[this.getServiceClass(serverClassIn)][method](args);
        },
        callMethod: function (method, args, readyCB, omitError) {
            args = args || [[]];
            var serviceClass = this.serviceClass;
            try {
                var thiz = this;
                //method not listed in SMD
                if (this.serviceObject[serviceClass][method] == null) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                this.serviceObject[this.serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, "Error calling RPC method");
                    }
                    //rpc batch call
                    if (res && res.error && res.error.code == 3) {
                        this.onMessages(res.error);
                    }
                    if (res && res.error && res.error && res.error.code == 1) {
                        this.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        this.publish(types.EVENTS.STATUS, struct, this);
                    }
                }.bind(this), function (err) {
                    this.onError(err);
                }.bind(this));
            } catch (e) {
                thiz.onError(e);
                logError(e, "Error calling RPC method");
            }
        }
    };

    var Module = dcl(ManagerBase, Implementation);
    Module.declare = declare(null, Implementation);
    Singleton = Module;
    return Module;
});
define('dstore/Cache',[
	'dojo/_base/array',
	'dojo/when',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'./Store',
	'./Memory',
	'./QueryResults'
], function (arrayUtil, when, declare, lang, Store, Memory, QueryResults) {

	// module:
	//		dstore/Cache


	function cachingQuery(type) {
		// ensure querying creates a parallel caching store query
		return function () {
			var subCollection = this.inherited(arguments);
			var cachingCollection = this.cachingCollection || this.cachingStore;
			subCollection.cachingCollection = cachingCollection[type].apply(cachingCollection, arguments);
			subCollection.isValidFetchCache = this.canCacheQuery === true || this.canCacheQuery(type, arguments);
			return subCollection;
		};
	}

	function init (store) {
		if (!store.cachingStore) {
			store.cachingStore = new Memory();
		}

		store.cachingStore.Model = store.Model;
		store.cachingStore.idProperty = store.idProperty;
	}
	var CachePrototype = {
		cachingStore: null,
		constructor: function () {
			init(this);
		},
		canCacheQuery: function (method, args) {
			// summary:
			//		Indicates if a queried (filter, sort, etc.) collection should using caching
			return false;
		},
		isAvailableInCache: function () {
			// summary:
			//		Indicates if the collection's cachingCollection is a viable source
			//		for a fetch
			return (this.isValidFetchCache && (this.allLoaded || this.fetchRequest)) ||
					this._parent && this._parent.isAvailableInCache();
		},
		fetch: function () {
			return this._fetch(arguments);
		},
		fetchRange: function () {
			return this._fetch(arguments, true);
		},
		_fetch: function (args, isRange) {
			// if the data is available in the cache (via any parent), we use fetch from the caching store
			var cachingStore = this.cachingStore;
			var cachingCollection = this.cachingCollection || cachingStore;
			var store = this;
			var available = this.isAvailableInCache();
			if (available) {
				return new QueryResults(when(available, function () {
					// need to double check to make sure the flag hasn't been cleared
					// and we really have all data loaded
					if (store.isAvailableInCache()) {
						return isRange ?
							cachingCollection.fetchRange(args[0]) :
							cachingCollection.fetch();
					} else {
						return store.inherited(args);
					}
				}));
			}
			var results = this.fetchRequest = this.inherited(args);
			when(results, function (results) {
				var allLoaded = !isRange;
				store.fetchRequest = null;
				// store each object before calling the callback
				arrayUtil.forEach(results, function (object) {
					// store each object before calling the callback
					if (!store.isLoaded || store.isLoaded(object)) {
						cachingStore.put(object);
					} else {
						// if anything is not loaded, we can't consider them all loaded
						allLoaded = false;
					}
				});
				if (allLoaded) {
					store.allLoaded = true;
				}

				return results;
			});
			return results;
		},
		// TODO: for now, all forEach() calls delegate to fetch(), but that may be different
		// with IndexedDB, so we may need to intercept forEach as well (and hopefully not
		// double load elements.
		// isValidFetchCache: boolean
		//		This flag indicates if a previous fetch can be used as a cache for subsequent
		//		fetches (in this collection, or downstream).
		isValidFetchCache: false,
		get: function (id, directives) {
			var cachingStore = this.cachingStore;
			var masterGet = this.getInherited(arguments);
			var masterStore = this;
			// if everything is being loaded, we always wait for that to finish
			return when(this.fetchRequest, function () {
				return when(cachingStore.get(id), function (result) {
					if (result !== undefined) {
						return result;
					} else if (masterGet) {
						return when(masterGet.call(masterStore, id, directives), function (result) {
							if (result) {
								cachingStore.put(result, {id: id});
							}
							return result;
						});
					}
				});
			});
		},
		add: function (object, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				// now put result in cache (note we don't do add, because add may have
				// called put() and already added it)
				var cachedPutResult =
					cachingStore.put(result && typeof result === 'object' ? result : object, directives);
				// the result from the add should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement add
				return result || cachedPutResult;
			});
		},
		put: function (object, directives) {
			// first remove from the cache, so it is empty until we get a response from the master store
			var cachingStore = this.cachingStore;
			cachingStore.remove((directives && directives.id) || this.getIdentity(object));
			return when(this.inherited(arguments), function (result) {
				// now put result in cache
				var cachedPutResult =
					cachingStore.put(result && typeof result === 'object' ? result : object, directives);
				// the result from the put should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement put
				return result || cachedPutResult;
			});
		},
		remove: function (id, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				return when(cachingStore.remove(id, directives), function () {
					return result;
				});
			});
		},
		evict: function (id) {
			// summary:
			//		Evicts an object from the cache
			// any eviction means that we don't have everything loaded anymore
			this.allLoaded = false;
			return this.cachingStore.remove(id);
		},
		invalidate: function () {
			// summary:
			//		Invalidates this collection's cache as being a valid source of
			//		future fetches
			this.allLoaded = false;
		},
		_createSubCollection: function () {
			var subCollection = this.inherited(arguments);
			subCollection._parent = this;
			return subCollection;
		},

		sort: cachingQuery('sort'),
		filter: cachingQuery('filter'),
		select: cachingQuery('select'),

		_getQuerierFactory: function (type) {
			var cachingStore = this.cachingStore;
			return this.inherited(arguments) || lang.hitch(cachingStore, cachingStore._getQuerierFactory(type));
		}
	};
	var Cache = declare(null, CachePrototype);
	Cache.create = function (target, properties) {
		// create a delegate of an existing store with caching
		// functionality mixed in
		target = declare.safeMixin(lang.delegate(target), CachePrototype);
		declare.safeMixin(target, properties);
		// we need to initialize it since the constructor won't have been called
		init(target);
		return target;
	};
	return Cache;
});

/** @module xfile/model/File **/
define('xfile/model/File',[
    "dcl/dcl",
    "xide/data/Model",
    "xide/utils",
    "xide/types"
], function (dcl, Model, utils, types) {
    /**
     * @class module:xfile/model/File
     */
    return dcl(Model, {
        declaredClass:'xfile.model.File',
        getFolder: function () {
            var path = this.getPath();
            if (this.directory) {
                return path;
            }
            return utils.pathinfo(path, types.PATH_PARTS.ALL).dirname;
        },
        getChildren: function () {
            return this.children;
        },
        getParent: function () {
            //current folder:
            var store = this.getStore() || this._S;
            return store.getParent(this);
        },
        getStore: function () {
            return this._store || this._S;
        }
    });
});

/**
 * @module xfile/data/FileStore
 **/
define('xfile/data/Store',[
    "dojo/_base/declare",
    "dojo/_base/lang",
    'dojo/Deferred',
    "xide/mixins/ReloadMixin",
    "xide/manager/ServerActionBase",
    'dstore/Cache',
    'dstore/QueryResults',
    'xide/types',
    'xide/utils',
    'dojo/when',
    'xide/data/TreeMemory',
    'dstore/Trackable',
    'xide/data/ObservableStore',
    'xfile/model/File',
    'xide/lodash'
], function (declare, lang, Deferred, ReloadMixin, ServerActionBase, Cache, QueryResults, types, utils, when, TreeMemory, Trackable, ObservableStore, File, _) {
    var _debug = false;
    /**
     * Constants
     * @type {string}
     */
    var C_ITEM_EXPANDED = "_EX";      // Attribute indicating if a directory item is fully expanded.
    /**
     *
     * A store based on dstore/Memory and additional dstore mixins, used for all xfile grids.
     *
     * ###General
     *
     * - This store is only fetching file listings from the server! Any other file operation is done in
     * by file manager. However, this store is the central database for all files.
     *
     *
     * ###Common features and remarks
     *
     * - works with for multiple grid instances: lists/thumb or tree grids
     * - caches all directory listings, use _loadPath(path,force=true) to drop the cache
     * - all server methods return dojo/Deferred handles
     * - loads path segments recursivly, ie: getItem('./path/subPath/anotherSub');
     *
     * ### Server related
     * #### Requests

     * This part is done in the {link:xide/manager/ServerActionBase} ServerActionBase mixin, wrapped in here as
     * '_request'. This will take care about the possible transports : JSON-RPC-2.0 with a Dojo-SMD envelope or JSONP.
     * Both requests will be signed upon its payload, using this.config.RPC_PARAMETERS(server controlled), if required.
     * At the time of writing, this library has been developed for a PHP and Java-Struts which both support Dojo - SMD.
     * However, you may adjust to REST based environments yourself. Also, when using the
     * supplied XPHP - JSON-RPC-2.0-SMD implementation you can make use of 'batch-requests' to avoid further requests.
     *
     * #### Responses
     *
     * The response arrives here parsed already, no need to do anything but adding it to the store.
     *
     * @class module:xfile/data/FileStore
     * @augments module:xide/manager/ServerActionBase
     * @augments module:dgrid/Memory
     * @augments module:dgrid/Tree
     * @augments module:dgrid/Cache
     * @augments module:xide/mixins/ReloadMixin
     */
    function Implementation() {
        return {
            addDot: true,
            /**
             * 'recursive' will tell the server to run the directory listing recursive for server method 'ls'
             * @type {boolean}
             */
            recursive: false,
            rootSegment: ".",
            Model: File,
            /**
             * @member idProperty {string} sets the unique identifier for store items is set to the 'path' of a file.
             * @public
             */
            idProperty: "path",
            parentProperty: "path",
            parentField: 'parent',
            /**
             * @member mount {string} sets the 'mount' prefix for a VFS. This is needed to simplify the work
             * with paths and needs to be handled separated. By default any request expects full paths as:
             * - root/_my_path
             * - root://_my_path/even_deeper
             * - dropbox/_my_folder
             *
             * This property is is being used to complete a full file path automatically in the request so that only the
             * actual inner path needs to be specified in all methods.
             * By default xfile supports multiple stores in the same application.
             * Each store is created upon mount + store options hash.
             * @public
             */
            mount: 'path',
            /**
             * @member options{Object[]} specifies the store options. The store options are tied to the server. As the store
             * is only relavant for enumerating files through a server method, there are only a couple of options needed:
             *
             * <b>options.fields</b> {int} A enumeration bitmask which specifies the fields to be added for a file or
             * directory node. This is described in link:xfile/types/Types#Fields and again, this is being processed by
             * the server.
             *
             * options.includeList {string} a comma separated list of allowed file extensions, this has priority the
             * exclusion mask.
             *
             * options.excludeList {string} a comma separated list of excluded file extensions
             *
             * This options are set through xfile/manager/Context#defaultStoreOptions which might be overriden
             * through the server controlled xFileConfiguration.mixins global header script tag.
             *
             * @example {
                "fields": 1663,
                "includeList": "*",
                "excludeList": "*"
            }
             * @public
             */
            options: {
                fields: 1663,
                includeList: "*",
                excludeList: "*"    // XPHP actually sets this to ".svn,.git,.idea" which are compatible to PHP's 'glob'
            },
            /**
             * @member serviceUrl {string} the path to the service entry point. There are 2 modes this end-point must
             * provide:
             * - a Dojo compatible SMD
             * - post/get requests with parameters. Currently JSONP & JSON-RPC-1/2.0 is supported.
             *
             * You can set also static SMD (see xide/manager/ServerActionBase) to bypass the SMD output. However,
             * this is being set usually by a server side mixin (in HTML header tag) on the fly!
             * @default null
             * @public
             */
            serviceUrl: null,
            /**
             * @member serviceClass {string} is the server class to be called. By default, this store creates a
             * JSON-RPC-2.0 post request where the methods looks like "XApp_Directory_Service.ls". Other formats are
             * supported in XPHP as well and support also composer autoloaders. If this is a singleton, you can also call
             * this.serviceObject.SERVER_CLASS.SERVER_METHOD(args) through here!
             * @public
             *
             */
            serviceClass: null,
            /**
             * @member singleton {boolean} Sets the ServerActionBase as 'Singleton' at the time of the construction. If there
             * is any other ServerActionBase subclass with the same service url, this will avoid additional requests to
             * fetch a SMD, furthermore, you can call other methods on the server through this here
             * as well: this.serviceObject.SERVER_CLASS.SERVER_METHOD(args)
             * @default true
             * @public
             */
            singleton: true,
            /////////////////////////////////////////////////////////////////////////////
            //
            //  dstore/Tree implementation
            //
            /////////////////////////////////////////////////////////////////////////////
            queryAccessors: true,
            autoEmitEvents: false, // this is handled by the methods themselves
            /*
             * test
             * @param object
             * @returns {boolean}
             */
            mayHaveChildren: function (object) {
                // summary:
                //		Check if an object may have children
                // description:
                //		This method is useful for eliminating the possibility that an object may have children,
                //		allowing collection consumers to determine things like whether to render UI for child-expansion
                //		and whether a query is necessary to retrieve an object's children.
                // object:
                //		The potential parent
                // returns: boolean
                if (object.mayHaveChildren == false) {
                    return false;
                }
                return object.directory === true;
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Private part, might be trashed
            //
            /////////////////////////////////////////////////////////////////////////////
            _lastFilter: null,
            _lastFilterDef: null,
            _lastFilterItem: null,
            _initiated: {
                value: false
            },
            id: null,
            _state: {
                initiated: false,
                filter: null,
                filterDef: null
            },
            isInitiated: function () {
                return this._state.initiated;
            },
            setInitiated: function (initiated) {
                this._state.initiated = initiated;
            },
            _extraSortProperties: {
                name: {
                    ignoreCase: true
                }
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Sorting
            //
            /////////////////////////////////////////////////////////////////////////////

            constructor: function () {
                this.id = utils.createUUID();
            },
            onSorted: function (sorted, data) {
                if (sorted.length == 1 && sorted[0].property === 'name') {
                    var upperCaseFirst = true,
                        directoriesFirst = true,
                        descending = sorted[0].descending;

                    if (directoriesFirst) {
                        function _sort(item) {
                            return upperCaseFirst ? item.name : item.name.toLowerCase();
                        }
                        var grouped = _.groupBy(data, function (item) {
                            return item.directory === true;
                        }, this);

                        data = _.sortBy(grouped['true'], _sort);
                        data = data.concat(_.sortBy(grouped['false'], _sort));
                        if (descending) {
                            data.reverse();
                        }
                    }
                }
                var _back = _.find(data, {
                    name: '..'
                });
                if (_back) {
                    data.remove(_back);
                    data.unshift(_back);
                }

                data = this.onAfterSort(data);

                return data;
            },
            onAfterSort: function (data) {
                var micromatch = this.micromatch;
                if (typeof mm !== 'undefined' && micromatch && data && data[0]) {
                    var what = data[0].realPath ? 'realPath' : 'path';
                    what = 'name';
                    var _items = _.pluck(data, what);
                    var matching = mm(_items, micromatch);
                    data = data.filter(function (item) {
                        if (matching.indexOf(item[what]) === -1) {
                            return null;
                        }
                        return item;
                    });
                    if (this._onAfterSort) {
                        data = this._onAfterSort(data);
                    }
                }
                return data;
            },
            /**
             * Overrides dstore method to add support for case in-sensitive sorting. This requires
             * ignoreCase: true in a this.sort(..) call, ie:
             *
             *  return [{property: 'name', descending: false, ignoreCase: true}]
             *
             * this will involve this._extraSortProperties and is being called by this.getDefaultSort().
             *
             * @param sorted
             * @returns {Function}
             * @private
             */
            _createSortQuerier: function (sorted) {
                var thiz = this;
                return function (data) {
                    data = data.slice();
                    data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
                        for (var i = 0; i < sorted.length; i++) {
                            var comparison;
                            if (typeof sorted[i] == 'function') {
                                comparison = sorted[i](a, b);
                            } else {
                                var property = sorted[i].property;
                                if (thiz._extraSortProperties[property]) {
                                    utils.mixin(sorted[i], thiz._extraSortProperties[property]);
                                }
                                var descending = sorted[i].descending;
                                var aValue = a.get ? a.get(property) : a[property];
                                var bValue = b.get ? b.get(property) : b[property];
                                var ignoreCase = !!sorted[i].ignoreCase;
                                aValue != null && (aValue = aValue.valueOf());
                                bValue != null && (bValue = bValue.valueOf());

                                if (ignoreCase) {
                                    aValue.toUpperCase && (aValue = aValue.toUpperCase());
                                    bValue.toUpperCase && (bValue = bValue.toUpperCase());
                                }
                                comparison = aValue === bValue ? 0 : (!!descending === (aValue === null || aValue > bValue) ? -1 : 1);
                            }
                            if (comparison !== 0) {
                                return comparison;
                            }
                        }
                        return 0;
                    });
                    return thiz.onSorted(sorted, data);
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Public API section
            //
            /////////////////////////////////////////////////////////////////////////////
            _getItem: function (path, allowNonLoaded) {
                //try instant and return when loaded
                //this.getSync(path.replace('./',''))
                if (path === '/') {
                    path = '.';
                }
                var item = this.getSync(path) || this.getSync('./' + path);
                if (item && (this.isItemLoaded(item) || allowNonLoaded == true)) {
                    return item;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Returns a promise or a store item. This works recursively for any path and
             * results in one request per path segment or a single request when batch-requests
             * are enabled on the server.

             * @param path {string} a unique path, ie: ./ | . | ./myFolder | ./myFolder/and_deeper. If the item isn't
             * fully loaded yet, it just returns the item, if you enable 'load' and does the full load.
             * @param load {boolean} load the item if not already
             * @param options {object|null} request options
             *
             * @returns {Object|Deferred|null}
             */
            getItem: function (path, load, options) {
                path = path.replace('./', '');
                if (load == false) {
                    return this._getItem(path);
                } else if (load == true) {
                    //at this point we have to load recursively
                    var parts = path.split('/'),
                        thiz = this,
                        partsToLoad = [],
                        item = thiz.getSync(path);

                    if (item && this.isItemLoaded(item)) {
                        return item;
                    }

                    //new head promise for all underlying this.getItem calls
                    var deferred = new Deferred();
                    var _loadNext = function () {
                        //no additional lodash or array stuff please, keep it simple
                        var isFinish = !_.find(partsToLoad, { loaded: false });
                        if (isFinish) {
                            deferred.resolve(thiz._getItem(path));
                        } else {
                            for (var i = 0; i < partsToLoad.length; i++) {
                                if (!partsToLoad[i].loaded) {
                                    var _item = thiz.getSync(partsToLoad[i].path);
                                    if (_item) {
                                        if (_item.directory === true && thiz.isItemLoaded(_item)) {
                                            partsToLoad[i].loaded = true;
                                            continue;
                                        } else if (_item.directory == null) {
                                            deferred.resolve(_item);
                                            break;
                                        }
                                    }
                                    thiz._loadPath(partsToLoad[i].path, false, options).then(function (items) {
                                        partsToLoad[i].loaded = true;
                                        _loadNext();
                                    }, function (err) {
                                        var _i = Math.abs(Math.min(0, i - 1));
                                        var nextPart = partsToLoad[_i];
                                        var parts = partsToLoad;
                                        if (!nextPart) {
                                            _i = partsToLoad.length - 1;
                                            nextPart = partsToLoad[_i];
                                        }
                                        var _item = thiz.getItem(nextPart.path);
                                        when(thiz.getItem(partsToLoad[_i].path, false), function (_item) {
                                            deferred.resolve(_item, partsToLoad[_i].path);
                                        });
                                    });
                                    break;
                                }
                            }
                        }
                    };

                    //prepare process array
                    var itemStr = '.';
                    for (var i = 0; i < parts.length; i++) {
                        if (parts[i] == '.') {
                            continue;
                        }
                        if (parts.length > 0) {
                            itemStr += '/';
                        }
                        itemStr += parts[i];
                        partsToLoad.push({ path: itemStr, loaded: false });
                    }
                    //fire
                    _loadNext();
                    return deferred;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Return the root item, is actually private
             * @TODO: root item unclear
             * @returns {{path: string, name: string, mount: *, directory: boolean, virtual: boolean, _S: (xfile|data|FileStore), getPath: Function}}
             */
            getRootItem: function () {
                return {
                    _EX: true,
                    path: '.',
                    name: '.',
                    mount: this.mount,
                    directory: true,
                    virtual: true,
                    _S: this,
                    getPath: function () {
                        return this.path;
                    }
                };
            },
            /**
             * back compat, trash
             */
            getItemByPath: function () {
                //console.log('FILESTORE::getItemByPath',arguments);
            },
            /*
             * */
            getParents: function () {
                return null;
            },
            /**
             * Return parent object in sync mode, default to root item
             * @TODO fix root problem
             * @param mixed {string|object}
             */
            getParent: function (mixed) {
                if (!mixed) {
                    return null;
                }
                var item = mixed,
                    result = null;

                if (lang.isString(item)) {
                    item = this.getSync(mixed);
                }

                if (item && item.parent) {
                    result = this.getSync(item.parent);
                }
                return result || this.getRootItem();
            },
            /**
             * Return 'loaded' state
             * @param item
             * @returns {boolean}
             */
            isItemLoaded: function (item) {
                return item && (!item.directory || this._isLoaded(item));
            },
            /**
             * Wrap loadItem
             * @TODO yeah, what?
             * @param item
             * @param force
             * @returns {*}
             */
            loadItem: function (item, force) {
                return this._loadItem(item, force);
            },
            /**
             * Fix an incoming item for our needs, adds the _S(this) attribute and
             * a function to safely return a its path since there are items with fake paths as: './myPath_back_'
             * @param item
             * @private
             */
            _parse: function (item) {
                item._S = this;
                if (!_.isEmpty(item.children)) {
                    _.each(item.children, function (_item) {
                        _item.parent = item.path;
                        this._parse(_item);
                    }, this);

                    item._EX = true;
                    item.children = this.addItems(item.children);
                }
                item.getPath = function () {
                    return this.path;
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  True store impl.
            //
            /////////////////////////////////////////////////////////////////////////////
            /**
             * Here to load an item forcefully (reload/refresh)
             * @param path
             * @param force
             * @param options {object|null}
             * @returns {*}
             * @private
             */
            _loadPath: function (path, force, options) {
                var thiz = this;
                var result = this._request(path, options);
                //console.log('load path : ' + path);
                result.then(function (items) {
                    //console.log('got : items for ' + path, items);
                    var _item = thiz._getItem(path, true);
                    if (_item) {
                        if (force) {
                            if (!_.isEmpty(_item.children)) {
                                thiz.removeItems(_item.children);
                            }
                        }
                        _item._EX = true;
                        thiz.addItems(items, force);
                        _item.children = items;
                        return items;
                    } else {
                        if (options && options.onError) {
                            options.onError('Error Requesting path on server : ' + path);
                        } else {
                            throw new Error('cant get item at ' + path);
                        }
                    }
                }.bind(this),
                    function (err) {
                        console.error('error in load');
                    });

                return result;

            },
            /**
             * Creates an object, throws an error if the object already exists.
             * @param object {Object} The object to store.
             * @param options {Object} Additional metadata for storing the data.  Includes an 'id' property if a specific
             * id is to be used. dstore/Store.PutDirectives?
             * @returns {Number|Object}
             */
            addSync: function (object, options) {
                (options = options || {}).overwrite = false;
                // call put with overwrite being false
                return this.putSync(object, options);
            },
            /**
             * @TODO: what?
             * @param item
             * @param force
             * @returns {Deferred}
             * @private
             */
            _loadItem: function (item, force) {
                var deferred = new Deferred(),
                    thiz = this;
                if (!item) {
                    deferred.reject('need item');
                    return deferred;
                }
                if (force) {
                    //special case on root
                    if (item.path === '.') {
                        thiz.setInitiated(false);
                        thiz.fetchRange().then(function (items) {
                            deferred.resolve({
                                store: thiz,
                                items: items,
                                item: item
                            });
                        });
                    } else {
                        this._loadPath(item.path, true).then(function (items) {
                            deferred.resolve(item);
                        }, function (err) {
                            console.error('error occured whilst loading items');
                            deferred.reject(err);
                        });
                    }
                }
                return deferred;
            },
            _normalize: function (response) {
                if (response && response.items) {
                    return response.items[0];
                }
                return [];
            },
            _isLoaded: function (item) {
                return item && item[C_ITEM_EXPANDED] === true;
            },
            fetch: function () {

            },
            put: function () {

            },
            add: function (item) {
                var _item = this.getSync(item.path);
                if (!_item) {
                    _item = this.addSync(item);
                    _item._S = this;
                    _item.getPath = function () {
                        return this.path;
                    };
                }
                return _item;
            },
            removeItems: function (items) {
                _.each(items, function (item) {
                    if (this.getSync(item.path)) {
                        this.removeSync(item.path);
                    }
                }, this);
            },
            getSync: function (id) {
                var data = this.storage.fullData;
                return data[this.storage.index[id]] || data[this.storage.index[id.replace('./', '')]];
            },
            addItems: function (items) {
                var result = [];
                _.each(items, function (item) {
                    var storeItem = this.getSync(item.path);
                    if (storeItem) {
                        this.removeSync(item.path);
                    }
                    result.push(this.add(item));
                }, this);
                return result;
            },
            open: function (item) {
                var thiz = this;
                if (!this._isLoaded(item)) {
                    item.isLoading = true;
                    return thiz._request(item.path).then(function (items) {
                        item.isLoading = false;
                        item._EX = true;
                        thiz.addItems(items);
                        item.children = items;
                        return items;
                    });
                } else {
                    var deferred = new Deferred();
                    thiz.resetQueryLog();
                    deferred.resolve(item.children);
                    return deferred;
                }
            },
            getDefaultSort: function () {
                return [{ property: 'name', descending: false, ignoreCase: true }];
            },
            filter: function (data) {
                if (data.parent) {
                    this._state.path = data.parent;
                }
                var item = this.getSync(data.parent);
                if (item) {
                    if (!this.isItemLoaded(item)) {
                        item.isLoading = true;
                        this._state.filterDef = this._loadPath(item.path);
                        this._state.filterDef.then(function () {
                            item.isLoading = false;
                        })
                    } else {
                        /*
                        if(item.children) {
                            var total = new Deferred();
                            total.resolve(item.children);
                            this._state.filterDef = total;
                            this._state.filter = data;
                        }
                        */
                        this._state.filterDef = null;
                    }
                }
                delete this._state.filter;
                this._state.filter = data;
                return this.inherited(arguments);
            },
            _request: function (path, options) {
                var collection = this;
                //console.log('requesting ' + path);
                return this.runDeferred(null, 'ls', {
                    path: path,
                    mount: this.mount,
                    options: this.options,
                    recursive: this.recursive
                },
                    utils.mixin({ checkErrors: false, displayError: true }, options)).then(function (response) {
                        var results = collection._normalize(response);
                        collection._parse(results);
                        // support items in the results
                        results = results.children || results;
                        return results;
                    }, function (e) {
                        if (options && options.displayError === false) {
                            return;
                        }
                        logError(e, 'error in FileStore : ' + this.mount + ' :' + e);
                    });
            },
            fetchRangeSync: function () {
                var data = this.fetchSync();
                var total = new Deferred();
                total.resolve(data.length);
                return new QueryResults(data, {
                    totalLength: total
                });
            },
            reset: function () {
                this._state.filter = null;
                this._state.filterDef = null;
                this.resetQueryLog();
            },
            resetQueryLog: function () {
                this.queryLog = [];
            },
            fetchRange: function () {
                // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
                // so we need to extend this as well.
                var results = this._fetchRange();
                return new QueryResults(results.then(function (data) {
                    return data;
                }), {
                        totalLength: results.then(function (data) {
                            return data.length;
                        })
                    });
            },
            initRoot: function () {
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (!this.isInitiated()) {
                    return thiz._request(_path).then(function (data) {
                        if (!thiz.isInitiated()) {
                            _.each(data, thiz._parse, thiz);
                            thiz.setData(data);
                            thiz.setInitiated(true);
                            thiz.emit('loaded');
                        }
                        return thiz.fetchRangeSync(arguments);
                    }.bind(this));
                }
                var dfd = new Deferred();
                dfd.resolve();
                return dfd;
            },
            _fetchRange: function () {
                //special case for trees
                if (this._state.filter) {
                    var def = this._state.filterDef;
                    if (def) {
                        def.then(function (items) {
                            this.reset();
                            if (def && def.resolve) {
                                def.resolve(items);
                            }
                        }.bind(this));
                        return def;
                    }
                }
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (this.isInitiated()) {
                    var _def = thiz.fetchRangeSync(arguments);
                    var resultsDeferred = new Deferred();
                    var totalDeferred = new Deferred();
                    resultsDeferred.resolve(_def);
                    totalDeferred.resolve(_def.length);
                    thiz.emit('loaded');
                    return new QueryResults(resultsDeferred, {
                        totalLength: _def.totalLength
                    });
                }
                return thiz._request(_path).then(function (data) {
                    if (!thiz.isInitiated()) {
                        _.each(data, thiz._parse, thiz);
                        thiz.setData(data);
                        thiz.setInitiated(true);
                        thiz.emit('loaded');
                    }
                    return thiz.fetchRangeSync(arguments);
                }.bind(this));
            },
            getDefaultCollection: function (path) {
                var _sort = this.getDefaultSort();
                if (!path) {
                    return this.sort(_sort);
                } else {
                    return this.filter({
                        parent: path
                    }).sort(_sort);
                }
            },
            getChildren: function (object) {
                // summary:
                //		Get a collection of the children of the provided parent object
                // object:
                //		The parent object
                // returns: dstore/Store.Collection
                return this.root.filter({ parent: this.getIdentity(object) });
            }
        };
    }
    var Module = declare("xfile/data/Store", [TreeMemory, Cache, Trackable, ObservableStore, ServerActionBase.declare, ReloadMixin], Implementation());
    Module.Implementation = Implementation;
    return Module;
});
define('xfile/factory/Store',[
    'xide/types',
    'xide/factory',
    'xide/utils',
    'xfile/data/Store'
], function (types, factory,utils,Store){
    /**
     *
     * @param mount
     * @param options
     * @param config
     * @param optionsMixin
     * @param ctx
     * @param args
     * @returns {*}
     */
    factory.createFileStore = function (mount,options,config,optionsMixin,ctx,args){
        var storeClass = Store;
        options = options || {
            fields:
            types.FIELDS.SHOW_ISDIR |
            types.FIELDS.SHOW_OWNER |
            types.FIELDS.SHOW_SIZE |
            //types.FIELDS.SHOW_FOLDER_SIZE |
            types.FIELDS.SHOW_MIME |
            types.FIELDS.SHOW_PERMISSIONS |
            types.FIELDS.SHOW_TIME |
            types.FIELDS.SHOW_MEDIA_INFO
        };

        utils.mixin(options,optionsMixin);
        var store = new storeClass(utils.mixin({
            data:[],
            ctx:ctx,
            config:config,
            url:config.FILE_SERVICE,
            serviceUrl:config.serviceUrl,
            serviceClass:config.FILES_STORE_SERVICE_CLASS,
            mount:mount,
            options:options
        },args));
        store._state = {
            initiated:false,
            filter:null,
            filterDef:null
        };
        store.reset();
        store.setData([]);
        store.init();
        ctx && ctx.getFileManager().addStore(store);
        return store;
    };
    return factory;

});
/** @module xfile/views/FileGrid **/
define('xfile/views/FileGridLight',[
    "xdojo/declare",
    "dojo/dom-class",
    'dojo/Deferred',
    'xide/types',
    'xide/utils',
    'xide/views/History',
    'xaction/DefaultActions',
    'xfile/views/GridLight',
    'xfile/factory/Store',
    'xide/model/Path',
    'xfile/model/File',
    "xfile/types",
    'xlang/i18'
], function (declare, domClass, Deferred, types, utils, History,DefaultActions,GridLight,factory,Path,File,fTypes,il8){
    

    var ACTION = types.ACTION;
    var DEFAULT_PERMISSIONS = fTypes.DEFAULT_FILE_GRID_PERMISSIONS;
    /**
     * A grid feature
     * @class module:xfile/views/FileGrid
     */
    var GridClass = declare('xfile.views.FileGrid', GridLight, {
        resizeAfterStartup:true,
        menuOrder: {
            'File': 110,
            'Edit': 100,
            'View': 50,
            'Settings': 20,
            'Navigation': 10,
            'Window': 5
        },
        groupOrder: {
            'Clipboard': 110,
            'File': 100,
            'Step': 80,
            'Open': 70,
            'Organize': 60,
            'Insert': 10,
            'Navigation':5,
            'Select': 0
        },
        tabOrder: {
            'Home': 100,
            'View': 50,
            'Settings': 20,
            'Navigation':10
        },
        /**
         *
         */
        noDataMessage: '<span/>',

        /**
         * history {module:xide/views/History}
         */
        _history:null,
        options: utils.clone(types.DEFAULT_GRID_OPTIONS),
        _columns: {},
        toolbarInitiallyHidden:true,
        itemType:types.ITEM_TYPE.FILE,
        permissions: DEFAULT_PERMISSIONS,
        contextMenuArgs:{
            limitTo:null
        },

        /**
         *
         * @param state
         * @returns {*}
         */
        setState:function(state){

            this.inherited(arguments);

            var self = this,
                collection = self.collection,
                path = state.store.path,//'./client/src'
                item = collection.getSync(path),
                dfd = self.refresh();

            try {
                dfd.then(function () {
                    item = collection.getItem(path, true).then(function (item) {
                        self.openFolder(item);
                    });
                });

            }catch(e){
                console.error('error restoring folder state');
            }
            return dfd;
        },
        /**
         *
         * @returns {*|{dir, lang, textDir}|{dir, lang}}
         */
        postMixInProperties: function () {
            var state =this.state;
            if(state){
                if(state._columns){
                    this._columns = state._columns;
                }
            }

            if (!this.columns) {
                this.columns = this.getColumns();
            }

            if(!this.collection && this.state){

                var _store = this.state.store,
                    ctx = this.ctx,
                    store = factory.createFileStore(_store.mount,_store.storeOptions,ctx.config);
                this.collection = store.getDefaultCollection();
            }
            return this.inherited(arguments);
        },
        /**
         *
         * @param state
         * @returns {object}
         */
        getState:function(state) {
            state = this.inherited(arguments) || {};
            state.store = {
                mount:this.collection.mount,
                path:this.getCurrentFolder().path,
                storeOptions:this.collection.options
            };
            state._columns = {};
            _.each(this._columns,function(c){
                state._columns[c.label]= !this.isColumnHidden(c.id);
            },this);
            return state;
        },
        onSaveLayout:function(e){
            var customData = e.data,
                gridState = this.getState(),
                data = {
                    widget:this.declaredClass,
                    state:gridState
                };

            customData.widgets.push(data);
            return customData;
        },
        formatColumn: function (field, value, obj) {
            var renderer = this.selectedRenderer ? this.selectedRenderer.prototype : this;
            if (renderer.formatColumn) {
                var result = renderer.formatColumn.apply(arguments);
                if (result) {
                    return result;
                }
            }
            if(obj.renderColumn){
               var rendered = obj.renderColumn.apply(this,arguments);
                if(rendered){
                    return rendered;
                }

            }
            switch (field) {

                case "fileType":{
                    if(value=='folder'){
                        return il8.localize('kindFolder');
                    }else{
                        if(obj.mime) {
                            var mime = obj.mime.split('/')[1]  ||  "unknown";
                            var key = 'kind' + mime.toUpperCase();
                            var _translated = il8.localize(key);
                            return key !== _translated ? _translated : value;
                        }
                    }
                }
                case "name":{

                    var directory = obj && obj.directory != null && obj.directory === true;
                    var no_access = obj.read === false && obj.write === false;
                    var isBack = obj.name == '..';

                    var folderClass = 'fa-folder';

                    var isLoading = obj.isLoading;
                    if(isLoading){
                        //folderClass = ' fa-spinner fa-spin';
                    }

                    var icon = '';
                    var imageClass = '';
                    var useCSS = false;
                    if (directory) {
                        if (isBack) {
                            imageClass = 'fa fa-level-up itemFolderList';
                            useCSS = true;
                        } else if (!no_access) {
                            imageClass = 'fa ' + folderClass +' itemFolderList';

                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }

                    } else {

                        if (!no_access) {
                            imageClass = 'itemFolderList fa ' + utils.getIconClass(obj.path);
                            useCSS = true;
                        } else {
                            imageClass = 'fa fa-lock itemFolderList';
                            useCSS = true;
                        }
                    }
                    var label = obj.showPath === true ? obj.path : value;
                    if (!useCSS) {
                        return '<img class="fileGridIconCell" src="' + icon + ' "/><span class="fileGridNameCell">' + label + '</span>';
                    } else {
                        return '<span class=\"' + imageClass + '\""></span><span class="name fileGridNameNode" style="vertical-align: middle;padding-top: 0px">' + label + '</span>';
                    }
                }
                case "sizeBytes":
                {
                    return obj.size;
                }
                case "fileType":
                {
                    return utils.capitalize(obj.fileType || 'unknown');
                }
                case "mediaInfo":{
                    return obj.mediaInfo || 'unknown';
                }
                case "owner":
                {
                    if(obj) {
                        var owner = obj.owner;
                        if (owner && owner.user) {
                            return owner.user.name;
                        }
                    }
                    return ""
                }
                case "modified":
                {
                    if(value ===''){
                        return value;
                    }
                    var directory = !obj.directory == null;
                    var dateStr = '';
                    if (directory) {

                    } else {
                        var dateFormat = il8.translations.dateFormat;
                        if(dateFormat){
                            var res = il8.formatDate(value);
                            return res.replace('ms','');
                        }
                    }
                    return dateStr;
                }

            }
            return value;
        },
        getColumns: function () {
            var thiz = this;
            this.columns = [];
            function createColumn(label, field, sortable, hidden) {

                if (thiz._columns[label] != null) {
                    hidden = !thiz._columns[label];
                }

                thiz.columns.push({
                    renderExpando: label === 'Name',
                    label: label,
                    field: field,
                    sortable: sortable,
                    formatter: function (value, obj) {
                        return thiz.formatColumn(field, value, obj);
                    },
                    hidden: hidden
                });
            }
            createColumn('Name', 'name', true, false);
            createColumn('Type', 'fileType', true, true);
            createColumn('Path', 'path', true, true);
            createColumn('Size', 'sizeBytes', true, false);
            createColumn('Modified', 'modified', true, false);
            createColumn('Owner', 'owner', true, true);
            createColumn('Media', 'mediaInfo', true, true);
            return this.columns;
        },
        _focus:function(){
            var thiz = this,
                rows = thiz.getRows();
            if(rows[0]){
                var _row = thiz.row(rows[0]);
                thiz.focus(_row.data);
            }
        },
        setQueryEx: function (item, settings) {
            settings = settings || {
                focus: true,
                delay:1
            };
            if (!item) {
                console.error('bad, no item!');
                return false;
            }

            if (!item.directory) {
                return false;
            }

            this._lastPath = item.getPath();
            var thiz = this,
                grid = thiz,
                dfd = new Deferred();

            if (!grid) {
                console.error('have no grid');
                return;
            }
            var col = thiz.collection,
                focusNext;

            if (item.path === '.') {
                col.resetQueryLog();
                grid.set("collection", col.getDefaultCollection(item.getPath()));
                if(dfd.resolve){
                    dfd.resolve();
                }

            } else {
                col.open(item).then(function (items) {
                    col.resetQueryLog();
                    grid.set("collection", col.getDefaultCollection(item.getPath()));
                    if(dfd.resolve) {
                        dfd.resolve(items);
                    }
                });
            }
            return dfd;
        },
        getCurrentFolder:function(){
            var renderer = this.getSelectedRenderer();
            if(renderer && renderer.getCurrentFolder){
                var _result = renderer.getCurrentFolder.apply(this);
                if(_result){
                    if(_result.isBack){
                        var __result = this.collection.getSync(_result.rPath);
                        if(__result){
                            _result = __result;
                        }
                    }
                    return _result;
                }
            }
            var item = this.getRows()[0];
            if(item && (item._S || item._store)) {
                if(item.isBack==true){
                    var _now = this.getHistory().getNow();
                    if(_now){
                        return this.collection.getSync(_now);
                    }
                }
                //current folder:
                var _parent = item._S.getParent(item);
                if(_parent){
                    return _parent;
                }
            }
            return null;
        },
        getClass:function(){
            return GridClass;
        },
        getHistory:function(){
            if(!this._history){
                this._history = new History();
            }
            return this._history;
        },
        renderArray:function(what,data){
            var items = arguments[0];
            var self = this;
            var firstItem = items[0],
                _parent = null;
            var addBack = !_.find(items,{
                isBack:true
            });
            return this.inherited(arguments);
        },
        startup: function () {
            if (this._started) {
                return;
            }
            var res  = this.inherited(arguments);
            domClass.add(this.domNode, 'xfileGrid');
            this.set('loading',true);
            if (this.permissions) {
                var _defaultActions = DefaultActions.getDefaultActions(this.permissions, this,this);
                _defaultActions = _defaultActions.concat(this.getFileActions(this.permissions));
                this.addActions(_defaultActions);
            }
            this._history = new History();
            var self = this;

            this.subscribe(types.EVENTS.ON_CLIPBOARD_COPY,function(evt){
                if(evt.type === self.itemType){
                    self.currentCopySelection = evt.selection;
                    self.refreshActions();
                }
            });
            
            self._on('noData',function(){

                var _rows = self.getRows();
                if(self._total>0){
                    return;
                }
                var _history = self._history,
                    now = _history.getNow();

                if(!now || now ==='./.'){
                    return;
                }
                self.renderArray([
                    {
                        name: '..',
                        path:'..',
                        rPath:now,
                        sizeBytes:0,
                        size:'',
                        icon:'fa-level-up',
                        isBack:true,
                        modified:'',
                        _S:self.collection,
                        directory:true,
                        _EX:true,
                        children:[],
                        mayHaveChildren:false
                    }
                ]);
            });

            this.on('dgrid-refresh-complete',function(){
                var rows = self.getRows();
                if(rows && rows.length>1){
                    var back = _.find(rows,{
                        isBack:true
                    });
                    if(back){
                        self.removeRow(back);
                        self.refresh();
                    }
                }
            })

            this._on('openFolder',function(evt){
                var isBack = evt.back,
                    item = evt.item,
                    path = item.path,
                    history = self._history;
                self.set('title',item.name);
            });

            //initiate
            if(self.selectedRenderer) {
                res = this.refresh();
                res && res.then(function () {
                    self.set('loading',false);
                    self.setRenderer(self.selectedRenderer,false);
                });
            }
            this._on('onChangeRenderer',function(){
                self.refresh();
            });
            setTimeout(function(){
                self.resize();
            },500);
            return res;
        }
    });

    /**
     *
     * @param ctx
     * @param args
     * @param parent
     * @param register
     * @param startup
     * @param store
     * @returns {widgetProto}
     */
    function createDefault(ctx,args,parent,register,startup,store) {

        args = utils.mixin({
            collection: store.getDefaultCollection(),
            _parent: parent,
            Module:GridClass,
            ctx:ctx
        }, args || {});

        var grid = utils.addWidget(GridClass, args, null, parent, startup, null, null, true, null);
        if (register) {
            ctx.getWindowManager().registerView(grid,false);
        }
        return grid;
    }

    GridClass.prototype.Module = GridClass;
    GridClass.Module = GridClass;
    GridClass.createDefault = createDefault;
    GridClass.DEFAULT_PERMISSIONS = DEFAULT_PERMISSIONS;

    return GridClass;

});
/** @module xfile/Statusbar **/
define('xfile/Statusbar',[
    "xdojo/declare",
    'xide/types',
    'xfile/Breadcrumb'
], function (declare, types, Breadcrumb) {

    //package via declare
    var _class = declare('xgrid.Statusbar', null, {
        statusbar: null,
        setState: function (state) {
            this.showStatusbar(state.statusBar);
            return this.inherited(arguments);
        },
        getState: function (state) {
            state = this.inherited(arguments) || {};
            state.statusBar = this.statusbar != null;
            return state;
        },
        runAction: function (action) {
            if (action.command == types.ACTION.STATUSBAR) {
                this.showStatusbar(this.statusbar ? false : true);
            }
            return this.inherited(arguments);
        },
        showStatusbar: function (show,priorityChange) {

            if (!show && this.statusbar) {
                this._destroyStatusbar();
            } else if (show) {
                this.getStatusbar();
            }

            this.resize();

            if(this._statusbarAction && priorityChange!==true){
                this._statusbarAction.set('value',show);
            }

        },
        _destroyStatusbar: function () {

            this.statusbarRoot && this.statusbarRoot.remove();
            this.statusbar = null;
            this.statusbarRoot = null;
        },
        _statusbarAction:null,
        buildRendering: function () {

            this.inherited(arguments);

            var self = this,
                node = this.domNode;

            this._on('onAddActions', function (evt) {

                var actions = evt.actions,
                    permissions = evt.permissions,
                    action = types.ACTION.STATUSBAR;

                if (!evt.store.getSync(action)) {

                    var _action = self.createAction({
                        label: 'Statusbar',
                        command: action,
                        icon: types.ACTION_ICON.STATUSBAR,
                        tab: 'View',
                        group: 'Show',
                        mixin:{
                            actionType:'multiToggle'
                        },
                        onCreate:function(action){
                            action.set('value',self.statusbar!==null);
                            self._statusbarAction = action;
                        },
                        onChange:function(property,value,action){
                            self.showStatusbar(value,true);

                        }
                    });

                    actions.push(_action);


                    /*
                    var _action = grid.createAction('Statusbar', action,
                        types.ACTION_ICON.STATUSBAR, null, 'View', 'Show', 'item|view', null,
                        null, null, null, null, permissions, node, grid);
                    if (!_action) {

                        return;
                    }
                    */
                    //actions.push(_action);
                }
            });
        },
        getStatusbar: function () {

            if (this.statusbar) {
                return this.statusbar;
            } else {
                return this.createStatusbar();
            }
        },
        onRenderedStatusBar: function (statusbar, root, text) {

            var bc = this.__bc;
            if (!bc && root && root.append) {
                bc = new Breadcrumb({}, $('<div>'));
                root.append(bc.domNode);

                $(bc.domNode).css({
                    "float": "right",
                    "padding": 0,
                    "margin-right": 10,
                    "top": 0,
                    "right": 50,
                    /*"right":0,*/
                    "position": "absolute"
                });

                this.__bc = bc;
                //bc.startup();
                bc.setSource(this);
            }
            if (bc) {

                bc.clear();


                var store = this.collection,
                    cwdItem = this.getCurrentFolder(),
                    cwd = cwdItem ? cwdItem.path : '';

                bc.setPath('.', store.getRootItem(), cwd, store);
            }

        },
        onStatusbarCollapse:function(e){

        },
        createStatusbar: function (where) {

            where = where = this.footer;
            var statusbar = this.statusbar,
                self = this;

            if (!statusbar) {


                var root = $('<div class="statusbar widget" style="width:inherit;padding: 0;margin:0;padding-left: 4px;"></div>')[0];

                where.appendChild(root);



                statusbar = $('<div class="status-bar-text ellipsis" style="display: inline-block;">0 items selected</div>')[0];

                root.appendChild(statusbar);

                var $collapser = $('<div class="status-bar-collapser fa-caret-up" style="" ></div>');
                $collapser.click(function(e){
                    self.onStatusbarCollapse($collapser);
                });
                var collapser  = $collapser[0];
                root.appendChild(collapser);
                this.statusbar = statusbar;
                this.statusbarCollapse = collapser;
                this.statusbarRoot = root;

                this._emit('createStatusbar', {
                    root: root,
                    statusbar: statusbar,
                    collapser: collapser
                })

            }

            return statusbar;

        },
        startup: function () {

            this.inherited(arguments);


            function bytesToSize(bytes) {
                var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                if (bytes == 0) return '0 Byte';
                var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
                return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
            }


            function calculateSize(items) {


                var bytes = 0;
                var sizeStr = '0 KB';
                _.each(items, function (item) {

                    var _bytes = item.sizeBytes || 0;
                    bytes += _bytes;
                });

                if (bytes > 0) {
                    sizeStr = bytesToSize(bytes);
                }

                return {
                    bytes: bytes,
                    sizeStr: sizeStr
                }


            }

            if (!this.hasPermission(types.ACTION.STATUSBAR)) {
                return;
            }
            var statusbar = this.getStatusbar(),
                self = this;

            if (statusbar) {

                function selectionChanged(evt) {
                    var selection = evt.selection || [],
                        nbItems = selection.length,
                        size = calculateSize(selection),
                        text = nbItems + '  ' +self.localize('selected') + ' (' + size.sizeStr + ')';

                    statusbar.innerHTML = text;

                    if (self.onRenderedStatusBar) {
                        self.onRenderedStatusBar(statusbar, self.statusbarRoot, text);
                    }

                }

                this._on('selectionChanged', selectionChanged);
            }
        }
    });

    return _class;
});
define('xfile/config',[
    'dojo/_base/declare',
    'xide/types'
],function(declare,types){

    types.config={

        /**
         * Root node id to for xfile main application, can be ignored for embedded mode.
         */
        ROOT_NODE:'xapp',
        /***
         * The absolute url to server rpc end-point
         */
        FILE_SERVICE:'',
        /***
         * Default start path
         */
        START_PATH:'./',
        /***
         * A pointer to a resolved AMD prototype. This should be xfile/data/FileStore
         */
        FILES_STORE_SERVICE_CLASS:'XCOM_Directory_Service',
        /***
         *  Enables file picker controls, obsolete at the moment
         */
        IS_MEDIA_PICKER:null,
        EDITOR_NODE:null,
        EDITOR_AFTER_NODE:null,
        ACTION_TOOLBAR:null,

        ALLOWED_DISPLAY_MODES:{
            TREE:1,
            LIST:1,
            THUMB:1,
            IMAGE_GRID:1
        },

        LAYOUT_PRESET:null,

        beanContextName:null

    };
    return types
});

define('xfile/manager/FileManagerActions',[
    'dcl/dcl',
    'xide/types',
    'xide/utils'
], function (dcl, types, utils) {
    /**
     * @class xfile.manager.FileManager
     * @augments module:xfile.manager.FileManager
     */
    return dcl(null, {
        declaredClass: "xfile/manager/FileManagerActions",
        /**
         * Publish a file's operations progress event
         * @param event
         * @param terminator
         * @param items
         * @param failed
         * @param extra
         * @private
         */
        _publishProgress: function (event, terminator, items, failed, extra) {
            var _args = {
                terminatorItem: terminator,
                failed: failed,
                items: items || terminator
            };
            utils.mixin(_args, extra);
            this.publish(event, _args, this);
        },
        /**
         *
         * @param operation
         * @param args
         * @param terminator
         * @param items
         * @returns {*}
         */
        doOperation: function (operation, args, terminator, items, extra, dfdOptions) {
            var thiz = this,
                operationCapitalized = operation.substring(0, 1).toUpperCase() + operation.substring(1),
                beginEvent = 'on' + operationCapitalized + 'Begin', //will evaluate for operation 'delete' to 'onDeleteBegin'
                endEvent = 'on' + operationCapitalized + 'End';

            thiz._publishProgress(beginEvent, terminator, items, false, extra);

            var rpcPromise = this.runDeferred(null, operation, args, dfdOptions).then(function () {
                thiz._publishProgress(endEvent, terminator, items, false, extra);
            }, function (err) {
                thiz._publishProgress(endEvent, terminator, items, true, extra);
            });
            return rpcPromise;
        },
        deleteItems: function (selection, options, dfdOptions) {
            return this.doOperation(types.OPERATION.DELETE, [selection, options, true], selection, selection, null, dfdOptions);
        },
        copyItem: function (selection, dst, options, dfdOptions) {
            return this.doOperation(types.OPERATION.COPY, [selection, dst, options, false], selection, selection, {dst: dst}, dfdOptions);
        },
        mkdir: function (mount, path, dfdOptions) {
            return this.doOperation(types.OPERATION.NEW_DIRECTORY, [mount, path], path, null, null, dfdOptions);
        },
        mkfile: function (mount, path, content) {
            return this.doOperation(types.OPERATION.NEW_FILE, [mount, path], path);
        },
        rename: function (mount, src, dst) {
            return this.doOperation(types.OPERATION.RENAME, [mount, src, dst], src);
        },
        moveItem: function (src, dst, include, exclude, mode, dfdOptions) {
            return this.doOperation(types.OPERATION.MOVE, [src, dst, include, exclude, mode], src, null, null, dfdOptions);
        },
        compressItem: function (mount, src, type, readyCB) {
            return this.doOperation(types.OPERATION.COMPRESS, [mount, src, type], src);
        },
        extractItem: function (mount, src, type) {
            return this.doOperation(types.OPERATION.EXTRACT, [mount, src], src);
        }
    });
});

/** @module xfile/manager/FileManager */
define('xfile/manager/FileManager',[
    'dcl/dcl',
    'dojo/_base/kernel',
    'xide/manager/ServerActionBase',
    'xide/types',
    'xfile/types',
    'xide/utils',
    'xide/encoding/SHA1',
    'xide/manager/RPCService',
    'dojo/Deferred',
    'xdojo/has',
    'xfile/manager/FileManagerActions',
    'require',
    'xfile/factory/Store',
    "xide/lodash",
    'xdojo/has!electron?xfile/manager/Electron'
], function (dcl,dojo,ServerActionBase, types, fTypes, utils, SHA1, RPCService, Deferred,has,FileManagerActions,require,StoreFactory,_,Electron) {
    var bases = [ServerActionBase, FileManagerActions];
    if(has('electronx') && Electron){
        bases.push(Electron);
    }
    var debug = false;
    /**
     * @class module:xfile.manager.FileManager
     * @extends {module:xide/manager/ServerActionBase}
     * @extends {module:xide/manager/ManagerBase}
     * @augments {module:xide/mixins/EventedMixin}
     */
    return dcl(bases, {
        declaredClass:"xfile.manager.FileManager",
        /**
         * Returns a new name 
         * @param item
         * @param others
         * @returns {*}
         */
        getNewName:function(item,others){
            var name = item.name.replace('.meta.json','');
            var found = false;
            var i = 1;
            var newName = null;
            while (!found){
                newName = name + '-' + i + '.meta.json';
                var colliding = _.find(others,{
                    name:newName
                });

                if(!colliding){
                    found = true;
                }else{
                    i++;
                }
            }
            return newName;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _uploadXHR: null,
        store: null,
        config: null,
        filesToUpload: null,
        serviceUrl: "index.php",
        serviceClass: 'XCOM_Directory_Service',
        settingsStore: null,
        stores:[],
        getStore:function(mount,cache){
            var store =  _.find(this.stores,{
                mount:mount
            });
            if(store){
                return store;
            }
            return StoreFactory.createFileStore(mount,null,this.config,null,this.ctx);
        },
        addStore:function(store){
            this.stores.push(store);
            store._on('destroy',this.removeStore.bind(this));
        },
        removeStore:function(store){
            var index = this.stores.indexOf(store);
            if(index) {
                this.stores.remove(store);
            }
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard manager interface implementation
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        download: function (src) {
            var selection = [];
            selection.push(src.path);

            if(has('nserver')){
                window.open('../files/'+src.mount+'/'+src.path);
                return;
            }

            var thiz = this;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            var serviceClass = this.serviceClass || 'XCOM_Directory_Service';
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html",
                "attachment": "1",
                "send": "1"
            });
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            delete  aParams['attachment'];
            delete  aParams['send'];
            var pStr = dojo.toJson(JSON.stringify(aParams));
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            window.open(downloadUrl);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  File manager only related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getImageUrl: function (src, preventCache, extraParams) {
            if(has('nserver')){
                return ('../files/'+src.mount+'/'+src.path);
            }
            preventCache = location.href.indexOf('noImageCache') != -1 || preventCache === true || src.dirty === true;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);

            var serviceClass = this.ctx.getFileManager().serviceClass || 'XCOM_Directory_Service';
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=0';
            downloadUrl += '&send=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html"
            });
            utils.mixin(aParams, extraParams);
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            var pStr = dojo.toJson(aParams);
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            if (preventCache) {
                downloadUrl += '&time=' + new Date().getTime();
            }
            if (extraParams) {
                for (var p in extraParams) {
                    downloadUrl += '&' + p + '=' + extraParams[p];
                }
            }
            return downloadUrl;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Upload related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onFileUploadFailed: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;
            if (item.dfd) {
                item.dfd.reject(item);
            }
            thiz.filesToUpload.remove(item);
            thiz.publish(eventKeys.ON_UPLOAD_FAILED, {item: item}, thiz);
        },
        onFileUploaded: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;

            setTimeout(function () {
                var struct1 = {
                    message: '' + item.file.name + ' uploaded to ' + item.dstDir,
                    messageArgs: {}
                };
                thiz.publish(eventKeys.STATUS, struct1, thiz);
                if (item.dfd) {
                    item.dfd.resolve(item);
                }
                thiz.filesToUpload.remove(item);
                thiz.publish(eventKeys.ON_UPLOAD_FINISH, {item: item});
            }, 500);
        },
        getUploadUrl: function () {
            if(has('nserver')){
                return this.serviceUrl.replace('/smd','/upload?');
            }
            var url = '' + decodeURIComponent(this.serviceUrl);

            url = url.replace('view=rpc', 'view=upload');
            url = url.replace('../../../../', './');
            url += '&service=';
            url += this.serviceClass;
            url += '.put&callback=nada';
            return url;
        },
        initXHRUpload: function (item, autoRename, dstDir, mount) {
            var xhr = new XMLHttpRequest();
            var uploadUrl = this.getUploadUrl();
            var uri = '' + uploadUrl;
            uri += '&mount=' + encodeURIComponent(mount);
            uri += '&dstDir=' + encodeURIComponent(dstDir);
            var thiz = this;
            var upload = xhr.upload;
            upload.addEventListener("progress", function (e) {
                if (!e.lengthComputable) {
                    thiz.onFileUploaded(item);
                } else {
                    var struct = {
                        item: item,
                        progress: e
                    };
                    item.isLoading = true;
                    item.dfd.progress(struct);
                }
            }.bind(this), false);

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.responseText && xhr.responseText != 'OK') {
                        var error = utils.getJson(xhr.responseText);
                        if (!error && xhr.responseText.indexOf('Fata Error')) {
                            error = {
                                result: [xhr.responseText],
                                code: 1
                            };
                        }
                        if (error && error.result && _.isArray(error.result) && error.result.length > 0) {
                            var _message = null;
                            for (var i = 0; i < error.result.length; i++) {
                                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.result[i], thiz);
                                _message = error.result[i];
                            }
                            if (_message) {
                                item.error = _message;
                            }
                            thiz.onFileUploadFailed(item);
                            thiz.submitNext();
                            return;
                        }
                        if (error && error.error) {
                            thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.error.message, thiz);
                            thiz.onFileUploadFailed(item);
                        }
                    }
                    thiz.onFileUploaded(item);
                    thiz.submitNext();
                }
            }.bind(this);
            upload.onerror = function () {
                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name, thiz);
            };
            xhr.open("POST", uri, true);
            return xhr;
        },
        hasLoadingItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (this.filesToUpload[i].status == 'loading') {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        /**
         *
         * @param files
         * @param mount
         * @param path
         * @param callee
         * @param view
         * @returns {Deferred[]}
         */
        upload: function (files, mount, path, callee, view) {
            var dfds = [];
            for (var i = 0; i < files.length; i++) {
                var uploadStruct = {
                    file: files[i],
                    dstDir: '' + path,
                    mount: '' + mount,
                    callee: callee,
                    view: callee,
                    dfd: new Deferred()
                };
                dfds.push(uploadStruct['dfd']);
                this.filesToUpload.push(uploadStruct);
            }
            this.submitNext();
            return dfds;
        },
        sendFileUsingFormData: function (xhr, file) {
            var formData = new FormData();
            formData.append("userfile_0", file.file);
            xhr.send(formData);
        },
        sendFileMultipart: function (item) {
            var auto_rename = false;
            item.status = 'loading';
            var xhr = this.initXHRUpload(item, (auto_rename ? "auto_rename=true" : ""), item['dstDir'], item['mount']);
            this.publish(types.EVENTS.ON_UPLOAD_BEGIN,{
                item: item,
                name: item.name
            }, this);
            if (window.FormData) {
                this.sendFileUsingFormData(xhr, item);
            }
        },
        submitNext: function () {
            var item = this.getNextUploadItem();
            if (item) {
                this.sendFileMultipart(item);
            }
        },
        getNextUploadItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (!this.filesToUpload[i].status) {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Error handling
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, err.message.join('<br/>'), this);
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok', this);
                }
            }
            this.publish(types.EVENTS.ERROR, {
                error: err
            }, this);
        },
        addError: function (def) {
            var thiz = this;
            var _cb = function () {
                thiz.onError();
            };
            def.addCallback(_cb);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  pre RPC roundup
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        downloadItem: function (src, readyCB) {
            return this.callMethod(types.OPERATION.DOWNLOAD, [src], readyCB, true);
        },
        downloadTo: function (url, mount, dst, readyCB, dstItem) {
            if (dstItem) {
                var thiz = this;
                var _cb = function (result) {
                    var _failed = false;
                    if (result && result.error && result.error.code == 1) {
                        _failed = true;
                    }
                    thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_END, {
                        terminatorItem: dstItem,
                        failed: _failed
                    }, this);

                    readyCB(arguments);
                };
                thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_BEGIN, {
                    dst: dstItem,
                    url: url,
                    items: [dstItem]
                }, this);
            } else {
                console.log('download from remote url have no dest item');
            }
            return this.callMethod(types.OPERATION.DOWNLOAD_TO, [url, mount, dst], _cb, true);
        },
        find: function (mount, conf, readyCB) {
            try {
                return this.callMethod(types.OPERATION.FIND, [mount, conf], readyCB, true);
            } catch (e) {
                logError(e,'find');
            }
        },
        getContent: function (mount, path, readyCB, emit) {
            if(this.getContentE){
                var res = this.getContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            if(has('php')) {
                var _path = this.serviceObject.base64_encode(utils.buildPath(mount, path, true));
                return this.callMethod(types.OPERATION.GET_CONTENT, [_path, false, false], readyCB, false);
            }else{
                return this._getText(require.toUrl(mount).replace('main.js','') + '/' + path,{
                    sync: false,
                    handleAs: 'text'
                }).then(function(res){
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, 'error running RPC');
                    }
                });
            }
        },
        setContent: function (mount, path, content, readyCB) {
            this.publish(types.EVENTS.ON_CHANGED_CONTENT, {
                'mount': mount,
                'path': path,
                'content': content
            });
            this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                text: "Did save file : " + mount + '://' + path
            });
            if(this.setContentE){
                var res = this.setContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            return this.callMethod(types.OPERATION.SET_CONTENT, [mount, path, content], readyCB, true);
        },
        onMessages: function (res) {
            var events = utils.getJson(res.events);
            if (events && _.isArray(events)) {
                for (var i = 0; i < events.length; i++) {
                    var struct = {
                        path: events[i].relPath
                    };
                    utils.mixin(struct, events[i]);
                    this.publish(events[i].clientEvent, struct, this);
                }
            }
        },
        onErrors: function (res) {},
        init:function(){
            this.stores = [];
            this.filesToUpload = [];
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  RPC helpers
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        callMethodEx: function (serverClassIn, method, args, readyCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = serverClassIn || this.serviceClass;
            var thiz = this;
            if (!this.serviceObject[serviceClass][method]) {
                if (omitError === true) {
                    this.onError({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method]
                    });
                }
                return null;
            }
            /***
             * Build signature
             */
            var params = {};
            params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
            /**
             * Mixin mandatory fields
             */
            params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
            this.serviceObject.extraArgs = params;
            this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
            this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            this.serviceObject[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }
                if (res && res.error && res.error.code == 3) {
                    setTimeout(function () {
                        thiz.onMessages(res.error);
                    }, 50);
                }

                if (res && res.error && res.error && res.error.code !== 0) {
                    thiz.onError(res.error);
                    return;
                }

                thiz.publish(types.EVENTS.STATUS, {
                    message: 'Ok!'
                }, this);

            }, function (err) {
                thiz.onError(err);
            });


        },
        callMethod: function (method, args, readyCB, omitError) {
            var thiz = this;
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = this.serviceClass;
            try {
                if (!this.serviceObject[serviceClass][method]) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                var dfd = this.serviceObject[this.serviceClass][method](args);
                dfd.then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        logError(e, 'error running RPC');

                    }
                    //@TODO: batch, still needed?
                    if (res && res.error && res.error.code == 3) {
                        setTimeout(function () {
                            thiz.onMessages(res.error);
                        }, 50);
                    }

                    if (res && res.error && res.error && res.error.code == 1) {
                        thiz.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        thiz.publish(types.EVENTS.STATUS, struct, this);
                    }
                }, function (err) {
                    thiz.onError(err);
                });
                return dfd;
            } catch (e) {
                console.error('crash calling method' + e,arguments);
                thiz.onError(e);
                logError(e,'error ');
            }
        },
        __initService: function () {
            this.filesToUpload = [];
            if (!this.serviceObject) {
                if(this.serviceUrl) {
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl));
                    this.serviceObject.config = this.config;
                }
            }
        }
    });
});
/** @mixin xide/mixin/VariableMixin **/
define('xide/mixins/VariableMixin',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/utils'
], function (dcl,declare,utils) {

    var Implementation = {
        /**
         *
         * @param what
         * @param variables
         * @param delimitters
         * @returns {*}
         */
        resolve:function(what,variables,delimitters){
            variables = variables || this.resourceVariables || this.ctx.getResourceManager().getResourceVariables() || null;
            delimitters = delimitters || this.variableDelimiters || null;
            return utils.replace(what,null,variables,delimitters);
        }
    }

    /**
     * Mixin to resolve resource variables in strings.
     * Currently stub
     */
    var Module = declare("xide/mixins/VariableMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});
/** @module xide/manager/ResourceManager **/
define('xide/manager/ResourceManager',[
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    'xide/mixins/VariableMixin'
], function (dcl,ServerActionBase, utils, VariableMixin) {
    /**
     *
     * Resource manager which provides:
     *
     * - Resolving variables in strings
     * - Loading & unloading of resources: CSS,JS, Blox, API-Docs and plugins
     *
     * @class xide.manager.ResourceManager
     */
    return dcl([ServerActionBase,VariableMixin.dcl], {
        declaredClass:"xide.manager.ResourceManager",
        serviceClass: "XApp_Resource_Service",
        resourceData: null,
        resourceVariables: null,
        getResourceVariables:function(){
            return this.resourceVariables;
        },
        setVariable: function (variableName,value) {
            return this.resourceVariables[variableName]=value;
        },
        getVariable: function (variableName) {
            return this.resourceVariables[variableName];
        },
        init: function () {
            if (!this.resourceVariables) {
                this.resourceVariables = {};
            }
        },
        replaceVariables: function (string, variables) {
            
            return utils.multipleReplace('' + string, variables || this.resourceVariables);
        }
    });
});
define('xfile/manager/MountManager',[
    'dcl/dcl',
    "dojo/_base/lang",
    "xide/manager/ResourceManager",
    "xide/mixins/ReloadMixin",
    "xide/mixins/EventedMixin",
    "xide/types",
    'xide/utils',
    'dojo/Deferred'
], function (dcl, lang, ResourceManager, ReloadMixin, EventedMixin, types, utils,Deferred) {
    return dcl([ResourceManager, EventedMixin.dcl, ReloadMixin.dcl], {
        declaredClass: "xfile.manager.MountManager",
        serviceClass: "XApp_Resource_Service",
        mountData: null,
        didReload: false,
        editMount: function (mount) {
            /*
            if (!mount) {
                return;
            }
            if (mount.type === 'FILE_PROXY') {
                this.registerLocalMount(mount);
            } else if (mount.type === 'REMOTE_FILE_PROXY') {

                if (has('remote-vfs')) {
                    if (mount.adapter === 'Ftp') {
                        this.registerFTP(mount);
                    }
                    if (mount.adapter === 'Sftp') {
                        this.registerSFTP(mount);
                    }
                    if (mount.adapter === 'Dropbox') {
                        this.registerDropbox(mount);
                    }
                    if (mount.adapter === 'Webdav') {
                        this.registerWebDav(mount);
                    }
                }
            }
            */
        },
        removeMount: function (mount) {
            /*
            if (!mount) {
                return;
            }
            var thiz = this;
            var onOk = function () {
                var _cb = function () {
                    thiz.ls(function (data) {
                        thiz.onMountDataReady(data)
                    });
                };
                thiz.removeResource(mount, false, _cb);

            };

            var dlg = new FileDeleteDialog({
                title: 'Remove ' + mount.name,
                config: this.config,
                delegate: {
                    onOk: function () {
                        onOk();
                    }
                },
                ctx: this.ctx,
                titleBarClass: 'ui-state-error',
                inserts: [{
                    query: '.dijitDialogPaneContent',
                    insert: '<div><span class="fileManagerDialogText">Do you really want to remove this item' + '?</span></div>',
                    place: 'first'
                }]

            });
            domClass.add(dlg.domNode, 'fileOperationDialog');
            dlg.show();
            dlg.addActionButtons();
            dlg.fixHeight();
            dlg.resize();
            setTimeout(function () {
                dlg.resize();
            }, 1000);
            */
        },
        getMounts: function () {
            return this.mountData;
        },
        _onDialogOk: function (dlg, data, mount) {
            var options = utils.toOptions(data);
            var thiz = this;

            var isUpdate = mount.name != null;

            //build resource object
            var resourceObject = {
                "class": "cmx.types.Resource",
                "enabled": true
            };

            //merge options to resource config
            for (var i = 0; i < options.length; i++) {
                var option = options[i];
                if (option.user == null) {
                    resourceObject[option.name] = option.value;//std resource field
                } else {

                    //we put adapter specific fields into the resource's 'config' field
                    if (!resourceObject.config) {
                        resourceObject.config = {};
                    }
                    resourceObject.config[option.name] = option.value;
                }
            }

            //complete resource config
            var label = '';
            if (resourceObject.label) {
                label = resourceObject.label;
            } else if (resourceObject.config.label) {
                label = resourceObject.config.label;
            }

            resourceObject.name = '' + (mount.name != null ? mount.name : label.toLowerCase());

            if (resourceObject.config.type === 'FILE_PROXY') {
                resourceObject.path = '' + resourceObject.path + '';//VFS Local adjustment
                lang.mixin(resourceObject, resourceObject.config);
            } else if (resourceObject.config.type === 'REMOTE_FILE_PROXY') {
                resourceObject.path = resourceObject.name + '://';//VFS Remote adjustment
            }
            var _cb = function () {
                thiz.ls(function (data) {
                    thiz.onMountDataReady(data)
                });
            };
            if (!isUpdate) {
                this.createResource(resourceObject, false, _cb);
            } else {
                this.updateResource(resourceObject, false, _cb);
            }

        },
        registerLocalMount: function (mount) {
/*
            var name = mount ? mount.name : '';
            var path = mount ? mount.path : '';
            if (mount && mount.config && mount.config.path) {
                path = mount.config.path;
            }
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: name ? 'Edit Mount ' + name : 'New Local Mount',
                style: 'max-width:400px;min-height:300px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: name
                    }),
                    utils.createCI('path', 13, '', {
                        group: 'Common',
                        title: 'Path',
                        value: path
                    }),
                    utils.createCI('type', 13, '', {
                        visible: false,
                        value: "FILE_PROXY"
                    })
                ]
            });
            actionDialog.show();
            */
        },
        registerFTP: function (mount) {
/*
            mount = mount || {};
            var config = mount.config || {};


            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: mount.name ? 'Edit Ftp ' + mount.name : 'New Ftp',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: mount.name

                    }),
                    xide.utils.createCI('root', 13, '', {
                        group: 'Ftp',
                        title: 'Start Path',
                        value: config.root,
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Ftp'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'Ftp',
                        title: 'Host',
                        user: {
                            config: true
                        },
                        value: config.host
                    }),
                    xide.utils.createCI('username', 13, '', {
                        group: 'Ftp',
                        title: 'User',
                        user: {
                            config: true
                        },
                        value: config.username
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'Ftp',
                        title: 'Password',
                        user: {
                            config: true
                        },
                        value: config.password
                    }),
                    xide.utils.createCI('passive', 0, '', {
                        group: 'Ftp',
                        title: 'Passive',
                        user: {
                            config: true
                        },
                        value: config.passive
                    }),
                    xide.utils.createCI('ssl', 0, '', {
                        group: 'Ftp',
                        title: 'SSL',
                        user: {
                            config: true
                        },
                        value: config.ssl != null ? config.ssl : false
                    }),
                    xide.utils.createCI('port', 13, '', {
                        group: 'Ftp',
                        title: 'Port',
                        user: {
                            config: true
                        },
                        value: config.port != null ? config.port : 21
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerSFTP: function (mount) {
            /*
            mount = mount || {};
            var config = mount.config || {};


            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: mount.name ? 'Edit Ftp ' + mount.name : 'New Ftp',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: mount.name

                    }),
                    xide.utils.createCI('root', 13, '', {
                        group: 'SFtp',
                        title: 'Start Path',
                        value: config.root,
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Sftp'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'SFtp',
                        title: 'Host',
                        user: {
                            config: true
                        },
                        value: config.host
                    }),
                    xide.utils.createCI('username', 13, '', {
                        group: 'SFtp',
                        title: 'User',
                        user: {
                            config: true
                        },
                        value: config.username
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'SFtp',
                        title: 'Password',
                        user: {
                            config: true
                        },
                        value: config.password
                    }),
                    xide.utils.createCI('port', 13, '', {
                        group: 'SFtp',
                        title: 'Port',
                        user: {
                            config: true
                        },
                        value: config.port != null ? config.port : 22
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerDropbox: function (mount) {
            /*
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: 'New Dropbox',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data, mount);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'Name',
                        value: 'Dropbox1'

                    }),
                    xide.utils.createCI('pathPrefix', 13, '', {
                        group: 'Common',
                        title: 'Start Path',
                        user: {
                            config: true
                        }

                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'Dropbox'
                    }),
                    xide.utils.createCI('token', 13, '', {
                        group: 'Dropbox',
                        title: 'Token',
                        user: {
                            config: true
                        },
                        value: 'h16UVItP7qQAAAAAAAAABP3qmBJFOHj3fA5ffKyaHH-j7HCLvFOceZxhENV0sy24'
                    }),
                    xide.utils.createCI('appname', 13, '', {
                        group: 'Dropbox',
                        title: 'App Name',
                        user: {
                            config: true
                        },
                        value: 'xapp_local'
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })

                ]
            });
            actionDialog.show();
            */
        },
        registerWebDav: function () {
            /*
            var thiz = this;
            var actionDialog = new CIActionDialog({
                title: 'New Webdav',
                style: 'max-width:400px',
                delegate: {
                    onOk: function (dlg, data) {
                        thiz._onDialogOk(dlg, data);
                    }
                },
                cis: [
                    xide.utils.createCI('label', 13, '', {
                        group: 'Common',
                        title: 'name'
                    }),
                    xide.utils.createCI('pathPrefix', 13, '', {
                        group: 'Common',
                        title: 'Start Path'
                    }),
                    xide.utils.createCI('adapter', 13, '', {
                        visible: false,
                        value: 'WebDav'
                    }),
                    xide.utils.createCI('host', 13, '', {
                        group: 'WebDav',
                        title: 'Host'
                    }),
                    xide.utils.createCI('baseUri', 13, '', {
                        group: 'WebDav',
                        title: 'Base URI'
                    }),
                    xide.utils.createCI('userName', 13, '', {
                        group: 'WebDav',
                        title: 'User Name'
                    }),
                    xide.utils.createCI('password', 13, '', {
                        group: 'WebDav',
                        title: 'Password'
                    }),
                    xide.utils.createCI('type', 13, '', {
                        visible: false,
                        value: "REMOTE_FILE_PROXY"
                    })
                ]
            });
            actionDialog.show();
            */
        },
        onMountDataReady: function (data) {
            this.mountData = data;
            this.publish(types.EVENTS.ON_MOUNT_DATA_READY, {data: data});
            var thiz = this;
            setTimeout(function () {
                thiz.publish(types.EVENTS.ON_MOUNT_DATA_READY, {data: data});
            }, 4000);
        },
        check: function () {
            if (!this.serviceObject)
                this._initService();
        },
        /**
         * Callback when context initializes us
         */
        init: function () {
            if (this.ctx.getFileManager()) {
                this.serviceObject = this.ctx.getFileManager().serviceObject;
            }
        },
        /////////////////////////////////////////////////////////////////////////////////
        //
        //  Server Methods
        //
        //////////////////////////////////////////////////////////////////////////////////
        createResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'createResource', [resource, test], readyCB, true);
        },
        removeResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'removeResource', [resource, true], readyCB, true);
        },
        updateResource: function (resource, test, readyCB) {
            return this.callMethodEx(null, 'updateResource', [resource, true], readyCB, true);
        },

        ls: function (readyCB) {
            function data(_data){
                this.mountData = _data;
                this.onMountDataReady(_data);
                if (readyCB) {
                    readyCB(_data);
                }
            }
            if(!_.isEmpty(this.prefetch)){
                var dfd = new Deferred();
                dfd.resolve(this.prefetch);
                data.apply(this,[this.prefetch]);
                delete this.prefetch;
                return dfd;
            }

            return this.runDeferred(null, 'ls', []).then(data.bind(this));
        }
    });
});
/**
 * @module xfile/data/DriverStore
 **/
define('xfile/data/DriverStore',[
    "dojo/_base/declare",
    'dojo/Deferred',
    'xide/data/ObservableStore',
    'xide/data/TreeMemory',
    "xfile/data/Store",
    "xide/manager/ServerActionBase",
    "xide/utils"
], function (declare, Deferred, ObservableStore, TreeMemory, Store, ServerActionBase, utils) {
    var Implementation = Store.Implementation;

    return declare('driverFileStore', [TreeMemory, ObservableStore, ServerActionBase.declare], utils.mixin(Implementation(), {
        driver: null,
        addDot: false,
        rootSegment: "/",
        getRootItem: function () {
            var root = this._root;
            if (root) {
                return root;
            }
            this._root = {
                _EX: false,
                path: '/',
                name: '/',
                mount: this.mount,
                directory: true,
                virtual: true,
                _S: this,
                getPath: function () {
                    return this.path;
                }
            };
            return this._root;
        },
        _filter: function (items) {
            return items;
        },
        _request: function (path) {
            var collection = this;
            var self = this;
            if (path === '.' || path === '/') {
                var result = new Deferred();
                var dfd = self.driver.callCommand('LSProg', {
                    override: {
                        args: ["/*"]
                    }
                });
                dfd.then(function (data) {
                    var files = data.files;
                    _.each(files, function (file) {
                        file.parent = ".";
                    });
                    files = self._filter(files);
                    var response = {
                        items: [{
                            mount: "root",
                            path: "/",
                            children: files,
                            name: "/",
                            isDir: true
                        }]
                    };

                    var results = collection._normalize(response);
                    self._parse(results);
                    results = results.children || results;
                    result.resolve(results);
                });
                return result;
            } else {
                var result = new Deferred();
                var arg = path + ( self.glob || "/*");
                var dfd = self.driver.callCommand('LSProg', {
                    override: {
                        args: [arg]
                    }
                });
                dfd.then(function (data) {
                    var files = data.files;
                    _.each(files, function (file) {
                        file.parent = path;
                    });
                    files = self._filter(files);
                    var response = {
                        items: [{
                            mount: "root",
                            path: path,
                            children: files,
                            isDir: true
                        }]
                    };
                    var results = collection._normalize(response);
                    self._parse(results);
                    results = results.children || results;
                    result.resolve(results);
                });
                return result;
            }
        }
    }));
});
define('xfile/mainr.js',[
    "dojo/_base/kernel",
    'dojo/Stateful',
    'dojo/query',
    'dojo/cache',
    'dojo/window',
    'xgrid/ListRenderer',
    'xfile/types',
    'xfile/component',
    'xfile/views/GridLight',
    'xfile/views/FileGridLight',
    'xfile/FileActions',
    'xfile/Statusbar',
    'xfile/ThumbRenderer',
    'xfile/types',
    'xfile/component',
    'xfile/config',
    'xfile/model/File',
    'xfile/manager/FileManager',
    'xfile/manager/MountManager',
    'xdocker/Docker2',
    'wcDocker/docker',
    'dstore/Memory',
    'dgrid/Tree',
    'dgrid/Grid',
    'xide/Keyboard',
    'xfile/data/DriverStore'
], function(){});

