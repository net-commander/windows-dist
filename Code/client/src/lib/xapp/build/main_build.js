require.config({"config":{"delite/theme":{"layersMap":{"delite/themes/{{theme}}/common.css":"themes/layer_{{theme}}.css","deliteful/Accordion/themes/{{theme}}/Accordion.css":"themes/layer_{{theme}}.css","xdeliteful/Script.css":"themes/layer_{{theme}}.css","xdeliteful/Bar/themes/Bar.css":"themes/layer_{{theme}}.css","deliteful/list/List/themes/{{theme}}/List.css":"themes/layer_{{theme}}.css","delite/Scrollable/themes/{{theme}}/Scrollable.css":"themes/layer_{{theme}}.css","deliteful/ProgressBar/themes/{{theme}}/ProgressBar.css":"themes/layer_{{theme}}.css","deliteful/StarRating/themes/{{theme}}/StarRating.css":"themes/layer_{{theme}}.css","xdeliteful/Button/themes/{{theme}}/Button.css":"themes/layer_{{theme}}.css","deliteful/LinearLayout/themes/{{theme}}/LinearLayout.css":"themes/layer_{{theme}}.css","deliteful/SidePane/themes/{{theme}}/SidePane.css":"themes/layer_{{theme}}.css","deliteful/Panel/themes/{{theme}}/Panel.css":"themes/layer_{{theme}}.css","deliteful/ViewStack/themes/{{theme}}/ViewStack.css":"themes/layer_{{theme}}.css","deliteful/ProgressIndicator/themes/{{theme}}/ProgressIndicator.css":"themes/layer_{{theme}}.css","deliteful/Switch/themes/{{theme}}/Switch.css":"themes/layer_{{theme}}.css","deliteful/ToggleButton/themes/{{theme}}/ToggleButton.css":"themes/layer_{{theme}}.css","deliteful/RadioButton/themes/{{theme}}/RadioButton.css":"themes/layer_{{theme}}.css","deliteful/Checkbox/themes/{{theme}}/Checkbox.css":"themes/layer_{{theme}}.css","deliteful/Select/themes/{{theme}}/Select.css":"themes/layer_{{theme}}.css","deliteful/Combobox/themes/{{theme}}/Combobox.css":"themes/layer_{{theme}}.css","delite/DialogUnderlay/themes/{{theme}}/DialogUnderlay.css":"themes/layer_{{theme}}.css","deliteful/Slider/themes/{{theme}}/Slider.css":"themes/layer_{{theme}}.css","deliteful/Button/themes/{{theme}}/Button.css":"themes/layer_{{theme}}.css"}}}});require.config({"config":{"requirejs-dplugins/i18n":{"bundlesMap":{"nls/main_build":["deliteful/list/List/nls/List","deliteful/StarRating/nls/StarRating","deliteful/Combobox/nls/Combobox"]},"localesMap":{"nls/main_build":["root"]}}}});require.config({config:{'ecma402/impl/load':{"af":true,"af-NA":true,"am":true,"ar":true,"ar-AE":true,"ar-BH":true,"ar-DZ":true,"ar-EG":true,"ar-IQ":true,"ar-JO":true,"ar-KW":true,"ar-LB":true,"ar-LY":true,"ar-MA":true,"ar-OM":true,"ar-QA":true,"ar-SA":true,"ar-SD":true,"ar-SY":true,"ar-TN":true,"ar-YE":true,"as":true,"az":true,"be":true,"bg":true,"bn":true,"bn-IN":true,"ca":true,"cs":true,"cy":true,"da":true,"de":true,"de-AT":true,"de-LU":true,"de-CH":true,"el":true,"en":true,"en-AU":true,"en-BE":true,"en-CM":true,"en-CA":true,"en-GB":true,"en-GH":true,"en-HK":true,"en-IE":true,"en-IN":true,"en-KE":true,"en-MU":true,"en-NG":true,"en-NZ":true,"en-PH":true,"en-SG":true,"en-TT":true,"en-ZA":true,"en-ZM":true,"es":true,"es-AR":true,"es-BO":true,"es-CL":true,"es-CO":true,"es-CR":true,"es-DO":true,"es-EC":true,"es-GT":true,"es-HN":true,"es-MX":true,"es-NI":true,"es-PA":true,"es-PE":true,"es-PR":true,"es-PY":true,"es-SV":true,"es-US":true,"es-UY":true,"es-VE":true,"eu":true,"fil":true,"fi":true,"fr":true,"fr-BE":true,"fr-CA":true,"fr-CD":true,"fr-CH":true,"fr-CI":true,"fr-CM":true,"fr-DZ":true,"fr-LU":true,"fr-MR":true,"fr-MA":true,"fr-SN":true,"fr-TN":true,"gl":true,"gu":true,"ha":true,"he":true,"hi":true,"hr":true,"hu":true,"hy":true,"id":true,"ig":true,"is":true,"it":true,"it-CH":true,"ja":true,"ka":true,"kk":true,"km":true,"kn":true,"ko":true,"kok":true,"lg":true,"lt":true,"lv":true,"mk":true,"ml":true,"mn":true,"mr":true,"ms":true,"mt":true,"nb":true,"ne":true,"ne-IN":true,"nl":true,"nl-BE":true,"nn":true,"om":true,"or":true,"pa":true,"pl":true,"pt":true,"pt-AO":true,"pt-MZ":true,"pt-PT":true,"ro":true,"root":true,"ru":true,"rw":true,"si":true,"sk":true,"sl":true,"sr":true,"sr-Latn":true,"sq":true,"sv":true,"sw":true,"sw-KE":true,"ta":true,"te":true,"th":true,"tr":true,"uk":true,"ur":true,"ur-IN":true,"uz":true,"uz-Cyrl":true,"vi":true,"yo":true,"zh":true,"zh-Hans":true,"zh-Hans-SG":true,"zh-Hant":true,"zh-Hant-HK":true,"_layerMid":"cldr/main_build"}}});require.config({"config":{"requirejs-dplugins/css":{"layersMap":{"deliteful/ViewStack/transitions/slide.css":"main_build.css","deliteful/ViewStack/transitions/reveal.css":"main_build.css"}}}});define('xapp/mainr',[
    "deliteful/Button",
    "xblox/RunScript",
    "delite/Container",
    "delite/register",
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/declare",
    "dojo/Deferred",
    "dojo/has",
    "dojo/noob",
    "dojo/node",
    "xdojo/declare",
    "xdojo/has",
    'dcl/dcl',
    'dcl/advise',
    'dcl/mini',
    'dstore/mainr',
    'xdojo/declare',
    'dstore/Filter',

    'xide/types',
    'xide/types/Types',

    'xide/utils',
    'xaction/types',
    'xide/utils/StringUtils',
    'xide/utils/HexUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/StoreUtils',
    'xide/utils/WidgetUtils',
    'xide/utils/CIUtils',
    'xide/utils/ObjectUtils',
    'xide/utils/CSSUtils',
    'xfile/types',

    'xide/manager/ContextBase',
    'xapp/manager/Context',
    'xapp/manager/Application',


    'xblox/mainr',

    "xblox/CSSState",
    "xblox/StyleState",
    'xblox/model/html/SetState',
    'xide/mainr',

    'xfile/manager/FileManager',
    'xwire/main',
    'xcf/mainr',

    'xnode/manager/NodeServiceManager',


    'decor/Evented',
    'decor/Invalidating',
    'decor/ObservableArray',
    'decor/features',
    'decor/schedule',
    'decor/sniff',

    'dpointer/events',
    'dpointer/handlers/features',
    'dpointer/handlers/mouse',
    'dpointer/handlers/touch',
    'dpointer/handlers/touchTracker',
    'dpointer/handlers/utils',

    "delite/Template",
    "delite/Widget",
    "delite/handlebars",
    "delite/theme",

    "deliteful/Slider",
    "deliteful/Combobox",
    "deliteful/Select",
    "deliteful/Checkbox",
    "deliteful/RadioButton",
    "deliteful/ToggleButton",
    "deliteful/Switch",
    "deliteful/features",
    "deliteful/ProgressIndicator",
    "deliteful/ViewStack",
    "deliteful/Panel",
    "deliteful/SidePane",
    "deliteful/LinearLayout",
    "deliteful/Button",
    "xdeliteful/Button",
    "deliteful/StarRating",
    "deliteful/ProgressBar",
    "deliteful/list/List",
    "dojo/selector/_loader",
    "xdeliteful/TabBar",
    "xdeliteful/MediaPlayer",
    "xdeliteful/Script",
    "deliteful/Accordion",
    "dojo/_base/kernel",
    'dojo/Stateful',
    'dojo/query',
    'dojo/cache',
    'dojo/window',
    'dojo/request',
    'dojo/selector/lite',
    "requirejs-domready/domReady"
], function(Button,RunScript,register){
    
});

/*

    'xblox/mainr',

    "xblox/CSSState",
    "xblox/StyleState",
    'xblox/model/html/SetState',
    'xide/mainr',

    //'xfile/manager/FileManager',
    'xwire/main',
    'xcf/mainr',

    'xnode/manager/NodeServiceManager',


    'decor/Evented',
    'decor/Invalidating',
    'decor/ObservableArray',
    'decor/features',
    'decor/schedule',
    'decor/sniff',

    'dpointer/events',
    'dpointer/handlers/features',
    'dpointer/handlers/mouse',
    'dpointer/handlers/touch',
    'dpointer/handlers/touchTracker',
    'dpointer/handlers/utils',

    "delite/Template",
    "delite/Widget",
    "delite/handlebars",
    "delite/theme",

    "deliteful/Slider",
    "deliteful/Combobox",
    "deliteful/Select",
    "deliteful/Checkbox",
    "deliteful/RadioButton",
    "deliteful/ToggleButton",
    "deliteful/Switch",
    "deliteful/features",
    "deliteful/ProgressIndicator",
    "deliteful/ViewStack",
    "deliteful/Panel",
    "deliteful/SidePane",
    "deliteful/LinearLayout",
    "deliteful/Button",
    "xdeliteful/Button",
    "deliteful/StarRating",
    "deliteful/ProgressBar",
    "deliteful/list/List",
    "dojo/selector/_loader",
    "xdeliteful/TabBar",
    "xdeliteful/MediaPlayer",
    "xdeliteful/Script",
    "deliteful/Accordion",
    "requirejs-domready/domReady"
*/;
/**
 * @license domReady 2.0.1 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/domReady/LICENSE
 */
/*jslint */
/*global require: false, define: false, requirejs: false,
  window: false, clearInterval: false, document: false,
  self: false, setInterval: false */


define('requirejs-domready/domReady',[],function () {
    'use strict';

    var isTop, testDiv, scrollIntervalId,
        isBrowser = typeof window !== "undefined" && window.document,
        isPageLoaded = !isBrowser,
        doc = isBrowser ? document : null,
        readyCalls = [];

    function runCallbacks(callbacks) {
        var i;
        for (i = 0; i < callbacks.length; i += 1) {
            callbacks[i](doc);
        }
    }

    function callReady() {
        var callbacks = readyCalls;

        if (isPageLoaded) {
            //Call the DOM ready callbacks
            if (callbacks.length) {
                readyCalls = [];
                runCallbacks(callbacks);
            }
        }
    }

    /**
     * Sets the page as loaded.
     */
    function pageLoaded() {
        if (!isPageLoaded) {
            isPageLoaded = true;
            if (scrollIntervalId) {
                clearInterval(scrollIntervalId);
            }

            callReady();
        }
    }

    if (isBrowser) {
        if (document.addEventListener) {
            //Standards. Hooray! Assumption here that if standards based,
            //it knows about DOMContentLoaded.
            document.addEventListener("DOMContentLoaded", pageLoaded, false);
            window.addEventListener("load", pageLoaded, false);
        } else if (window.attachEvent) {
            window.attachEvent("onload", pageLoaded);

            testDiv = document.createElement('div');
            try {
                isTop = window.frameElement === null;
            } catch (e) {}

            //DOMContentLoaded approximation that uses a doScroll, as found by
            //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,
            //but modified by other contributors, including jdalton
            if (testDiv.doScroll && isTop && window.external) {
                scrollIntervalId = setInterval(function () {
                    try {
                        testDiv.doScroll();
                        pageLoaded();
                    } catch (e) {}
                }, 30);
            }
        }

        //Check if document already complete, and if so, just trigger page load
        //listeners. Latest webkit browsers also use "interactive", and
        //will fire the onDOMContentLoaded before "interactive" but not after
        //entering "interactive" or "complete". More details:
        //http://dev.w3.org/html5/spec/the-end.html#the-end
        //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded
        //Hmm, this is more complicated on further use, see "firing too early"
        //bug: https://github.com/requirejs/domReady/issues/1
        //so removing the || document.readyState === "interactive" test.
        //There is still a window.onload binding that should get fired if
        //DOMContentLoaded is missed.
        if (document.readyState === "complete") {
            pageLoaded();
        }
    }

    /** START OF PUBLIC API **/

    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately.
     * @param {Function} callback
     */
    function domReady(callback) {
        if (isPageLoaded) {
            callback(doc);
        } else {
            readyCalls.push(callback);
        }
        return domReady;
    }

    domReady.version = '2.0.1';

    /**
     * Loader Plugin API method
     */
    domReady.load = function (name, req, onLoad, config) {
        if (config.isBuild) {
            onLoad(null);
        } else {
            domReady(onLoad);
        }
    };

    /** END OF PUBLIC API **/

    return domReady;
});
;
define('dojo/selector/lite',["../has", "../_base/kernel"], function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matchesSelector || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector; // IE9, WebKit, Firefox have this, but not Opera yet
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		// fast path regardless of whether or not querySelectorAll exists
		if(match[2]){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
});
;
define('dojo/request',[
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});
;
define('dojo/request/default',[
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if(has('host-browser') || has('host-webworker')){
		platformId = './xhr';
	}else if(has('host-node')){
		platformId = './node';
	/* TODO:
	}else if(has('host-rhino')){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});
;
define('dojo/window',["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") < 9 && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera")) && ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
						if(elPos.x < 0 || !isIE || isIE >= 9){ elPos.x = 0; } // older IE can have values > 0
						if(elPos.y < 0 || !isIE || isIE >= 9){ elPos.y = 0; }
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
						old = el.scrollLeft;
						el.scrollLeft += s;
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						el.scrollTop += s;
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	has("extend-dojo") && lang.setObject("dojo.window", window);

	return window;
});
;
define('dojo/dom-construct',["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"],
	function(exports, dojo, has, win, dom, attr){
		// module:
		//		dojo/dom-construct
		// summary:
		//		This module defines the core dojo DOM construction API.

		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

		// support stuff for toDom()
		var tagWrap = {
				option: ["select"],
				tbody: ["table"],
				thead: ["table"],
				tfoot: ["table"],
				tr: ["table", "tbody"],
				td: ["table", "tbody", "tr"],
				th: ["table", "thead", "tr"],
				legend: ["fieldset"],
				caption: ["table"],
				colgroup: ["table"],
				col: ["table", "colgroup"],
				li: ["ul"]
			},
			reTag = /<\s*([\w\:]+)/,
			masterNode = {}, masterNum = 0,
			masterName = "__" + dojo._scopeName + "ToDomId";

		// generate start/end tag strings to use
		// for the injection for each special tag wrap case.
		for(var param in tagWrap){
			if(tagWrap.hasOwnProperty(param)){
				var tw = tagWrap[param];
				tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
				tw.post = "</" + tw.reverse().join("></") + ">";
				// the last line is destructive: it reverses the array,
				// but we don't care at this point
			}
		}

		var html5domfix;
		if(has("ie") <= 8){
			html5domfix = function(doc){
				doc.__dojo_html5_tested = "yes";
				var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
				if(div.childNodes.length !== 1){
					('abbr article aside audio canvas details figcaption figure footer header ' +
					'hgroup mark meter nav output progress section summary time video').replace(
						/\b\w+\b/g, function(n){
							doc.createElement(n);
						}
					);
				}
				destroy(div);
			}
		}

		function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
			var parent = ref.parentNode;
			if(parent){
				parent.insertBefore(node, ref);
			}
		}

		function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
			// summary:
			//		Try to insert node after ref
			var parent = ref.parentNode;
			if(parent){
				if(parent.lastChild == ref){
					parent.appendChild(node);
				}else{
					parent.insertBefore(node, ref.nextSibling);
				}
			}
		}

		exports.toDom = function toDom(frag, doc){
			// summary:
			//		instantiates an HTML fragment returning the corresponding DOM.
			// frag: String
			//		the HTML fragment
			// doc: DocumentNode?
			//		optional document to use when creating DOM nodes, defaults to
			//		dojo/_base/window.doc if not specified.
			// returns:
			//		Document fragment, unless it's a single node in which case it returns the node itself
			// example:
			//		Create a table row:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
			//	|	});

			doc = doc || win.doc;
			var masterId = doc[masterName];
			if(!masterId){
				doc[masterName] = masterId = ++masterNum + "";
				masterNode[masterId] = doc.createElement("div");
			}

			if(has("ie") <= 8){
				if(!doc.__dojo_html5_tested && doc.body){
					html5domfix(doc);
				}
			}

			// make sure the frag is a string.
			frag += "";

			// find the starting tag, and get node wrapper
			var match = frag.match(reTag),
				tag = match ? match[1].toLowerCase() : "",
				master = masterNode[masterId],
				wrap, i, fc, df;
			if(match && tagWrap[tag]){
				wrap = tagWrap[tag];
				master.innerHTML = wrap.pre + frag + wrap.post;
				for(i = wrap.length; i; --i){
					master = master.firstChild;
				}
			}else{
				master.innerHTML = frag;
			}

			// one node shortcut => return the node itself
			if(master.childNodes.length == 1){
				return master.removeChild(master.firstChild); // DOMNode
			}

			// return multiple nodes as a document fragment
			df = doc.createDocumentFragment();
			while((fc = master.firstChild)){ // intentional assignment
				df.appendChild(fc);
			}
			return df; // DocumentFragment
		};

		exports.place = function place(node, refNode, position){
			// summary:
			//		Attempt to insert node into the DOM, choosing from various positioning options.
			//		Returns the first argument resolved to a DOM node.
			// node: DOMNode|DocumentFragment|String
			//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
			// refNode: DOMNode|String
			//		id or node reference to use as basis for placement
			// position: String|Number?
			//		string noting the position of node relative to refNode or a
			//		number indicating the location in the childNodes collection of refNode.
			//		Accepted string values are:
			//
			//		- before
			//		- after
			//		- replace
			//		- only
			//		- first
			//		- last
			//
			//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
			//		"only" replaces all children.  position defaults to "last" if not specified
			// returns: DOMNode
			//		Returned values is the first argument resolved to a DOM node.
			//
			//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
			// example:
			//		Place a node by string id as the last child of another node by string id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode");
			//	|	});
			// example:
			//		Place a node by string id before another node by string id
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode", "before");
			//	|	});
			// example:
			//		Create a Node, and place it in the body element (last child):
			//	|	require(["dojo/dom-construct", "dojo/_base/window"
			//	|	], function(domConstruct, win){
			//	|		domConstruct.place("<div></div>", win.body());
			//	|	});
			// example:
			//		Put a new LI as the first child of a list by id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("<li></li>", "someUl", "first");
			//	|	});

			refNode = dom.byId(refNode);
			if(!refNode){
				console.error('have no node in domConstruct');
				console.trace();
				return;
			}
			if(typeof node == "string"){ // inline'd type check
				node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
			}
			if(typeof position == "number"){ // inline'd type check
				var cn = refNode.childNodes;
				if(!cn.length || cn.length <= position){
					refNode.appendChild(node);
				}else{
					_insertBefore(node, cn[position < 0 ? 0 : position]);
				}
			}else{
				switch(position){
					case "before":
						_insertBefore(node, refNode);
						break;
					case "after":
						_insertAfter(node, refNode);
						break;
					case "replace":
						refNode.parentNode.replaceChild(node, refNode);
						break;
					case "only":
						exports.empty(refNode);
						refNode.appendChild(node);
						break;
					case "first":
						if(refNode.firstChild){
							_insertBefore(node, refNode.firstChild);
							break;
						}
					// else fallthrough...
					default: // aka: last
					{
						if(!refNode){
							console.error('bad');
							console.trace();
							return null;
						}
						refNode.appendChild(node);
					}
				}
			}
			return node; // DomNode
		};

		var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
			// summary:
			//		Create an element, allowing for optional attribute decoration
			//		and placement.
			// description:
			//		A DOM Element creation function. A shorthand method for creating a node or
			//		a fragment, and allowing for a convenient optional attribute setting step,
			//		as well as an optional DOM placement reference.
			//
			//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
			//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
			//
			//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
			//		the action node, passing along the optional reference node and position.
			// tag: DOMNode|String
			//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
			//		or an existing DOM node to process.
			// attrs: Object
			//		An object-hash of attributes to set on the newly created node.
			//		Can be null, if you don't want to set any attributes/styles.
			//		See: `dojo/dom-attr.set` for a description of available attributes.
			// refNode: DOMNode|String?
			//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
			//		node somewhere in the dom relative to refNode. Can be a DomNode reference
			//		or String ID of a node.
			// pos: String?
			//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
			//		though can be set to "first","after","before","last", "replace" or "only"
			//		to further control the placement of the new node relative to the refNode.
			//		'refNode' is required if a 'pos' is specified.
			// example:
			//		Create a DIV:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div");
			//	|	});
			//
			// example:
			//		Create a DIV with content:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
			//	|	});
			//
			// example:
			//		Place a new DIV in the BODY, with no attributes set
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		var n = domConstruct.create("div", null, win.body());
			//	|	});
			//
			// example:
			//		Create an UL, and populate it with LI's. Place the list as the first-child of a
			//		node with id="someId":
			//	|	require(["dojo/dom-construct", "dojo/_base/array"],
			//	|	function(domConstruct, arrayUtil){
			//	|		var ul = domConstruct.create("ul", null, "someId", "first");
			//	|		var items = ["one", "two", "three", "four"];
			//	|		arrayUtil.forEach(items, function(data){
			//	|			domConstruct.create("li", { innerHTML: data }, ul);
			//	|		});
			//	|	});
			//
			// example:
			//		Create an anchor, with an href. Place in BODY:
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
			//	|	});

			var doc = win.doc;
			if(refNode){
				refNode = dom.byId(refNode);
				doc = refNode.ownerDocument;
			}
			if(typeof tag == "string"){ // inline'd type check
				tag = doc.createElement(tag);
			}
			if(attrs){ attr.set(tag, attrs); }
			if(refNode){ exports.place(tag, refNode, pos); }
			return tag; // DomNode
		};

		function _empty(/*DomNode*/ node){
			// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
			// and then uncomment the emptyGrandchildren() test case from html.html.
			// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
			// see http://jsperf.com/clear-dom-node.
			if("innerHTML" in node){
				try{
					// fast path
					node.innerHTML = "";
					return;
				}catch(e){
					// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
					// Fall through (saves bytes)
				}
			}

			// SVG/strict elements don't support innerHTML
			for(var c; c = node.lastChild;){ // intentional assignment
				node.removeChild(c);
			}
		}

		exports.empty = function empty(/*DOMNode|String*/ node){
			// summary:
			//		safely removes all children of the node.
			// node: DOMNode|String
			//		a reference to a DOM node or an id.
			// example:
			//		Destroy node's children byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.empty("someId");
			//	|	});

			_empty(dom.byId(node));
		};


		function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
			// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
			if(node.firstChild){
				_empty(node);
			}
			if(parent){
				// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
				// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
				// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
				// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
				has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
			}
		}
		var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
			// summary:
			//		Removes a node from its parent, clobbering it and all of its
			//		children.
			//
			// description:
			//		Removes a node from its parent, clobbering it and all of its
			//		children. Function only works with DomNodes, and returns nothing.
			//
			// node: DOMNode|String
			//		A String ID or DomNode reference of the element to be destroyed
			//
			// example:
			//		Destroy a node byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.destroy("someId");
			//	|	});

			node = dom.byId(node);
			if(!node){ return; }
			_destroy(node, node.parentNode);
		};
	});
;
define('dojo/dom-attr',["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"],
		function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)

	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie"),
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}

	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}

		if(propName == "textContent"){
			return prop.get(node, propName);
		}

		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
});
;
define('dojo/dom-prop',["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"],
	function(exports, dojo, has, lang, dom, style, ctr, conn){
		// module:
		//		dojo/dom-prop
		// summary:
		//		This module defines the core dojo DOM properties API.

		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

		// =============================
		// Element properties Functions
		// =============================

		// helper to connect events
		var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
		has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

		exports.names = {
			// properties renamed to avoid clashes with reserved words
			"class": "className",
			"for": "htmlFor",
			// properties written as camelCase
			tabindex: "tabIndex",
			readonly: "readOnly",
			colspan: "colSpan",
			frameborder: "frameBorder",
			rowspan: "rowSpan",
			textcontent: "textContent",
			valuetype: "valueType"
		};

		function getText(/*DOMNode*/node){
			// summary:
			//		recursion method for get('textContent') to use. Gets text value for a node.
			// description:
			//		Juse uses nodedValue so things like <br/> tags do not end up in
			//		the text as any sort of line return.
			var text = "", ch = node.childNodes;
			for(var i = 0, n; n = ch[i]; i++){
				//Skip comments.
				if(n.nodeType != 8){
					if(n.nodeType == 1){
						text += getText(n);
					}else{
						text += n.nodeValue;
					}
				}
			}
			return text;
		}

		exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Gets a property on an HTML element.
			// description:
			//		Handles normalized getting of properties on DOM nodes.
			//
			// node: DOMNode|String
			//		id or reference to the element to get the property on
			// name: String
			//		the name of the property to get.
			// returns:
			//		the value of the requested property or its default value
			//
			// example:
			//	|	// get the current value of the "foo" property on a node
			//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
			//	|		domProp.get(dom.byId("nodeId"), "foo");
			//	|		// or we can just pass the id:
			//	|		domProp.get("nodeId", "foo");
			//	|	});

			node = dom.byId(node);
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;

			if(propName == "textContent" && !has("dom-textContent")){
				return getText(node);
			}

			return node[propName];	// Anything
		};

		exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
			// summary:
			//		Sets a property on an HTML element.
			// description:
			//		Handles normalized setting of properties on DOM nodes.
			//
			//		When passing functions as values, note that they will not be
			//		directly assigned to slots on the node, but rather the default
			//		behavior will be removed and the new behavior will be added
			//		using `dojo.connect()`, meaning that event handler properties
			//		will be normalized and that some caveats with regards to
			//		non-standard behaviors for onsubmit apply. Namely that you
			//		should cancel form submission using `dojo.stopEvent()` on the
			//		passed event object instead of returning a boolean value from
			//		the handler itself.
			// node: DOMNode|String
			//		id or reference to the element to set the property on
			// name: String|Object
			//		the name of the property to set, or a hash object to set
			//		multiple properties at once.
			// value: String?
			//		The value to set for the property
			// returns:
			//		the DOM node
			//
			// example:
			//	|	// use prop() to set the tab index
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("nodeId", "tabIndex", 3);
			//	|	});
			//
			// example:
			//	Set multiple values at once, including event handlers:
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("formId", {
			//	|			"foo": "bar",
			//	|			"tabIndex": -1,
			//	|			"method": "POST",
			//	|		});
			//	|	});

			node = dom.byId(node);
			if(!node){
				console.error('invalid node!',node);
				return node;
			}
			var l = arguments.length;
			if(l == 2 && typeof name != "string"){ // inline'd type check
				// the object form of setter: the 2nd argument is a dictionary
				for(var x in name){
					exports.set(node, x, name[x]);
				}
				return node; // DomNode
			}
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;
			if(propName == "style" && typeof value != "string"){ // inline'd type check
				// special case: setting a style
				style.set(node, value);
				return node; // DomNode
			}
			if(propName == "innerHTML"){
				// special case: assigning HTML
				// the hash lists elements with read-only innerHTML on IE
				if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
					ctr.empty(node);
					node.appendChild(ctr.toDom(value, node.ownerDocument));
				}else{
					node[propName] = value;
				}
				return node; // DomNode
			}
			if(propName == "textContent" && !has("dom-textContent")) {
				ctr.empty(node);
				node.appendChild(node.ownerDocument.createTextNode(value));
				return node;
			}
			if(lang.isFunction(value)){
				// special case: assigning an event handler
				// clobber if we can
				var attrId = node[_attrId];
				if(!attrId){
					attrId = _ctr++;
					node[_attrId] = attrId;
				}
				if(!_evtHdlrMap[attrId]){
					_evtHdlrMap[attrId] = {};
				}
				var h = _evtHdlrMap[attrId][propName];
				if(h){
					//h.remove();
					conn.disconnect(h);
				}else{
					try{
						delete node[propName];
					}catch(e){}
				}
				// ensure that event objects are normalized, etc.
				if(value){
					//_evtHdlrMap[attrId][propName] = on(node, propName, value);
					_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
				}else{
					node[propName] = null;
				}
				return node; // DomNode
			}
			node[propName] = value;
			return node;	// DomNode
		};
	});
;
define('dojo/_base/connect',["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

has("extend-dojo") && lang.mixin(dojo, connect);
return connect;

});


;
define('dojo/keys',["./_base/kernel", "./sniff"], function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
});
;
define('dojo/_base/sniff',["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(!has("host-browser")){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
});
;
define('dojo/mouse',["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
});
;
define('dojo/_base/event',["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if(has("extend-dojo")){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
});
;
define('dojo/aspect',[], function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
						args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
						if(after.receiveArguments){
							var newResults = after.advice.apply(this, args);
							// change the return value only if a new value was returned
							results = newResults === undefined ? results : newResults;
						}else{
							results = after.advice.call(this, results, args);
						}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
});
;
define('dojo/topic',["./Evented"], function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
});
;
/**
 * @module dojo/Evented
 **/
define('dojo/Evented',[
    "./aspect",
    "./on"
], function (aspect, on) {
    "use strict";
    var after = aspect.after;
    /**
     * A class that can be used as a mixin or base class,
     * to add on() and emit() methods to a class
     * for listening for events and emitting events:
     *
     * @class module:dojo/Evented
     * @example
     *
     * define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"], function(Evented, declare, Stateful){
		var EventedStateful = declare([Evented, Stateful], {...});
		var instance = new EventedStateful();
		instance.on("open", function(event){
		//		... do something with event
		});
		instance.emit("open", {name:"some event", ...});
     */
    function Evented() {
        // summary:
        //		A class that can be used as a mixin or base class,
        //		to add on() and emit() methods to a class
        //		for listening for events and emitting events:
        // example:
        //		|
    }

    Evented.prototype = {
        on: function (type, listener) {
            return on.parse(this, type, listener, function (target, type) {
                return after(target, 'on' + type, listener, true);
            });
        },
        emit: function (type, event) {
            var args = [this];
            args.push.apply(args, arguments);
            return on.emit.apply(on, args);
        }
    };
    return Evented;
});
;
define('dojo/on',["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has){

	"use strict";
	if(has("dom")){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			// All browsers except firefox support focusin, but too hard to feature test webkit since element.onfocusin
			// is undefined.  Just return true for IE and use fallback path for other browsers.
			return !!element.attachEvent;
		});
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(listen){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(listen, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it 
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype 
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The 
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			var events = type.split(/\s*,\s*/);
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){
				handles.push(addListener(target, eventName, listener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1, 
				//but works through "resize" on window
				type = "resize"; 
				target = window;
				listener = fixTouchListener(listener);
			} 
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
			    type:type,
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}

	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to 
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(listen, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				// see if we have a valid matchesTarget or default to dojo/query
				matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
				// there is a selector, so make sure it matches
				while(!matchesTarget.matches(eventTarget, selector, target)){
					if(eventTarget == target || children === false || !(eventTarget = eventTarget.parentNode) || eventTarget.nodeType != 1){ // intentional assignment
						return;
					}
				}
				return eventTarget;
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				return eventTarget && listener.call(eventTarget, event);
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain 
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and 
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent 
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable 
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		}
	} 
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event				
				// we could create branch into the different types of event constructors, but 
				// that would be a lot of extra code, with little benefit that I can see, seems 
				// best to use the generic constructor and copy properties over, making it 
				// easy to have events look like the ones created with specific initializers
				var nativeEvent = target.ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || 
						has("jscript") < 5.8) && 
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){ 
		var Event = function(){};
		var windowOrientation = window.orientation; 
		var fixTouchListener = function(listener){ 
			return function(originalEvent){ 
				//Event normalization(for ontouchxxx and resize): 
				//1.incorrect e.pageX|pageY in iOS 
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties make them mutable
					}catch(e){} 
					if(originalEvent.type){
						// deleting properties doesn't work (older iOS), have to use delegation
						if(has('mozilla')){
							// Firefox doesn't like delegated properties, so we have to copy
							var event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}else{
							// old iOS branch
							Event.prototype = originalEvent;
							var event = new Event;
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){ 
							return null;//double tap causes an unexpected 'resize' in Android
						} 
						windowOrientation = window.orientation;
						event.type = "orientationchange"; 
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0; 
						event.scale = 1;
					}
					//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
					var firstChangeTouch = event.changedTouches[0];
					for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
						delete event[i]; // delete it first to make it mutable
						event[i] = firstChangeTouch[i];
					}
				}
				return listener.call(this, event); 
			}; 
		}; 
	}
	return on;
});
;
define('dojo/dom-style',["./sniff", "./dom"], function(has, dom){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			if(!node){
				return {};
			}
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			if(!node){
				console.error('getComputedStyle :: invalid node');
				return node;
			}
			return node.nodeType == 1 /* ELEMENT_NODE*/ ?
				node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	 style.getComputedStyle = function(node){
	 // summary:
	 //		Returns a "computed style" object.
	 //
	 // description:
	 //		Gets a "computed style" object which can be used to gather
	 //		information about the current state of the rendered node.
	 //
	 //		Note that this may behave differently on different browsers.
	 //		Values may have different formats and value encodings across
	 //		browsers.
	 //
	 //		Note also that this method is expensive.  Wherever possible,
	 //		reuse the returned object.
	 //
	 //		Use the dojo/dom-style.get() method for more consistent (pixelized)
	 //		return values.
	 //
	 // node: DOMNode
	 //		A reference to a DOM node. Does NOT support taking an
	 //		ID string for speed reasons.
	 // example:
	 //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
	 //	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
	 //	|	});
	 //
	 // example:
	 //		Reusing the returned object, avoiding multiple lookups:
	 //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
	 //	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
	 //	|		var w = cs.width, h = cs.height;
	 //	|	});
	 return; // CSS2Properties
	 };
	 =====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	 style.toPixelValue = function(node, value){
	 // summary:
	 //		converts style value to pixels on IE or return a numeric value.
	 // node: DOMNode
	 // value: String
	 // returns: Number
	 };
	 =====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
			function(node){
				return getComputedStyle(node).opacity;
			};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
			function(node, opacity){
				return node.style.opacity = opacity;
			};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
});
;
define('dojo/dom-geometry',["./sniff", "./_base/window","./dom", "./dom-style"],
	function(has, win, dom, style){
		// module:
		//		dojo/dom-geometry

		// the result object
		var geom = {
			// summary:
			//		This module defines the core dojo DOM geometry API.
		};

		// Box functions will assume this model.
		// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
		// Can be set to change behavior of box setters.

		// can be either:
		//	"border-box"
		//	"content-box" (default)
		geom.boxModel = "content-box";

		// We punt per-node box mode testing completely.
		// If anybody cares, we can provide an additional (optional) unit
		// that overrides existing code to include per-node box sensitivity.

		// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
		// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
		// IIRC, earlier versions of Opera did in fact use border-box.
		// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

		if(has("ie") /*|| has("opera")*/){
			// client code may have to adjust if compatMode varies across iframes
			geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
		}

		geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with special values specifically useful for node
			//		fitting.
			// description:
			//		Returns an object with `w`, `h`, `l`, `t` properties:
			//	|		l/t/r/b = left/top/right/bottom padding (respectively)
			//	|		w = the total of the left and right padding
			//	|		h = the total of the top and bottom padding
			//		If 'node' has position, l/t forms the origin for child nodes.
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		var none = "none";

		geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object with properties useful for noting the border
			//		dimensions.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right border
			//		- h = the sum of the top and bottom border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
				l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
				t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
				r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
				b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with properties useful for box fitting with
			//		regards to padding.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right padding and border
			//		- h = the sum of the top and bottom padding and border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node),
				p = geom.getPadExtents(node, s),
				b = geom.getBorderExtents(node, s);
			return {
				l: p.l + b.l,
				t: p.t + b.t,
				r: p.r + b.r,
				b: p.b + b.b,
				w: p.w + b.w,
				h: p.h + b.h
			};
		};

		geom.getMarginExtents = function getMarginExtents(node, computedStyle){
			// summary:
			//		returns object with properties useful for box fitting with
			//		regards to box margins (i.e., the outer-box).
			//
			//		- l/t = marginLeft, marginTop, respectively
			//		- w = total width, margin inclusive
			//		- h = total height, margin inclusive
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};

		// Box getters work in any box context because offsetWidth/clientWidth
		// are invariant wrt box context
		//
		// They do *not* work for display: inline objects that have padding styles
		// because the user agent ignores padding (it's bogus styling in any case)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.

		// Although it would be easier to read, there are not separate versions of
		// _getMarginBox for each browser because:
		// 1. the branching is not expensive
		// 2. factoring the shared code wastes cycles (function call overhead)
		// 3. duplicating the shared code wastes bytes

		geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width, height, left and top
			//		positions of the node's margin box.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			if(!node){
				console.error('have no node');
				return {
					l:0,
					t:0,
					w:0,
					h:0
				};
			}
			var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
				l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
			if(has("mozilla")){
				// Mozilla:
				// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
				// by the parent's border.
				// We don't want to compute the parent's style, so instead we examine node's
				// computed left/top which is more stable.
				var sl = parseFloat(s.left), st = parseFloat(s.top);
				if(!isNaN(sl) && !isNaN(st)){
					l = sl;
					t = st;
				}else{
					// If child's computed left/top are not parseable as a number (e.g. "auto"), we
					// have no choice but to examine the parent's computed style.
					if(p && p.style){
						pcs = style.getComputedStyle(p);
						if(pcs.overflow != "visible"){
							l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
							t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
						}
					}
				}
			}else if(has("opera") || (has("ie") == 8 && !has("quirks"))){
				// On Opera and IE 8, offsetLeft/Top includes the parent's border
				if(p){
					pcs = style.getComputedStyle(p);
					l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
					t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
				}
			}
			return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
		};

		geom.getContentBox = function getContentBox(node, computedStyle){
			// summary:
			//		Returns an object that encodes the width, height, left and top
			//		positions of the node's content box, irrespective of the
			//		current box model.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			// clientWidth/Height are important since the automatically account for scrollbars
			// fallback to offsetWidth/Height for special cases (see #3378)
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
				pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
			if(!w){
				w = node.offsetWidth;
				h = node.offsetHeight;
			}else{
				h = node.clientHeight;
				be.w = be.h = 0;
			}
			// On Opera, offsetLeft includes the parent's border
			if(has("opera")){
				pe.l += be.l;
				pe.t += be.t;
			}
			return {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};
		};

		// Box setters depend on box context because interpretation of width/height styles
		// vary wrt box context.
		//
		// The value of boxModel is used to determine box context.
		// boxModel can be set directly to change behavior.
		//
		// Beware of display: inline objects that have padding styles
		// because the user agent ignores padding (it's a bogus setup anyway)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.
		//
		// Elements other than DIV may have special quirks, like built-in
		// margins or padding, or values not detectable via computedStyle.
		// In particular, margins on TABLE do not seems to appear
		// at all in computedStyle on Mozilla.

		function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
			// summary:
			//		sets width/height/left/top in the current (native) box-model
			//		dimensions. Uses the unit passed in u.
			// node:
			//		DOM Node reference. Id string not supported for performance
			//		reasons.
			// l:
			//		left offset from parent.
			// t:
			//		top offset from parent.
			// w:
			//		width in current box model.
			// h:
			//		width in current box model.
			// u:
			//		unit measure to use for other measures. Defaults to "px".
			u = u || "px";
			var s = node.style;
			if(!isNaN(l)){
				s.left = l + u;
			}
			if(!isNaN(t)){
				s.top = t + u;
			}
			if(w >= 0){
				s.width = w + u;
			}
			if(h >= 0){
				s.height = h + u;
			}
		}

		function isButtonTag(/*DomNode*/ node){
			// summary:
			//		True if the node is BUTTON or INPUT.type="button".
			return node.tagName.toLowerCase() == "button" ||
				node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
		}

		function usesBorderBox(/*DomNode*/ node){
			// summary:
			//		True if the node uses border-box layout.

			// We could test the computed style of node to see if a particular box
			// has been specified, but there are details and we choose not to bother.

			// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
			// If you have assigned a different box to either one via CSS then
			// box functions will break.

			return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
		}

		geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		Sets the size of the node's contents, irrespective of margins,
			//		padding, or borders.
			// node: DOMNode
			// box: Object
			//		hash with optional "w", and "h" properties for "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var w = box.w, h = box.h;
			if(usesBorderBox(node)){
				var pb = geom.getPadBorderExtents(node, computedStyle);
				if(w >= 0){
					w += pb.w;
				}
				if(h >= 0){
					h += pb.h;
				}
			}
			setBox(node, NaN, NaN, w, h);
		};

		var nilExtents = {l: 0, t: 0, w: 0, h: 0};

		geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		sets the size of the node's margin box and placement
			//		(left/top), irrespective of box model. Think of it as a
			//		passthrough to setBox that handles box-model vagaries for
			//		you.
			// node: DOMNode
			// box: Object
			//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			if(!node){
				console.error('have no node');
				return;
			}
			var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
				// Some elements have special padding, margin, and box-model settings.
				// To use box functions you may need to set padding, margin explicitly.
				// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
				pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
				mb = geom.getMarginExtents(node, s);
			if(has("webkit")){
				// on Safari (3.1.2), button nodes with no explicit size have a default margin
				// setting an explicit size eliminates the margin.
				// We have to swizzle the width to get correct margin reading.
				if(isButtonTag(node)){
					var ns = node.style;
					if(w >= 0 && !ns.width){
						ns.width = "4px";
					}
					if(h >= 0 && !ns.height){
						ns.height = "4px";
					}
				}
			}
			if(w >= 0){
				w = Math.max(w - pb.w - mb.w, 0);
			}
			if(h >= 0){
				h = Math.max(h - pb.h - mb.h, 0);
			}
			setBox(node, box.l, box.t, w, h);
		};

		// =============================
		// Positioning
		// =============================

		geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
			// summary:
			//		Returns true if the current language is left-to-right, and false otherwise.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Boolean

			doc = doc || win.doc;
			return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
		};

		geom.docScroll = function docScroll(/*Document?*/ doc){
			// summary:
			//		Returns an object with {node, x, y} with corresponding offsets.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Object

			doc = doc || win.doc;
			var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
			return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
			{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
		};

		geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
			// summary:
			//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
			return {
				x: 0,
				y: 0
			};
		};

		geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
			// summary:
			//		In RTL direction, scrollLeft should be a negative value, but IE
			//		returns a positive one. All codes using documentElement.scrollLeft
			//		must call this function to fix this error, otherwise the position
			//		will offset to right when there is a horizontal scrollbar.
			// scrollLeft: Number
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Number

			// In RTL direction, scrollLeft should be a negative value, but IE
			// returns a positive one. All codes using documentElement.scrollLeft
			// must call this function to fix this error, otherwise the position
			// will offset to right when there is a horizontal scrollbar.

			doc = doc || win.doc;
			var ie = has("ie");
			if(ie && !geom.isBodyLtr(doc)){
				var qk = has("quirks"),
					de = qk ? win.body(doc) : doc.documentElement,
					pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
				if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
					scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
				}
				return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
			}
			return scrollLeft; // Integer
		};

		geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
			// summary:
			//		Gets the position and size of the passed element relative to
			//		the viewport (if includeScroll==false), or relative to the
			//		document root (if includeScroll==true).
			//
			// description:
			//		Returns an object of the form:
			//		`{ x: 100, y: 300, w: 20, h: 15 }`.
			//		If includeScroll==true, the x and y values will include any
			//		document offsets that may affect the position relative to the
			//		viewport.
			//		Uses the border-box model (inclusive of border and padding but
			//		not margin).  Does not act as a setter.
			// node: DOMNode|String
			// includeScroll: Boolean?
			// returns: Object

			node = dom.byId(node);
			var	db = win.body(node.ownerDocument),
				ret = node.getBoundingClientRect();
			ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

			if(has("ie") < 9){
				// fixes the position in IE, quirks mode
				ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
				ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
			}

			// account for document scrolling
			// if offsetParent is used, ret value already includes scroll position
			// so we may have to actually remove that value if !includeScroll
			if(includeScroll){
				var scroll = geom.docScroll(node.ownerDocument);
				ret.x += scroll.x;
				ret.y += scroll.y;
			}

			return ret; // Object
		};

		// random "private" functions wildly used throughout the toolkit

		geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width and height of
			//		the node's margin box
			// node: DOMNode|String
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().

			node = dom.byId(node);
			var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
			var size = node.getBoundingClientRect();
			return {
				w: (size.right - size.left) + me.w,
				h: (size.bottom - size.top) + me.h
			};
		};

		geom.normalizeEvent = function(event){
			// summary:
			//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
			//		offsetX, offsetY, layerX, and layerX properties
			// event: Object
			if(!("layerX" in event)){
				event.layerX = event.offsetX;
				event.layerY = event.offsetY;
			}

			if(!("pageX" in event)){
				// FIXME: scroll position query is duped from dojo/_base/html to
				// avoid dependency on that entire module. Now that HTML is in
				// Base, we should convert back to something similar there.
				var se = event.target;
				var doc = (se && se.ownerDocument) || document;
				// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
				// here rather than document.body
				var docBody = has("quirks") ? doc.body : doc.documentElement;
				event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
				event.pageY = event.clientY + (docBody.scrollTop || 0);
			}
		};

		// TODO: evaluate separate getters/setters for position and sizes?

		return geom;
	});
;
define('dojo/dom',["./sniff", "./_base/window"],
		function(has, win){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	dom.isDescendant = function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
		// summary:
		//		Returns true if node is a descendant of ancestor
		// node: DOMNode|String
		//		string id or node reference to test
		// ancestor: DOMNode|String
		//		string id or node reference of potential parent to test against
		//
		// example:
		//		Test is node id="bar" is a descendant of node id="foo"
		//	|	require(["dojo/dom"], function(dom){
		//	|		if(dom.isDescendant("bar", "foo")){ ... }
		//	|	});

		try{
			node = dom.byId(node);
			ancestor = dom.byId(ancestor);
			while(node){
				if(node == ancestor){
					return true; // Boolean
				}
				node = node.parentNode;
			}
		}catch(e){ /* squelch, return false */ }
		return false; // Boolean
	};


	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }
		
		var style = element.style;
		var prefixes = ["Khtml", "O", "ms", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
});
;
define('dojo/_base/window',["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: this["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

has("extend-dojo") && lang.mixin(dojo, ret);

return ret;

});
;
define('dojo/sniff',["./has"], function(has){
	// module:
	//		dojo/sniff

	/*=====
	 return function(){
	 // summary:
	 //		This module sets has() flags based on the current browser.
	 //		It returns the has() function.
	 };
	 =====*/

	if(has("host-browser")){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
			&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
			&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
		&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
		&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
			&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
				&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
});
;
define('dojo/cache',["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});
;
define('dojo/text',["./_base/kernel", "require", "./has", "./has!host-browser?./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if(has("host-browser")){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}else if(require.cache && requireCacheUrl.replace('src/lib','src') in require.cache){
			    //support pre-build layers in full debug config
                text = require.cache[requireCacheUrl.replace('src/lib','src')];
            }else if(require.cache && requireCacheUrl.replace('src/build','src') in require.cache){
                //support layers in full release config
                text = require.cache[requireCacheUrl.replace('src/build','src')];
            }
			if(text===notFound){
			    if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});

;
define('dojo/query',["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"],
	function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
});
;
define('dojo/_base/array',["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	has("extend-dojo") && lang.mixin(dojo, array);

	return array;
});
;
define('dojo/Stateful',["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediatly
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendent class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});
;
define('dojo/when',[
	"./Deferred",
	"./promise/Promise"
], function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
});
;
define('dojo/promise/Promise',[
	"../_base/lang"
], function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
});
;
/** @module deliteful/Accordion */
define('deliteful/Accordion',[
	"dcl/dcl",
	"decor/sniff",
	"requirejs-dplugins/Promise!",
	"delite/register",
	"delite/KeyNav",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/DisplayContainer",
	"./Accordion/AccordionHeader",
	"./features",
	"delite/theme!./Accordion/themes/{{theme}}/Accordion.css"
], function (dcl, has, Promise, register, KeyNav, $, DisplayContainer, AccordionHeader) {

	function setVisibility(node, val) {
		node.style.display = val ? "" : "none";
	}

	function listenAnimationEndEvent(element) {
		return new Promise(function (resolve) {
			var handler = element.on(has("animationEndEvent"), function () {
				handler.remove();
				resolve();
			});
		});
	}

	/* Accordion modes */
	var accordionModes = {
		singleOpen: "singleOpen", // default
		multipleOpen: "multipleOpen"
	};

	var defaultMode = accordionModes.singleOpen;

	/**
	 * A layout container that displays a vertically stacked list of Panels whose titles are all visible, but only one
	 * or at least one panel's content is visible at a time (depending on the `mode` property value).
	 *
	 * Once the panels are in an Accordion, they become collapsible.
	 *
	 * When a panel is open, it fills all the available space with its content.
	 *
	 * @example
	 * <d-accordion id="accordion" selectedChildId="panel1">
	 *     <d-panel id="panel1">...</d-panel>
	 *     <d-panel id="panel2">...</d-panel>
	 *     <d-panel id="panel3">...</d-panel>
	 * </d-accordion>
	 * @class module:deliteful/Accordion
	 * @augments module:delite/DisplayContainer
	 */
	return register("d-accordion", [HTMLElement, DisplayContainer, KeyNav], /** @lends module:deliteful/Accordion# */ {
		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-accordion"
		 */
		baseClass: "d-accordion",

		/**
		 * The id of the panel to be open at initialization.
		 * If not specified, the default open panel is the first one.
		 * @member {string}
		 * @default ""
		 */
		selectedChildId: "",

		/**
		 * The mode of the Accordion
		 * `mode` is one of `["singleOpen", "multipleOpen"]`.
		 * @member {string}
		 * @default "singleOpen"
		 */
		mode: defaultMode,

		/**
		 * If true, animation is used when a panel is opened or closed.
		 * @member {boolean}
		 * @default true
		 */
		animate: true,

		/**
		 * The default CSS class to apply to DOMNode in panel headers to make them display an icon when they are
		 * open.  If a child panel has its own openIconClass specified, that value is used on that panel.
		 * @member {string}
		 * @default ""
		 */
		openIconClass: "",

		/**
		 * The default CSS class to apply to DOMNode in panel headers to make them display an icon when they are
		 * closed.  If a child panel has its own closedIconClass specified, that value is used on that panel.
		 * @member {string}
		 * @default ""
		 */
		closedIconClass: "",

		/**
		 * List of upgraded panels (i.e. `<d-panel>` widgets that have already run createdCallback() and
		 * attachedCallback()).
		 * @member {module:delite/Panel[]}
		 */
		_panelList: null,

		_numOpenPanels: 0,

		createdCallback: function () {
			this._panelList = [];

			// Declarative case (panels specified declaratively inside the declarative Accordion).
			var panels = Array.prototype.slice.call(this.children);	// copy array since we'll be adding more children
			for (var i = 0, l = panels.length; i < l; i++) {
				if (!panels[i].attached) {
					this._setupNonUpgradedChild(panels[i]);
				} else {
					this._panelList.push(this._setupUpgradedChild(panels[i]));
				}
			}
		},

		postRender: function () {
			this.setAttribute("role", "tablist");
			this.setAttribute("aria-multiselectable", "false");
			this.on("delite-remove-child", this._onRemoveChild.bind(this));
		},

		/**
		 * Handle a mouse click or touch on a panel header.
		 * @param event
		 * @private
		 */
		_headerClickHandler: function (event) {
			this.activatePanel(event.currentTarget.panel);
		},

		/**
		 * Open a panel due to a click or spacebar on the panel header.
		 * @param panel
		 */
		activatePanel: function (panel) {
			switch (this.mode) {
			case accordionModes.singleOpen:
				this.show(panel);
				break;
			case accordionModes.multipleOpen:
				if (panel.open) {
					this.hide(panel);
				} else {
					this.show(panel);
				}
				break;
			}
		},

		/**
		 * Overridable method to create the header corresponding to a panel.
		 * The header displays the panel's title, and the user clicks it to open the panel.
		 * @param panel
		 */
		createHeader: function (panel, params) {
			return new AccordionHeader(params);
		},

		_setupUpgradedChild: function (panel) {
			// Create the header (that displays the panel's title).
			var header = this.createHeader(panel, {
				id: panel.id + "_panelHeader",
				label: panel.label,
				openIconClass: panel.openIconClass || this.openIconClass,
				closedIconClass: panel.closedIconClass || this.closedIconClass,
				panel: panel
			});
			header.setAttribute("tabindex", "-1");
			header.setAttribute("role", "tab");
			header.setAttribute("aria-expanded", "false");
			header.setAttribute("aria-selected", "false");
			header.on("click", this._headerClickHandler.bind(this));
			header.placeAt(panel, "before");

			// React to programmatic changes on the panel to update the header.
			panel.observe(function (oldValues) {
				if ("label" in oldValues) {
					header.label = panel.label;
				}
				if ("openIconClass" in oldValues) {
					header.openIconClass = panel.openIconClass;
				}
				if ("closedIconClass" in oldValues) {
					header.closedIconClass = panel.closedIconClass;
				}
			});

			// And set up the panel itself.
			setVisibility(panel, false);
			panel.open = false;
			panel.setAttribute("role", "tabpanel");
			panel.setAttribute("aria-labelledby", header.labelNode.id);
			panel.setAttribute("aria-hidden", "true");
			panel.headerNode = header;

			return panel;
		},

		_setupNonUpgradedChild: function (panel) {
			var attachListener;
			panel.accordion = this;
			panel.addEventListener("customelement-attached", attachListener = function () {
				this.removeEventListener("customelement-attached", attachListener);
				this.accordion._panelList.push(this.accordion._setupUpgradedChild(this));
			}.bind(panel));
		},

		/**
		 * If no panel is shown then show the first one.
		 * @private
		 */
		_showOpenPanel: function () {
			if (!this._selectedChild && this._panelList.length > 0) {
				this._selectedChild = this._panelList[0];
				this.show(this._selectedChild);
			}
		},

		getChildren: function () {
			// Override getChildren() to only return the panels, not the headers
			return Array.prototype.filter.call(this.children, function (element) {
				return element.getAttribute("role") === "tabpanel";
			});
		},

		getHeaders: function () {
			return Array.prototype.filter.call(this.children, function (element) {
				return element.getAttribute("role") === "tab";
			});
		},

		/* jshint maxcomplexity: 14 */
		refreshRendering: function (props) {
			if ("selectedChildId" in props && this.selectedChildId) {
				var childNode = this.ownerDocument.getElementById(this.selectedChildId);
				if (childNode) {
					if (childNode.attached) {
						if (childNode !== this._selectedChild) { // To avoid calling show() method twice
							if (!this._selectedChild) { // If selectedChild is not initialized, then initialize it
								this._selectedChild = childNode;
							}
							this.show(childNode);
						}
					} else {
						// TODO: don't we need to set up a listener for when the child finishes initializing,
						// to call show() then?
						this._selectedChild = childNode;
					}
				}
			}

			// If no panel was selected, then show the first one.
			if (("attached" in props || "_panelList" in  props) && this._panelList.length > 0) {
				this._showOpenPanel();
			}

			if ("openIconClass" in props) {
				this.getChildren().forEach(function (panel) {
					if (panel.attached && !panel.openIconClass) {
						panel.headerNode.openIconClass = this.openIconClass;
					}
				}.bind(this));
			}
			if ("closedIconClass" in props) {
				this.getChildren().forEach(function (panel) {
					if (panel.attached && !panel.closedIconClass) {
						panel.headerNode.closedIconClass = this.closedIconClass;
					}
				}.bind(this));
			}
			if ("mode" in props) {
				this.setAttribute("aria-multiselectable", this.mode === accordionModes.multipleOpen);
				if (this.mode === accordionModes.singleOpen) {
					this._showOpenPanel();
					this._panelList.forEach(function (panel) {
						if (panel.open && panel !== this._selectedChild) {
							this.hide(panel);
						}
					}.bind(this));
				}
			}
		},
		/* jshint maxcomplexity: 10 */

		_useAnimation: function () {
			return (this.animate && (function () {
				// Animation events are broken if the widget is not visible
				var parent = this;
				while (parent && parent.style.display !== "none" && parent !== this.ownerDocument.documentElement) {
					parent = parent.parentNode;
				}
				var visible =  parent === this.ownerDocument.documentElement;

				// Flexbox animation is not supported on IE
				// TODO: Create a feature test for flexbox animation
				return (!!has("animationEndEvent") && visible && (!has("ie")));
			}.bind(this))());
		},

		_doTransition: function (panel, params) {
			var promise;
			if (params.hide) {
				if (this._useAnimation()) {
					// To avoid hiding the panel title bar on animation
					$(panel).addClass("d-accordion-close-animation").removeClass("d-accordion-open-panel");
					panel.style.overflow = "hidden"; //To avoid scrollBar on animation
					promise = listenAnimationEndEvent(panel).then(function () {
						setVisibility(panel, panel.open);
						$(panel).removeClass("d-accordion-close-animation");
						panel.style.overflow = "";
					});
				} else {
					$(panel).removeClass("d-accordion-open-panel");
					setVisibility(panel, false);
				}
			} else {
				if (this._useAnimation()) {
					$(panel).addClass("d-accordion-open-animation");
					setVisibility(panel, true);
					panel.style.overflow = "hidden"; //To avoid scrollBar on animation
					promise = listenAnimationEndEvent(panel).then(function () {
						$(panel).addClass(function () {
							return panel.open ? "d-accordion-open-panel" : "";
						}).removeClass("d-accordion-open-animation");
						panel.style.overflow = "";
						panel.style.minHeight = "";
					});
				} else {
					$(panel).addClass("d-accordion-open-panel");
					setVisibility(panel, true);
				}
			}
			return Promise.resolve(promise);
		},

		changeDisplay: function (widget, params) {
			var valid = true, promises = [];
			if (params.hide) {
				if (widget.open) {
					if (this._numOpenPanels > 1) {
						this._numOpenPanels--;
						widget.open = false;
						widget.headerNode.open = false;
					} else {
						widget.headerNode.open = true;
						valid = false;
					}
				} else {
					widget.headerNode.open = false;
					valid = false;
				}
			} else {
				if (!widget.open) {
					this._numOpenPanels++;
					if (this.mode === accordionModes.singleOpen) {
						var origin = this._selectedChild;
						this._selectedChild = widget;
						this.selectedChildId = widget.id;
						if (origin !== widget) {
							promises.push(this.hide(origin));
						}
					}
					widget.open = true;
					widget.headerNode.open = true;
				} else {
					widget.headerNode.open = true;
					valid = false;
				}
			}
			if (valid) {
				promises.push(this._doTransition(widget, params));
				// Update WAI-ARIA attributes.
				widget.headerNode.setAttribute("aria-selected", "" + widget.open);
				widget.headerNode.setAttribute("aria-expanded", "" + widget.open);
				widget.setAttribute("aria-hidden", "" + !widget.open);
				if (params.hide) {
					widget.headerNode.removeAttribute("aria-controls");
				} else {
					widget.headerNode.setAttribute("aria-controls", widget.id);
				}
			}
			return Promise.all(promises);
		},

		/**
		 * This method must be called to hide the content of a particular child Panel on this container.
		 * The parameter 'params' is optional and only used to specify the content to load on the panel specified.
		 * @method module:deliteful/Accordion#hide
		 * @param {Element|string} dest - Element or Element id that points to the Panel whose content must be hidden
		 * @param {Object} [params] - A hash like {contentId: "newContentId"}. The 'contentId' is the id of the element
		 * to load as content of the Panel.
		 * @returns {Promise} A promise that will be resolved when the display and transition effect will have
		 * been performed.
		 * @fires module:delite/DisplayContainer#delite-display-load
		 * @fires module:delite/DisplayContainer#delite-before-hide
		 * @fires module:delite/DisplayContainer#delite-after-hide
		 */

		/**
		 * This method must be called to display the content of a particular child Panel on this container.
		 * The parameter 'params' is optional and only used to specify the content to load on the panel specified.
		 * loadChild() is used to do this, so a controller could load/create the content by listening the
		 * `delite-display-load` event.
		 * @method module:deliteful/Accordion#show
		 * @param {Element|string} dest - Element or Element id that points to the Panel whose content must be shown
		 * @param {Object} [params] - A hash like {contentId: "newContentId"}. The 'contentId' is the id of the element
		 * to load as content of the Panel.
		 * @returns {Promise} A promise that will be resolved when the display and transition effect will have
		 * been performed.
		 * @fires module:delite/DisplayContainer#delite-display-load
		 * @fires module:delite/DisplayContainer#delite-before-show
		 * @fires module:delite/DisplayContainer#delite-after-show
		 */

		/**
		 * This method must be called to load a particular child on this container.
		 * A `delite-display-load` event is fired giving the chance to a controller to load/create the child by using
		 * the event's setChild() method (the child has to be a deliteful/Panel Element) and/or to load/create
		 * the content for a Panel by using the event's setContent() method. This last method takes as first parameter
		 * the deliteful/Panel Element and as second parameter the Element to load as content for the panel.
		 * @method
		 * @param {Element|string} dest  - Element or Element id that points to the child this container must
		 * load.
		 * @param {Object} [params] - A hash like {contentId: "newContentId"}. The 'contentId' is the id passed to the
		 * controller to load/create an element as content of the Panel.
		 * @returns {Promise} A promise that will be resolved when the child will have been
		 * loaded with an object of the following form: `{ child: panelElement }` or with an optional index
		 * `{ child: panelElement, index: index }`.
		 * @fires module:delite/DisplayContainer#delite-display-load
		 */
		loadChild: dcl.superCall(function (sup) {
			return function (dest, params) {
				var event = {
					setContent: function (panel, content) {
						panel.innerHTML = "";
						while (content.firstChild) {
							panel.appendChild(content.firstChild);
						}
					}
				};
				dcl.mix(event, params);
				return sup.apply(this, [dest, event]);
			};
		}),

		onAddChild: dcl.superCall(function (sup) {
			return function (node) {
				var res = sup.call(this, node);
				if (node.getAttribute("role") !== "tab") {
					// Process new panels (but not the headers created to go along with the panels).
					this._panelList.push(this._setupUpgradedChild(node));
					this.notifyCurrentValue("_panelList");
				}
				return res;
			};
		}),

		_onRemoveChild: function (event) {
			this._panelList.splice(this._panelList.indexOf(event.child), 1);
			this.notifyCurrentValue("_panelList");
		},

		//////////// delite/KeyNav implementation ///////////////////////////////////////
		// Keyboard navigation is based on WAI-ARIA Pattern for Accordion:
		// http://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#accordion

		// Arrow keys should go to first focusable field in each header.
		// To get to the other focusable fields, user should use the tab key.
		// By default, only the header itself is focusable.  If a subclass makes
		// elements inside the header focusable, then it should change descendantSelector.
		descendantSelector: "[role=tab]",

		_getCurrentHeader: function () {
			var node = this.navigatedDescendant;
			while (node && node !== this) {
				if (node.getAttribute("role") === "tab") {
					return node;
				}
				node = node.parentElement;
			}
		},

		/**
		 * Navigate to the next (offset=1) or previous header (offset=-1).
		 * @param offset
		 * @private
		 */
		_switchHeader: function (offset) {
			var focusedHeader = this._getCurrentHeader();
			if (focusedHeader) {
				var headers = this.getHeaders();
				var idx = headers.indexOf(focusedHeader),
					newIdx = (idx + headers.length + offset) % headers.length;
				this.navigateTo(headers[newIdx]);
			}
		},

		previousKeyHandler: function () {
			this._switchHeader(-1);
		},

		nextKeyHandler: function () {
			this._switchHeader(1);
		},

		upKeyHandler: function () {
			this._switchHeader(-1);
		},

		downKeyHandler: function () {
			this._switchHeader(1);
		},

		spacebarKeyHandler: function () {
			var focusedHeader = this._getCurrentHeader();
			this.activatePanel(focusedHeader.panel);
		},

		enterKeyHandler: function () {
			var focusedHeader = this._getCurrentHeader();
			this.activatePanel(focusedHeader.panel);
		},

		focus: function () {
			// Navigate to the header for the first open panel, or if no open panels, then the first header.
			var header = this.children[0];
			for (var i = 0; i < this.children.length; i++) {
				if (this.children[i].open) {
					header = this.children[i];
					break;
				}
			}

			this.navigateTo(header);
		}
	});
});
;
define( 'jquery/src/attributes/classes',[
	"../core",
	"../core/stripAndCollapse",
	"../var/rnothtmlwhite",
	"../data/var/dataPriv",
	"../core/init"
], function( jQuery, stripAndCollapse, rnothtmlwhite, dataPriv ) {

"use strict";

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );

} );
;
// Initialize a jQuery object
define( 'jquery/src/core/init',[
	"../core",
	"../var/document",
	"./var/rsingleTag",
	"../traversing/findFilter"
], function( jQuery, document, rsingleTag ) {

"use strict";

// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );

return init;

} );
;
define( 'jquery/src/traversing/findFilter',[
	"../core",
	"../var/indexOf",
	"./var/rneedsContext",
	"../selector"
], function( jQuery, indexOf, rneedsContext ) {

"use strict";

var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );

} );
;
define( 'jquery/src/selector',[ "./selector-sizzle" ], function() {
	"use strict";
} );
;
define( 'jquery/src/selector-sizzle',[
	"./core",
	"../external/sizzle/dist/sizzle"
], function( jQuery, Sizzle ) {

"use strict";

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;

} );
;
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

// EXPOSE
var _sizzle = window.Sizzle;

Sizzle.noConflict = function() {
	if ( window.Sizzle === Sizzle ) {
		window.Sizzle = _sizzle;
	}

	return Sizzle;
};

if ( typeof define === "function" && define.amd ) {
	define('jquery/external/sizzle/dist/sizzle',[],function() { return Sizzle; });
// Sizzle requires that there be a global window in Common-JS like environments
} else if ( typeof module !== "undefined" && module.exports ) {
	module.exports = Sizzle;
} else {
	window.Sizzle = Sizzle;
}
// EXPOSE

})( window );
;
define( 'jquery/src/traversing/var/rneedsContext',[
	"../../core",
	"../../selector"
], function( jQuery ) {
	"use strict";

	return jQuery.expr.match.needsContext;
} );
;
define( 'jquery/src/var/indexOf',[
	"./arr"
], function( arr ) {
	"use strict";

	return arr.indexOf;
} );
;
define( 'jquery/src/var/arr',[],function() {
	"use strict";

	return [];
} );
;
define( 'jquery/src/core/var/rsingleTag',[],function() {
	"use strict";

	// Match a standalone tag
	return ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
} );
;
define( 'jquery/src/var/document',[],function() {
	"use strict";

	return window.document;
} );
;
define( 'jquery/src/data/var/dataPriv',[
	"../Data"
], function( Data ) {
	"use strict";

	return new Data();
} );
;
define( 'jquery/src/data/Data',[
	"../core",
	"../var/rnothtmlwhite",
	"./var/acceptData"
], function( jQuery, rnothtmlwhite, acceptData ) {

"use strict";

function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};

return Data;
} );
;
define( 'jquery/src/data/var/acceptData',[],function() {

"use strict";

/**
 * Determines whether an object can have data
 */
return function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};

} );
;
define( 'jquery/src/var/rnothtmlwhite',[],function() {
	"use strict";

	// Only count HTML whitespace
	// Other whitespace should count in values
	// https://html.spec.whatwg.org/multipage/infrastructure.html#space-character
	return ( /[^\x20\t\r\n\f]+/g );
} );
;
define( 'jquery/src/core/stripAndCollapse',[
	"../var/rnothtmlwhite"
], function( rnothtmlwhite ) {
	"use strict";

	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}

	return stripAndCollapse;
} );
;
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module

define( 'jquery/src/core',[
	"./var/arr",
	"./var/document",
	"./var/getProto",
	"./var/slice",
	"./var/concat",
	"./var/push",
	"./var/indexOf",
	"./var/class2type",
	"./var/toString",
	"./var/hasOwn",
	"./var/fnToString",
	"./var/ObjectFunctionString",
	"./var/support",
	"./core/DOMEval"
], function( arr, document, getProto, slice, concat, push, indexOf,
	class2type, toString, hasOwn, fnToString, ObjectFunctionString,
	support, DOMEval ) {

"use strict";

var
	version = "@VERSION",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}

return jQuery;
} );
;
define( 'jquery/src/core/DOMEval',[
	"../var/document"
], function( document ) {
	"use strict";

	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}

	return DOMEval;
} );
;
define( 'jquery/src/var/support',[],function() {
	"use strict";

	// All support tests are defined in their respective modules.
	return {};
} );
;
define( 'jquery/src/var/ObjectFunctionString',[
	"./fnToString"
], function( fnToString ) {
	"use strict";

	return fnToString.call( Object );
} );
;
define( 'jquery/src/var/fnToString',[
	"./hasOwn"
], function( hasOwn ) {
	"use strict";

	return hasOwn.toString;
} );
;
define( 'jquery/src/var/hasOwn',[
	"./class2type"
], function( class2type ) {
	"use strict";

	return class2type.hasOwnProperty;
} );
;
define( 'jquery/src/var/toString',[
	"./class2type"
], function( class2type ) {
	"use strict";

	return class2type.toString;
} );
;
define( 'jquery/src/var/class2type',[],function() {
	"use strict";

	// [[Class]] -> type pairs
	return {};
} );
;
define( 'jquery/src/var/push',[
	"./arr"
], function( arr ) {
	"use strict";

	return arr.push;
} );
;
define( 'jquery/src/var/concat',[
	"./arr"
], function( arr ) {
	"use strict";

	return arr.concat;
} );
;
define( 'jquery/src/var/slice',[
	"./arr"
], function( arr ) {
	"use strict";

	return arr.slice;
} );
;
define( 'jquery/src/var/getProto',[],function() {
	"use strict";

	return Object.getPrototypeOf;
} );
;
/**
 * Plugin to load specified jQuery module(s), unless the application has loaded the whole jQuery
 * library via a `<script>` tag, in which case it just returns a pointer to the already loaded jQuery.
 * Useful to avoid loading jQuery twice.
 *
 * @example:
 * To get a jQuery object that can modify classes and do animations:
 * ```
 * require(["requirejs-dplugins/jquery!attributes/classes,effects"], function ($){
 *     ...
 *     $(myNode).addClass("selected");
 *     $(myNode).animate(...);
 * });
 * ```
 *
 * @module requirejs-dplugins/jquery
 */

define('requirejs-dplugins/jquery',[], function () {

	// This is modifying and using the global require() configuration.  Is there a better way?
	// I tried using a local require but it doesn't have a config() method.
	require.config({
		map: {
			jquery: {
				"jquery/src/selector": "jquery/src/selector-native"     // don't pull in sizzle
			}
		}
	});

	// Convert abbreviated list of jQuery modules to real list of jQuery modules
	//		1. Always include jquery/core since some modules like jquery/attributes/classes don't return
	//		   anything.
	//		2. Fix paths to modules by prefixing each module name with jQuery/src.  The "src" directoy
	//		   is to match the directory structure in the jQuery installed via bower.
	//
	// Ex: "attributes/classes,effects" --> ["jquery/src/core", "jquery/src/attributes/classes", "jquery/src/effects"]
	function getModules(str) {
		return ["core"].concat(str.split(/, */)).map(function (amid) {
			return "jquery/src/" + amid;
		});
	}

	return {
		normalize: function (resource) {
			// Don't do any normalization here; it's done when getModules() is called.
			return resource;
		},

		load: function (resource, req, onLoad, config) {
			/* global jQuery */
			/* global $ */
			if (config.isBuild) {
				onLoad();
			} else if (typeof jQuery !== "undefined") {
				onLoad(jQuery);
			} else if (typeof $ !== "undefined") {
				onLoad($);
			} else {
				require(getModules(resource), function ($) {
					onLoad($);
				});
			}
		},

		// Interface for grunt-amd-build.  If the application doesn't want jQuery in the layer it should exclude
		// it through directives to grunt-amd-build.
		addModules: function (pluginName, resource, addModules) {
			addModules(getModules(resource));
		}
	};
});
;
/**
 * Promise plugin.
 *
 * This plugin returns an ES6 compliant Promise implementation. It returns the implementation from the
 * browser if there is one. If the browser does not support Promise, this plugin returns the lie.js
 * Promise shim.
 *
 * @example:
 *      To create a promise:
 *      ```
 *      require(["requirejs-dplugins/Promise!"], function (Promise){
 *         var promise = new Promise(function (resolve, reject) {
 *             ...
 *         });
 *      });
 *      ```
 *
 * @module requirejs-dplugins/Promise
 */
/* global Promise */
define('requirejs-dplugins/Promise',["require"], function (require) {
	var writeFile;
	var lieId = "lie/dist/lie";

	return {
		load: function (name, req, onload, config) {
			config = config || {};
			if (config.isBuild) {
				onload();
			} else if (typeof Promise === "function") {
				onload(Promise);
			} else {
				// Use absolute path to allow map configuration.
				// Also use a variable to avoid RequireJS detection at build time so it is not included in the
				// layer.
				require([lieId], function (lie) {
					onload(lie);
				});
			}
		},
		writeFile: function (pluginName, resource, require, write) {
			writeFile = write;
		},
		onLayerEnd: function () {
			var fs = require("fs");
			var url = require.toUrl(lieId + ".js");
			// copy lie to the build output.
			writeFile(url, fs.readFileSync(url));
		}
	};
});;
define('delite/handlebars!deliteful/Accordion/AccordionHeader/AccordionHeader.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template role=\"tab\" aria-labelledby=\"{{this.widgetId + '_label'}}\" tabindex=\"-1\">\n\t<span role=\"presentation\" attach-point=\"iconNode\" class=\"d-icon {{this.open ? this.openIconClass : this.closedIconClass}}\"></span>\n\t<span attach-point=\"labelNode\" id=\"{{this.widgetId + '_label'}}\">{{label}}</span>\n</template>");
});;
/** @module deliteful/Accordion/AccordionHeader */
define('deliteful/Accordion/AccordionHeader',[
	"delite/a11y",
	"delite/register",
	"delite/Widget",
	"delite/handlebars!./AccordionHeader/AccordionHeader.html"
], function (
	a11y,
	register,
	Widget,
	template
) {
	/**
	 * The header (aka title) that goes above each Panel of an Accordion.
	 * @class module:deliteful/Accordion/AccordionHeader
	 */
	return register("d-accordion-header", [HTMLElement, Widget],
			/** @lends module:deliteful/Accordion/AccordionHeader# */ {
		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-panel"
		 */
		baseClass: "d-accordion-header",

		/**
		 * Header's label.
		 * @member {string}
		 * @default ""
		 */
		label: "",

		/**
		 * Accordion sets this value to true if the corresponding Panel is open.
		 * @member {boolean}
		 */
		open: false,

		/**
		 * CSS class to apply to DOMNode to display an icon for an open panel.
		 * @member {string}
		 * @default ""
		 */
		openIconClass: "",

		/**
		 * CSS class to apply to DOMNode to display an icon for a closed panel.
		 * @member {string}
		 * @default ""
		 */
		closedIconClass: "",

		/**
		 * Corresponding panel.
		 * @member {delite/Widget}
		 */
		panel: null,

		template: template,

		createdCallback: function () {
			this.on("focusin", this.focusinHandler.bind(this));
			this.on("focusout", this.focusoutHandler.bind(this));
			this.on("keydown", this.keydownHandler.bind(this));
		},

		refreshRendering: function (oldVals) {
			if ("panel" in oldVals) {
				this.panel.on("focusin", this.focusinHandler.bind(this));
				this.panel.on("focusout", this.focusoutHandler.bind(this));
			}
		},

		/**
		 * Handler for when header or related panel gets a focus event.
		 * @param evt
		 */
		focusinHandler: function (evt) {
			if (evt.target === this || this.panel.contains(evt.target)) {
				// If the AccordionHeader itself is focused, or if the panel is focused,
				// then set tabIndex=0 so that tab and shift-tab work correctly.
				this.tabIndex = 0;

				// Handling for when there are fields inside the header that can be tab navigated.
				// Set all the tabindexes to 0 so that user can tab around fields in the header.
				Array.prototype.forEach.call(this.querySelectorAll("[tabindex]"), function (node) {
					node.tabIndex = 0;
				});
			} else {
				// If my descendant gets focus, remove my tabIndex to
				// avoid Safari and Firefox problems with nested focusable elements.
				this.removeAttribute("tabindex");
			}
		},

		keydownHandler: function (evt) {
			// The focusinHandler() may have removed my tabIndex, but shift-tab from a node
			// inside of me should still go to me.  Call getFirstInTabbingOrder() on every
			// keystroke in case content changes dynamically.
			if (evt.shiftKey && evt.key === "Tab" && evt.target === a11y.getFirstInTabbingOrder(this)) {
				evt.preventDefault();
				evt.stopPropagation();
				this.tabIndex = 0;
				this.focus();
			}
		},

		/**
		 * Handler for when header or related panel gets a blur event.
		 * @param evt
		 */
		focusoutHandler: function (evt) {
			if (!this.contains(evt.relatedTarget) && !this.panel.contains(evt.relatedTarget)) {
				// Set all the tabindexes to -1 so that tabbing doesn't hit unselected headers.
				this.tabIndex = -1;
				Array.prototype.forEach.call(this.querySelectorAll("[tabindex]"), function (node) {
					node.tabIndex = -1;
				});
			}
		}
	});
});
;
/**
 * Accessibility utility functions (keyboard, tab stops, etc.).
 * @module delite/a11y
 * */
define('delite/a11y',[], function () {

	var a11y = /** @lends module:delite/a11y */ {
		/**
		 * Returns true if Element is visible.
		 * @param {Element} elem - The Element.
		 * @returns {boolean}
		 * @private
		 */
		_isElementShown: function (elem) {
			var s = getComputedStyle(elem);
			return s.visibility !== "hidden"
				&& s.visibility !== "collapsed"
				&& s.display !== "none"
				&& elem.type !== "hidden";
		},

		/**
		 * Tests if element is tab-navigable even without an explicit tabIndex setting
		 * @param {Element} elem - The Element.
		 * @returns {boolean}
		 */
		hasDefaultTabStop: function (elem) {
			/* jshint maxcomplexity:11 */

			// No explicit tabIndex setting, need to investigate node type
			switch (elem.nodeName.toLowerCase()) {
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return elem.hasAttribute("href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				var contentDocument = elem.contentDocument;
				if ("designMode" in contentDocument && contentDocument.designMode === "on") {
					return true;
				}
				var body = contentDocument.body;
				return body && (body.contentEditable === "true" ||
					(body.firstChild && body.firstChild.contentEditable === "true"));
			default:
				return elem.contentEditable === "true";
			}
		},

		/**
		 * Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.
		 * @param {Element} elem - The Element.
		 * @returns {number|undefined}
		 */
		effectiveTabIndex: function (elem) {
			if (elem.disabled) {
				return undefined;
			} else if (elem.hasAttribute("tabIndex")) {
				// Explicit tab index setting
				return +elem.getAttribute("tabIndex");// + to convert string --> number
			} else {
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		/**
		 * Tests if an element is tab-navigable.
		 * @param {Element} elem - The Element.
		 * @returns {boolean}
		 */
		isTabNavigable: function (elem) {
			return a11y.effectiveTabIndex(elem) >= 0;
		},

		/**
		 * Tests if an element is focusable by tabbing to it, or clicking it with the mouse.
		 * @param {Element} elem - The Element.
		 * @returns {boolean}
		 */
		isFocusable: function (elem) {
			return a11y.effectiveTabIndex(elem) >= -1;
		},

		/**
		 * Finds descendants of the specified root node.
		 *
		 * The following descendants of the specified root node are returned:
		 *
		 * - the first tab-navigable element in document order without a tabIndex or with tabIndex="0"
		 * - the last tab-navigable element in document order without a tabIndex or with tabIndex="0"
		 * - the first element in document order with the lowest positive tabIndex value
		 * - the last element in document order with the highest positive tabIndex value
		 *
		 * @param Element root - The Element.
		 * @returns {Object} Hash of the format `{first: Element, last: Element, lowest: Element, highest: Element}`.
		 * @private
		 */
		_getTabNavigable: function (root) {
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node) {
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() === "input" &&
					node.type && node.type.toLowerCase() === "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;

			function walkTree(/*Element*/ parent) {
				/* jshint maxcomplexity:14 */
				for (var child = parent.firstChild; child; child = child.nextSibling) {
					// Skip text elements, hidden elements
					if (child.nodeType !== 1 || !shown(child)) {
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if (tabindex >= 0) {
						if (tabindex === 0) {
							if (!first) {
								first = child;
							}
							last = child;
						} else if (tabindex > 0) {
							if (!lowest || tabindex < lowestTabindex) {
								lowestTabindex = tabindex;
								lowest = child;
							}
							if (!highest || tabindex >= highestTabindex) {
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if (child.checked && rn) {
							radioSelected[rn] = child;
						}
					}
					if (child.nodeName.toUpperCase() !== "SELECT") {
						walkTree(child);
					}
				}
			}

			if (shown(root)) {
				walkTree(root);
			}
			function rs(node) {
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		/**
		 * Finds the descendant of the specified root node that is first in the tabbing order.
		 * @param {string|Element} root
		 * @param {Document} [doc]
		 * @returns {Element}
		 */
		getFirstInTabbingOrder: function (root, doc) {
			if (typeof root === "string") {
				root = (doc || document).getElementById(root);
			}
			var elems = a11y._getTabNavigable(root);
			return elems.lowest ? elems.lowest : elems.first;
		},

		/**
		 * Finds the descendant of the specified root node that is last in the tabbing order.
		 * @param {string|Element} root
		 * @param {Document} [doc]
		 * @returns {Element}
		 */
		getLastInTabbingOrder: function (root, doc) {
			if (typeof root === "string") {
				root = (doc || document).getElementById(root);
			}
			var elems = a11y._getTabNavigable(root);
			return elems.last ? elems.last : elems.highest;
		}
	};

	return a11y;
});
;
/** @module delite/DisplayContainer */
define('delite/DisplayContainer',["dcl/dcl", "requirejs-dplugins/Promise!", "./Container"],
	function (dcl, Promise, Container) {
	
	/**
	 * Dispatched before child is shown.
	 * @example
	 * document.addEventListener("delite-before-show", function (evt) {
	 *      console.log("about to show child", evt.child);
	 * });
	 * @event module:delite/DisplayContainer#delite-before-show
	 * @property {Element} child - reference to child element
	 */
	
	/**
	 * Dispatched after child is shown.
	 * @example
	 * document.addEventListener("delite-after-show", function (evt) {
	 *      console.log("just displayed child", evt.child);
	 * });
	 * @event module:delite/DisplayContainer#delite-after-show
	 * @property {Element} child - reference to child element
	 */
	
	/**
	 * Dispatched to let an application level listener create/load the child node.
	 * @example
	 * document.addEventListener("delite-display-load", function (evt) {
	 *     evt.setChild(new Promise(function (resolve, reject) {
	 *         // fetch the data for the specified id, then create a node with that data
	 *         fetchData(evt.dest).then(function(data) {
	 *             var child = document.createElement("div");
	 *             child.innerHTML = data;
	 *             resolve({child: child});
	 *         });
	 *     );
	 * });
	 * @event module:delite/DisplayContainer#delite-display-load
	 * @property {Function} setChild - method to set child element, or Promise for child element
	 */
	
	/**
	 * Dispatched before child is hidden.
	 * @example
	 * document.addEventListener("delite-before-hide", function (evt) {
	 *      console.log("about to hide child", evt.child);
	 * });
	 * @event module:delite/DisplayContainer#delite-before-hide
	 * @property {Element} child - reference to child element
	 */
	
	/**
	 * Dispatched after child is hidden.
	 * @example
	 * document.addEventListener("delite-after-hide", function (evt) {
	 *      console.log("just hid child", evt.child);
	 * });
	 * @event module:delite/DisplayContainer#delite-after-hide
	 * @property {Element} child - reference to child element
	 */
	
	/**
	 * Mixin for widget containers that need to show on or off a child.
	 *
	 * When the show method is called a container extending this mixin is able to be notified that one of
	 * its children must be displayed. Before displaying it, it will fire the `delite-display-load` event
	 * giving a chance to a listener to load and create the child if not yet available before proceeding with
	 * the display. After the display has been performed a `delite-display-complete` event will be fired.
	 * @mixin module:delite/DisplayContainer
	 * @augments module:delite/Container
	 */
	return dcl(Container, /** @lends module:delite/DisplayContainer# */ {
		/**
		 * This method must be called to display a particular destination child on this container.
		 * @param {Element|string} dest - Element or Element id that points to the child this container must
		 * display.
		 * @param {Object} [params] - Optional params that might be taken into account when displaying the child.
		 * This can be the type of visual transitions involved. This might vary from one DisplayContainer to another.
		 * @returns {Promise} A promise that will be resolved when the display & transition effect will have been
		 * performed.
		 * @fires module:delite/DisplayContainer#delite-before-show
		 * @fires module:delite/DisplayContainer#delite-after-show
		 * @fires module:delite/DisplayContainer#delite-display-load
		 */
		show: function (dest, params) {
			var self = this;
			return this.loadChild(dest, params).then(function (value) {
				// if view is not already a child this means we loaded a new view (div), add it
				if (self.getIndexOfChild(value.child) === -1) {
					self.addChild(value.child, value.index);
				}
				// the child is here, actually perform the display
				// notify everyone we are going to proceed
				var event = {
					dest: dest,
					cancelable: false
				};
				dcl.mix(event, params);
				dcl.mix(event, value);

				self.emit("delite-before-show", event);

				return Promise.resolve(self.changeDisplay(value.child, event)).then(function () {
					self.emit("delite-after-show", event);

					return value;
				});
			});
		},

		/**
		 * This method must be called to hide a particular destination child on this container.
		 * @param {Element|string} dest - Element or Element id that points to the child this container must
		 * hide.
		 * @param {Object} [params] - Optional params that might be taken into account when hiding the child.
		 * This can be the type of visual transitions involved.  This might vary from one DisplayContainer to another.
		 * @returns {Promise} A promise that will be resolved when the display & transition effect will have been
		 * performed.
		 * @fires module:delite/DisplayContainer#delite-display-load
		 * @fires module:delite/DisplayContainer#delite-before-hide
		 * @fires module:delite/DisplayContainer#delite-after-hide
		 */
		hide: function (dest, params) {
			var args = {hide: true};
			dcl.mix(args, params);
			var self = this;
			return this.loadChild(dest, args).then(function (value) {
				// the child is here, actually perform the display
				// notify everyone we are going to proceed
				var event = {
					dest: dest,
					bubbles: true,
					cancelable: false,
					hide: true
				};
				dcl.mix(event, params);
				dcl.mix(event, value);

				self.emit("delite-before-hide", event);

				return Promise.resolve(self.changeDisplay(value.child, event)).then(function () {
					// one might listen to that event and actuall remove the child if needed (view unload feature)
					self.emit("delite-after-hide", event);
					return value;
				});
			});
		},

		/**
		 * This method must perform the display and possible transition effect.  It is meant to be specialized by
		 * subclasses.
		 * @param {Element|string} widget - Element or Element id that points to the child this container must
		 * show or hide.
		 * @param {Object} [params] - Optional params that might be taken into account when displaying the child.  This
		 * can be the type of visual transitions involved.  This might vary from one DisplayContainer to another.
		 * By default on the "hide" param is supporting meaning that the transition should hide the widget
		 * not display it.
		 * @returns {Promise} Optionally a promise that will be resolved when the display & transition effect will have
		 * been performed.
		 */
		changeDisplay: function (widget, /*jshint unused: vars*/params) {
			if (params.hide === true) {
				widget.style.visibility = "hidden";
				widget.style.display = "none";
			} else {
				widget.style.visibility = "visible";
				widget.style.display = "";
			}
		},

		/**
		 * This method must be called to load a particular child on this container.
		 * A `delite-display-load` event is fired giving the chance to a controller to load/create the child.
		 * This method can be redefined to actually load a child of the container. If a controller is not present,
		 * it just looks up elements by id.
		 * @param {Element|string} dest  - Element or Element id that points to the child this container must
		 * load.
		 * @param {Object} [params] - Optional params that might be taken into account when removing the child.
		 * @returns {Promise} A promise that will be resolved when the child will have been
		 * loaded with an object of the following form: `{ child: childElement }` or with an optional index
		 * `{ child: childElement, index: index }`. Other properties might be added to	the object if needed.
		 * @fires module:delite/DisplayContainer#delite-display-load
		 */
		loadChild: function (dest, params) {
			// we need to warn potential app controller we are going to load a view
			var child, event = {
				dest: dest,
				setChild: function (val) {
					child = val;
				}
			};
			dcl.mix(event, params);

			// we now need to warn potential app controller we need to load a new child.
			// if the controller specifies the child then use it,
			// otherwise call the container load method
			this.emit("delite-display-load", event);
			if (!child) {
				child = { child: typeof dest === "string" ? this.ownerDocument.getElementById(dest) : dest };
			}
			return Promise.resolve(child);
		}
	});
});;
/** @module delite/KeyNav */
define('delite/KeyNav',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass(), removeClass()
	"./features",
	"./Widget",
	"dpointer/events"		// so can just monitor for "pointerdown"
], function (dcl, $, has, Widget) {

	/**
	 * Dispatched after the user has selected a different descendant, by clicking, arrow keys,
	 * or keyboard search.
	 * @example
	 * widget.on("keynav-child-navigated", function (evt) {
	 *	console.log("old value: " + evt.oldValue);
	 *	console.log("new value: " + evt.newValue);
	 * }
	 * @event module:delite/KeyNav#keynav-child-navigated
	 * @property {number} oldValue - The previously selected item.
	 * @property {number} newValue - The new selected item.
	 */

	/**
	 * Return true if node is an `<input>` or similar that responds to keyboard input.
	 * @param {Element} node
	 * @returns {boolean}
	 */
	function takesInput(node) {
		var tag = node.nodeName.toLowerCase();

		return !node.readOnly && (tag === "textarea" || (tag === "input" &&
			/^(color|email|number|password|search|tel|text|url|range)$/.test(node.type)));
	}

	/**
	 * Return true if node is "clickable" via keyboard space / enter key
	 * @param {Element} node
	 * @returns {boolean}
	 */
	function keyboardClickable(node) {
		return !node.readOnly && /^(button|a)$/i.test(node.nodeName);
	}

	/**
	  * A mixin to allow arrow key and letter key navigation of child Elements.
	  * It can be used by delite/Container based widgets with a flat list of children,
	  * or more complex widgets like a Tree.
	  *
	  * To use this mixin, the subclass must:
	  *
	  * - Implement one method for each keystroke that the subclass wants to handle.
	  *   The methods for up and down arrow keys are `upKeyHandler() and `downKeyHandler()`.
	  *   For BIDI support, the left and right arrows are handled specially, mapped to the `previousKeyHandler()`
	  *   and `nextKeyHandler()` methods in LTR mode, or reversed in RTL mode.
	  *   Otherwise, the method name is based on the key names
	  *   defined by https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key, for example `homeKeyHandler()`.
	  *   The method takes two parameters: the event, and the currently navigated node.
	  *   Most subclasses will want to implement either `previousKeyHandler()`
	  *   and `nextKeyHandler()`, or `downKeyHandler()` and `upKeyHandler()`.
	  * - Set all navigable descendants' initial tabIndex to "-1"; both initial descendants and any
	  *   descendants added later, by for example `addChild()`.  Exception: if `focusDescendants` is false then the
	  *   descendants shouldn't have any tabIndex at all.
	  * - Define `descendantSelector` as a function or string that identifies navigable child Elements.
	  * - If the descendant elements contain text, they should have a label attribute.  KeyNav uses the label
	  *   attribute for letter key navigation.
	  *
	  * @mixin module:delite/KeyNav
	  * @augments module:delite/Widget
	  */
	return dcl(Widget, /** @lends module:delite/KeyNav# */ {

		/*jshint -W101*/
		/**
		 * When true, focus the descendant widgets as the user navigates to them via arrow keys or keyboard letter
		 * search.  When false, rather than focusing the widgets, it merely sets `navigatedDescendant`,
		 * and sets the `d-active-descendant` class on the descendant widget the user has navigated to.
		 *
		 * False mode is intended for widgets like ComboBox where the focus is somewhere outside this widget
		 * (typically on an `<input>`) and keystrokes are merely being forwarded to the KeyNav widget.
		 *
		 * When set to false:
		 *
		 * - Navigable descendants shouldn't have any tabIndex (as opposed to having tabIndex=-1).
		 * - The focused element should specify `aria-owns` to point to this KeyNav Element.
		 * - The focused Element must be kept synced so that `aria-activedescendant` points to the currently
		 *   navigated descendant.  Do this responding to the `keynav-child-navigated` event emitted by this widget,
		 *   or by calling `observe()` and monitoring changed to `navigatedDescendant`.
		 * - The focused Element must forward keystrokes by calling `emit("keydown", ...)` and/or
		 *   `emit("keypress", ...)` on this widget.
		 * - You must somehow set the initial navigated descendant, typically by calling `navigateToFirst()` either
		 *   when the the dropdown is opened, or on the first call to `downKeyHandler()`.
		 * - You must have some CSS styling so that the currently navigated node is apparent.
		 *
		 * See http://www.w3.org/WAI/GL/wiki/Using_aria-activedescendant_to_allow_changes_in_focus_within_widgets_to_be_communicated_to_Assistive_Technology#Example_1:_Combobox
		 * for details.
		 * @member {boolean}
		 * @default true
		 * @protected
		 */
		focusDescendants: true,
		/*jshint +W101*/

		/**
		 * The currently navigated descendant, or null if there isn't one.
		 * @member {Element}
		 * @readonly
		 * @protected
		 */
		navigatedDescendant: null,

		/**
		 * Selector to identify which descendant Elements are navigable via arrow keys or
		 * keyboard search.  Note that for subclasses like a Tree, one navigable node could be a descendant of another.
		 *
		 * It's either a function that takes an Element parameter and returns true/false,
		 * or a CSS selector string, for example ".list-item".
		 *
		 * By default, the direct DOM children of this widget are considered the selectable descendants.
		 *
		 * Must be set in the prototype rather than on the instance.
		 *
		 * @member {string|Function}
		 * @protected
		 * @constant
		 */
		descendantSelector: null,

		/**
		 * The node to receive the KeyNav behavior.
		 * Can be set in a template via a `attach-point` assignment.
		 * If missing, then `this.containerNode` or `this` will be used.
		 * If set, then subclass must set the tabIndex on this node rather than the root node.
		 * @member {Element}
		 * @protected
		 */
		keyNavContainerNode: null,

		/**
		 * Figure out effective navigable descendant of this event.
		 * @param {Event} evt
		 * @private
		 */
		_getTargetElement: function (evt) {
			for (var child = evt.target; child !== this; child = child.parentNode) {
				if (this._selectorFunc(child)) {
					return child;
				}
			}
			return null;
		},

		postRender: function () {
			// If keyNavContainerNode unspecified, set to default value.
			if (!this.keyNavContainerNode) {
				this.keyNavContainerNode = this.containerNode || this;
			}

			this.on("keypress", this._keynavKeyPressHandler.bind(this), this.keyNavContainerNode);
			this.on("keydown", this._keynavKeyDownHandler.bind(this), this.keyNavContainerNode);

			this.on("pointerdown", this.pointerdownHandler.bind(this), this.keyNavContainerNode);
			this.on("focusin", this.focusinHandler.bind(this), this.keyNavContainerNode);
			this.on("focusout", this.focusoutHandler.bind(this), this.keyNavContainerNode);

			// Setup function to check which child nodes are navigable.
			if (typeof this.descendantSelector === "string") {
				var matchesFuncName = has("dom-matches");
				this._selectorFunc = function (elem) {
					return elem[matchesFuncName](this.descendantSelector);
				};
			} else if (this.descendantSelector) {
				this._selectorFunc = this.descendantSelector;
			} else {
				this._selectorFunc = function (elem) { return elem.parentNode === this.containerNode; };
			}
		},

		attachedCallback: function () {
			// If the user hasn't specified a tabindex declaratively, then set to default value.
			var container = this.keyNavContainerNode;
			if (this.focusDescendants && !container.hasAttribute("tabindex")) {
				container.tabIndex = "0";
			}
		},

		/**
		 * Called on pointerdown event (on container or child of container).
		 * Navigation occurs on pointerdown, to match behavior of native elements.
		 * Normally this handler isn't needed as it's redundant w/the focusin event.
		 */
		pointerdownHandler: function (evt) {
			var target = this._getTargetElement(evt);
			if (target) {
				this._descendantNavigateHandler(target, evt);
			}
		},

		/**
		 * Called on focus of container or child of container.
		 */
		focusinHandler: function (evt) {
			var container = this.keyNavContainerNode;
			if (this.focusDescendants) {
				if (evt.target === this || evt.target === container) {
					// Ignore spurious focus event:
					// On IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
					if (!this.navigatedDescendant) {
						// Focus the first child but do it on a delay so that activationTracker sees my "focus"
						// event before seeing the "focus" event on the child widget.
						this.defer(this.focus);
					}
				} else {
					// When container's descendant gets focus,
					// remove the container's tabIndex so that tab or shift-tab
					// will go to the fields after/before the container, rather than the container itself.
					// Also avoids Safari and Firefox problems with nested focusable elements.
					if (container.hasAttribute("tabindex")) {
						this._savedTabIndex = container.tabIndex;
						container.removeAttribute("tabindex");
					}

					// Handling for when navigatedDescendant or a node inside a navigableDescendant gets focus.
					var navigatedDescendant = this._getTargetElement(evt);
					if (navigatedDescendant) {
						if (evt.target === navigatedDescendant) {
							// If the navigable descendant itself is focused, then set tabIndex=0 so that tab and
							// shift-tab work correctly.
							navigatedDescendant.tabIndex = this._savedTabIndex;
						}

						// Note: when focus is moved outside the navigable descendant,
						// focusoutHandler() resets its tabIndex to -1.

						this._descendantNavigateHandler(navigatedDescendant, evt);
					}
				}
			}
		},

		/**
		 * Called on blur of container or child of container.
		 */
		focusoutHandler: function (evt) {
			if (this.focusDescendants) {
				// Note: don't use this.navigatedDescendant because it may or may not have already been
				// updated to point to the new descendant, depending on if navigation was by mouse
				// or keyboard.
				var previouslyNavigatedDescendant = this._getTargetElement(evt);
				if (previouslyNavigatedDescendant) {
					if (previouslyNavigatedDescendant !== evt.relatedTarget) {
						// If focus has moved outside of the previously navigated descendant, then set its
						// tabIndex back to -1, for future time when navigable descendant is clicked.
						previouslyNavigatedDescendant.tabIndex = "-1";
						$(previouslyNavigatedDescendant).removeClass("d-active-descendant");

						if (this.navigatedDescendant === previouslyNavigatedDescendant) {
							this.navigatedDescendant = null;
						}
					}
				}

				// If focus has moved outside of container, then restore container's tabindex.
				if ("_savedTabIndex" in this && !this.keyNavContainerNode.contains(evt.relatedTarget)) {
					this.keyNavContainerNode.setAttribute("tabindex", this._savedTabIndex);
					delete this._savedTabIndex;
				}
			}
		},

		/**
		 * Called on home key.
		 * @param {Event} evt
		 * @param {Element} navigatedDescendant
		 * @protected
		 */
		homeKeyHandler: function (evt) {
			this.navigateToFirst(evt);
		},

		/**
		 * Called on end key.
		 * @param {Event} evt
		 * @param {Element} navigatedDescendant
		 * @protected
		 */
		endKeyHandler: function (evt) {
			this.navigateToLast(evt);
		},

		/**

		/**
		 * Default focus() implementation: navigate to the first navigable descendant.
		 * Note that if `focusDescendants` is false, this will merely set the `d-active-descendant` class
		 * rather than actually focusing the descendant.
		 */
		focus: function () {
			this.navigateToFirst();
		},

		/**
		 * Navigate to the first navigable descendant.
		 * Note that if `focusDescendants` is false, this will merely set the `d-active-descendant` class
		 * rather than actually focusing the descendant.
		 * @param {Event} [triggerEvent] - The event that lead to the navigation, or `undefined`
		 *     if the navigation is triggered programmatically.
		 * @protected
		 */
		navigateToFirst: function (triggerEvent) {
			this.navigateTo(this.getNext(this.keyNavContainerNode, 1), triggerEvent);
		},

		/**
		 * Navigate to the last navigable descendant.
		 * Note that if `focusDescendants` is false, this will merely set the `d-active-descendant` class
		 * rather than actually focusing the descendant.
		 * @param {Event} [triggerEvent] - The event that lead to the navigation, or `undefined`
		 *     if the navigation is triggered programmatically.
		 * @protected
		 */
		navigateToLast: function (triggerEvent) {
			this.navigateTo(this.getNext(this.keyNavContainerNode, -1), false, triggerEvent);
		},

		/**
		 * Navigate to the specified descendant.
		 * Note that if `focusDescendants` is false, this will merely set the `d-active-descendant` class
		 * rather than actually focusing the descendant.
		 * @param {Element} child - Reference to the descendant.
		 * @param {boolean} [last] - If true and if descendant has multiple focusable nodes, focus the
		 *     last one instead of the first one.  This assumes that the child's `focus()` method takes a boolean
		 *     parameter where `true` means to focus the last child.
		 * @param {Event} [triggerEvent] - The event that lead to the navigation, or `undefined`
		 *     if the navigation is triggered programmatically.
		 * @protected
		 */
		navigateTo: function (child, last, triggerEvent) {
			if (this.focusDescendants) {
				// For IE focus outline to appear, must set tabIndex before focus.
				// If this._savedTabIndex is set, use it instead of this.tabIndex, because it means
				// the container's tabIndex has already been changed to -1.
				child.tabIndex = "_savedTabIndex" in this ? this._savedTabIndex : this.keyNavContainerNode.tabIndex;
				child.focus(last ? "end" : "start");

				// _descendantNavigateHandler() will be called automatically from child's focus event.
			} else {
				this._descendantNavigateHandler(child, triggerEvent);
			}
		},

		/**
		 * Called when a child is navigated to, either by user clicking it, or programatically by arrow key handling
		 * code.  It marks that the specified child is the navigated one.
		 * @param {Element} child
		 * @param {Event} triggerEvent - The event that lead to the navigation, or `undefined`
		 *     if the navigation is triggered programmatically.
		 * @fires module:delite/KeyNav#keynav-child-navigated
		 * @private
		 */
		_descendantNavigateHandler: function (child, triggerEvent) {
			if (child && child !== this.navigatedDescendant) {
				if (this.navigatedDescendant) {
					$(this.navigatedDescendant).removeClass("d-active-descendant");
					this.navigatedDescendant.tabIndex = "-1";
				}

				this.emit("keynav-child-navigated", {
					oldValue: this.navigatedDescendant,
					newValue: child,
					triggerEvent: triggerEvent
				});

				// mark that the new node is the currently navigated one
				this.navigatedDescendant = child;
				if (child) {
					$(child).addClass("d-active-descendant");
				}
			}
		},

		_searchString: "",

		/**
		 * If multiple characters are typed where each keystroke happens within
		 * multiCharSearchDuration of the previous keystroke,
		 * search for nodes matching all the keystrokes.
		 *
		 * For example, typing "ab" will search for entries starting with
		 * "ab" unless the delay between "a" and "b" is greater than `multiCharSearchDuration`.
		 *
		 * @member {number} KeyNav#multiCharSearchDuration
		 * @default 1000
		 */
		multiCharSearchDuration: 1000,

		/**
		 * When a key is pressed that matches a child item,
		 * this method is called so that a widget can take appropriate action if necessary.
		 *
		 * @param {Element} item
		 * @param {Event} evt
		 * @param {string} searchString
		 * @param {number} numMatches
		 * @private
		 */
		_keyboardSearchHandler: function (item, /*jshint unused: vars */ evt, searchString, numMatches) {
			if (item) {
				this.navigateTo(item);
			}
		},

		/**
		 * Compares the searchString to the Element's text label, returning:
		 *
		 * - -1: a high priority match  and stop searching
		 * - 0: not a match
		 * - 1: a match but keep looking for a higher priority match
		 *
		 * @param {Element} item
		 * @param {string} searchString
		 * @returns {number}
		 * @private
		 */
		_keyboardSearchCompare: function (item, searchString) {
			var element = item,
				text = item.label || (element.focusNode ? element.focusNode.label : "") || element.textContent || "",
				currentString = text.replace(/^\s+/, "").substr(0, searchString.length).toLowerCase();

			// stop searching after first match by default
			return (!!searchString.length && currentString === searchString) ? -1 : 0;
		},

		/**
		 * Called when keydown.  Ignores key events inside <input>, <button>, etc.,
		 * and passes the other events to the _processKeyDown() method.
		 * @param {Event} evt
		 * @private
		 */
		_keynavKeyDownHandler: function (evt) {
			// Ignore left, right, home, end, and space on <input> controls.
			if (takesInput(evt.target) &&
				(evt.key === "ArrowLeft" || evt.key === "ArrowRight" ||
				evt.key === "Home" || evt.key === "End" || evt.key === "Spacebar")) {
				return;
			}

			// Ignore space and enter on <button> elements.
			if (keyboardClickable(evt.target) && (evt.key === "Enter" || evt.key === "Spacebar")) {
				return;
			}

			this._processKeyDown(evt);
		},

		/**
		 * Called when there's a keydown event that should be handled by the KeyNav class.
		 * @param evt
		 * @private
		 */
		_processKeyDown: function (evt) {
			if (evt.key === "Spacebar" && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)) {
				// If the user types some string like "new york", interpret the space as part of the search rather
				// than to perform some action, even if there is a key handler method defined.

				// Stop a11yclick from interpreting key as a click event.
				// Also stop IE from scrolling, and most browsers (except FF) from emitting keypress event.
				evt.preventDefault();

				this._keyboardSearch(evt, " ");
			} else {
				// Otherwise call the handler specified in this.keyHandlers.
				this._applyKeyHandler(evt);
			}
		},

		/**
		 * If the class has defined a method to handle the specified key, then call it.
		 * See the description of `KeyNav` for details on how to define methods.
		 * @param {Event} evt
		 * @private
		 */
		_applyKeyHandler: function (evt) {
			// Get name of method to call
			var methodName;
			switch (evt.key) {
			case "ArrowLeft":
				methodName = this.effectiveDir === "rtl" ? "nextKeyHandler" : "previousKeyHandler";
				break;
			case "ArrowRight":
				methodName = this.effectiveDir === "rtl" ? "previousKeyHandler" : "nextKeyHandler";
				break;
			case "ArrowUp":
			case "ArrowDown":
				methodName = evt.key.charAt(5).toLowerCase() + evt.key.substr(6) + "KeyHandler";
				break;
			default:
				methodName = evt.key.charAt(0).toLowerCase() + evt.key.substr(1) + "KeyHandler";
			}

			// Call it
			var func = this[methodName];
			if (func) {
				func.call(this, evt, this.navigatedDescendant);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ""; // so a DOWN_ARROW b doesn't search for ab
			}
		},

		/**
		 * When a printable key is pressed, it's handled here, searching by letter.
		 * @param {Event} evt
		 * @private
		 */
		_keynavKeyPressHandler: function (evt) {
			// Ignore:
			//		- keystrokes on <input> and <textarea>
			// 		- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)
			//		- control sequences like CMD-Q.
			//		- the SPACE key (only occurs on FF)
			//
			// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search
			// in progress, then SPACE is handled in _keynavKeyDownHandler.
			if (takesInput(evt.target) || evt.charCode <= 32 || evt.ctrlKey || evt.altKey || evt.metaKey) {
				return;
			}

			evt.preventDefault();
			evt.stopPropagation();

			this._keyboardSearch(evt, evt.key.toLowerCase());
		},

		/**
		 * Perform a search of the widget's options based on the user's keyboard activity.
		 *
		 * Called on keypress (and sometimes keydown), searches through this widget's children
		 * looking for items that match the user's typed search string.  Multiple characters
		 * typed within `multiCharSearchDuration` of each other are combined for multi-character searching.
		 * @param {Event} evt
		 * @param {string} keyChar
		 * @private
		 */
		_keyboardSearch: function (evt, keyChar) {
			var
				matchedItem = null,
				searchString,
				numMatches = 0;

			if (this._searchTimer) {
				this._searchTimer.remove();
			}
			this._searchString += keyChar;
			var allSameLetter = /^(.)\1*$/.test(this._searchString);
			var searchLen = allSameLetter ? 1 : this._searchString.length;
			searchString = this._searchString.substr(0, searchLen);
			this._searchTimer = this.defer(function () { // this is the "success" timeout
				this._searchTimer = null;
				this._searchString = "";
			}, this.multiCharSearchDuration);
			var currentItem = this.navigatedDescendant || null;
			if (searchLen === 1 || !currentItem) {
				currentItem = this.getNext(currentItem, 1); // skip current
				if (!currentItem) {
					return;
				} // no items
			}
			var stop = currentItem;
			do {
				var rc = this._keyboardSearchCompare(currentItem, searchString);
				if (!!rc && numMatches++ === 0) {
					matchedItem = currentItem;
				}
				if (rc === -1) { // priority match
					numMatches = -1;
					break;
				}
				currentItem = this.getNext(currentItem, 1);
			} while (currentItem !== stop);

			this._keyboardSearchHandler(matchedItem, evt, searchString, numMatches);
		},

		/**
		 * Returns the next or previous navigable descendant, relative to "child".
		 * If "child" is this, then it returns the first focusable descendant (when dir === 1)
		 * or last focusable descendant (when dir === -1).
		 * @param {Element} child - The current child Element.
		 * @param {number} dir - 1 = after, -1 = before
		 * @returns {Element}
		 * @protected
		 */
		getNext: function (child, dir) {
			var container = this.keyNavContainerNode, origChild = child;
			function dfsNext(node) {
				if (node.firstElementChild) { return node.firstElementChild; }
				while (node !== container) {
					if (node.nextElementSibling) { return node.nextElementSibling; }
					node = node.parentNode;
				}
				return container;	// loop around, plus corner case when no children
			}
			function dfsLast(node) {
				while (node.lastElementChild) { node = node.lastElementChild; }
				return node;
			}
			function dfsPrev(node) {
				return node === container ? dfsLast(container) : // loop around, plus corner case when no children
					(node.previousElementSibling && dfsLast(node.previousElementSibling)) || node.parentNode;
			}
			while (true) {
				child = dir > 0 ? dfsNext(child) : dfsPrev(child);
				if (child === origChild) {
					return null;	// looped back to original child
				} else if (this._selectorFunc(child)) {
					return child;	// this child matches
				}
			}
		}
	});
});
;
define('delite/features',["requirejs-dplugins/has"], function (has) {
	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files.
	has.add("config-bgIframe", false);

	// Flag to enable advanced bidi support
	has.add("bidi", false);

	// Flag to enable inheritance direction from any ancestor
	has.add("inherited-dir", false);

	if (typeof window !== "undefined") {
		// Returns the name of the method to test if an element matches a CSS selector.
		has.add("dom-matches", function () {
			var node = document.body;
			if (node.matches) {
				return "matches";
			}
			if (node.webkitMatchesSelector) {
				return "webkitMatchesSelector";
			}
			if (node.mozMatchesSelector) {
				return "mozMatchesSelector";
			}
			if (node.msMatchesSelector) {
				return "msMatchesSelector";
			}
		});

		// Does platform have native support for document.registerElement() or a polyfill to simulate it?
		has.add("document-register-element", !!document.registerElement);

		// Test for how to monitor DOM nodes being inserted and removed from the document.
		// For DOMNodeInserted events, there are two variations:
		//		"root" - just notified about the root of each tree added to the document
		//		"all" - notified about all nodes added to the document
		has.add("MutationObserver", window.MutationObserver ? "MutationObserver" : window.WebKitMutationObserver ?
			"WebKitMutationObserver" : "");
		has.add("DOMNodeInserted", function () {
			var root = document.createElement("div"),
				child = document.createElement("div"),
				sawRoot, sawChild;
			root.id = "root";
			child.id = "child";
			root.appendChild(child);

			function listener(event) {
				if (event.target.id === "root") {
					sawRoot = true;
				}
				if (event.target.id === "child") {
					sawChild = true;
				}
			}

			document.body.addEventListener("DOMNodeInserted", listener);
			document.body.appendChild(root);
			document.body.removeChild(root);
			document.body.removeEventListener("DOMNodeInserted", listener);
			return sawChild ? "all" : sawRoot ? "root" : "";
		});

		// Can we use __proto__ to reset the prototype of DOMNodes?
		// It's not available on IE<11, and even on IE11 it makes the node's attributes
		// (ex: node.attributes, node.textContent) disappear, so disabling it on IE11 too.
		has.add("dom-proto-set", function () {
			var node = document.createElement("div");
			/* jshint camelcase: false */
			/* jshint proto: true */
			return !!node.__proto__;
			/* jshint camelcase: true */
			/* jshint proto: false */
		});

		// Support for <template> elements (specifically, that their content is available via templateNode.content
		// rather than templateNode.children[] etc.
		has.add("dom-template", !!document.createElement("template").content);
	}

	return has;
});;
define('requirejs-dplugins/has',["module"], function (module) {
	var cache = (module.config && module.config()) || {};
	var tokensRE = /[\?:]|[^:\?]+/g;

	function resolve(resource, has, isBuild) {
		var tokens = resource.match(tokensRE);
		var i = 0;
		var get = function (skip) {
			var term = tokens[i++];
			if (term === ":") {
				// empty string module name; therefore, no dependency
				return "";
			} else {
				// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
				if (tokens[i++] === "?") {
					var hasResult = has(term);
					if (hasResult === undefined && isBuild) {
						return undefined;
					} else if (!skip && hasResult) {
						// matched the feature, get the first value from the options
						return get();
					} else {
						// did not match, get the second value, passing over the first
						get(true);
						return get(skip);
					}
				}
				// A module or empty string.
				// This allows to tell apart "undefined flag at build time" and "no module required" cases.
				return term || "";
			}
		};
		return get();
	}

	function forEachModule(tokens, callback) {
		for (var i = 0; i < tokens.length; i++) {
			if (tokens[i] !== ":" && tokens[i] !== "?" && tokens[i + 1] !== "?") {
				callback(tokens[i], i);
			}
		}
	}

	var has = function (name) {
		var global = (function () {
			return this;
		})();

		return typeof cache[name] === "function" ? (cache[name] = cache[name](global)) : cache[name]; // Boolean
	};

	has.cache = cache;

	has.add = function (name, test, now, force) {
		if (!has("builder")) {
			(typeof cache[name] === "undefined" || force) && (cache[name] = test);
			return now && has(name);
		}
	};

	has.normalize = function (resource, normalize) {
		var tokens = resource.match(tokensRE);

		forEachModule(tokens, function (module, index) {
			tokens[index] = normalize(module);
		});

		return tokens.join("");
	};

	has.load = function (resource, req, onLoad, config) {
		config = config || {};

		if (!resource) {
			onLoad();
			return;
		}

		var mid = resolve(resource, has, config.isBuild);

		if (mid) {
			req([mid], onLoad);
		} else {
			onLoad();
		}
	};

	has.addModules = function (pluginName, resource, addModules) {
		var modulesToInclude = [];

		var mid = resolve(resource, has, true);
		if (mid) {
			modulesToInclude.push(mid);
		} else if (typeof mid === "undefined") {
			// has expression cannot be resolved at build time so include all the modules just in case.
			var tokens = resource.match(tokensRE);
			forEachModule(tokens, function (module) {
				modulesToInclude.push(module);
			});
		}

		addModules(modulesToInclude);
	};

	return has;
});
;
/** @module xdeliteful/Script */
define('xdeliteful/Script',[
    "dcl/dcl",
    "delite/register",
    'xide/mixins/EventedMixin',
    "delite/theme!xdeliteful/Script.css"
], function (dcl, register,EventedMixin) {

    var SCRIPT = dcl([EventedMixin.dcl], /** @lends module:delite/Widget# */ {
        type:"none",
        declaredClass: 'xblox/Script',
        _script:null,
        name:null,
        hasChildNodes:function(){
            return true;
        },
        getChildrenData:function(){
            return [this._script];
        },
        getContent:function(){
            return this._script;
        },
        /**
         * when restoring from createWidget in Maqetta
         * @param data
         */
        fromWidgetData:function(data){
            if(data && data.children && data.children[0]){
                this.setScript(data.children[0]);
            }
        },
        setScript:function(script){
            if(script) {
                delete this._function;
                delete this._script;
                this.innerHTML = "";
                this._function = new Function("{" + script + "; }");
                this._script = script;
            }
        },
        getFunction:function(){
            return this._function;
        },
        attachedCallback:function () {
            this.setScript(this.innerHTML);
        },
        createdCallback: function () {
            // Get label from innerHTML, and then clear it since we are to put the label in a <span>
            this.setScript(this.innerHTML);
        }
    });
    return register("d-script", [HTMLElement,SCRIPT]);
});

;
/** @module xide/mixins/EventedMixin **/
define('xide/mixins/EventedMixin',[
    "dojo/_base/array",
    "dcl/dcl",
    "xdojo/declare",
    "xdojo/has",
    'xide/types',
    'xide/factory'
], function (array, dcl, declare, has, types, factory) {

    var toString = Object.prototype.toString;
    /**
     * Adds convenient functions for events to the consumer, generalizing dojo.subscribe/publish or dojo.on.
     * This mixin can be applied to anything dijit/_Widget based or custom functional classes(needs to call destroy!)
     *
     * Check online-documentation {@link http://rawgit.com/mc007/xjs/dgrid_update/src/lib/xide/out/xide/0.1.1-dev/EventedMixin.html|here}
     *
     * @class module:xide/mixins/EventedMixin
     */
    var Impl = {

        _didRegisterSubscribers: false,

        subscribers: null,
        /**
         * Subscription filter map
         * @type {Object.<string,boolean}
         */
        subscribes: {},
        /**
         * Emit filter map
         * @type {Object.<string,boolean}
         */
        emits: {},
        /**
         * Array of dojo subscribe/on handles, destroyed on this.destroy();
         * @private
         * @type {Object[]}
         */
        __events: null,
        /**
         * Add emit filter
         * @param type
         * @param data
         */
        addPublishFilter: function (type, data) {
            if (type) {
                if (data != null) {
                    this.emits[type] = data;
                } else if (type in this.emits) {
                    delete this.emits[type];
                }
            }
        },
        /**
         * Simple filter function to block subscriptions.
         * @param key
         * @returns {boolean}
         */
        filterSubscribe: function (key) {

            if (this.subscribes) {
                return this.subscribes[key] !== false;
            }
            return true;
        },
        /**
         * Simple filter function to block publishing.
         * @param key
         * @returns {boolean}
         */
        filterPublish: function (key) {
            if (this.emits) {
                return this.emits[key] !== false;
            }
            return true;
        },
        /**
         * Subscribe to an event or multiple events. Attention, this is NOT checking for duplicates!
         *
         * @example
         *
         * // widget case with event callback delegation to 'this', code is written inside a custom widget or whatever
         * // class subclassing from this mixin:
         * // pre-requisites for dijit/dojox widgets: lang.extend(dijit.Button,EventedMixin.prototype);
         *
         * //simple example #1
         * var button = new dijit.Button({});
         * button.subscribe('click',this.onButtonClick,this);//calls this.onButtonClick with scope this
         *
         * //simple example #2
         * var button = new dijit.Button({});
         * button.subscribe('click',null,this);//calls this.click with scope this
         *
         * //multi-event example #1
         * var button = new dijit.Button({});
         * button.subscribe(['click','dblclick'],null,this);//calls this.click and this.dblclick with scope this
         *
         * // custom events (using dojo-publish/subscribe or dojo.topic)
         * // assuming you want listen to the events of dijit/layout/TabContainer or any other StackContainer. Notice,
         * // that stack-containers will publish events like this: topic.publish(this.id + "-removeChild", page);
         *
         * var tabContainerId = 'tabContainer';
         *
         * this.subscribe(tabContainerId + 'addChild',this.childAdded);//notice that the scope is set here automatically!
         *
         * //multi-event version, this will call this['tabContainerId-addChild'] and this['tabContainerId-removeChild']
         *
         * this.subscribe([tabContainerId + 'addChild',tabContainerId + 'removeChild']);
         *
         *
         *
         *
         *
         *
         * @param keys {String|String[]} : The event key(s), given as single string or an array of strings, holding all
         * event keys for publishing multiple events in one row.
         *
         * @param cb {Function} : callback, by the default the callback's scope will 'this'
         *
         * @param to {Object} : override 'this' scope to something else
         */
        subscribe: function (keys, cb, to) {
            if (!this.__events) {
                this.__events = {};
            }
            var self = this,
                events = factory.subscribe(keys, cb, to || self, self.filterSubscribe.bind(self)),
                container = self.__events;

            //replay on local tracking map
            for (var i = 0, l = events.length; i < l; i++) {
                var _type = events[i].type;
                if (!container[_type]) {
                    container[_type] = [];
                }
                container[_type].push(events[i]);
            }
            return events;

        },
        /**
         * Publish an event (uses dojo.publish)
         *
         * @param keys {String|String[]} : The event key, given as string or array for publishing multiple events in one row
         *
         * @param data {Object|null} : The actual event data.
         *
         * @param from {Object|null} : Send event 'as' this source. By default, its using 'this' as sender.
         *
         * @param delay {Number|null} : Send event with a delay, otherwise call now
         *
         */
        publish: function (keys, data, from, delay) {
            var self = this;
            if (delay > 0) {
                setTimeout(function () {
                    factory.publish(keys, data, from || self, self.filterPublish.bind(self));
                }.bind(self), delay);
            } else {
                factory.publish(keys, data, from || self, self.filterPublish.bind(self));
            }
        },
        /**
         * @TODO: deal with unsubscribe in _EventedMixin
         * @param key
         * @private
         */
        _destroyHandle: function (key) {
        },
        /**
         * Turns the lights off, kills all event handles.
         * @private
         * @returns void
         */
        _destroyHandles: function () {
            if (this.__events) {
                for (var type in this.__events) {
                    array.forEach(this.__events[type], function (item) {
                        if (item && item.remove) {
                            item.remove();
                        }
                    });
                }
                delete this.__events;
            }
        },
        /**
         * When using subscribe, all event subscription handles are stored in this.__events.
         * This function will remove all the event handles, using this._destroyHandles()
         */
        destroy: function () {
            this._emit('destroy');
            this.inherited && this.inherited(arguments);
            this._destroyHandles();
        },
        /**
         * Adds a one time listener for the event. This listener is invoked only the
         * next time the event is fired, after which it is removed.
         *
         * @name emitter.once(event, listener)
         * @param {String} event- The event name/id to listen for
         * @param {Function} listener - The function to bind to the event
         * @api public
         *
         * ```javascript
         * db.once('unauthorized', function (req) {
         *     // this event listener will fire once, then be unbound
         * });
         * ```
         */
        once: function (type, listener) {
            var self = this;

            function wrapped() {
                self.unsubscribe(type, listener);
                return listener.apply(self, arguments);
            }

            wrapped.listener = listener;
            self._on(type, wrapped);
            return this;
        },
        /*
         __emit:function(target,type,event){
         event = event || {};
         if (typeof target.emit === 'function' && !target.nodeType) {
         return target.emit(type, event);
         }
         if (target.dispatchEvent && target.ownerDocument && target.ownerDocument.createEvent) {
         var nativeEvent = target.ownerDocument.createEvent('HTMLEvents');
         nativeEvent.initEvent(type, Boolean(event.bubbles), Boolean(event.cancelable));
         for (var key in event) {
         if (!(key in nativeEvent)) {
         nativeEvent[key] = event[key];
         }
         }
         return target.dispatchEvent(nativeEvent);
         }
         throw new Error('Target must be an event emitter');
         },
         */
        /**
         * Execute each of the listeners in order with the supplied arguments.
         *
         * @name emitter.emit(event, [arg1], [arg2], [...])
         * @param {String} event - The event name/id to fire
         * @api public
         */
        _emit: function (type) {
            if (!this.__events)
                return;

            if (!this._didRegisterSubscribers && this.subscribers) {
                for (var i = 0; i < this.subscribers.length; i++) {
                    var subscriber = this.subscribers[i];
                    this._on(subscriber.event, subscriber.handler, subscriber.owner);
                }
                this._didRegisterSubscribers = true;
            }

            if (arguments[2] === true)
                throw new Error("Please use emit.sticky() instead of passing sticky=true for event: " + type);

            var handler = this.__events[type],
                eventArgs = arguments.length > 1 ? arguments[2] : null;

            if (!handler)
                return;

            var returnValue;

            if (typeof handler == 'function') {
                switch (arguments.length) {
                    // fast cases
                    case 1:
                        return handler.call(this);
                    case 2:
                        return handler.call(this, arguments[1]);
                    case 3:
                        return handler.call(this, arguments[1], arguments[2]);
                    // slower
                    default:
                        var args = Array.prototype.slice.call(arguments, 1);
                        returnValue = handler.apply(this, args);
                }
            }

            else if (_.isArray(handler)) {
                var args = Array.prototype.slice.call(arguments, 1);
                var listeners = handler.slice(), temp;
                var _listener = null;
                var who = null;

                for (var i = 0, l = listeners.length; i < l; i++) {

                    _listener = listeners[i];
                    who = _listener.owner || this;

                    args && args[0] && (args[0].owner = args[0] ? args[0].owner || who : null);

                    _listener.handler && (temp = _listener.handler.apply(who, args));
                    if (temp !== undefined) {
                        returnValue = temp;
                    }

                    args && args[0] && args[0].owner && (args[0].owner = null);


                }
            }

            //forward to global
            eventArgs && eventArgs['public'] === true && this.publish(type, args);

            return returnValue;
        },
        /**
         * Remove a listener from the listener array for the specified event. Caution:
         * changes array indices in the listener array behind the listener.
         *
         * @name emitter.removeListener(event, listener)
         * @param {String} event - The event name/id to remove the listener from
         * @param {Function} listener - The listener function to remove
         * @api public
         *
         * ```javascript
         * var callback = function (init) {
         *     console.log('duality app loaded');
         * };
         * devents.on('init', callback);
         * // ...
         * devents.removeListener('init', callback);
         * ```
         */
        unsubscribe: function (type, listener) {

            // does not use listeners(), so no side effect of creating __events[type]
            if (!this.__events || !this.__events[type]) return this;

            // no listener given, unsubscribe all per type
            if (('function' !== typeof listener || !listener)) {
                array.forEach(this.__events[type], dojo.unsubscribe);
                delete this.__events[type];
                this.__events[type] = [];
                return this;
            }
            var list = this.__events[type];
            if (_.isArray(list)) {
                var _remove = [];
                _.each(list, function (handle, a, b) {
                    var which = handle.handler == listener ? handle.handler : handle.handler.listener == listener ? handle.handler.listener : null;
                    if (which) {
                        _remove.push(handle);
                    }
                });
                _.each(_remove, function (handler) {
                    handler.remove();
                });
                if (list.length === 0) {
                    delete this.__events[type];
                }
            } else if ((this.__events[type].listener || this.__events[type]) === listener) {
                delete this.__events[type];
            }
            return this;
        },
        /**
         * Returns an array of listeners for the specified event. This array can be
         * manipulated, e.g. to remove listeners.
         *
         * @name emitter.listeners(event)
         * @param {String} events - The event name/id to return listeners for
         * @api public
         *
         * ```javascript
         * session.on('change', function (stream) {
         *     console.log('session changed');
         * });
         * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]
         * ```
         */
        listeners: function (type) {
            if (!this.__events) this.__events = {};
            if (!this.__events[type]) this.__events[type] = [];
            if (!isArray(this.__events[type])) {
                this.__events[type] = [this.__events[type]];
            }
            return this.__events[type];
        },
        /**
         *
         * @param type
         * @param handle
         * @returns {*}
         */
        addHandle: function (type, handle) {
            if (!this.__events) {
                this.__events = {}
            }
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            handle.type = type;
            this.__events[type].push(handle);
            return handle;
        },
        /**
         * jQuery sub
         * @param element
         * @param type
         * @param selector
         * @param handler
         * @returns {{handler: *, owner: (exports|module.exports|module:xide/mixins/EventedMixin), type: *, element: (*|jQuery|HTMLElement), selector: *, remove: _handle.remove}}
         */
        __on: function (element, type, selector, handler) {

            var _handler = handler;

            if (typeof selector == 'function' && !handler) {
                //no selector given
                handler = selector;
                selector = null;
            }

            element = element.jquery ? element : $(element);
            element.on(type, selector, handler);

            if (!this.__events) this.__events = {};
            if (!this.__events[type]) {
                this.__events[type] = [];
            }
            var eventList = this.__events[type];
            var _handle = {
                handler: _handler,
                owner: this,
                type: type,
                element: element,
                selector: selector,
                remove: function () {
                    eventList.remove(this);
                    this.element.off(this.type, this.selector, this.handler);
                }
            };
            eventList.push(_handle);
            return _handle;

        },
        /**
         * Dojo based sub
         * @param type
         * @param listener
         * @param owner
         * @returns {*}
         * @private
         */
        _on: function (type, listener, owner) {
            try {
                if (!this.__events) this.__events = {};

                if (!this.__events[type]) {
                    this.__events[type] = [];
                }

                var eventList = this.__events[type];


                if (!eventList) {
                    // Optimize the case of one listener. Don't need the extra array object.
                    this.__events[type] = listener;
                }
                else if (_.isArray(eventList)) {

                    if (eventList.indexOf(listener) != -1)
                        return console.warn("adding same listener twice", type);

                    // If we've already got an array, just append.
                    var _handle = {
                        handler: listener,
                        owner: owner || this,
                        type: type,
                        remove: function () {
                            eventList.remove(this);
                            owner && owner.__events && owner.__events[type] && owner.__events[type].remove(this);
                            this.owner = null;
                            this.handler = null;
                            delete this.type;
                        }
                    };
                    eventList.push(_handle);
                    return _handle;
                }
            } catch (e) {
                logError(e);
            }
            return this;
        }
    };

    //package via declare
    var Module = declare(null, Impl);
    //static access to Impl.
    Module.Impl = Impl;
    Module.dcl = dcl(null, Impl);
    dcl.chainAfter(Module.dcl, 'destroy');
    return Module;
});

;
define('xide/factory',[
    'dcl/dcl'
],function(dcl){
    return new dcl(null,{
        declaredClass:'xide/factory'
    });
});;
define('delite/handlebars!xdeliteful/MediaPlayer/template.html',["delite/handlebars","deliteful/ToggleButton","xdeliteful/Button","xblox/RunScript","deliteful/Slider"], function(handlebars){
	return handlebars.compile("<template attach-point=\"focusNode\" style=\"position: relative;display: inherit;width: 300px;height: 300px;min-width:300px;min-height:300px\">\n\n<button class=\"mediaPlayerLabel\" is=\"d-button\" title=\"Default Label\" label=\"Position\" style=\"position: absolute; left: 18px; top: 61px;\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"label\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=2219d68b-862f-92ab-de5d-b7a847930a7a\" script=\"Current Position\" style=\"position: relative;\"></d-xscript>\n</button>\n<button class=\"mediaPlayerLabel\" attach-point=\"btnCurrentTrack\" is=\"d-button\" title=\"Default Label\" label=\"Current Track\" style=\"position: absolute; left: 19px; top: 158px;\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"label\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=e76f0b30-4443-47ae-0cef-2c4c9e4acffd\" style=\"position: relative;\"></d-xscript>\n</button>\n<d-slider class=\"mediaPlayerSlider\" attach-point=\"slider\" max=\"1\" step=\"0.01\" style=\"position: absolute; width: 202px; height: 3px; left: 14px; top: 106px;\" value=\"0.2\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"value\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=2219d68b-862f-92ab-de5d-b7a847930a7a\" style=\"position: relative;\"></d-xscript>\n</d-slider>\n<button class=\"mediaPlayerButton\" attach-point=\"btnStop\" is=\"d-button\" title=\"Default Label\" label=\" \" iconclass=\"fa fa-stop \" style=\"position: absolute; left: 63px; top: 17px;\">\n    <d-xscript style=\"position:relative\" targetevent=\"click\" block=\"command://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=418f48fc-9d4d-9c8c-fc19-4674848fa55c\" script=\"Stop\"></d-xscript>\n</button>\n<button class=\"mediaPlayerButton\" attach-point=\"btnPause\" is=\"d-button\" title=\"Default Label\" label=\"\" iconclass=\"fa fa-pause\" style=\"position: absolute; left: 109.53125px; width: 38px; height: 34px; top: 17px;\">\n    <d-xscript style=\"position:relative\" targetevent=\"click\" block=\"command://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=a3c0e8d7-e517-18a2-1405-0a46e6182aef\" script=\"Pause\"></d-xscript>\n</button>\n<button class=\"mediaPlayerButton\" attach-point=\"btnPlay\" is=\"d-button\" title=\"Default Label\" style=\"position: absolute; left: 155px; width: 38px; height: 34px; top: 17px;\" iconclass=\"fa fa-play\">\n    <d-xscript style=\"position:relative\" targetevent=\"click\" block=\"command://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=450d2c75-29b0-29b7-13c5-be175b2a5749\" script=\"Play Args\"></d-xscript>\n</button>\n<button class=\"mediaPlayerButton\" attach-point=\"btnNext\" is=\"d-button\" title=\"Default Label\" label=\"\" iconclass=\"fa fa-caret-right\" style=\"position: absolute; left: 203px; width: 38px; height: 34px; top: 17px;\">\n    <d-xscript style=\"position:relative\" targetevent=\"click\" block=\"command://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=49936bba-e005-053f-b88d-48ec88688b8b\" script=\"Next\"></d-xscript>\n</button>\n<button class=\"mediaPlayerButton\" attach-point=\"btnPrev\" is=\"d-button\" title=\"Default Label\" label=\"\" iconclass=\"fa fa-caret-left\" style=\"position: absolute; left: 15.015625px; width: 38px; height: 34px; top: 17px;\">\n    <d-xscript style=\"position:relative\" targetevent=\"click\" block=\"command://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=ab927f79-8968-ff46-44a8-e5fbe5bbfdbe\" script=\"Prev\"></d-xscript>\n</button>\n<button class=\"mediaPlayerButton\" attach-point=\"btnOpenFolder\" is=\"d-button\" title=\"Default Label\" label=\"\" iconclass=\"fa fa-folder-open\" style=\"position: absolute; left: 254px; top: 17px;\"></button>\n\n<button class=\"mediaPlayerLabel\" is=\"d-button\" label=\"Default Label\" title=\"Default Label\" style=\"position: absolute; left: 19px; top: 236px;\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"label\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=9673fd4c-15f5-cebb-82a0-8500ec7b52e6\" style=\"position: relative;\"></d-xscript>\n</button>\n\n<d-slider class=\"mediaPlayerSlider\" attach-point=\"volume\" value=\"100\" sliderange=\"true\" vertical=\"true\" style=\"position: absolute; left: 354px; top: 5px; width: 4px; height: 104px;\" id=\"mediaPlayerVolume\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"value\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=3879e1cd-7a17-71d2-59d4-6e825658194b\" script=\"Current Volume\" style=\"position: relative;\"></d-xscript>\n</d-slider>\n\n<button attach-point=\"mute\" is=\"d-toggle-button\" checkediconclass=\"fa fa-volume-down\" iconclass=\"fa fa-volume-up\" style=\"position: absolute; left: 203px; top: 61px;display: none\" checked=\"false\">\n    <d-xscript stop=\"false\" bidirectional=\"false\" mode=\"1\" targetproperty=\"checked\" sourceevent=\"onDriverVariableChanged\" sourceeventvaluepath=\"item.value\" sourceeventnamepath=\"item.name\" block=\"variable://deviceScope=user_devices&amp;device=VLC&amp;driver=9db866a4-bb3e-137b-ae23-793b729c44f8&amp;driverScope=user_drivers&amp;block=cabd937b-28b7-3985-6a10-d456dbe74374\" script=\"Muted\" style=\"position: relative;\"></d-xscript>\n</button>\n\n</template>");
});;
/** @module deliteful/TabBar */
define('xdeliteful/MediaPlayer',[
    "dcl/dcl",
    "delite/register",
    "delite/Widget",
    "xblox/RunScript",
    'xide/mixins/EventedMixin',
    "delite/handlebars!./MediaPlayer/template.html",
    "requirejs-dplugins/jquery!attributes/classes",
    "requirejs-dplugins/has",
    "delite/handlebars",
    "delite/Template",
    "deliteful/ToggleButton",
    "xdeliteful/Button",
    "xblox/RunScript",
    "deliteful/Slider"
], function (dcl, register,Widget,RunScript,EventedMixin,template, $,has,handlebars,Template) {

    var MediaPlayer = dcl([Widget,EventedMixin.dcl], /** @lends module:delite/Widget# */ {
        baseClass: "d-media-player",
        template:template,
        context:null,
        vlc:null,
        fileServer:null,
        declaredClass:'delite/MediaPlayer',
        allowAudio:true,
        allowVideo:false,
        getDriverInstance:function(name){
            var deviceManager = this.context.getDeviceManager();
            //device instance
            return deviceManager.getInstanceByName(name);
        },
        onPickedFolder:function(selection){

            var vlc = this.vlc;
            if(!vlc){
                console.error('can`t get VLC driver, abort');
                return;
            }

            var cmd = vlc.getCommand('Play Args');
            var item = selection[0];
            if(selection.length>1){
                var _items = _.pluck(selection,'realPath');
                var items = [];
                _.each(_items,function(path){
                    items.push(path.replace(/\\/g, '/'));
                });
                cmd.stop();
                vlc.setVariable("Current Folder",items.join(';'));
                vlc.callCommand('Play Args');
                return;

            }

            item = item || {isDir:true};

            var path = item.realPath;
            path = path  || "/home/mc007/Music/Sasha/";
            path = path.replace(/\\/g, '/');
            if(item.isDir) {
                //path += '/*.mp3';
                path+='/+(*.mp3|*.wav|*.m4a|*.wma)';
            }
            vlc.setVariable("Current Folder",path);
            vlc.callCommand('Play Args');
        },
        initFilePicker:function(){

            var thiz  = this;
            var btn = this.btnOpenFolder;
            var _r = require;
            _r(['xfile/build/xfiler'], function () {
                _r([
                    "xdeliteful/Widgets/Popup",
                    'xfile/views/FileGridLight',
                    'xide/utils',
                    'xfile/data/DriverStore',
                    'xide/types',
                    'dojo/Deferred',
                    'xide/_Popup',
                    'xfile/views/FilePicker',
                    "dojo/_base/declare",
                    "delite/popup",
                    "deliteful/Combobox",
                    "deliteful/list/List",
                    "dstore/Memory",
                    "requirejs-dplugins/css!../../../build/xfile/xfile.min.css"
                ], function (Popup, FileGridLight, utils, DriverStore, types, Deferred, _Popup, FilePicker, declare,popup,Combobox, List, Memory) {

                    function createStore(ext) {
                        var config = {};
                        var options = {
                            fields: types.FIELDS.SHOW_ISDIR | types.FIELDS.SHOW_OWNER | types.FIELDS.SHOW_SIZE |
                            types.FIELDS.SHOW_FOLDER_SIZE |
                            types.FIELDS.SHOW_MIME |
                            types.FIELDS.SHOW_PERMISSIONS |
                            types.FIELDS.SHOW_TIME |
                            types.FIELDS.SHOW_MEDIA_INFO
                        };

                        var match = thiz.allowAudio ? "(*.m4a)|(*.wav)|(*.mp3)|(*.wma)" : "";
                        if(thiz.allowVideo){
                            thiz.allowAudio && (match+="|");
                            match+="(*.avi)|(*.mp4)|(*.mkv)";
                        }
                        match+="|!(*.*)";
                        return new DriverStore({
                            data: [],
                            config: config,
                            mount: 'none',
                            options: options,
                            driver: thiz.fileServer,
                            glob: ext,
                            _micromatch: "(*.m4a)|(*.wav)|(*.mp3)|(*.wma)|!(*.*)", // Only folders
                            micromatch: match // Only folders
                        });
                    }
                    _Popup.setStartIndex(2000);
                    var owner = {};
                    var permissions = utils.clone(types.DEFAULT_FILE_GRID_PERMISSIONS);
                    function createPickerPopup(button,picker,Popup) {
                        var value = [];
                        var _popup;

                        /**
                         * callback when ok
                         */
                        function ok() {
                            var selection = picker._selection || [{isDir:true}];
                            console.log('ok ',selection[0]);
                            utils.destroy(picker);
                            utils.destroy(_popup);
                            thiz.onPickedFolder(selection);                        }

                        

                        var dataSource = new Memory({idProperty: "label", data: []});
                        var list = new List({source: dataSource, righttextAttr: "value"});
                        var combo = new Combobox({
                            list: list,
                            id: "combo-single",
                            selectionMode: 'single'
                        });

                        var gridNode = picker.domNode;

                        _popup =  new Popup({
                            /**
                             * Called when clicking the OK button of the popup.
                             * @protected
                             */
                            okHandler: function () {
                                this.combobox._validateMultiple(this.combobox.inputNode);
                                this.combobox.closeDropDown();
                                popup.close(button.popup);
                                ok();
                            },

                            /**
                             * Called when clicking the Cancel button of the popup.
                             * @protected
                             */
                            cancelHandler: function () {
                                this.combobox.list.selectedItems = this.combobox._selectedItems;
                                this.combobox.closeDropDown();
                                popup.close(button.popup);
                                utils.destroy(picker);
                                utils.destroy(_popup);
                            },
                            combobox: combo
                        });


                        //extend button
                        utils.mixin(button, {
                            popup:_popup,
                            _setLabelAttr: function (label) {
                                this.textContent = label;
                                this._set("label", label);
                            },
                            closePopup: function () {
                                if (this.open) {
                                    popup.close(this.popup);
                                    this.open = false;
                                }
                            },
                            _deactivatedHandler: function () {

                            },
                            _openPopup: function () {
                                $(combo.list).css('height','600px');
                                $(combo.list).css('width','800px');
                                $(combo.list).empty();
                                $(combo.list).append(gridNode);
                                this._openRet = popup.open({
                                    popup: this.popup,
                                    parent: this,
                                    around: this,
                                    orient: ['center'],
                                    maxHeight: -1
                                });
                                this.open = true;
                                picker._parent = combo.list;
                                picker.startup();
                                $(gridNode).css('height','100%');
                                $(gridNode).css('min-width','100%');

                                picker.resize();
                                function refreshGrid(fileGrid,collection){

                                    picker.resize();
                                    picker.resize();
                                }
                                
                                setTimeout(function() {
                                    picker.rightGrid.collection._loadPath('/',true).then(function(){
                                        picker.rightGrid.refresh();
                                        setTimeout(function(){
                                            picker.leftGrid.select(0,null,true,{
                                                append:false,
                                                focus:true,
                                                delay:10
                                            });
                                        },200);
                                    });
                                },100);
                            }
                        });
                        button.on("delite-deactivated", function () {
                            button._deactivatedHandler();
                        });
                        button._openPopup();
                    }

                    $(btn).on('click',function(){
                        var picker = utils.addWidget(FilePicker, utils.mixin({
                            ctx: thiz.context,
                            owner: owner,
                            selection: '.',
                            resizeToParent: true,
                            storeOptionsMixin: {
                                "includeList": "*,.*",
                                "excludeList": ""
                            },
                            Module: FileGridLight,
                            permissions: permissions,
                            leftStore: createStore("/*"),
                            rightStore: createStore("/*")
                        }, {}), this, $('BODY')[0], false);

                        $(picker.domNode).addClass('MediaPlayerFilePicker');

                        $(picker.domNode).css('height','600px');

                        createPickerPopup(btn, picker, Popup);
                    });

                });
            });
        },
        initVLC:function(){
        },
        wireWidgets:function(){
            var self = this;
            var vlc = self.vlc;
            if(!vlc) {
                return;
            }
            //wire slider to position
            $(this.slider).on('change',function(e){
                if(self._lastPos ===e.target.value){
                    return;
                }
                self._lastPos = e.target.value;
                var settings = {
                    override:{
                        args:[e.target.value]
                    }
                };
                vlc.callCommand('Position',settings);
            });

            $(this.mute).on('click',function(e){

                var settings = {
                    override:{
                        args:[self.mute.checked ? 1 : 0]
                    }
                };
                console.log('changed mute : ',settings);
                vlc.callCommand('Mute',settings);

            });

            $(this.volume).on('change',function(e){
                if(self._lastVol ===e.target.value){
                    return;
                }
                self._lastVol = e.target.value;

                var settings = {
                    override:{
                        args:[e.target.value]
                    }
                };
                console.log('changed volume : ',settings);
                vlc.callCommand('Volume',settings);
            });
        },

        doTemplate:function(){
            var template = $(this).attr('templateId');
            if(template){
                template = $(template);
                if(template[0] && !this._didTemplate){
                    var text = template[0].outerHTML;
                    text = text.replace('display:none','');
                    text = text.replace('pointer-events:none','');
                    var templateDom = handlebars.toDom(text);
                    var requires = templateDom.getAttribute("requires") ||templateDom.getAttribute("data-requires") || "";

                    templateDom.removeAttribute("requires");
                    templateDom.removeAttribute("data-requires");
                    templateDom.removeAttribute("style");
                    var tree = handlebars.parse(templateDom);
                    this.template = new Template(tree).func;
                    this._didTemplate=true;
                }
            }
        },
        attachedCallback:function () {
            var template = $(this).attr('templateId');
            if(template) {
                template = $(template);
                if (template[0]) {
                    this.doTemplate();
                }
            }
        },
        DevicesConnected:function(){
            var vlc = this.getDriverInstance("VLC");
            if(vlc && !this.vlc){
                this.vlc = vlc;
                this.initVLC();
                this.wireWidgets();
            }
            var fileServer = this.getDriverInstance("File-Server");
            if(fileServer && !this.fileServer){
                this.fileServer = fileServer;
                this.initFilePicker();
            }
        },
        onContextReady:function(context){
            this.context = context;
            this.subscribe('DevicesConnected');
        },
        init:function(){
            this.subscribe('onContextReady');
        },
        createdCallback: function () {
            // Get label from innerHTML, and then clear it since we are to put the label in a <span>
            this.doTemplate();
            this.init();
        }
    });

    return register("d-media-player", [HTMLElement,MediaPlayer]);
});

;
/** @module deliteful/TabBar */
define('xdeliteful/TabBar',[
    "dcl/dcl",
    "delite/register",
    "./Bar",
    "deliteful/ToggleButton",
    "deliteful/Button",
    "requirejs-dplugins/jquery!attributes/classes"
], function (dcl, register, Bar, ToggleButton, Button, $) {
    /**
     * TabBar is a widget that controls the visibility of views in a ViewStack through a set of toggle buttons.
     * The buttons are automatically created from the views available in the ViewStack. One can replace the created
     * buttons by its own custom element Widget using the button property.
     * @lends module:deliteful/TabBar#
     * @example:
     * <d-tab-bar viewStack="vs">
     * </d-tab-bar>
     * <d-view-stack id="vs">
     *     <div id="childA">...</div>
     *     <div id="childB">...</div>
     *     <div id="childC">...</div>
     * </d-view-stack>
     * @class module:deliteful/TabBar
     */
    return register("d-tab-bar", [HTMLElement, Bar], {
        /**
         * The name of the CSS class of this widget. Note that this element also use the d-bar class to leverage
         *`deliteful/Bar` styles.
         * @member {string}
         * @default "d-tab-bar"
         */
        baseClass: "d-tab-bar",

        /**
         * The `deliteful/ViewStack` this TabBar is connected to.
         * @member {deliteful/ViewStack}
         * @default null
         */
        viewStack: null,

        /**
         * The toggle element class this TabBar is using to fill out the bar.
         * @member {deliteful/Toggle}
         * @default deliteful/ToggleButton
         */
        toggle: ToggleButton,

        preRender: function () {
            // we want to inherit from Bar
            $(this).addClass(Bar._ctor.prototype.baseClass);
        },

        refreshRendering: function (oldValues) {
            if(!this.viewStack){
                this.viewStack = $('#' + $(this).attr('viewStack'))[0];
            }else if(_.isString(this.viewStack)){
                var viewStack = $('#' + $(this).attr('viewStack'))[0];
                if(viewStack){
                    this.viewStack = viewStack;
                }
            }
            if (this.viewStack && this.viewStack.children && "viewStack" in oldValues) {
                // take all existing views and fill the bar with corresponding buttons
                for (var i = 0; i < this.viewStack.children.length; i++) {
                    var element = this.viewStack.children[i];
                    this.renderTabButton(element);
                }
                /*
                this.viewStack.children.forEach(function (element) {

                }.bind(this));
                */
                // if new views are added later we must add more buttons

                this.viewStack.on("delite-add-child", function (event) {
                    console.error('add child');
                    // FIXME: issue with the index this should not always be added to the end of the list
                    this.renderTabButton(event.child);
                }.bind(this));

                // we must also listen to possible changes on selected view to replicate it

                this.viewStack.on("delite-after-show", function () {
                    this.getChildren().forEach(function (item) {
                        item._update();
                    });
                }.bind(this));

            }
        },
        /**
         * Creates the tab bar button corresponding to the given view. The default implementation is using the
         * `toggle` property to create the button and pass the view `title` as `label` and when provided the
         * view `iconClass` attribute for the button `iconClass`.
         * @param {HTMLElement} view - The view the button must be created for.
         * @returns {deliteful/Toggle} An element representing the tab bar button for the given view.
         */
        createTabButton: function (view) {
            return new this.toggle({label: view.label, iconClass: view.getAttribute("iconClass")});
        },

        /**
         * Renders the tab bar button corresponding to the given view.
         * @param {HTMLElement} view - The view the button must be rendered for.
         */
        renderTabButton: function (view) {
            var button = this.createTabButton(view);
            var self = this;
            button._update = function () {
                this.checked = self.viewStack._visibleChild === view;
            };
            button._update();
            button.on("click", function () {
                console.log('show');
                self.viewStack.show(view);
            });
            this.appendChild(button);
        }
    });
});

;
/** @module deliteful/Bar */
define('xdeliteful/Bar',[
    "dcl/dcl",
    "delite/register",
    "delite/Widget",
    "requirejs-dplugins/jquery!attributes/classes",
    "delite/theme!xdeliteful/Bar/themes/Bar.css"
], function (dcl, register, Widget, $) {
    /**
     * Bar is a container that lays out its children elements either horizontally or vertically. It can for example
     * be used as a menu bar.
     * @lends module:deliteful/Bar#
     * @example:
     * <d-bar>
     *     <d-button></d-button>
     *     <d-button></d-button>
     * </d-bar>
     * @class module:deliteful/Bar
     */
    return register("d-bar", [HTMLElement, Widget], {
        /**
         * The name of the CSS class of this widget.
         * @member {string}
         * @default "d-bar"
         */
        baseClass: "d-bar",

        /**
         * Whether the layout is vertical or not.
         * @member {boolean}
         * @default false
         */
        vertical: false,

        render: dcl.advise({
            before: function () {
                // Save original markup to put into this.containerNode.
                var srcDom = this._srcDom = this.ownerDocument.createDocumentFragment();
                while (this.firstChild) {
                    srcDom.appendChild(this.firstChild);
                }
            },

            after: function () {
                this._childArray = [];
                // Safari & IE are not supporting children on DocumentFragment
                var holder, children = this._srcDom.children || this._srcDom.querySelectorAll("*");
                // if Safari/IE the children array is not live, find a way to iterate common to both
                for (var i = children.length - 1; i >= 0; i--) {
                    holder = this._setupHolder(children[i]);
                    this.appendChild(holder);
                }
                $(this).addClass(this.vertical ? "d-bar-v" : "d-bar-h");
            }
        }),

        _setupHolder: function (child) {
            this._childArray = this._childArray || [];
            var holder = this.ownerDocument.createElement("div");
            this._childArray.push(child);
            holder.appendChild(child);
            return holder;
        },

        appendChild: dcl.superCall(function (sup) {
            return function (child) {
                if (this.created) {
                    var holder = this._setupHolder(child);
                    sup.call(this, holder);
                    return child;
                } else {
                    return sup.call(this, child);
                }
            };
        }),

        insertBefore: dcl.superCall(function (sup) {
            return function (newChild, refChild) {
                if (this.created) {
                    var index = this._childArray.indexOf(refChild);
                    var holderRef = this.children[index];
                    var holder = this._setupHolder(newChild);
                    sup.call(this, holder, holderRef);
                    this.onAddChild(newChild);
                    return newChild;
                } else {
                    return sup.call(this, newChild, refChild);
                }
            };
        }),

        refreshRendering: function (oldValues) {
            if ("vertical" in oldValues) {
                $(this).toggleClass("d-bar-v", this.vertical);
                $(this).toggleClass("d-bar-h", !this.vertical);
            }
        },

        /**
         * Callback whenever a child element is added to this widget via `appendChild()`, `insertBefore()`,
         * or a method like `addChild()` that internally calls `appendChild()` and/or `insertBefore()`.
         * @param {Element} node
         */
        onAddChild: function (node) {
            // If I've been started but the child widget hasn't been started,
            // start it now.  Make sure to do this after widget has been
            // inserted into the DOM tree, so it can see that it's being controlled by me,
            // so it doesn't try to size itself.
            if (this.attached && node.attachedCallback) {
                node.attachedCallback();
            }
        },

        /**
         * Inserts the specified Element at the specified index.
         * For example, `.addChild(node, 3)` sets this widget's fourth child to node.
         * @param {Element} node - Element to add as a child.
         * @param {number} [insertIndex] - Position the child as at the specified position relative to other children.
         */
        addChild: function (node, insertIndex) {
            // Note: insertBefore(node, null) equivalent to appendChild().  Null arg is needed (only) on IE.
            var nextSibling = this._childArray[insertIndex];
            this.insertBefore(node, nextSibling || null);
        },

        /**
         * Detaches the specified node instance from this widget but does
         * not destroy it.  You can also pass in an integer indicating
         * the index within the container to remove (ie, removeChild(5) removes the sixth node).
         * @param {Element|number} node
         */
        removeChild: function (node) {
            if (typeof node === "number") {
                node = this.getChildren()[node];
            }

            if(this.contains(node)) {
                //this.removeChild(node);
                HTMLElement.prototype.removeChild.call(this, node);
                if (node && node.parentNode && node.parentNode.parentNode) {

                    //HTMLElement.prototype.removeChild.call(node.parentNode.parentNode, node.parentNode);
                    //HTMLElement.prototype.removeChild.call(node.parentNode, node); // detach but don't destroy
                }
            }else{
                console.warn('no me');
            }
        },

        /**
         * Returns all direct children of this widget, i.e. all widgets or DOM nodes underneath
         * `this.containerNode`.  Note that it does not return all
         * descendants, but rather just direct children.
         *
         * The result intentionally excludes element outside off `this.containerNode`.  So, it is different than
         * accessing the `children` or `childNode` properties.
         *
         * @returns {Element[]}
         */
        getChildren: function () {
            return this._childArray;
        },

        /**
         * Returns true if widget has child nodes, i.e. if `this.containerNode` contains widgets.
         * @returns {boolean}
         */
        hasChildren: function () {
            return this.getChildren().length > 0;
        },

        /**
         * Returns the index of the child in this container or -1 if not found.
         * @param {Element} child
         * @returns {number}
         */
        getIndexOfChild: function (child) {
            return this.getChildren().indexOf(child);
        }
    });
});;
define('dojo/selector/_loader',["../has", "require"],
		function(has, require){

"use strict";
var testDiv = document.createElement("div");
has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
has.add("dom-qsa3", function(){
			// test to see if we have a reasonable native selector engine available
			try{
				testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
				// Safari can't handle uppercase or unicode characters when
				// in quirks mode, IE8 can't handle pseudos like :empty
				return testDiv.querySelectorAll(".TEST:empty").length == 1;
			}catch(e){}
		});
var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
});
;
define('delite/handlebars!deliteful/list/List/List.html',["delite/handlebars","deliteful/ProgressIndicator"], function(handlebars){
	return handlebars.compile("<template>\n\t<div class=\"d-list-container\" attach-point=\"containerNode\" aria-busy=\"{{_busy}}\" role=\"{{type}}\" d-shown=\"{{this._displayedPanel === 'list'}}\" on-click=\"{{handleSelection}}\" tabindex=\"{{tabIndex}}\"></div>\n\t<div class=\"d-list-no-items\" d-shown=\"{{this._displayedPanel === 'no-items'}}\" attach-point=\"noItemsNode\">\n\t\t<div class=\"d-list-no-item-info\">{{noItemsInfo}}</div>\n\t</div>\n\t<div class=\"d-list-loading-panel\" attach-point=\"loadingIndicatorNode\" d-shown=\"{{this._displayedPanel === 'loading-panel'}}\" aria-hidden=\"{{!this._busy}}\" aria-labelledby=\"loadingIndicatorLabel-{{widgetId}}\">\n\t\t<div class=\"d-list-loading-panel-info\">\n\t\t\t<d-progress-indicator active=\"{{_busy}}\"></d-progress-indicator>\n\t\t\t<div class=\"d-list-loading-panel-info-label\" id=\"loadingIndicatorLabel-{{widgetId}}\" attach-point=\"loadingIndicatorLabel\">{{loadingMessage}}</div>\n\t\t</div>\n\t</div>\n</template>");
});;
/** @module deliteful/list/List */
define('deliteful/list/List',[
	"dcl/dcl",
	"delite/Widget",
	"delite/register",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/CustomElement",
	"delite/Selection",
	"delite/KeyNav",
	"delite/StoreMap",
	"delite/Scrollable",
	"./ItemRenderer",
	"./CategoryRenderer",
	"delite/handlebars!./List/List.html",
	"requirejs-dplugins/i18n!./List/nls/List",
	"delite/theme!./List/themes/{{theme}}/List.css"
], function (dcl, Widget, register, $, CustomElement,
		Selection, KeyNav, StoreMap, Scrollable, ItemRenderer, CategoryRenderer, template, messages) {

	// Put tabIndex in mixin class to workaround https://github.com/uhop/dcl/issues/9.
	var TabbableWidget = register.dcl(Widget, {
		tabIndex: 0
	});

	/**
	 * A widget that renders a scrollable list of items.
	 *
	 * The List widget renders a scrollable list of items that are retrieved from a Store.
	 * Its custom element tag is `d-list`.
	 *
	 * See the {@link https://github.com/ibm-js/deliteful/tree/master/docs/list/List.md user documentation}
	 * for more details.
	 *
	 * @class module:deliteful/list/List
	 * @augments module:delite/Selection
	 * @augments module:delite/KeyNav
	 * @augments module:delite/StoreMap
	 * @augments module:delite/Scrollable
	 */

	return register("d-list", [HTMLElement, Selection, KeyNav, StoreMap, Scrollable, TabbableWidget],
			/** @lends module:deliteful/list/List# */ {

		/**
		 * Dojo object store that contains the items to render in the list.
		 * If no value is provided for this attribute, the List will initialize
		 * it with an internal store implementation. Note that this internal store
		 * implementation ignores any query options and returns all the items from
		 * the store, in the order they were added to the store.
		 * @member {module:dstore/Store} module:deliteful/list/List#store
		 * @default null
		 */

		/**
		 * Query to pass to the store to retrieve the items to render in the list.
		 * @member {Object} module:deliteful/list/List#query
		 * @default {}
		 */

		/**
		 * The widget class to use to render list items.
		 *	It MUST extend {@link module:deliteful/list/ItemRenderer deliteful/list/ItemRenderer}.
		 * @member {module:deliteful/list/ItemRenderer}
		 * @default module:deliteful/list/ItemRenderer
		 */
		itemRenderer: ItemRenderer,

		/**
		 * The widget class to use to render category headers when the list items are categorized.
		 * It MUST extend {@link module:deliteful/list/CategoryRenderer deliteful/list/CategoryRenderer}.
		 * @member {module:deliteful/list/CategoryRenderer}
		 * @default module:deliteful/list/CategoryRenderer
		 */
		categoryRenderer: CategoryRenderer,

		/**
		 * Default mapping between the attribute of the item retrieved from the store
		 * and the label attribute expected by the default renderer
		 * @member {string}
		 * @default "label"
		 */
		labelAttr: "label",

		/**
		 * Default mapping between the attribute of the item retrieved from the store
		 * and the icon attribute expected by the default renderer
		 * @member {string}
		 * @default "iconclass"
		 */
		iconclassAttr: "iconclass",

		/**
		 * Default mapping between the attribute of the item retrieved from the store
		 * and the righttext attribute expected by the default renderer
		 * @member {string}
		 * @default "righttext"
		 */
		righttextAttr: "righttext",

		/**
		 * Default mapping between the attribute of the item retrieved from the store
		 * and the righticon attribute expected by the default renderer
		 * @member {string}
		 * @default "righticonclass"
		 */
		righticonclassAttr: "righticonclass",

		/**
		 * Name of the list item attribute that define the category of a list item.
		 * If falsy and categoryFunc is also falsy, the list is not categorized.
		 * @member {string}
		 * @default ""
		 */
		categoryAttr: "",

		/**
		 * A function (or the name of a function) that extracts the category of a list item
		 * from the following input parameters:
		 * - `item`: the list item from the store
		 * - `store`: the store
		 * If falsy and `categoryAttr` is also falsy, the list is not categorized.
		 * see {@link module:delite/StoreMap delite/StoreMap}
		 * @member
		 * @default null
		 */
		categoryFunc: null,

		/**
		 *	The base class that defines the style of the list.
		 * Available values are:
		 * - `"d-list"` (default): render a list with no rounded corners and no left and right margins;
		 * - `"d-round-rect-list"`: render a list with rounded corners and left and right margins.
		 * @member {string}
		 * @default "d-list"
		 */
		baseClass: "d-list",

		// By default, letter search is one character only, so that it does not interfere with pressing
		// the SPACE key to (de)select an item.
		multiCharSearchDuration: 0,

		/**
		 * If `true` and the list's store is empty, the NoItemContainer element will be shown.
		 * @member {boolean}
		 * @default false
		 */
		showNoItems: false,

		/**
		 * Message to display when the d-list-no-items node is shown.
		 * @member {string}
		 * @default "Nothing to show."
		 */
		noItemsInfo: messages["no-items-info"],

		/**
		 * Flag set to a truthy value once the items initialization starts.
		 * It is set to false when the initialization ends.
		 * Furthermore if `true`, a loading panel will be shown.
		 * @member {boolean}
		 * @private
		 */
		_busy: false,

		/**
		 * Specifies the role of list. It can be one of `grid`, `menu`, `listbox` or `list`.
		 * @type {string}
		 * @default "grid"
		 */
		type: "grid",

		/**
		 * Property responsible for managing the right view of the list. It can be one of
		 * `loading-panel`, `list`, `no-items`, `none`.
		 * When it is equal to `loading-panel` (as `busy` is equal to `true`), a `d-list-loading-panel`
		 * loading panel is shown.
		 * When it is equal to `list` (as `busy` is equal to `false` and the `containerNode` children length
		 * is greater than zero), the actual list is shown.
		 * When it is equal to `no-items` (only if `showNoItems` is set to `true`and the `containerNode`
		 * children length is equal to zero), a `d-list-no-items` is displayed.
		 * When it is `none` (as `showNoItems is set to `false` and `busy` not `true` and `containerNode`
		 * children length is equal to zero, nothing is shown.
		 * @type {String}
		 * @default ""
		 * @private
		 */
		_displayedPanel: "",

		template: template,

		/**
		 * Defines the scroll direction: `"vertical"` for a scrollable List, `"none"` for a non scrollable List.
		 * @member {string} module:deliteful/list/List#scrollDirection
		 * @default "vertical"
		 */
		_setScrollDirectionAttr: function (value) {
			if (value !== "vertical" && value !== "none") {
				throw new TypeError("'"
						+ value
						+ "' not supported for scrollDirection, keeping the previous value of '"
						+ this.scrollDirection
						+ "'");
			} else {
				this._set("scrollDirection", value);
			}
		},

		/**
		 * Defines the selection mode: `"none"` (not allowed if `role=listbox` or `role=list`),
		 * `"radio"`, `"single"` or `"multiple"`.
		 * @member {string} module:deliteful/list/List#selectionMode
		 * @default "none", or "single" if `role=listbox` or `role=list`.
		 */
		_setSelectionModeAttr: dcl.superCall(function (sup) {
			return function (value) {
				if ((this.type === "listbox" || this.type === "list") && value === "none") {
					throw new TypeError("selectionMode 'none' is invalid for an aria listbox/list, "
							+ "keeping the previous value of '" + this.selectionMode + "'");
				} else {
					sup.apply(this, arguments);
				}
			};
		}),

		////////////////////////////////////////////////////////////////////////////////////////////
		// Override setAttribute(), getAttribute(), hasAttribute() and removeAttribute to move down to
		// the containerNode any aria attribute set to the root.

		setAttribute: dcl.superCall(function (sup) {
			return function (name, value) {
				if (/^aria-/.test(name) && this.containerNode) {
					this.containerNode.setAttribute(name, value);
				} else {
					sup.call(this, name, value);
				}
			};
		}),

		getAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name) && this.containerNode) {
					return this.containerNode.getAttribute(name);
				} else {
					return sup.call(this, name);
				}
			};
		}),

		hasAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name) && this.containerNode) {
					return this.containerNode.hasAttribute(name);
				} else {
					return sup.call(this, name);
				}
			};
		}),

		removeAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name) && this.containerNode) {
					this.containerNode.removeAttribute(name);
				} else {
					sup.call(this, name);
				}
			};
		}),

		/**
		 * The selection mode for list items (see {@link module:delite/Selection delite/Selection}).
		 * @member {string}
		 * @default "none"
		 */
		selectionMode: "none",

		/**
		 * Optional message to display, with a progress indicator, when
		 * the list is loading its content.
		 * @member {string}
		 * @default ""
		 */
		loadingMessage: "",

		// CSS classes internally referenced by the List widget
		_cssClasses: {
			cell: "d-list-cell",
			selected: "d-selected",
			selectable: "d-selectable",
			multiselectable: "d-multiselectable"
		},

		/**
		 * Previous focus child before the list loose focus
		 * @member {Element} module:deliteful/list/List#_previousFocusedChild
		 * @private
		 */

		/**
		 * Flag set to a truthy value once the items have been loaded from the store
		 * @member {boolean} module:deliteful/list/List#_dataLoaded
		 * @private
		 */

		createdCallback: function () {
			this.on("query-error", function () {
				this._busy = false;
			}.bind(this));
		},

		queryStoreAndInitItems: dcl.superCall(function (sup) {
			return function () {
				// Setting busy to true and showing the progress indicator.
				// It's removed in initItems(), after the query completes and busy is set to false.
				this._busy = true;
				sup.apply(this, arguments);
			};
		}),

		refreshRendering: function (props, isAfterInitialRendering) {
			//	List attributes have been updated.
			/*jshint maxcomplexity:15*/
			if ("selectionMode" in props) {
				// Update aria attributes
				$(this.containerNode).removeClass(this._cssClasses.selectable);
				$(this.containerNode).removeClass(this._cssClasses.multiselectable);
				this.containerNode.removeAttribute("aria-multiselectable");
				if (this.selectionMode === "none") {
					// update aria-selected attribute on unselected items
					for (var i = 0; i < this.containerNode.children.length; i++) {
						var child = this.containerNode.children[i];
						if (child.renderNode // no renderNode for the loading panel child
							&& child.renderNode.hasAttribute("aria-selected")) {
							child.renderNode.removeAttribute("aria-selected");
							$(child).removeClass(this._cssClasses.selected);
						}
					}
				} else {
					if (this.selectionMode === "single" || this.selectionMode === "radio") {
						$(this.containerNode).addClass(this._cssClasses.selectable);
					} else {
						$(this.containerNode).addClass(this._cssClasses.multiselectable);
						this.containerNode.setAttribute("aria-multiselectable", "true");
					}
					// update aria-selected attribute on unselected items
					if (this.type === "grid" || this.type === "listbox") {
						for (i = 0; i < this.containerNode.children.length; i++) {
							child = this.containerNode.children[i];
							if (child.tagName.toLowerCase() === this.itemRenderer.tag
									&& child.renderNode // no renderNode for the loading panel child
									&& !child.renderNode.hasAttribute("aria-selected")) {
								child.renderNode.setAttribute("aria-selected", "false");
								$(child).removeClass(this._cssClasses.selected); // TODO: NOT NEEDED ?
							}
						}
					}
				}
			}

			if ("type" in props) {
				this.getRenderers().forEach(function (renderer) {
					renderer.parentRole = this.type;
					if (renderer.deliver) {
						renderer.deliver();
					}
				}.bind(this));
				if (this.type === "grid") {
					this.containerNode.setAttribute("aria-readonly", true);
				} else {
					this.containerNode.removeAttribute("aria-readonly");
				}
			}

			if (("renderItems" in props && this.renderItems ||
					"_displayedPanel" in props) && !isAfterInitialRendering) {
				// notify the list content changed.
				this.emit("delite-size-change");
			}
		},

		computeProperties: function (props) {
			/*jshint maxcomplexity:13*/
			//	List attributes have been updated.
			if ("itemRenderer" in props
				|| (this._isCategorized()
						&& ("categoryAttr" in props || "categoryFunc" in props || "categoryRenderer" in props))) {
				if (this._dataLoaded) {
					this._busy = true;

					// trigger a reload of the list
					this.notifyCurrentValue("source");
				}
			}
			if (("renderItems" in props && this.renderItems) || "_busy" in props || "showNoItems" in props) {
				this._displayedPanel = (this._busy) ? "loading-panel" :
					(this.containerNode && this.containerNode.children.length > 0) ?
						"list" : ((this.showNoItems) ? "no-items" : "none");
			}
		},

		postRender: function () {
			// moving down to the containerNode any aria attribute that has been set to the root node.
			for (var i = 0; i < this.attributes.length; i++) {
				if (/^aria-/.test(this.attributes[i].name)) {
					this.containerNode.setAttribute(this.attributes[i].name, this.attributes[i].value);
					HTMLElement.prototype.removeAttribute.call(this, this.attributes[i].name);
				}
			}
		},

		destroy: function () {
			// Remove reference to the list in the default store
			if (this.source && this.source.list) {
				this.source.list = null;
			}
		},

		deliver: dcl.superCall(function (sup) {
			return function () {
				// Deliver pending changes to the list and its renderers
				sup.apply(this, arguments);
				this.getRenderers().forEach(function (renderer) {
					if (renderer.deliver) {
						renderer.deliver();
					}
				});
			};
		}),

		//////////// Public methods ///////////////////////////////////////

		/**
		 * Returns the renderers displayed by the list.
		 * @returns {module:deliteful/list/Renderer[]}
		 * @private
		 */
		getRenderers: function () {
			return [].slice.call(this.containerNode ? this.containerNode.childNodes : []);
		},

		/**
		 * Returns the item and category renderers displayed by the list.
		 * @returns {module:deliteful/list/Renderer[]}
		 * @private
		 */
		getItemAndCategoryRenderers: function () {
			return Array.prototype.filter.call(this.containerNode.childNodes, function (node) {
				return node.tagName.toLowerCase() === this.itemRenderer.tag
					|| node.tagName.toLowerCase() === this.categoryRenderer.tag;
			}, this);
		},

		/**
		 * Returns the item renderers displayed by the list.
		 * @returns {module:deliteful/list/ItemRenderer[]}
		 */
		getItemRenderers: function () {
			return Array.prototype.filter.call(this.containerNode.childNodes, function (node) {
				return node.tagName.toLowerCase() === this.itemRenderer.tag;
			}, this);
		},

		/**
		 * Returns the renderer currently displaying an item with a specific id, or
		 * null if there is no renderer displaying an item with this id.
		 * @param {Object} id The id of the item displayed by the renderer.
		 * @returns {module:deliteful/list/Renderer}
		 */
		getRendererByItemId: function (id) {
			var renderers = this.getItemRenderers();
			for (var i = 0; i < renderers.length; i++) {
				var renderer = renderers[i];
				if (this.getIdentity(renderer.item) === id) {
					return renderer;
				}
			}
			return null;
		},

		/**
		 * Returns the item renderer at a specific index in the List, or null if there is no
		 * renderer at this index.
		 * @param {number} index The item renderer at the index (first item renderer index is 0).
		 * @returns {module:deliteful/list/ItemRenderer}
		 */
		getItemRendererByIndex: function (index) {
			return this.getItemRenderers()[index] || null;
		},

		/**
		 * Returns the index of an item renderer in the List, or -1 if
		 * the item renderer is not found in the list.
		 * @param {Object} renderer The item renderer.
		 * @returns {number}
		 */
		getItemRendererIndex: function (renderer) {
			var result = -1;
			if (renderer.item) {
				var id = this.getIdentity(renderer.item);
				var nodeList = this.getItemRenderers();
				for (var i = 0; i < nodeList.length; i++) {
					var currentRenderer = nodeList[i];
					if (this.getIdentity(currentRenderer.item) === id) {
						result = i;
						break;
					}
				}
			}
			return result;
		},

		/**
		 * Returns the renderer enclosing a dom node, or null
		 * if there is none.
		 * @param {Element} node The dom node.
		 * @returns {module:deliteful/list/Renderer}
		 */
		getEnclosingRenderer: function (node) {
			var currentNode = node;
			while (currentNode) {
				if (currentNode.parentNode && currentNode.parentNode === this.containerNode) {
					break;
				}
				currentNode = currentNode.parentNode;
			}
			return currentNode;
		},

		//////////// delite/Selection implementation ///////////////////////////////////////

		/**
		 * Updates renderers when the selection has changed.
		 * @param {Object[]} items The items which renderers must be updated.
		 * @protected
		 */
		updateRenderers: function (items) {
			if (this.selectionMode !== "none" && (this.type === "grid" || this.type === "listbox")) {
				for (var i = 0; i < items.length; i++) {
					var currentItem = items[i];
					var renderer = this.getRendererByItemId(this.getIdentity(currentItem));
					if (renderer) {
						var itemSelected = !!this.isSelected(currentItem);
						renderer.renderNode.setAttribute("aria-selected", itemSelected ? "true" : "false");
						$(renderer).toggleClass(this._cssClasses.selected, itemSelected);
					}
				}
			}
		},

		/**
		 * Always returns true so that no keyboard modifier is needed when selecting / deselecting items.
		 * @param {Event} event
		 * @return {boolean}
		 * @protected
		 */
		hasSelectionModifier: function (/*jshint unused: vars*/event) {
			return true;
		},

		/**
		 * Event handler that performs items (de)selection.
		 * @param {Event} event The event the handler was called for.
		 * @returns {boolean} `true` if the event has been handled, that is if the
		 *    event target has an enclosing item renderer. Returns `false` otherwise.
		 * @protected
		 */
		handleSelection: function (/*Event*/event) {
			var eventRenderer = this.getEnclosingRenderer(event.target);
			if (eventRenderer) {
				if (!this.isCategoryRenderer(eventRenderer)) {
					this.selectFromEvent(event, eventRenderer.item, eventRenderer, true);
				}
				return true;
			}
			return false;
		},

		//////////// Private methods ///////////////////////////////////////

		/**
		 * Returns whether the list is categorized or not.
		 * @private
		 */
		_isCategorized: function () {
			return this.categoryAttr || this.categoryFunc;
		},

		/**
		 * Destroys all children of the list and empty it
		 * @private
		 */
		_empty: function () {
			this.findCustomElements(this.containerNode).forEach(function (w) {
				if (w.destroy) {
					w.destroy();
				}
			});
			this.containerNode.innerHTML = "";
			this._previousFocusedChild = null;
		},

		//////////// Renderers life cycle ///////////////////////////////////////

		/**
		 * Renders new items within the list widget.
		 * @param {Object[]} items The new items to render.
		 * @param {boolean} atTheTop If true, the new items are rendered at the top of the list.
		 * If false, they are rendered at the bottom of the list.
		 * @private
		 */
		_renderNewItems: function (/*Array*/ items, /*boolean*/atTheTop) {
			if (!this.containerNode.firstElementChild) {
				this.containerNode.appendChild(this._createRenderers(items, 0, items.length, null));
			} else {
				if (atTheTop) {
					if (this._isCategorized()) {
						var firstRenderer = this._getFirstRenderer();
						if (this.isCategoryRenderer(firstRenderer)
								&& items[items.length - 1].category === firstRenderer.item.category) {
							// Remove the category renderer on top before adding the new items
							this._removeRenderer(firstRenderer);
						}
					}
					this.containerNode.insertBefore(this._createRenderers(items, 0, items.length, null),
							this.containerNode.firstElementChild);
				} else {
					this.containerNode.appendChild(this._createRenderers(items, 0, items.length,
							this._getLastRenderer().item));
				}
			}
			// start renderers
			this.findCustomElements(this.containerNode).forEach(function (w) {
				w.attachedCallback();
			});
		},

		/**
		 * Creates renderers for a list of items (including the category renderers if the list
		 * is categorized).
		 * @param {Object[]} items Array An array that contains the items to create renderers for.
		 * @param {number} fromIndex The index of the first item in the array of items
		 * (no renderer will be created for the items before this index).
		 * @param {number} count The number of items to use from the array of items, starting
		 * from the fromIndex position
		 * (no renderer will be created for the items that follows).
		 * @param {Object} previousItem The item that precede the first one for which a renderer will be created.
		 * This is only usefull for categorized lists.
		 * @return {DocumentFragment}  A DocumentFragment that contains the renderers.
		 * The startup method of the renderers has not been called at this point.
		 * @private
		 */
		_createRenderers: function (items, fromIndex, count, previousItem) {
			var currentIndex = fromIndex,
				currentItem, toIndex = fromIndex + count - 1;
			var documentFragment = this.ownerDocument.createDocumentFragment();
			for (; currentIndex <= toIndex; currentIndex++) {
				currentItem = items[currentIndex];
				if (this._isCategorized()
					&& (!previousItem || currentItem.category !== previousItem.category)) {
					documentFragment.appendChild(this._createCategoryRenderer(currentItem));
				}
				documentFragment.appendChild(this._createItemRenderer(currentItem));
				previousItem = currentItem;
			}
			return documentFragment;
		},

		/**
		 * Add an item renderer to the List, updating category renderers if needed.
		 * This method calls the startup method on the renderer after it has been
		 * added to the List.
		 * @param {module:deliteful/list/ItemRenderer} The renderer to add to the list.
		 * @param {number} atIndex The index (not counting category renderers) where to add
		 * the item renderer in the list.
		 * @private
		 */
		_addItemRenderer: function (renderer, atIndex) {
			var spec = this._getInsertSpec(renderer, atIndex);
			if (spec.nodeRef) {
				this.containerNode.insertBefore(renderer, spec.nodeRef);
				if (spec.addCategoryAfter) {
					var categoryRenderer = this._createCategoryRenderer(spec.nodeRef.item);
					this.containerNode.insertBefore(categoryRenderer, spec.nodeRef);
					categoryRenderer.attachedCallback();
				}
			} else {
				this.containerNode.appendChild(renderer);
			}
			if (spec.addCategoryBefore) {
				categoryRenderer = this._createCategoryRenderer(renderer.item);
				this.containerNode.insertBefore(categoryRenderer, renderer);
				categoryRenderer.attachedCallback();
			}
			renderer.attachedCallback();
		},

		/**
		 * Get a specification for the insertion of an item renderer in the list.
		 * @param {module:deliteful/list/ItemRenderer} renderer The renderer to add to the list.
		 * @param {number} atIndex The index (not counting category renderers) where to add
		 * the item renderer in the list.
		 * @return {Object} an object that contains the following attributes:
		 * - nodeRef: the node before which to insert the item renderer
		 * - addCategoryBefore: true if a category header should be inserted before the item renderer
		 * - addCategoryAfter: true if a category header should be inserted after the item renderer
		 * @private
		 */
		_getInsertSpec: function (renderer, atIndex) {
			var result = {nodeRef: atIndex >= 0 ? this.getItemRendererByIndex(atIndex) : null,
						  addCategoryBefore: false,
						  addCategoryAfter: false};
			if (this._isCategorized()) {
				var previousRenderer = result.nodeRef
										? this._getNextRenderer(result.nodeRef, -1)
										: this._getLastRenderer();
				if (!previousRenderer) {
					result.addCategoryBefore = true;
				} else {
					if (!this._sameCategory(renderer, previousRenderer)) {
						if (this.isCategoryRenderer(previousRenderer)) {
							result.nodeRef = previousRenderer;
							previousRenderer = this._getNextRenderer(previousRenderer, -1);
							if (!previousRenderer
								|| (previousRenderer && !this._sameCategory(renderer, previousRenderer))) {
								result.addCategoryBefore = true;
							}
						} else {
							result.addCategoryBefore = true;
						}
					}
				}
				if (result.nodeRef
					&& !this.isCategoryRenderer(result.nodeRef)
					&& !this._sameCategory(result.nodeRef, renderer)) {
					result.addCategoryAfter = true;
				}
			}
			return result;
		},

		/*jshint maxcomplexity:12*/
		/**
		 * Removes a renderer from the List, updating category renderers if needed.
		 * @param {module:deliteful/list/Renderer} renderer The renderer to remove from the list.
		 * @param {boolean} keepSelection Set to true if the renderer item should not be removed
		 * from the list of selected items.
		 * @private
		 */
		_removeRenderer: function (renderer, keepSelection) {
			if (this._isCategorized() && !this.isCategoryRenderer(renderer)) {
				// remove the previous category header if necessary
				var previousRenderer = this._getNextRenderer(renderer, -1);
				if (previousRenderer && this.isCategoryRenderer(previousRenderer)) {
					var nextRenderer = this._getNextRenderer(renderer, 1);
					if (!nextRenderer || !this._sameCategory(renderer, nextRenderer)) {
						this._removeRenderer(previousRenderer);
					}
				}
			}
			// Update focus if necessary
			if (this._getFocusedRenderer() === renderer) {
				var nextFocusRenderer = this._getNextRenderer(renderer, 1) || this._getNextRenderer(renderer, -1);
				if (nextFocusRenderer) {
					this.navigateTo(nextFocusRenderer.renderNode);
				}
			}
			if (!keepSelection && !this.isCategoryRenderer(renderer) && this.isSelected(renderer.item)) {
				// deselect the item before removing the renderer
				this.selectFromEvent(null, renderer.item, renderer, true);
			}
			// remove and destroy the renderer
			if (this._previousFocusedChild && this.getEnclosingRenderer(this._previousFocusedChild) === renderer) {
				this._previousFocusedChild = null;
			}
			this.containerNode.removeChild(renderer);
			renderer.destroy();
		},
		/*jshint maxcomplexity:10*/

		/**
		 * Creates a renderer instance for an item.
		 * @param {Object} item The item to render.
		 * @returns {module:deliteful/list/ItemRenderer} An instance of item renderer that renders the item.
		 * @private
		 */
		_createItemRenderer: function (item) {
			var renderer = new this.itemRenderer({
				item: item,
				parentRole: this.type,
				tabindex: "-1"
			});
			if (this.selectionMode !== "none" && (this.type === "grid" || this.type === "listbox")) {
				var itemSelected = !!this.isSelected(item);
				renderer.renderNode.setAttribute("aria-selected", itemSelected ? "true" : "false");
				$(renderer).toggleClass(this._cssClasses.selected, itemSelected);
			}
			return renderer;
		},

		/**
		 * Creates a category renderer instance for an item.
		 * @param {Object} item The item which category to render.
		 * @returns {module:deliteful/list/CategoryRenderer} An instance of category renderer
		 * that renders the category of the item.
		 * @private
		 */
		_createCategoryRenderer: function (item) {
			var renderer = new this.categoryRenderer({
				item: item,
				parentRole: this.type,
				tabindex: "-1"
			});
			return renderer;
		},

		/**
		 * Returns whether a renderer is a category renderer or not>.
		 * @param {module:deliteful/list/Renderer} renderer The renderer to test.
		 * @return {boolean}
		 */
		isCategoryRenderer: function (/*deliteful/list/Renderer*/renderer) {
			return renderer.tagName.toLowerCase() === this.categoryRenderer.tag;
		},

		/**
		 * Returns whether two renderers have the same category or not.
		 * @param {module:deliteful/list/Renderer} renderer1 The first renderer.
		 * @param {module:deliteful/list/Renderer} renderer2 The second renderer.
		 * @private
		 */
		_sameCategory: function (renderer1, renderer2) {
			return renderer1.item.category === renderer2.item.category;
		},

		/**
		 * Returns the renderer that comes immediately after of before another one.
		 * @param {module:deliteful/list/Renderer} renderer The renderer immediately before or after the one to return.
		 * @param {number} dir 1 to return the renderer that comes immediately after renderer, -1 to
		 * return the one that comes immediately before.
		 * @returns {module:deliteful/list/Renderer}
		 * @private
		 */
		_getNextRenderer: function (renderer, dir) {
			if (dir >= 0) {
				return renderer.nextElementSibling;
			} else {
				return renderer.previousElementSibling;
			}
		},

		/**
		 * Returns the first item or category renderer in the list.
		 * @returns {module:deliteful/list/Renderer}
		 * @private
		 */
		_getFirstRenderer: function () {
			return this.getItemAndCategoryRenderers()[0] || null;
		},

		/**
		 * Returns the last item or category renderer in the list.
		 * @returns {module:deliteful/list/Renderer}
		 * @private
		 */
		_getLastRenderer: function () {
			var renderers = this.getItemAndCategoryRenderers();
			return renderers[renderers.length - 1] || null;
		},

		////////////delite/Store implementation ///////////////////////////////////////

		/**
		 * Populate the list using the items retrieved from the store.
		 * @param {Object[]} items items retrieved from the store.
		 * @protected
		 * @fires module:delite/Store#query-success
		 */
		initItems: dcl.superCall(function (sup) {
			return function (items) {
				this._empty();
				this._renderNewItems(items, false);
				this._busy = false;
				this._dataLoaded = true;
				return sup.call(this, items);
			};
		}),

		/**
		 * Function to call when an item is removed from the store, to update
		 * the content of the list widget accordingly.
		 * @param {number} index The index of the render item to remove.
		 * @param {Object[]} renderItems Ignored by this implementation.
		 * @param {boolean} keepSelection Set to true if the item should not be removed from the list of selected items.
		 * @protected
		 */
		itemRemoved: function (index, renderItems, keepSelection) {
			var renderer = this.getItemRendererByIndex(index);
			if (renderer) {
				this._removeRenderer(renderer, keepSelection);
			}
			this.notifyCurrentValue("renderItems");
		},

		/**
		 * Function to call when an item is added to the store, to update
		 * the content of the list widget accordingly.
		 * @param {number} index The index where to add the render item.
		 * @param {Object} renderItem The render item to be added.
		 * @param {Object[]} renderItems Ignored by this implementation.
		 * @private
		 */
		itemAdded: function (index, renderItem, /*jshint unused:vars*/renderItems) {
			var newRenderer = this._createItemRenderer(renderItem);
			this._addItemRenderer(newRenderer, index);
			this.notifyCurrentValue("renderItems");
		},

		/**
		 * Function to call when an item is updated in the store, to update
		 * the content of the list widget accordingly.
		 * @param {number}  index The index of the render item to update.
		 * @param {Object} renderItem The render item data the render item must be updated with.
		 * @param {Object[]} renderItems Ignored by this implementation.
		 * @protected
		 */
		itemUpdated: function (index,  renderItem, /*jshint unused:vars*/renderItems) {
			var renderer = this.getItemRendererByIndex(index);
			if (renderer) {
				renderer.item = renderItem;
			}
		},

		itemMoved: function (previousIndex, newIndex, renderItem, renderItems) {
			// summary:
			//		Function to call when an item is moved in the store, to update
			//		the content of the list widget accordingly.
			// previousIndex: Number
			//		The previous index of the render item.
			// newIndex: Number
			//		The new index of the render item.
			// renderItem: Object
			//		The render item to be moved.
			// renderItems: Array
			//		Ignored by this implementation.
			// tags:
			//		protected
			this.itemRemoved(previousIndex, renderItems, true);
			this.itemAdded(newIndex, renderItem, renderItems);
		},

		//////////// delite/Scrollable extension ///////////////////////////////////////

		/**
		 * Returns the distance between the top of a node and
		 * the top of the scrolling container.
		 * @param {Node} node the node
		 * @protected
		 */
		getTopDistance: function (node) {
			// Need to use Math.round for IE
			return Math.round(node.offsetTop - this.getCurrentScroll().y);
		},

		/**
		 * Returns the distance between the bottom of a node and
		 * the bottom of the scrolling container.
		 * @param {Node} node the node
		 * @protected
		 */
		getBottomDistance: function (node) {
			var clientRect = this.getBoundingClientRect();
			// Need to use Math.round for IE
			return Math.round(node.offsetTop +
				node.offsetHeight -
				this.getCurrentScroll().y -
				(clientRect.bottom - clientRect.top));
		},

		//////////// delite/KeyNav implementation ///////////////////////////////////////
		// Keyboard navigation is based on WAI ARIA Pattern for Grid:
		// http://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#grid

		/**
		 * Test if the child is navigable.  Skips category renderers when role=listbox,
		 * role=list or role=menu.
		 * @private
		 */
		descendantSelector: function (child) {
			var enclosingRenderer = this.getEnclosingRenderer(child);
			return enclosingRenderer &&
				(this.type === "grid" || !this.isCategoryRenderer(enclosingRenderer)) &&
				($(child).hasClass(this._cssClasses.cell) || child.hasAttribute("navindex"));
		},

		/**
		 * Handle keydown events.
		 * @private
		 */
		_keynavKeyDownHandler: dcl.before(function (evt) {
			if (!evt.defaultPrevented) {
				if ((evt.key === "Spacebar" && !this._searchTimer)) {
					this._spaceKeydownHandler(evt);
				} else {
					if (this.type === "grid") {
						this._gridKeydownHandler(evt);
					}
				}
			}
		}),

		focus: function () {
			// Focus the previously focused child of the first visible grid cell
			if (this._previousFocusedChild) {
				this.navigateTo(this._previousFocusedChild);
			} else {
				var cell = this._getFirst();
				if (cell) {
					while (cell) {
						if (this.getTopDistance(cell) >= 0) {
							break;
						}
						var nextRenderer = cell.parentNode.nextElementSibling;
						cell = nextRenderer ? nextRenderer.renderNode : null;
					}
					this.navigateTo(cell);
				}
			}
		},

		focusoutHandler: dcl.superCall(function (sup) {
			return function (evt) {
				// When focus moves outside of the List, save reference to previously focused child.
				if (!this.contains(evt.relatedTarget)) {
					this._previousFocusedChild = this.navigatedDescendant;
				}

				sup.apply(this, arguments);
			};
		}),

		/**
		 * Returns the first cell in the list.
		 * For role=listbox, role=list and role=menu, skips category renderers.
		 * However, it doesn't skip navigation renderers ("click to load previous rows ...").
		 * @private
		 * @returns {Element}
		 */
		_getFirst: function () {
			var firstRenderer = this.containerNode.childNodes[0],
				firstCell = firstRenderer && firstRenderer.renderNode;
			if (this.type !== "grid" && firstRenderer && this.isCategoryRenderer(firstRenderer)) {
				firstCell = this.getNext(firstCell, 1);
			}
			return firstCell;
		},

		/**
		 * Returns the last cell in the list.
		 * For role=listbox, role=list and role=menu, skips category renderers.
		 * However, it doesn't skip navigation renderers ("click to load more rows ...").
		 * @private
		 * @returns {Element}
		 */
		_getLast: function () {
			var lastRenderer = this.containerNode.childNodes[this.containerNode.childNodes.length - 1],
				lastCell = lastRenderer && lastRenderer.renderNode;
			if (this.type !== "grid" && lastRenderer && this.isCategoryRenderer(lastRenderer)) {
				lastCell = this.getNext(lastCell, -1);
			}
			return lastCell || null;
		},

		/**
		 * Get the next or previous cell, compared to the specified one.
		 * @param child
		 * @param dir
		 * @returns {Element}
		 */
		getNext: function (child, dir) {
			if (child === this.containerNode) {
				return dir > 0 ? this._getFirst() : this._getLast();
			}

			var renderer = this.getEnclosingRenderer(child);
			return dir > 0 ? renderer.nextElementSibling ? renderer.nextElementSibling.renderNode : this._getFirst() :
				renderer.previousElementSibling ? renderer.previousElementSibling.renderNode : this._getLast();
		},

		// Simple arrow key support.
		downKeyHandler: function (evt) {
			if (this.navigatedDescendant && this.navigatedDescendant.hasAttribute("navindex")) {
				return;
			}
			var focusedRenderer = this._getFocusedRenderer();
			var next = null;
			if (focusedRenderer) {
				next = focusedRenderer.nextElementSibling;
				if (next && this.type !== "grid" && this.isCategoryRenderer(next)) {
					next = next.nextElementSibling;
				}
			}
			this.navigateTo(next ? next.renderNode : this._getFirst(), false, evt);
		},

		upKeyHandler: function (evt) {
			if (this.navigatedDescendant && this.navigatedDescendant.hasAttribute("navindex")) {
				return;
			}
			var focusedRenderer = this._getFocusedRenderer();
			var next = null;
			if (focusedRenderer) {
				next = focusedRenderer.previousElementSibling;
				if (next && this.type !== "grid" && this.isCategoryRenderer(next)) {
					next = next.previousElementSibling;
				}
			}
			this.navigateTo(next ? next.renderNode : this._getLast(), false, evt);
		},

		// Remap Page Up -> Home and Page Down -> End

		pageUpKeyHandler: function (evt) {
			this.navigateToFirst(evt);
		},

		pageDownKeyHandler: function (evt) {
			this.navigateToLast(evt);
		},

		//////////// Extra methods for Keyboard navigation ///////////////////////////////////////

		/**
		 * Handles SPACE key keydown event
		 * @param {Event} evt the keydown event
		 * @private
		 */
		_spaceKeydownHandler: function (evt) {
			if (this.selectionMode !== "none") {
				if (this.handleSelection(evt)) {
					evt.preventDefault();
				} // else do not prevent-default, for the sake of use-cases
				// such as Combobox where the target of the key event is an
				// input element outside the List. In this use-case, delite/HasDropDown
				// forwards "keydown" events to the List instance and prevent-defaults
				// the event if any key handler prevent-defaults the event, which would
				// forbid the user from entering space characters in the input element.
			}
		},

		/*jshint maxcomplexity:13*/
		/**
		 * Handles keydown events for the aria role grid
		 * @param {Event} evt the keydown event
		 * @private
		 */
		_gridKeydownHandler: function (evt) {
			if (evt.key === "Enter" || evt.key === "F2") {
				if (this.navigatedDescendant && !this.navigatedDescendant.hasAttribute("navindex")) {
					// Enter Actionable Mode
					// TODO: prevent default ONLY IF autoAction is false on the renderer ?
					// See http://www.w3.org/TR/2013/WD-wai-aria-practices-20130307/#grid
					evt.preventDefault();
					this._enterActionableMode();
				}
			} else if (evt.key === "Tab") {
				if (this.navigatedDescendant && this.navigatedDescendant.hasAttribute("navindex")) {
					// We are in Actionable mode
					evt.preventDefault();
					var renderer = this._getFocusedRenderer();
					var next = renderer[evt.shiftKey ? "getPrev" : "getNext"](this.navigatedDescendant);
					while (!next) {
						renderer = renderer[evt.shiftKey ? "previousElementSibling" : "nextElementSibling"]
							|| this[evt.shiftKey ? "_getLast" : "_getFirst"]().parentNode;
						next = renderer[evt.shiftKey ? "getLast" : "getFirst"]();
					}
					this.navigateTo(next);
				}
			} else if (evt.key === "Escape") {
				// Leave Actionable mode
				this._leaveActionableMode();
			}
		},
		/*jshint maxcomplexity:10*/

		/**
		 * @private
		 */
		_enterActionableMode: function () {
			var focusedRenderer = this._getFocusedRenderer();
			if (focusedRenderer) {
				var next = focusedRenderer.getFirst();
				if (next) {
					this.navigateTo(next);
				}
			}
		},

		/**
		 * @private
		 */
		_leaveActionableMode: function () {
			this.navigateTo(this._getFocusedRenderer().renderNode);
		},

		/**
		 * Returns the renderer that currently has the focused or is
		 * an ancestor of the focused node.
		 * @return {module:deliteful/list/Renderer}
		 * @private
		 */
		_getFocusedRenderer: function () {
			return this.navigatedDescendant ? this.getEnclosingRenderer(this.navigatedDescendant) : null;
		}
	});
});
;
/**
 * Plugin based on requirejs i18n
 * see: http://github.com/requirejs/i18n for details
 */
define('requirejs-dplugins/i18n',["./i18n/common", "./i18n/build", "module"], function (common, build, module) {

	var localesList,
		writePluginFile,

		mixin = common.mixin,
		eachProp = common.eachProp,
		parseName = common.parseName,
		getMasterMid = common.getMasterMid,

		normalizeBundlesMap = function (bundlesMap) {
			var result = {};
			eachProp(bundlesMap, function (layer, bundleList) {
				bundleList.forEach(function (bundle) {
					result[bundle] = layer;
				});
			});
			return result;
		},

		// Transform a bundle from a language layer to a root bundle.
		rootify = function (bundle, locale) {
			var result = {};
			if (bundle._pseudoRoot) {
				result[locale] = {};
				mixin(result, bundle._pseudoRoot);
				delete bundle._pseudoRoot;
				mixin(result[locale], bundle);
				bundle = result;
			}
			return bundle;
		},

		// Construct the best language bundle by merging from most specific locale to less specific locale.
		resolveAMD = function (name, req, onLoad) {
			var masterMid = getMasterMid(name);

			//First, fetch the master bundle, it knows what locales are available.
			req([masterMid], function (master) {
				var getBundleAndMixin = function (prefix, suffix, locale, value) {
					var mixBundle = function (bundle) {
						mixin(value, bundle);
						locale = common.getParentLocale(locale);
						if (!bundle._flattened && locale) {
							getBundleAndMixin(prefix, suffix, locale, value);
						} else {
							value._flattened = true;
							onLoad(value);
						}
					};

					if (master[locale] === true || master[locale] === 1) {
						req([prefix + locale + '/' + suffix], mixBundle);
					} else {
						// locale is on the master bundle or locale is unexisting
						mixBundle(master[locale] || {});
					}
				};

				master = rootify(master, name.masterLocale);
				getBundleAndMixin(name.prefix, name.suffix, name.requestedLocale, {});
			});
		},

		getLayer = function (name, layer, moduleConfig, getParentLocale, req, onLoad) {
			var locale = name.requestedLocale,
				localesList = moduleConfig.localesMap[layer];

			while (locale && localesList.indexOf(locale) < 0) {
				locale = getParentLocale(locale);
			}

			if (locale) {
				name.masterLocale = locale;

				req([layer + "_" + locale], function () {
					pickFromLayer(name, moduleConfig, req, onLoad);
				});
			} else {
				console.log("i18n: no relevant layer " + layer + " found for locale " + name.requestedLocale + ".");
				onLoad();
			}
		},


		tryLayer = function (name, layer, moduleConfig, getParentLocale, req, onLoad) {
			var helper = function (locale) {
				if (locale) {
					req(["maybe!" + layer + "_" + locale], function (bundle) {
						if (bundle) {
							name.masterLocale = locale;
							pickFromLayer(name, moduleConfig, req, onLoad);
						} else {
							helper(getParentLocale(locale));
						}
					});
				} else {
					console.log("i18n: no relevant layer " + layer + " found for locale " + name.requestedLocale + ".");
					onLoad();
				}
			};

			helper(name.requestedLocale);
		},

		pickFromLayer = function (name, moduleConfig, req, onLoad) {
			var masterMid = getMasterMid(name);

			if (name.requestedLocale === name.masterLocale || moduleConfig.layerOnly || !moduleConfig.enhanceLayer) {
				req([masterMid], function (bundle) {
					if (bundle.root) {
						bundle = bundle.root;
					}
					onLoad(bundle);
				});
			} else {
				resolveAMD(name, req, onLoad);
			}
		};

	return {
		/* jshint maxcomplexity:15 */
		load: function (name, req, onLoad, config) {
			if (!name) {
				onLoad();
				return;
			}

			config = config || {};

			var moduleConfig = {},
				masterMid,
				layer;

			// Copy the config
			mixin(moduleConfig, typeof module.config === "function" ? module.config() || {} : {});

			if (config.isBuild) {
				localesList = moduleConfig.localesList;
				onLoad();
				return;
			}

			moduleConfig.enhanceLayer = moduleConfig.enhanceLayer === undefined ? true : moduleConfig.enhanceLayer;

			// Parse name and set the locale if a top level bundle is required
			name = parseName(name);
			name.requestedLocale = name.requestedLocale || common.getLocale(moduleConfig.locale || config.locale);
			masterMid = getMasterMid(name);

			// If there is no layer, classic AMD mode
			if (!moduleConfig.bundlesMap) {
				resolveAMD(name, req, onLoad);
				return;
			}

			// From now on there is at least one layer available

			// Check if requested module is in a layer
			moduleConfig.bundlesMap = normalizeBundlesMap(moduleConfig.bundlesMap);
			layer = moduleConfig.bundlesMap[masterMid];

			if (!layer && moduleConfig.layerOnly) {
				console.log("i18n: module " + masterMid + " not found in layer.");
				onLoad();
				return;
			} else if (!layer) {
				resolveAMD(name, req, onLoad);
				return;
			}

			// The module is in a layer

			if (moduleConfig.languagePack) {
				// Drop language pack mode, hence need to try every possible layer
				tryLayer(name, layer, moduleConfig, common.getParentLocale, req, onLoad);
				return;
			} else {
				// There is a locale list for the layer
				getLayer(name, layer, moduleConfig, common.getParentLocale, req, onLoad);
				return;
			}
		},
		/* jshint  maxcomplexity:10 */

		write: function (pluginName, moduleName, write) {
			var name = parseName(moduleName),
				bundle;

			if (name.requestedLocale) {
				bundle = build.resolveSync(name.requestedLocale, name);
				if (name.requestedLocale !== "root") {
					bundle._pseudoRoot = {};
					bundle._flattened = true;
				}
				write.asModule(pluginName + "!" + moduleName, "define(" + JSON.stringify(bundle) + ")");
			} else {
				build.addBundleToNlsLayer(name);
			}
		},

		writeFile: function (pluginName, resource, requirejs, writeFile) {
			writePluginFile = writeFile;
		},

		onLayerEnd: function (write, data) {
			if (data.name && data.path) {
				var layersContent;

				build.setLocalesList(localesList);

				layersContent = build.getLayersContent();

				build.writeLayers(layersContent, data, writePluginFile);
				build.writeConfig(module.id, data, write);
			}
			build.reset();
		}
	};
});
;
define('requirejs-dplugins/i18n/build',["./common"], function (common) {
	var bundlesList = [],
		localesList,
		layerMid,

		mixin = common.mixin,
		eachProp = common.eachProp,
		getMasterMid = common.getMasterMid,

		getLayerMid = function (data) {
			var match;
			if (!layerMid) {
				match = data.name.match(/^(.*\/)?(.*)$/);
				layerMid = (match[1] || "") + "nls/" + match[2];
			}
			return layerMid;
		},

		getLayerPath = function (data, loc) {
			var match = data.path.match(/^(.*\/)?(.*)\.js$/);
			return (match[1] || "") + "nls/" + match[2] + "_" + loc + ".js";
		},

		getAllAvailableLocales = function () {
			localesList = [];
			bundlesList.forEach(function (name) {
				var root = require(getMasterMid(name));

				eachProp(root, function (loc) {
					if (root[loc] && localesList.indexOf(loc) < 0) {
						localesList.push(loc);
					}
				});
			});
			return localesList;
		},

		normalizeRoot = function (bundle, name) {
			bundle.root = (bundle.root === true || bundle.root === 1) ?
				require(name.prefix + "root/" + name.suffix) : bundle.root;
			return bundle;
		},

		getPseudoRoots = function (root) {
			var pseudoRoots = {};
			eachProp(root, function (loc) {
				var parent = common.getParentLocale(loc);
				while (parent && parent !== "root") {
					pseudoRoots[parent] = pseudoRoots[parent] || {};
					pseudoRoots[parent][loc] = true;
					parent = common.getParentLocale(parent);
				}
			});
			return pseudoRoots;
		},

		resolveSync = function (locale, name, root) {
			var loc = locale,
				result = {},
				localizedBundle;

			if (arguments.length === 2) {
				root = normalizeRoot(require(getMasterMid(name)), name);
			}

			if (loc !== "root") {
				while (loc && loc !== "root") {
					if (root[loc]) {
						localizedBundle = require(name.prefix + loc + "/" + name.suffix);
						mixin(result, localizedBundle);
					}
					loc = common.getParentLocale(loc);
				}
				localizedBundle = root.root;
				mixin(result, localizedBundle);
			} else {
				mixin(result, root);
			}

			return result;
		};

	return {
		addBundleToNlsLayer: function (name) {
			bundlesList.push(name);
		},

		setLocalesList: function (locList) {
			localesList = locList ? locList.slice() : getAllAvailableLocales();
			if (localesList.indexOf("root") < 0) {
				localesList.push("root");
			}
		},

		reset: function () {
			bundlesList = [];
			localesList = undefined;
			layerMid = undefined;
		},

		getLayersContent: function () {
			var layersContent = {};

			bundlesList.forEach(function (name) {
				var root = normalizeRoot(require(getMasterMid(name)), name),
					pseudoRoots = getPseudoRoots(root);

				localesList.forEach(function (loc) {
					var result = resolveSync(loc, name, root);

					layersContent[loc] = layersContent[loc] || "";

					var mid;
					if (loc !== "root") {
						mid = name.prefix + loc + "/" + name.suffix;
						result._flattened = true;
						result._pseudoRoot = pseudoRoots[loc] || {};
					} else {
						mid = name.prefix + name.suffix;
					}

					layersContent[loc] += 'define("' + mid + '",' + JSON.stringify(result) + ");";
				});
			});

			return layersContent;
		},

		writeLayers: function (layersContent, data, writePluginFile) {
			eachProp(layersContent, function (loc, content) {
				content += "define('" + getLayerMid(data) + "_" + loc + "', true);";
				writePluginFile(getLayerPath(data, loc), content);
			});
		},

		writeConfig: function (pluginName, data, write) {
			var bundles = bundlesList.map(getMasterMid),
				layerMid = getLayerMid(data),
				i18nConf = {
					config: {}
				};
			i18nConf.config[pluginName] = {
				bundlesMap: {},
				localesMap: {}
			};
			i18nConf.config[pluginName].bundlesMap[layerMid] = bundles;
			i18nConf.config[pluginName].localesMap[layerMid] = localesList;

			// write i18n config on the layer
			write("require.config(" + JSON.stringify(i18nConf) + ");");
		},

		resolveSync: resolveSync
	};
});
;
define('requirejs-dplugins/i18n/common',["./parentLocale"], function (parentLocale) {

	// regexp for reconstructing the master bundle name from parts of the regexp match
	// "foo/bar/baz/nls/en-ca/foo".match(nlsRegExp) gives:
	// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "en-ca", "foo"]
	// nlsRegExp.exec("foo/bar/baz/nls/foo") gives:
	// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "foo", ""]
	// so, if match[3] is blank, it means this is the top bundle definition.
	var nlsRegExp = /(^.*(?:^|\/)nls\/)([^\/]*)\/?([^\/]*)$/;

	return {
		eachProp: function (obj, func) {
			var prop;
			for (prop in obj) {
				if (obj.hasOwnProperty(prop)) {
					func(prop, obj[prop]);
				}
			}
		},

		getLocale: function (locale) {
			if (!locale) {
				locale = typeof navigator === "undefined" ? "root" :
					(navigator.language ||
					// IE <= 10
					navigator.userLanguage ||
					"root");
			}
			// just to be extra-sure
			return locale.toLowerCase();
		},

		getParentLocale: function (loc) {
			if (!loc || loc === "root") {
				return undefined;
			}
			if (parentLocale[loc]) {
				return parentLocale[loc];
			}

			var parts = loc.split("-");
			parts.pop();
			return (parts.length > 0) ? parts.join("-") : "root";
		},


		// Simple function to mix in properties from source into target,
		// but only if target does not already have a property of the same name.
		// This is not robust in IE for transferring methods that match
		// Object.prototype names, but the uses of mixin here seem unlikely to
		// trigger a problem related to that.
		mixin: function mixin(target, source, force) {
			var prop;
			for (prop in source) {
				if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {
					target[prop] = source[prop];
				} else if (typeof source[prop] === 'object') {
					if (!target[prop] && source[prop]) {
						target[prop] = {};
					}
					mixin(target[prop], source[prop], force);
				}
			}
		},

		// Parse the resource mid and return a usable object.	
		parseName: function (name) {
			var match = name.match(nlsRegExp);

			// If match[3] is blank, it means this is the top bundle definition,
			// hence suffix is match[2] and locale is null.
			return {
				prefix: match[1],
				masterLocale: "root",
				requestedLocale: match[3] ? match[2] : null,
				suffix: match[3] || match[2]
			};
		},


		getMasterMid: function (name) {
			return name.masterLocale === "root" ? name.prefix + name.suffix :
				name.prefix + name.masterLocale + "/" + name.suffix;
		}
	};
});
;
define('requirejs-dplugins/i18n/parentLocale',{
	"en-ag": "en-001",
	"en-ai": "en-001",
	"en-bb": "en-001",
	"en-bm": "en-001",
	"en-bs": "en-001",
	"en-bw": "en-001",
	"en-bz": "en-001",
	"en-cc": "en-001",
	"en-ck": "en-001",
	"en-cm": "en-001",
	"en-cx": "en-001",
	"en-dm": "en-001",
	"en-er": "en-001",
	"en-fj": "en-001",
	"en-fm": "en-001",
	"en-gb": "en-001",
	"en-gd": "en-001",
	"en-gh": "en-001",
	"en-gm": "en-001",
	"en-gy": "en-001",
	"en-jm": "en-001",
	"en-ke": "en-001",
	"en-ki": "en-001",
	"en-kn": "en-001",
	"en-ky": "en-001",
	"en-lc": "en-001",
	"en-lr": "en-001",
	"en-ls": "en-001",
	"en-mg": "en-001",
	"en-ms": "en-001",
	"en-mu": "en-001",
	"en-mw": "en-001",
	"en-na": "en-001",
	"en-nf": "en-001",
	"en-ng": "en-001",
	"en-nr": "en-001",
	"en-nu": "en-001",
	"en-pg": "en-001",
	"en-ph": "en-001",
	"en-pn": "en-001",
	"en-pw": "en-001",
	"en-rw": "en-001",
	"en-sb": "en-001",
	"en-sc": "en-001",
	"en-sd": "en-001",
	"en-sl": "en-001",
	"en-ss": "en-001",
	"en-sx": "en-001",
	"en-sz": "en-001",
	"en-tc": "en-001",
	"en-tk": "en-001",
	"en-to": "en-001",
	"en-tt": "en-001",
	"en-tv": "en-001",
	"en-tz": "en-001",
	"en-ug": "en-001",
	"en-vc": "en-001",
	"en-vu": "en-001",
	"en-ws": "en-001",
	"en-za": "en-001",
	"en-zm": "en-001",
	"en-zw": "en-001",
	"en-150": "en-gb",
	"en-au": "en-gb",
	"en-be": "en-gb",
	"en-dg": "en-gb",
	"en-fk": "en-gb",
	"en-gg": "en-gb",
	"en-gi": "en-gb",
	"en-hk": "en-gb",
	"en-ie": "en-gb",
	"en-im": "en-gb",
	"en-in": "en-gb",
	"en-io": "en-gb",
	"en-je": "en-gb",
	"en-mo": "en-gb",
	"en-mt": "en-gb",
	"en-nz": "en-gb",
	"en-pk": "en-gb",
	"en-sg": "en-gb",
	"en-sh": "en-gb",
	"en-vg": "en-gb",
	"es-ar": "es-419",
	"es-bo": "es-419",
	"es-cl": "es-419",
	"es-co": "es-419",
	"es-cr": "es-419",
	"es-cu": "es-419",
	"es-do": "es-419",
	"es-ec": "es-419",
	"es-gt": "es-419",
	"es-hn": "es-419",
	"es-mx": "es-419",
	"es-ni": "es-419",
	"es-pa": "es-419",
	"es-pe": "es-419",
	"es-pr": "es-419",
	"es-py": "es-419",
	"es-sv": "es-419",
	"es-us": "es-419",
	"es-uy": "es-419",
	"es-ve": "es-419",
	"pt-ao": "pt-pt",
	"pt-cv": "pt-pt",
	"pt-gw": "pt-pt",
	"pt-mo": "pt-pt",
	"pt-mz": "pt-pt",
	"pt-st": "pt-pt",
	"pt-tl": "pt-pt",
	"az-cyrl": "root",
	"bs-cyrl": "root",
	"en-dsrt": "root",
	"ha-arab": "root",
	"mn-mong": "root",
	"ms-arab": "root",
	"pa-arab": "root",
	"shi-latn": "root",
	"sr-latn": "root",
	"uz-arab": "root",
	"uz-cyrl": "root",
	"vai-latn": "root",
	"zh-hant": "root",
	"zh-hant-mo": "zh-hant-hk"
});
;
define('delite/handlebars!deliteful/list/List/CategoryRenderer.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template>\n\t<div attach-point=\"renderNode\">{{item.category}}</div>\n</template>");
});;
/** @module deliteful/list/CategoryRenderer */
define('deliteful/list/CategoryRenderer',[
	"delite/register",
	"delite/handlebars!./List/CategoryRenderer.html",
	"./Renderer"
], function (register, template, Renderer) {

	/**
	 * Default category renderer for the {@link module:deliteful/list/List deliteful/list/List widget}.
	 * 
	 * @class module:deliteful/list/CategoryRenderer
	 */
	return register("d-list-category-renderer", [HTMLElement, Renderer],
		 /** @lends module:deliteful/list/CategoryRenderer# */ {

		/**
		 * CSS class of a category renderer.
		 * @member {string}
		 * @protected
		 */
		baseClass: "d-list-category",

		template: template,

		//////////// PROTECTED METHODS ///////////////////////////////////////

		refreshRendering: function (oldVals) {
			if ("parentRole" in oldVals) {
				if (this.parentRole === "grid") {
					this.setAttribute("role", "row");
					this.renderNode.setAttribute("role", "columnheader");
				} else {
					this.removeAttribute("role");		// alternately, set role=presentation
					this.renderNode.removeAttribute("tabindex");	// todo: do opposite for when parentRole === grid
					this.renderNode.setAttribute("role", "heading");
				}
			}
		}
	});
});
;
/** @module deliteful/list/Renderer */
define('deliteful/list/Renderer',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/register",
	"delite/Widget"
], function (dcl, $, register, Widget) {

	/**
	 * The base class for a widget that render an item or its category inside a deliteful/list/List widget.
	 * 
	 * This base class provide all the infrastructure that a deliteful/list/List widget
	 * expect from a renderer, including keyboard navigation support.
	 * 
	 * Focusability and Keyboard navigation order for a renderer instance is defined using
	 * the navindex attribute on the rendered nodes:
	 * - no navindex attribute value means that the node is not focusable
	 * - a navindex attribute means that the node is focusable. When navigating
	 *  the renderer instance using arrow keys, the traversal order is the following:
	 *  - the nodes with the lowest navindex value comes first
	 *  - if two nodes have the same navindex value, the one that is before the other one in the DOM
	 *  comes first.
	 * @class module:deliteful/list/Renderer
	 * @augments module:delite/Widget
	 */
	return dcl([Widget], /** @lends module:deliteful/list/Renderer# */ {
		/**
		 * The list item to render.
		 * @member {Object}
		 * @default {}
		 */
		item: {}, // must be initialized to an empty object because it is expected by the template

		/**
		 * Contains all the renderer nodes that can be focused, in the same order
		 * that they are to be focused during keyboard navigation with the left and right arrow
		 * keys.
		 * @member {Node[]}
		 * @private
		 */
		_focusableChildren: null,

		/**
		 * The ARIA role of the parent.  Renderer role will be adjusted based on its parent's role.
		 */
		parentRole: "",

		//////////// PROTECTED METHODS ///////////////////////////////////////

		render: dcl.after(function () {
			if (!this.renderNode) {
				throw new Error("render must define a renderNode property on the Renderer."
						+ " Example using attach-point in a template: "
						+ "<template><div attach-point='renderNode'></div></template>");
			}
			this.renderNode.tabIndex = -1;
			$(this.renderNode).addClass("d-list-cell");
			this.updateFocusableChildren();
		}),

		// Interface from List to Renderer to navigate fields

		/**
		 * Retrieves the first focusable child.
		 * @returns {Element}
		 * @protected
		 */
		getFirst: function () {
			if (this._focusableChildren && this._focusableChildren.length) {
				return this._focusableChildren[0];
			} else {
				return null;
			}
		},

		/**
		 * Retrieves the last focusable child.
		 * @returns {Element}
		 * @protected
		 */
		getLast: function () {
			if (this._focusableChildren && this._focusableChildren.length) {
				return this._focusableChildren[this._focusableChildren.length - 1];
			} else {
				return null;
			}
		},

		/**
		 * Retrieves the next focusable child after another child.
		 * @param {Element} child the child from which to retrieve the next focusable child
		 * @returns {Element}
		 * @protected
		 */
		getNext: function (child) {
			return this.getNextFocusableChild(child, 1);
		},

		/**
		 * Retrieves the previous focusable child before another child.
		 * @param {Element} child the child from which to retrieve the previous focusable child
		 * @returns {Element}
		 * @protected
		 */
		getPrev: function (child) {
			return this.getNextFocusableChild(child, -1);
		},

		/**
		 * This method updates the list of children of the renderer that can
		 * be focused during keyboard navigation.
		 * If the list of navigable children of the renderer is updated after the
		 * render step has been executed, this method must be
		 * called to take into account the new list.
		 * If the list of navigable children is defined during the render
		 * step, there is no need to call this method.
		 */
		updateFocusableChildren: function () {
			if (this._focusableChildren) {
				for (var i = 0; i < this._focusableChildren.length; i++) {
					delete this._focusableChildren[i].tabIndex;
				}
			}
			// parse the renderNode content to retrieve the ordered list of focusable children
			var nodes = Array.prototype.slice.call(this.renderNode.querySelectorAll("[navindex]"), 0);
			this._focusableChildren = nodes.slice(0).sort(function (a, b) {
				var navindexA = parseInt(a.getAttribute("navindex"), 10);
				var navindexB = parseInt(b.getAttribute("navindex"), 10);
				if (navindexA === navindexB) {
					return nodes.indexOf(a) - nodes.indexOf(b);
				} else {
					return navindexA - navindexB;
					
				}
			});
			// update the focusable children nodes
			for (i = 0; i < this._focusableChildren.length; i++) {
				var node = this._focusableChildren[i];
				node.tabIndex = -1;
			}
		},

		/**
		 * Get the next renderer child that can be focused using arrow keys.
		 * @param {Element} fromChild The child from which the next focusable child is requested
		 * @param {number} dir The direction, from fromChild, of the next child: 1 for the child that
		 * comes after in the focusable order, -1 for the child that comes before.
		 * @returns {Element} The next focusable child if there is one.
		 * @protected
		 */
		getNextFocusableChild: function (fromChild, dir) {
			if (this._focusableChildren && fromChild !== this) {
				// retrieve the position of the from node
				var fromChildIndex = fromChild ? this._focusableChildren.indexOf(fromChild) : -1;
				var nextChildIndex = fromChildIndex + dir;
				if (nextChildIndex >= 0 && nextChildIndex < this._focusableChildren.length) {
					return this._focusableChildren[nextChildIndex]; // Widget
				} else {
					return null;
				}
			}
		}

	});

});
;
define('delite/handlebars!deliteful/list/List/ItemRenderer.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template>\n\t<div attach-point=\"renderNode\">\n\t\t<div class=\"d-list-item-icon {{item.iconclass}}\" aria-hidden=\"true\" role=\"presentation\"></div>\n\t\t<div class=\"d-list-item-label\">{{item.label}}</div>\n\t\t<div class=\"d-spacer\"></div>\n\t\t<div class=\"d-list-item-right-text\">{{item.righttext}}</div>\n\t\t<div class=\"d-list-item-right-icon {{item.righticonclass}}\" aria-hidden=\"true\" role=\"presentation\"></div>\n\t</div>\n</template>");
});;
/** @module deliteful/list/ItemRenderer */
define('deliteful/list/ItemRenderer',[
	"delite/register",
	"./Renderer",
	"delite/handlebars!./List/ItemRenderer.html"
], function (register, Renderer, template) {

	/**
	 * Default item renderer for the {@link module:deliteful/list/List deliteful/list/List widget}.
	 *
	 * This renderer renders generic items that can have any of the following attributes (display
	 * position of the rendering described for LTR direction):
	 * - `iconclass`: css class to apply to a DIV element on the left side of the list item in order
	 * to display an icon.
	 * Rendered with CSS class `d-list-item-icon` + the value of the attribute;
	 * - `label`: string to render on the left side of the node, after the icon.
	 * Rendered with CSS class `d-list-item-label`;
	 * - `righttext`: string to render of the right side if the node.
	 * Rendered with CSS class `d-list-item-right-text`;
	 * - `righticonclass`: css class to apply to a DIV element on the right side of the list item
	 * in order to display an icon.
	 * Rendered with CSS class `d-list-item-right-icon2` + the value of the attribute;
	 * By default, none of the nodes that renders the attributes are focusable with keyboard navigation
	 * (no navindex attribute on the nodes).
	 *
	 * @class module:deliteful/list/ItemRenderer
	 * @augments module:deliteful/list/Renderer
	 */

	return register("d-list-item-renderer", [HTMLElement, Renderer], /** @lends module:deliteful/list/ItemRenderer# */ {
		/**
		 * CSS class of an item renderer.
		 * @member {string}
		 * @protected
		 */
		baseClass: "d-list-item",

		template: template,

		//////////// PROTECTED METHODS ///////////////////////////////////////

		refreshRendering: function (oldVals) {
			if ("parentRole" in oldVals) {
				if (this.parentRole === "grid") {
					this.setAttribute("role", "row");
					this.renderNode.setAttribute("role", "gridcell");
				} else {
					this.removeAttribute("role");		// alternately, set role=presentation
					this.renderNode.setAttribute("role", {
						listbox: "option",
						menu: "menuitem",	// there's also menuitemcheckbox and menuitemradio
						list: "listitem"
					}[this.parentRole]);
				}
			}
		}
	});
});
;
/** @module delite/Scrollable */
define('delite/Scrollable',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes,effects",	// toggleClass()
	"./Widget",
	"./theme!./Scrollable/themes/{{theme}}/Scrollable.css"
], function (dcl, $, Widget) {

	/**
	 * A mixin which adds scrolling capabilities to a widget.
	 *
	 * When mixed into a host widget, this mixin brings scrolling capabilities
	 * based on the overflow: auto CSS property.
	 *
	 * By default, the scrolling capabilities are added to the widget
	 * node itself. The host widget can chose the node thanks to the property
	 * `scrollableNode` which must be set at latest in its `render()`
	 * method.
	 *
	 * During interactive or programmatic scrolling, native "scroll"
	 * events are emitted, and can be listened to as follows (here,
	 * `scrollWidget` is the widget into which this mixin is mixed):
	 *
	 * ```js
	 * scrollWidget.on("scroll", function (event) {
	 *   ...
	 * });
	 * ```
	 *
	 * For widgets that customize the `scrollableNode` property,
	 * the events should be listened to on `widget.scrollableNode`:
	 *
	 * ```js
	 * scrollWidget.on("scroll", function (event) {
	 *   ...
	 *   }, scrollWidget.scrollableNode);
	 * ```
	 *
	 * @mixin module:delite/Scrollable
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** @lends module:delite/Scrollable# */{

		/**
		 * The direction of the interactive scroll. Possible values are:
		 * "vertical", "horizontal", "both, and "none".
		 *
		 * Note that scrolling programmatically using `scrollTo()` is
		 * possible on both horizontal and vertical directions independently
		 * on the value of `scrollDirection`.
		 * @member {string}
		 * @default "vertical"
		 */
		scrollDirection: "vertical",

		/**
		 * Designates the descendant node of this widget which is made scrollable.
		 *
		 * If not set otherwise before the `render()`
		 * method of the mixin is executed, it is set by default to this widget
		 * itself (`this`).
		 *
		 * Note that this property can be set only at construction time, at latest
		 * in the `render()` method of the host widget into which this class is mixed.
		 * It should not be changed afterwards.
		 * Typically, this property can be set by a host widget which needs scrolling
		 * capabilities on one its descendant nodes.
		 *
		 * @member {Element}
		 * @default null
		 */
		scrollableNode: null,

		render: dcl.after(function () {
			// Do it using after advice to give a chance to a custom widget to
			// set the scrollableNode at latest in an overridden render().
			if (!this.scrollableNode) {
				this.scrollableNode = this; // If unspecified, defaults to 'this'.
			}
		}),

		refreshRendering: function (oldVals) {
			if ("scrollDirection" in oldVals) {
				$(this.scrollableNode)
					.toggleClass("d-scrollable", this.scrollDirection !== "none")
					.toggleClass("d-scrollable-h", /^(both|horizontal)$/.test(this.scrollDirection))
					.toggleClass("d-scrollable-v", /^(both|vertical)$/.test(this.scrollDirection));
			}
		},

		detachedCallback: function () {
			this._stopAnimation();
		},

		/**
		 * Returns true if container's scroll has reached the maximum limit at
		 * the top of the contents. Returns false otherwise.
		 * @example
		 * var scrollableNode = scrollableWidget.scrollableNode;
		 * scrollableNode.on("scroll", function () {
		 *   if (scrollableWidget.isTopScroll()) {
		 *     console.log("Scroll reached the maximum limit at the top");
		 *   }
		 * }
		 * @returns {boolean}
		 */
		isTopScroll: function () {
			return this.scrollableNode.scrollTop === 0;
		},

		/**
		 * Returns true if container's scroll has reached the maximum limit at
		 * the bottom of the contents. Returns false otherwise.
		 * @example
		 * var scrollableNode = scrollableWidget.scrollableNode;
		 * scrollableNode.on("scroll", function () {
		 *   if (scrollableWidget.isBottomScroll()) {
		 *     console.log("Scroll reached the maximum limit at the bottom");
		 *   }
		 * }
		 * @returns {boolean}
		 */
		isBottomScroll: function () {
			var scrollableNode = this.scrollableNode;
			return scrollableNode.offsetHeight + scrollableNode.scrollTop >=
				scrollableNode.scrollHeight;
		},

		/**
		 * Returns true if container's scroll has reached the maximum limit at
		 * the left of the contents. Returns false otherwise.
		 * @example
		 * var scrollableNode = scrollableWidget.scrollableNode;
		 * scrollableNode.on("scroll", function () {
		 *   if (scrollableWidget.isLeftScroll()) {
		 *     console.log("Scroll reached the maximum limit at the left");
		 *   }
		 * }
		 * @returns {boolean}
		 */
		isLeftScroll: function () {
			return this.scrollableNode.scrollLeft === 0;
		},

		/**
		 * Returns true if container's scroll has reached the maximum limit at
		 * the right of the contents. Returns false otherwise.
		 * @example
		 * var scrollableNode = scrollableWidget.scrollableNode;
		 * scrollableNode.on("scroll", function () {
		 *   if (scrollableWidget.isRightScroll()) {
		 *     console.log("Scroll reached the maximum limit at the right");
		 *   }
		 * }
		 * @returns {boolean}
		 */
		isRightScroll: function () {
			var scrollableNode = this.scrollableNode;
			return scrollableNode.offsetWidth + scrollableNode.scrollLeft >= scrollableNode.scrollWidth;
		},

		/**
		 * Returns the current amount of scroll, as an object with x and y properties
		 * for the horizontal and vertical scroll amount.
		 * This is a convenience method and it is not supposed to be overridden.
		 * @returns {Object}
		 */
		getCurrentScroll: function () {
			return {x: this.scrollableNode.scrollLeft, y: this.scrollableNode.scrollTop};
		},

		/**
		 * Scrolls by the given amount.
		 * @param {Object} by - The scroll amount. An object with x and/or y properties, for example
		 * `{x: 0, y: -5}` or `{y: -29}`.
		 * @param {number} duration - Duration of scrolling animation in milliseconds.
		 * If 0 or unspecified, scrolls without animation.
		 */
		scrollBy: function (by, duration) {
			var to = {};
			if (by.x !== undefined) {
				to.x = this.scrollableNode.scrollLeft + by.x;
			}
			if (by.y !== undefined) {
				to.y = this.scrollableNode.scrollTop + by.y;
			}
			this.scrollTo(to, duration);
		},

		/**
		 * Scrolls to the given position.
		 * @param {Object} to - The scroll destination position. An object with w and/or y properties,
		 * for example `{x: 0, y: -5}` or `{y: -29}`.
		 * @param {number} [duration] - Duration of scrolling animation in milliseconds.
		 * If 0 or unspecified, scrolls without animation.
		 */
		scrollTo: function (to, duration) {
			var scrollableNode = this.scrollableNode;
			this._stopAnimation();
			if (!duration || duration <= 0) { // shortcut
				if (to.x !== undefined) {
					scrollableNode.scrollLeft = to.x;
				}
				if (to.y !== undefined) {
					scrollableNode.scrollTop = to.y;
				}
			} else {
				var from = {
					x: to.x !== undefined ? scrollableNode.scrollLeft : undefined,
					y: to.y !== undefined ? scrollableNode.scrollTop : undefined
				};
				// See http://james.padolsey.com/javascript/fun-with-jquerys-animate/
				var self = this;
				self._animation = $(from).animate(to, {
					duration: duration,
					rate: 20, // TODO: IMPROVEME
					step: function () {
						if (this.x !== undefined) {
							scrollableNode.scrollLeft = this.x;
						}
						if (this.y !== undefined) {
							scrollableNode.scrollTop = this.y;
						}
					},
					complete: function () {
						if (this.x !== undefined) {
							scrollableNode.scrollLeft = this.x;
						}
						if (this.y !== undefined) {
							scrollableNode.scrollTop = this.y;
						}
						delete self._animation;
					}
				});
			}
		},

		/**
		 * Stops the scrolling animation if it is currently playing.
		 * Does nothing otherwise.
		 */
		_stopAnimation: function () {
			if (this._animation) {
				this._animation.stop();
			}
		}
	});
});
;
define( 'jquery/src/effects',[
	"./core",
	"./var/document",
	"./var/rcssNum",
	"./var/rnothtmlwhite",
	"./css/var/cssExpand",
	"./css/var/isHiddenWithinTree",
	"./css/var/swap",
	"./css/adjustCSS",
	"./data/var/dataPriv",
	"./css/showHide",

	"./core/init",
	"./queue",
	"./deferred",
	"./traversing",
	"./manipulation",
	"./css",
	"./effects/Tween"
], function( jQuery, document, rcssNum, rnothtmlwhite, cssExpand, isHiddenWithinTree, swap,
	adjustCSS, dataPriv, showHide ) {

"use strict";

var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	var i = jQuery.timers.push( timer ) - 1,
		timers = jQuery.timers;

	if ( timer() ) {
		jQuery.fx.start();

	// If the timer finished immediately, safely remove it (allowing for external removal)
	// Use a superfluous post-decrement for better compressibility w.r.t. jQuery.fx.tick above
	} else if ( timers[ i ] === timer ) {
		timers.splice( i--, 1 );
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};

return jQuery;
} );
;
define( 'jquery/src/effects/Tween',[
	"../core",
	"../css"
], function( jQuery ) {

"use strict";

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};

} );
;
define( 'jquery/src/css',[
	"./core",
	"./var/pnum",
	"./core/access",
	"./css/var/rmargin",
	"./var/document",
	"./var/rcssNum",
	"./css/var/rnumnonpx",
	"./css/var/cssExpand",
	"./css/var/getStyles",
	"./css/var/swap",
	"./css/curCSS",
	"./css/adjustCSS",
	"./css/addGetHookIf",
	"./css/support",

	"./core/init",
	"./core/ready",
	"./selector" // contains
], function( jQuery, pnum, access, rmargin, document, rcssNum, rnumnonpx, cssExpand,
	getStyles, swap, curCSS, adjustCSS, addGetHookIf, support ) {

"use strict";

var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );

return jQuery;
} );
;
define( 'jquery/src/core/ready',[
	"../core",
	"../var/document",
	"../core/readyException",
	"../deferred"
], function( jQuery, document ) {

"use strict";

// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}

} );
;
define( 'jquery/src/core/readyException',[
	"../core"
], function( jQuery ) {

"use strict";

jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};

} );
;
define( 'jquery/src/css/support',[
	"../core",
	"../var/document",
	"../var/documentElement",
	"../var/support"
], function( jQuery, document, documentElement, support ) {

"use strict";

( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();

return support;

} );
;
define( 'jquery/src/var/documentElement',[
	"./document"
], function( document ) {
	"use strict";

	return document.documentElement;
} );
;
define( 'jquery/src/css/addGetHookIf',[],function() {

"use strict";

function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}

return addGetHookIf;

} );
;
define( 'jquery/src/css/curCSS',[
	"../core",
	"./var/rnumnonpx",
	"./var/rmargin",
	"./var/getStyles",
	"./support",
	"../selector" // Get jQuery.contains
], function( jQuery, rnumnonpx, rmargin, getStyles, support ) {

"use strict";

function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}

return curCSS;
} );
;
define( 'jquery/src/css/var/getStyles',[],function() {
	"use strict";

	return function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};
} );
;
define( 'jquery/src/css/var/rnumnonpx',[
	"../../var/pnum"
], function( pnum ) {
	"use strict";

	return new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
} );
;
define( 'jquery/src/css/var/rmargin',[],function() {
	"use strict";

	return ( /^margin/ );
} );
;
define( 'jquery/src/core/access',[
	"../core"
], function( jQuery ) {

"use strict";

// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};

return access;

} );
;
define( 'jquery/src/var/pnum',[],function() {
	"use strict";

	return ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
} );
;
define( 'jquery/src/manipulation',[
	"./core",
	"./var/concat",
	"./var/push",
	"./var/rcheckableType",
	"./core/access",
	"./manipulation/var/rtagName",
	"./manipulation/var/rscriptType",
	"./manipulation/wrapMap",
	"./manipulation/getAll",
	"./manipulation/setGlobalEval",
	"./manipulation/buildFragment",
	"./manipulation/support",

	"./data/var/dataPriv",
	"./data/var/dataUser",
	"./data/var/acceptData",
	"./core/DOMEval",

	"./core/init",
	"./traversing",
	"./selector",
	"./event"
], function( jQuery, concat, push, rcheckableType,
	access, rtagName, rscriptType,
	wrapMap, getAll, setGlobalEval, buildFragment, support,
	dataPriv, dataUser, acceptData, DOMEval ) {

"use strict";

var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );

return jQuery;
} );
;
define( 'jquery/src/event',[
	"./core",
	"./var/document",
	"./var/documentElement",
	"./var/rnothtmlwhite",
	"./var/rcheckableType",
	"./var/slice",
	"./data/var/dataPriv",
	"./core/init",
	"./selector"
], function( jQuery, document, documentElement, rnothtmlwhite, rcheckableType, slice, dataPriv ) {

"use strict";

var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkable types, fire native event so checked state will be right
			trigger: function() {
				if ( rcheckableType.test( this.type ) &&
					this.click && jQuery.nodeName( this, "input" ) ) {

					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );

return jQuery;
} );
;
define( 'jquery/src/data/var/dataUser',[
	"../Data"
], function( Data ) {
	"use strict";

	return new Data();
} );
;
define( 'jquery/src/manipulation/support',[
	"../var/document",
	"../var/support"
], function( document, support ) {

"use strict";

( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();

return support;

} );
;
define( 'jquery/src/manipulation/buildFragment',[
	"../core",
	"./var/rtagName",
	"./var/rscriptType",
	"./wrapMap",
	"./getAll",
	"./setGlobalEval"
], function( jQuery, rtagName, rscriptType, wrapMap, getAll, setGlobalEval ) {

"use strict";

var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}

return buildFragment;
} );
;
define( 'jquery/src/manipulation/setGlobalEval',[
	"../data/var/dataPriv"
], function( dataPriv ) {

"use strict";

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}

return setGlobalEval;
} );
;
define( 'jquery/src/manipulation/getAll',[
	"../core"
], function( jQuery ) {

"use strict";

function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}

return getAll;
} );
;
define( 'jquery/src/manipulation/wrapMap',[],function() {

"use strict";

// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

return wrapMap;
} );
;
define( 'jquery/src/manipulation/var/rscriptType',[],function() {
	"use strict";

	return ( /^$|\/(?:java|ecma)script/i );
} );
;
define( 'jquery/src/manipulation/var/rtagName',[],function() {
	"use strict";

	return ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
} );
;
define( 'jquery/src/var/rcheckableType',[],function() {
	"use strict";

	return ( /^(?:checkbox|radio)$/i );
} );
;
define( 'jquery/src/traversing',[
	"./core",
	"./var/indexOf",
	"./traversing/var/dir",
	"./traversing/var/siblings",
	"./traversing/var/rneedsContext",
	"./core/init",
	"./traversing/findFilter",
	"./selector"
], function( jQuery, indexOf, dir, siblings, rneedsContext ) {

"use strict";

var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( jQuery.nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( jQuery.nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );

return jQuery;
} );
;
define( 'jquery/src/traversing/var/siblings',[],function() {

"use strict";

return function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};

} );
;
define( 'jquery/src/traversing/var/dir',[
	"../../core"
], function( jQuery ) {

"use strict";

return function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};

} );
;
define( 'jquery/src/deferred',[
	"./core",
	"./var/slice",
	"./callbacks"
], function( jQuery, slice ) {

"use strict";

function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );

return jQuery;
} );
;
define( 'jquery/src/callbacks',[
	"./core",
	"./var/rnothtmlwhite"
], function( jQuery, rnothtmlwhite ) {

"use strict";

// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};

return jQuery;
} );
;
define( 'jquery/src/queue',[
	"./core",
	"./data/var/dataPriv",
	"./deferred",
	"./callbacks"
], function( jQuery, dataPriv ) {

"use strict";

jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );

return jQuery;
} );
;
define( 'jquery/src/css/showHide',[
	"../core",
	"../data/var/dataPriv",
	"../css/var/isHiddenWithinTree"
], function( jQuery, dataPriv, isHiddenWithinTree ) {

"use strict";

var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );

return showHide;
} );
;
define( 'jquery/src/css/adjustCSS',[
	"../core",
	"../var/rcssNum"
], function( jQuery, rcssNum ) {

"use strict";

function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}

return adjustCSS;
} );
;
define( 'jquery/src/css/var/swap',[],function() {

"use strict";

// A method for quickly swapping in/out CSS properties to get correct calculations.
return function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};

} );
;
define( 'jquery/src/css/var/isHiddenWithinTree',[
	"../../core",
	"../../selector"

	// css is assumed
], function( jQuery ) {
	"use strict";

	// isHiddenWithinTree reports if an element has a non-"none" display style (inline and/or
	// through the CSS cascade), which is useful in deciding whether or not to make it visible.
	// It differs from the :hidden selector (jQuery.expr.pseudos.hidden) in two important ways:
	// * A hidden ancestor does not force an element to be classified as hidden.
	// * Being disconnected from the document does not force an element to be classified as hidden.
	// These differences improve the behavior of .toggle() et al. when applied to elements that are
	// detached or contained within hidden ancestors (gh-2404, gh-2863).
	return function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};
} );
;
define( 'jquery/src/css/var/cssExpand',[],function() {
	"use strict";

	return [ "Top", "Right", "Bottom", "Left" ];
} );
;
define( 'jquery/src/var/rcssNum',[
	"../var/pnum"
], function( pnum ) {

"use strict";

return new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );

} );
;
/** @module delite/StoreMap */
define('delite/StoreMap',["dcl/dcl", "./Store"], function (dcl, Store) {

	var getvalue = function (map, item, key, store) {
		if (map[key + "Func"]) {
			return map[key + "Func"](item, store);
		} else if (map[key + "Attr"]) {
			return item[map[key + "Attr"]];
		} else {
			return item[key];
		}
	};

	var setvalue = function (map, item, key, store, value) {
		if (map[key + "Func"]) {
			map[key + "Func"](item, store, value);
		} else if (map[key + "Attr"]) {
			item[map[key + "Attr"]] = value;
		} else {
			item[key] = value;
		}
	};

	var propregexp = /^(?!_)(\w)+(?=Attr$|Func$)/;

	var capitalize = /f(?=unc$)|a(?=ttr$)/;


	/**
	 * Mixin providing store binding management for widgets that extend delite/Store. Classes extending
	 * this mixin can easily define how store items properties are mapped in the render items properties
	 * consumable by the widget. The mapping can either occur by property (property A in store item
	 * corresponds to property B in render item) or by function (a function is specified that mapped the
	 * store item into the value of a property of the render item)..
	 *
	 * For each mapped property "foo" from the render item one can provide:
	 *
	 * - fooAttr property in which case the mapping is looking into the store item property specified
	 *   by fooAttr
	 * - fooFunc property function in which case the mapping is delegating the mapping operation to the
	 *   fooFunc function.
	 * - fooFunc is of the following signature (value must be passed only for set operations:
	 *   fooFunc(item, store, value)
	 * - if none of this is provided the mapping is looking into store item "foo" property
	 *
	 * Mapping properties are meant to be added to the widget class using the mixin. One can directly add the
	 * mapping properties to an instance but in this case there are two limitations:
	 *
	 * - The property must be added before the widget is started
	 * - If the property is added in the markup only fully lower case properties are supported
	 *   (e.g. foobar not fooBar)
	 *
	 * @mixin module:delite/StoreMap
	 * @augments module:delite/Store
	 */
	return dcl(Store, /** @lends module:delite/StoreMap# */{
		/**
		 * Whether the created render items will be updated when call the remap() function on the component
		 * allowing the consuming component to re-perform the mapping on demand. This property must not be
		 * changed after the initialization cycle.
		 * @member {boolean}
		 * @default false
		 */
		allowRemap: false,

		/**
		 * Array of item keys to be considered for mapping. The component will be introspected to find
		 * all the properties ending with "Attr" or "Func" and provide mapping for those.
		 * @member {Object}
		 * @default null
		 * @private
		 */
		_mappedKeys: null,

		/**
		 * If true, in addition to the mapped properties copy all the other properties of the store item into
		 * the render item with direct mapping. This property must not be changed after the initialization cycle.
		 * @member {boolean}
		 * @default false
		 */
		copyAllItemProps: false,

		// Called for each attribute specified declaratively.  Overrides CustomElement#parseAttribute().
		// Convert all attributes like foofunc="..." or fooattr="..." to instance properties.
		// foofunc="return item.value" converted to property named fooFunc w/value
		// function(item, store, value){ return item.value; }
		parseAttribute: dcl.superCall(function (sup) {
			return function (name, value) {
				if (/Attr$|Func$/i.test(name)) {
					name = name.toLowerCase();	// needed only on IE9
					name = this._propCaseMap[name] ||
							name.replace(capitalize, capitalize.exec(name)[0].toUpperCase());
					return {
						prop: name,
						value: /Attr$/.test(name) ? value :
							this.parseFunctionAttribute(value, ["item", "store", "value"])
					};
				} else {
					return sup.apply(this, arguments);
				}
			};
		}),

		queryStoreAndInitItems: dcl.superCall(function (sup) {
			return function (processQueryResult, force) {
				if (this.attached || force) {
					sup.apply(this, arguments);
				} else {
					// we just keep the last processQueryResult we were called with as we are before attachment
					// and so only the last one should anyway have actual visual effect
					this._pendingQuery = processQueryResult;
				}
			};
		}),

		attachedCallback: function () {
			// This runs after the attributes have been processed (and converted into properties),
			// and after any properties specified to the constructor have been mixed in.

			// look into properties of the instance for keys to map
			var mappedKeys = [];
			for (var prop in this) {
				var match = propregexp.exec(prop);
				if (match && mappedKeys.indexOf(match[0]) === -1) {
					mappedKeys.push(match[0]);
				}
			}

			// which are the considered keys in the store item itself
			if (this.copyAllItemProps) {
				this._itemKeys = [];
				for (var i = 0; i < mappedKeys.length; i++) {
					this._itemKeys.push(this[mappedKeys[i] + "Attr"] ?
						this[mappedKeys[i] + "Attr"] : mappedKeys[i]);
				}
			}

			this._mappedKeys = mappedKeys;
			this.deliver();
			
			if (this._pendingQuery) {
				this.queryStoreAndInitItems(this._pendingQuery, true);
				this._pendingQuery = null;
			}
		},

		/**
		 * Creates a store item based from the widget internal item based on the various mapped properties. Works 
		 * asynchronously.
		 * @param {Object} renderItem - The render item.
		 * @returns {Promise}		
		 */
		renderItemToItem: function (renderItem) {
			var tmp = {}, store = this._storeAdapter;
			// special id case
			store.setIdentity(tmp, renderItem.id);
			for (var key in renderItem) {
				setvalue(this, tmp, key, store, renderItem[key]);
			}
			return store.get(tmp.id).then(function (item) {
				dcl.mix(item, tmp);
				return item;
			});
		},

		/**
		 * Returns the widget internal item for a given store item based on the various mapped properties.
		 * @param {Object} item - The store item.
		 * @returns {Object}
		 * @protected
		 */
		itemToRenderItem: function (item) {
			var renderItem = {};
			var mappedKeys = this._mappedKeys;
			var store = this._storeAdapter;

			// if we allow remap we need to store the initial item
			// we need this to be enumerable for dealing with update case (where only enumerable
			// properties are copied)
			// we might need it in other context as well
			renderItem.__item = item;
			// special id case
			var id = this.getIdentity(item);
			// Warning: we are using private API from dstore/Store here so let's do that conditionally
			// the purpose is to workaround the fact in some cases the store might miss the ID and we don't
			// want to bother people about that.
			if (id == null && store.setIdentity) {
				store.setIdentity(item, Math.random());
			}
			renderItem.id = this.getIdentity(item);
			// general mapping case
			for (var i = 0; i < mappedKeys.length; i++) {
				renderItem[mappedKeys[i]] = getvalue(this, item, mappedKeys[i], store);
			}
			if (this.copyAllItemProps) {
				for (var key in item) {
					if (this._itemKeys.indexOf(key) === -1 && item.hasOwnProperty(key)) {
						renderItem[key] = item[key];
					}
				}
			}

			return renderItem;
		},

		/**
		 * If allowRemap is true, the method allows to perform again the mapping between the data item
		 * and the render items. This might be useful is mapping by function is used and the execution
		 * context of the mapping function as changed so that the results would need to be updated.
		 * It should not be called if allowRemap is false.
		 */
		remap: function () {
			var items = this.renderItems;
			var mappedKeys = this._mappedKeys;
			for (var i = 0; i < items.length; i++) {
				for (var j = 0; j < mappedKeys.length; j++) {
					items[i][mappedKeys[j]] = getvalue(this, items[i].__item, mappedKeys[j], this.source);
				}
			}
		}
	});
});
;
/** @module delite/Store */
define('delite/Store',[
	"dcl/dcl",
	"requirejs-dplugins/has",
	"decor/Invalidating",
	"requirejs-dplugins/Promise!",
	"decor/ObservableArray",
	"decor/Observable",
	"./ArrayToStoreAdapter",
	"./DstoreToStoreAdapter"
], function (dcl, has, Invalidating, Promise, ObservableArray, Observable, ArrayToStoreAdapter, DstoreToStoreAdapter) {

	/**
	 * Dispatched once the query has been executed and the `renderItems` array
	 * has been initialized with the list of initial render items.
	 * @example
	 * widget.on("query-success", function (evt) {
	 *      console.log("query done, initial renderItems: " + evt.renderItems);
	 * });
	 * @event module:delite/Store#query-success
	 * @property {Object[]} renderItems - The array of initial render items.
	 * @property {boolean} cancelable - Indicates whether the event is cancelable or not.
	 * @property {boolean} bubbles - Indicates whether the given event bubbles up through the DOM or not.
	 */
	
	/**
	 * Mixin for store management that creates render items from store items after
	 * querying the store. The receiving class must extend decor/Evented or delite/Widget.
	 *
	 * Classes extending this mixin automatically create render items that are consumable
	 * from store items after querying the store. This happens each time the `store`, `query` or
	 * `queryOptions` properties are set. If that store is Trackable it will be observed and render items
	 * will be automatically updated, added or deleted based on store notifications.
	 *
	 * @mixin module:delite/Store
	 */
	return dcl(Invalidating, /** @lends module:delite/Store# */ {
		/**
		 * The source that contains the items to display.
		 * @member {(dstore/Store|decor/ObservableArray|Array)}
		 * @default null
		 */
		source: null,

		/**
		 * A query filter to apply to the store.
		 * @member {Object}
		 * @default {}
		 */
		query: {},

		/**
		 * A function that processes the collection or the array returned by the source query and returns a new
		 * collection or a new array (to sort it, etc...). This processing is applied before potentially tracking
		 * the source for modifications (if Trackable or Observable).
		 * Be careful you can not use the same function for both arrays and collections.
		 * Changing this function on the instance will not automatically refresh the class.
		 * @default identity function
		 */
		processQueryResult: function (source) { return source; },

		/**
		 * The render items corresponding to the store items for this widget. This is filled from the store and
		 * is not supposed to be modified directly. Initially null. 
		 * @member {Object[]}
		 * @default null
		 */
		renderItems: null,

		/**
		 * Creates a store item based from the widget internal item.
		 * @param {Object} renderItem - The render item.
		 * @returns {Object}
		 */
		renderItemToItem: function (renderItem) {
			return renderItem;
		},

		/**
		 * Returns the widget internal item for a given store item. By default it returns the store
		 * item itself.
		 * @param {Object} item - The store item.
		 * @returns {Object}
		 * @protected
		 */
		itemToRenderItem: function (item) {
			return item;
		},

		createdCallback: function () {
			// Get the data from the textContent
			if (this.textContent.trim()) {
				var data = JSON.parse("[" + this.textContent + "]");
				if (data.length) {
					this.source = new ObservableArray();
					for (var j = 0; j < data.length; j++) {
						if (!data[j].id) {
							data[j].id = Math.random();
						}
						this.source[j] = new Observable(data[j]);
					}
				}
				this.textContent = "";
			}
		},

		/**
		 * This method is called once the query has been executed to initialize the renderItems array
		 * with the list of initial render items.
		 *
		 * This method sets the renderItems property to the render items array passed as parameter. Once
		 * done, it fires a 'query-success' event.
		 * @param {Object[]} renderItems - The array of initial render items to be set in the renderItems property.
		 * @returns {Object[]} the renderItems array.
		 * @protected
		 * @fires module:delite/Store#query-success
		 */
		initItems: function (renderItems) {
			this.renderItems = renderItems;
			this.emit("query-success", { renderItems: renderItems, cancelable: false, bubbles: true });
			return renderItems;
		},

		computeProperties: dcl.after(function (args) {
			// Runs after the subclass computeProperties() methods run and possibly set this.query and this.source.
			// If this call is upon widget creation but `this.source` is not available, don't bother querying store.
			// If the store parameters are invalidated, queries the store, creates the render items
			// and calls initItems() when ready.  If an error occurs a 'query-error' event will be fired.
			// If this call is upon widget creation but `this.store` is not available, don't bother querying store.

			var props = args[0], isAfterCreation = args[1];
			if (("source" in props || "query" in props) && (this.source || !isAfterCreation)) {
				this.queryStoreAndInitItems(this.processQueryResult);
			}
		}),

		/**
		 * Queries the store, creates the render items and calls initItems() when ready. If an error occurs
		 * a 'query-error' event will be fired.
		 *
		 * This method is not supposed to be called by application developer.
		 * It will be called automatically when modifying the store related properties or by the subclass
		 * if needed.
		 * @param processQueryResult - A function that processes the collection returned by the store query
		 * and returns a new collection (to sort it, etc...)., applied before tracking.
		 * @returns {Promise} If store to be processed is not null a promise that will be resolved when the loading
		 * process will be finished.
		 * @protected
		 */
		queryStoreAndInitItems: function (processQueryResult) {
			this._untrack();
			if (this.source != null) {
				if (!Array.isArray(this.source)) {
					this._storeAdapter = new DstoreToStoreAdapter({source: this.source, query: this.query,
						processQueryResult: processQueryResult});
				} else {
					this._storeAdapter = new ArrayToStoreAdapter({source: this.source, query: this.query,
						processQueryResult: processQueryResult});
				}
				var collection = this._storeAdapter;
				if (collection.track) {
					this._addListener = collection.on("add", this._itemAdded.bind(this));
					this._deleteListener = collection.on("delete", this._itemRemoved.bind(this));
					this._updateListener = collection.on("update", this._itemUpdated.bind(this));
					this._newQueryListener = collection.on("_new-query-asked", function (evt) {
						this.emit("new-query-asked", evt);
					}.bind(this));
				}
				return this.processCollection(collection);
			} else {
				this.initItems([]);
			}
		},

		/**
		 * Synchronously deliver change records to all listeners registered via `observe()`.
		 */
		deliver: dcl.superCall(function (sup) {
			return function () {
				sup.call();
				if (this._storeAdapter && typeof this._storeAdapter.deliver === "function") {
					this._storeAdapter.deliver();
				}
			};
		}),

		/**
		 * Discard change records for all listeners registered via `observe()`.
		 */
		discardChanges: dcl.superCall(function (sup) {
			return function () {
				sup.call();
				if (this._storeAdapter && typeof this._storeAdapter.discardChanges === "function") {
					this._storeAdapter.discardChanges();
				}
			};
		}),

		/**
		 * Called to process the items returned after querying the store.
		 * @param {dstore/Collection} collection - Items to be displayed.
		 * @protected
		 */
		processCollection: function (collection) {
			return this.fetch(collection).then(function (items) {
				return this.initItems(items.map(this.itemToRenderItem.bind(this)));
			}.bind(this), this._queryError.bind(this));
		},

		/**
		 * Called to perform the fetch operation on the collection.
		 * @param {dstore/Collection} collection - Items to be displayed.
		 * @protected
		 */
		fetch: function (collection) {
			return collection.fetch();
		},

		_queryError: function (error) {
			console.log(error);
			this.emit("query-error", { error: error, cancelable: false, bubbles: true });
		},

		_untrack: function () {
			if (this._storeAdapter) {
				this._storeAdapter.untrack();
			}
			if (this._addListener) {
				this._addListener.remove(this._addListener);
			}
			if (this._deleteListener) {
				this._deleteListener.remove(this._deleteListener);
			}
			if (this._updateListener) {
				this._updateListener.remove(this._updateListener);
			}
			if (this._newQueryListener) {
				this._newQueryListener.remove(this._newQueryListener);
			}
		},

		detachedCallback: function () {
			this._untrack();
		},

		destroy: function () {
			this._untrack();
		},

		/**
		 * This method is called when an item is removed from an observable store. The default
		 * implementation actually removes a renderItem from the renderItems array. This can be redefined but
		 * must not be called directly.
		 * @param {number} index - The index of the render item to remove.
		 * @param {Object[]} renderItems - The array of render items to remove the render item from.
		 * @protected
		 */
		itemRemoved: function (index, renderItems) {
			renderItems.splice(index, 1);
		},

		/**
		 * This method is called when an item is added in an observable store. The default
		 * implementation actually adds the renderItem to the renderItems array. This can be redefined but
		 * must not be called directly.
		 * @param {number} index - The index where to add the render item.
		 * @param {Object} renderItem - The render item to be added.
		 * @param {Object[]} renderItems - The array of render items to add the render item to.
		 * @protected
		 */
		itemAdded: function (index, renderItem, renderItems) {
			renderItems.splice(index, 0, renderItem);
		},

		/**
		 * This method is called when an item is updated in an observable store. The default
		 * implementation actually updates the renderItem in the renderItems array. This can be redefined but
		 * must not be called directly.
		 * @param {number} index - The index of the render item to update.
		 * @param {Object} renderItem - The render item data the render item must be updated with.
		 * @param {Object[]} renderItems - The array of render items to render item to be updated is part of.
		 * @protected
		 */
		itemUpdated: function (index, renderItem, renderItems) {
			// we want to keep the same item object and mixin new values into old object
			dcl.mix(renderItems[index], renderItem);
		},

		/**
		 * This method is called when an item is moved in an observable store. The default
		 * implementation actually moves the renderItem in the renderItems array. This can be redefined but
		 * must not be called directly.
		 * @param {number} previousIndex - The previous index of the render item.
		 * @param {number} newIndex - The new index of the render item.
		 * @param {Object} renderItem - The render item to be moved.
		 * @param {Object[]} renderItems - The array of render items to render item to be moved is part of.
		 * @protected
		 */
		itemMoved: function (previousIndex, newIndex, renderItem, renderItems) {
			// we want to keep the same item object and mixin new values into old object
			this.itemRemoved(previousIndex, renderItems);
			this.itemAdded(newIndex, renderItem, renderItems);
		},
		
		_refreshHandler: function () {
			this.queryStoreAndInitItems(this.processQueryResult);
		},

		/**
		 * When the store is observed and an item is removed in the store this method is called to remove the
		 * corresponding render item. This can be redefined but must not be called directly.
		 * @param {Event} event - The "remove" `dstore/Trackable` event.
		 * @private
		 */
		_itemRemoved: function (event) {
			if (event.previousIndex !== undefined) {
				this.itemRemoved(event.previousIndex, this.renderItems);
				// the change of the value of the renderItems property (splice of the array)
				// does not automatically trigger a notification. Hence:
				this.notifyCurrentValue("renderItems");
			}
			// if no previousIndex the items is removed outside of the range we monitor so we don't care
		},

		/**
		 * When the store is observed and an item is updated in the store this method is called to update the
		 * corresponding render item.  This can be redefined but must not be called directly.
		 * @param {Event} event - The "update" `dstore/Trackable` event.
		 * @private
		 */
		_itemUpdated: function (event) {
			if (event.index === undefined) {
				// this is actually a remove
				this.itemRemoved(event.previousIndex, this.renderItems);
			} else if (event.previousIndex === undefined) {
				// this is actually a add
				this.itemAdded(event.index, this.itemToRenderItem(event.target), this.renderItems);
			} else if (event.index !== event.previousIndex) {
				// this is a move
				this.itemMoved(event.previousIndex, event.index, this.itemToRenderItem(event.target), this.renderItems);
			} else {
				// we want to keep the same item object and mixin new values into old object
				this.itemUpdated(event.index, this.itemToRenderItem(event.target), this.renderItems);
			}
			// the change of the value of the renderItems property (splice of the array)
			// does not automatically trigger a notification. Hence:
			this.notifyCurrentValue("renderItems");
		},

		/**
		 * When the store is observed and an item is added in the store this method is called to add the
		 * corresponding render item. This can be redefined but must not be called directly.
		 * @param {Event} event - The "add" `dstore/Trackable` event.
		 * @private
		 */
		_itemAdded: function (event) {
			if (event.index !== undefined) {
				this.itemAdded(event.index, this.itemToRenderItem(event.target), this.renderItems);
				// the change of the value of the renderItems property (splice of the array)
				// does not automatically trigger a notification. Hence:
				this.notifyCurrentValue("renderItems");
			}
			// if no index the item is added outside of the range we monitor so we don't care
		},

		/**
		 * Return the identity of an item.
		 * @param {Object} item - The item
		 * @returns {Object}
		 * @protected
		 */
		getIdentity: function (item) {
			return this._storeAdapter.getIdentity(item);
		}
	});
});
;
/** @module delite/DstoreToStoreAdapter */
define('delite/DstoreToStoreAdapter',[
	"dcl/dcl"
], function (dcl) {

	/**
	 * An adapter to use dstore/Store in the source of delite/Store.js.
	 * Created to keep a commun interface with the use of an array instead of dstore/Store.
	 * The arguments to pass to the constructor are:
	 *
	 * - source: dstore/Store - the dstore/Store represented by the adapter.
	 * - query: the query filter to apply to the store.
	 * - processQueryResult: function to apply to the store.
	 *
	 * @class module:delite/DstoreToStoreAdapter
	 */
	return dcl(null, /** @lends module:delite/DstoreToStoreAdapter# */ {
		constructor: function (args) {
			this.source = args.source;
			this.data = args.processQueryResult(this.source.filter(args.query));
			if (this.data.track) {
				this.data = this._tracked = this.data.track();
				this.track = true;
			}
		},

		/**
		 * Indicates if the source is trackable.
		 * @member {boolean}
		 * @default false
		 * @readonly
		 */
		track: false,

		/**
		 * Remove the trackability of the dstore.
		 */
		untrack: function () {
			if (this._tracked) {
				this._tracked.tracking.remove();
				this._tracked = null;
			}
		},

		/**
		 * Perform the fetch operation on the collection.
		 */
		fetch: function () {
			return this.data.fetch();
		},

		/**
		 * Perform the fetchRange operation on the collection.
		 * @param {Object} args - contains the start index and the end index of the fetch.
		 */
		fetchRange: function (args) {
			return this.data.fetchRange(args);
		},

		/**
		 * Bind the listener of the adapter with the events send by the dstore/Trackable.
		 * @param type
		 * @param listener
		 * @returns {Object} Handle with `remove()` method to cancel the listener.
		 */
		on: function (type, listener) {
			return this.data.on(type, listener);
		},

		/**
		 * Set the identity of an object.
		 */
		setIdentity: function (item, id) {
			this.source._setIdentity(item, id);
		},

		/**
		 * Retrieve an object in the data by its identity.
		 */
		get: function (id) {
			return this.source.get(id);
		},

		/**
		 * Return the identity of an item.
		 * @param {Object} item - The item.
		 * @returns {*}
		 * @protected
		 */
		getIdentity: function (item) {
			return this.source.getIdentity(item);
		}
	});
});
;
/** @module delite/ArrayToStoreAdapter */
define('delite/ArrayToStoreAdapter',[
	"dcl/dcl",
	"decor/Evented",
	"decor/ObservableArray",
	"decor/Observable",
	"requirejs-dplugins/Promise!"
], function (dcl, Evented, ObservableArray, Observable, Promise) {

	/**
	 * Returns a thenable on some static data, but unlike Promise, it executes synchronously.
	 */
	function syncThenable(data) {
		return {
			then: function (resolve) {
				var res = resolve(data);
				return res && res.then ? res : syncThenable(res);
			}
		};
	}

	/**
	 * An adapter to use an array in the source of delite/Store.js.
	 * Created to keep a commun interface with the use of dstore/Store instead of an array.
	 *
	 * The arguments to pass to the constructor are:
	 *
	 * - source: Array - the array represented by the adapter.
	 * - query: the query filter to apply to the source.
	 * - processQueryResult: function to apply to the source
	 *
	 * @class module:delite/ArrayToStoreAdapter
	 */
	return dcl(Evented, /** @lends module:delite/ArrayToStoreAdapter# */ {
		constructor: function (args) {
			this.source = args.source;
			// affect the callbacks of the observe functions
			this._itemHandles = [];
			this._observeCallbackArray = this.__observeCallbackArray.bind(this);
			this._observeCallbackItems = this.__observeCallbackItems.bind(this);
			for (var i = 0; i < this.source.length; i++) {
				// affect the callback to the observe function if the item is observable
				this._itemHandles[i] = Observable.observe(this.source[i], this._observeCallbackItems);
			}
			// affect the callback to the observe function if the array is observable
			this._arrayHandle = ObservableArray.observe(this.source, this._observeCallbackArray);
			this._isQueried = this._compileQuery(args.query);
			this.data = args.processQueryResult(this.source.filter(this._isQueried));
			if (this._arrayHandle || this._itemHandles) {
				this.track = true;
			}
		},

		/**
		 * Indicates if the source is observable.
		 * @member {boolean}
		 * @default false
		 * @readonly
		 */
		track: false,

		/////////////////////////////////////////////////////////////////
		// Functions dedicated to the Observability of the source
		/////////////////////////////////////////////////////////////////

		/**
		 * Function to add an item in the data and pass the good event to the function `itemAdded()` of `delite/Store`.
		 * @param evt
		 * @returns {{index: *, target: (*|evtUpdated.obj|evtRemoved.obj|evtAdded.obj|host.obj|obj)}}
		 * @private
		 */
		_addItemToCollection: function (evt) {
			var i = evt.index - 1;
			while (!this._isQueried(this.source[i])) {
				i--;
			}
			var idx = this.data.indexOf(this.source[i]);
			this.data.splice(idx + 1, 0, evt.obj);
			return {index: idx + 1, target: evt.obj};
		},

		/**
		 * Function to remove an item from the data and pass the good event to the function `itemRemoved()`
		 * of `delite/Store`.
		 * @param evt
		 * @returns {{previousIndex: (*|number|Number)}}
		 * @private
		 */
		_removeItemFromCollection: function (evt) {
			var idx = this.data.indexOf(evt.obj);
			this.data.splice(idx, 1);
			return {previousIndex: idx};
		},

		/**
		 * Function to test if the update was finally a remove or an add to the data.
		 * @param evt
		 * @param idx
		 * @returns {boolean}
		 * @private
		 */
		_isAnUpdate: function (evt, idx) {
			return this._isQueried(evt.obj) && idx >= 0;
		},

		/**
		 * Function that emit an event "add" if the update was finally an "add" and an event "remove" if it was a
		 * remove.
		 * @param evt
		 * @param idx
		 * @private
		 */
		_redirectEvt: function (evt, idx) {
			if (this._isQueried(evt.obj) && idx < 0) {
				var evtAdded = this._addItemToCollection(evt);
				this.emit("add", evtAdded);
			} else if (!this._isQueried(evt.obj) && idx >= 0) {
				var evtRemoved = this._removeItemFromCollection(evt);
				this.emit("delete", evtRemoved);
			}
		},

		/**
		 * Function to pass the good event to the function `itemUpdated()` of `delite/Store`.
		 * @param evt
		 * @param idx
		 * @returns {{index: *, previousIndex: *, target: (*|evtUpdated.obj|evtRemoved.obj|evtAdded.obj|host.obj|obj)}}
		 * @private
		 */
		_updateItemInCollection: function (evt, idx) {
			return {index: idx, previousIndex: idx, target: evt.obj};
		},

		/**
		 * Called when a modification is done on the array.
		 * @param {Array} changeRecords - sent by the Observe function.
		 */
		__observeCallbackArray: function (changeRecords) {
			if (!this._beingDiscarded) {
				for (var i = 0; i < changeRecords.length; i++) {
					if (changeRecords[i].type === "splice") {
						var j, evt;
						for (j = 0; j < changeRecords[i].removed.length; j++) {
							this._itemHandles[changeRecords[i].index].remove();
							this._itemHandles.splice(changeRecords[i].index, 1);
							var evtRemoved = {previousIndex: changeRecords[i].index,
								obj: changeRecords[i].removed[j]};
							if (this._isQueried(evtRemoved.obj)) {
								evt = this._removeItemFromCollection(evtRemoved);
								this.emit("delete", evt);
							}
						}
						for (j = 0; j < changeRecords[i].addedCount; j++) {
							var evtAdded = {
								index: changeRecords[i].index + j,
								obj: this.source[changeRecords[i].index + j]
							};
							if (this.renderItems !== null && this.renderItems !== undefined) {
								evtAdded.index = evtAdded.index <= this.renderItems.length ?
									evtAdded.index : this.renderItems.length;
							}
							// affect the callback to the observe function if the item is observable
							this._itemHandles.splice(changeRecords[i].index + j, 0,
								Observable.observe(
									this.source[changeRecords[i].index + j], this._observeCallbackItems)
							);
							if (this._isQueried(evtAdded.obj)) {
								evt = this._addItemToCollection(evtAdded);
								this.emit("add", evt);
							}
						}
					}
				}
			}
		},

		/**
		 * Called when a modification is done on the items.
		 * @param {Array} changeRecords - sent by the Observe function.
		 */
		__observeCallbackItems: function (changeRecords) {
			if (!this._beingDiscarded) {
				var objects = [];
				for (var i = 0; i < changeRecords.length; i++) {
					var object = changeRecords[i].object;
					if (objects.indexOf(object) < 0) {
						objects.push(object);
						if (changeRecords[i].type === "add" || changeRecords[i].type === "update" ||
							changeRecords[i].type === "delete" || changeRecords[i].type === "splice") {
							var evtUpdated = {
								index: this.source.indexOf(object),
								previousIndex: this.source.indexOf(object),
								obj: object,
								oldValue: changeRecords[i].oldValue,
								name: changeRecords[i].name
							};
							var idx = this.data.indexOf(evtUpdated.obj);
							if (!this._isAnUpdate(evtUpdated, idx)) {
								this._redirectEvt(evtUpdated, idx);
							} else {
								var evt = this._updateItemInCollection(evtUpdated, idx);
								this.emit("update", evt);
							}
						}
					}
				}
			}
		},

		/**
		 * Generate a function that will test if an item respects the query conditions.
		 * @param query
		 * @returns {Function}
		 * @private
		 */
		_compileQuery: function (query) {
			if (Object.getOwnPropertyNames(query).length !== 0) {
				if (typeof query === "function") {
					return query;
				}
				if (!query.type) {
					return function (item) {
						for (var property in query) {
							if (item[property] !== query[property]) { return false; }
						}
						return true;
					};
				}
				return this._compileFilterQuery(query);
			} else {
				return function () { return true; };
			}
		},

		/**
		 * Generate a function that will test if an item respects the query conditions, based on a query
		 * object generated from `dstore/Filter`.
		 * @param query
		 * @returns {Function}
		 * @private
		 */
		/* jshint maxcomplexity: 12 */
		_compileFilterQuery: function (query) {
			var prop = query.args[0];
			var value = query.args[1];
			switch (query.type) {
			case "eq":
				return function (item) {return item[prop] === value; };
			case "ne":
				return function (item) {return item[prop] !== value; };
			case "lt":
				return function (item) {return item[prop] < value; };
			case "lte":
				return function (item) {return item[prop] <= value; };
			case "gt":
				return function (item) {return item[prop] > value; };
			case "gte":
				return function (item) {return item[prop] >= value; };
			case "in":
				return function (item) {return value.indexOf(item[prop]) !== -1; };
			case "match":
				return function (item) {return value.test(item[prop]); };
			case "contains":
				return function (item) {return this._arrayContains(item[prop], value); }.bind(this);
			/**
			 * In the case of "and" and "or" the prop in in fact the first member of the two queries and value the
			 * second member.
			 */
			case "and":
				var f1 = this._compileFilterQuery(prop);
				var f2 = this._compileFilterQuery(value);
				return function (item) {return f1(item) && f2(item); };
			case "or":
				f1 = this._compileFilterQuery(prop);
				f2 = this._compileFilterQuery(value);
				return function (item) {return f1(item) || f2(item); };
			default:
				throw new Error("Unknown filter operation '" + query.type + "'");
			}
		},
		/* jshint maxcomplexity: 10*/

		/**
		 * Test if an array contains all the values in parameter values.
		 * @param array
		 * @param values
		 * @returns {boolean}
		 * @private
		 */
		_arrayContains: function (array, values) {
			for (var j = 0; j < values.length; j++) {
				if (array.indexOf(values[j]) === -1) {
					return false;
				}
			}
			return true;
		},

		/**
		 * Synchronously emit add/update/delete events for all recent changes.
		 */
		deliver: function () {
			if (this._arrayHandle) {
				this._arrayHandle.deliver();
			}
			if (this._itemHandles.length !== 0) {
				this._observeCallbackItems && Observable.deliverChangeRecords(this._observeCallbackItems);
			}
		},

		/**
		 * Discard recent change records.
		 */
		discardChanges: function () {
			if (this._arrayHandle && this._itemHandles) {
				this._beingDiscarded = true;
				this._arrayHandle.deliver();
				this._observeCallbackItems && Observable.deliverChangeRecords(this._observeCallbackItems);
				this._beingDiscarded = false;
				return this;
			}
		},

		/**
		 * Stop observing the array and its items.
		 */
		untrack: function () {
			if (this._arrayHandle) {
				this._arrayHandle.remove();
			}
			if (this._itemHandles) {
				for (var i = 0; i < this._itemHandles.length; i++) {
					this._itemHandles[i].remove();
				}
			}
		},


		/////////////////////////////////////////////////////////////////////////
		// Functions dedicated to reproduce the behaviour of dstore functions
		/////////////////////////////////////////////////////////////////////////

		/**
		 * Perform the fetch operation on the collection.
		 */
		fetch: function () {
			return syncThenable(this.data);
		},

		/**
		 * Perform the fetchRange operation on the collection.
		 * @param {Object} args - contains the start index and the end index of the fetch.
		 */
		fetchRange: function (args) {
			var res = this.data.slice(args.start, args.end);
			if (res.length < (args.end - args.start)) {
				var promise;
				var evt = {start: args.start, end: args.end, resLength: res.length, setPromise: function (pro) {
					promise = pro;
				}};
				this.emit("_new-query-asked", evt);
				return promise;
			} else {
				return syncThenable(res);
			}
		},

		/**
		 * Set the identity of an object.
		 */
		setIdentity: function (item, id) {
			item.id = id;
		},

		/**
		 * Retrieve an object in the data by its identity.
		 */
		get: function (id) {
			for (var i = 0; i < this.data.length; i++) {
				var res = this.data[i];
				if (res.id === id) {
					return Promise.resolve(res);
				}
			}
		},

		/**
		 * Returns the identity of an item.
		 * @param {Object} item - The item.
		 * @returns {*}
		 */
		getIdentity: function (item) {
			return item.id !== undefined ? item.id : this.data.indexOf(item);
		}
	});
});
;
/** @module decor/Observable */
define('decor/Observable',[
	"./features",
	"./features!object-observe-api?:./schedule"
], function (has, schedule) {
	"use strict";

	/**
	 * An observable object, working as a shim
	 * of {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Object.observe()}.
	 * @class
	 * @alias module:decor/Observable
	 * @param {Object} o The object to mix-into the new Observable.
	 * @example
	 *     var observable = new Observable({foo: "Foo0"});
	 *     Observable.observe(observable, function (changeRecords) {
	 *         // Called at the end of microtask with:
	 *         //     [
	 *         //         {
	 *         //             type: "update",
	 *         //             object: observable,
	 *         //             name: "foo",
	 *         //             oldValue: "Foo0"
	 *         //         },
	 *         //         {
	 *         //             type: "add",
	 *         //             object: observable,
	 *         //             name: "bar"
	 *         //         }
	 *         //     ]
	 *     });
	 *     observable.set("foo", "Foo1");
	 *     observable.set("bar", "Bar0");
	 */
	var Observable,
		defineProperty = Object.defineProperty,
		getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	/**
	 * The default list of change record types, which is:
	 * [
	 *     "add",
	 *     "update",
	 *     "delete",
	 *     "reconfigure",
	 *     "setPrototype",
	 *     "preventExtensions"
	 * ]
	 * @constant {Array.<module:decor/Observable~ChangeType>}
	 *     module:decor/Observable~DEFAULT_CHANGETYPES
	 */
	var DEFAULT_ACCEPT_CHANGETYPES = {
		"add": 1,
		"update": 1,
		"delete": 1,
		"reconfigure": 1,
		"setPrototype": 1,
		"preventExtensions": 1
	}; // Observable#set() only supports the first two

	/**
	 * Change record type.
	 * One of:
	 * * "add"
	 * * "update"
	 * * "delete"
	 * * "reconfigure"
	 * * "setPrototype"
	 * * "preventExtensions"
	 * * "splice"
	 * @typedef {string} module:decor/Observable~ChangeType
	 */

	/**
	 * Change record seen in Observable.observe().
	 * @typedef {Object} module:decor/Observable~ChangeRecord
	 * @property {module:decor/Observable~ChangeType} type The type of change record.
	 * @property {Object} object The changed object.
	 * @property {string} [name] The changed property name. Set only for non-splice type of change records.
	 * @property {number} [index] The array index of splice. Set only for splice type of change records.
	 * @property {Array} [removed] The removed array elements. Set only for splice type of change records.
	 * @property {number} [addedCount] The count of added array elements. Set only for splice type of change records.
	 */

	/**
	 * Change callback.
	 * @callback module:decor/Observable~ChangeCallback
	 * @param {Array.<module:decor/Observable~ChangeRecord>} changeRecords The change records.
	 */

	Observable = function (o) {
		// Make Observable marker not enumerable, configurable or writable
		if (!this._observable) { // In case this constructor is called manually
			defineProperty(this, "_observable", {value: 1});
		}
		o && Observable.assign(this, o);
	};

	/**
	 * @method module:decor/Observable.test
	 * @param {Object} o The object to test.
	 * @returns {boolean} true if o is an instance of Observable.
	 */
	Observable.test = function (o) {
		return o && o._observable;
	};

	/**
	 * @method module:decor/Observable.is
	 * @returns {boolean} true if the given two values are the same, considering NaN as well as +0 vs. -0.
	 */
	Observable.is = has("object-is-api") ? Object.is : function (lhs, rhs) {
		return lhs === rhs && (lhs !== 0 || 1 / lhs === 1 / rhs) || lhs !== lhs && rhs !== rhs;
	};

	/**
	 * Copy properties of given source objects to given target object.
	 * If target object has {@link module:decor/Observable#set set()} function for the property, uses it.
	 * @function module:decor/Observable.assign
	 * @param {Object} dst The target object.
	 * @param {...Object} var_args The source objects.
	 * @returns {Object} The target object.
	 */
	Observable.assign = function (dst) {
		if (dst == null) {
			throw new TypeError("Can't convert " + dst + " to object.");
		}
		dst = Object(dst);
		for (var i = 1, l = arguments.length; i < l; ++i) {
			var src = Object(arguments[i]),
				props = Object.getOwnPropertyNames(src);
			for (var j = 0, m = props.length; j < m; ++j) {
				var prop = props[j];
				Observable.prototype.set.call(dst, prop, src[prop]);
			}
		}
		return dst;
	};

	/**
	 * @method module:decor/Observable.canObserve
	 * @param {Object} o The object to test.
	 * @returns {boolean} true if o can be observed with {@link module:decor/Observable.observe Observable.observe()}.
	 */
	if (has("object-observe-api")) {
		Observable.canObserve = function (o) {
			return typeof o === "object" && o != null;
		};
	} else {
		Observable.canObserve = Observable.test;
	}

	if (has("object-observe-api")) {
		defineProperty(Observable.prototype, "set", { // Make set() not enumerable
			value: function (name, value) {
				this[name] = value;
				return value;
			},
			configurable: true,
			writable: true
		});

		Observable.observe = function (object, callback, accept) {
			Object.observe.call(this, object, callback, accept);
			return {
				remove: function () {
					Object.unobserve(object, callback);
				}
			};
		};

		Observable.getNotifier = Object.getNotifier;
		Observable.deliverChangeRecords = Object.deliverChangeRecords;
	} else {
		defineProperty(Observable.prototype, "set", { // Make set() not enumerable
			/**
			 * Sets a value.
			 * Automatically emits change record(s)
			 * compatible with {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe Object.observe()}
			 * if no ECMAScript setter is defined for the given property.
			 * If ECMAScript setter is defined for the given property, use
			 * {@link module:decor/Observable~Notifier#notify Observable.getNotifier(observable).notify(changeRecord)}
			 * to manually emit a change record.
			 * @method module:decor/Observable#set
			 * @param {string} name The property name.
			 * @param value The property value.
			 * @returns The value set.
			 */
			value: function (name, value) {
				var type = name in this ? "update" : "add",
					oldValue = this[name],
					// For defining setter, ECMAScript setter should be used
					setter = (getOwnPropertyDescriptor(this, name) || {}).set;
				this[name] = value;
				if (!Observable.is(value, oldValue) && setter === undefined) {
					// Auto-notify if there is no setter defined for the property.
					// Application should manually call Observable.getNotifier(observable).notify(changeRecord)
					// if a setter is defined.
					var changeRecord = {
						type: type,
						object: this,
						name: name + ""
					};
					if (type === "update") {
						changeRecord.oldValue = oldValue;
					}
					Observable.getNotifier(this).notify(changeRecord);
				}
				return value;
			},
			configurable: true,
			writable: true
		});

		var seq = 0,
			hotCallbacks = {},
			deliverHandle = null,
			deliverAllByTimeout = function () {
				/* global Platform */
				has("polymer-platform") && Platform.performMicrotaskCheckpoint(); // For Polymer watching for Observable
				for (var anyWorkDone = true; anyWorkDone;) {
					anyWorkDone = false;
					// Observation may stop during observer callback
					var callbacks = [];
					for (var s in hotCallbacks) {
						callbacks.push(hotCallbacks[s]);
					}
					hotCallbacks = {};
					callbacks = callbacks.sort(function (lhs, rhs) {
						return lhs._seq - rhs._seq;
					});
					for (var i = 0, l = callbacks.length; i < l; ++i) {
						if (callbacks[i]._changeRecords.length > 0) {
							Observable.deliverChangeRecords(callbacks[i]);
							anyWorkDone = true;
						}
					}
				}
				deliverHandle = null;
			},
			removeGarbageCallback = function (callback) {
				if (callback._changeRecords.length === 0 && callback._refCountOfNotifier === 0) {
					callback._seq = undefined;
				}
			};

		/**
		 * Notifier object for Observable.
		 * This is an internal function and cannot be used directly.
		 * @class module:decor/Observable~Notifier
		 */
		var Notifier = function (target) {
			this.target = target;
			this.observers = {};
			this._activeChanges = {};
		};

		Notifier.prototype = /** @lends module:decor/Observable~Notifier */ {
			/**
			 * Queue up a change record.
			 * It will be notified at the end of microtask,
			 * or when {@link module:decor/Observable.deliverChangeRecords Observable.deliverChangeRecords()}
			 * is called.
			 * @method module:decor/Observable~Notifier#notify
			 * @param {module:decor/Observable~ChangeRecord} changeRecord
			 *     The change record to queue up for notification.
			 */
			notify: function (changeRecord) {
				function shouldDeliver(activeChanges, acceptTable, changeType) {
					if (changeType in acceptTable) {
						for (var s in acceptTable) {
							if (activeChanges[s] > 0) {
								return false;
							}
						}
						return true;
					}
				}
				for (var s in this.observers) {
					if (shouldDeliver(this._activeChanges, this.observers[s].acceptTable, changeRecord.type)) {
						var callback = this.observers[s].callback;
						callback._changeRecords.push(changeRecord);
						hotCallbacks[callback._seq] = callback;
						if (!deliverHandle) {
							deliverHandle = schedule(deliverAllByTimeout);
						}
					}
				}
			},
			/**
			 * Let the series of changes made in the given callback be represented
			 * by a synthetic change of the given change type.
			 * The callback may return the synthetic change record,
			 * which will be of the `type` and automatically emitted.
			 * Otherwise, the caller can emit the synthetic record manually
			 * via {@link module:decor/Observable~Notifier#notify notify()}.
			 * @param {string} type The change type of synthetic change record.
			 * @param {Function} callback The callback function.
			 */
			performChange: function (type, callback) {
				this._activeChanges[type] = (this._activeChanges[type] || 0) + 1;
				var source = callback.call(undefined);
				--this._activeChanges[type];
				if (source) {
					var target = {
						type: type,
						object: this.target
					};
					for (var s in source) {
						if (!(s in target)) {
							target[s] = source[s];
						}
					}
					this.notify(target);
				}
			}
		};

		/**
		 * Obtains a notifier object for the given {@link module:decor/Observable Observable}.
		 * @method module:decor/Observable.getNotifier
		 * @param {Object} observable The {@link module:decor/Observable Observable} to get a notifier object of.
		 * @returns {module:decor/Observable~Notifier}
		 */
		Observable.getNotifier = function (observable) {
			if (!getOwnPropertyDescriptor(observable, "_notifier")) {
				// Make the notifier reference not enumerable, configurable or writable
				defineProperty(observable, "_notifier", {
					value: new Notifier(observable)
				});
			}
			return observable._notifier;
		};

		/**
		 * Observes an {@link module:decor/Observable Observable} for changes.
		 * @method module:decor/Observable.observe
		 * @param {Object} observable The {@link module:decor/Observable Observable} to observe.
		 * @param {module:decor/Observable~ChangeCallback} callback The change callback.
		 * @param {Array.<module:decor/Observable~ChangeType>}
		 *     [accept={@link module:decor/Observable~DEFAULT_CHANGETYPES}]
		 *     The list of change record types to observe.
		 * @returns {Handle} The handle to stop observing.
		 * @throws {TypeError} If the 1st argument is non-object or null.
		 */
		Observable.observe = function (observable, callback, accept) {
			if (Object(observable) !== observable) {
				throw new TypeError("Observable.observe() cannot be called on non-object.");
			}
			if (!("_seq" in callback)) {
				callback._seq = seq++;
				callback._changeRecords = [];
				callback._refCountOfNotifier = 0;
			}
			var acceptTable = accept ? accept.reduce(function (types, type) {
					types[type] = 1;
					return types;
				}, {}) : DEFAULT_ACCEPT_CHANGETYPES,
				notifier = Observable.getNotifier(observable);
			if (!(callback._seq in notifier.observers)) {
				notifier.observers[callback._seq] = {
					acceptTable: acceptTable,
					callback: callback
				};
				++callback._refCountOfNotifier;
			} else {
				notifier.observers[callback._seq].acceptTable = acceptTable;
			}
			return {
				remove: function () {
					if (callback._seq in notifier.observers) {
						delete notifier.observers[callback._seq];
						--callback._refCountOfNotifier;
					}
				}
			};
		};

		/**
		 * Delivers change records immediately.
		 * @method module:decor/Observable.deliverChangeRecords
		 * @param {Function} callback The change callback to deliver change records of.
		 */
		Observable.deliverChangeRecords = function (callback) {
			var length = callback._changeRecords.length;
			try {
				callback(callback._changeRecords.splice(0, length));
			} catch (e) {
				has("console-api") && console.error("Error occured in observer callback: " + (e.stack || e));
			}
			removeGarbageCallback(callback);
		};
	}

	return Observable;
});
;
/** @module delite/Selection */
define('delite/Selection',["dcl/dcl", "decor/sniff", "./Widget"], function (dcl, has, Widget) {
	
	/**
	 * Selection change event. Dispatched after the selection has
	 * been modified through user interaction.
	 * @example
	 * widget.on("selection-change", function (evt) {
	 *	console.log("old value: " + evt.oldValue);
	 *	console.log("new value: " + evt.newValue);
	 * }
	 * @event module:delite/Selection#selection-change
	 * @property {number} oldValue - The previously selected item.
	 * @property {number} newValue- The new selected item.
	 * @property {Object} renderer - The visual renderer of the selected/deselected item.
	 * @property {Event} triggerEvent - The event that lead to the selection of the item.
	 */
	
	/**
	 * Mixin for widgets that manage a list of selected data items.
	 * @mixin module:delite/Selection
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** @lends module:delite/Selection# */{
		createdCallback: function () {
			this._set("selectedItems", []);
		},
		
		/**
		 * The chosen selection mode.
		 *
		 * Valid values are:
		 *
		 * 1. "none": No selection can be done.
		 * 2. "single": Only one or zero items can be selected at a time. Interactively selecting a new item deselects
		 * the previously selected one.
		 * 3. "radio":  Initially only one or zero items can be selected. Once an item has been selected, interactively 
		 * selecting another item deselects the previously selected item, and the user cannot deselect the currently 
		 * selected item. 
		 * 4. "multiple": Multiple items can be selected. By default ctrl key must be used to select additional items.
		 * However that behavior might be specialized by subclasses.
		 *
		 * Changing this value impacts the current selected items to adapt the selection to the new mode. However
		 * whatever the selection mode is you can always set several selected items using the selectItem(s) API.
		 * The mode will be enforced only when using setSelected and/or selectFromEvent APIs.
		 *
		 * @member {string}
		 * @default "single"
		 */
		selectionMode: "single",

		_setSelectionModeAttr: function (value) {
			if (value !== "none" && value !== "single" && value !== "multiple" && value !== "radio") {
				throw new TypeError("selectionMode invalid value");
			}
			if (value !== this.selectionMode) {
				this._set("selectionMode", value);
				if (value === "none") {
					this.selectedItems = null;
				} else if ((value === "single" || value === "radio") && this.selectedItem) {
					this.selectedItems = [this.selectedItem];
				}
			}
		},

		/**
		 * In single selection mode, the selected item or in multiple selection mode the last selected item.
		 * @member {Object}
		 * @default null
		 */
		selectedItem: null,

		_setSelectedItemAttr: function (value) {
			if (this.selectedItem !== value) {
				this.selectedItems = (value == null ? null : [value]);
			}
		},

		/**
		 * The list of selected items.
		 * @member {Object[]}
		 * @default null
		 */
		selectedItems: null,

		_setSelectedItemsAttr: function (value) {
			var oldSelectedItems = this.selectedItems;

			this._set("selectedItems", value);

			if (oldSelectedItems != null && oldSelectedItems.length > 0) {
				this.updateRenderers(oldSelectedItems);
			}
			if (this.selectedItems && this.selectedItems.length > 0) {
				this._set("selectedItem", this.selectedItems[0]);
				this.updateRenderers(this.selectedItems);
			} else {
				this._set("selectedItem", null);
			}
		},

		_getSelectedItemsAttr: function () {
			return this._get("selectedItems") == null ? [] : this._get("selectedItems").concat();
		},

		/**
		 * Tests if an event has a selection modifier.
		 *
		 * If it has a selection modifier, that means that:
		 *
		 * * if selectionMode is "single", the event will be able to deselect a selected item
		 * * if selectionMode is "multiple", the event will trigger the selection state of the item
		 *
		 * The default implementation of this method returns true if the event.ctrlKey attribute is
		 * true, which means that:
		 *
		 * * if selectionMode is "single", the Ctrl (or Command on MacOS) key must be pressed for the
		 * * event to deselect the currently selected item
		 * * if selectionMode is "multiple", the Ctrl (or Command on MacOS) key must be pressed for the
		 *     event to toggle the selection status of the item.
		 *
		 * @param {Event} event - The event that led to the selection .
		 * @returns {boolean} Whether the event has selection modifier.
		 * @protected
		 */
		hasSelectionModifier: function (event) {
			return !has("mac") ? event.ctrlKey : event.metaKey;
		},

		/**
		 * Returns whether an item is selected or not.
		 * @param {item} object The item to test.
		 * @returns {Object} The item to test the selection for.
		 */
		isSelected: function (item) {
			if (this.selectedItems == null || this.selectedItems.length === 0) {
				return false;
			}
			var identity = this.getIdentity(item);
			return this.selectedItems.some(function (sitem) {
				return this.getIdentity(sitem) === identity;
			}, this);
		},

		/**
		 * This function must be implemented to return the id of a item.
		 * @param {item} object - The item the identity of must be returned.
		 * @returns {string} The identity of the item.
		 */
		getIdentity: function (/*jshint unused: vars */item) {
		},

		/**
		 * This function must be implemented to update the rendering of the items based on whether they are
		 * selected or not. The implementation must check for their new selection state and update
		 * accordingly.
		 * @param {Object[]} items - The array of items changing their selection state.
		 * @protected
		 */
		updateRenderers: function (/*jshint unused: vars */items) {
		},

		/**
		 * Change the selection state of an item.
		 * @param {Object} item - The item to change the selection state for.
		 * @param {boolean} value - True to select the item, false to deselect it.
		 */
		setSelected: function (item, value) {
			if (this.selectionMode === "none" || item == null) {
				return;
			}

			this._setSelected(item, value);
		},

		/* jshint maxcomplexity: 11*/
		_setSelected: function (item, value) {
			// copy is returned
			var sel = this.selectedItems, res, identity;

			if (this.selectionMode === "single" || this.selectionMode === "radio") {
				if (value) {
					this.selectedItem = item;
				} else if (this.selectionMode === "single" && this.isSelected(item)) {
					this.selectedItems = null;
				}
			} else { // multiple
				if (value) {
					if (this.isSelected(item)) {
						return; // already selected
					}
					if (sel == null) {
						sel = [item];
					} else {
						sel.unshift(item);
					}
					this.selectedItems = sel;
				} else {
					identity = this.getIdentity(item);
					res = sel ? sel.filter(function (sitem) {
						return this.getIdentity(sitem) !== identity;
					}, this) : [];
					if (res == null || res.length === sel.length) {
						return; // already not selected
					}
					this.selectedItems = res;
				}
			}
		},
		/* jshint maxcomplexity: 10*/

		/**
		 * Applies selection triggered by an user interaction.
		 * @param {Event} event - The source event of the user interaction.
		 * @param {Object} item - The item that has been selected/deselected.
		 * @param {Object} renderer - The visual renderer of the selected/deselected item.
		 * @param {boolean} dispatch - Whether an event must be dispatched or not.
		 * @returns {boolean} True if the selection has changed and false otherwise.
		 * @protected
		 */
		selectFromEvent: function (event, item, renderer, dispatch) {
			if (this.selectionMode === "none") {
				return false;
			}

			return this._selectFromEvent(event, item, renderer, dispatch);
		},

		_selectFromEvent: function (event, item, renderer, dispatch) {
			var changed;
			var oldSelectedItem = this.selectedItem;
			var selected = item == null ? false : this.isSelected(item);

			if (item == null) {
				if ((this.selectionMode === "multiple" && !this.hasSelectionModifier(event))
					&& this.selectedItem != null) {
					this.selectedItem = null;
					changed = true;
				}
			} else if (this.selectionMode === "multiple") {
				if (this.hasSelectionModifier(event)) {
					this.setSelected(item, !selected);
					changed = true;
				} else {
					this.selectedItem = item;
					changed = true;
				}
			} else { // single
				if (this.selectionMode === "single" && this.hasSelectionModifier(event)) {
					//if the object is selected deselects it.
					this.selectedItem = (selected ? null : item);
					changed = true;
				} else {
					if (!selected) {
						this.selectedItem = item;
						changed = true;
					}
				}
			}

			if (dispatch && changed) {
				this.dispatchSelectionChange(oldSelectedItem, this.selectedItem, renderer, event);
			}

			return changed;
		},

		/**
		 * Dispatch a selection change event.
		 * @param {Object} oldSelectedItem - The previously selected item.
		 * @param {Object} newSelectedItem - The new selected item.
		 * @param {Object} renderer - The visual renderer of the selected/deselected item.
		 * @param {Event} triggerEvent - The event that lead to the selection of the item.
		 * @protected
		 * @fires module:delite/Selection#selection-change
		 */
		dispatchSelectionChange: function (oldSelectedItem, newSelectedItem, renderer, triggerEvent) {
			this.emit("selection-change", {
				oldValue: oldSelectedItem,
				newValue: newSelectedItem,
				renderer: renderer,
				triggerEvent: triggerEvent
			});
		}
	});
});;
/** @module delite/CustomElement */
define('delite/CustomElement',[
	"dcl/advise",
	"dcl/dcl",
	"decor/Observable",
	"decor/Destroyable",
	"decor/Stateful",
	"requirejs-dplugins/has",
	"./on",
	"./register"
], function (advise, dcl, Observable, Destroyable, Stateful, has, on, register) {

	/**
	 * Dispatched after the CustomElement has been attached.
	 * This is useful to be notified when an HTMLElement has been upgraded to a
	 * CustomElement and attached to the DOM, in particular on browsers supporting native Custom Element.
	 * @example
	 * element.addEventListener("customelement-attached", function (evt) {
	 *      console.log("custom element: "+evt.target.id+" has been attached");
	 * });
	 * @event module:delite/CustomElement#customelement-attached
	 */

	// Test if custom setters work for native properties like dir, or if they are ignored.
	// They don't work on some versions of webkit (Chrome, Safari 7, iOS 7), but do work on Safari 8 and iOS 8.
	// If needed, this test could probably be reduced to just use Object.defineProperty() and dcl(),
	// skipping use of register().
	has.add("setter-on-native-prop", function () {
		var works = false,
			Mixin = dcl(Stateful, {	// mixin to workaround https://github.com/uhop/dcl/issues/9
				getProps: function () { return {dir: true}; },
				dir: "",
				_setDirAttr: function () { works = true; }
			}),
			TestWidget = register("test-setter-on-native-prop", [HTMLElement, Mixin], {}),
			tw = new TestWidget();
		tw.dir = "rtl";
		return works;
	});


	/**
	 * Get a property from a dot-separated string, such as "A.B.C".
	 */
	function getObject(name) {
		try {
			return name.split(".").reduce(function (context, part) {
				return context[part];
			}, this);	// "this" is the global object (i.e. window on browsers)
		} catch (e) {
			// Return undefined to indicate that object doesn't exist.
		}
	}

	// Properties not to monitor for changes.
	var REGEXP_IGNORE_PROPS = /^constructor$|^_set$|^_get$|^deliver$|^discardChanges$|^_(.+)Attr$/;

	/**
	 * Base class for all custom elements.
	 *
	 * Use this class rather that delite/Widget for non-visual custom elements.
	 * Custom elements can provide custom setters/getters for properties, which are called automatically
	 * when the value is set.  For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	 *
	 * @mixin module:delite/CustomElement
	 * @augments module:decor/Stateful
	 * @augments module:decor/Destroyable
	 */
	var CustomElement = dcl([Stateful, Destroyable], /** @lends module:delite/CustomElement# */{
		introspect: function () {
			if (!has("setter-on-native-prop")) {
				// Generate map from native attributes of HTMLElement to custom setters for those attributes.
				// Necessary because webkit masks all custom setters for native properties on the prototype.
				// For details see:
				//		https://bugs.webkit.org/show_bug.cgi?id=36423
				//		https://bugs.webkit.org/show_bug.cgi?id=49739
				//		https://bugs.webkit.org/show_bug.cgi?id=75297
				var proto = this,
					nativeProps = document.createElement(this._extends || "div"),
					setterMap = this._nativePropSetterMap = {};

				this._nativeAttrs = [];
				do {
					Object.keys(proto).forEach(function (prop) {
						var lcProp = prop.toLowerCase();

						if (prop in nativeProps && !setterMap[lcProp]) {
							var desc = Object.getOwnPropertyDescriptor(proto, prop);
							if (desc && desc.set) {
								this._nativeAttrs.push(lcProp);
								setterMap[lcProp] = desc.set;
							}
						}
					}, this);

					proto = Object.getPrototypeOf(proto);
				} while (proto && proto !== this._baseElement.prototype);
			}
		},

		getProps: function () {
			// Override _Stateful.getProps() to ignore properties from the HTML*Element superclasses, like "style".
			// You would need to explicitly declare style: "" in your widget to get it here.
			//
			// Also sets up this._propCaseMap, a mapping from lowercase property name to actual name,
			// ex: iconclass --> iconClass, which does include the methods, but again doesn't
			// include props like "style" that are merely inherited from HTMLElement.

			var hash = {}, proto = this,
				pcm = this._propCaseMap = {};

			do {
				Object.keys(proto).forEach(function (prop) {
					if (!REGEXP_IGNORE_PROPS.test(prop)) {
						hash[prop] = true;
						pcm[prop.toLowerCase()] = prop;
					}
				});

				proto = Object.getPrototypeOf(proto);
			} while (proto && proto !== this._baseElement.prototype);

			return hash;
		},

		/**
		 * This method will detect and process any properties that the application has set, but the custom setter
		 * didn't run because `has("setter-on-native-prop") === false`.
		 * Used during initialization and also by `deliver()`.
		 * @private
		 */
		_processNativeProps: function () {
			if (!has("setter-on-native-prop")) {
				this._nativeAttrs.forEach(function (attrName) {
					if (this.hasAttribute(attrName)) { // value was specified
						var value = this.getAttribute(attrName);
						this.removeAttribute(attrName);
						if (value !== null) {
							this._nativePropSetterMap[attrName].call(this, value); // call custom setter
						}
					}
				}, this);
			}
		},

		/**
		 * Set to true when `createdCallback()` has completed.
		 * @member {boolean}
		 * @protected
		 */
		created: false,

		/**
		 * Called when the custom element is created, or when `register.parse()` parses a custom tag.
		 *
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @method
		 * @protected
		 */
		createdCallback: dcl.advise({
			before: function () {
				// Mark this object as observable with Object.observe() shim
				if (!this._observable) {
					Observable.call(this);
				}

				// Get parameters that were specified declaratively on the widget DOMNode.
				this._parsedAttributes = this._mapAttributes();
			},

			after: function () {
				this.created = true;

				// Now that creation has finished, apply parameters that were specified declaratively.
				// This is consistent with the timing that parameters are applied for programmatic creation.
				this._parsedAttributes.forEach(function (pa) {
					if (pa.event) {
						this.on(pa.event, pa.callback);
					} else {
						this[pa.prop] = pa.value;
					}
				}, this);

				if (!has("setter-on-native-prop")) {
					// Call custom setters for initial values of attributes with shadow properties (dir, tabIndex, etc)
					this._processNativeProps();

					// Begin watching for changes to those DOM attributes.
					// Note that (at least on Chrome) I could use attributeChangedCallback() instead, which is
					// synchronous, so Widget#deliver() will work as expected, but OTOH gets lots of notifications
					// that I don't care about.
					// If Polymer is loaded, use MutationObserver rather than WebKitMutationObserver
					// to avoid error about "referencing a Node in a context where it does not exist".
					/* global WebKitMutationObserver */
					var MO = window.MutationObserver || WebKitMutationObserver;	// for jshint
					var observer = new MO(function (records) {
						records.forEach(function (mr) {
							var attrName = mr.attributeName,
								setter = this._nativePropSetterMap[attrName],
								newValue = this.getAttribute(attrName);
							if (newValue !== null) {
								this.removeAttribute(attrName);
								setter.call(this, newValue);
							}
						}, this);
					}.bind(this));
					observer.observe(this, {
						subtree: false,
						attributeFilter: this._nativeAttrs,
						attributes: true
					});
				}
			}
		}),

		/**
		 * Set to true when `attachedCallback()` has completed, and false when `detachedCallback()` called.
		 * @member {boolean}
		 * @protected
		 */
		attached: false,

		/**
		 * Called automatically when the element is added to the document, after `createdCallback()` completes.
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @method
		 * @fires module:delite/CustomElement#customelement-attached
		 */
		attachedCallback: dcl.advise({
			before: function () {
				// Call computeProperties() and refreshRendering() for declaratively set properties.
				// Do this in attachedCallback() rather than createdCallback() to avoid calling refreshRendering() etc.
				// prematurely in the programmatic case (i.e. calling it before user parameters have been applied).
				this.deliver();
			},

			after: function () {
				this.attached = true;

				this.emit("customelement-attached", {
					bubbles: false,
					cancelable: false
				});
			}
		}),

		/**
		 * Called when the element is removed the document.
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 */
		detachedCallback: function () {
			this.attached = false;
		},

		/**
		 * Returns value for widget property based on attribute value in markup.
		 * @param {string} name - Name of widget property.
		 * @param {string} value - Value of attribute in markup.
		 * @private
		 */
		_parsePrototypeAttr: function (name, value) {
			// inner function useful to reduce cyclomatic complexity when using jshint
			function stringToObject(value) {
				var obj;

				try {
					// TODO: remove this code if it isn't being used, so we don't scare people that are afraid of eval.
					/* jshint evil:true */
					// This will only be executed when complex parameters are used in markup
					// <my-tag constraints="max: 3, min: 2"></my-tag>
					// This can be avoided by using such complex parameters only programmatically or by not using
					// them at all.
					// This is harmless if you make sure the JavaScript code that is passed to the attribute
					// is harmless.
					obj = eval("(" + (value[0] === "{" ? "" : "{") + value + (value[0] === "{" ? "" : "}") + ")");
				}
				catch (e) {
					throw new SyntaxError("Error in attribute conversion to object: " + e.message +
						"\nAttribute Value: '" + value + "'");
				}
				return obj;
			}

			switch (typeof this[name]) {
			case "string":
				return value;
			case "number":
				return value - 0;
			case "boolean":
				return value !== "false";
			case "object":
				// Try to interpret value as global variable, ex: store="myStore", array of strings
				// ex: "1, 2, 3", or expression, ex: constraints="min: 10, max: 100"
				return getObject(value) ||
					(this[name] instanceof Array ? (value ? value.split(/\s+/) : []) : stringToObject(value));
			case "function":
				return this.parseFunctionAttribute(value, []);
			}
		},

		/**
		 * Helper to parse function attribute in markup.  Unlike `_parsePrototypeAttr()`, does not require a
		 * corresponding widget property.  Functions can be specified as global variables or as inline javascript:
		 *
		 * ```html
		 * <my-widget funcAttr="globalFunction" on-click="console.log(event.pageX);">
		 * ```
		 *
		 * @param {string} value - Value of the attribute.
		 * @param {string[]} params - When generating a function from inline javascript, give it these parameter names.
		 * @protected
		 */
		parseFunctionAttribute: function (value, params) {
			/* jshint evil:true */
			// new Function() will only be executed if you have properties that are of function type in your widget
			// and that you use them in your tag attributes as follows:
			// <my-tag whatever="console.log(param)"></my-tag>
			// This can be avoided by setting the function programmatically or by not setting it at all.
			// This is harmless if you make sure the JavaScript code that is passed to the attribute is harmless.
			// Use Function.bind to get a partial on Function constructor (trick to call it with an array
			// of args instead list of args).
			return getObject(value) ||
				new (Function.bind.apply(Function, [undefined].concat(params).concat([value])))();
		},

		/**
		 * Helper for parsing declarative widgets.  Interpret a given attribute specified in markup, returning either:
		 *
		 * - `undefined`: ignore
		 * - `{prop: prop, value: value}`: set `this[prop] = value`
		 * - `{event: event, callback: callback}`: call `this.on(event, callback)`
		 *
		 * @param {string} name - Attribute name.
		 * @param {string} value - Attribute value.
		 * @protected
		 */
		parseAttribute: function (name, value) {
			var pcm = this._propCaseMap;
			if (name in pcm) {
				name =  pcm[name]; // convert to correct case for widget
				return {
					prop: name,
					value: this._parsePrototypeAttr(name, value)
				};
			} else if (/^on-/.test(name)) {
				return {
					event: name.substring(3),
					callback: this.parseFunctionAttribute(value, ["event"])
				};
			}
		},

		/**
		 * Parse declaratively specified attributes for widget properties and connects.
		 * @returns {Array} Info about the attributes and their values as returned by `parseAttribute()`.
		 * @private
		 */
		_mapAttributes: function () {
			var attr,
				idx = 0,
				parsedAttrs = [],
				attrsToRemove = [];

			while ((attr = this.attributes[idx++])) {
				var name = attr.name.toLowerCase();	// note: will be lower case already except for IE9
				var parsedAttr = this.parseAttribute(name, attr.value);
				if (parsedAttr) {
					parsedAttrs.push(parsedAttr);
					attrsToRemove.push(attr.name);
				}
			}

			// Remove attributes that were processed, but do it in a separate loop so we don't modify this.attributes
			// while we are looping through it.   (See CustomElement-attr.html test failure on IE10.)
			attrsToRemove.forEach(this.removeAttribute, this);

			return parsedAttrs;
		},

		/**
		 * Release resources used by this custom element and its descendants.
		 * After calling this method, the element can no longer be used,
		 * and should be removed from the document.
		 */
		destroy: function () {
			// Destroy descendants
			this.findCustomElements().forEach(function (w) {
				if (w.destroy) {
					w.destroy();
				}
			});

			if (this.parentNode) {
				this.parentNode.removeChild(this);
				this.detachedCallback();
			}
		},

		/**
		 * Emits a synthetic event of specified type, based on eventObj.
		 * @param {string} type - Name of event.
		 * @param {Object} [eventObj] - Properties to mix in to emitted event.  Can also contain
		 * `bubbles` and `cancelable` properties to control how the event is emitted.
		 * @param {Element} [node] - Element to emit event on, defaults to `this`.
		 * @returns {boolean} True if the event was *not* canceled, false if it was canceled.
		 * @example
		 * myWidget.emit("query-success", {});
		 * @protected
		 */
		emit: function (type, eventObj, node) {
			on.emit(node || this, type, eventObj);
		},

		/**
		 * Call specified function when event occurs.
		 *
		 * Note that the function is not run in any particular scope, so if (for example) you want it to run
		 * in the element's scope you must do `myCustomElement.on("click", myCustomElement.func.bind(myCustomElement))`.
		 *
		 * Note that `delite/Widget` overrides `on()` so that `on("focus", ...)` and `on("blur", ...) will trigger the
		 * listener when focus moves into or out of the widget, rather than just when the widget's root node is
		 * focused/blurred.  In other words, the listener is called when the widget is conceptually focused or blurred.
		 *
		 * @param {string} type - Name of event (ex: "click").
		 * @param {Function} func - Callback function.
		 * @param {Element} [node] - Element to attach handler to, defaults to `this`.
		 * @returns {Object} Handle with `remove()` method to cancel the event.
		 */
		on: function (type, func, node) {
			return on(node || this, type, func);
		},

		// Override Stateful#getPropsToObserve() because the way to get the list of properties to watch is different
		// than for a plain Stateful.  Especially since IE doesn't support prototype swizzling.
		getPropsToObserve: function () {
			return this._ctor._propsToObserve;
		},

		// Before deliver() runs, process any native properties (tabIndex, dir) etc. that may have been
		// set without the custom setter getting called.
		deliver: dcl.before(function () {
			this._processNativeProps();
		}),

		/**
		 * Search subtree under root returning custom elements found.
		 * @param {Element} [root] - Node to search under.
		 */
		findCustomElements: function (root) {
			var outAry = [];

			function getChildrenHelper(root) {
				for (var node = root.firstChild; node; node = node.nextSibling) {
					if (node.nodeType === 1 && node.createdCallback) {
						outAry.push(node);
					} else {
						getChildrenHelper(node);
					}
				}
			}

			getChildrenHelper(root || this);
			return outAry;
		}
	});

	// Setup automatic chaining for lifecycle methods.
	// destroy() is chained in Destroyable.js.
	dcl.chainAfter(CustomElement, "createdCallback");
	dcl.chainAfter(CustomElement, "attachedCallback");
	dcl.chainBefore(CustomElement, "detachedCallback");

	return CustomElement;
});
;
/** @module delite/on */
define('delite/on',[],function () {
	/**
	 * Call specified function when event occurs.
	 * @param {Element} [node] - Element to attach handler to.
	 * @param {string} type - Name of event (ex: "click").
	 * @param {Function} callback - Callback function.
	 * @returns {Object} Handle with `remove()` method to cancel the listener.
	 */
	var on = function (node, type, callback) {
		var capture = false;

		// Shim support for focusin/focusout where necessary.
		// Don't shim on IE since IE supports focusin/focusout natively, and conversely
		// focus and blur events have a problem that relatedTarget isn't set.
		var captures = "onfocusin" in node ? {} : { focusin: "focus", focusout: "blur" };
		if (type in captures) {
			type = captures[type];
			capture = true;
		}

		// Shim support for Event.key, and fix some wrong/outdated Event.key values
		if (/^key(down|press|up)$/.test(type)) {
			var origFunc = callback;
			callback = function (event) {
				var key = event.key || event.keyIdentifier || String.fromCharCode(event.charCode);

				var fixedKey = {
					// mappings for event.keyIdentifier differences from event.key for special keys
					"U+0020": "Spacebar",
					"U+0008": "Backspace",
					"U+0009": "Tab",
					"U+001B": "Escape",

					// fix for FF 34
					" ": "Spacebar",

					// fix for old key names, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=22084
					"Apps": "ContextMenu",
					"Left": "ArrowLeft",
					"Down": "ArrowDown",
					"Right": "ArrowRight",
					"Up": "ArrowUp",
					"Del": "Delete",
					"Esc": "Escape",

					// fix for Android 4.2
					"U+00007F": "Backspace"
				}[key] || key.replace(/^U\+0*(.*)$/, function (all, hexString) {
					// fix event.keyIdentifier for normal printable characters, ex: "U+0041" --> "A" or "a"
					var code = parseInt(hexString, 16);
					if (code >= 65 && code <= 90 && !event.shiftKey) {
						code += 32;	// uppercase --> lowercase
					}
					return String.fromCharCode(code);
				});

				if (event.key !== fixedKey) {
					// A simple "event.key = fixedKey" doesn't work on FF31 (for " " --> "Spacebar" conversion).
					// And Object.defineProperty(event, "key", {value: fixedKey}); (for "Down" --> "ArrowDown")
					// doesn't work on IE.
					Object.defineProperty(event, "key", {get: function () { return fixedKey; }});
				}

				origFunc(event);
			};
		}

		node.addEventListener(type, callback, capture);

		return {
			remove: function () {
				node.removeEventListener(type, callback, capture);
			}
		};
	};


	/**
	 * Emits a synthetic event of specified type, based on eventObj.
	 * @param {Element} node - Element to emit event on.
	 * @param {string} type - Name of event.
	 * @param {Object} [eventObj] - Properties to mix in to emitted event.  Can also contain
	 * `bubbles` and `cancelable` properties to control how the event is emitted.
	 * @returns {boolean} True if the event was *not* canceled, false if it was canceled.
	 * @example
	 * myWidget.emit("query-success", {});
	 * @protected
	 */
	on.emit = function (node, type, eventObj) {
		eventObj = eventObj || {};
		var bubbles = "bubbles" in eventObj ? eventObj.bubbles : true;
		var cancelable = "cancelable" in eventObj ? eventObj.cancelable : true;

		// Note: can't use jQuery.trigger() because it doesn't work with addEventListener(),
		// see http://bugs.jquery.com/ticket/11047.
		var nativeEvent = node.ownerDocument.createEvent("HTMLEvents");
		nativeEvent.initEvent(type, bubbles, cancelable);
		for (var i in eventObj) {
			if (!(i in nativeEvent)) {
				nativeEvent[i] = eventObj[i];
			}
		}

		return node.dispatchEvent(nativeEvent);
	};

	return on;
});
;
/** @module decor/Stateful */
define('decor/Stateful',[
	"dcl/advise",
	"dcl/dcl",
	"./features",
	"./Observable"
], function (advise, dcl, has, Observable) {
	var apn = {};

	/**
	 * Helper function to map "foo" --> "_setFooAttr" with caching to avoid recomputing strings.
	 */
	function propNames(name) {
		if (apn[name]) {
			return apn[name];
		}
		var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function (c) {
			return c.charAt(c.length - 1).toUpperCase();
		});
		var ret = apn[name] = {
			p: "_shadow" + uc + "Attr",	// shadow property, since real property hidden by setter/getter
			s: "_set" + uc + "Attr",	// converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
			g: "_get" + uc + "Attr"
		};
		return ret;
	}

	/**
	 * Utility function for notification.
	 */
	function notify(stateful, name, oldValue) {
		Observable.getNotifier(stateful).notify({
			// Property is never new because setting up shadow property defines the property
			type: "update",
			object: stateful,
			name: name + "",
			oldValue: oldValue
		});
	}

	var REGEXP_IGNORE_PROPS = /^constructor$|^_set$|^_get$|^deliver$|^discardChanges$|^_(.+)Attr$/;

	/**
	 * Base class for objects that provide named properties with optional getter/setter
	 * control and the ability to observe for property changes.
	 *
	 * The class also provides the functionality to auto-magically manage getters
	 * and setters for class attributes/properties.  Note though that expando properties
	 * (i.e. properties added to an instance but not in the prototype) are not supported.
	 *
	 * Getters and Setters should follow the format of `_setXxxAttr` or `_getXxxAttr` where
	 * the xxx is a name of the attribute to handle.  So an attribute of `foo`
	 * would have a custom getter of `_getFooAttr` and a custom setter of `_setFooAttr`.
	 * Setters must save and announce the new property value by calling `this._set("foo", val)`,
	 * and getters should access the property value as `this._get("foo")`.
	 *
	 * @example <caption>Example 1</caption>
	 * var MyClass = dcl(Stateful, { foo: "initial" });
	 * var obj = new MyClass();
	 * obj.observe(function(oldValues){
	 *    if ("foo" in oldValues) {
	 *      console.log("foo changed to " + this.foo);
	 *    }
	 * });
	 * obj.foo = bar;
	 * // Stateful by default interprets the first parameter passed to
	 * // the constructor as a set of properties to set on the widget 
	 * // immediately after it is created.
	 *
	 * @example <caption>Example 2</caption>
	 * var MyClass = dcl(Stateful, { foo: "initial" });
	 * var obj = new MyClass({ foo: "special"});
	 *
	 * @mixin module:decor/Stateful
	 */
	var Stateful = dcl(null, /** @lends module:decor/Stateful# */ {
		/**
		 * Returns a hash of properties that should be observed.
		 * @returns {Object} Hash of properties.
		 * @protected
		 */
		getProps: function () {
			var hash = {};
			for (var prop in this) {
				if (!REGEXP_IGNORE_PROPS.test(prop)) {
					hash[prop] = true;
				}
			}
			return hash;
		},

		/**
		 * Sets up ES5 getters/setters for each class property.
		 * Inside introspect(), "this" is a reference to the prototype rather than any individual instance.
		 * @param {Object} props - Hash of properties.
		 * @protected
		 */
		introspect: function (props) {
			Object.keys(props).forEach(function (prop) {
				var names = propNames(prop),
					shadowProp = names.p,
					getter = names.g,
					setter = names.s;

				// Setup ES5 getter and setter for this property, if not already setup.
				// For a property named foo, saves raw value in _fooAttr.
				// ES5 setter intentionally does late checking for this[names.s] in case a subclass sets up a
				// _setFooAttr method.
				if (!(shadowProp in this)) {
					this[shadowProp] = this[prop];
					delete this[prop]; // make sure custom setters fire
					Object.defineProperty(this, prop, {
						enumerable: true,
						set: function (x) {
							setter in this ? this[setter](x) : this._set(prop, x);
						},
						get: function () {
							return getter in this ? this[getter]() : this[shadowProp];
						}
					});
				}
			}, this);
		},

		constructor: dcl.advise({
			before: function () {
				// First time this class is instantiated, introspect it.
				// Use _introspected flag on constructor, rather than prototype, to avoid hits when superclass
				// was already inspected but this class wasn't.
				var ctor = this.constructor;
				if (!ctor._introspected) {
					// note: inside getProps() and introspect(), this refs prototype
					ctor._props = ctor.prototype.getProps();
					ctor.prototype.introspect(ctor._props);
					ctor._introspected = true;
				}
				Observable.call(this);
			},

			after: function (args) {
				// Automatic setting of params during construction.
				// In after() advice so that it runs after all the subclass constructor methods.
				this.processConstructorParameters(args);
			}
		}),

		/**
		 * Called after Object is created to process parameters passed to constructor.
		 * @protected
		 */
		processConstructorParameters: function (args) {
			if (args.length) {
				this.mix(args[0]);
			}
		},

		/**
		 * Set a hash of properties on a Stateful instance.
		 * @param {Object} hash - Hash of properties.
		 * @example
		 * myObj.mix({
		 *     foo: "Howdy",
		 *     bar: 3
		 * });
		 */
		mix: function (hash) {
			for (var x in hash) {
				if (hash.hasOwnProperty(x)) {
					this[x] = hash[x];
				}
			}
		},

		/**
		 * Internal helper for directly setting a property value without calling the custom setter.
		 *
		 * Directly changes the value of an attribute on an object, bypassing any
		 * accessor setter.  Also notifies callbacks registered via observe().
		 * Custom setters should call `_set` to actually record the new value.
		 * @param {string} name - The property to set.
		 * @param {*} value - Value to set the property to.
		 * @protected
		 */
		_set: function (name, value) {
			var shadowPropName = propNames(name).p,
				oldValue = this[shadowPropName];
			this[shadowPropName] = value;
			// Even if Object.observe() is natively available,
			// automatic change record emission won't happen if there is a ECMAScript setter
			!Observable.is(value, oldValue) && notify(this, name, oldValue);
		},

		/**
		 * Internal helper for directly accessing an attribute value.
		 *
		 * Directly gets the value of an attribute on an object, bypassing any accessor getter.
		 * It is designed to be used by descendant class if they want
		 * to access the value in their custom getter before returning it.
		 * @param {string} name - Name of property.
		 * @returns {*} Value of property.
		 * @protected
		 */
		_get: function (name) {
			return this[propNames(name).p];
		},

		/**
		 * Notifies current values to observers for specified property name(s).
		 * Handy to manually schedule invocation of observer callbacks when there is no change in value.
		 * @method module:decor/Stateful#notifyCurrentValue
		 * @param {...string} name The property name.
		 */
		notifyCurrentValue: function () {
			Array.prototype.forEach.call(arguments, function (name) {
				notify(this, name, this[propNames(name).p]);
			}, this);
		},

		/**
		 * Get list of properties that Stateful#observe() should observe.
		 * @returns {string[]} list of properties
		 * @protected
		 */
		getPropsToObserve: function () {
			return this.constructor._props;
		},

		/**
		 * Observes for change in properties.
		 * Callback is called at the end of micro-task of changes with a hash table of
		 * old values keyed by changed property.
		 * Multiple changes to a property in a micro-task are squashed.
		 * @method module:decor/Stateful#observe
		 * @param {function} callback The callback.
		 * @returns {module:decor/Stateful.PropertyListObserver}
		 *     The observer that can be used to stop observation
		 *     or synchronously deliver/discard pending change records.
		 * @example
		 *     var stateful = new (dcl(Stateful, {
		 *             foo: undefined,
		 *             bar: undefined,
		 *             baz: undefined
		 *         }))({
		 *             foo: 3,
		 *             bar: 5,
		 *             baz: 7
		 *         });
		 *     stateful.observe(function (oldValues) {
		 *         // oldValues is {foo: 3, bar: 5, baz: 7}
		 *     });
		 *     stateful.foo = 4;
		 *     stateful.bar = 6;
		 *     stateful.baz = 8;
		 *     stateful.foo = 6;
		 *     stateful.bar = 8;
		 *     stateful.baz = 10;
		 */
		observe: function (callback) {
			// create new listener
			var h = new Stateful.PropertyListObserver(this, this.getPropsToObserve());
			h.open(callback, this);

			// make this.deliver() and this.discardComputing() call deliver() and discardComputing() on new listener
			var a1 = advise.after(this, "deliver", h.deliver.bind(h)),
				a2 = advise.after(this, "discardChanges", h.discardChanges.bind(h));
			advise.before(h, "close", function () {
				a1.unadvise();
				a2.unadvise();
			});

			return h;
		},

		/**
		 * Synchronously deliver change records to all listeners registered via `observe()`.
		 */
		deliver: function () {
		},

		/**
		 * Discard change records for all listeners registered via `observe()`.
		 */
		discardChanges: function () {
		}
	});

	dcl.chainAfter(Stateful, "introspect");

	/**
	 * An observer to observe a set of {@link module:decor/Stateful Stateful} properties at once.
	 * This class is what {@link module:decor/Stateful#observe} returns.
	 * @class module:decor/Stateful.PropertyListObserver
	 * @param {Object} o - The {@link module:decor/Stateful Stateful} being observed.
	 * @param {Object} props - Hash of properties to observe.
	 */
	Stateful.PropertyListObserver = function (o, props) {
		this.o = o;
		this.props = props;
	};

	Stateful.PropertyListObserver.prototype = {
		/**
		 * Starts the observation.
		 * {@link module:decor/Stateful#observe `Stateful#observe()`} calls this method automatically.
		 * @method module:decor/Stateful.PropertyListObserver#open
		 * @param {function} callback The change callback.
		 * @param {Object} thisObject The object that should work as "this" object for callback.
		 */
		open: function (callback, thisObject) {
			var props = this.props;
			this._boundCallback = function (records) {
				if (!this._closed && !this._beingDiscarded) {
					var oldValues = {};
					records.forEach(function (record) {
						// for consistency with platforms w/out native Object.observe() support,
						// only notify about updates to properties in prototype (see getProps())
						if (record.name in props && !(record.name in oldValues)) {
							oldValues[record.name] = record.oldValue;
						}
					});
					/* jshint unused: false */
					for (var s in oldValues) {
						callback.call(thisObject, oldValues);
						break;
					}
				}
			}.bind(this);
			this._h = Observable.observe(this.o, this._boundCallback);
			return this.o;
		},

		/**
		 * Synchronously delivers pending change records.
		 * @method module:decor/Stateful.PropertyListObserver#deliver
		 */
		deliver: function () {
			this._boundCallback && Observable.deliverChangeRecords(this._boundCallback);
		},

		/**
		 * Discards pending change records.
		 * @method module:decor/Stateful.PropertyListObserver#discardChanges
		 */
		discardChanges: function () {
			this._beingDiscarded = true;
			this._boundCallback && Observable.deliverChangeRecords(this._boundCallback);
			this._beingDiscarded = false;
			return this.o;
		},

		/**
		 * Does nothing, just exists for API compatibility with liaison and other data binding libraries.
		 * @method module:decor/Stateful.PropertyListObserver#setValue
		 */
		setValue: function () {},

		/**
		 * Stops the observation.
		 * @method module:decor/Stateful.PropertyListObserver#close
		 */
		close: function () {
			if (this._h) {
				this._h.remove();
				this._h = null;
			}
			this._closed = true;
		}
	};

	/**
	 * Synonym for {@link module:decor/Stateful.PropertyListObserver#close `close()`}.
	 * @method module:decor/Stateful.PropertyListObserver#remove
	 */
	Stateful.PropertyListObserver.prototype.remove = Stateful.PropertyListObserver.prototype.close;

	return Stateful;
});
;
/** @module decor/Destroyable */
define('decor/Destroyable',[
	"dcl/advise",
	"dcl/dcl"
], function (advise, dcl) {
	/**
	 * Mixin to track handles and release them when instance is destroyed.
	 *
	 * Call `this.own(...)` on list of handles (returned from dcl/advise, dojo/on,
	 * decor/Stateful#observe, or any class (including widgets) with a destroy() or remove() method.
	 * Then call `destroy()` later to destroy this instance and release the resources.
	 * @mixin module:decor/Destroyable
	 */
	var Destroyable = dcl(null, /** @lends module:decor/Destroyable# */ {
		/**
		 * Destroy this class, releasing any resources registered via `own()`.
		 * @method
		 */
		destroy: dcl.advise({
			before: function () {
				this._beingDestroyed = true;
				this._releaseHandles();
			},
			after: function () {
				this._destroyed = true;
			}
		}),

		_releaseHandles: function () {
		},

		/**
		 * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
		 * already removed/destroyed manually.
		 * @returns {Object[]} The array of specified handles, so you can do for example:
		 * `var handle = this.own(on(...))[0];`
		 * @protected
		 */
		own: function () {
			var cleanupMethods = [
				"destroy",
				"remove",
				"cancel"
			];

			// transform arguments into an Array
			var ary = Array.prototype.slice.call(arguments);
			ary.forEach(function (handle) {
				// When this.destroy() is called, destroy handle.  Since I'm using advise.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = advise.after(this, "_releaseHandles", function () {
					handle[destroyMethodName]();
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];

				function onManualDestroy() {
					odh.destroy();
					hdhs.forEach(function (hdh) {
						hdh.destroy();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also compute destroyMethodName, used in listener above.
				if (handle.then) {
					// Special path for Promises.  Detect when Promise is settled.
					handle.then(onManualDestroy, onManualDestroy);
				}
				cleanupMethods.forEach(function (cleanupMethod) {
					if (typeof handle[cleanupMethod] === "function") {
						if (!destroyMethodName) {
							// Use first matching method name in above listener.
							destroyMethodName = cleanupMethod;
						}
						if (!handle.then) {
							// Path for non-promises.  Use AOP to detect when handle is manually destroyed.
							hdhs.push(advise.after(handle, cleanupMethod, onManualDestroy));
						}
					}
				});
			}, this);

			return ary;
		},

		/**
		 * Wrapper to setTimeout to avoid deferred functions executing
		 * after the originating widget has been destroyed.
		 * @param {Function} fcn - Function to be executed after specified delay (or 0ms if no delay specified).
		 * @param {number} delay - Delay in ms, defaults to 0.
		 * @returns {Object} Handle with a remove method that deschedules the callback from being called.
		 * @protected
		 */
		defer: function (fcn, delay) {
			// TODO: if delay unspecified, use schedule?
			var timer = setTimeout(
				function () {
					if (!timer) {
						return;
					}
					timer = null;
					if (!this._destroyed) {
						fcn.call(this);
					}
				}.bind(this),
					delay || 0
			);
			return {
				remove: function () {
					if (timer) {
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	dcl.chainBefore(Destroyable, "destroy");

	return Destroyable;
});
;
define('delite/handlebars!deliteful/ProgressBar/ProgressBar.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template role=\"progressbar\">\n\t<div class=\"d-progress-bar-background\">\n\t\t<div class=\"d-progress-bar-msg\" attach-point=\"msgNode\"></div>\n\t\t<div class=\"d-progress-bar-indicator\" attach-point=\"indicatorNode\">\n\t\t\t<div class=\"d-progress-bar-msg-invert\" attach-point=\"msgInvertNode\"></div>\n\t\t\t<div class=\"d-progress-bar-a11y\"></div>\n\t\t</div>\n\t</div>\n</template>");
});;
/** @module deliteful/ProgressBar */
define('deliteful/ProgressBar',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",
	"ecma402/IntlShim",
	"delite/register",
	"delite/Widget",
	"delite/handlebars!./ProgressBar/ProgressBar.html",
	"delite/theme!./ProgressBar/themes/{{theme}}/ProgressBar.css"
], function (dcl, $, Intl, register, Widget, template) {
	/**
	 * A widget that displays the completion progress of a task.
	 *
	 * The progress is either indeterminate, indicating that progress is being made but that it is not clear how
	 * much more work remains to be done before the task is complete, or the progress is a number in the range
	 * zero to a maximum, giving the fraction of work that has so far been completed.
	 *
	 * There are two properties that determine the current task completion represented by the element. The value
	 * property specifies how much of the task has been completed, and the max property specifies how much work
	 * the task requires in total. The units are arbitrary and not specified.
	 *
	 * When the progress bar is determinate, a default message displays the percentage of progression.
	 * The property fractionDigits allows to specify the number of fraction digits to display. You can set a custom
	 * message using the message property, or override the method formatMessage to generate a dynamic custom message.
	 *
	 * When the progress bar is indeterminate, use the message property to display a message.
	 *
	 * @class module:deliteful/ProgressBar
	 * @augments module:delite/Widget
	 */
	return register("d-progress-bar", [HTMLElement, Widget], /** @lends module:deliteful/ProgressBar# */{

		/**
		 * A number indicating the amount of completion of a task.
		 * The value property must be a valid floating-point number or NaN. Set the value to NaN to make the
		 * progress bar indeterminate. Set a value comprised between 0 and the max property to make
		 * the progress bar determinate. A value greater than max is converted to the max value. An invalid or
		 * negative value is converted to 0.
		 * @member {number}
		 * @default NaN
		 */
		value: NaN,

		/**
		 * A number which express the task as completed.
		 * The max property must be a valid positive floating-point number, otherwise it is converted to 1.0.
		 * @member {number}
		 * @default 1.0
		 */
		max: 1.0,

		/**
		 * Indicates the relative position of the current value relative to the maximum value (max).
		 * If the progress bar is an indeterminate progress bar, then the position is 1. Otherwise, it is the result
		 * of dividing the current value by the maximum value.
		 * @member {number}
		 * @default -1
		 * @readonly
		 */
		position: -1,

		/**
		 * Allow to specify/override the message on the progress bar whether it's determinate or indeterminate.
		 * The default behavior of the ProgressBar is to  displays the percentage of completion when the state
		 * is determinate, and to display no message when state is indeterminate. You can override this with the
		 * message property. Set an empty string to restore the default behavior.
		 * @member {string}
		 * @default ""
		 */
		message: "",

		/**
		 * Allow to set an additional message.
		 * Depending on the theme it may not be displayed. For themes that display
		 * both messages, typically message is on one side and the additional message is on the other side. By default
		 * the additional message is in the form value/max. Ex: [65%........379/583] or [Loading......379/583]. You may
		 * customize it by overriding the method formatExtMsg.
		 * @member {boolean}
		 * @default false
		 */
		displayExtMsg: false,

		/**
		 * Number of places to show on the default message displayed when the progress bar is determinate.
		 * @member {number}
		 * @default 0
		 */
		fractionDigits: 0,

		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-progress-bar"
		 */
		baseClass: "d-progress-bar",

		template: template,

		postRender: function () {
			// TODO: move this code to the template
			this.setAttribute("aria-valuemin", 0);
		},

		computeProperties: function (props) {
			if ("max" in props) {
				var newMax = this._convert2Float(this.max, 1.0);
				if (newMax <= 0) {
					newMax = 1.0;
				}
				if (newMax !== this.max) {
					this.max = newMax;
				}
			}
			if ("value" in props && !isNaN(this.value)) {
				var newValue = this._convert2Float(this.value, 0);
				newValue = Math.max(0, Math.min(this.max, newValue));
				if (newValue !== this.value) {
					this.value = newValue;
				}
			}
			this.position = isNaN(this.value) ? -1 : this.value / this.max;
		},

		refreshRendering: function (props) {
			//update widget to reflect value/max changes
			if ("max" in props) {
				// TODO: move to template
				this.setAttribute("aria-valuemax", this.max);
			}
			if ("value" in props || "max" in props) {
				if (this.position === -1) { //indeterminate state
					this.indicatorNode.style.removeProperty("width");
					this.removeAttribute("aria-valuenow");
				} else {
					this.indicatorNode.style.width = (this.position * 100) + "%";
					this.msgInvertNode.style.width =
						window.getComputedStyle(this.msgNode).getPropertyValue("width");
					this.setAttribute("aria-valuenow", this.value);
				}
			}

			//update widget message
			this.msgNode.innerHTML = this.msgInvertNode.innerHTML =
				this.formatMessage(this.position, this.value, this.max);
			var hasExtMsg = this.displayExtMsg && this.position !== -1;
			$(this.msgNode).toggleClass(this.baseClass + "-msg-ext", hasExtMsg);
			if (hasExtMsg) {
				//set content value to be used by pseudo element d-progress-bar-msg-ext::after
				this.msgNode.setAttribute("msg-ext", this.formatExtMsg(this.position, this.value, this.max));
			} else {
				this.msgNode.removeAttribute("msg-ext");
			}
			//aria text only on indeterminate state with custom message
			if (this.message && this.position === -1) {
				this.setAttribute("aria-valuetext", this.message);
			} else {
				this.removeAttribute("aria-valuetext");
			}
			$(this).toggleClass(this.baseClass + "-indeterminate", (this.position === -1));
		},

		/**
		 * Formats and returns a message to display inside/beside the progress bar (depends on theme settings).
		 * If a custom message is specified with the message property, it is returned as-is. Otherwise if the
		 * progress bar is determined (value is not NaN), it returns the percentage of progression formatted in
		 * respect with fractionDigits. This method is called when the value and/or the max property changes. May be
		 * overridden to customize the message.
		 *
		 * @param {number} position -  Position of the current value relative to the maximum value (from 0.0 to 1.0).
		 * @param {number} value - The amount of completion of the task.
		 * @param {number} max - The value that express the task is completed (maximum value).
		 * @returns {string} The message to display.
		 */
		formatMessage: function (position, value, /*jshint unused: vars */max) {
			if (!this._numberFormat || this._prevLang !== this.lang ||
				this._numberFormat.resolvedOptions().minimumFractionDigits !== this.fractionDigits) {
				var options = {
					style: "percent",
					minimumFractionDigits: this.fractionDigits,
					maximumFractionDigits: this.fractionDigits
				};
				this._numberFormat = new Intl.NumberFormat(this.lang || undefined, options);
				this._prevLang = this.lang;
			}
			return this.message ? this.message : (isNaN(value) ? "" : this._numberFormat.format(position));
		},

		/**
		 * Formats and returns the extra message to display when the property displayExtMsg is enabled.
		 * Returns a string formatted with "value/max". May be overridden to customize the extra message.
		 *
		 * @param {number} position Position of the current value relative to the maximum value (from 0.0 to 1.0).
		 * @param {number} value The amount of completion of the task.
		 * @param {number} max The value that express the task is completed (maximum value).
		 * @returns {string} The extra message to display.
		 */
		formatExtMsg: function (position, value, max) {
			return value + "/" + max;
		},

		/*
		 * Converts a value to a valid floating-point numbers.
		 * The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.
		 *
		 * @param value - The value to convert
		 * @param fallbackValue - The value to assign if the conversion fails.
		 * @returns {Number}
		 * @private
		 */
		_convert2Float: function (value, fallbackValue) {
			var v = parseFloat(value);
			if (isNaN(v) || v === Infinity) {
				v = fallbackValue;
			}
			return v;
		}
	});
});
;
/* global Intl */
/**
  * Shim for native vs. ecma402 package implementation of the Intl object.
  * By default, using IntlShim will leverage any support for Intl that exists
  * natively in the browser.  If the browser does not have support for Intl,
  * then the JavaScript implementation from this package is used instead.
  * 
  * Loads ./Intl.js only if necessary
  * 
  * @constructor
  */
define('ecma402/IntlShim',["./features!intl-api?:./Intl"], function (IntlShim) {
	return IntlShim || Intl;
});
;
define('requirejs-text/text!ecma402/cldr/supplemental/currencyData.json',[],function () { return '{\n  "supplemental": {\n    "currencyData": {\n      "fractions": {\n        "ADP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "AFN": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ALL": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "AMD": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "BHD": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "BIF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "BYR": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "CAD": {\n          "_rounding": "0",\n          "_digits": "2",\n          "_cashRounding": "5"\n        },\n        "CHF": {\n          "_rounding": "0",\n          "_digits": "2",\n          "_cashRounding": "5"\n        },\n        "CLF": {\n          "_rounding": "0",\n          "_digits": "4"\n        },\n        "CLP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "COP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "CRC": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "CZK": {\n          "_rounding": "0",\n          "_digits": "2",\n          "_cashDigits": "0",\n          "_cashRounding": "0"\n        },\n        "DEFAULT": {\n          "_rounding": "0",\n          "_digits": "2"\n        },\n        "DJF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ESP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "GNF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "GYD": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "HUF": {\n          "_rounding": "0",\n          "_digits": "2",\n          "_cashDigits": "0",\n          "_cashRounding": "0"\n        },\n        "IDR": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "IQD": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "IRR": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ISK": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ITL": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "JOD": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "JPY": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "KMF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "KPW": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "KRW": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "KWD": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "LAK": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "LBP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "LUF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "LYD": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "MGA": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "MGF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "MMK": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "MNT": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "MRO": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "MUR": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "OMR": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "PKR": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "PYG": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "RSD": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "RWF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "SLL": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "SOS": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "STD": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "SYP": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "TMM": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "TND": {\n          "_rounding": "0",\n          "_digits": "3"\n        },\n        "TRL": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "TWD": {\n          "_rounding": "0",\n          "_digits": "2",\n          "_cashDigits": "0",\n          "_cashRounding": "0"\n        },\n        "TZS": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "UGX": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "UYI": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "UZS": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "VND": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "VUV": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "XAF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "XOF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "XPF": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "YER": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ZMK": {\n          "_rounding": "0",\n          "_digits": "0"\n        },\n        "ZWD": {\n          "_rounding": "0",\n          "_digits": "0"\n        }\n      }\n    }\n  }\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/timeData.json',[],function () { return '{\n  "supplemental": {\n    "timeData": {\n      "001": {\n        "_allowed": "H h",\n        "_preferred": "H"\n      },\n      "AD": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "AE": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "AG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "AL": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "AM": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "AO": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "AS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "AT": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "AU": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "AW": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "AX": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BB": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BD": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BF": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BH": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BJ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BL": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BN": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BQ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BR": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "BS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BT": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "BW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "CA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "CD": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "CG": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "CI": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "CN": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "CO": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "CP": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "CV": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "CY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "CZ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "DE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "DJ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "DK": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "DM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "DZ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "EE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "EG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "EH": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ER": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ET": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "FI": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "FJ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "FM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "FR": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GA": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GD": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GF": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GH": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GL": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GN": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GP": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GR": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GU": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "GW": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "GY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "HK": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "HR": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "ID": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "IL": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "IN": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "IQ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "IS": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "IT": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "JM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "JO": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "JP": {\n        "_allowed": "H K h",\n        "_preferred": "H"\n      },\n      "KH": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KI": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KN": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KP": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KR": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "KY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "LB": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "LC": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "LR": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "LS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "LY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MC": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "MD": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "MF": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "MH": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ML": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "MO": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MP": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MQ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "MR": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "MZ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "NA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "NC": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "NE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "NG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "NL": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "NZ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "OM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "PG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "PK": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "PM": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "PR": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "PS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "PT": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "PW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "QA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "RE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "RO": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "RU": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SB": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SD": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SE": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SI": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SJ": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SK": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SL": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SM": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SO": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SR": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ST": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "SY": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "SZ": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "TC": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "TD": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "TG": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "TN": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "TR": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "TT": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "TW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "UM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "US": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "VC": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "VG": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "VI": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "VU": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "WF": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "WS": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "YE": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "YT": {\n        "_allowed": "H",\n        "_preferred": "H"\n      },\n      "ZA": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ZM": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      },\n      "ZW": {\n        "_allowed": "H h",\n        "_preferred": "h"\n      }\n    }\n  }\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/numberingSystems.json',[],function () { return '{\n  "supplemental": {\n    "numberingSystems": {\n      "arab": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "arabext": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "bali": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "beng": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "cham": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "deva": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "fullwide": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "gujr": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "guru": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "hanidec": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "java": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "kali": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "khmr": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "knda": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "lana": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "lanatham": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "laoo": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "latn": {\n        "_digits": "0123456789",\n        "_type": "numeric"\n      },\n      "lepc": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "limb": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "mlym": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "mong": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "mtei": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "mymr": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "mymrshan": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "nkoo": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "olck": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "orya": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "saur": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "sund": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "talu": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "tamldec": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "telu": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "thai": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "tibt": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "vaii": {\n        "_digits": "",\n        "_type": "numeric"\n      },\n      "armn": {\n        "_type": "algorithmic",\n        "_rules": "armenian-upper"\n      },\n      "armnlow": {\n        "_type": "algorithmic",\n        "_rules": "armenian-lower"\n      },\n      "ethi": {\n        "_type": "algorithmic",\n        "_rules": "ethiopic"\n      },\n      "geor": {\n        "_type": "algorithmic",\n        "_rules": "georgian"\n      },\n      "grek": {\n        "_type": "algorithmic",\n        "_rules": "greek-upper"\n      },\n      "greklow": {\n        "_type": "algorithmic",\n        "_rules": "greek-lower"\n      },\n      "hanidays": {\n        "_type": "algorithmic",\n        "_rules": "zh/SpelloutRules/spellout-numbering-days"\n      },\n      "hans": {\n        "_type": "algorithmic",\n        "_rules": "zh/SpelloutRules/spellout-cardinal"\n      },\n      "hansfin": {\n        "_type": "algorithmic",\n        "_rules": "zh/SpelloutRules/spellout-cardinal-financial"\n      },\n      "hant": {\n        "_type": "algorithmic",\n        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal"\n      },\n      "hantfin": {\n        "_type": "algorithmic",\n        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal-financial"\n      },\n      "hebr": {\n        "_type": "algorithmic",\n        "_rules": "hebrew"\n      },\n      "jpan": {\n        "_type": "algorithmic",\n        "_rules": "ja/SpelloutRules/spellout-cardinal"\n      },\n      "jpanfin": {\n        "_type": "algorithmic",\n        "_rules": "ja/SpelloutRules/spellout-cardinal-financial"\n      },\n      "roman": {\n        "_type": "algorithmic",\n        "_rules": "roman-upper"\n      },\n      "romanlow": {\n        "_type": "algorithmic",\n        "_rules": "roman-lower"\n      },\n      "taml": {\n        "_type": "algorithmic",\n        "_rules": "tamil"\n      }\n    }\n  }\n}\n';});
;
define('ecma402/Intl',[ "./impl/Record", "./impl/calendars", "./impl/common", "./locales!",
		"requirejs-text/text!./cldr/supplemental/currencyData.json",
		"requirejs-text/text!./cldr/supplemental/timeData.json",
		"requirejs-text/text!./cldr/supplemental/numberingSystems.json" ],
	function (Record, calendars, common, preloads,
			currencyDataJson, timeDataJson, numberingSystemsJson) {
			/**
			 * JavaScript implementation of internationalization APIs ("Intl") as defined by ECMA standard 402
			 * version 1.0, available for download at http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf
			 * 
			 * @constructor
			 */
			/*jshint maxcomplexity: 25*/
			var Intl = {};
			var currencyData = JSON.parse(currencyDataJson);
			var timeData = JSON.parse(timeDataJson).supplemental.timeData;
			var numberingSystems = JSON.parse(numberingSystemsJson).supplemental.numberingSystems;
			var availableNumberingSystems = [ "latn" ];
			for (var ns in numberingSystems) {
				if (numberingSystems[ns]._type === "numeric" && ns !== "latn") {
					availableNumberingSystems.push(ns);
				}
			}

			/**
			 * InitializeNumberFormat abstract operation as defined in ECMA-402 Section 11.1.1.1
			 * 
			 * @param {Object} numberFormat The object to be initialized as a NumberFormat object
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Number formatting options
			 * @private
			 */
			function _initializeNumberFormat(numberFormat, locales, options) {
				if (numberFormat.hasOwnProperty("initializedIntlObject") && numberFormat.initializedIntlObject) {
					throw new TypeError("NumberFormat is already initialized.");
				}
				numberFormat.initializedIntlObject = true;
				var requestedLocales = common.CanonicalizeLocaleList(locales);
				if (options === undefined) {
					options = {};
				} else {
					options = Object(options);
				}
				var opt = new Record();
				var matcher = common
						.GetOption(options, "localeMatcher", "string", [ "lookup", "best fit" ], "best fit");
				opt.set("localeMatcher", matcher);
				var r = common.ResolveLocale(NumberFormat.availableLocales, requestedLocales, opt,
						NumberFormat.relevantExtensionKeys, NumberFormat.localeData);
				numberFormat.locale = r.locale;
				numberFormat.dataLocale = r.dataLocale;
				numberFormat.numberingSystem = r.nu;
				var s = common.GetOption(options, "style", "string", [ "decimal", "percent", "currency" ], "decimal");
				numberFormat.style = s;
				var c = common.GetOption(options, "currency", "string");
				if (c !== undefined && !common.IsWellFormedCurrencyCode(c)) {
					throw new RangeError("Invalid currency code " + c);
				}
				if (s === "currency" && c === undefined) {
					throw new TypeError("No currency code specified.");
				}
				var cDigits = 2;
				if (s === "currency") {
					c = common._toUpperCaseIdentifier(c);
					numberFormat.currency = c;
					numberFormat.currencySymbol = c;
					numberFormat.currencyDisplayName = c;
					if (currencyData.supplemental.currencyData.fractions[c]) {
						cDigits = currencyData.supplemental.currencyData.fractions[c]._digits;
					}
				}
				var cd = common.GetOption(options, "currencyDisplay", "string", [ "code", "symbol", "name" ], "symbol");
				if (s === "currency") {
					numberFormat.currencyDisplay = cd;
					if (cd === "symbol" || cd === "name") {
						var curr = preloads[r.dataLocale].currencies.main[r.dataLocale].numbers.currencies;
						if (curr[numberFormat.currency]) {
							numberFormat.currencySymbol = curr[numberFormat.currency].symbol;
							numberFormat.currencyDisplayName = curr[numberFormat.currency].displayName;
						}
					}
				}
				var mnid = common.GetNumberOption(options, "minimumIntegerDigits", 1, 21, 1);
				numberFormat.minimumIntegerDigits = mnid;
				var mnfdDefault;
				if (s === "currency") {
					mnfdDefault = cDigits;
				} else {
					mnfdDefault = 0;
				}
				var mnfd = common.GetNumberOption(options, "minimumFractionDigits", 0, 20, mnfdDefault);
				numberFormat.minimumFractionDigits = mnfd;
				var mxfdDefault;
				if (s === "currency") {
					mxfdDefault = Math.max(mnfd, cDigits);
				} else if (s === "percent") {
					mxfdDefault = Math.max(mnfd, 0);
				} else {
					mxfdDefault = Math.max(mnfd, 3);
				}
				var mxfd = common.GetNumberOption(options, "maximumFractionDigits", mnfd, 20, mxfdDefault);
				numberFormat.maximumFractionDigits = mxfd;
				var mnsd = options.minimumSignificantDigits;
				var mxsd = options.maximumSignificantDigits;
				if (mnsd !== undefined || mxsd !== undefined) {
					mnsd = common.GetNumberOption(options, "minimumSignificantDigits", 1, 21, 1);
					mxsd = common.GetNumberOption(options, "maximumSignificantDigits", mnsd, 21, 1);
					numberFormat.minimumSignificantDigits = mnsd;
					numberFormat.maximumSignificantDigits = mxsd;
				}
				var g = common.GetOption(options, "useGrouping", "boolean", undefined, true);
				numberFormat.useGrouping = g;
				var numb = preloads[r.dataLocale].numbers.main[r.dataLocale].numbers;
				if (r.locale === r.dataLocale) {
					numberFormat.numberingSystem = numb.defaultNumberingSystem;
				}
				var numberInfo = _getNumberInfo(numb, numberFormat.numberingSystem);
				var stylePatterns = numberInfo.patterns[s];
				numberFormat.positivePattern = stylePatterns.positivePattern;
				numberFormat.negativePattern = stylePatterns.negativePattern;
				/*
				 * The CLDR number format pattern is necessary in order to do localized grouping properly, for example
				 * #,##,##0.00 grouping in India.
				 */
				numberFormat.cldrPattern = stylePatterns.cldrPattern;
				numberFormat.symbols = numberInfo.symbols;
				numberFormat.boundFormat = undefined;
				numberFormat.initializedNumberFormat = true;
			}

			/**
			 * Utility function to insert grouping separators into the proper locations in a string of digits based on
			 * the CLDR pattern string.
			 * 
			 * @param {String} n The string representing the number to be formatted
			 * @param {String} pattern The number formatting pattern (from CLDR)
			 * @returns {String} The formatted string
			 * @private
			 */
			function doGrouping(n, pattern) {
				var numExp = /[0-9#.,]+/;
				var number = numExp.exec(pattern)[0];
				var dPos = number.lastIndexOf(".");
				if (dPos !== -1) {
					number = number.substring(0, dPos);
				}
				var groupings = number.split(",");
				groupings.reverse();
				groupings.pop();
				var currentGrouping = groupings.shift();
				var ungroupedDigits = /^\d+/.exec(n);
				while (ungroupedDigits && ungroupedDigits[0].length > currentGrouping.length) {
					var digitsLeft = ungroupedDigits[0].length - currentGrouping.length;
					n = n.substr(0, digitsLeft) + "," + n.substring(digitsLeft);
					if (groupings.length > 0) {
						currentGrouping = groupings.shift();
					}
					ungroupedDigits = /^\d+/.exec(n);
				}
				return n;
			}
			/**
			 * Utility function to convert a string in scientific notation to a corresponding string of digits
			 * 
			 * @param {String} x The string to be converted
			 * @returns {String} The corresponding string of digits
			 * @private
			 */
			function _toDigitString(x) {
				var m = x;
				var negative = false;
				if (m.charAt(0) === "-") {
					negative = true;
					m = m.substring(1);
				}
				var parts = m.split("e");
				var mantissa = parts[0];
				var exponent = Number(parts[1]);
				if (exponent > 0) {
					m = mantissa.substr(0, 1) + mantissa.substr(2); // Get just the digits
					if (m.length - 1 < exponent) { // Need to add zeroes.
						var e = exponent + 1 - m.length;
						while (e > 0) {
							m = m + "0";
							e--;
						}
					} else if (m.length - 1 > exponent) {
						m = m.substr(0, exponent + 1) + "." + m.substr(exponent + 1);
					}
				} else if (exponent < 0) {
					var digits = mantissa.substr(0, 1) + mantissa.substr(2); // Get just the digits
					m = "0.";
					for (var i = exponent; i < -1; i++) {
						m += "0";
					}
					m += digits;
				}
				if (negative) {
					m = "-" + m;
				}
				return m;
			}
			/**
			 * ToRawPrecision abstract operation as defined in ECMA-402 Section 11.3.2
			 * 
			 * @param {Number} x The number being formatted
			 * @param {Number} minPrecision The minimum precision
			 * @param {Number} maxPrecision The maximum precision
			 * @returns {String} The string representing the formatted number
			 * @private
			 */
			function _toRawPrecision(x, minPrecision, maxPrecision) {
				var p = maxPrecision;
				var e;
				var m = "";
				var target;
				if (x === 0) {
					for (var i = 0; i < p; i++) {
						m += "0";
					}
					e = 0;
				} else {
					target = Math.pow(10, p - 1);
					if (x < target) {
						e = p - 1;
						while (x < target) {
							target /= 10;
							e--;
						}
					} else {
						target = Math.pow(10, p);
						e = p - 1;
						while (x >= target) {
							target *= 10;
							e++;
						}
					}
					m = x.toString();
					if (/e/.test(m)) {
						m = _toDigitString(m);
					}
					if (!/\./.test(m)) {
						m += ".";
					}
					for (i = 0; i < p; i++) {
						m += "0";
					}
					var placesToMove = p - 1 - e;
					var mi = m.indexOf(".");
					if (placesToMove > 0) {
						m = m.substr(0, mi) + m.substr(mi + 1, placesToMove) + "." + m.substr(mi + 1 + placesToMove, 1);
					}
					if (placesToMove < 0) {
						m = m.substr(0, p) + "." + m.substr(p, 1);
					}
					m = Math.round(m).toString();
				}
				if (e >= p) {
					for (i = 0; i < e - p + 1; i++) {
						m += "0";
					}
					return m;
				}
				if (e === p - 1) {
					return m;
				}
				if (e >= 0) {
					m = m.substr(0, e + 1) + "." + m.substr(e + 1, p - (e + 1));
				} else {
					var prefix = "0.";
					for (i = 0; i < -(e + 1); i++) {
						prefix += "0";
					}
					m = prefix + m;

				}
				if (/\./.test(m) && maxPrecision > minPrecision) {
					var cut = maxPrecision - minPrecision;
					while (cut > 0 && /0$/.test(m)) {
						m = m.substr(0, m.length - 1);
						cut--;
					}
					if (/\.$/.test(m)) {
						m = m.substr(0, m.length - 1);
					}
				}
				return m;
			}
			/**
			 * ToRawFixed abstract operation as defined in ECMA-402 Section 11.3.2
			 * 
			 * @param {Number} x The number being formatted
			 * @param {Number} minInteger The minimum number of integer digits
			 * @param {Number} minFraction The minimum number of fractional digits
			 * @param {Number} maxFraction The maximum number of fractional digits
			 * @returns {String} The string representing the formatted number
			 * @private
			 */
			function _toRawFixed(x, minInteger, minFraction, maxFraction) {
				var m;
				/*
				 * if x < 10^21, then we can use the standard built in function. Otherwise, Number.toFixed() is going to
				 * give us back a value in scientific notation, and we have to convert it back to a series of digits.
				 */
				if (Math.abs(x) < Math.pow(10, 21)) {
					m = x.toFixed(maxFraction).toString();
				} else {
					m = _toDigitString(x.toString());
					if (maxFraction > 0) {
						m += ".";
						for (var i = 0; i < maxFraction; i++) {
							m += "0";
						}
					}
				}
				var cut = maxFraction - minFraction;
				while (cut > 0 && /0$/.test(m)) {
					m = m.replace(/0$/, "");
					cut--;
				}
				if (/\.$/.test(m)) {
					m = m.replace(/\.$/, "");
				}
				var dPos = m.indexOf(".");
				var _int = dPos > 0 ? dPos : m.length;
				while (_int < minInteger) {
					m = "0" + m;
					_int++;
				}
				return m;
			}
			/**
			 * FormatNumber abstract operation as defined in ECMA-402 Section 11.3.2
			 * 
			 * @param {Object} numberFormat The number format object to use for formatting
			 * @param {Number} x The number being formatted
			 * @returns {String} The string representing the formatted number
			 * @private
			 */
			function _formatNumber(numberFormat, x) {
				var negative = (x < 0);
				var n;
				if (!isFinite(x)) {
					if (isNaN(x)) {
						n = numberFormat.symbols.nan;
					} else {
						n = numberFormat.symbols.infinity;
					}
				} else {
					if (negative) {
						x = -x;
					}
					if (numberFormat.style === "percent") {
						x *= 100;
					}
					if (numberFormat.minimumSignificantDigits !== undefined
							&& numberFormat.maximumSignificantDigits !== undefined) {
						n = _toRawPrecision(x, numberFormat.minimumSignificantDigits,
								numberFormat.maximumSignificantDigits);
					} else {
						n = _toRawFixed(x, numberFormat.minimumIntegerDigits, numberFormat.minimumFractionDigits,
								numberFormat.maximumFractionDigits);
					}
					if (numberFormat.useGrouping) {
						n = doGrouping(n, numberFormat.cldrPattern);
					}
					if (numberFormat.numberingSystem !== undefined && numberFormat.numberingSystem !== "latn") {
						var alldigits = /\d/g;
						n = n.replace(alldigits, function (m) {
							return numberingSystems[numberFormat.numberingSystem]._digits.charAt(m);
						});
					}
					n = n.replace(/[.,]/g, function (m) {
						if (m === ".") {
							return numberFormat.symbols.decimal ? numberFormat.symbols.decimal : m;
						}
						return numberFormat.symbols.group ? numberFormat.symbols.group : m;
					});
				}
				var result = numberFormat.positivePattern;
				if (negative) {
					result = numberFormat.negativePattern;
				}
				if (result) {
					result = result.replace("-", numberFormat.symbols.minusSign);
					result = result.replace("%", numberFormat.symbols.percentSign);
					result = result.replace("{number}", n);
					if (numberFormat.style === "currency") {
						var currency = numberFormat.currency;
						var cd = currency;
						if (numberFormat.currencyDisplay === "symbol") {
							cd = numberFormat.currencySymbol;
						} else if (numberFormat.currencyDisplay === "name") {
							cd = numberFormat.currencyDisplayName;
						}
						result = result.replace("{currency}", cd);
					}
				}
				return result;
			}

			/**
			 * Utility function to retrive necessary number fields from the CLDR data
			 * 
			 * @param {Object} numbers The JSON object containing numbers data from CLDR
			 * @param {String} numberingSystem The numbering system being used
			 * @returns {Object} An object containing the number symbols and formatting patterns
			 * @private
			 */
			function _getNumberInfo(numbers, numberingSystem) {
				var result = {};
				result.symbols = {};
				var numberExp = /[0-9#.,]+/;
				var key = "symbols-numberSystem-" + numberingSystem;
				var altkey = "symbols-numberSystem-latn";
				var cldrSymbols = numbers[key] ? numbers[key] : numbers[altkey];
				result.symbols = cldrSymbols;

				result.patterns = {};
				var styles = [ "decimal", "percent", "currency" ];
				for (var s in styles) {
					var style = styles[s];
					key = style + "Formats-numberSystem-" + numberingSystem;
					altkey = style + "Formats-numberSystem-latn";
					var cldrPattern = numbers[key] ? numbers[key].standard : numbers[altkey].standard;
					var patterns = cldrPattern.split(";");
					var positivePattern, negativePattern;
					positivePattern = patterns[0];
					if (patterns[length] === 2) {
						negativePattern = patterns[1];
					} else {
						negativePattern = "-" + positivePattern;
					}
					positivePattern = positivePattern.replace(numberExp, "{number}").replace(/\u00A4/, "{currency}");
					negativePattern = negativePattern.replace(numberExp, "{number}").replace(/\u00A4/, "{currency}");
					result.patterns[style] = {
						"cldrPattern" : cldrPattern,
						"positivePattern" : positivePattern,
						"negativePattern" : negativePattern
					};
				}
				return result;
			}

			/**
			 * ToDateTimeOptions abstract operation as defined in ECMA-402 Section 12.1.1.1
			 * 
			 * @param {Object} options The number format object to use for formatting
			 * @param {String} required String indicating which options are required
			 * @param {String} defaults String indicating which options can use defaults
			 * @returns {Object} The corresponding date/time options
			 * @private
			 */
			function _toDateTimeOptions(options, required, defaults) {
				if (options === undefined) {
					options = null;
				} else {
					options = Object(options);
				}
				options = Object.create(options);
				var weekdayFields = [ "weekday", "year", "month", "day" ];
				var dateFields = [ "year", "month", "day" ];
				var timeFields = [ "hour", "minute", "second" ];

				var needDefaults = true;
				if (required === "date" || required === "any") {
					weekdayFields.forEach(function (field) {
						if (options[field] !== undefined) {
							needDefaults = false;
						}
					});
				}
				if (required === "time" || required === "any") {
					timeFields.forEach(function (field) {
						if (options[field] !== undefined) {
							needDefaults = false;
						}
					});
				}
				if (needDefaults && (defaults === "date" || defaults === "all")) {
					dateFields.forEach(function (field) {
						Object.defineProperty(options, field, {
							value : "numeric",
							writable : true,
							configurable : true,
							enumerable : true
						});
					});
				}
				if (needDefaults && (defaults === "time" || defaults === "all")) {
					timeFields.forEach(function (field) {
						Object.defineProperty(options, field, {
							value : "numeric",
							writable : true,
							configurable : true,
							enumerable : true
						});
					});
				}
				return options;
			}
			/**
			 * BasicFormatMatcher abstract operation as defined in ECMA-402 Section 12.1.1.1
			 * 
			 * @param {Object} options The requested options (i.e. fields) to be included in the date/time format
			 * @param {Object []} formats An array of the available date/time formats
			 * @returns {Object} The date/time format that best matches the requested options
			 * @private
			 */
			function _basicFormatMatcher(options, formats) {
				var removalPenalty = 120;
				var additionPenalty = 20;
				var longLessPenalty = 8;
				var longMorePenalty = 6;
				var shortLessPenalty = 6;
				var shortMorePenalty = 3;
				var bestScore = Number.NEGATIVE_INFINITY;
				var bestFormat;
				var i = 0;
				var len = formats.length;
				while (i < len) {
					var format = formats[i.toString()];
					var score = 0;
					var dateTimeProperties = [ "weekday", "era", "year", "month", "day", "hour", "minute", "second",
							"timeZoneName" ];
					dateTimeProperties.forEach(function (property) {
						var optionsProp = options[property];
						var formatProp;
						var formatPropDesc = Object.getOwnPropertyDescriptor(format, property);
						if (formatPropDesc !== undefined) {
							formatProp = format[property];
						}
						if (optionsProp === undefined && formatProp !== undefined) {
							score -= additionPenalty;
						} else if (optionsProp !== undefined && formatProp === undefined) {
							score -= removalPenalty;
						} else {
							var values = [ "2-digit", "numeric", "narrow", "short", "long" ];
							var optionsPropIndex = values.indexOf(optionsProp);
							var formatPropIndex = values.indexOf(formatProp);
							var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);
							if (delta === 2) {
								score -= longMorePenalty;
							} else if (delta === 1) {
								score -= shortMorePenalty;
							} else if (delta === -1) {
								score -= shortLessPenalty;
							} else if (delta === -2) {
								score -= longLessPenalty;
							}
						}
					});
					if (score > bestScore) {
						bestScore = score;
						bestFormat = format;
					}
					i++;
				}
				return bestFormat;
			}
			/**
			 * BestFitFormat abstract operation as defined in ECMA-402 Section 12.1.1.1
			 * ECMA-402 allows this algorithm to be implementation defined. For now we are using
			 * the same algorithm as for BasicFormatMatcher.
			 * 
			 * @param {Object} options The requested options (i.e. fields) to be included in the date/time format
			 * @param {Object []} formats An array of the available date/time formats
			 * @returns {Object} The date/time format that best matches the requested options
			 * @private
			 */
			function _bestFitFormatMatcher(options, formats) {
				return _basicFormatMatcher(options, formats);
			}

			/**
			 * InitializeDateTimeFormat abstract operation as defined in ECMA-402 Section 12.1.1.1
			 * 
			 * @param {Object} dateTimeFormat The object to be initialized as a DateTimeFormat object
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Date/time formatting options
			 * @private
			 */
			function _initializeDateTimeFormat(dateTimeFormat, locales, options) {
				var dateProperties = [ "weekday", "era", "year", "month", "day" ];
				var timeProperties = [ "hour", "minute", "second", "timeZoneName" ];
				var dateTimeProperties = [ "weekday", "era", "year", "month", "day", "hour", "minute", "second",
				                           "timeZoneName" ];
				var hasDateProperties = false;
				var hasTimeProperties = false;
				if (dateTimeFormat.hasOwnProperty("initializedIntlObject") && dateTimeFormat.initializedIntlObject) {
					throw new TypeError("DateTimeFormat is already initialized.");
				}
				dateTimeFormat.initializedIntlObject = true;
				var requestedLocales = common.CanonicalizeLocaleList(locales);
				options = _toDateTimeOptions(options, "any", "date");
				var opt = new Record();
				var matcher = common
						.GetOption(options, "localeMatcher", "string", [ "lookup", "best fit" ], "best fit");
				opt.set("localeMatcher", matcher);
				var r = common.ResolveLocale(DateTimeFormat.availableLocales, requestedLocales, opt,
						DateTimeFormat.relevantExtensionKeys, DateTimeFormat.localeData);
				dateTimeFormat.locale = r.locale;
				dateTimeFormat.numberingSystem = r.nu;
				dateTimeFormat.calendar = r.ca;
				dateTimeFormat.dataLocale = r.dataLocale;
				var tz = options.timeZone;
				if (tz !== undefined) {
					tz = tz.toString();
					tz = common._toUpperCaseIdentifier(tz);
					if (tz !== "UTC") {
						throw new RangeError("Timezones other than UTC are not supported");
					}
				}
				dateTimeFormat.timeZone = tz;
				opt = new Record();
				var requestedDateOptions = new Record();
				var requestedTimeOptions = new Record();
				dateProperties.forEach(function (prop) {
					var value = common
							.GetOption(options, prop, "string", _validDateTimePropertyValues(prop), undefined);
					opt.set(prop, value);
					if (value) {
						requestedDateOptions.set(prop,value);
						hasDateProperties = true;
					}
				});
				timeProperties.forEach(function (prop) {
					var value = common
							.GetOption(options, prop, "string", _validDateTimePropertyValues(prop), undefined);
					opt.set(prop, value);
					if (value) {
						requestedTimeOptions.set(prop,value);
						hasTimeProperties = true;
					}
				});

				/*
				 * Steps 20-21: Here we deviate slightly from the strict definition as defined in ECMA 402. Instead of
				 * having all the formats predefined (i.e. hard-coded) in the locale data object up front, and accessing
				 * them here, we instead wait until we know which locale we are interested in, and load the formats from
				 * the JSON data. This saves us having to convert CLDR date formats to ECMA 402's format for a bunch of
				 * locales that we aren't really using.
				 */
				var cldrCalendar = dateTimeFormat.calendar.replace("gregory", "gregorian");
				dateTimeFormat.calData =
					preloads[r.dataLocale]["ca-" + cldrCalendar].main[r.dataLocale].dates.calendars[cldrCalendar];
				var dateTimeFormats = dateTimeFormat.calData.dateTimeFormats;
				var formats = _convertAvailableDateTimeFormats(dateTimeFormats);
				matcher = common.GetOption(options, "formatMatcher", "string", [ "basic", "best fit" ], "best fit");
				var bestFormat;
				if (hasDateProperties && hasTimeProperties) {
					var bestDateFormat = matcher === "basic" ? _basicFormatMatcher(requestedDateOptions, formats) : 
						_bestFitFormatMatcher(requestedDateOptions, formats);
					var bestTimeFormat = matcher === "basic" ? _basicFormatMatcher(requestedTimeOptions, formats) :
						_bestFitFormatMatcher(requestedTimeOptions, formats);
					bestFormat = bestDateFormat;
					var combinedDateFormat;
					if (requestedDateOptions.weekday === "long" &&
						requestedDateOptions.month === "long" ) {
						combinedDateFormat = _ToIntlDateTimeFormat(dateTimeFormats.full || "{1} {0}");
					} else if (requestedDateOptions.month === "long") {
						combinedDateFormat = _ToIntlDateTimeFormat(dateTimeFormats.long || "{1} {0}");
					} else if (requestedDateOptions.month === "short") {
						combinedDateFormat = _ToIntlDateTimeFormat(dateTimeFormats.medium || "{1} {0}");
					} else {
						combinedDateFormat = _ToIntlDateTimeFormat(dateTimeFormats.short || "{1} {0}");
					}
					combinedDateFormat.pattern = combinedDateFormat.pattern.replace("{1}", bestDateFormat.pattern);
					var combinedDateTimeFormat24 = combinedDateFormat.pattern.replace("{0}", bestTimeFormat.pattern);
					var combinedDateTimeFormat12 = combinedDateFormat.pattern.replace("{0}", bestTimeFormat.pattern12);
					bestFormat.set("hour12", bestTimeFormat.hour12);
					bestFormat.set("pattern", combinedDateTimeFormat24);
					bestFormat.set("pattern12", combinedDateTimeFormat12);
					dateProperties.forEach(function (prop) {
						var pDesc = Object.getOwnPropertyDescriptor(bestDateFormat, prop);
						if (pDesc !== undefined) {
							dateTimeFormat[prop] = bestDateFormat[prop];
						}
					});					
					timeProperties.forEach(function (prop) {
						var pDesc = Object.getOwnPropertyDescriptor(bestTimeFormat, prop);
						if (pDesc !== undefined) {
							dateTimeFormat[prop] = bestTimeFormat[prop];
						}
					});					
				} else {
					bestFormat = matcher === "basic" ? _basicFormatMatcher(opt, formats) : _bestFitFormatMatcher(opt,
						formats);
					dateTimeProperties.forEach(function (prop) {
						var pDesc = Object.getOwnPropertyDescriptor(bestFormat, prop);
						if (pDesc !== undefined) {
							dateTimeFormat[prop] = bestFormat[prop];
						}
					});
				}
				var pattern;
				var hr12 = common.GetOption(options, "hour12", "boolean", undefined, undefined);
				if (dateTimeFormat.hour !== undefined) {
					if (hr12 === undefined) {
						hr12 = DateTimeFormat.localeData[dateTimeFormat.dataLocale]
								&& DateTimeFormat.localeData[dateTimeFormat.dataLocale].hour12;
					}
					dateTimeFormat.hour12 = hr12;
					if (hr12) {
						var hourNo0 = DateTimeFormat.localeData[dateTimeFormat.dataLocale]
								&& DateTimeFormat.localeData[dateTimeFormat.dataLocale].hourNo0;
						dateTimeFormat.hourNo0 = hourNo0;
						dateTimeFormat.hour = bestFormat.hour12;
						pattern = bestFormat.pattern12;
					} else {
						pattern = bestFormat.pattern;
					}
				} else {
					pattern = bestFormat.pattern;
				}
				dateTimeFormat.pattern = pattern;
				dateTimeFormat.boundFormat = undefined;
				dateTimeFormat.initializedDateTimeFormat = true;
			}

			/**
			 * FormatDateTime abstract operation as defined in ECMA-402 Section 12.3.2
			 * 
			 * @param {Object} dateTimeFormat The date/time format object to use for formatting
			 * @param {Number} x The value of the date being formatted, as would be received from
			 *  the getTime() method of the Date object
			 * @returns {String} The string representing the formatted number
			 * @private
			 */
			function _formatDateTime(dateTimeFormat, x) {
				var dateTimeProperties = [ "weekday", "era", "year", "month", "day", "hour", "minute", "second",
						"timeZoneName" ];
				if (!isFinite(x)) {
					throw new RangeError("Attempting to format an invalid date/time.");
				}
				var locale = dateTimeFormat.locale;
				var nf = {};
				_initializeNumberFormat(nf, locale, {
					useGrouping : false
				});
				var nf2 = {};
				_initializeNumberFormat(nf2, locale, {
					minimumIntegerDigits : 2,
					useGrouping : false
				});
				var tm = calendars.toLocalTime(x, dateTimeFormat.calendar, dateTimeFormat.timeZone);
				var pm = false;
				var result = dateTimeFormat.pattern;
				dateTimeProperties.forEach(function (prop) {
					var p = prop;
					var f = dateTimeFormat[p];
					var v = tm[p];
					var fv;
					if (p === "month") {
						v++;
					}
					if (p === "hour" && dateTimeFormat.hour12) {
						v = v % 12;
						pm = (v !== tm[p]);
						if (v === 0 && dateTimeFormat.hourNo0) {
							v = 12;
						}
					}
					if (f === "numeric") {
						fv = _formatNumber(nf, v);
					} else if (f === "2-digit") {
						fv = _formatNumber(nf2, v);
						if (fv.length > 2) {
							fv = fv.substr(-2);
						}
					} else {
						var standalone = (p === "month" && dateTimeFormat.standaloneMonth || 
								p === "weekday" && dateTimeFormat.standaloneWeekday);
						fv = _getCalendarField(dateTimeFormat.calendar, dateTimeFormat.calData, tm.year, standalone, p,
								f, v);
					}
					if (result) {
						result = result.replace("{" + p + "}", fv);
					}
				});
				if (dateTimeFormat.hour12) {
					var ampm = pm ? "pm" : "am";
					var fv = _getCalendarField(dateTimeFormat.calendar, dateTimeFormat.calData, tm.year, false,
							"dayperiod", "short", ampm);
					if (result) {
						result = result.replace("{ampm}", fv);
					}
				}
				return result;
			}

			/**
			 * Utility function to retrive necessary date/time fields from the CLDR data
			 * 
			 * @param {String} calType The type of calendar in use (i.e. "hebrew", "japanese", etc. )
			 * @param {Object} calData The JSON object containing calendar data from CLDR
			 * @param {Number} year The year number
			 * @param {Boolean} standalone TRUE indicates a stand-alone month name,
			 *  which is spelled differently in some languages.
			 * @param {String} property The type of field being requested (i.e. "weekday", "month", etc.)
			 * @param {String} format The length of the field being requested (i.e. "narrow", "short", "long")
			 * @param {Number} value Indicates which month, day, etc. is being requested (zero based)
			 * @returns {String} A string containing the requested calendar field
			 * @private
			 */
			function _getCalendarField(calType, calData, year, standalone, property, format, value) {
				/*jshint maxcomplexity: 36*/
				var result = null;
				switch (property) {
				case "weekday":
					var cldrWeekdayKeys = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];
					var weekdayKey = cldrWeekdayKeys[value];
					switch (format) {
					case "narrow":
						result = standalone ? calData.days["stand-alone"].narrow[weekdayKey]
								: calData.days.format.narrow[weekdayKey];
						break;
					case "short":
						result = standalone ? calData.days["stand-alone"].abbreviated[weekdayKey]
						: calData.days.format.abbreviated[weekdayKey];
						break;
					case "long":
						result = standalone ? calData.days["stand-alone"].wide[weekdayKey]
						: calData.days.format.wide[weekdayKey];
						break;
					}
					break;
				case "era":
					switch (format) {
					case "narrow":
						result = calData.eras.eraNarrow[value];
						break;
					case "short":
						result = calData.eras.eraAbbr[value];
						break;
					case "long":
						result = calData.eras.eraNames[value];
						break;
					}
					break;
				case "month":
					var monthValue = value;
					/*
					* Because of leap month in the Hebrew calendar, there isn't a 1-1 correlation between
					* month number and the resource name in CLDR, so we have to adjust accordingly.
					*/
					if (calType === "hebrew") {
						monthValue = calendars.hebrewMonthResource(year, value);
					}
					switch (format) {
					case "narrow":
						result = standalone ? calData.months["stand-alone"].narrow[monthValue]
								: calData.months.format.narrow[monthValue];
						break;
					case "short":
						result = standalone ? calData.months["stand-alone"].abbreviated[monthValue]
								: calData.months.format.abbreviated[monthValue];
						break;
					case "long":
						result = standalone ? calData.months["stand-alone"].wide[monthValue]
								: calData.months.format.wide[monthValue];
						break;
					}
					break;
				case "dayperiod":
					switch (format) {
					case "narrow":
						result = calData.dayPeriods.format.narrow[value];
						break;
					case "short":
						result = calData.dayPeriods.format.abbreviated[value];
						break;
					case "long":
						result = calData.dayPeriods.format.wide[value];
						break;
					}
					break;
				case "timeZoneName":
					if (value === "UTC") {
						result = "UTC";
					}
					result = "local";
					break;
				}
				return result;
			}
			/**
			 * Utility function to convert the availableFormats from a CLDR JSON object into an array of available
			 * formats as defined by ECMA 402. For definition of fields, in CLDR, refer to
			 * http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
			 * 
			 * @param {String} format The date/time format pattern as from CLDR
			 * @returns {String} A string containing the corresponding date/time pattern in ECMA-402 format
			 * @private
			 */
			function _ToIntlDateTimeFormat(format) {
				var dateFields = /G{1,5}|y{1,4}|[ML]{1,5}|[Ec]{1,5}|d{1,2}|a|[Hh]{1,2}|m{1,2}|s{1,2}/g;
				var result = new Record();
				var pieces = format.split("'");
				for (var x = 0; x < pieces.length; x += 2) { // Don't do replacements for fields that are quoted
					/*jshint maxcomplexity: 45*/
					pieces[x] = pieces[x].replace(dateFields, function (field) {
						switch (field) {
						case "GGGGG":
							result.set("era", "narrow");
							return "{era}";
						case "GGGG":
							result.set("era", "long");
							return "{era}";
						case "GGG":
						case "GG":
						case "G":
							result.set("era", "short");
							return "{era}";
						case "yy":
							result.set("year", "2-digit");
							return "{year}";
						case "y":
						case "yyy":
						case "yyyy":
							result.set("year", "numeric");
							return "{year}";
						case "LLLLL":
							result.set("standaloneMonth", true);
							result.set("month", "narrow");
							return "{month}";
						case "MMMMM":
							result.set("month", "narrow");
							return "{month}";
						case "LLLL":
							result.set("standaloneMonth", true);
							result.set("month", "long");
							return "{month}";
						case "MMMM":
							result.set("month", "long");
							return "{month}";
						case "LLL":
							result.set("standaloneMonth", true);
							result.set("month", "short");
							return "{month}";
						case "MMM":
							result.set("month", "short");
							return "{month}";
						case "LL":
						case "MM":
							result.set("month", "2-digit");
							return "{month}";
						case "L":
						case "M":
							result.set("month", "numeric");
							return "{month}";
						case "ccccc":
							result.set("standaloneWeekday", true);
							result.set("weekday", "narrow");
							return "{weekday}";
						case "EEEEE":
							result.set("weekday", "narrow");
							return "{weekday}";
						case "cccc":
							result.set("standaloneWeekday", true);
							result.set("weekday", "long");
							return "{weekday}";
						case "EEEE":
							result.set("weekday", "long");
							return "{weekday}";
						case "ccc":
						case "cc":
						case "c":
							result.set("standaloneWeekday", true);
							result.set("weekday", "short");
							return "{weekday}";
						case "EEE":
						case "EE":
						case "E":
							result.set("weekday", "short");
							return "{weekday}";
						case "dd":
							result.set("day", "2-digit");
							return "{day}";
						case "d":
							result.set("day", "numeric");
							return "{day}";
						case "a":
							return "{ampm}";
						case "hh":
							result.set("hour12", "2-digit");
							result.set("hour", "2-digit");
							return "{hour}";
						case "HH":
							result.set("hour", "2-digit");
							return "{hour}";
						case "h":
							result.set("hour12", "numeric");
							result.set("hour", "numeric");
							return "{hour}";
						case "H":
							result.set("hour", "numeric");
							return "{hour}";
						case "mm":
							result.set("minute", "2-digit");
							return "{minute}";
						case "m":
							result.set("minute", "numeric");
							return "{minute}";
						case "ss":
							result.set("second", "2-digit");
							return "{second}";
						case "s":
							result.set("second", "numeric");
							return "{second}";
						default:
							return field;
						}
					});
					/*jshint maxcomplexity: 10*/
				}
				result.set("pattern", pieces.join(""));
				return result;
			}

			/**
			 * Utility function to construct alternate forms of flexible date
			 * patterns to accommodate the various widths.
			 * 
			 * @param {String} format The original date format pattern
			 * @param {RegExp} sourceFormat Matches the field that will be replaced in the "format" context.
			 * @param {String} targetFormat String to replace "sourceFormat" when matched.
			 * @param {RegExp} sourceStandalone Matches the field that will be replaced in the "stand alone" context.
			 * @param {String} targetStandalone String to replace "sourceStandalone" when matched.
			 * @returns {String[]} The constructed date pattern, in ECMA-402 format
			 * @private
			 */
			function _constructFormat(format,sourceFormat,targetFormat,sourceStandalone,targetStandalone) {
				var constructedFormatPattern = format.replace(sourceFormat, targetFormat)
					.replace(sourceStandalone, targetStandalone);
				var constructedFormat = _ToIntlDateTimeFormat(constructedFormatPattern);
				constructedFormat.cldrPattern = constructedFormatPattern;
				return constructedFormat;
			}
			/**
			 * Utility function to convert the availableFormats from a CLDR JSON
			 * object into an array of available formats as defined by ECMA 402. For
			 * a definition of fields in CLDR, refer to
			 * http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
			 * 
			 * @param {Object} dateTimeFormats The CLDR JSON object containing date/time information
			 * @returns {String[]} A array of strings, each corrresponding to one of the date/time 
			 *  patterns (in ECMA-402 format) that can be used to format dates or times
			 * @private
			 */
			function _convertAvailableDateTimeFormats(dateTimeFormats) {
				var availableFormats = dateTimeFormats.availableFormats;
				var result = [];
				var usableFormatSkeletons = /^G{0,5}y{0,4}M{0,5}E{0,5}d{0,2}H{0,2}m{0,2}s{0,2}$/;
				var abbrMonthSkeleton = /(^|[^M])M{3}([^M]|$)/;
				var weekdaySkeleton = /(^|[^E])E{1,3}([^E]|$)/;
				for (var format in availableFormats) {
					var format12 = availableFormats[format.replace("H", "h")];
					if (usableFormatSkeletons.test(format) && format12 !== undefined) {
						var outputFormat = _ToIntlDateTimeFormat(availableFormats[format]);
						if (/H/.test(format)) {
							var outputFormat12 = _ToIntlDateTimeFormat(format12);
							outputFormat.set("hour12", outputFormat12.hour12);
							outputFormat.set("pattern12", outputFormat12.pattern);
						}
						result.push(outputFormat);
						// Flexible date format logic - If the locale contains just a E pattern (abbreviated weekday)
						// and not a corresponding EEEE pattern (long weekday), then we can infer
						// an appropriate EEEE pattern by just replacing the E with EEEE.
						if (weekdaySkeleton.test(format) && !availableFormats[format.replace("E", "EEEE")]) {
							result.push(_constructFormat(availableFormats[format],/E{1,3}/,"EEEE",/c{1,3}/,"cccc"));
						}
						// Flexible date format logic - If the locale contains just a E pattern (abbreviated weekday)
						// and not a corresponding EEEEE pattern (narrow weekday), then we can infer
						// an appropriate EEEEE pattern by just replacing the E with EEEEE.
						if (weekdaySkeleton.test(format) && !availableFormats[format.replace("E", "EEEEE")]) {
							result.push(_constructFormat(availableFormats[format],/E{1,3}/,"EEEEE",/c{1,3}/,"ccccc"));
						}
						// Flexible date format logic - If the locale contains just a MMM pattern (abbreviated month)
						// and not a corresponding MMMM pattern (long month), then we can infer
						// an appropriate MMMM pattern by just replacing the MMM with MMMM.
						if (abbrMonthSkeleton.test(format) && !availableFormats[format.replace("MMM", "MMMM")]) {
							var constructedSkeleton = format.replace("MMM", "MMMM");
							var constructedFormat = _constructFormat(availableFormats[format],
									/M{3}/,"MMMM",/L{3}/,"LLLL");
							result.push(constructedFormat);
							// If the constructed format contains a weekday pattern, then we have to repeat the
							// two steps above to cover that case as well.
							if (weekdaySkeleton.test(constructedSkeleton) && 
									!availableFormats[constructedSkeleton.replace(weekdaySkeleton, "EEEE")]) {
								result.push(_constructFormat(constructedFormat.cldrPattern,
										/E{1,3}/,"EEEE",/c{1,3}/,"cccc"));
							}
							if (weekdaySkeleton.test(constructedSkeleton) &&
									!availableFormats[constructedSkeleton.replace(weekdaySkeleton, "EEEEE")]) {
								result.push(_constructFormat(constructedFormat.cldrPattern,
										/E{1,3}/,"EEEEE",/c{1,3}/,"ccccc"));
							}
						}
					}
				}
				return result;
			}

			/**
			 * Utility function to return the valid values for a date/time field, according to table 3 in ECMA 402
			 * section 12.1.1.1
			 * 
			 * @param {String} prop The requested date/time field
			 * @returns {String[]} A array of strings, each corrresponding one of the valid date/time property values 
			 * @private
			 */
			function _validDateTimePropertyValues(prop) {
				if (prop === "weekday" || prop === "era") {
					return [ "narrow", "short", "long" ];
				}
				if (prop === "year" || prop === "day" || prop === "hour" || prop === "minute" || prop === "second") {
					return [ "2-digit", "numeric" ];
				}
				if (prop === "month") {
					return [ "2-digit", "numeric", "narrow", "short", "long" ];
				}
				if (prop === "timeZoneName") {
					return [ "short", "long" ];
				}
			}

			/**
			 * Internal properties of NumberFormat, as defined in ECMA 402 Section 11.2.3
			 */
			var NumberFormat = {};
			NumberFormat.availableLocales = Object.keys(preloads);
			NumberFormat.relevantExtensionKeys = [ "nu" ];
			NumberFormat.localeData = {};
			NumberFormat.availableLocales.forEach(function (loc) {
				NumberFormat.localeData[loc] = {
					"nu" : availableNumberingSystems
				};
			});
			Object.freeze(NumberFormat);

			/**
			 * Internal properties of DateTimeFormat, as defined in ECMA 402 Section 12.2.3
			 */
			var DateTimeFormat = {};
			DateTimeFormat.availableLocales = Object.keys(preloads);
			DateTimeFormat.relevantExtensionKeys = [ "ca", "nu" ];
			DateTimeFormat.localeData = {};
			DateTimeFormat.availableLocales.forEach(function (loc) {
				var region = common._getRegion(loc);
				var hour12 = false;
				var hourNo0 = false;
				hour12 = timeData[region] && (/h|K/.test(timeData[region]._preferred));
				hourNo0 = timeData[region] && (/h|k/.test(timeData[region]._preferred));
				
				DateTimeFormat.localeData[loc] = {
					"nu" : availableNumberingSystems,
					"ca" : common._getSupportedCalendars(common._getRegion(loc)),
					"hour12" : hour12,
					"hourNo0" : hourNo0
				};
			});
			Object.freeze(DateTimeFormat);

			/**
			 * Placeholder for Intl.Collator constructor as defined by EMCA 402 Section 10.1.
			 * Intl.Collator is not supported by this package.
			 * @constructor
			 */
			Intl.Collator = function () {
				throw new TypeError("Intl.Collator is not supported.");
			};

			/**
			 * Intl.NumberFormat constructor as defined by EMCA 402 Section 11.1.
			 * @constructor
			 */
			Intl.NumberFormat = function () {
				this.prototype = Intl.NumberFormat.prototype;
				this.extensible = true;
				// ECMA 402 Section 11.1.3.1
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				_initializeNumberFormat(this, locales, options);
			};

			// ECMA 402 Section 7
			Object.defineProperty(Intl, "NumberFormat", {
				writable : true,
				configurable : true,
				enumerable : false
			});

			/**
			 * Intl.NumberFormat.call as defined in ECMA-402 Section 11.1.2.1
			 *
			 * @param {Object} thisObject The NumberFormat object. If undefined,
			 *  a new NumberFormat object will be created.
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Number formatting options
			 * @returns 
			 */
			Intl.NumberFormat.call = function (thisObject, locales, options) {
				if (thisObject === Intl || thisObject === undefined) {
					return new Intl.NumberFormat(locales, options);
				}
				var obj = Object(thisObject);
				if (!Object.isExtensible(obj)) {
					throw new TypeError("Intl.NumberFormat.call: object is not extensible");
				}
				_initializeNumberFormat(obj, locales, options);
				return obj;
			};

			/**
			 * Intl.NumberFormat.supportedLocalesOf as defined in ECMA-402 Section 11.2.2
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Locale lookup options
			 * @returns {String[]} An array of supported locales that matches the request
			 */
			Object.defineProperty(Intl.NumberFormat, "supportedLocalesOf", {
				value : function (locales) {
					var availableLocales = NumberFormat.availableLocales;
					var requestedLocales = common.CanonicalizeLocaleList(locales);
					var options;
					if (arguments.length > 1) {
						options = arguments[1];
					}
					return common.SupportedLocales(availableLocales, requestedLocales, options);
				},
				writable : true,
				enumerable : false,
				configurable : true
			});

			Intl.NumberFormat.prototype = Intl.NumberFormat.call({});

			// ECMA 402 Section 11.2.1
			Object.defineProperty(Intl.NumberFormat, "prototype", {
				writable : false,
				enumerable : false,
				configurable : false
			});

			// ECMA 402 Section 11.3.1
			Object.defineProperty(Intl.NumberFormat.prototype, "constructor", {
				value : Intl.NumberFormat,
				writable : true,
				configurable : true,
				enumerable : false
			});

			/**
			 * Intl.NumberFormat.prototype.format as defined in ECMA-402 Section 11.3.2
			 * @param {Number} value The number to format
			 */
			Object.defineProperty(Intl.NumberFormat.prototype, "format", {
				get : function () {
					if (this !== Object(this) || !this.initializedNumberFormat) {
						throw new TypeError(
								"Intl.NumberFormat format getter: 'this' is not a valid Intl.NumberFormat instance");
					}
					if (this.boundFormat === undefined) {
						var F = function (value) {
							var x = Number(value);
							return _formatNumber(this, x);
						};
						var bf = F.bind(this);
						this.boundFormat = bf;
					}
					return this.boundFormat;
				},
				configurable : true
			});

			/**
			 * Intl.NumberFormat.resolvedOptions as defined in ECMA-402 Section 11.3.3
			 *
			 * @returns {Object} An object containing information about the options associated with a NumberFormat
			 */
			Object.defineProperty(Intl.NumberFormat.prototype, "resolvedOptions", {
				value : function () {
					if (this !== Object(this) || !this.initializedNumberFormat) {
						throw new TypeError(
								"Intl.NumberFormat.resolvedOptions: 'this' is not a valid Intl.NumberFormat instance");
					}
					var fields = [ "locale", "numberingSystem", "style", "currency", "currencyDisplay",
							"minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits",
							"minimumSignificantDigits", "maximumSignificantDigits", "useGrouping" ];
					var result = new Record();
					for (var f in fields) {
						if (this.hasOwnProperty(fields[f])) {
							result.set(fields[f], this[fields[f]]);
						}
					}
					return result;
				},
				writable : true,
				enumerable : false,
				configurable : true
			});

			/**
			 * Intl.DateTimeFormat constructor as defined by EMCA 402 Section 12.1.
			 * @constructor
			 */
			Intl.DateTimeFormat = function () {
				this.prototype = Intl.DateTimeFormat.prototype;
				this.extensible = true;
				// ECMA 402 Section 12.1.3.1
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				_initializeDateTimeFormat(this, locales, options);
			};
			// ECMA 402 Section 7
			Object.defineProperty(Intl, "DateTimeFormat", {
				writable : true,
				configurable : true,
				enumerable : false
			});

			/**
			 * Intl.DateTimeFormat.call as defined in ECMA-402 Section 12.1.2.1
			 *
			 * @param {Object} thisObject The DateTimeFormat object. If undefined,
			 *  a new DateTimeFormat object will be created.
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Date/time formatting options
			 * @returns 
			 */
			Intl.DateTimeFormat.call = function (thisObject, locales, options) {
				if (thisObject === Intl || thisObject === undefined) {
					return new Intl.DateTimeFormat(locales, options);
				}
				var obj = Object(thisObject);
				if (!Object.isExtensible(obj)) {
					throw new TypeError("Intl.DateTimeFormat.call: object is not extensible");
				}
				_initializeDateTimeFormat(obj, locales, options);
				return obj;
			};

			/**
			 * Intl.DateTimeFormat.supportedLocalesOf as defined in ECMA-402 Section 12.2.2
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Locale lookup options
			 * @returns {String[]} An array of supported locales that matches the request
			 */
			Object.defineProperty(Intl.DateTimeFormat, "supportedLocalesOf", {
				value : function (locales) {
					var availableLocales = DateTimeFormat.availableLocales;
					var requestedLocales = common.CanonicalizeLocaleList(locales);
					var options;
					if (arguments.length > 1) {
						options = arguments[1];
					}
					return common.SupportedLocales(availableLocales, requestedLocales, options);
				},
				writable : true,
				enumerable : false,
				configurable : true
			});

			Intl.DateTimeFormat.prototype = Intl.DateTimeFormat.call({});

			// ECMA 402 Section 12.2.1
			Object.defineProperty(Intl.DateTimeFormat, "prototype", {
				writable : false,
				enumerable : false,
				configurable : false
			});

			// ECMA 402 Section 12.3.1
			Object.defineProperty(Intl.DateTimeFormat.prototype, "constructor", {
				value : Intl.DateTimeFormat,
				writable : true,
				configurable : true,
				enumerable : false
			});

			/**
			 * @param {Date} date The date to format
			 * Intl.DateTimeFormat.prototype.format as defined in ECMA-402 Section 12.3.2
			 */
			Object.defineProperty(Intl.DateTimeFormat.prototype, "format", {
				get : function () {
					if (this !== Object(this) || !this.initializedDateTimeFormat) {
						var msg = "DateTimeFormat format getter: 'this' is not a valid Intl.DateTimeFormat instance";
						throw new TypeError(msg);
					}
					if (this.boundFormat === undefined) {
						var F = function () {
							var date;
							if (arguments.length > 0) {
								date = arguments[0];
							}
							var x;
							if (date === undefined) {
								x = Date.now();
							} else {
								x = Number(date);
							}
							return _formatDateTime(this, x);
						};
						var bf = F.bind(this);
						this.boundFormat = bf;
					}
					return this.boundFormat;
				},
				configurable : true
			});

			/**
			 * Intl.DateTimeFormat.resolvedOptions as defined in ECMA-402 Section 12.3.3
			 *
			 * @returns {Object} An object containing information about the options associated with a DateTimeFormat
			 */
			Object.defineProperty(Intl.DateTimeFormat.prototype, "resolvedOptions", {
				value : function () {
					if (this !== Object(this) || !this.initializedDateTimeFormat) {
						var msg = "DateTimeFormat.resolvedOptions: 'this' is not a valid Intl.DateTimeFormat instance";
						throw new TypeError(msg);
					}
					var fields = [ "locale", "calendar", "numberingSystem", "timeZone", "hour12", "weekday", "era",
							"year", "month", "day", "hour", "minute", "second", "timeZoneName" ];
					var result = new Record();
					for (var f in fields) {
						if (this.hasOwnProperty(fields[f])) {
							result.set(fields[f], this[fields[f]]);
						}
					}
					return result;
				},
				writable : true,
				enumerable : false,
				configurable : true
			});

			/**
			 * Number.prototype.toLocaleString as defined in ECMA-402 Section 13.2.1
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Number formatting options
			 * @returns {String} String representing the formatted number
			 */
			Number.prototype.toLocaleString = function () {
				if (!(this instanceof Number)) {
					throw new TypeError("not a valid Number");
				}
				var x = Number(this);
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				var numberFormat = {};
				_initializeNumberFormat(numberFormat, locales, options);
				return _formatNumber(numberFormat, x);
			};

			/**
			 * Date.prototype.toLocaleString as defined in ECMA-402 Section 13.3.1
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Date/time formatting options
			 * @returns {String} String representing the formatted date/time
			 */
			Date.prototype.toLocaleString = function () {
				if (!(this instanceof Date)) {
					throw new TypeError("not a valid Date");
				}
				var x = this.getTime();
				if (isNaN(x)) {
					return "Invalid Date";
				}
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				options = _toDateTimeOptions(options, "any", "all");
				var dateTimeFormat = {};
				_initializeDateTimeFormat(dateTimeFormat, locales, options);
				return _formatDateTime(dateTimeFormat, x);
			};
			/**
			 * Date.prototype.toLocaleDateString as defined in ECMA-402 Section 13.3.2
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Date formatting options
			 * @returns {String} String representing the formatted date
			 */
			Date.prototype.toLocaleDateString = function () {
				if (!(this instanceof Date)) {
					throw new TypeError("not a valid Date");
				}
				var x = this.getTime();
				if (isNaN(x)) {
					return "Invalid Date";
				}
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				options = _toDateTimeOptions(options, "date", "date");
				var dateTimeFormat = {};
				_initializeDateTimeFormat(dateTimeFormat, locales, options);
				return _formatDateTime(dateTimeFormat, x);
			};
			/**
			 * Date.prototype.toLocaleTimeString as defined in ECMA-402 Section 13.3.3
			 *
			 * @param {*} locales The requested locale or locales for formatting
			 * @param {Object} options Time formatting options
			 * @returns {String} String representing the formatted time
			 */
			Date.prototype.toLocaleTimeString = function () {
				if (!(this instanceof Date)) {
					throw new TypeError("not a valid Date");
				}
				var x = this.getTime();
				if (isNaN(x)) {
					return "Invalid Date";
				}
				var locales;
				var options;
				if (arguments.length > 0) {
					locales = arguments[0];
				}
				if (arguments.length > 1) {
					options = arguments[1];
				}
				options = _toDateTimeOptions(options, "time", "time");
				var dateTimeFormat = {};
				_initializeDateTimeFormat(dateTimeFormat, locales, options);
				return _formatDateTime(dateTimeFormat, x);
			};
			return Intl;
		});
;
/**
 * @license text 2.0.15 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('requirejs-text/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.15',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});
;
define(
	'ecma402/calendars/rocCalendar',[ "../impl/Record", "../impl/calendarFunctions"],
	function (Record, calendarFunctions) {
	var rocCalendar = {
		toLocalTime : function (date, timeZone) {
			var result = new Record();
			var dt = new Date(date);
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			var year = timeZone === "UTC" ? dt.getUTCFullYear() : dt.getFullYear();
			result.set("era", calendarFunctions.findEra("roc", dt, 1));
			var offset = calendarFunctions.eraOffset("roc", 1);
			if (year - offset >= 0) {
				result.set("year", year - offset + 1);
			} else {
				result.set("year", offset - year);
			}
			result.set("month", timeZone === "UTC" ? dt.getUTCMonth() : dt.getMonth());
			result.set("day", timeZone === "UTC" ? dt.getUTCDate() : dt.getDate());
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
	return rocCalendar;
});;
define('requirejs-text/text!ecma402/cldr/supplemental/calendarData.json',[],function () { return '{\n  "supplemental": {\n    "calendarData": {\n      "buddhist": {\n        "calendarSystem": "solar",\n        "eras": {\n          "0": {\n            "_start": "-542-01-01"\n          }\n        }\n      },\n      "chinese": {\n        "calendarSystem": "lunisolar",\n        "eras": {\n          "0": {\n            "_start": "-2636-01-01"\n          }\n        }\n      },\n      "coptic": {\n        "calendarSystem": "other",\n        "eras": {\n          "0": {\n            "_end": "284-08-28"\n          },\n          "1": {\n            "_start": "284-08-29"\n          }\n        }\n      },\n      "dangi": {\n        "calendarSystem": "lunisolar",\n        "eras": {\n          "0": {\n            "_start": "-2332-01-01"\n          }\n        }\n      },\n      "ethiopic": {\n        "calendarSystem": "other",\n        "eras": {\n          "0": {\n            "_end": "8-08-28"\n          },\n          "1": {\n            "_start": "8-08-29"\n          }\n        }\n      },\n      "generic": {},\n      "gregorian": {\n        "calendarSystem": "solar",\n        "eras": {\n          "0": {\n            "_end": "0-12-31"\n          },\n          "1": {\n            "_start": "1-01-01"\n          }\n        }\n      },\n      "hebrew": {\n        "calendarSystem": "lunisolar",\n        "eras": {\n          "0": {\n            "_start": "-3760-10-7"\n          }\n        }\n      },\n      "indian": {\n        "eras": {\n          "0": {\n            "_start": "79-01-01"\n          }\n        }\n      },\n      "islamic": {\n        "calendarSystem": "lunar",\n        "eras": {\n          "0": {\n            "_start": "622-7-15"\n          }\n        }\n      },\n      "islamic-civil": {\n        "calendarSystem": "lunar",\n        "eras": {\n          "0": {\n            "_start": "622-7-16"\n          }\n        }\n      },\n      "islamic-rgsa": {\n        "calendarSystem": "lunar",\n        "eras": {\n          "0": {\n            "_start": "622-7-15"\n          }\n        }\n      },\n      "islamic-tbla": {\n        "calendarSystem": "lunar",\n        "eras": {\n          "0": {\n            "_start": "622-7-15"\n          }\n        }\n      },\n      "islamic-umalqura": {\n        "calendarSystem": "lunar",\n        "eras": {\n          "0": {\n            "_start": "622-7-15"\n          }\n        }\n      },\n      "japanese": {\n        "calendarSystem": "solar",\n        "eras": {\n          "0": {\n            "_start": "645-6-19"\n          },\n          "1": {\n            "_start": "650-2-15"\n          },\n          "10": {\n            "_start": "729-8-5"\n          },\n          "100": {\n            "_start": "1169-4-8"\n          },\n          "101": {\n            "_start": "1171-4-21"\n          },\n          "102": {\n            "_start": "1175-7-28"\n          },\n          "103": {\n            "_start": "1177-8-4"\n          },\n          "104": {\n            "_start": "1181-7-14"\n          },\n          "105": {\n            "_start": "1182-5-27"\n          },\n          "106": {\n            "_start": "1184-4-16"\n          },\n          "107": {\n            "_start": "1185-8-14"\n          },\n          "108": {\n            "_start": "1190-4-11"\n          },\n          "109": {\n            "_start": "1199-4-27"\n          },\n          "11": {\n            "_start": "749-4-14"\n          },\n          "110": {\n            "_start": "1201-2-13"\n          },\n          "111": {\n            "_start": "1204-2-20"\n          },\n          "112": {\n            "_start": "1206-4-27"\n          },\n          "113": {\n            "_start": "1207-10-25"\n          },\n          "114": {\n            "_start": "1211-3-9"\n          },\n          "115": {\n            "_start": "1213-12-6"\n          },\n          "116": {\n            "_start": "1219-4-12"\n          },\n          "117": {\n            "_start": "1222-4-13"\n          },\n          "118": {\n            "_start": "1224-11-20"\n          },\n          "119": {\n            "_start": "1225-4-20"\n          },\n          "12": {\n            "_start": "749-7-2"\n          },\n          "120": {\n            "_start": "1227-12-10"\n          },\n          "121": {\n            "_start": "1229-3-5"\n          },\n          "122": {\n            "_start": "1232-4-2"\n          },\n          "123": {\n            "_start": "1233-4-15"\n          },\n          "124": {\n            "_start": "1234-11-5"\n          },\n          "125": {\n            "_start": "1235-9-19"\n          },\n          "126": {\n            "_start": "1238-11-23"\n          },\n          "127": {\n            "_start": "1239-2-7"\n          },\n          "128": {\n            "_start": "1240-7-16"\n          },\n          "129": {\n            "_start": "1243-2-26"\n          },\n          "13": {\n            "_start": "757-8-18"\n          },\n          "130": {\n            "_start": "1247-2-28"\n          },\n          "131": {\n            "_start": "1249-3-18"\n          },\n          "132": {\n            "_start": "1256-10-5"\n          },\n          "133": {\n            "_start": "1257-3-14"\n          },\n          "134": {\n            "_start": "1259-3-26"\n          },\n          "135": {\n            "_start": "1260-4-13"\n          },\n          "136": {\n            "_start": "1261-2-20"\n          },\n          "137": {\n            "_start": "1264-2-28"\n          },\n          "138": {\n            "_start": "1275-4-25"\n          },\n          "139": {\n            "_start": "1278-2-29"\n          },\n          "14": {\n            "_start": "765-1-7"\n          },\n          "140": {\n            "_start": "1288-4-28"\n          },\n          "141": {\n            "_start": "1293-8-55"\n          },\n          "142": {\n            "_start": "1299-4-25"\n          },\n          "143": {\n            "_start": "1302-11-21"\n          },\n          "144": {\n            "_start": "1303-8-5"\n          },\n          "145": {\n            "_start": "1306-12-14"\n          },\n          "146": {\n            "_start": "1308-10-9"\n          },\n          "147": {\n            "_start": "1311-4-28"\n          },\n          "148": {\n            "_start": "1312-3-20"\n          },\n          "149": {\n            "_start": "1317-2-3"\n          },\n          "15": {\n            "_start": "767-8-16"\n          },\n          "150": {\n            "_start": "1319-4-28"\n          },\n          "151": {\n            "_start": "1321-2-23"\n          },\n          "152": {\n            "_start": "1324-12-9"\n          },\n          "153": {\n            "_start": "1326-4-26"\n          },\n          "154": {\n            "_start": "1329-8-29"\n          },\n          "155": {\n            "_start": "1331-8-9"\n          },\n          "156": {\n            "_start": "1334-1-29"\n          },\n          "157": {\n            "_start": "1336-2-29"\n          },\n          "158": {\n            "_start": "1340-4-28"\n          },\n          "159": {\n            "_start": "1346-12-8"\n          },\n          "16": {\n            "_start": "770-10-1"\n          },\n          "160": {\n            "_start": "1370-7-24"\n          },\n          "161": {\n            "_start": "1372-4-1"\n          },\n          "162": {\n            "_start": "1375-5-27"\n          },\n          "163": {\n            "_start": "1379-3-22"\n          },\n          "164": {\n            "_start": "1381-2-10"\n          },\n          "165": {\n            "_start": "1384-4-28"\n          },\n          "166": {\n            "_start": "1384-2-27"\n          },\n          "167": {\n            "_start": "1387-8-23"\n          },\n          "168": {\n            "_start": "1389-2-9"\n          },\n          "169": {\n            "_start": "1390-3-26"\n          },\n          "17": {\n            "_start": "781-1-1"\n          },\n          "170": {\n            "_start": "1394-7-5"\n          },\n          "171": {\n            "_start": "1428-4-27"\n          },\n          "172": {\n            "_start": "1429-9-5"\n          },\n          "173": {\n            "_start": "1441-2-17"\n          },\n          "174": {\n            "_start": "1444-2-5"\n          },\n          "175": {\n            "_start": "1449-7-28"\n          },\n          "176": {\n            "_start": "1452-7-25"\n          },\n          "177": {\n            "_start": "1455-7-25"\n          },\n          "178": {\n            "_start": "1457-9-28"\n          },\n          "179": {\n            "_start": "1460-12-21"\n          },\n          "18": {\n            "_start": "782-8-19"\n          },\n          "180": {\n            "_start": "1466-2-28"\n          },\n          "181": {\n            "_start": "1467-3-3"\n          },\n          "182": {\n            "_start": "1469-4-28"\n          },\n          "183": {\n            "_start": "1487-7-29"\n          },\n          "184": {\n            "_start": "1489-8-21"\n          },\n          "185": {\n            "_start": "1492-7-19"\n          },\n          "186": {\n            "_start": "1501-2-29"\n          },\n          "187": {\n            "_start": "1504-2-30"\n          },\n          "188": {\n            "_start": "1521-8-23"\n          },\n          "189": {\n            "_start": "1528-8-20"\n          },\n          "19": {\n            "_start": "806-5-18"\n          },\n          "190": {\n            "_start": "1532-7-29"\n          },\n          "191": {\n            "_start": "1555-10-23"\n          },\n          "192": {\n            "_start": "1558-2-28"\n          },\n          "193": {\n            "_start": "1570-4-23"\n          },\n          "194": {\n            "_start": "1573-7-28"\n          },\n          "195": {\n            "_start": "1592-12-8"\n          },\n          "196": {\n            "_start": "1596-10-27"\n          },\n          "197": {\n            "_start": "1615-7-13"\n          },\n          "198": {\n            "_start": "1624-2-30"\n          },\n          "199": {\n            "_start": "1644-12-16"\n          },\n          "2": {\n            "_start": "672-1-1"\n          },\n          "20": {\n            "_start": "810-9-19"\n          },\n          "200": {\n            "_start": "1648-2-15"\n          },\n          "201": {\n            "_start": "1652-9-18"\n          },\n          "202": {\n            "_start": "1655-4-13"\n          },\n          "203": {\n            "_start": "1658-7-23"\n          },\n          "204": {\n            "_start": "1661-4-25"\n          },\n          "205": {\n            "_start": "1673-9-21"\n          },\n          "206": {\n            "_start": "1681-9-29"\n          },\n          "207": {\n            "_start": "1684-2-21"\n          },\n          "208": {\n            "_start": "1688-9-30"\n          },\n          "209": {\n            "_start": "1704-3-13"\n          },\n          "21": {\n            "_start": "824-1-5"\n          },\n          "210": {\n            "_start": "1711-4-25"\n          },\n          "211": {\n            "_start": "1716-6-22"\n          },\n          "212": {\n            "_start": "1736-4-28"\n          },\n          "213": {\n            "_start": "1741-2-27"\n          },\n          "214": {\n            "_start": "1744-2-21"\n          },\n          "215": {\n            "_start": "1748-7-12"\n          },\n          "216": {\n            "_start": "1751-10-27"\n          },\n          "217": {\n            "_start": "1764-6-2"\n          },\n          "218": {\n            "_start": "1772-11-16"\n          },\n          "219": {\n            "_start": "1781-4-2"\n          },\n          "22": {\n            "_start": "834-1-3"\n          },\n          "220": {\n            "_start": "1789-1-25"\n          },\n          "221": {\n            "_start": "1801-2-5"\n          },\n          "222": {\n            "_start": "1804-2-11"\n          },\n          "223": {\n            "_start": "1818-4-22"\n          },\n          "224": {\n            "_start": "1830-12-10"\n          },\n          "225": {\n            "_start": "1844-12-2"\n          },\n          "226": {\n            "_start": "1848-2-28"\n          },\n          "227": {\n            "_start": "1854-11-27"\n          },\n          "228": {\n            "_start": "1860-3-18"\n          },\n          "229": {\n            "_start": "1861-2-19"\n          },\n          "23": {\n            "_start": "848-6-13"\n          },\n          "230": {\n            "_start": "1864-2-20"\n          },\n          "231": {\n            "_start": "1865-4-7"\n          },\n          "232": {\n            "_start": "1868-9-8"\n          },\n          "233": {\n            "_start": "1912-7-30"\n          },\n          "234": {\n            "_start": "1926-12-25"\n          },\n          "235": {\n            "_start": "1989-1-8"\n          },\n          "24": {\n            "_start": "851-4-28"\n          },\n          "25": {\n            "_start": "854-11-30"\n          },\n          "26": {\n            "_start": "857-2-21"\n          },\n          "27": {\n            "_start": "859-4-15"\n          },\n          "28": {\n            "_start": "877-4-16"\n          },\n          "29": {\n            "_start": "885-2-21"\n          },\n          "3": {\n            "_start": "686-7-20"\n          },\n          "30": {\n            "_start": "889-4-27"\n          },\n          "31": {\n            "_start": "898-4-26"\n          },\n          "32": {\n            "_start": "901-7-15"\n          },\n          "33": {\n            "_start": "923-4-11"\n          },\n          "34": {\n            "_start": "931-4-26"\n          },\n          "35": {\n            "_start": "938-5-22"\n          },\n          "36": {\n            "_start": "947-4-22"\n          },\n          "37": {\n            "_start": "957-10-27"\n          },\n          "38": {\n            "_start": "961-2-16"\n          },\n          "39": {\n            "_start": "964-7-10"\n          },\n          "4": {\n            "_start": "701-3-21"\n          },\n          "40": {\n            "_start": "968-8-13"\n          },\n          "41": {\n            "_start": "970-3-25"\n          },\n          "42": {\n            "_start": "973-12-20"\n          },\n          "43": {\n            "_start": "976-7-13"\n          },\n          "44": {\n            "_start": "978-11-29"\n          },\n          "45": {\n            "_start": "983-4-15"\n          },\n          "46": {\n            "_start": "985-4-27"\n          },\n          "47": {\n            "_start": "987-4-5"\n          },\n          "48": {\n            "_start": "989-8-8"\n          },\n          "49": {\n            "_start": "990-11-7"\n          },\n          "5": {\n            "_start": "704-5-10"\n          },\n          "50": {\n            "_start": "995-2-22"\n          },\n          "51": {\n            "_start": "999-1-13"\n          },\n          "52": {\n            "_start": "1004-7-20"\n          },\n          "53": {\n            "_start": "1012-12-25"\n          },\n          "54": {\n            "_start": "1017-4-23"\n          },\n          "55": {\n            "_start": "1021-2-2"\n          },\n          "56": {\n            "_start": "1024-7-13"\n          },\n          "57": {\n            "_start": "1028-7-25"\n          },\n          "58": {\n            "_start": "1037-4-21"\n          },\n          "59": {\n            "_start": "1040-11-10"\n          },\n          "6": {\n            "_start": "708-1-11"\n          },\n          "60": {\n            "_start": "1044-11-24"\n          },\n          "61": {\n            "_start": "1046-4-14"\n          },\n          "62": {\n            "_start": "1053-1-11"\n          },\n          "63": {\n            "_start": "1058-8-29"\n          },\n          "64": {\n            "_start": "1065-8-2"\n          },\n          "65": {\n            "_start": "1069-4-13"\n          },\n          "66": {\n            "_start": "1074-8-23"\n          },\n          "67": {\n            "_start": "1077-11-17"\n          },\n          "68": {\n            "_start": "1081-2-10"\n          },\n          "69": {\n            "_start": "1084-2-7"\n          },\n          "7": {\n            "_start": "715-9-2"\n          },\n          "70": {\n            "_start": "1087-4-7"\n          },\n          "71": {\n            "_start": "1094-12-15"\n          },\n          "72": {\n            "_start": "1096-12-17"\n          },\n          "73": {\n            "_start": "1097-11-21"\n          },\n          "74": {\n            "_start": "1099-8-28"\n          },\n          "75": {\n            "_start": "1104-2-10"\n          },\n          "76": {\n            "_start": "1106-4-9"\n          },\n          "77": {\n            "_start": "1108-8-3"\n          },\n          "78": {\n            "_start": "1110-7-13"\n          },\n          "79": {\n            "_start": "1113-7-13"\n          },\n          "8": {\n            "_start": "717-11-17"\n          },\n          "80": {\n            "_start": "1118-4-3"\n          },\n          "81": {\n            "_start": "1120-4-10"\n          },\n          "82": {\n            "_start": "1124-4-3"\n          },\n          "83": {\n            "_start": "1126-1-22"\n          },\n          "84": {\n            "_start": "1131-1-29"\n          },\n          "85": {\n            "_start": "1132-8-11"\n          },\n          "86": {\n            "_start": "1135-4-27"\n          },\n          "87": {\n            "_start": "1141-7-10"\n          },\n          "88": {\n            "_start": "1142-4-28"\n          },\n          "89": {\n            "_start": "1144-2-23"\n          },\n          "9": {\n            "_start": "724-2-4"\n          },\n          "90": {\n            "_start": "1145-7-22"\n          },\n          "91": {\n            "_start": "1151-1-26"\n          },\n          "92": {\n            "_start": "1154-10-28"\n          },\n          "93": {\n            "_start": "1156-4-27"\n          },\n          "94": {\n            "_start": "1159-4-20"\n          },\n          "95": {\n            "_start": "1160-1-10"\n          },\n          "96": {\n            "_start": "1161-9-4"\n          },\n          "97": {\n            "_start": "1163-3-29"\n          },\n          "98": {\n            "_start": "1165-6-5"\n          },\n          "99": {\n            "_start": "1166-8-27"\n          }\n        }\n      },\n      "persian": {\n        "calendarSystem": "solar",\n        "eras": {\n          "0": {\n            "_start": "622-01-01"\n          }\n        }\n      },\n      "roc": {\n        "eras": {\n          "0": {\n            "_end": "1911-12-31"\n          },\n          "1": {\n            "_start": "1912-01-01"\n          }\n        }\n      }\n    }\n  }\n}\n';});
;
define('ecma402/impl/calendarFunctions',[ "./Record", "requirejs-text/text!../cldr/supplemental/calendarData.json"],
	function (Record, calendarDataJson) {
	/**
	 * Utility functions that are common across multiple
	 * different calendars.  Functions that are unique to a specific calendar should be contained
	 * in the code for the given calendar, and not here.
	 * 
	 * @private
	 */
	var calendarData = JSON.parse(calendarDataJson).supplemental.calendarData;
	var calendarFunctions = {
		/**
		 * Used to determine when a given era begins, based on supplemental calendar data from CLDR.
		 * 
		 * @param {String} calendar The type of calendar
		 * @param {Number} era The era number
		 * @returns {Number} The year in which the given era begins
		 * @private
		 */
		eraOffset : function (calendar, era) {
			var eraStartDate = calendarData[calendar].eras[era.toString()]._start;
			var result = eraStartDate.charAt(0) === "-" ? Number(eraStartDate.split("-")[1]) * -1 :
				Number(eraStartDate.split("-")[0]);
			
			if (result <= 0) {
				result--; // Compensate for the fact that year 0 (Gregorian) doesn't exist.
			}
			return result;
		},
		/**
		 * Used to find the era for a given date. Starts at the most recent era (highest era number) and works
		 * backwards. Right now, findEra is only used in the Japanese and ROC calendar implementations, so
		 * we don't have to worry about eras starting in a year numbered less than 0.
		 * 
		 * @param {String} calendar The type of calendar
		 * @param {Date} date The date for which we are trying to determine the era
		 * @param {Number} maxEra The maximum era number in the given calendar
		 * @returns {Number} The number of the era in which the given date resides
		 * @private
		 */
		findEra : function (calendar, date, maxEra) {
			var currentEra = maxEra;
			while (currentEra >= 0) {
				var compareDate = new Date();
				var eraStartDate = calendarData[calendar].eras[currentEra.toString()]._start;
				if (!eraStartDate) {
					return currentEra;
				}
				var pieces = eraStartDate.split("-");
				compareDate.setFullYear(pieces[0], pieces[1] - 1, pieces[2] - 1);
				if (date >= compareDate) {
					return currentEra;
				}
				currentEra--;
			}
			return currentEra; // Return -1 if date is before the start of era #0
		},
		/**
		 * Used to set the hour, minute, second, and inDST fields, which usually don't vary across calendars.
		 * 
		 * @param {Date} dt The date used as the basis for setting fields
		 * @param {String} timeZone String representing the time zone (UTC or local)
		 * @param {Record} result The object representing the resulting date/time
		 * @private
		 */
		setTimeFields : function (dt, timeZone, result) {
			result.set("hour", timeZone === "UTC" ? dt.getUTCHours() : dt.getHours());
			result.set("minute", timeZone === "UTC" ? dt.getUTCMinutes() : dt.getMinutes());
			result.set("second", timeZone === "UTC" ? dt.getUTCSeconds() : dt.getSeconds());
			var localMinutes = dt.getHours() * 60 + dt.getMinutes();
			var UTCMinutes = dt.getUTCHours() * 60 + dt.getUTCMinutes();
			result.set("inDST", timeZone === "UTC" ? false : localMinutes + dt.getTimezoneOffset() !== UTCMinutes);
		}
	};
	return calendarFunctions;
});;
define('ecma402/calendars/buddhistCalendar',[ "../impl/Record", "../impl/calendarFunctions"],
	function (Record, calendarFunctions) {
	var calendarBuddhist = {
		toLocalTime : function (date, timeZone) {
			var result = new Record();
			var dt = new Date(date);
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			result.set("era", 0);
			var year = timeZone === "UTC" ? dt.getUTCFullYear() : dt.getFullYear();
			year -= calendarFunctions.eraOffset("buddhist", 0);
			result.set("year", year);
			result.set("month", timeZone === "UTC" ? dt.getUTCMonth() : dt.getMonth());
			result.set("day", timeZone === "UTC" ? dt.getUTCDate() : dt.getDate());
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
	return calendarBuddhist;
});;
define(
	'ecma402/calendars/japaneseCalendar',[ "../impl/Record", "../impl/calendarFunctions" ],
	function (Record, calendarFunctions) {
	var japaneseCalendar = {
		toLocalTime : function (date, timeZone) {
			var result = new Record();
			var dt = new Date(date);
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			/*
			 * Current highest era number in Japanese calendar is 235 - Will need to bump this up if Japan gets a new
			 * emperor!!!
			 */
			var maxJapaneseEra = 235;
			var era = calendarFunctions.findEra("japanese", dt, maxJapaneseEra);
			var year = timeZone === "UTC" ? dt.getUTCFullYear() : dt.getFullYear();
			var offset = calendarFunctions.eraOffset("japanese", era >= 0 ? era : 0);
			result.set("era", era >= 0 ? era : 0);
			result.set("year", year - offset + 1);
			result.set("month", timeZone === "UTC" ? dt.getUTCMonth() : dt.getMonth());
			result.set("day", timeZone === "UTC" ? dt.getUTCDate() : dt.getDate());
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
	return japaneseCalendar;
});;
define(
	'ecma402/calendars/hebrewCalendar',[ "../impl/Record", "../impl/calendarFunctions" ], function (Record, calendarFunctions) {
	// A helek ( plural halakim ) is the basic unit of time measurement in the Hebrew calendar.
	// There are exactly 1080 halakim in an hour. Ref: http://en.wikipedia.org/wiki/Helek
	var HALAKIM_PER_HOUR = 1080;
	var HALAKIM_PER_DAY = 24 * HALAKIM_PER_HOUR;
	var HALAKIM_FRACTIONAL_MONTH = 12 * HALAKIM_PER_HOUR + 793;
	var HALAKIM_PER_MONTH = 29 * HALAKIM_PER_DAY + HALAKIM_FRACTIONAL_MONTH; // Refers to a Hebrew mean month.
	// BAHARAD refers to the time of the new moon (in halakim) on 1 Tishri, year 1 (the epoch)
	// counting from noon on the day before.
	var BAHARAD = 11 * HALAKIM_PER_HOUR + 204;
	var MILLIS_PER_MINUTE = 60000;

	function isLeapYear(year) {
		var x = (year * 12 + 17) % 19;
		return x >= ((x < 0) ? -7 : 12);
	}

	function firstDayOfYear(year) {
		var monthsBeforeYear = Math.floor((235 * year - 234) / 19);
		var fractionalMonthsBeforeYear = monthsBeforeYear * HALAKIM_FRACTIONAL_MONTH + BAHARAD;
		var dayNumber = monthsBeforeYear * 29 + Math.floor(fractionalMonthsBeforeYear / HALAKIM_PER_DAY);
		var timeOfDay = fractionalMonthsBeforeYear % HALAKIM_PER_DAY;

		var dayOfWeek = dayNumber % 7; // 0 == Monday

		// Postponement rules.
		if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) {
			dayNumber++;
			dayOfWeek = dayNumber % 7;
		}
		if (dayOfWeek === 1 && timeOfDay > 15 * HALAKIM_PER_HOUR + 204 && !isLeapYear(year)) {
			dayNumber += 2;
		} else if (dayOfWeek === 0 && timeOfDay > 21 * HALAKIM_PER_HOUR + 589 && isLeapYear(year - 1)) {
			dayNumber++;
		}
		return dayNumber;
	}

	var calendarHebrew = {
		isLeapYear : isLeapYear,
		toLocalTime : function (date, timeZone) {
			var result = new Record();
			var dt = new Date(date);
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			result.set("era", 0);
			var MILLIS_PER_DAY = 86400000;
			var HEBREW_DAY_ON_JAN_1_1970 = 2092591;
			var time = timeZone === "UTC" ? dt.getTime() : dt.getTime() - dt.getTimezoneOffset() * MILLIS_PER_MINUTE;
			var daysSinceEpoch = Math.floor(time / MILLIS_PER_DAY) + HEBREW_DAY_ON_JAN_1_1970;
			var monthsSinceEpoch = Math.floor(daysSinceEpoch * HALAKIM_PER_DAY / HALAKIM_PER_MONTH);
			var year = Math.floor((monthsSinceEpoch * 19 + 234) / 235) + 1;
			var firstDayOfThisYear = firstDayOfYear(year);
			var dayOfYear = daysSinceEpoch - firstDayOfThisYear;
			while (dayOfYear < 1) {
				year--;
				firstDayOfThisYear = firstDayOfYear(year);
				dayOfYear = daysSinceEpoch - firstDayOfThisYear;
			}
			var yearLength = firstDayOfYear(year + 1) - firstDayOfThisYear;
			if (yearLength > 380) {
				yearLength -= 30;
			}
			var yearType = yearLength - 353; // This should result in 0 = deficient, 1 = normal, 2 = complete
			var leapYear = isLeapYear(year);
			var daysInMonth = leapYear ?
				[ 30, 29, 29, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29 ] :
				[ 30, 29, 29, 29, 30, 29, 30, 29, 30, 29, 30, 29 ];
			if (yearType > 0) {
				daysInMonth[2]++; // Kislev gets an extra day in normal or complete years.
			}
			if (yearType > 1) {
				daysInMonth[1]++; // Heshvan gets an extra day in complete years only.
			}
			var month = 0;
			var day = dayOfYear;
			while (day > daysInMonth[month]) {
				day -= daysInMonth[month];
				month++;
			}
			result.set("year", year);
			result.set("month", month);
			result.set("day", day);
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
	return calendarHebrew;
});
;
define('ecma402/calendars/umalquraCalendar',["../impl/Record", "../impl/calendarFunctions", "./gregorianCalendar", "./islamicCalendar"],
	function (Record, calendarFunctions, gregorian, islamicCalendar) {

    return {

        MONTH_LENGTH:
            //1300-1304
            ["101010101010", "110101010100", "111011001001", "011011010100", "011011101010",
            //1305-1309
            "001101101100", "101010101101", "010101010101", "011010101001", "011110010010",
            //1310-1314
            "101110101001", "010111010100", "101011011010", "010101011100", "110100101101",
            //1315-1319
            "011010010101", "011101001010", "101101010100", "101101101010", "010110101101",
            //1320-1324
            "010010101110", "101001001111", "010100010111", "011010001011", "011010100101",
            //1325-1329
            "101011010101", "001011010110", "100101011011", "010010011101", "101001001101",
            //1330-1334
            "110100100110", "110110010101", "010110101100", "100110110110", "001010111010",
            //1335-1339
            "101001011011", "010100101011", "101010010101", "011011001010", "101011101001",
            //1340-1344
            "001011110100", "100101110110", "001010110110", "100101010110", "101011001010",
            //1345-1349
            "101110100100", "101111010010", "010111011001", "001011011100", "100101101101",
            //1350-1354
            "010101001101", "101010100101", "101101010010", "101110100101", "010110110100",
            //1355-1359
            "100110110110", "010101010111", "001010010111", "010101001011", "011010100011",
            //1360-1364
            "011101010010", "101101100101", "010101101010", "101010101011", "010100101011",
            //1365-1369
            "110010010101", "110101001010", "110110100101", "010111001010", "101011010110",
            //1370-1374
            "100101010111", "010010101011", "100101001011", "101010100101", "101101010010",
            //1375-1379
            "101101101010", "010101110101", "001001110110", "100010110111", "010001011011",
            //1380-1384
            "010101010101", "010110101001", "010110110100", "100111011010", "010011011101",
            //1385-1389
            "001001101110", "100100110110", "101010101010", "110101010100", "110110110010",
            //1390-1394
            "010111010101", "001011011010", "100101011011", "010010101011", "101001010101",
            //1395-1399
            "101101001001", "101101100100", "101101110001", "010110110100", "101010110101",
            //1400-1404
            "101001010101", "110100100101", "111010010010", "111011001001", "011011010100",
            //1405-1409
            "101011101001", "100101101011", "010010101011", "101010010011", "110101001001",
            //1410-1414
            "110110100100", "110110110010", "101010111001", "010010111010", "101001011011",
            //1415-1419
            "010100101011", "101010010101", "101100101010", "101101010101", "010101011100",
            //1420-1424
            "010010111101", "001000111101", "100100011101", "101010010101", "101101001010",
            //1425-1429
            "101101011010", "010101101101", "001010110110", "100100111011", "010010011011",
            //1430-1434
            "011001010101", "011010101001", "011101010100", "101101101010", "010101101100",
            //1435-1439
            "101010101101", "010101010101", "101100101001", "101110010010", "101110101001",
            //1440-1444
            "010111010100", "101011011010", "010101011010", "101010101011", "010110010101",
            //1445-1449
            "011101001001", "011101100100", "101110101010", "010110110101", "001010110110",
            //1450-1454
            "101001010110", "111001001101", "101100100101", "101101010010", "101101101010",
            //1455-1459
            "010110101101", "001010101110", "100100101111", "010010010111", "011001001011",
            //1460-1464
            "011010100101", "011010101100", "101011010110", "010101011101", "010010011101",
            //1465-1469
            "101001001101", "110100010110", "110110010101", "010110101010", "010110110101",
            //1470-1474
            "001011011010", "100101011011", "010010101101", "010110010101", "011011001010",
            //1475-1479
            "011011100100", "101011101010", "010011110101", "001010110110", "100101010110",
            //1480-1484
            "101010101010", "101101010100", "101111010010", "010111011001", "001011101010",
            //1485-1489
            "100101101101", "010010101101", "101010010101", "101101001010", "101110100101",
            //1490-1494
            "010110110010", "100110110101", "010011010110", "101010010111", "010101000111",
            //1495-1499
            "011010010011", "011101001001", "101101010101", "010101101010", "101001101011",
            //1500-1504
            "010100101011", "101010001011", "110101000110", "110110100011", "010111001010",
            //1505-1509
            "101011010110", "010011011011", "001001101011", "100101001011", "101010100101",
            //1510-1514
            "101101010010", "101101101001", "010101110101", "000101110110", "100010110111",
            //1515-1519
            "001001011011", "010100101011", "010101100101", "010110110100", "100111011010",
            //1520-1524
            "010011101101", "000101101101", "100010110110", "101010100110", "110101010010",
            //1525-1529
            "110110101001", "010111010100", "101011011010", "100101011011", "010010101011",
            //1530-1534
            "011001010011", "011100101001", "011101100010", "101110101001", "010110110010",
            //1535-1539
            "101010110101", "010101010101", "101100100101", "110110010010", "111011001001",
            //1540-1544
            "011011010010", "101011101001", "010101101011", "010010101011", "101001010101",
            //1545-1549
            "110100101001", "110101010100", "110110101010", "100110110101", "010010111010",
            //1550-1554
            "101000111011", "010010011011", "101001001101", "101010101010", "101011010101",
            //1555-1559
            "001011011010", "100101011101", "010001011110", "101000101110", "110010011010",
            //1560-1564
            "110101010101", "011010110010", "011010111001", "010010111010", "101001011101",
            //1565-1569
            "010100101101", "101010010101", "101101010010", "101110101000", "101110110100",
            //1570-1574
            "010110111001", "001011011010", "100101011010", "101101001010", "110110100100",
            //1575-1579
            "111011010001", "011011101000", "101101101010", "010101101101", "010100110101",
            //1580-1584
            "011010010101", "110101001010", "110110101000", "110111010100", "011011011010",
            //1585-1589
            "010101011011", "001010011101", "011000101011", "101100010101", "101101001010",
            //1590-1594
            "101110010101", "010110101010", "101010101110", "100100101110", "110010001111",
            //1595-1599
            "010100100111", "011010010101", "011010101010", "101011010110", "010101011101",
            //1600
            "001010011101"
        ],
        
        getDaysDiff: function (date1, date2) {
            // summary:
            //		This function returns the number of days between two different dates.
            var ONE_DAY = 1000 * 60 * 60 * 24;
            var diff = Math.abs(date1.getTime() - date2.getTime());
            return Math.round(diff / ONE_DAY);

        },

        fromGregorian: function ( /* Date */ gdate) {
            // summary:
            //		This function returns the equivalent islamic(umalqura) date value for a give input gregorian date.
            // gdate: Date
            //      Gregorian date which will be converted to islamic date
            // returns:
            //      Islamic(umalqura) date.
            var date = new Date(gdate);
            var gregorianFirstRef = new Date(1882, 10, 12, 0, 0, 0, 0);
            var gregorianLastRef = new Date(2174, 10, 25, 23, 59, 59, 999);
            var daysDiff = this.getDaysDiff(date, gregorianFirstRef);
            if (date - gregorianFirstRef >= 0 && date - gregorianLastRef <= 0) {
                var year = 1300;
                for (var i = 0; i < this.MONTH_LENGTH.length; i++, year++) {
                    for (var j = 0; j < 12; j++) {
                        var numOfDays = parseInt(this.MONTH_LENGTH[i][j], 10) + 29;
                        if (daysDiff <= numOfDays) {
                            this.date = daysDiff + 1;
                            if (this.date > numOfDays) {
                                this.date = 1;
                                j++;
                            }
                            if (j > 11) {
                                j = 0;
                                year++;
                            }
                            this.month = j;
                            this.year = year;
                            this.hours = date.getHours();
                            this.minutes = date.getMinutes();
                            this.seconds = date.getSeconds();
                            this.milliseconds = date.getMilliseconds();
                            this.day = date.getDay();
                            return this;
                        }
                        daysDiff = parseInt(daysDiff, 10) - numOfDays;
                    }
                }
            } else {
                var islamicDate = islamicCalendar.fromGregorian(date);
                this.date = islamicDate.date;
                this.month = islamicDate.month;
                this.year = islamicDate.year;
                this.hours = islamicDate.hours;
                this.minutes = islamicDate.minutes;
                this.seconds = islamicDate.seconds;
                this.milliseconds = islamicDate.milliseconds;
                this.day = islamicDate.day;
            }
            return this;
        },

        toLocalTime: function (date, timeZone) {
            var islamicDate = this.fromGregorian(date);
            var dt = new Date(date);
            var result = new Record();
            result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
            result.set("era", 0);
            result.set("year", islamicDate.year);
            result.set("month", islamicDate.month);
            result.set("day", islamicDate.date);
            calendarFunctions.setTimeFields(dt, timeZone, result);
            return result;
        }
    };
});;
define(
	'ecma402/calendars/gregorianCalendar',[ "../impl/Record", "../impl/calendarFunctions" ],
	function (Record, calendarFunctions) {
	var gregorianCalendar = {
		toLocalTime : function (date, timeZone) {
			var result = new Record();
			var dt = new Date(date);
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			var year = timeZone === "UTC" ? dt.getUTCFullYear() : dt.getFullYear();
			if (year <= 0) {
				result.set("era", 0);
				year--; // Compensate for fact that year 0 doesn't exist.
				year = -year;
			} else {
				result.set("era", 1);
			}
			result.set("year", year);
			result.set("month", timeZone === "UTC" ? dt.getUTCMonth() : dt.getMonth());
			result.set("day", timeZone === "UTC" ? dt.getUTCDate() : dt.getDate());
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
	return gregorianCalendar;
});;
define('ecma402/calendars/civilTabularCalendar',[ "../impl/Record", "../impl/calendarFunctions"], function (Record, calendarFunctions) {
	return {
		CIVIL_EPOC : 1948439.5,
		ASTRONOMICAL_EPOC : 1948438.5,
		GREGORIAN_EPOCH : 1721425.5,
		isGregorianLeapYear : function (year) {
			// summary:
			//		Determines if the year is a leap year in the Gregorian calendar.
			// description:
			//		Leap years are years with an additional day YYYY-02-29, where the
			//		Year number is a multiple of four with the following exception: If
			//		A year is a multiple of 100, then it is only a leap year if it is
			//		Also a multiple of 400. For example, 1900 was not a leap year, but
			//		2000 is one.
			return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
		},
		getIslamicYearStart : function (/*Number*/ year) {
			// summary:
			//		Return start of Islamic year.
			return (year - 1) * 354	+ Math.floor((3 + 11 * year) / 30.0);
		},
		getIslamicMonthStart : function (/*Number*/ year, /*Number*/ month) {
			// summary:
			//		Return the start of Islamic Month.
			return Math.ceil(29.5 * month) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30.0);
		},
		fromGregorian : function (/*Date*/ gdate, /*String*/ cType) {
			// summary:
			//		This function returns the equivalent islamic(civil/tabular) date value 
			//		for a give input gregorian date.
			// gdate: Date
			//      Gregorian date which will be converted to islamic(civil/tabular) date
			// cType: String
			//      The type of the islamic calendar the gregorain date should converted to.
			//		The expected values are 'civil' or 'tbla'
			// returns:
			//      Islamic(civil/tabular) date.
			var date = new Date(gdate);
			var gYear = date.getFullYear(),
				gMonth = date.getMonth(),
				gDay = date.getDate();
			var julianDay = (this.GREGORIAN_EPOCH - 1) + (365 * (gYear - 1)) + Math.floor((gYear - 1) / 4)
						+ (-Math.floor((gYear - 1) / 100)) + Math.floor((gYear - 1) / 400)
						+ Math.floor((((367 * (gMonth + 1)) - 362) / 12)
						+ (((gMonth + 1) <= 2) ? 0 : (this.isGregorianLeapYear(gYear) ? -1 : -2)) + gDay);
			julianDay = Math.floor(julianDay) + 0.5;
			var  days = julianDay - this.CIVIL_EPOC;
			if (cType === "tbla") {
				days = julianDay - this.ASTRONOMICAL_EPOC;
			}
			var hYear  = Math.floor((30 * days + 10646) / 10631.0);
			var hMonth = Math.ceil((days - 29 - this.getIslamicYearStart(hYear)) / 29.5);
			hMonth = Math.min(hMonth, 11);
			var hDay = Math.ceil(days - this.getIslamicMonthStart(hYear, hMonth) + 1);

			this.date = hDay;
			this.month = hMonth;
			this.year = hYear;
			this.hours = date.getHours();
			this.minutes = date.getMinutes();
			this.seconds = date.getSeconds();
			this.milliseconds = date.getMilliseconds();
			this.day = date.getDay();
			return this;
		},
		
		toLocalTime : function (date, timeZone, cType) {
			var islamicDate = this.fromGregorian(date, cType);
			var dt = new Date(date);
			var result = new Record();
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			result.set("era", 0);
			result.set("year", islamicDate.year);
			result.set("month", islamicDate.month);
			result.set("day", islamicDate.date);
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		}
	};
});;
define(
	'ecma402/calendars/islamicCalendar',[ "../impl/Record", "../impl/calendarFunctions"], function (Record, calendarFunctions) {

		
	return {
		
		SYNODIC_MONTH     : 29.530588853,
		TROPICAL_YEAR     : 365.242191,

		CIVIL_EPOC        : 1948440,
		JD_EPOCH          : 2447891.5,
		EPOCH_JULIAN_DAY  : 2440588,

		SUN_ETA_G         : 279.403303 * Math.PI / 180,
		SUN_OMEGA_G       : 282.768422 * Math.PI / 180,
		SUN_E             : 0.016713,

		DAY_MS            : 24 * 60 * 60 * 1000,
		JULIAN_EPOCH_MS   : -210866760000000,
		HIJRA_MS          : -42521587200000,

		MOON_L0           : 318.351648 * Math.PI / 180,
		MOON_P0           : 36.340410  * Math.PI / 180,
		MOON_N0           : 318.510107 * Math.PI / 180,
		MOON_I            : 5.145366   * Math.PI / 180,

		fromGregorian: function (/*Date*/ gdate) {
			// summary:
			//		This function returns the equivalent Islamic Date value for the Gregorian Date
			var date = new Date(gdate);

			var localMillis = date.getTime() - date.getTimezoneOffset() * 60 * 1000;
			var julianDay = this._floorDivide(localMillis, this.DAY_MS) + this.EPOCH_JULIAN_DAY;

			var days = julianDay - this.CIVIL_EPOC;
			
			// Guess at the number of elapsed full months since the epoch
			var months = Math.floor(days / this.SYNODIC_MONTH);

			var monthStart = Math.floor(months * this.SYNODIC_MONTH - 1);

			if (days - monthStart >= 25 && this._moonAge(date.getTime()) > 0) {
				// If we're near the end of the month, assume next month and search backwards
				months++;
			}

			// Find out the last time that the new moon was actually visible at this longitude
			// This returns midnight the night that the moon was visible at sunset.
			while ((monthStart = this._trueMonthStart(months)) > days) {
				// If it was after the date in question, back up a month and try again
				months--;
			}

			var year = Math.floor(months / 12) + 1;
			var month = months % 12;
			var day = Math.floor(days - this._monthStart(year, month)) + 1;

			this.date = day;
			this.month = month;
			this.year = year;
			this.hours = date.getHours();
			this.minutes = date.getMinutes();
			this.seconds = date.getSeconds();
			this.milliseconds = date.getMilliseconds();
			this.day = date.getDay();
			return this;
		},

		toLocalTime: function (date, timeZone) {
			var islamicDate = this.fromGregorian(date);
			var dt = new Date(date);
			var result = new Record();
			result.set("weekday", timeZone === "UTC" ? dt.getUTCDay() : dt.getDay());
			result.set("era", 0);
			result.set("year", islamicDate.year);
			result.set("month", islamicDate.month);
			result.set("day", islamicDate.date);
			calendarFunctions.setTimeFields(dt, timeZone, result);
			return result;
		},

		_floorDivide: function (numerator, denominator) {
			// summary:
			//		Divide two long integers, returning the floor of the quotient.
			//		Unlike the built-in division, this is mathematically well-behaved.
			//		E.g., -1/4 => 0
			//		but _floorDivide(-1,4) => -1.
			// numerator: Long
			//		The numerator
			// denominator: Long
			//		A divisor which must be > 0
			// returns:
			//		The floor of the quotient.

			// We do this computation in order to handle
			// a numerator of Long.MIN_VALUE correctly
			return Math.floor((numerator >= 0) ? numerator / denominator : ((numerator + 1) / denominator) - 1);
		},

		_monthStart: function (year, month) {
			// summary:
			//		Return the day # on which the given month starts.  Days are counted
			//		From the Hijri epoch, origin 0.
			// year: Integer
			//		The hijri year
			// month: Integer
			//		The hijri month, 0-based

			// Normalize year/month in case month is outside the normal bounds, which may occur
			// in the case of an add operation
			var realYear = year + Math.floor(month / 12);
			var realMonth = month % 12;
			var ms = this._trueMonthStart(12 * (realYear - 1) + realMonth);
			return ms;
		},

		_trueMonthStart: function (month) {
			// summary:
			//		Find the day number on which a particular month of the true/lunar
			//		Islamic calendar starts.
			// month:
			//		The month in question, origin 0 from the Hijri epoch
			// returns:
			//		The day number on which the given month starts.

			// Make a guess at when the month started, using the average length
			var origin = this.HIJRA_MS + Math.floor(month * this.SYNODIC_MONTH) * this.DAY_MS;

			var age = this._moonAge(origin);

			if (this._moonAge(origin) >= 0) {
				// The month has already started
				do {
					origin -= this.DAY_MS;
					age = this._moonAge(origin);
				} while (age >= 0);
			}
			else {
				// Preceding month has not ended yet.
				do {
					origin += this.DAY_MS;
					age = this._moonAge(origin);
				} while (age < 0);
			}

			var start = Math.floor((origin - this.HIJRA_MS) / this.DAY_MS) + 1;
			return start;
		},

		_moonAge: function (time) {
		// summary:
		//		Return the "age" of the moon at the given time; this is the difference
		//		In ecliptic latitude between the moon and the sun.  This method simply
		//		Calls this._getMoonAge, converts to degrees, 
		//		And adjusts the result to be in the range [-180, 180].
		// time: Long
		//		The time at which the moon's age is desired, in millis since 1/1/1970.

			this._time = time;
			var age = this._getMoonAge();
			// Convert to degrees and normalize...
			age = age * 180 / Math.PI;
			if (age > 180) {
				age = age - 360;
			}

			return age;
		},

		_getJulianDay: function () {
		// summary:
		//		Get the current time of this object,
		//		Expressed as a "julian day number", which is the number of elapsed
		//		Days since 1/1/4713 BC (Julian), 12:00 GMT.

			var julianDay = (this._time - this.JULIAN_EPOCH_MS) / this.DAY_MS;
			return julianDay;
		},

		_getSunLongitude: function (julian) {
			// summary:
			//		The longitude of the sun at the time specified by this object.
			//		The longitude is measured in radians along the ecliptic
			//		from the "first point of Aries," the point at which the ecliptic
			//		Crosses the earth's equatorial plane at the vernal equinox.
			//		Currently, this method uses an approximation of the two-body Kepler's
			//		Equation for the earth and the sun.  It does not take into account the
			//		Perturbations caused by the other planets, the moon, etc.
			// julian: Double
			//		The current time expressed as a julian day number
			// returns: Object

			var day = julian - this.JD_EPOCH;       // Days since epoch

			// Find the angular distance the sun in a fictitious
			// circular orbit has travelled since the epoch.
			var epochAngle = this._norm2PI(2 * Math.PI / this.TROPICAL_YEAR * day);

			// The epoch wasn't at the sun's perigee; find the angular distance
			// since perigee, which is called the "mean anomaly"
			var meanAnomaly = this._norm2PI(epochAngle + this.SUN_ETA_G - this.SUN_OMEGA_G);

			// Now find the "true anomaly", e.g. the real solar longitude
			// by solving Kepler's equation for an elliptical orbit
			// NOTE: The 3rd ed. of the book lists omega_g and eta_g in different
			// equations; omega_g is to be correct.
			return {
				sunLongitude : this._norm2PI(this._trueAnomaly(meanAnomaly, this.SUN_E) + this.SUN_OMEGA_G),
				meanAnomalySun: meanAnomaly
			};
		},

		_getMoonAge: function () {
			// summary:
			//		The "age" of the moon at the time specified in this object.
			//		This is really the angle between the
			//		Current ecliptic longitudes of the sun and the moon,
			//		Measured in radians.

			// Calculate the solar longitude.  Has the side effect of
			// filling in "meanAnomalySun" as well.
			var ret = this._getSunLongitude(this._getJulianDay());
			var sunLongitude = ret.sunLongitude;
			var meanAnomalySun = ret.meanAnomalySun;

			//
			// Find the # of days since the epoch of our orbital parameters.
			//
			var day = this._getJulianDay() - this.JD_EPOCH;       // Days since epoch
			
			// Calculate the mean longitude and anomaly of the moon, based on
			// a circular orbit.  Similar to the corresponding solar calculation.
			var meanLongitude = this._norm2PI(13.1763966 * Math.PI / 180 * day + this.MOON_L0);
			var meanAnomalyMoon = this._norm2PI(meanLongitude - 0.1114041 * Math.PI / 180 * day - this.MOON_P0);

			//
			// Calculate the following corrections:
			//  Evection:   the sun's gravity affects the moon's eccentricity
			//  Annual Eqn: variation in the effect due to earth-sun distance
			//  A3:         correction factor (for ???)
			//
			var evection = 1.2739 * Math.PI / 180 * Math.sin(2 * (meanLongitude - sunLongitude) - meanAnomalyMoon);
			var annual   = 0.1858 * Math.PI / 180 * Math.sin(meanAnomalySun);
			var a3       = 0.3700 * Math.PI / 180 * Math.sin(meanAnomalySun);

			meanAnomalyMoon += evection - annual - a3;

			//
			// More correction factors:
			//  center  equation of the center correction
			//  a4      yet another error correction (???)
			//
			var center = 6.2886 * Math.PI / 180 * Math.sin(meanAnomalyMoon);
			var a4     = 0.2140 * Math.PI / 180 * Math.sin(2 * meanAnomalyMoon);

			// Now find the moon's corrected longitude
			var moonLongitude = meanLongitude + evection + center - annual + a4;

			//
			// And finally, find the variation, caused by the fact that the sun's
			// gravitational pull on the moon varies depending on which side of
			// the earth the moon is on
			//
			var variation = 0.6583 * Math.PI / 180 * Math.sin(2 * (moonLongitude - sunLongitude));

			moonLongitude += variation;

			//
			// What we've calculated so far is the moon's longitude in the plane
			// of its own orbit.  Now map to the ecliptic to get the latitude
			// and longitude.  First we need to find the longitude of the ascending
			// node, the position on the ecliptic where it is crossed by the moon's
			// orbit as it crosses from the southern to the northern hemisphere.
			//
			var nodeLongitude = this._norm2PI(this.MOON_N0 - 0.0529539 * Math.PI / 180 * day);

			nodeLongitude -= 0.16 * Math.PI / 180 * Math.sin(meanAnomalySun);

			var y = Math.sin(moonLongitude - nodeLongitude);
			var x = Math.cos(moonLongitude - nodeLongitude);
			
			var moonEclipLong = Math.atan2(y * Math.cos(this.MOON_I), x) + nodeLongitude;

			return this._norm2PI(moonEclipLong - sunLongitude);
		},

		_norm2PI: function (angle) {
			// summary:
			//		Normalize an angle so that it's in the range 0 - 2pi.
			//		For positive angles this is just (angle % 2pi), but the Java
			//		mod operator doesn't work that way for negative numbers....
			// angle: Double
			//		The angle to be normalized in radians
			// returns:
			//		The normalized angle
			return angle - 2 * Math.PI * Math.floor(angle / (2 * Math.PI));
		},

		_trueAnomaly: function (meanAnomaly, eccentricity) {
			// summary:
			//		Find the "true anomaly" (longitude) of an object from
			//		Its mean anomaly and the eccentricity of its orbit.  This uses
			//		An iterative solution to Kepler's equation.
			// meanAnomaly: Double
			//		The object's longitude calculated as if it were in
			//		A regular, circular orbit, measured in radians
			//		From the point of perigee.  
			// eccentricity: Double
			//		The eccentricity of the orbit
			// returns:
			//		The true anomaly (longitude) measured in radians

			// First, solve Kepler's equation iteratively
			// Duffett-Smith, p.90
			var delta;
			var E = meanAnomaly;
			do {
				delta = E - eccentricity * Math.sin(E) - meanAnomaly;
				E = E - delta / (1 - eccentricity * Math.cos(E));
			}
			while (Math.abs(delta) > 1e-5); // epsilon = 1e-5 rad

			return 2.0 * Math.atan(Math.tan(E / 2) * Math.sqrt((1 + eccentricity) / (1 - eccentricity)));
		}
	};
});;
/**
 * Plugin to pre-load the locales the app has specified via:
 *
 * require.config({
 *		config: {
 * 			"ecma402/locales":  /^(ar-(TN|SA)|en|es|hi|ja|de)$/
 *		}
 * });
 */
define('ecma402/locales',[
	"module",
	"require",
	"./impl/common",
	"./impl/load"
], function (module, require, common, load) {
	// Build variable
	var writeFile;

	// Compute locales to pre-load. Use hash to remove duplicates.
	var localeHash = {};
	localeHash.root = true;
	localeHash[common.DefaultLocale()] = true;
	var config = module.config();
	if (config instanceof RegExp) {
		common.availableLocalesList.forEach(function (locale) {
			if (config.test(locale)) {
				localeHash[locale] = true;
			}
		});
	} else {
		if (typeof config === "string") {
			config = [ config ];
		}
		if (config instanceof Array) {
			config.forEach(function (locale) {
				var bestFitPreload = common.BestFitAvailableLocale(common.availableLocalesList, locale);
				if (bestFitPreload) {
					localeHash[bestFitPreload] = true;
				}
			});
		}
	}
	var locales = Object.keys(localeHash);
	var localeDataHash = {};

	// Compute dependencies to require()
	function getDependency(locale) {
		return load.id + "!" + locale;
	}

	function isObject(value) {
		return Object.prototype.toString.call(value) === "[object Object]";
	}

	return {
		load: function (path, callerRequire, onload, loaderConfig) {
			if (isObject(config) && loaderConfig.isBuild) {
				localeHash = {};
				common.availableLocalesList.forEach(function (locale) {
					localeHash[locale] = true;
				});
				locales = Object.keys(localeHash);
			}

			var dependencies = locales.map(getDependency);
			// Load the locale data for every requested locale, and then return it in a hash
			require(dependencies, function () {
				var localeDataArray = arguments;
				locales.forEach(function (locale, idx) {
					localeDataHash[locale] = localeDataArray[idx];
				});
				onload(localeDataHash);
			});
		},

		writeFile: function (pluginName, resource, callerRequire, write) {
			writeFile = write;
		},

		addModules: function (pluginName, resource, addModules) {
			var modulesToAdd = [];
			locales.forEach(function (locale) {
				var localeData = localeDataHash[locale];
				var calendarsDeps = localeData.calendars.map(function (cal) {return "./calendars/" + cal; });
				modulesToAdd = modulesToAdd.concat(calendarsDeps);
				delete localeData.calendars;
			});
			addModules(modulesToAdd);
		},

		onLayerEnd: function (write, data) {
			// Calculate layer path
			var match = data.path.match(/^(.*\/)?(.*)\.js$/);
			var partialLayerPath = (match[1] || "") + "cldr/" + match[2] + "_";

			// Calculate layer mid
			match = data.name.match(/^(.*\/)?(.*)$/);
			var layerMid = (match[1] || "") + "cldr/" + match[2];

			locales.forEach(function (locale) {
				var path = partialLayerPath + locale + ".js";
				writeFile(path, "define(" + JSON.stringify(localeDataHash[locale]) + ")");
			});

			localeHash._layerMid = layerMid;
			write("require.config({config:{'" + load.id + "':" + JSON.stringify(localeHash) + "}});");

			// Reset
			localeDataHash = {};
		}
	};
});
;
/**
 * Plugin to load a single locale.  For example, load!en returns
 * an Object like { currencies: ..., numbers: ..., "ca-gregorian": ... }.
 * Used by locales! plugin.
 */
define('ecma402/impl/load',[
    "./calendars",
	"./common",
	"require",
	"module",
	"requirejs-text/text"	// just so builder knows we will be using that module
], function (calendars, common, require, module) {
	return {
		id: module.id,

		load: function (locale, callerRequire, onload, loaderConfig) {
			// Compute dependencies to require().
			// For specified locale, load JSON files for its "currencies", "numbers" data.
			var jsonElements = ["currencies", "numbers"];
			var calendarsToLoad = [];
			var region = common._getRegion(locale);
			var supportedCalendars = common._getSupportedCalendars(region);
			supportedCalendars.forEach(function (calendar) {
				var calendarName = "ca-" +  (calendar === "gregory" ? "gregorian" : calendar);
				// Add json data
				jsonElements.push(calendarName);
				// Add calendar module
				if (calendar !== "gregory") {
					calendarsToLoad.push(calendar);
				}
			});

			var dependencies;

			// Check if there is a layer
			var config = module.config();
			if (config[locale]) {
				dependencies = jsonElements = [config._layerMid + "_" + locale];
			} else {
				dependencies = jsonElements.map(function (element) {
					return "requirejs-text/text!../cldr/" + locale + "/" + element + ".json";
				});
			}

			var calendarDependencies = calendarsToLoad.map(function (calendar) {
				return "../calendars/" + calendars.dependencies[calendar].calendar;
			});

			dependencies = dependencies.concat(calendarDependencies);

			// Load all the JSON files requested, and any non-gregorian calendars
			// that are required. Return the locale data in a hash
			require(dependencies, function () {
				var dataAsArray = arguments, dataAsHash = {};
				jsonElements.forEach(function (element, idx) {
					if (config[locale]) {
						dataAsHash = dataAsArray[0];
					} else {
						dataAsHash[element] = JSON.parse(dataAsArray[idx]);
					}
				});
				calendarsToLoad.forEach(function (cal, idx) {
					calendars.calendarMap[cal] = dataAsArray[idx + jsonElements.length];
				});

				if (loaderConfig.isBuild) {
					dataAsHash.calendars = calendarsToLoad.map(function (calendar) {
						return calendars.dependencies[calendar].calendar;
					});
				}

				onload(dataAsHash);
			});
		}
	};
});
;
define('requirejs-text/text!ecma402/cldr/config/availableLocales.json',[],function () { return '{\n \t"availableLocales": [\n\t\t"af",\n\t\t"af-NA",\n\t\t"am",\n\t\t"ar",\n\t\t"ar-AE",\n\t\t"ar-BH",\n\t\t"ar-DZ",\n\t\t"ar-EG",\n\t\t"ar-IQ",\n\t\t"ar-JO",\n\t\t"ar-KW",\n\t\t"ar-LB",\n\t\t"ar-LY",\n\t\t"ar-MA",\n\t\t"ar-OM",\n\t\t"ar-QA",\n\t\t"ar-SA",\n\t\t"ar-SD",\n\t\t"ar-SY",\n\t\t"ar-TN",\n\t\t"ar-YE",\n\t\t"as",\n\t\t"az",\n\t\t"be",\n\t\t"bg",\n\t\t"bn",\n\t\t"bn-IN",\n\t\t"ca",\n\t\t"cs",\n\t\t"cy",\n\t\t"da",\n\t\t"de",\n\t\t"de-AT",\n\t\t"de-LU",\n\t\t"de-CH",\n\t\t"el",\n\t\t"en",\n\t\t"en-AU",\n\t\t"en-BE",\n\t\t"en-CM",\n\t\t"en-CA",\n\t\t"en-GB",\n\t\t"en-GH",\n\t\t"en-HK",\n\t\t"en-IE",\n\t\t"en-IN",\n\t\t"en-KE",\n\t\t"en-MU",\n\t\t"en-NG",\n\t\t"en-NZ",\n\t\t"en-PH",\n\t\t"en-SG",\n\t\t"en-TT",\n\t\t"en-ZA",\n\t\t"en-ZM",\n\t\t"es",\n\t\t"es-AR",\n\t\t"es-BO",\n\t\t"es-CL",\n\t\t"es-CO",\n\t\t"es-CR",\n\t\t"es-DO",\n\t\t"es-EC",\n\t\t"es-GT",\n\t\t"es-HN",\n\t\t"es-MX",\n\t\t"es-NI",\n\t\t"es-PA",\n\t\t"es-PE",\n\t\t"es-PR",\n\t\t"es-PY",\n\t\t"es-SV",\n\t\t"es-US",\n\t\t"es-UY",\n\t\t"es-VE",\n\t\t"eu",\n\t\t"fil",\n\t\t"fi",\n\t\t"fr",\n\t\t"fr-BE",\n\t\t"fr-CA",\n\t\t"fr-CD",\n\t\t"fr-CH",\n\t\t"fr-CI",\n\t\t"fr-CM",\n\t\t"fr-DZ",\n\t\t"fr-LU",\n\t\t"fr-MR",\n\t\t"fr-MA",\n\t\t"fr-SN",\n\t\t"fr-TN",\n\t\t"gl",\n\t\t"gu",\n\t\t"ha",\n\t\t"he",\n\t\t"hi",\n\t\t"hr",\n\t\t"hu",\n\t\t"hy",\n\t\t"id",\n\t\t"ig",\n\t\t"is",\n\t\t"it",\n\t\t"it-CH",\n\t\t"ja",\n\t\t"ka",\n\t\t"kk",\n\t\t"km",\n\t\t"kn",\n\t\t"ko",\n\t\t"kok",\n\t\t"lg",\n\t\t"lt",\n\t\t"lv",\n\t\t"mk",\n\t\t"ml",\n\t\t"mn",\n\t\t"mr",\n\t\t"ms",\n\t\t"mt",\n\t\t"nb",\n\t\t"ne",\n\t\t"ne-IN",\n\t\t"nl",\n\t\t"nl-BE",\n\t\t"nn",\n\t\t"om",\n\t\t"or",\n\t\t"pa",\n\t\t"pl",\n\t\t"pt",\n\t\t"pt-AO",\n\t\t"pt-MZ",\n\t\t"pt-PT",\n\t\t"ro",\n\t\t"root",\n\t\t"ru",\n\t\t"rw",\n\t\t"si",\n\t\t"sk",\n\t\t"sl",\n\t\t"sr",\n\t\t"sr-Latn",\n\t\t"sq",\n\t\t"sv",\n\t\t"sw",\n\t\t"sw-KE",\n\t\t"ta",\n\t\t"te",\n\t\t"th",\n\t\t"tr",\n\t\t"uk",\n\t\t"ur",\n\t\t"ur-IN",\n\t\t"uz",\n\t\t"uz-Cyrl",\n\t\t"vi",\n\t\t"yo",\n\t\t"zh",\n\t\t"zh-Hans",\n\t\t"zh-Hans-SG",\n\t\t"zh-Hant",\n\t\t"zh-Hant-HK"\n\t]\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/aliases.json',[],function () { return '{\n  "supplemental": {\n    "metadata": {\n      "alias": {\n        "languageAlias": {\n          "aa-SAAHO": {\n            "_replacement": "ssy",\n            "_reason": "deprecated"\n          },\n          "aar": {\n            "_replacement": "aa",\n            "_reason": "overlong"\n          },\n          "abk": {\n            "_replacement": "ab",\n            "_reason": "overlong"\n          },\n          "afr": {\n            "_replacement": "af",\n            "_reason": "overlong"\n          },\n          "aju": {\n            "_replacement": "jrb",\n            "_reason": "macrolanguage"\n          },\n          "aka": {\n            "_replacement": "ak",\n            "_reason": "overlong"\n          },\n          "alb": {\n            "_replacement": "sq",\n            "_reason": "bibliographic"\n          },\n          "als": {\n            "_replacement": "sq",\n            "_reason": "macrolanguage"\n          },\n          "amh": {\n            "_replacement": "am",\n            "_reason": "overlong"\n          },\n          "ara": {\n            "_replacement": "ar",\n            "_reason": "overlong"\n          },\n          "arb": {\n            "_replacement": "ar",\n            "_reason": "macrolanguage"\n          },\n          "arg": {\n            "_replacement": "an",\n            "_reason": "overlong"\n          },\n          "arm": {\n            "_replacement": "hy",\n            "_reason": "bibliographic"\n          },\n          "art-lojban": {\n            "_replacement": "jbo",\n            "_reason": "deprecated"\n          },\n          "asm": {\n            "_replacement": "as",\n            "_reason": "overlong"\n          },\n          "ava": {\n            "_replacement": "av",\n            "_reason": "overlong"\n          },\n          "ave": {\n            "_replacement": "ae",\n            "_reason": "overlong"\n          },\n          "aym": {\n            "_replacement": "ay",\n            "_reason": "overlong"\n          },\n          "ayr": {\n            "_replacement": "ay",\n            "_reason": "macrolanguage"\n          },\n          "az-AZ": {\n            "_replacement": "az-Latn-AZ",\n            "_reason": "legacy"\n          },\n          "aze": {\n            "_replacement": "az",\n            "_reason": "overlong"\n          },\n          "azj": {\n            "_replacement": "az",\n            "_reason": "macrolanguage"\n          },\n          "bak": {\n            "_replacement": "ba",\n            "_reason": "overlong"\n          },\n          "bam": {\n            "_replacement": "bm",\n            "_reason": "overlong"\n          },\n          "baq": {\n            "_replacement": "eu",\n            "_reason": "bibliographic"\n          },\n          "bcc": {\n            "_replacement": "bal",\n            "_reason": "macrolanguage"\n          },\n          "bcl": {\n            "_replacement": "bik",\n            "_reason": "macrolanguage"\n          },\n          "bel": {\n            "_replacement": "be",\n            "_reason": "overlong"\n          },\n          "ben": {\n            "_replacement": "bn",\n            "_reason": "overlong"\n          },\n          "bih": {\n            "_replacement": "bh",\n            "_reason": "overlong"\n          },\n          "bis": {\n            "_replacement": "bi",\n            "_reason": "overlong"\n          },\n          "bod": {\n            "_replacement": "bo",\n            "_reason": "overlong"\n          },\n          "bos": {\n            "_replacement": "bs",\n            "_reason": "overlong"\n          },\n          "bre": {\n            "_replacement": "br",\n            "_reason": "overlong"\n          },\n          "bs-BA": {\n            "_replacement": "bs-Latn-BA",\n            "_reason": "legacy"\n          },\n          "bul": {\n            "_replacement": "bg",\n            "_reason": "overlong"\n          },\n          "bur": {\n            "_replacement": "my",\n            "_reason": "bibliographic"\n          },\n          "bxk": {\n            "_replacement": "luy",\n            "_reason": "macrolanguage"\n          },\n          "bxr": {\n            "_replacement": "bua",\n            "_reason": "macrolanguage"\n          },\n          "cat": {\n            "_replacement": "ca",\n            "_reason": "overlong"\n          },\n          "ces": {\n            "_replacement": "cs",\n            "_reason": "overlong"\n          },\n          "cha": {\n            "_replacement": "ch",\n            "_reason": "overlong"\n          },\n          "che": {\n            "_replacement": "ce",\n            "_reason": "overlong"\n          },\n          "chi": {\n            "_replacement": "zh",\n            "_reason": "bibliographic"\n          },\n          "chu": {\n            "_replacement": "cu",\n            "_reason": "overlong"\n          },\n          "chv": {\n            "_replacement": "cv",\n            "_reason": "overlong"\n          },\n          "cld": {\n            "_replacement": "syr",\n            "_reason": "macrolanguage"\n          },\n          "cmn": {\n            "_replacement": "zh",\n            "_reason": "macrolanguage"\n          },\n          "cor": {\n            "_replacement": "kw",\n            "_reason": "overlong"\n          },\n          "cos": {\n            "_replacement": "co",\n            "_reason": "overlong"\n          },\n          "cre": {\n            "_replacement": "cr",\n            "_reason": "overlong"\n          },\n          "cwd": {\n            "_replacement": "cr",\n            "_reason": "macrolanguage"\n          },\n          "cym": {\n            "_replacement": "cy",\n            "_reason": "overlong"\n          },\n          "cze": {\n            "_replacement": "cs",\n            "_reason": "bibliographic"\n          },\n          "dan": {\n            "_replacement": "da",\n            "_reason": "overlong"\n          },\n          "deu": {\n            "_replacement": "de",\n            "_reason": "overlong"\n          },\n          "dgo": {\n            "_replacement": "doi",\n            "_reason": "macrolanguage"\n          },\n          "dhd": {\n            "_replacement": "mwr",\n            "_reason": "macrolanguage"\n          },\n          "dik": {\n            "_replacement": "din",\n            "_reason": "macrolanguage"\n          },\n          "diq": {\n            "_replacement": "zza",\n            "_reason": "macrolanguage"\n          },\n          "div": {\n            "_replacement": "dv",\n            "_reason": "overlong"\n          },\n          "dut": {\n            "_replacement": "nl",\n            "_reason": "bibliographic"\n          },\n          "dzo": {\n            "_replacement": "dz",\n            "_reason": "overlong"\n          },\n          "ekk": {\n            "_replacement": "et",\n            "_reason": "macrolanguage"\n          },\n          "ell": {\n            "_replacement": "el",\n            "_reason": "overlong"\n          },\n          "emk": {\n            "_replacement": "man",\n            "_reason": "macrolanguage"\n          },\n          "eng": {\n            "_replacement": "en",\n            "_reason": "overlong"\n          },\n          "epo": {\n            "_replacement": "eo",\n            "_reason": "overlong"\n          },\n          "esk": {\n            "_replacement": "ik",\n            "_reason": "macrolanguage"\n          },\n          "est": {\n            "_replacement": "et",\n            "_reason": "overlong"\n          },\n          "eus": {\n            "_replacement": "eu",\n            "_reason": "overlong"\n          },\n          "ewe": {\n            "_replacement": "ee",\n            "_reason": "overlong"\n          },\n          "fao": {\n            "_replacement": "fo",\n            "_reason": "overlong"\n          },\n          "fas": {\n            "_replacement": "fa",\n            "_reason": "overlong"\n          },\n          "fat": {\n            "_replacement": "ak",\n            "_reason": "macrolanguage"\n          },\n          "fij": {\n            "_replacement": "fj",\n            "_reason": "overlong"\n          },\n          "fin": {\n            "_replacement": "fi",\n            "_reason": "overlong"\n          },\n          "fra": {\n            "_replacement": "fr",\n            "_reason": "overlong"\n          },\n          "fre": {\n            "_replacement": "fr",\n            "_reason": "bibliographic"\n          },\n          "fry": {\n            "_replacement": "fy",\n            "_reason": "overlong"\n          },\n          "fuc": {\n            "_replacement": "ff",\n            "_reason": "macrolanguage"\n          },\n          "ful": {\n            "_replacement": "ff",\n            "_reason": "overlong"\n          },\n          "gaz": {\n            "_replacement": "om",\n            "_reason": "macrolanguage"\n          },\n          "gbo": {\n            "_replacement": "grb",\n            "_reason": "macrolanguage"\n          },\n          "geo": {\n            "_replacement": "ka",\n            "_reason": "bibliographic"\n          },\n          "ger": {\n            "_replacement": "de",\n            "_reason": "bibliographic"\n          },\n          "gla": {\n            "_replacement": "gd",\n            "_reason": "overlong"\n          },\n          "gle": {\n            "_replacement": "ga",\n            "_reason": "overlong"\n          },\n          "glg": {\n            "_replacement": "gl",\n            "_reason": "overlong"\n          },\n          "glv": {\n            "_replacement": "gv",\n            "_reason": "overlong"\n          },\n          "gno": {\n            "_replacement": "gon",\n            "_reason": "macrolanguage"\n          },\n          "gre": {\n            "_replacement": "el",\n            "_reason": "bibliographic"\n          },\n          "grn": {\n            "_replacement": "gn",\n            "_reason": "overlong"\n          },\n          "gug": {\n            "_replacement": "gn",\n            "_reason": "macrolanguage"\n          },\n          "guj": {\n            "_replacement": "gu",\n            "_reason": "overlong"\n          },\n          "gya": {\n            "_replacement": "gba",\n            "_reason": "macrolanguage"\n          },\n          "ha-GH": {\n            "_replacement": "ha-Latn-GH",\n            "_reason": "legacy"\n          },\n          "ha-NE": {\n            "_replacement": "ha-Latn-NE",\n            "_reason": "legacy"\n          },\n          "ha-NG": {\n            "_replacement": "ha-Latn-NG",\n            "_reason": "legacy"\n          },\n          "hat": {\n            "_replacement": "ht",\n            "_reason": "overlong"\n          },\n          "hau": {\n            "_replacement": "ha",\n            "_reason": "overlong"\n          },\n          "hbs": {\n            "_replacement": "sr-Latn",\n            "_reason": "overlong"\n          },\n          "hdn": {\n            "_replacement": "hai",\n            "_reason": "macrolanguage"\n          },\n          "hea": {\n            "_replacement": "hmn",\n            "_reason": "macrolanguage"\n          },\n          "heb": {\n            "_replacement": "he",\n            "_reason": "overlong"\n          },\n          "her": {\n            "_replacement": "hz",\n            "_reason": "overlong"\n          },\n          "him": {\n            "_replacement": "srx",\n            "_reason": "macrolanguage"\n          },\n          "hin": {\n            "_replacement": "hi",\n            "_reason": "overlong"\n          },\n          "hmo": {\n            "_replacement": "ho",\n            "_reason": "overlong"\n          },\n          "hrv": {\n            "_replacement": "hr",\n            "_reason": "overlong"\n          },\n          "hun": {\n            "_replacement": "hu",\n            "_reason": "overlong"\n          },\n          "hye": {\n            "_replacement": "hy",\n            "_reason": "overlong"\n          },\n          "i-ami": {\n            "_replacement": "ami",\n            "_reason": "deprecated"\n          },\n          "i-bnn": {\n            "_replacement": "bnn",\n            "_reason": "deprecated"\n          },\n          "i-hak": {\n            "_replacement": "hak",\n            "_reason": "deprecated"\n          },\n          "i-klingon": {\n            "_replacement": "tlh",\n            "_reason": "deprecated"\n          },\n          "i-lux": {\n            "_replacement": "lb",\n            "_reason": "deprecated"\n          },\n          "i-navajo": {\n            "_replacement": "nv",\n            "_reason": "deprecated"\n          },\n          "i-pwn": {\n            "_replacement": "pwn",\n            "_reason": "deprecated"\n          },\n          "i-tao": {\n            "_replacement": "tao",\n            "_reason": "deprecated"\n          },\n          "i-tay": {\n            "_replacement": "tay",\n            "_reason": "deprecated"\n          },\n          "i-tsu": {\n            "_replacement": "tsu",\n            "_reason": "deprecated"\n          },\n          "ibo": {\n            "_replacement": "ig",\n            "_reason": "overlong"\n          },\n          "ice": {\n            "_replacement": "is",\n            "_reason": "bibliographic"\n          },\n          "ido": {\n            "_replacement": "io",\n            "_reason": "overlong"\n          },\n          "iii": {\n            "_replacement": "ii",\n            "_reason": "overlong"\n          },\n          "ike": {\n            "_replacement": "iu",\n            "_reason": "macrolanguage"\n          },\n          "iku": {\n            "_replacement": "iu",\n            "_reason": "overlong"\n          },\n          "ile": {\n            "_replacement": "ie",\n            "_reason": "overlong"\n          },\n          "in": {\n            "_replacement": "id",\n            "_reason": "deprecated"\n          },\n          "ina": {\n            "_replacement": "ia",\n            "_reason": "overlong"\n          },\n          "ind": {\n            "_replacement": "id",\n            "_reason": "overlong"\n          },\n          "ipk": {\n            "_replacement": "ik",\n            "_reason": "overlong"\n          },\n          "isl": {\n            "_replacement": "is",\n            "_reason": "overlong"\n          },\n          "ita": {\n            "_replacement": "it",\n            "_reason": "overlong"\n          },\n          "iw": {\n            "_replacement": "he",\n            "_reason": "deprecated"\n          },\n          "jav": {\n            "_replacement": "jv",\n            "_reason": "overlong"\n          },\n          "ji": {\n            "_replacement": "yi",\n            "_reason": "deprecated"\n          },\n          "jpn": {\n            "_replacement": "ja",\n            "_reason": "overlong"\n          },\n          "jw": {\n            "_replacement": "jv",\n            "_reason": "deprecated"\n          },\n          "kal": {\n            "_replacement": "kl",\n            "_reason": "overlong"\n          },\n          "kan": {\n            "_replacement": "kn",\n            "_reason": "overlong"\n          },\n          "kas": {\n            "_replacement": "ks",\n            "_reason": "overlong"\n          },\n          "kat": {\n            "_replacement": "ka",\n            "_reason": "overlong"\n          },\n          "kau": {\n            "_replacement": "kr",\n            "_reason": "overlong"\n          },\n          "kaz": {\n            "_replacement": "kk",\n            "_reason": "overlong"\n          },\n          "khk": {\n            "_replacement": "mn",\n            "_reason": "macrolanguage"\n          },\n          "khm": {\n            "_replacement": "km",\n            "_reason": "overlong"\n          },\n          "kik": {\n            "_replacement": "ki",\n            "_reason": "overlong"\n          },\n          "kin": {\n            "_replacement": "rw",\n            "_reason": "overlong"\n          },\n          "kir": {\n            "_replacement": "ky",\n            "_reason": "overlong"\n          },\n          "kk-KZ": {\n            "_replacement": "kk-Cyrl-KZ",\n            "_reason": "legacy"\n          },\n          "kmr": {\n            "_replacement": "ku",\n            "_reason": "macrolanguage"\n          },\n          "knc": {\n            "_replacement": "kr",\n            "_reason": "macrolanguage"\n          },\n          "kng": {\n            "_replacement": "kg",\n            "_reason": "macrolanguage"\n          },\n          "knn": {\n            "_replacement": "kok",\n            "_reason": "macrolanguage"\n          },\n          "kom": {\n            "_replacement": "kv",\n            "_reason": "overlong"\n          },\n          "kon": {\n            "_replacement": "kg",\n            "_reason": "overlong"\n          },\n          "kor": {\n            "_replacement": "ko",\n            "_reason": "overlong"\n          },\n          "kpv": {\n            "_replacement": "kv",\n            "_reason": "macrolanguage"\n          },\n          "ks-IN": {\n            "_replacement": "ks-Arab-IN",\n            "_reason": "legacy"\n          },\n          "kua": {\n            "_replacement": "kj",\n            "_reason": "overlong"\n          },\n          "kur": {\n            "_replacement": "ku",\n            "_reason": "overlong"\n          },\n          "ky-KG": {\n            "_replacement": "ky-Cyrl-KG",\n            "_reason": "legacy"\n          },\n          "lao": {\n            "_replacement": "lo",\n            "_reason": "overlong"\n          },\n          "lat": {\n            "_replacement": "la",\n            "_reason": "overlong"\n          },\n          "lav": {\n            "_replacement": "lv",\n            "_reason": "overlong"\n          },\n          "lbk": {\n            "_replacement": "bnc",\n            "_reason": "macrolanguage"\n          },\n          "lim": {\n            "_replacement": "li",\n            "_reason": "overlong"\n          },\n          "lin": {\n            "_replacement": "ln",\n            "_reason": "overlong"\n          },\n          "lit": {\n            "_replacement": "lt",\n            "_reason": "overlong"\n          },\n          "ltz": {\n            "_replacement": "lb",\n            "_reason": "overlong"\n          },\n          "lub": {\n            "_replacement": "lu",\n            "_reason": "overlong"\n          },\n          "lug": {\n            "_replacement": "lg",\n            "_reason": "overlong"\n          },\n          "lvs": {\n            "_replacement": "lv",\n            "_reason": "macrolanguage"\n          },\n          "mac": {\n            "_replacement": "mk",\n            "_reason": "bibliographic"\n          },\n          "mah": {\n            "_replacement": "mh",\n            "_reason": "overlong"\n          },\n          "mal": {\n            "_replacement": "ml",\n            "_reason": "overlong"\n          },\n          "mao": {\n            "_replacement": "mi",\n            "_reason": "bibliographic"\n          },\n          "mar": {\n            "_replacement": "mr",\n            "_reason": "overlong"\n          },\n          "may": {\n            "_replacement": "ms",\n            "_reason": "bibliographic"\n          },\n          "mhr": {\n            "_replacement": "chm",\n            "_reason": "macrolanguage"\n          },\n          "mkd": {\n            "_replacement": "mk",\n            "_reason": "overlong"\n          },\n          "mlg": {\n            "_replacement": "mg",\n            "_reason": "overlong"\n          },\n          "mlt": {\n            "_replacement": "mt",\n            "_reason": "overlong"\n          },\n          "mn-MN": {\n            "_replacement": "mn-Cyrl-MN",\n            "_reason": "legacy"\n          },\n          "mnk": {\n            "_replacement": "man",\n            "_reason": "macrolanguage"\n          },\n          "mo": {\n            "_replacement": "ro-MD",\n            "_reason": "deprecated"\n          },\n          "mol": {\n            "_replacement": "ro-MD",\n            "_reason": "overlong"\n          },\n          "mon": {\n            "_replacement": "mn",\n            "_reason": "overlong"\n          },\n          "mri": {\n            "_replacement": "mi",\n            "_reason": "overlong"\n          },\n          "ms-BN": {\n            "_replacement": "ms-Latn-BN",\n            "_reason": "legacy"\n          },\n          "ms-MY": {\n            "_replacement": "ms-Latn-MY",\n            "_reason": "legacy"\n          },\n          "ms-SG": {\n            "_replacement": "ms-Latn-SG",\n            "_reason": "legacy"\n          },\n          "msa": {\n            "_replacement": "ms",\n            "_reason": "overlong"\n          },\n          "mup": {\n            "_replacement": "raj",\n            "_reason": "macrolanguage"\n          },\n          "mya": {\n            "_replacement": "my",\n            "_reason": "overlong"\n          },\n          "nau": {\n            "_replacement": "na",\n            "_reason": "overlong"\n          },\n          "nav": {\n            "_replacement": "nv",\n            "_reason": "overlong"\n          },\n          "nbl": {\n            "_replacement": "nr",\n            "_reason": "overlong"\n          },\n          "nde": {\n            "_replacement": "nd",\n            "_reason": "overlong"\n          },\n          "ndo": {\n            "_replacement": "ng",\n            "_reason": "overlong"\n          },\n          "nep": {\n            "_replacement": "ne",\n            "_reason": "overlong"\n          },\n          "nld": {\n            "_replacement": "nl",\n            "_reason": "overlong"\n          },\n          "nno": {\n            "_replacement": "nn",\n            "_reason": "overlong"\n          },\n          "no": {\n            "_replacement": "nb",\n            "_reason": "legacy"\n          },\n          "no-BOKMAL": {\n            "_replacement": "nb",\n            "_reason": "deprecated"\n          },\n          "no-NYNORSK": {\n            "_replacement": "nn",\n            "_reason": "deprecated"\n          },\n          "no-bok": {\n            "_replacement": "nb",\n            "_reason": "deprecated"\n          },\n          "no-nyn": {\n            "_replacement": "nn",\n            "_reason": "deprecated"\n          },\n          "nob": {\n            "_replacement": "nb",\n            "_reason": "overlong"\n          },\n          "nor": {\n            "_replacement": "nb",\n            "_reason": "overlong"\n          },\n          "npi": {\n            "_replacement": "ne",\n            "_reason": "macrolanguage"\n          },\n          "nya": {\n            "_replacement": "ny",\n            "_reason": "overlong"\n          },\n          "oci": {\n            "_replacement": "oc",\n            "_reason": "overlong"\n          },\n          "ojg": {\n            "_replacement": "oj",\n            "_reason": "macrolanguage"\n          },\n          "oji": {\n            "_replacement": "oj",\n            "_reason": "overlong"\n          },\n          "ori": {\n            "_replacement": "or",\n            "_reason": "overlong"\n          },\n          "orm": {\n            "_replacement": "om",\n            "_reason": "overlong"\n          },\n          "ory": {\n            "_replacement": "or",\n            "_reason": "macrolanguage"\n          },\n          "oss": {\n            "_replacement": "os",\n            "_reason": "overlong"\n          },\n          "pa-IN": {\n            "_replacement": "pa-Guru-IN",\n            "_reason": "legacy"\n          },\n          "pa-PK": {\n            "_replacement": "pa-Arab-PK",\n            "_reason": "legacy"\n          },\n          "pan": {\n            "_replacement": "pa",\n            "_reason": "overlong"\n          },\n          "pbu": {\n            "_replacement": "ps",\n            "_reason": "macrolanguage"\n          },\n          "per": {\n            "_replacement": "fa",\n            "_reason": "bibliographic"\n          },\n          "pes": {\n            "_replacement": "fa",\n            "_reason": "macrolanguage"\n          },\n          "pli": {\n            "_replacement": "pi",\n            "_reason": "overlong"\n          },\n          "plt": {\n            "_replacement": "mg",\n            "_reason": "macrolanguage"\n          },\n          "pnb": {\n            "_replacement": "lah",\n            "_reason": "macrolanguage"\n          },\n          "pol": {\n            "_replacement": "pl",\n            "_reason": "overlong"\n          },\n          "por": {\n            "_replacement": "pt",\n            "_reason": "overlong"\n          },\n          "pus": {\n            "_replacement": "ps",\n            "_reason": "overlong"\n          },\n          "que": {\n            "_replacement": "qu",\n            "_reason": "overlong"\n          },\n          "quz": {\n            "_replacement": "qu",\n            "_reason": "macrolanguage"\n          },\n          "rmy": {\n            "_replacement": "rom",\n            "_reason": "macrolanguage"\n          },\n          "roh": {\n            "_replacement": "rm",\n            "_reason": "overlong"\n          },\n          "ron": {\n            "_replacement": "ro",\n            "_reason": "overlong"\n          },\n          "rum": {\n            "_replacement": "ro",\n            "_reason": "bibliographic"\n          },\n          "run": {\n            "_replacement": "rn",\n            "_reason": "overlong"\n          },\n          "rus": {\n            "_replacement": "ru",\n            "_reason": "overlong"\n          },\n          "sag": {\n            "_replacement": "sg",\n            "_reason": "overlong"\n          },\n          "san": {\n            "_replacement": "sa",\n            "_reason": "overlong"\n          },\n          "sgn-BE-FR": {\n            "_replacement": "sfb",\n            "_reason": "deprecated"\n          },\n          "sgn-BE-NL": {\n            "_replacement": "vgt",\n            "_reason": "deprecated"\n          },\n          "sgn-CH-DE": {\n            "_replacement": "sgg",\n            "_reason": "deprecated"\n          },\n          "sh": {\n            "_replacement": "sr-Latn",\n            "_reason": "legacy"\n          },\n          "shi-MA": {\n            "_replacement": "shi-Tfng-MA",\n            "_reason": "legacy"\n          },\n          "sin": {\n            "_replacement": "si",\n            "_reason": "overlong"\n          },\n          "slk": {\n            "_replacement": "sk",\n            "_reason": "overlong"\n          },\n          "slo": {\n            "_replacement": "sk",\n            "_reason": "bibliographic"\n          },\n          "slv": {\n            "_replacement": "sl",\n            "_reason": "overlong"\n          },\n          "sme": {\n            "_replacement": "se",\n            "_reason": "overlong"\n          },\n          "smo": {\n            "_replacement": "sm",\n            "_reason": "overlong"\n          },\n          "sna": {\n            "_replacement": "sn",\n            "_reason": "overlong"\n          },\n          "snd": {\n            "_replacement": "sd",\n            "_reason": "overlong"\n          },\n          "som": {\n            "_replacement": "so",\n            "_reason": "overlong"\n          },\n          "sot": {\n            "_replacement": "st",\n            "_reason": "overlong"\n          },\n          "spa": {\n            "_replacement": "es",\n            "_reason": "overlong"\n          },\n          "spy": {\n            "_replacement": "kln",\n            "_reason": "macrolanguage"\n          },\n          "sqi": {\n            "_replacement": "sq",\n            "_reason": "overlong"\n          },\n          "sr-BA": {\n            "_replacement": "sr-Cyrl-BA",\n            "_reason": "legacy"\n          },\n          "sr-ME": {\n            "_replacement": "sr-Latn-ME",\n            "_reason": "legacy"\n          },\n          "sr-RS": {\n            "_replacement": "sr-Cyrl-RS",\n            "_reason": "legacy"\n          },\n          "sr-XK": {\n            "_replacement": "sr-Cyrl-XK",\n            "_reason": "legacy"\n          },\n          "src": {\n            "_replacement": "sc",\n            "_reason": "macrolanguage"\n          },\n          "srd": {\n            "_replacement": "sc",\n            "_reason": "overlong"\n          },\n          "srp": {\n            "_replacement": "sr",\n            "_reason": "overlong"\n          },\n          "ssw": {\n            "_replacement": "ss",\n            "_reason": "overlong"\n          },\n          "sun": {\n            "_replacement": "su",\n            "_reason": "overlong"\n          },\n          "swa": {\n            "_replacement": "sw",\n            "_reason": "overlong"\n          },\n          "swe": {\n            "_replacement": "sv",\n            "_reason": "overlong"\n          },\n          "swh": {\n            "_replacement": "sw",\n            "_reason": "macrolanguage"\n          },\n          "tah": {\n            "_replacement": "ty",\n            "_reason": "overlong"\n          },\n          "tam": {\n            "_replacement": "ta",\n            "_reason": "overlong"\n          },\n          "tat": {\n            "_replacement": "tt",\n            "_reason": "overlong"\n          },\n          "tel": {\n            "_replacement": "te",\n            "_reason": "overlong"\n          },\n          "tgk": {\n            "_replacement": "tg",\n            "_reason": "overlong"\n          },\n          "tgl": {\n            "_replacement": "fil",\n            "_reason": "overlong"\n          },\n          "tha": {\n            "_replacement": "th",\n            "_reason": "overlong"\n          },\n          "tib": {\n            "_replacement": "bo",\n            "_reason": "bibliographic"\n          },\n          "tir": {\n            "_replacement": "ti",\n            "_reason": "overlong"\n          },\n          "tl": {\n            "_replacement": "fil",\n            "_reason": "legacy"\n          },\n          "ton": {\n            "_replacement": "to",\n            "_reason": "overlong"\n          },\n          "tsn": {\n            "_replacement": "tn",\n            "_reason": "overlong"\n          },\n          "tso": {\n            "_replacement": "ts",\n            "_reason": "overlong"\n          },\n          "ttq": {\n            "_replacement": "tmh",\n            "_reason": "macrolanguage"\n          },\n          "tuk": {\n            "_replacement": "tk",\n            "_reason": "overlong"\n          },\n          "tur": {\n            "_replacement": "tr",\n            "_reason": "overlong"\n          },\n          "tw": {\n            "_replacement": "ak",\n            "_reason": "macrolanguage"\n          },\n          "twi": {\n            "_replacement": "ak",\n            "_reason": "overlong"\n          },\n          "tzm-MA": {\n            "_replacement": "tzm-Latn-MA",\n            "_reason": "legacy"\n          },\n          "ug-CN": {\n            "_replacement": "ug-Arab-CN",\n            "_reason": "legacy"\n          },\n          "uig": {\n            "_replacement": "ug",\n            "_reason": "overlong"\n          },\n          "ukr": {\n            "_replacement": "uk",\n            "_reason": "overlong"\n          },\n          "umu": {\n            "_replacement": "del",\n            "_reason": "macrolanguage"\n          },\n          "urd": {\n            "_replacement": "ur",\n            "_reason": "overlong"\n          },\n          "uz-AF": {\n            "_replacement": "uz-Arab-AF",\n            "_reason": "legacy"\n          },\n          "uz-UZ": {\n            "_replacement": "uz-Latn-UZ",\n            "_reason": "legacy"\n          },\n          "uzb": {\n            "_replacement": "uz",\n            "_reason": "overlong"\n          },\n          "uzn": {\n            "_replacement": "uz",\n            "_reason": "macrolanguage"\n          },\n          "vai-LR": {\n            "_replacement": "vai-Vaii-LR",\n            "_reason": "legacy"\n          },\n          "ven": {\n            "_replacement": "ve",\n            "_reason": "overlong"\n          },\n          "vie": {\n            "_replacement": "vi",\n            "_reason": "overlong"\n          },\n          "vol": {\n            "_replacement": "vo",\n            "_reason": "overlong"\n          },\n          "wel": {\n            "_replacement": "cy",\n            "_reason": "bibliographic"\n          },\n          "wln": {\n            "_replacement": "wa",\n            "_reason": "overlong"\n          },\n          "wol": {\n            "_replacement": "wo",\n            "_reason": "overlong"\n          },\n          "xho": {\n            "_replacement": "xh",\n            "_reason": "overlong"\n          },\n          "xpe": {\n            "_replacement": "kpe",\n            "_reason": "macrolanguage"\n          },\n          "xsl": {\n            "_replacement": "den",\n            "_reason": "macrolanguage"\n          },\n          "ydd": {\n            "_replacement": "yi",\n            "_reason": "macrolanguage"\n          },\n          "yid": {\n            "_replacement": "yi",\n            "_reason": "overlong"\n          },\n          "yor": {\n            "_replacement": "yo",\n            "_reason": "overlong"\n          },\n          "zai": {\n            "_replacement": "zap",\n            "_reason": "macrolanguage"\n          },\n          "zh-CN": {\n            "_replacement": "zh-Hans-CN",\n            "_reason": "legacy"\n          },\n          "zh-HK": {\n            "_replacement": "zh-Hant-HK",\n            "_reason": "legacy"\n          },\n          "zh-MO": {\n            "_replacement": "zh-Hant-MO",\n            "_reason": "legacy"\n          },\n          "zh-SG": {\n            "_replacement": "zh-Hans-SG",\n            "_reason": "legacy"\n          },\n          "zh-TW": {\n            "_replacement": "zh-Hant-TW",\n            "_reason": "legacy"\n          },\n          "zh-guoyu": {\n            "_replacement": "zh",\n            "_reason": "deprecated"\n          },\n          "zh-hakka": {\n            "_replacement": "hak",\n            "_reason": "deprecated"\n          },\n          "zh-min": {\n            "_reason": "deprecated"\n          },\n          "zh-min-nan": {\n            "_replacement": "nan",\n            "_reason": "deprecated"\n          },\n          "zh-xiang": {\n            "_replacement": "hsn",\n            "_reason": "deprecated"\n          },\n          "zha": {\n            "_replacement": "za",\n            "_reason": "overlong"\n          },\n          "zho": {\n            "_replacement": "zh",\n            "_reason": "overlong"\n          },\n          "zsm": {\n            "_replacement": "ms",\n            "_reason": "macrolanguage"\n          },\n          "zul": {\n            "_replacement": "zu",\n            "_reason": "overlong"\n          },\n          "zyb": {\n            "_replacement": "za",\n            "_reason": "macrolanguage"\n          }\n        },\n        "scriptAlias": {\n          "Qaai": {\n            "_replacement": "Zinh",\n            "_reason": "deprecated"\n          }\n        },\n        "territoryAlias": {\n          "004": {\n            "_replacement": "AF",\n            "_reason": "overlong"\n          },\n          "008": {\n            "_replacement": "AL",\n            "_reason": "overlong"\n          },\n          "010": {\n            "_replacement": "AQ",\n            "_reason": "overlong"\n          },\n          "012": {\n            "_replacement": "DZ",\n            "_reason": "overlong"\n          },\n          "016": {\n            "_replacement": "AS",\n            "_reason": "overlong"\n          },\n          "020": {\n            "_replacement": "AD",\n            "_reason": "overlong"\n          },\n          "024": {\n            "_replacement": "AO",\n            "_reason": "overlong"\n          },\n          "028": {\n            "_replacement": "AG",\n            "_reason": "overlong"\n          },\n          "031": {\n            "_replacement": "AZ",\n            "_reason": "overlong"\n          },\n          "032": {\n            "_replacement": "AR",\n            "_reason": "overlong"\n          },\n          "036": {\n            "_replacement": "AU",\n            "_reason": "overlong"\n          },\n          "040": {\n            "_replacement": "AT",\n            "_reason": "overlong"\n          },\n          "044": {\n            "_replacement": "BS",\n            "_reason": "overlong"\n          },\n          "048": {\n            "_replacement": "BH",\n            "_reason": "overlong"\n          },\n          "050": {\n            "_replacement": "BD",\n            "_reason": "overlong"\n          },\n          "051": {\n            "_replacement": "AM",\n            "_reason": "overlong"\n          },\n          "052": {\n            "_replacement": "BB",\n            "_reason": "overlong"\n          },\n          "056": {\n            "_replacement": "BE",\n            "_reason": "overlong"\n          },\n          "060": {\n            "_replacement": "BM",\n            "_reason": "overlong"\n          },\n          "062": {\n            "_replacement": "034 143",\n            "_reason": "deprecated"\n          },\n          "064": {\n            "_replacement": "BT",\n            "_reason": "overlong"\n          },\n          "068": {\n            "_replacement": "BO",\n            "_reason": "overlong"\n          },\n          "070": {\n            "_replacement": "BA",\n            "_reason": "overlong"\n          },\n          "072": {\n            "_replacement": "BW",\n            "_reason": "overlong"\n          },\n          "074": {\n            "_replacement": "BV",\n            "_reason": "overlong"\n          },\n          "076": {\n            "_replacement": "BR",\n            "_reason": "overlong"\n          },\n          "084": {\n            "_replacement": "BZ",\n            "_reason": "overlong"\n          },\n          "086": {\n            "_replacement": "IO",\n            "_reason": "overlong"\n          },\n          "090": {\n            "_replacement": "SB",\n            "_reason": "overlong"\n          },\n          "092": {\n            "_replacement": "VG",\n            "_reason": "overlong"\n          },\n          "096": {\n            "_replacement": "BN",\n            "_reason": "overlong"\n          },\n          "100": {\n            "_replacement": "BG",\n            "_reason": "overlong"\n          },\n          "104": {\n            "_replacement": "MM",\n            "_reason": "overlong"\n          },\n          "108": {\n            "_replacement": "BI",\n            "_reason": "overlong"\n          },\n          "112": {\n            "_replacement": "BY",\n            "_reason": "overlong"\n          },\n          "116": {\n            "_replacement": "KH",\n            "_reason": "overlong"\n          },\n          "120": {\n            "_replacement": "CM",\n            "_reason": "overlong"\n          },\n          "124": {\n            "_replacement": "CA",\n            "_reason": "overlong"\n          },\n          "132": {\n            "_replacement": "CV",\n            "_reason": "overlong"\n          },\n          "136": {\n            "_replacement": "KY",\n            "_reason": "overlong"\n          },\n          "140": {\n            "_replacement": "CF",\n            "_reason": "overlong"\n          },\n          "144": {\n            "_replacement": "LK",\n            "_reason": "overlong"\n          },\n          "148": {\n            "_replacement": "TD",\n            "_reason": "overlong"\n          },\n          "152": {\n            "_replacement": "CL",\n            "_reason": "overlong"\n          },\n          "156": {\n            "_replacement": "CN",\n            "_reason": "overlong"\n          },\n          "158": {\n            "_replacement": "TW",\n            "_reason": "overlong"\n          },\n          "162": {\n            "_replacement": "CX",\n            "_reason": "overlong"\n          },\n          "166": {\n            "_replacement": "CC",\n            "_reason": "overlong"\n          },\n          "170": {\n            "_replacement": "CO",\n            "_reason": "overlong"\n          },\n          "172": {\n            "_replacement": "RU AM AZ BY GE KG KZ MD TJ TM UA UZ",\n            "_reason": "deprecated"\n          },\n          "174": {\n            "_replacement": "KM",\n            "_reason": "overlong"\n          },\n          "175": {\n            "_replacement": "YT",\n            "_reason": "overlong"\n          },\n          "178": {\n            "_replacement": "CG",\n            "_reason": "overlong"\n          },\n          "180": {\n            "_replacement": "CD",\n            "_reason": "overlong"\n          },\n          "184": {\n            "_replacement": "CK",\n            "_reason": "overlong"\n          },\n          "188": {\n            "_replacement": "CR",\n            "_reason": "overlong"\n          },\n          "191": {\n            "_replacement": "HR",\n            "_reason": "overlong"\n          },\n          "192": {\n            "_replacement": "CU",\n            "_reason": "overlong"\n          },\n          "196": {\n            "_replacement": "CY",\n            "_reason": "overlong"\n          },\n          "200": {\n            "_replacement": "CZ SK",\n            "_reason": "deprecated"\n          },\n          "203": {\n            "_replacement": "CZ",\n            "_reason": "overlong"\n          },\n          "204": {\n            "_replacement": "BJ",\n            "_reason": "overlong"\n          },\n          "208": {\n            "_replacement": "DK",\n            "_reason": "overlong"\n          },\n          "212": {\n            "_replacement": "DM",\n            "_reason": "overlong"\n          },\n          "214": {\n            "_replacement": "DO",\n            "_reason": "overlong"\n          },\n          "218": {\n            "_replacement": "EC",\n            "_reason": "overlong"\n          },\n          "222": {\n            "_replacement": "SV",\n            "_reason": "overlong"\n          },\n          "226": {\n            "_replacement": "GQ",\n            "_reason": "overlong"\n          },\n          "230": {\n            "_replacement": "ET",\n            "_reason": "deprecated"\n          },\n          "231": {\n            "_replacement": "ET",\n            "_reason": "overlong"\n          },\n          "232": {\n            "_replacement": "ER",\n            "_reason": "overlong"\n          },\n          "233": {\n            "_replacement": "EE",\n            "_reason": "overlong"\n          },\n          "234": {\n            "_replacement": "FO",\n            "_reason": "overlong"\n          },\n          "238": {\n            "_replacement": "FK",\n            "_reason": "overlong"\n          },\n          "239": {\n            "_replacement": "GS",\n            "_reason": "overlong"\n          },\n          "242": {\n            "_replacement": "FJ",\n            "_reason": "overlong"\n          },\n          "246": {\n            "_replacement": "FI",\n            "_reason": "overlong"\n          },\n          "248": {\n            "_replacement": "AX",\n            "_reason": "overlong"\n          },\n          "249": {\n            "_replacement": "FR",\n            "_reason": "overlong"\n          },\n          "250": {\n            "_replacement": "FR",\n            "_reason": "overlong"\n          },\n          "254": {\n            "_replacement": "GF",\n            "_reason": "overlong"\n          },\n          "258": {\n            "_replacement": "PF",\n            "_reason": "overlong"\n          },\n          "260": {\n            "_replacement": "TF",\n            "_reason": "overlong"\n          },\n          "262": {\n            "_replacement": "DJ",\n            "_reason": "overlong"\n          },\n          "266": {\n            "_replacement": "GA",\n            "_reason": "overlong"\n          },\n          "268": {\n            "_replacement": "GE",\n            "_reason": "overlong"\n          },\n          "270": {\n            "_replacement": "GM",\n            "_reason": "overlong"\n          },\n          "275": {\n            "_replacement": "PS",\n            "_reason": "overlong"\n          },\n          "276": {\n            "_replacement": "DE",\n            "_reason": "overlong"\n          },\n          "278": {\n            "_replacement": "DE",\n            "_reason": "overlong"\n          },\n          "280": {\n            "_replacement": "DE",\n            "_reason": "deprecated"\n          },\n          "288": {\n            "_replacement": "GH",\n            "_reason": "overlong"\n          },\n          "292": {\n            "_replacement": "GI",\n            "_reason": "overlong"\n          },\n          "296": {\n            "_replacement": "KI",\n            "_reason": "overlong"\n          },\n          "300": {\n            "_replacement": "GR",\n            "_reason": "overlong"\n          },\n          "304": {\n            "_replacement": "GL",\n            "_reason": "overlong"\n          },\n          "308": {\n            "_replacement": "GD",\n            "_reason": "overlong"\n          },\n          "312": {\n            "_replacement": "GP",\n            "_reason": "overlong"\n          },\n          "316": {\n            "_replacement": "GU",\n            "_reason": "overlong"\n          },\n          "320": {\n            "_replacement": "GT",\n            "_reason": "overlong"\n          },\n          "324": {\n            "_replacement": "GN",\n            "_reason": "overlong"\n          },\n          "328": {\n            "_replacement": "GY",\n            "_reason": "overlong"\n          },\n          "332": {\n            "_replacement": "HT",\n            "_reason": "overlong"\n          },\n          "334": {\n            "_replacement": "HM",\n            "_reason": "overlong"\n          },\n          "336": {\n            "_replacement": "VA",\n            "_reason": "overlong"\n          },\n          "340": {\n            "_replacement": "HN",\n            "_reason": "overlong"\n          },\n          "344": {\n            "_replacement": "HK",\n            "_reason": "overlong"\n          },\n          "348": {\n            "_replacement": "HU",\n            "_reason": "overlong"\n          },\n          "352": {\n            "_replacement": "IS",\n            "_reason": "overlong"\n          },\n          "356": {\n            "_replacement": "IN",\n            "_reason": "overlong"\n          },\n          "360": {\n            "_replacement": "ID",\n            "_reason": "overlong"\n          },\n          "364": {\n            "_replacement": "IR",\n            "_reason": "overlong"\n          },\n          "368": {\n            "_replacement": "IQ",\n            "_reason": "overlong"\n          },\n          "372": {\n            "_replacement": "IE",\n            "_reason": "overlong"\n          },\n          "376": {\n            "_replacement": "IL",\n            "_reason": "overlong"\n          },\n          "380": {\n            "_replacement": "IT",\n            "_reason": "overlong"\n          },\n          "384": {\n            "_replacement": "CI",\n            "_reason": "overlong"\n          },\n          "388": {\n            "_replacement": "JM",\n            "_reason": "overlong"\n          },\n          "392": {\n            "_replacement": "JP",\n            "_reason": "overlong"\n          },\n          "398": {\n            "_replacement": "KZ",\n            "_reason": "overlong"\n          },\n          "400": {\n            "_replacement": "JO",\n            "_reason": "overlong"\n          },\n          "404": {\n            "_replacement": "KE",\n            "_reason": "overlong"\n          },\n          "408": {\n            "_replacement": "KP",\n            "_reason": "overlong"\n          },\n          "410": {\n            "_replacement": "KR",\n            "_reason": "overlong"\n          },\n          "414": {\n            "_replacement": "KW",\n            "_reason": "overlong"\n          },\n          "417": {\n            "_replacement": "KG",\n            "_reason": "overlong"\n          },\n          "418": {\n            "_replacement": "LA",\n            "_reason": "overlong"\n          },\n          "422": {\n            "_replacement": "LB",\n            "_reason": "overlong"\n          },\n          "426": {\n            "_replacement": "LS",\n            "_reason": "overlong"\n          },\n          "428": {\n            "_replacement": "LV",\n            "_reason": "overlong"\n          },\n          "430": {\n            "_replacement": "LR",\n            "_reason": "overlong"\n          },\n          "434": {\n            "_replacement": "LY",\n            "_reason": "overlong"\n          },\n          "438": {\n            "_replacement": "LI",\n            "_reason": "overlong"\n          },\n          "440": {\n            "_replacement": "LT",\n            "_reason": "overlong"\n          },\n          "442": {\n            "_replacement": "LU",\n            "_reason": "overlong"\n          },\n          "446": {\n            "_replacement": "MO",\n            "_reason": "overlong"\n          },\n          "450": {\n            "_replacement": "MG",\n            "_reason": "overlong"\n          },\n          "454": {\n            "_replacement": "MW",\n            "_reason": "overlong"\n          },\n          "458": {\n            "_replacement": "MY",\n            "_reason": "overlong"\n          },\n          "462": {\n            "_replacement": "MV",\n            "_reason": "overlong"\n          },\n          "466": {\n            "_replacement": "ML",\n            "_reason": "overlong"\n          },\n          "470": {\n            "_replacement": "MT",\n            "_reason": "overlong"\n          },\n          "474": {\n            "_replacement": "MQ",\n            "_reason": "overlong"\n          },\n          "478": {\n            "_replacement": "MR",\n            "_reason": "overlong"\n          },\n          "480": {\n            "_replacement": "MU",\n            "_reason": "overlong"\n          },\n          "484": {\n            "_replacement": "MX",\n            "_reason": "overlong"\n          },\n          "492": {\n            "_replacement": "MC",\n            "_reason": "overlong"\n          },\n          "496": {\n            "_replacement": "MN",\n            "_reason": "overlong"\n          },\n          "498": {\n            "_replacement": "MD",\n            "_reason": "overlong"\n          },\n          "499": {\n            "_replacement": "ME",\n            "_reason": "overlong"\n          },\n          "500": {\n            "_replacement": "MS",\n            "_reason": "overlong"\n          },\n          "504": {\n            "_replacement": "MA",\n            "_reason": "overlong"\n          },\n          "508": {\n            "_replacement": "MZ",\n            "_reason": "overlong"\n          },\n          "512": {\n            "_replacement": "OM",\n            "_reason": "overlong"\n          },\n          "516": {\n            "_replacement": "NA",\n            "_reason": "overlong"\n          },\n          "520": {\n            "_replacement": "NR",\n            "_reason": "overlong"\n          },\n          "524": {\n            "_replacement": "NP",\n            "_reason": "overlong"\n          },\n          "528": {\n            "_replacement": "NL",\n            "_reason": "overlong"\n          },\n          "530": {\n            "_replacement": "CW SX BQ",\n            "_reason": "overlong"\n          },\n          "531": {\n            "_replacement": "CW",\n            "_reason": "overlong"\n          },\n          "532": {\n            "_replacement": "CW SX BQ",\n            "_reason": "deprecated"\n          },\n          "533": {\n            "_replacement": "AW",\n            "_reason": "overlong"\n          },\n          "534": {\n            "_replacement": "SX",\n            "_reason": "overlong"\n          },\n          "535": {\n            "_replacement": "BQ",\n            "_reason": "overlong"\n          },\n          "536": {\n            "_replacement": "SA IQ",\n            "_reason": "overlong"\n          },\n          "540": {\n            "_replacement": "NC",\n            "_reason": "overlong"\n          },\n          "548": {\n            "_replacement": "VU",\n            "_reason": "overlong"\n          },\n          "554": {\n            "_replacement": "NZ",\n            "_reason": "overlong"\n          },\n          "558": {\n            "_replacement": "NI",\n            "_reason": "overlong"\n          },\n          "562": {\n            "_replacement": "NE",\n            "_reason": "overlong"\n          },\n          "566": {\n            "_replacement": "NG",\n            "_reason": "overlong"\n          },\n          "570": {\n            "_replacement": "NU",\n            "_reason": "overlong"\n          },\n          "574": {\n            "_replacement": "NF",\n            "_reason": "overlong"\n          },\n          "578": {\n            "_replacement": "NO",\n            "_reason": "overlong"\n          },\n          "580": {\n            "_replacement": "MP",\n            "_reason": "overlong"\n          },\n          "581": {\n            "_replacement": "UM",\n            "_reason": "overlong"\n          },\n          "582": {\n            "_replacement": "FM MH MP PW",\n            "_reason": "deprecated"\n          },\n          "583": {\n            "_replacement": "FM",\n            "_reason": "overlong"\n          },\n          "584": {\n            "_replacement": "MH",\n            "_reason": "overlong"\n          },\n          "585": {\n            "_replacement": "PW",\n            "_reason": "overlong"\n          },\n          "586": {\n            "_replacement": "PK",\n            "_reason": "overlong"\n          },\n          "591": {\n            "_replacement": "PA",\n            "_reason": "overlong"\n          },\n          "598": {\n            "_replacement": "PG",\n            "_reason": "overlong"\n          },\n          "600": {\n            "_replacement": "PY",\n            "_reason": "overlong"\n          },\n          "604": {\n            "_replacement": "PE",\n            "_reason": "overlong"\n          },\n          "608": {\n            "_replacement": "PH",\n            "_reason": "overlong"\n          },\n          "612": {\n            "_replacement": "PN",\n            "_reason": "overlong"\n          },\n          "616": {\n            "_replacement": "PL",\n            "_reason": "overlong"\n          },\n          "620": {\n            "_replacement": "PT",\n            "_reason": "overlong"\n          },\n          "624": {\n            "_replacement": "GW",\n            "_reason": "overlong"\n          },\n          "626": {\n            "_replacement": "TL",\n            "_reason": "overlong"\n          },\n          "630": {\n            "_replacement": "PR",\n            "_reason": "overlong"\n          },\n          "634": {\n            "_replacement": "QA",\n            "_reason": "overlong"\n          },\n          "638": {\n            "_replacement": "RE",\n            "_reason": "overlong"\n          },\n          "642": {\n            "_replacement": "RO",\n            "_reason": "overlong"\n          },\n          "643": {\n            "_replacement": "RU",\n            "_reason": "overlong"\n          },\n          "646": {\n            "_replacement": "RW",\n            "_reason": "overlong"\n          },\n          "652": {\n            "_replacement": "BL",\n            "_reason": "overlong"\n          },\n          "654": {\n            "_replacement": "SH",\n            "_reason": "overlong"\n          },\n          "659": {\n            "_replacement": "KN",\n            "_reason": "overlong"\n          },\n          "660": {\n            "_replacement": "AI",\n            "_reason": "overlong"\n          },\n          "662": {\n            "_replacement": "LC",\n            "_reason": "overlong"\n          },\n          "663": {\n            "_replacement": "MF",\n            "_reason": "overlong"\n          },\n          "666": {\n            "_replacement": "PM",\n            "_reason": "overlong"\n          },\n          "670": {\n            "_replacement": "VC",\n            "_reason": "overlong"\n          },\n          "674": {\n            "_replacement": "SM",\n            "_reason": "overlong"\n          },\n          "678": {\n            "_replacement": "ST",\n            "_reason": "overlong"\n          },\n          "682": {\n            "_replacement": "SA",\n            "_reason": "overlong"\n          },\n          "686": {\n            "_replacement": "SN",\n            "_reason": "overlong"\n          },\n          "688": {\n            "_replacement": "RS",\n            "_reason": "overlong"\n          },\n          "690": {\n            "_replacement": "SC",\n            "_reason": "overlong"\n          },\n          "694": {\n            "_replacement": "SL",\n            "_reason": "overlong"\n          },\n          "702": {\n            "_replacement": "SG",\n            "_reason": "overlong"\n          },\n          "703": {\n            "_replacement": "SK",\n            "_reason": "overlong"\n          },\n          "704": {\n            "_replacement": "VN",\n            "_reason": "overlong"\n          },\n          "705": {\n            "_replacement": "SI",\n            "_reason": "overlong"\n          },\n          "706": {\n            "_replacement": "SO",\n            "_reason": "overlong"\n          },\n          "710": {\n            "_replacement": "ZA",\n            "_reason": "overlong"\n          },\n          "716": {\n            "_replacement": "ZW",\n            "_reason": "overlong"\n          },\n          "720": {\n            "_replacement": "YE",\n            "_reason": "overlong"\n          },\n          "724": {\n            "_replacement": "ES",\n            "_reason": "overlong"\n          },\n          "728": {\n            "_replacement": "SS",\n            "_reason": "overlong"\n          },\n          "729": {\n            "_replacement": "SD",\n            "_reason": "overlong"\n          },\n          "732": {\n            "_replacement": "EH",\n            "_reason": "overlong"\n          },\n          "736": {\n            "_replacement": "SD",\n            "_reason": "deprecated"\n          },\n          "740": {\n            "_replacement": "SR",\n            "_reason": "overlong"\n          },\n          "744": {\n            "_replacement": "SJ",\n            "_reason": "overlong"\n          },\n          "748": {\n            "_replacement": "SZ",\n            "_reason": "overlong"\n          },\n          "752": {\n            "_replacement": "SE",\n            "_reason": "overlong"\n          },\n          "756": {\n            "_replacement": "CH",\n            "_reason": "overlong"\n          },\n          "760": {\n            "_replacement": "SY",\n            "_reason": "overlong"\n          },\n          "762": {\n            "_replacement": "TJ",\n            "_reason": "overlong"\n          },\n          "764": {\n            "_replacement": "TH",\n            "_reason": "overlong"\n          },\n          "768": {\n            "_replacement": "TG",\n            "_reason": "overlong"\n          },\n          "772": {\n            "_replacement": "TK",\n            "_reason": "overlong"\n          },\n          "776": {\n            "_replacement": "TO",\n            "_reason": "overlong"\n          },\n          "780": {\n            "_replacement": "TT",\n            "_reason": "overlong"\n          },\n          "784": {\n            "_replacement": "AE",\n            "_reason": "overlong"\n          },\n          "788": {\n            "_replacement": "TN",\n            "_reason": "overlong"\n          },\n          "792": {\n            "_replacement": "TR",\n            "_reason": "overlong"\n          },\n          "795": {\n            "_replacement": "TM",\n            "_reason": "overlong"\n          },\n          "796": {\n            "_replacement": "TC",\n            "_reason": "overlong"\n          },\n          "798": {\n            "_replacement": "TV",\n            "_reason": "overlong"\n          },\n          "800": {\n            "_replacement": "UG",\n            "_reason": "overlong"\n          },\n          "804": {\n            "_replacement": "UA",\n            "_reason": "overlong"\n          },\n          "807": {\n            "_replacement": "MK",\n            "_reason": "overlong"\n          },\n          "810": {\n            "_replacement": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",\n            "_reason": "overlong"\n          },\n          "818": {\n            "_replacement": "EG",\n            "_reason": "overlong"\n          },\n          "826": {\n            "_replacement": "GB",\n            "_reason": "overlong"\n          },\n          "830": {\n            "_replacement": "JE GG",\n            "_reason": "deprecated"\n          },\n          "831": {\n            "_replacement": "GG",\n            "_reason": "overlong"\n          },\n          "832": {\n            "_replacement": "JE",\n            "_reason": "overlong"\n          },\n          "833": {\n            "_replacement": "IM",\n            "_reason": "overlong"\n          },\n          "834": {\n            "_replacement": "TZ",\n            "_reason": "overlong"\n          },\n          "840": {\n            "_replacement": "US",\n            "_reason": "overlong"\n          },\n          "850": {\n            "_replacement": "VI",\n            "_reason": "overlong"\n          },\n          "854": {\n            "_replacement": "BF",\n            "_reason": "overlong"\n          },\n          "858": {\n            "_replacement": "UY",\n            "_reason": "overlong"\n          },\n          "860": {\n            "_replacement": "UZ",\n            "_reason": "overlong"\n          },\n          "862": {\n            "_replacement": "VE",\n            "_reason": "overlong"\n          },\n          "876": {\n            "_replacement": "WF",\n            "_reason": "overlong"\n          },\n          "882": {\n            "_replacement": "WS",\n            "_reason": "overlong"\n          },\n          "886": {\n            "_replacement": "YE",\n            "_reason": "deprecated"\n          },\n          "887": {\n            "_replacement": "YE",\n            "_reason": "overlong"\n          },\n          "890": {\n            "_replacement": "RS ME SI HR MK BA",\n            "_reason": "deprecated"\n          },\n          "891": {\n            "_replacement": "RS ME",\n            "_reason": "overlong"\n          },\n          "894": {\n            "_replacement": "ZM",\n            "_reason": "overlong"\n          },\n          "958": {\n            "_replacement": "AA",\n            "_reason": "overlong"\n          },\n          "959": {\n            "_replacement": "QM",\n            "_reason": "overlong"\n          },\n          "960": {\n            "_replacement": "QN",\n            "_reason": "overlong"\n          },\n          "962": {\n            "_replacement": "QP",\n            "_reason": "overlong"\n          },\n          "963": {\n            "_replacement": "QQ",\n            "_reason": "overlong"\n          },\n          "964": {\n            "_replacement": "QR",\n            "_reason": "overlong"\n          },\n          "965": {\n            "_replacement": "QS",\n            "_reason": "overlong"\n          },\n          "966": {\n            "_replacement": "QT",\n            "_reason": "overlong"\n          },\n          "967": {\n            "_replacement": "EU",\n            "_reason": "overlong"\n          },\n          "968": {\n            "_replacement": "QV",\n            "_reason": "overlong"\n          },\n          "969": {\n            "_replacement": "QW",\n            "_reason": "overlong"\n          },\n          "970": {\n            "_replacement": "QX",\n            "_reason": "overlong"\n          },\n          "971": {\n            "_replacement": "QY",\n            "_reason": "overlong"\n          },\n          "972": {\n            "_replacement": "QZ",\n            "_reason": "overlong"\n          },\n          "973": {\n            "_replacement": "XA",\n            "_reason": "overlong"\n          },\n          "974": {\n            "_replacement": "XB",\n            "_reason": "overlong"\n          },\n          "975": {\n            "_replacement": "XC",\n            "_reason": "overlong"\n          },\n          "976": {\n            "_replacement": "XD",\n            "_reason": "overlong"\n          },\n          "977": {\n            "_replacement": "XE",\n            "_reason": "overlong"\n          },\n          "978": {\n            "_replacement": "XF",\n            "_reason": "overlong"\n          },\n          "979": {\n            "_replacement": "XG",\n            "_reason": "overlong"\n          },\n          "980": {\n            "_replacement": "XH",\n            "_reason": "overlong"\n          },\n          "981": {\n            "_replacement": "XI",\n            "_reason": "overlong"\n          },\n          "982": {\n            "_replacement": "XJ",\n            "_reason": "overlong"\n          },\n          "983": {\n            "_replacement": "XK",\n            "_reason": "overlong"\n          },\n          "984": {\n            "_replacement": "XL",\n            "_reason": "overlong"\n          },\n          "985": {\n            "_replacement": "XM",\n            "_reason": "overlong"\n          },\n          "986": {\n            "_replacement": "XN",\n            "_reason": "overlong"\n          },\n          "987": {\n            "_replacement": "XO",\n            "_reason": "overlong"\n          },\n          "988": {\n            "_replacement": "XP",\n            "_reason": "overlong"\n          },\n          "989": {\n            "_replacement": "XQ",\n            "_reason": "overlong"\n          },\n          "990": {\n            "_replacement": "XR",\n            "_reason": "overlong"\n          },\n          "991": {\n            "_replacement": "XS",\n            "_reason": "overlong"\n          },\n          "992": {\n            "_replacement": "XT",\n            "_reason": "overlong"\n          },\n          "993": {\n            "_replacement": "XU",\n            "_reason": "overlong"\n          },\n          "994": {\n            "_replacement": "XV",\n            "_reason": "overlong"\n          },\n          "995": {\n            "_replacement": "XW",\n            "_reason": "overlong"\n          },\n          "996": {\n            "_replacement": "XX",\n            "_reason": "overlong"\n          },\n          "997": {\n            "_replacement": "XY",\n            "_reason": "overlong"\n          },\n          "998": {\n            "_replacement": "XZ",\n            "_reason": "overlong"\n          },\n          "999": {\n            "_replacement": "ZZ",\n            "_reason": "overlong"\n          },\n          "AAA": {\n            "_replacement": "AA",\n            "_reason": "overlong"\n          },\n          "ABW": {\n            "_replacement": "AW",\n            "_reason": "overlong"\n          },\n          "AFG": {\n            "_replacement": "AF",\n            "_reason": "overlong"\n          },\n          "AGO": {\n            "_replacement": "AO",\n            "_reason": "overlong"\n          },\n          "AIA": {\n            "_replacement": "AI",\n            "_reason": "overlong"\n          },\n          "ALA": {\n            "_replacement": "AX",\n            "_reason": "overlong"\n          },\n          "ALB": {\n            "_replacement": "AL",\n            "_reason": "overlong"\n          },\n          "AN": {\n            "_replacement": "CW SX BQ",\n            "_reason": "deprecated"\n          },\n          "AND": {\n            "_replacement": "AD",\n            "_reason": "overlong"\n          },\n          "ANT": {\n            "_replacement": "CW SX BQ",\n            "_reason": "overlong"\n          },\n          "ARE": {\n            "_replacement": "AE",\n            "_reason": "overlong"\n          },\n          "ARG": {\n            "_replacement": "AR",\n            "_reason": "overlong"\n          },\n          "ARM": {\n            "_replacement": "AM",\n            "_reason": "overlong"\n          },\n          "ASC": {\n            "_replacement": "AC",\n            "_reason": "overlong"\n          },\n          "ASM": {\n            "_replacement": "AS",\n            "_reason": "overlong"\n          },\n          "ATA": {\n            "_replacement": "AQ",\n            "_reason": "overlong"\n          },\n          "ATF": {\n            "_replacement": "TF",\n            "_reason": "overlong"\n          },\n          "ATG": {\n            "_replacement": "AG",\n            "_reason": "overlong"\n          },\n          "AUS": {\n            "_replacement": "AU",\n            "_reason": "overlong"\n          },\n          "AUT": {\n            "_replacement": "AT",\n            "_reason": "overlong"\n          },\n          "AZE": {\n            "_replacement": "AZ",\n            "_reason": "overlong"\n          },\n          "BDI": {\n            "_replacement": "BI",\n            "_reason": "overlong"\n          },\n          "BEL": {\n            "_replacement": "BE",\n            "_reason": "overlong"\n          },\n          "BEN": {\n            "_replacement": "BJ",\n            "_reason": "overlong"\n          },\n          "BES": {\n            "_replacement": "BQ",\n            "_reason": "overlong"\n          },\n          "BFA": {\n            "_replacement": "BF",\n            "_reason": "overlong"\n          },\n          "BGD": {\n            "_replacement": "BD",\n            "_reason": "overlong"\n          },\n          "BGR": {\n            "_replacement": "BG",\n            "_reason": "overlong"\n          },\n          "BHR": {\n            "_replacement": "BH",\n            "_reason": "overlong"\n          },\n          "BHS": {\n            "_replacement": "BS",\n            "_reason": "overlong"\n          },\n          "BIH": {\n            "_replacement": "BA",\n            "_reason": "overlong"\n          },\n          "BLM": {\n            "_replacement": "BL",\n            "_reason": "overlong"\n          },\n          "BLR": {\n            "_replacement": "BY",\n            "_reason": "overlong"\n          },\n          "BLZ": {\n            "_replacement": "BZ",\n            "_reason": "overlong"\n          },\n          "BMU": {\n            "_replacement": "BM",\n            "_reason": "overlong"\n          },\n          "BOL": {\n            "_replacement": "BO",\n            "_reason": "overlong"\n          },\n          "BRA": {\n            "_replacement": "BR",\n            "_reason": "overlong"\n          },\n          "BRB": {\n            "_replacement": "BB",\n            "_reason": "overlong"\n          },\n          "BRN": {\n            "_replacement": "BN",\n            "_reason": "overlong"\n          },\n          "BTN": {\n            "_replacement": "BT",\n            "_reason": "overlong"\n          },\n          "BU": {\n            "_replacement": "MM",\n            "_reason": "deprecated"\n          },\n          "BUR": {\n            "_replacement": "MM",\n            "_reason": "overlong"\n          },\n          "BVT": {\n            "_replacement": "BV",\n            "_reason": "overlong"\n          },\n          "BWA": {\n            "_replacement": "BW",\n            "_reason": "overlong"\n          },\n          "CAF": {\n            "_replacement": "CF",\n            "_reason": "overlong"\n          },\n          "CAN": {\n            "_replacement": "CA",\n            "_reason": "overlong"\n          },\n          "CCK": {\n            "_replacement": "CC",\n            "_reason": "overlong"\n          },\n          "CHE": {\n            "_replacement": "CH",\n            "_reason": "overlong"\n          },\n          "CHL": {\n            "_replacement": "CL",\n            "_reason": "overlong"\n          },\n          "CHN": {\n            "_replacement": "CN",\n            "_reason": "overlong"\n          },\n          "CIV": {\n            "_replacement": "CI",\n            "_reason": "overlong"\n          },\n          "CMR": {\n            "_replacement": "CM",\n            "_reason": "overlong"\n          },\n          "COD": {\n            "_replacement": "CD",\n            "_reason": "overlong"\n          },\n          "COG": {\n            "_replacement": "CG",\n            "_reason": "overlong"\n          },\n          "COK": {\n            "_replacement": "CK",\n            "_reason": "overlong"\n          },\n          "COL": {\n            "_replacement": "CO",\n            "_reason": "overlong"\n          },\n          "COM": {\n            "_replacement": "KM",\n            "_reason": "overlong"\n          },\n          "CPT": {\n            "_replacement": "CP",\n            "_reason": "overlong"\n          },\n          "CPV": {\n            "_replacement": "CV",\n            "_reason": "overlong"\n          },\n          "CRI": {\n            "_replacement": "CR",\n            "_reason": "overlong"\n          },\n          "CS": {\n            "_replacement": "RS ME",\n            "_reason": "deprecated"\n          },\n          "CT": {\n            "_replacement": "KI",\n            "_reason": "deprecated"\n          },\n          "CUB": {\n            "_replacement": "CU",\n            "_reason": "overlong"\n          },\n          "CUW": {\n            "_replacement": "CW",\n            "_reason": "overlong"\n          },\n          "CXR": {\n            "_replacement": "CX",\n            "_reason": "overlong"\n          },\n          "CYM": {\n            "_replacement": "KY",\n            "_reason": "overlong"\n          },\n          "CYP": {\n            "_replacement": "CY",\n            "_reason": "overlong"\n          },\n          "CZE": {\n            "_replacement": "CZ",\n            "_reason": "overlong"\n          },\n          "DD": {\n            "_replacement": "DE",\n            "_reason": "deprecated"\n          },\n          "DDR": {\n            "_replacement": "DE",\n            "_reason": "overlong"\n          },\n          "DEU": {\n            "_replacement": "DE",\n            "_reason": "overlong"\n          },\n          "DGA": {\n            "_replacement": "DG",\n            "_reason": "overlong"\n          },\n          "DJI": {\n            "_replacement": "DJ",\n            "_reason": "overlong"\n          },\n          "DMA": {\n            "_replacement": "DM",\n            "_reason": "overlong"\n          },\n          "DNK": {\n            "_replacement": "DK",\n            "_reason": "overlong"\n          },\n          "DOM": {\n            "_replacement": "DO",\n            "_reason": "overlong"\n          },\n          "DY": {\n            "_replacement": "BJ",\n            "_reason": "deprecated"\n          },\n          "DZA": {\n            "_replacement": "DZ",\n            "_reason": "overlong"\n          },\n          "ECU": {\n            "_replacement": "EC",\n            "_reason": "overlong"\n          },\n          "EGY": {\n            "_replacement": "EG",\n            "_reason": "overlong"\n          },\n          "ERI": {\n            "_replacement": "ER",\n            "_reason": "overlong"\n          },\n          "ESH": {\n            "_replacement": "EH",\n            "_reason": "overlong"\n          },\n          "ESP": {\n            "_replacement": "ES",\n            "_reason": "overlong"\n          },\n          "EST": {\n            "_replacement": "EE",\n            "_reason": "overlong"\n          },\n          "ETH": {\n            "_replacement": "ET",\n            "_reason": "overlong"\n          },\n          "FIN": {\n            "_replacement": "FI",\n            "_reason": "overlong"\n          },\n          "FJI": {\n            "_replacement": "FJ",\n            "_reason": "overlong"\n          },\n          "FLK": {\n            "_replacement": "FK",\n            "_reason": "overlong"\n          },\n          "FQ": {\n            "_replacement": "AQ TF",\n            "_reason": "deprecated"\n          },\n          "FRA": {\n            "_replacement": "FR",\n            "_reason": "overlong"\n          },\n          "FRO": {\n            "_replacement": "FO",\n            "_reason": "overlong"\n          },\n          "FSM": {\n            "_replacement": "FM",\n            "_reason": "overlong"\n          },\n          "FX": {\n            "_replacement": "FR",\n            "_reason": "deprecated"\n          },\n          "FXX": {\n            "_replacement": "FR",\n            "_reason": "overlong"\n          },\n          "GAB": {\n            "_replacement": "GA",\n            "_reason": "overlong"\n          },\n          "GBR": {\n            "_replacement": "GB",\n            "_reason": "overlong"\n          },\n          "GEO": {\n            "_replacement": "GE",\n            "_reason": "overlong"\n          },\n          "GGY": {\n            "_replacement": "GG",\n            "_reason": "overlong"\n          },\n          "GHA": {\n            "_replacement": "GH",\n            "_reason": "overlong"\n          },\n          "GIB": {\n            "_replacement": "GI",\n            "_reason": "overlong"\n          },\n          "GIN": {\n            "_replacement": "GN",\n            "_reason": "overlong"\n          },\n          "GLP": {\n            "_replacement": "GP",\n            "_reason": "overlong"\n          },\n          "GMB": {\n            "_replacement": "GM",\n            "_reason": "overlong"\n          },\n          "GNB": {\n            "_replacement": "GW",\n            "_reason": "overlong"\n          },\n          "GNQ": {\n            "_replacement": "GQ",\n            "_reason": "overlong"\n          },\n          "GRC": {\n            "_replacement": "GR",\n            "_reason": "overlong"\n          },\n          "GRD": {\n            "_replacement": "GD",\n            "_reason": "overlong"\n          },\n          "GRL": {\n            "_replacement": "GL",\n            "_reason": "overlong"\n          },\n          "GTM": {\n            "_replacement": "GT",\n            "_reason": "overlong"\n          },\n          "GUF": {\n            "_replacement": "GF",\n            "_reason": "overlong"\n          },\n          "GUM": {\n            "_replacement": "GU",\n            "_reason": "overlong"\n          },\n          "GUY": {\n            "_replacement": "GY",\n            "_reason": "overlong"\n          },\n          "HKG": {\n            "_replacement": "HK",\n            "_reason": "overlong"\n          },\n          "HMD": {\n            "_replacement": "HM",\n            "_reason": "overlong"\n          },\n          "HND": {\n            "_replacement": "HN",\n            "_reason": "overlong"\n          },\n          "HRV": {\n            "_replacement": "HR",\n            "_reason": "overlong"\n          },\n          "HTI": {\n            "_replacement": "HT",\n            "_reason": "overlong"\n          },\n          "HUN": {\n            "_replacement": "HU",\n            "_reason": "overlong"\n          },\n          "HV": {\n            "_replacement": "BF",\n            "_reason": "deprecated"\n          },\n          "IDN": {\n            "_replacement": "ID",\n            "_reason": "overlong"\n          },\n          "IMN": {\n            "_replacement": "IM",\n            "_reason": "overlong"\n          },\n          "IND": {\n            "_replacement": "IN",\n            "_reason": "overlong"\n          },\n          "IOT": {\n            "_replacement": "IO",\n            "_reason": "overlong"\n          },\n          "IRL": {\n            "_replacement": "IE",\n            "_reason": "overlong"\n          },\n          "IRN": {\n            "_replacement": "IR",\n            "_reason": "overlong"\n          },\n          "IRQ": {\n            "_replacement": "IQ",\n            "_reason": "overlong"\n          },\n          "ISL": {\n            "_replacement": "IS",\n            "_reason": "overlong"\n          },\n          "ISR": {\n            "_replacement": "IL",\n            "_reason": "overlong"\n          },\n          "ITA": {\n            "_replacement": "IT",\n            "_reason": "overlong"\n          },\n          "JAM": {\n            "_replacement": "JM",\n            "_reason": "overlong"\n          },\n          "JEY": {\n            "_replacement": "JE",\n            "_reason": "overlong"\n          },\n          "JOR": {\n            "_replacement": "JO",\n            "_reason": "overlong"\n          },\n          "JPN": {\n            "_replacement": "JP",\n            "_reason": "overlong"\n          },\n          "JT": {\n            "_replacement": "UM",\n            "_reason": "deprecated"\n          },\n          "KAZ": {\n            "_replacement": "KZ",\n            "_reason": "overlong"\n          },\n          "KEN": {\n            "_replacement": "KE",\n            "_reason": "overlong"\n          },\n          "KGZ": {\n            "_replacement": "KG",\n            "_reason": "overlong"\n          },\n          "KHM": {\n            "_replacement": "KH",\n            "_reason": "overlong"\n          },\n          "KIR": {\n            "_replacement": "KI",\n            "_reason": "overlong"\n          },\n          "KNA": {\n            "_replacement": "KN",\n            "_reason": "overlong"\n          },\n          "KOR": {\n            "_replacement": "KR",\n            "_reason": "overlong"\n          },\n          "KWT": {\n            "_replacement": "KW",\n            "_reason": "overlong"\n          },\n          "LAO": {\n            "_replacement": "LA",\n            "_reason": "overlong"\n          },\n          "LBN": {\n            "_replacement": "LB",\n            "_reason": "overlong"\n          },\n          "LBR": {\n            "_replacement": "LR",\n            "_reason": "overlong"\n          },\n          "LBY": {\n            "_replacement": "LY",\n            "_reason": "overlong"\n          },\n          "LCA": {\n            "_replacement": "LC",\n            "_reason": "overlong"\n          },\n          "LIE": {\n            "_replacement": "LI",\n            "_reason": "overlong"\n          },\n          "LKA": {\n            "_replacement": "LK",\n            "_reason": "overlong"\n          },\n          "LSO": {\n            "_replacement": "LS",\n            "_reason": "overlong"\n          },\n          "LTU": {\n            "_replacement": "LT",\n            "_reason": "overlong"\n          },\n          "LUX": {\n            "_replacement": "LU",\n            "_reason": "overlong"\n          },\n          "LVA": {\n            "_replacement": "LV",\n            "_reason": "overlong"\n          },\n          "MAC": {\n            "_replacement": "MO",\n            "_reason": "overlong"\n          },\n          "MAF": {\n            "_replacement": "MF",\n            "_reason": "overlong"\n          },\n          "MAR": {\n            "_replacement": "MA",\n            "_reason": "overlong"\n          },\n          "MCO": {\n            "_replacement": "MC",\n            "_reason": "overlong"\n          },\n          "MDA": {\n            "_replacement": "MD",\n            "_reason": "overlong"\n          },\n          "MDG": {\n            "_replacement": "MG",\n            "_reason": "overlong"\n          },\n          "MDV": {\n            "_replacement": "MV",\n            "_reason": "overlong"\n          },\n          "MEX": {\n            "_replacement": "MX",\n            "_reason": "overlong"\n          },\n          "MHL": {\n            "_replacement": "MH",\n            "_reason": "overlong"\n          },\n          "MI": {\n            "_replacement": "UM",\n            "_reason": "deprecated"\n          },\n          "MKD": {\n            "_replacement": "MK",\n            "_reason": "overlong"\n          },\n          "MLI": {\n            "_replacement": "ML",\n            "_reason": "overlong"\n          },\n          "MLT": {\n            "_replacement": "MT",\n            "_reason": "overlong"\n          },\n          "MMR": {\n            "_replacement": "MM",\n            "_reason": "overlong"\n          },\n          "MNE": {\n            "_replacement": "ME",\n            "_reason": "overlong"\n          },\n          "MNG": {\n            "_replacement": "MN",\n            "_reason": "overlong"\n          },\n          "MNP": {\n            "_replacement": "MP",\n            "_reason": "overlong"\n          },\n          "MOZ": {\n            "_replacement": "MZ",\n            "_reason": "overlong"\n          },\n          "MRT": {\n            "_replacement": "MR",\n            "_reason": "overlong"\n          },\n          "MSR": {\n            "_replacement": "MS",\n            "_reason": "overlong"\n          },\n          "MTQ": {\n            "_replacement": "MQ",\n            "_reason": "overlong"\n          },\n          "MUS": {\n            "_replacement": "MU",\n            "_reason": "overlong"\n          },\n          "MWI": {\n            "_replacement": "MW",\n            "_reason": "overlong"\n          },\n          "MYS": {\n            "_replacement": "MY",\n            "_reason": "overlong"\n          },\n          "MYT": {\n            "_replacement": "YT",\n            "_reason": "overlong"\n          },\n          "NAM": {\n            "_replacement": "NA",\n            "_reason": "overlong"\n          },\n          "NCL": {\n            "_replacement": "NC",\n            "_reason": "overlong"\n          },\n          "NER": {\n            "_replacement": "NE",\n            "_reason": "overlong"\n          },\n          "NFK": {\n            "_replacement": "NF",\n            "_reason": "overlong"\n          },\n          "NGA": {\n            "_replacement": "NG",\n            "_reason": "overlong"\n          },\n          "NH": {\n            "_replacement": "VU",\n            "_reason": "deprecated"\n          },\n          "NIC": {\n            "_replacement": "NI",\n            "_reason": "overlong"\n          },\n          "NIU": {\n            "_replacement": "NU",\n            "_reason": "overlong"\n          },\n          "NLD": {\n            "_replacement": "NL",\n            "_reason": "overlong"\n          },\n          "NOR": {\n            "_replacement": "NO",\n            "_reason": "overlong"\n          },\n          "NPL": {\n            "_replacement": "NP",\n            "_reason": "overlong"\n          },\n          "NQ": {\n            "_replacement": "AQ",\n            "_reason": "deprecated"\n          },\n          "NRU": {\n            "_replacement": "NR",\n            "_reason": "overlong"\n          },\n          "NT": {\n            "_replacement": "SA IQ",\n            "_reason": "deprecated"\n          },\n          "NTZ": {\n            "_replacement": "SA IQ",\n            "_reason": "overlong"\n          },\n          "NZL": {\n            "_replacement": "NZ",\n            "_reason": "overlong"\n          },\n          "OMN": {\n            "_replacement": "OM",\n            "_reason": "overlong"\n          },\n          "PAK": {\n            "_replacement": "PK",\n            "_reason": "overlong"\n          },\n          "PAN": {\n            "_replacement": "PA",\n            "_reason": "overlong"\n          },\n          "PC": {\n            "_replacement": "FM MH MP PW",\n            "_reason": "deprecated"\n          },\n          "PCN": {\n            "_replacement": "PN",\n            "_reason": "overlong"\n          },\n          "PER": {\n            "_replacement": "PE",\n            "_reason": "overlong"\n          },\n          "PHL": {\n            "_replacement": "PH",\n            "_reason": "overlong"\n          },\n          "PLW": {\n            "_replacement": "PW",\n            "_reason": "overlong"\n          },\n          "PNG": {\n            "_replacement": "PG",\n            "_reason": "overlong"\n          },\n          "POL": {\n            "_replacement": "PL",\n            "_reason": "overlong"\n          },\n          "PRI": {\n            "_replacement": "PR",\n            "_reason": "overlong"\n          },\n          "PRK": {\n            "_replacement": "KP",\n            "_reason": "overlong"\n          },\n          "PRT": {\n            "_replacement": "PT",\n            "_reason": "overlong"\n          },\n          "PRY": {\n            "_replacement": "PY",\n            "_reason": "overlong"\n          },\n          "PSE": {\n            "_replacement": "PS",\n            "_reason": "overlong"\n          },\n          "PU": {\n            "_replacement": "UM",\n            "_reason": "deprecated"\n          },\n          "PYF": {\n            "_replacement": "PF",\n            "_reason": "overlong"\n          },\n          "PZ": {\n            "_replacement": "PA",\n            "_reason": "deprecated"\n          },\n          "QAT": {\n            "_replacement": "QA",\n            "_reason": "overlong"\n          },\n          "QMM": {\n            "_replacement": "QM",\n            "_reason": "overlong"\n          },\n          "QNN": {\n            "_replacement": "QN",\n            "_reason": "overlong"\n          },\n          "QPP": {\n            "_replacement": "QP",\n            "_reason": "overlong"\n          },\n          "QQQ": {\n            "_replacement": "QQ",\n            "_reason": "overlong"\n          },\n          "QRR": {\n            "_replacement": "QR",\n            "_reason": "overlong"\n          },\n          "QSS": {\n            "_replacement": "QS",\n            "_reason": "overlong"\n          },\n          "QTT": {\n            "_replacement": "QT",\n            "_reason": "overlong"\n          },\n          "QU": {\n            "_replacement": "EU",\n            "_reason": "deprecated"\n          },\n          "QUU": {\n            "_replacement": "EU",\n            "_reason": "overlong"\n          },\n          "QVV": {\n            "_replacement": "QV",\n            "_reason": "overlong"\n          },\n          "QWW": {\n            "_replacement": "QW",\n            "_reason": "overlong"\n          },\n          "QXX": {\n            "_replacement": "QX",\n            "_reason": "overlong"\n          },\n          "QYY": {\n            "_replacement": "QY",\n            "_reason": "overlong"\n          },\n          "QZZ": {\n            "_replacement": "QZ",\n            "_reason": "overlong"\n          },\n          "REU": {\n            "_replacement": "RE",\n            "_reason": "overlong"\n          },\n          "RH": {\n            "_replacement": "ZW",\n            "_reason": "deprecated"\n          },\n          "ROU": {\n            "_replacement": "RO",\n            "_reason": "overlong"\n          },\n          "RUS": {\n            "_replacement": "RU",\n            "_reason": "overlong"\n          },\n          "RWA": {\n            "_replacement": "RW",\n            "_reason": "overlong"\n          },\n          "SAU": {\n            "_replacement": "SA",\n            "_reason": "overlong"\n          },\n          "SCG": {\n            "_replacement": "RS ME",\n            "_reason": "overlong"\n          },\n          "SDN": {\n            "_replacement": "SD",\n            "_reason": "overlong"\n          },\n          "SEN": {\n            "_replacement": "SN",\n            "_reason": "overlong"\n          },\n          "SGP": {\n            "_replacement": "SG",\n            "_reason": "overlong"\n          },\n          "SGS": {\n            "_replacement": "GS",\n            "_reason": "overlong"\n          },\n          "SHN": {\n            "_replacement": "SH",\n            "_reason": "overlong"\n          },\n          "SJM": {\n            "_replacement": "SJ",\n            "_reason": "overlong"\n          },\n          "SLB": {\n            "_replacement": "SB",\n            "_reason": "overlong"\n          },\n          "SLE": {\n            "_replacement": "SL",\n            "_reason": "overlong"\n          },\n          "SLV": {\n            "_replacement": "SV",\n            "_reason": "overlong"\n          },\n          "SMR": {\n            "_replacement": "SM",\n            "_reason": "overlong"\n          },\n          "SOM": {\n            "_replacement": "SO",\n            "_reason": "overlong"\n          },\n          "SPM": {\n            "_replacement": "PM",\n            "_reason": "overlong"\n          },\n          "SRB": {\n            "_replacement": "RS",\n            "_reason": "overlong"\n          },\n          "SSD": {\n            "_replacement": "SS",\n            "_reason": "overlong"\n          },\n          "STP": {\n            "_replacement": "ST",\n            "_reason": "overlong"\n          },\n          "SU": {\n            "_replacement": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",\n            "_reason": "deprecated"\n          },\n          "SUN": {\n            "_replacement": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",\n            "_reason": "overlong"\n          },\n          "SUR": {\n            "_replacement": "SR",\n            "_reason": "overlong"\n          },\n          "SVK": {\n            "_replacement": "SK",\n            "_reason": "overlong"\n          },\n          "SVN": {\n            "_replacement": "SI",\n            "_reason": "overlong"\n          },\n          "SWE": {\n            "_replacement": "SE",\n            "_reason": "overlong"\n          },\n          "SWZ": {\n            "_replacement": "SZ",\n            "_reason": "overlong"\n          },\n          "SXM": {\n            "_replacement": "SX",\n            "_reason": "overlong"\n          },\n          "SYC": {\n            "_replacement": "SC",\n            "_reason": "overlong"\n          },\n          "SYR": {\n            "_replacement": "SY",\n            "_reason": "overlong"\n          },\n          "TAA": {\n            "_replacement": "TA",\n            "_reason": "overlong"\n          },\n          "TCA": {\n            "_replacement": "TC",\n            "_reason": "overlong"\n          },\n          "TCD": {\n            "_replacement": "TD",\n            "_reason": "overlong"\n          },\n          "TGO": {\n            "_replacement": "TG",\n            "_reason": "overlong"\n          },\n          "THA": {\n            "_replacement": "TH",\n            "_reason": "overlong"\n          },\n          "TJK": {\n            "_replacement": "TJ",\n            "_reason": "overlong"\n          },\n          "TKL": {\n            "_replacement": "TK",\n            "_reason": "overlong"\n          },\n          "TKM": {\n            "_replacement": "TM",\n            "_reason": "overlong"\n          },\n          "TLS": {\n            "_replacement": "TL",\n            "_reason": "overlong"\n          },\n          "TMP": {\n            "_replacement": "TL",\n            "_reason": "overlong"\n          },\n          "TON": {\n            "_replacement": "TO",\n            "_reason": "overlong"\n          },\n          "TP": {\n            "_replacement": "TL",\n            "_reason": "deprecated"\n          },\n          "TTO": {\n            "_replacement": "TT",\n            "_reason": "overlong"\n          },\n          "TUN": {\n            "_replacement": "TN",\n            "_reason": "overlong"\n          },\n          "TUR": {\n            "_replacement": "TR",\n            "_reason": "overlong"\n          },\n          "TUV": {\n            "_replacement": "TV",\n            "_reason": "overlong"\n          },\n          "TWN": {\n            "_replacement": "TW",\n            "_reason": "overlong"\n          },\n          "TZA": {\n            "_replacement": "TZ",\n            "_reason": "overlong"\n          },\n          "UGA": {\n            "_replacement": "UG",\n            "_reason": "overlong"\n          },\n          "UK": {\n            "_replacement": "GB",\n            "_reason": "deprecated"\n          },\n          "UKR": {\n            "_replacement": "UA",\n            "_reason": "overlong"\n          },\n          "UMI": {\n            "_replacement": "UM",\n            "_reason": "overlong"\n          },\n          "URY": {\n            "_replacement": "UY",\n            "_reason": "overlong"\n          },\n          "USA": {\n            "_replacement": "US",\n            "_reason": "overlong"\n          },\n          "UZB": {\n            "_replacement": "UZ",\n            "_reason": "overlong"\n          },\n          "VAT": {\n            "_replacement": "VA",\n            "_reason": "overlong"\n          },\n          "VCT": {\n            "_replacement": "VC",\n            "_reason": "overlong"\n          },\n          "VD": {\n            "_replacement": "VN",\n            "_reason": "deprecated"\n          },\n          "VEN": {\n            "_replacement": "VE",\n            "_reason": "overlong"\n          },\n          "VGB": {\n            "_replacement": "VG",\n            "_reason": "overlong"\n          },\n          "VIR": {\n            "_replacement": "VI",\n            "_reason": "overlong"\n          },\n          "VNM": {\n            "_replacement": "VN",\n            "_reason": "overlong"\n          },\n          "VUT": {\n            "_replacement": "VU",\n            "_reason": "overlong"\n          },\n          "WK": {\n            "_replacement": "UM",\n            "_reason": "deprecated"\n          },\n          "WLF": {\n            "_replacement": "WF",\n            "_reason": "overlong"\n          },\n          "WSM": {\n            "_replacement": "WS",\n            "_reason": "overlong"\n          },\n          "XAA": {\n            "_replacement": "XA",\n            "_reason": "overlong"\n          },\n          "XBB": {\n            "_replacement": "XB",\n            "_reason": "overlong"\n          },\n          "XCC": {\n            "_replacement": "XC",\n            "_reason": "overlong"\n          },\n          "XDD": {\n            "_replacement": "XD",\n            "_reason": "overlong"\n          },\n          "XEE": {\n            "_replacement": "XE",\n            "_reason": "overlong"\n          },\n          "XFF": {\n            "_replacement": "XF",\n            "_reason": "overlong"\n          },\n          "XGG": {\n            "_replacement": "XG",\n            "_reason": "overlong"\n          },\n          "XHH": {\n            "_replacement": "XH",\n            "_reason": "overlong"\n          },\n          "XII": {\n            "_replacement": "XI",\n            "_reason": "overlong"\n          },\n          "XJJ": {\n            "_replacement": "XJ",\n            "_reason": "overlong"\n          },\n          "XKK": {\n            "_replacement": "XK",\n            "_reason": "overlong"\n          },\n          "XLL": {\n            "_replacement": "XL",\n            "_reason": "overlong"\n          },\n          "XMM": {\n            "_replacement": "XM",\n            "_reason": "overlong"\n          },\n          "XNN": {\n            "_replacement": "XN",\n            "_reason": "overlong"\n          },\n          "XOO": {\n            "_replacement": "XO",\n            "_reason": "overlong"\n          },\n          "XPP": {\n            "_replacement": "XP",\n            "_reason": "overlong"\n          },\n          "XQQ": {\n            "_replacement": "XQ",\n            "_reason": "overlong"\n          },\n          "XRR": {\n            "_replacement": "XR",\n            "_reason": "overlong"\n          },\n          "XSS": {\n            "_replacement": "XS",\n            "_reason": "overlong"\n          },\n          "XTT": {\n            "_replacement": "XT",\n            "_reason": "overlong"\n          },\n          "XUU": {\n            "_replacement": "XU",\n            "_reason": "overlong"\n          },\n          "XVV": {\n            "_replacement": "XV",\n            "_reason": "overlong"\n          },\n          "XWW": {\n            "_replacement": "XW",\n            "_reason": "overlong"\n          },\n          "XXX": {\n            "_replacement": "XX",\n            "_reason": "overlong"\n          },\n          "XYY": {\n            "_replacement": "XY",\n            "_reason": "overlong"\n          },\n          "XZZ": {\n            "_replacement": "XZ",\n            "_reason": "overlong"\n          },\n          "YD": {\n            "_replacement": "YE",\n            "_reason": "deprecated"\n          },\n          "YEM": {\n            "_replacement": "YE",\n            "_reason": "overlong"\n          },\n          "YMD": {\n            "_replacement": "YE",\n            "_reason": "overlong"\n          },\n          "YU": {\n            "_replacement": "RS ME",\n            "_reason": "deprecated"\n          },\n          "YUG": {\n            "_replacement": "RS ME",\n            "_reason": "overlong"\n          },\n          "ZAF": {\n            "_replacement": "ZA",\n            "_reason": "overlong"\n          },\n          "ZAR": {\n            "_replacement": "CD",\n            "_reason": "overlong"\n          },\n          "ZMB": {\n            "_replacement": "ZM",\n            "_reason": "overlong"\n          },\n          "ZR": {\n            "_replacement": "CD",\n            "_reason": "deprecated"\n          },\n          "ZWE": {\n            "_replacement": "ZW",\n            "_reason": "overlong"\n          },\n          "ZZZ": {\n            "_replacement": "ZZ",\n            "_reason": "overlong"\n          }\n        },\n        "variantAlias": {\n          "AALAND": {\n            "_replacement": "AX",\n            "_reason": "deprecated"\n          },\n          "BOKMAL": {\n            "_reason": "deprecated"\n          },\n          "BOONT": {\n            "_reason": "deprecated"\n          },\n          "GAULISH": {\n            "_reason": "deprecated"\n          },\n          "GUOYU": {\n            "_reason": "deprecated"\n          },\n          "HAKKA": {\n            "_reason": "deprecated"\n          },\n          "HEPLOC": {\n            "_replacement": "ALALC97",\n            "_reason": "deprecated"\n          },\n          "LOJBAN": {\n            "_reason": "deprecated"\n          },\n          "NYNORSK": {\n            "_reason": "deprecated"\n          },\n          "POLYTONI": {\n            "_replacement": "POLYTON",\n            "_reason": "deprecated"\n          },\n          "SAAHO": {\n            "_reason": "deprecated"\n          },\n          "SCOUSE": {\n            "_reason": "deprecated"\n          },\n          "XIANG": {\n            "_reason": "deprecated"\n          }\n        },\n        "zoneAlias": {\n          "Africa": {\n            "Timbuktu": {\n              "_replacement": "Africa/Bamako",\n              "_reason": "deprecated"\n            }\n          },\n          "America": {\n            "Montreal": {\n              "_replacement": "America/Toronto",\n              "_reason": "deprecated"\n            },\n            "Shiprock": {\n              "_replacement": "America/Denver",\n              "_reason": "deprecated"\n            }\n          },\n          "Antarctica": {\n            "South_Pole": {\n              "_replacement": "Pacific/Auckland",\n              "_reason": "deprecated"\n            }\n          },\n          "Asia": {\n            "Chongqing": {\n              "_replacement": "Asia/Shanghai",\n              "_reason": "deprecated"\n            },\n            "Harbin": {\n              "_replacement": "Asia/Shanghai",\n              "_reason": "deprecated"\n            },\n            "Kashgar": {\n              "_replacement": "Asia/Urumqi",\n              "_reason": "deprecated"\n            }\n          },\n          "Atlantic": {\n            "Jan_Mayen": {\n              "_replacement": "Europe/Oslo",\n              "_reason": "deprecated"\n            }\n          },\n          "EST": {\n            "_replacement": "America/Indianapolis",\n            "_reason": "deprecated"\n          },\n          "Europe": {\n            "Belfast": {\n              "_replacement": "Europe/London",\n              "_reason": "deprecated"\n            }\n          },\n          "HST": {\n            "_replacement": "Pacific/Honolulu",\n            "_reason": "deprecated"\n          },\n          "MST": {\n            "_replacement": "America/Phoenix",\n            "_reason": "deprecated"\n          },\n          "Pacific": {\n            "Yap": {\n              "_replacement": "Pacific/Truk",\n              "_reason": "deprecated"\n            }\n          },\n          "SystemV": {\n            "AST4": {\n              "_replacement": "America/Puerto_Rico",\n              "_reason": "deprecated"\n            },\n            "AST4ADT": {\n              "_replacement": "America/Halifax",\n              "_reason": "deprecated"\n            },\n            "CST6": {\n              "_replacement": "America/Regina",\n              "_reason": "deprecated"\n            },\n            "CST6CDT": {\n              "_replacement": "America/Chicago",\n              "_reason": "deprecated"\n            },\n            "EST5": {\n              "_replacement": "America/Indianapolis",\n              "_reason": "deprecated"\n            },\n            "EST5EDT": {\n              "_replacement": "America/New_York",\n              "_reason": "deprecated"\n            },\n            "HST10": {\n              "_replacement": "Pacific/Honolulu",\n              "_reason": "deprecated"\n            },\n            "MST7": {\n              "_replacement": "America/Phoenix",\n              "_reason": "deprecated"\n            },\n            "MST7MDT": {\n              "_replacement": "America/Denver",\n              "_reason": "deprecated"\n            },\n            "PST8": {\n              "_replacement": "Pacific/Pitcairn",\n              "_reason": "deprecated"\n            },\n            "PST8PDT": {\n              "_replacement": "America/Los_Angeles",\n              "_reason": "deprecated"\n            },\n            "YST9": {\n              "_replacement": "Pacific/Gambier",\n              "_reason": "deprecated"\n            },\n            "YST9YDT": {\n              "_replacement": "America/Anchorage",\n              "_reason": "deprecated"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/parentLocales.json',[],function () { return '{\n  "supplemental": {\n    "parentLocales": {\n      "parentLocale": {\n        "en-AG": "en-001",\n        "en-AI": "en-001",\n        "en-BB": "en-001",\n        "en-BM": "en-001",\n        "en-BS": "en-001",\n        "en-BW": "en-001",\n        "en-BZ": "en-001",\n        "en-CC": "en-001",\n        "en-CK": "en-001",\n        "en-CM": "en-001",\n        "en-CX": "en-001",\n        "en-DM": "en-001",\n        "en-ER": "en-001",\n        "en-FJ": "en-001",\n        "en-FM": "en-001",\n        "en-GB": "en-001",\n        "en-GD": "en-001",\n        "en-GH": "en-001",\n        "en-GM": "en-001",\n        "en-GY": "en-001",\n        "en-JM": "en-001",\n        "en-KE": "en-001",\n        "en-KI": "en-001",\n        "en-KN": "en-001",\n        "en-KY": "en-001",\n        "en-LC": "en-001",\n        "en-LR": "en-001",\n        "en-LS": "en-001",\n        "en-MG": "en-001",\n        "en-MS": "en-001",\n        "en-MU": "en-001",\n        "en-MW": "en-001",\n        "en-MY": "en-001",\n        "en-NA": "en-001",\n        "en-NF": "en-001",\n        "en-NG": "en-001",\n        "en-NR": "en-001",\n        "en-NU": "en-001",\n        "en-PG": "en-001",\n        "en-PH": "en-001",\n        "en-PN": "en-001",\n        "en-PW": "en-001",\n        "en-RW": "en-001",\n        "en-SB": "en-001",\n        "en-SC": "en-001",\n        "en-SD": "en-001",\n        "en-SL": "en-001",\n        "en-SS": "en-001",\n        "en-SX": "en-001",\n        "en-SZ": "en-001",\n        "en-TC": "en-001",\n        "en-TK": "en-001",\n        "en-TO": "en-001",\n        "en-TT": "en-001",\n        "en-TV": "en-001",\n        "en-TZ": "en-001",\n        "en-UG": "en-001",\n        "en-VC": "en-001",\n        "en-VU": "en-001",\n        "en-WS": "en-001",\n        "en-ZA": "en-001",\n        "en-ZM": "en-001",\n        "en-ZW": "en-001",\n        "en-150": "en-GB",\n        "en-AU": "en-GB",\n        "en-BE": "en-GB",\n        "en-DG": "en-GB",\n        "en-FK": "en-GB",\n        "en-GG": "en-GB",\n        "en-GI": "en-GB",\n        "en-HK": "en-GB",\n        "en-IE": "en-GB",\n        "en-IM": "en-GB",\n        "en-IN": "en-GB",\n        "en-IO": "en-GB",\n        "en-JE": "en-GB",\n        "en-MO": "en-GB",\n        "en-MT": "en-GB",\n        "en-NZ": "en-GB",\n        "en-PK": "en-GB",\n        "en-SG": "en-GB",\n        "en-SH": "en-GB",\n        "en-VG": "en-GB",\n        "es-AR": "es-419",\n        "es-BO": "es-419",\n        "es-CL": "es-419",\n        "es-CO": "es-419",\n        "es-CR": "es-419",\n        "es-CU": "es-419",\n        "es-DO": "es-419",\n        "es-EC": "es-419",\n        "es-GT": "es-419",\n        "es-HN": "es-419",\n        "es-MX": "es-419",\n        "es-NI": "es-419",\n        "es-PA": "es-419",\n        "es-PE": "es-419",\n        "es-PR": "es-419",\n        "es-PY": "es-419",\n        "es-SV": "es-419",\n        "es-US": "es-419",\n        "es-UY": "es-419",\n        "es-VE": "es-419",\n        "pt-AO": "pt-PT",\n        "pt-CV": "pt-PT",\n        "pt-GW": "pt-PT",\n        "pt-MO": "pt-PT",\n        "pt-MZ": "pt-PT",\n        "pt-ST": "pt-PT",\n        "pt-TL": "pt-PT",\n        "az-Cyrl": "root",\n        "bm-Nkoo": "root",\n        "bs-Cyrl": "root",\n        "en-Dsrt": "root",\n        "ha-Arab": "root",\n        "mn-Mong": "root",\n        "ms-Arab": "root",\n        "pa-Arab": "root",\n        "shi-Latn": "root",\n        "sr-Latn": "root",\n        "uz-Arab": "root",\n        "uz-Cyrl": "root",\n        "vai-Latn": "root",\n        "zh-Hant": "root",\n        "zh-Hant-MO": "zh-Hant-HK"\n      }\n    }\n  }\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/likelySubtags.json',[],function () { return '{\n  "supplemental": {\n    "likelySubtags": {\n      "aa": "aa-Latn-ET",\n      "ab": "ab-Cyrl-GE",\n      "abr": "abr-Latn-GH",\n      "ace": "ace-Latn-ID",\n      "ach": "ach-Latn-UG",\n      "ady": "ady-Cyrl-RU",\n      "ae": "ae-Avst-IR",\n      "aeb": "aeb-Arab-TN",\n      "af": "af-Latn-ZA",\n      "agq": "agq-Latn-CM",\n      "ak": "ak-Latn-GH",\n      "akk": "akk-Xsux-IQ",\n      "aln": "aln-Latn-XK",\n      "alt": "alt-Cyrl-RU",\n      "am": "am-Ethi-ET",\n      "amo": "amo-Latn-NG",\n      "aoz": "aoz-Latn-ID",\n      "ar": "ar-Arab-EG",\n      "arc": "arc-Armi-IR",\n      "arc-Nbat": "arc-Nbat-JO",\n      "arc-Palm": "arc-Palm-SY",\n      "arn": "arn-Latn-CL",\n      "aro": "aro-Latn-BO",\n      "arq": "arq-Arab-DZ",\n      "ary": "ary-Arab-MA",\n      "arz": "arz-Arab-EG",\n      "as": "as-Beng-IN",\n      "asa": "asa-Latn-TZ",\n      "ast": "ast-Latn-ES",\n      "atj": "atj-Latn-CA",\n      "av": "av-Cyrl-RU",\n      "awa": "awa-Deva-IN",\n      "ay": "ay-Latn-BO",\n      "az": "az-Latn-AZ",\n      "az-Arab": "az-Arab-IR",\n      "az-IR": "az-Arab-IR",\n      "az-RU": "az-Cyrl-RU",\n      "azb": "azb-Arab-IR",\n      "ba": "ba-Cyrl-RU",\n      "bal": "bal-Arab-PK",\n      "ban": "ban-Latn-ID",\n      "bap": "bap-Deva-NP",\n      "bar": "bar-Latn-AT",\n      "bas": "bas-Latn-CM",\n      "bax": "bax-Bamu-CM",\n      "bbc": "bbc-Latn-ID",\n      "bbj": "bbj-Latn-CM",\n      "bci": "bci-Latn-CI",\n      "be": "be-Cyrl-BY",\n      "bem": "bem-Latn-ZM",\n      "bew": "bew-Latn-ID",\n      "bez": "bez-Latn-TZ",\n      "bfd": "bfd-Latn-CM",\n      "bfq": "bfq-Taml-IN",\n      "bft": "bft-Arab-PK",\n      "bfy": "bfy-Deva-IN",\n      "bg": "bg-Cyrl-BG",\n      "bgc": "bgc-Deva-IN",\n      "bgx": "bgx-Grek-TR",\n      "bh": "bh-Kthi-IN",\n      "bhb": "bhb-Deva-IN",\n      "bhi": "bhi-Deva-IN",\n      "bhk": "bhk-Latn-PH",\n      "bho": "bho-Deva-IN",\n      "bi": "bi-Latn-VU",\n      "bik": "bik-Latn-PH",\n      "bin": "bin-Latn-NG",\n      "bjj": "bjj-Deva-IN",\n      "bjn": "bjn-Latn-ID",\n      "bkm": "bkm-Latn-CM",\n      "bku": "bku-Latn-PH",\n      "blt": "blt-Tavt-VN",\n      "bm": "bm-Latn-ML",\n      "bmq": "bmq-Latn-ML",\n      "bn": "bn-Beng-BD",\n      "bo": "bo-Tibt-CN",\n      "bpy": "bpy-Beng-IN",\n      "bqi": "bqi-Arab-IR",\n      "bqv": "bqv-Latn-CI",\n      "br": "br-Latn-FR",\n      "bra": "bra-Deva-IN",\n      "brh": "brh-Arab-PK",\n      "brx": "brx-Deva-IN",\n      "bs": "bs-Latn-BA",\n      "bsq": "bsq-Bass-LR",\n      "bss": "bss-Latn-CM",\n      "bto": "bto-Latn-PH",\n      "btv": "btv-Deva-PK",\n      "bua": "bua-Cyrl-RU",\n      "buc": "buc-Latn-YT",\n      "bug": "bug-Latn-ID",\n      "bum": "bum-Latn-CM",\n      "bvb": "bvb-Latn-GQ",\n      "byn": "byn-Ethi-ER",\n      "byv": "byv-Latn-CM",\n      "bze": "bze-Latn-ML",\n      "ca": "ca-Latn-ES",\n      "cch": "cch-Latn-NG",\n      "ccp": "ccp-Beng-IN",\n      "ccp-Cakm": "ccp-Cakm-BD",\n      "ce": "ce-Cyrl-RU",\n      "ceb": "ceb-Latn-PH",\n      "cgg": "cgg-Latn-UG",\n      "ch": "ch-Latn-GU",\n      "chk": "chk-Latn-FM",\n      "chm": "chm-Cyrl-RU",\n      "chp": "chp-Latn-CA",\n      "chr": "chr-Cher-US",\n      "cja": "cja-Arab-KH",\n      "cjm": "cjm-Cham-VN",\n      "ckb": "ckb-Arab-IQ",\n      "co": "co-Latn-FR",\n      "cop": "cop-Copt-EG",\n      "cps": "cps-Latn-PH",\n      "cr": "cr-Cans-CA",\n      "crj": "crj-Cans-CA",\n      "crk": "crk-Cans-CA",\n      "crl": "crl-Cans-CA",\n      "crm": "crm-Cans-CA",\n      "crs": "crs-Latn-SC",\n      "cs": "cs-Latn-CZ",\n      "csb": "csb-Latn-PL",\n      "csw": "csw-Cans-CA",\n      "ctd": "ctd-Pauc-MM",\n      "cu": "cu-Cyrl-RU",\n      "cu-Glag": "cu-Glag-BG",\n      "cv": "cv-Cyrl-RU",\n      "cy": "cy-Latn-GB",\n      "da": "da-Latn-DK",\n      "dar": "dar-Cyrl-RU",\n      "dav": "dav-Latn-KE",\n      "dcc": "dcc-Arab-IN",\n      "de": "de-Latn-DE",\n      "den": "den-Latn-CA",\n      "dgr": "dgr-Latn-CA",\n      "dje": "dje-Latn-NE",\n      "dnj": "dnj-Latn-CI",\n      "doi": "doi-Arab-IN",\n      "dsb": "dsb-Latn-DE",\n      "dtm": "dtm-Latn-ML",\n      "dtp": "dtp-Latn-MY",\n      "dua": "dua-Latn-CM",\n      "dv": "dv-Thaa-MV",\n      "dyo": "dyo-Latn-SN",\n      "dyu": "dyu-Latn-BF",\n      "dz": "dz-Tibt-BT",\n      "ebu": "ebu-Latn-KE",\n      "ee": "ee-Latn-GH",\n      "efi": "efi-Latn-NG",\n      "egl": "egl-Latn-IT",\n      "egy": "egy-Egyp-EG",\n      "eky": "eky-Kali-MM",\n      "el": "el-Grek-GR",\n      "en": "en-Latn-US",\n      "en-Shaw": "en-Shaw-GB",\n      "eo": "eo-Latn-001",\n      "es": "es-Latn-ES",\n      "esu": "esu-Latn-US",\n      "et": "et-Latn-EE",\n      "ett": "ett-Ital-IT",\n      "eu": "eu-Latn-ES",\n      "ewo": "ewo-Latn-CM",\n      "ext": "ext-Latn-ES",\n      "fa": "fa-Arab-IR",\n      "fan": "fan-Latn-GQ",\n      "ff": "ff-Latn-SN",\n      "ffm": "ffm-Latn-ML",\n      "fi": "fi-Latn-FI",\n      "fil": "fil-Latn-PH",\n      "fit": "fit-Latn-SE",\n      "fj": "fj-Latn-FJ",\n      "fo": "fo-Latn-FO",\n      "fon": "fon-Latn-BJ",\n      "fr": "fr-Latn-FR",\n      "frc": "frc-Latn-US",\n      "frp": "frp-Latn-FR",\n      "frr": "frr-Latn-DE",\n      "frs": "frs-Latn-DE",\n      "fud": "fud-Latn-WF",\n      "fuq": "fuq-Latn-NE",\n      "fur": "fur-Latn-IT",\n      "fuv": "fuv-Latn-NG",\n      "fy": "fy-Latn-NL",\n      "ga": "ga-Latn-IE",\n      "gaa": "gaa-Latn-GH",\n      "gag": "gag-Latn-MD",\n      "gan": "gan-Hans-CN",\n      "gbm": "gbm-Deva-IN",\n      "gbz": "gbz-Arab-IR",\n      "gcr": "gcr-Latn-GF",\n      "gd": "gd-Latn-GB",\n      "gez": "gez-Ethi-ET",\n      "ggn": "ggn-Deva-NP",\n      "gil": "gil-Latn-KI",\n      "gjk": "gjk-Arab-PK",\n      "gju": "gju-Arab-PK",\n      "gl": "gl-Latn-ES",\n      "glk": "glk-Arab-IR",\n      "gn": "gn-Latn-PY",\n      "gom": "gom-Deva-IN",\n      "gon": "gon-Telu-IN",\n      "gor": "gor-Latn-ID",\n      "gos": "gos-Latn-NL",\n      "got": "got-Goth-UA",\n      "grc": "grc-Cprt-CY",\n      "grc-Linb": "grc-Linb-GR",\n      "grt": "grt-Beng-IN",\n      "gsw": "gsw-Latn-CH",\n      "gu": "gu-Gujr-IN",\n      "gub": "gub-Latn-BR",\n      "guc": "guc-Latn-CO",\n      "gur": "gur-Latn-GH",\n      "guz": "guz-Latn-KE",\n      "gv": "gv-Latn-IM",\n      "gvr": "gvr-Deva-NP",\n      "gwi": "gwi-Latn-CA",\n      "ha": "ha-Latn-NG",\n      "ha-CM": "ha-Arab-CM",\n      "ha-SD": "ha-Arab-SD",\n      "hak": "hak-Hans-CN",\n      "haw": "haw-Latn-US",\n      "haz": "haz-Arab-AF",\n      "he": "he-Hebr-IL",\n      "hi": "hi-Deva-IN",\n      "hif": "hif-Deva-FJ",\n      "hil": "hil-Latn-PH",\n      "hmd": "hmd-Plrd-CN",\n      "hnd": "hnd-Arab-PK",\n      "hne": "hne-Deva-IN",\n      "hnj": "hnj-Hmng-LA",\n      "hnn": "hnn-Latn-PH",\n      "hno": "hno-Arab-PK",\n      "ho": "ho-Latn-PG",\n      "hoc": "hoc-Deva-IN",\n      "hoj": "hoj-Deva-IN",\n      "hr": "hr-Latn-HR",\n      "hsb": "hsb-Latn-DE",\n      "hsn": "hsn-Hans-CN",\n      "ht": "ht-Latn-HT",\n      "hu": "hu-Latn-HU",\n      "hy": "hy-Armn-AM",\n      "ia": "ia-Latn-FR",\n      "ibb": "ibb-Latn-NG",\n      "id": "id-Latn-ID",\n      "ig": "ig-Latn-NG",\n      "ii": "ii-Yiii-CN",\n      "ik": "ik-Latn-US",\n      "ikt": "ikt-Latn-CA",\n      "ilo": "ilo-Latn-PH",\n      "in": "in-Latn-ID",\n      "inh": "inh-Cyrl-RU",\n      "is": "is-Latn-IS",\n      "it": "it-Latn-IT",\n      "iu": "iu-Cans-CA",\n      "iw": "iw-Hebr-IL",\n      "izh": "izh-Latn-RU",\n      "ja": "ja-Jpan-JP",\n      "jam": "jam-Latn-JM",\n      "jgo": "jgo-Latn-CM",\n      "ji": "ji-Hebr-UA",\n      "jmc": "jmc-Latn-TZ",\n      "jml": "jml-Deva-NP",\n      "jut": "jut-Latn-DK",\n      "jv": "jv-Latn-ID",\n      "jw": "jw-Latn-ID",\n      "ka": "ka-Geor-GE",\n      "kaa": "kaa-Cyrl-UZ",\n      "kab": "kab-Latn-DZ",\n      "kaj": "kaj-Latn-NG",\n      "kam": "kam-Latn-KE",\n      "kao": "kao-Latn-ML",\n      "kbd": "kbd-Cyrl-RU",\n      "kcg": "kcg-Latn-NG",\n      "kck": "kck-Latn-ZW",\n      "kde": "kde-Latn-TZ",\n      "kdt": "kdt-Thai-TH",\n      "kea": "kea-Latn-CV",\n      "ken": "ken-Latn-CM",\n      "kfo": "kfo-Latn-CI",\n      "kfr": "kfr-Deva-IN",\n      "kfy": "kfy-Deva-IN",\n      "kg": "kg-Latn-CD",\n      "kge": "kge-Latn-ID",\n      "kgp": "kgp-Latn-BR",\n      "kha": "kha-Latn-IN",\n      "khb": "khb-Talu-CN",\n      "khn": "khn-Deva-IN",\n      "khq": "khq-Latn-ML",\n      "kht": "kht-Mymr-IN",\n      "khw": "khw-Arab-PK",\n      "ki": "ki-Latn-KE",\n      "kiu": "kiu-Latn-TR",\n      "kj": "kj-Latn-NA",\n      "kjg": "kjg-Laoo-LA",\n      "kk": "kk-Cyrl-KZ",\n      "kk-AF": "kk-Arab-AF",\n      "kk-Arab": "kk-Arab-CN",\n      "kk-CN": "kk-Arab-CN",\n      "kk-IR": "kk-Arab-IR",\n      "kk-MN": "kk-Arab-MN",\n      "kkj": "kkj-Latn-CM",\n      "kl": "kl-Latn-GL",\n      "kln": "kln-Latn-KE",\n      "km": "km-Khmr-KH",\n      "kmb": "kmb-Latn-AO",\n      "kn": "kn-Knda-IN",\n      "ko": "ko-Kore-KR",\n      "koi": "koi-Cyrl-RU",\n      "kok": "kok-Deva-IN",\n      "kos": "kos-Latn-FM",\n      "kpe": "kpe-Latn-LR",\n      "krc": "krc-Cyrl-RU",\n      "kri": "kri-Latn-SL",\n      "krj": "krj-Latn-PH",\n      "krl": "krl-Latn-RU",\n      "kru": "kru-Deva-IN",\n      "ks": "ks-Arab-IN",\n      "ksb": "ksb-Latn-TZ",\n      "ksf": "ksf-Latn-CM",\n      "ksh": "ksh-Latn-DE",\n      "ku": "ku-Latn-TR",\n      "ku-Arab": "ku-Arab-IQ",\n      "ku-LB": "ku-Arab-LB",\n      "kum": "kum-Cyrl-RU",\n      "kv": "kv-Cyrl-RU",\n      "kvr": "kvr-Latn-ID",\n      "kvx": "kvx-Arab-PK",\n      "kw": "kw-Latn-GB",\n      "kxm": "kxm-Thai-TH",\n      "kxp": "kxp-Arab-PK",\n      "ky": "ky-Cyrl-KG",\n      "ky-Arab": "ky-Arab-CN",\n      "ky-CN": "ky-Arab-CN",\n      "ky-Latn": "ky-Latn-TR",\n      "ky-TR": "ky-Latn-TR",\n      "la": "la-Latn-VA",\n      "lab": "lab-Lina-GR",\n      "lad": "lad-Hebr-IL",\n      "lag": "lag-Latn-TZ",\n      "lah": "lah-Arab-PK",\n      "laj": "laj-Latn-UG",\n      "lb": "lb-Latn-LU",\n      "lbe": "lbe-Cyrl-RU",\n      "lbw": "lbw-Latn-ID",\n      "lcp": "lcp-Thai-CN",\n      "lep": "lep-Lepc-IN",\n      "lez": "lez-Cyrl-RU",\n      "lg": "lg-Latn-UG",\n      "li": "li-Latn-NL",\n      "lif": "lif-Deva-NP",\n      "lif-Limb": "lif-Limb-IN",\n      "lij": "lij-Latn-IT",\n      "lis": "lis-Lisu-CN",\n      "ljp": "ljp-Latn-ID",\n      "lki": "lki-Arab-IR",\n      "lkt": "lkt-Latn-US",\n      "lmn": "lmn-Telu-IN",\n      "lmo": "lmo-Latn-IT",\n      "ln": "ln-Latn-CD",\n      "lo": "lo-Laoo-LA",\n      "lol": "lol-Latn-CD",\n      "loz": "loz-Latn-ZM",\n      "lrc": "lrc-Arab-IR",\n      "lt": "lt-Latn-LT",\n      "ltg": "ltg-Latn-LV",\n      "lu": "lu-Latn-CD",\n      "lua": "lua-Latn-CD",\n      "luo": "luo-Latn-KE",\n      "luy": "luy-Latn-KE",\n      "luz": "luz-Arab-IR",\n      "lv": "lv-Latn-LV",\n      "lwl": "lwl-Thai-TH",\n      "lzh": "lzh-Hans-CN",\n      "lzz": "lzz-Latn-TR",\n      "mad": "mad-Latn-ID",\n      "maf": "maf-Latn-CM",\n      "mag": "mag-Deva-IN",\n      "mai": "mai-Deva-IN",\n      "mak": "mak-Latn-ID",\n      "man": "man-Latn-GM",\n      "man-GN": "man-Nkoo-GN",\n      "man-Nkoo": "man-Nkoo-GN",\n      "mas": "mas-Latn-KE",\n      "maz": "maz-Latn-MX",\n      "mdf": "mdf-Cyrl-RU",\n      "mdh": "mdh-Latn-PH",\n      "mdr": "mdr-Latn-ID",\n      "men": "men-Latn-SL",\n      "mer": "mer-Latn-KE",\n      "mfa": "mfa-Arab-TH",\n      "mfe": "mfe-Latn-MU",\n      "mg": "mg-Latn-MG",\n      "mgh": "mgh-Latn-MZ",\n      "mgo": "mgo-Latn-CM",\n      "mgp": "mgp-Deva-NP",\n      "mgy": "mgy-Latn-TZ",\n      "mh": "mh-Latn-MH",\n      "mi": "mi-Latn-NZ",\n      "min": "min-Latn-ID",\n      "mk": "mk-Cyrl-MK",\n      "ml": "ml-Mlym-IN",\n      "mn": "mn-Cyrl-MN",\n      "mn-CN": "mn-Mong-CN",\n      "mn-Mong": "mn-Mong-CN",\n      "mni": "mni-Beng-IN",\n      "mnw": "mnw-Mymr-MM",\n      "moe": "moe-Latn-CA",\n      "moh": "moh-Latn-CA",\n      "mos": "mos-Latn-BF",\n      "mr": "mr-Deva-IN",\n      "mrd": "mrd-Deva-NP",\n      "mrj": "mrj-Cyrl-RU",\n      "mru": "mru-Mroo-BD",\n      "ms": "ms-Latn-MY",\n      "ms-CC": "ms-Arab-CC",\n      "ms-ID": "ms-Arab-ID",\n      "mt": "mt-Latn-MT",\n      "mtr": "mtr-Deva-IN",\n      "mua": "mua-Latn-CM",\n      "mvy": "mvy-Arab-PK",\n      "mwk": "mwk-Latn-ML",\n      "mwr": "mwr-Deva-IN",\n      "mwv": "mwv-Latn-ID",\n      "mxc": "mxc-Latn-ZW",\n      "my": "my-Mymr-MM",\n      "myv": "myv-Cyrl-RU",\n      "myx": "myx-Latn-UG",\n      "myz": "myz-Mand-IR",\n      "mzn": "mzn-Arab-IR",\n      "na": "na-Latn-NR",\n      "nan": "nan-Hans-CN",\n      "nap": "nap-Latn-IT",\n      "naq": "naq-Latn-NA",\n      "nb": "nb-Latn-NO",\n      "nch": "nch-Latn-MX",\n      "nd": "nd-Latn-ZW",\n      "ndc": "ndc-Latn-MZ",\n      "nds": "nds-Latn-DE",\n      "ne": "ne-Deva-NP",\n      "new": "new-Deva-NP",\n      "ng": "ng-Latn-NA",\n      "ngl": "ngl-Latn-MZ",\n      "nhe": "nhe-Latn-MX",\n      "nhw": "nhw-Latn-MX",\n      "nij": "nij-Latn-ID",\n      "niu": "niu-Latn-NU",\n      "njo": "njo-Latn-IN",\n      "nl": "nl-Latn-NL",\n      "nmg": "nmg-Latn-CM",\n      "nn": "nn-Latn-NO",\n      "nnh": "nnh-Latn-CM",\n      "no": "no-Latn-NO",\n      "nod": "nod-Lana-TH",\n      "noe": "noe-Deva-IN",\n      "non": "non-Runr-SE",\n      "nqo": "nqo-Nkoo-GN",\n      "nr": "nr-Latn-ZA",\n      "nsk": "nsk-Cans-CA",\n      "nso": "nso-Latn-ZA",\n      "nus": "nus-Latn-SD",\n      "nv": "nv-Latn-US",\n      "nxq": "nxq-Latn-CN",\n      "ny": "ny-Latn-MW",\n      "nym": "nym-Latn-TZ",\n      "nyn": "nyn-Latn-UG",\n      "oc": "oc-Latn-FR",\n      "om": "om-Latn-ET",\n      "or": "or-Orya-IN",\n      "os": "os-Cyrl-GE",\n      "otk": "otk-Orkh-MN",\n      "pa": "pa-Guru-IN",\n      "pa-Arab": "pa-Arab-PK",\n      "pa-PK": "pa-Arab-PK",\n      "pag": "pag-Latn-PH",\n      "pal": "pal-Phli-IR",\n      "pal-Phlp": "pal-Phlp-CN",\n      "pam": "pam-Latn-PH",\n      "pap": "pap-Latn-AW",\n      "pau": "pau-Latn-PW",\n      "pcd": "pcd-Latn-FR",\n      "pcm": "pcm-Latn-NG",\n      "pdc": "pdc-Latn-US",\n      "pdt": "pdt-Latn-CA",\n      "peo": "peo-Xpeo-IR",\n      "pfl": "pfl-Latn-DE",\n      "phn": "phn-Phnx-LB",\n      "pka": "pka-Brah-IN",\n      "pko": "pko-Latn-KE",\n      "pl": "pl-Latn-PL",\n      "pms": "pms-Latn-IT",\n      "pnt": "pnt-Grek-GR",\n      "pon": "pon-Latn-FM",\n      "pra": "pra-Khar-PK",\n      "prd": "prd-Arab-IR",\n      "prg": "prg-Latn-001",\n      "ps": "ps-Arab-AF",\n      "pt": "pt-Latn-BR",\n      "puu": "puu-Latn-GA",\n      "qu": "qu-Latn-PE",\n      "quc": "quc-Latn-GT",\n      "qug": "qug-Latn-EC",\n      "raj": "raj-Latn-IN",\n      "rcf": "rcf-Latn-RE",\n      "rej": "rej-Latn-ID",\n      "rgn": "rgn-Latn-IT",\n      "ria": "ria-Latn-IN",\n      "rif": "rif-Tfng-MA",\n      "rif-NL": "rif-Latn-NL",\n      "rjs": "rjs-Deva-NP",\n      "rkt": "rkt-Beng-BD",\n      "rm": "rm-Latn-CH",\n      "rmf": "rmf-Latn-FI",\n      "rmo": "rmo-Latn-CH",\n      "rmt": "rmt-Arab-IR",\n      "rmu": "rmu-Latn-SE",\n      "rn": "rn-Latn-BI",\n      "rng": "rng-Latn-MZ",\n      "ro": "ro-Latn-RO",\n      "rob": "rob-Latn-ID",\n      "rof": "rof-Latn-TZ",\n      "rtm": "rtm-Latn-FJ",\n      "ru": "ru-Cyrl-RU",\n      "rue": "rue-Cyrl-UA",\n      "rug": "rug-Latn-SB",\n      "rw": "rw-Latn-RW",\n      "rwk": "rwk-Latn-TZ",\n      "ryu": "ryu-Kana-JP",\n      "sa": "sa-Deva-IN",\n      "saf": "saf-Latn-GH",\n      "sah": "sah-Cyrl-RU",\n      "saq": "saq-Latn-KE",\n      "sas": "sas-Latn-ID",\n      "sat": "sat-Latn-IN",\n      "saz": "saz-Saur-IN",\n      "sbp": "sbp-Latn-TZ",\n      "sc": "sc-Latn-IT",\n      "sck": "sck-Deva-IN",\n      "scn": "scn-Latn-IT",\n      "sco": "sco-Latn-GB",\n      "scs": "scs-Latn-CA",\n      "sd": "sd-Arab-PK",\n      "sd-Deva": "sd-Deva-IN",\n      "sd-Khoj": "sd-Khoj-IN",\n      "sd-Sind": "sd-Sind-IN",\n      "sdc": "sdc-Latn-IT",\n      "se": "se-Latn-NO",\n      "sef": "sef-Latn-CI",\n      "seh": "seh-Latn-MZ",\n      "sei": "sei-Latn-MX",\n      "ses": "ses-Latn-ML",\n      "sg": "sg-Latn-CF",\n      "sga": "sga-Ogam-IE",\n      "sgs": "sgs-Latn-LT",\n      "shi": "shi-Tfng-MA",\n      "shn": "shn-Mymr-MM",\n      "si": "si-Sinh-LK",\n      "sid": "sid-Latn-ET",\n      "sk": "sk-Latn-SK",\n      "skr": "skr-Arab-PK",\n      "sl": "sl-Latn-SI",\n      "sli": "sli-Latn-PL",\n      "sly": "sly-Latn-ID",\n      "sm": "sm-Latn-WS",\n      "sma": "sma-Latn-SE",\n      "smj": "smj-Latn-SE",\n      "smn": "smn-Latn-FI",\n      "smp": "smp-Samr-IL",\n      "sms": "sms-Latn-FI",\n      "sn": "sn-Latn-ZW",\n      "snk": "snk-Latn-ML",\n      "so": "so-Latn-SO",\n      "sou": "sou-Thai-TH",\n      "sq": "sq-Latn-AL",\n      "sr": "sr-Cyrl-RS",\n      "sr-ME": "sr-Latn-ME",\n      "sr-RO": "sr-Latn-RO",\n      "sr-RU": "sr-Latn-RU",\n      "sr-TR": "sr-Latn-TR",\n      "srb": "srb-Sora-IN",\n      "srn": "srn-Latn-SR",\n      "srr": "srr-Latn-SN",\n      "srx": "srx-Deva-IN",\n      "ss": "ss-Latn-ZA",\n      "ssy": "ssy-Latn-ER",\n      "st": "st-Latn-ZA",\n      "stq": "stq-Latn-DE",\n      "su": "su-Latn-ID",\n      "suk": "suk-Latn-TZ",\n      "sus": "sus-Latn-GN",\n      "sv": "sv-Latn-SE",\n      "sw": "sw-Latn-TZ",\n      "swb": "swb-Arab-YT",\n      "swc": "swc-Latn-CD",\n      "swv": "swv-Deva-IN",\n      "sxn": "sxn-Latn-ID",\n      "syl": "syl-Beng-BD",\n      "syr": "syr-Syrc-IQ",\n      "szl": "szl-Latn-PL",\n      "ta": "ta-Taml-IN",\n      "taj": "taj-Deva-NP",\n      "tbw": "tbw-Latn-PH",\n      "tcy": "tcy-Knda-IN",\n      "tdd": "tdd-Tale-CN",\n      "tdg": "tdg-Deva-NP",\n      "tdh": "tdh-Deva-NP",\n      "te": "te-Telu-IN",\n      "tem": "tem-Latn-SL",\n      "teo": "teo-Latn-UG",\n      "tet": "tet-Latn-TL",\n      "tg": "tg-Cyrl-TJ",\n      "tg-Arab": "tg-Arab-PK",\n      "tg-PK": "tg-Arab-PK",\n      "th": "th-Thai-TH",\n      "thl": "thl-Deva-NP",\n      "thq": "thq-Deva-NP",\n      "thr": "thr-Deva-NP",\n      "ti": "ti-Ethi-ET",\n      "tig": "tig-Ethi-ER",\n      "tiv": "tiv-Latn-NG",\n      "tk": "tk-Latn-TM",\n      "tkl": "tkl-Latn-TK",\n      "tkr": "tkr-Latn-AZ",\n      "tkt": "tkt-Deva-NP",\n      "tl": "tl-Latn-PH",\n      "tly": "tly-Latn-AZ",\n      "tmh": "tmh-Latn-NE",\n      "tn": "tn-Latn-ZA",\n      "to": "to-Latn-TO",\n      "tpi": "tpi-Latn-PG",\n      "tr": "tr-Latn-TR",\n      "tru": "tru-Latn-TR",\n      "trv": "trv-Latn-TW",\n      "ts": "ts-Latn-ZA",\n      "tsd": "tsd-Grek-GR",\n      "tsf": "tsf-Deva-NP",\n      "tsg": "tsg-Latn-PH",\n      "tsj": "tsj-Tibt-BT",\n      "tt": "tt-Cyrl-RU",\n      "ttj": "ttj-Latn-UG",\n      "tts": "tts-Thai-TH",\n      "ttt": "ttt-Latn-AZ",\n      "tum": "tum-Latn-MW",\n      "tvl": "tvl-Latn-TV",\n      "twq": "twq-Latn-NE",\n      "ty": "ty-Latn-PF",\n      "tyv": "tyv-Cyrl-RU",\n      "tzm": "tzm-Latn-MA",\n      "udm": "udm-Cyrl-RU",\n      "ug": "ug-Arab-CN",\n      "ug-Cyrl": "ug-Cyrl-KZ",\n      "ug-KZ": "ug-Cyrl-KZ",\n      "ug-MN": "ug-Cyrl-MN",\n      "uga": "uga-Ugar-SY",\n      "uk": "uk-Cyrl-UA",\n      "uli": "uli-Latn-FM",\n      "umb": "umb-Latn-AO",\n      "und": "en-Latn-US",\n      "und-002": "en-Latn-NG",\n      "und-003": "en-Latn-US",\n      "und-005": "pt-Latn-BR",\n      "und-009": "en-Latn-AU",\n      "und-011": "en-Latn-NG",\n      "und-013": "es-Latn-MX",\n      "und-014": "en-Latn-KE",\n      "und-015": "ar-Arab-EG",\n      "und-017": "sw-Latn-CD",\n      "und-018": "en-Latn-ZA",\n      "und-019": "en-Latn-US",\n      "und-021": "en-Latn-US",\n      "und-029": "es-Latn-CU",\n      "und-030": "zh-Hans-CN",\n      "und-034": "hi-Deva-IN",\n      "und-035": "id-Latn-ID",\n      "und-039": "it-Latn-IT",\n      "und-053": "en-Latn-AU",\n      "und-054": "en-Latn-PG",\n      "und-057": "en-Latn-KI",\n      "und-061": "sm-Latn-WS",\n      "und-142": "zh-Hans-CN",\n      "und-143": "uz-Latn-UZ",\n      "und-145": "ar-Arab-SA",\n      "und-150": "ru-Cyrl-RU",\n      "und-151": "ru-Cyrl-RU",\n      "und-154": "en-Latn-GB",\n      "und-155": "de-Latn-DE",\n      "und-419": "es-Latn-419",\n      "und-AD": "ca-Latn-AD",\n      "und-AE": "ar-Arab-AE",\n      "und-AF": "fa-Arab-AF",\n      "und-AL": "sq-Latn-AL",\n      "und-AM": "hy-Armn-AM",\n      "und-AO": "pt-Latn-AO",\n      "und-AQ": "und-Latn-AQ",\n      "und-AR": "es-Latn-AR",\n      "und-AS": "sm-Latn-AS",\n      "und-AT": "de-Latn-AT",\n      "und-AW": "nl-Latn-AW",\n      "und-AX": "sv-Latn-AX",\n      "und-AZ": "az-Latn-AZ",\n      "und-Aghb": "lez-Aghb-RU",\n      "und-Arab": "ar-Arab-EG",\n      "und-Arab-CC": "ms-Arab-CC",\n      "und-Arab-CN": "ug-Arab-CN",\n      "und-Arab-GB": "ks-Arab-GB",\n      "und-Arab-ID": "ms-Arab-ID",\n      "und-Arab-IN": "ur-Arab-IN",\n      "und-Arab-KH": "cja-Arab-KH",\n      "und-Arab-MN": "kk-Arab-MN",\n      "und-Arab-MU": "ur-Arab-MU",\n      "und-Arab-NG": "ha-Arab-NG",\n      "und-Arab-PK": "ur-Arab-PK",\n      "und-Arab-TH": "mfa-Arab-TH",\n      "und-Arab-TJ": "fa-Arab-TJ",\n      "und-Arab-YT": "swb-Arab-YT",\n      "und-Armi": "arc-Armi-IR",\n      "und-Armn": "hy-Armn-AM",\n      "und-Avst": "ae-Avst-IR",\n      "und-BA": "bs-Latn-BA",\n      "und-BD": "bn-Beng-BD",\n      "und-BE": "nl-Latn-BE",\n      "und-BF": "fr-Latn-BF",\n      "und-BG": "bg-Cyrl-BG",\n      "und-BH": "ar-Arab-BH",\n      "und-BI": "rn-Latn-BI",\n      "und-BJ": "fr-Latn-BJ",\n      "und-BL": "fr-Latn-BL",\n      "und-BN": "ms-Latn-BN",\n      "und-BO": "es-Latn-BO",\n      "und-BQ": "pap-Latn-BQ",\n      "und-BR": "pt-Latn-BR",\n      "und-BT": "dz-Tibt-BT",\n      "und-BV": "und-Latn-BV",\n      "und-BY": "be-Cyrl-BY",\n      "und-Bali": "ban-Bali-ID",\n      "und-Bamu": "bax-Bamu-CM",\n      "und-Bass": "bsq-Bass-LR",\n      "und-Batk": "bbc-Batk-ID",\n      "und-Beng": "bn-Beng-BD",\n      "und-Bopo": "zh-Bopo-TW",\n      "und-Brah": "pka-Brah-IN",\n      "und-Brai": "fr-Brai-FR",\n      "und-Bugi": "bug-Bugi-ID",\n      "und-Buhd": "bku-Buhd-PH",\n      "und-CD": "sw-Latn-CD",\n      "und-CF": "fr-Latn-CF",\n      "und-CG": "fr-Latn-CG",\n      "und-CH": "de-Latn-CH",\n      "und-CI": "fr-Latn-CI",\n      "und-CL": "es-Latn-CL",\n      "und-CM": "fr-Latn-CM",\n      "und-CN": "zh-Hans-CN",\n      "und-CO": "es-Latn-CO",\n      "und-CP": "und-Latn-CP",\n      "und-CR": "es-Latn-CR",\n      "und-CU": "es-Latn-CU",\n      "und-CV": "pt-Latn-CV",\n      "und-CW": "pap-Latn-CW",\n      "und-CY": "el-Grek-CY",\n      "und-CZ": "cs-Latn-CZ",\n      "und-Cakm": "ccp-Cakm-BD",\n      "und-Cans": "cr-Cans-CA",\n      "und-Cari": "xcr-Cari-TR",\n      "und-Cham": "cjm-Cham-VN",\n      "und-Cher": "chr-Cher-US",\n      "und-Copt": "cop-Copt-EG",\n      "und-Cprt": "grc-Cprt-CY",\n      "und-Cyrl": "ru-Cyrl-RU",\n      "und-Cyrl-AL": "mk-Cyrl-AL",\n      "und-Cyrl-BA": "sr-Cyrl-BA",\n      "und-Cyrl-GE": "ab-Cyrl-GE",\n      "und-Cyrl-GR": "mk-Cyrl-GR",\n      "und-Cyrl-MD": "uk-Cyrl-MD",\n      "und-Cyrl-PL": "be-Cyrl-PL",\n      "und-Cyrl-RO": "bg-Cyrl-RO",\n      "und-Cyrl-SK": "uk-Cyrl-SK",\n      "und-Cyrl-TR": "kbd-Cyrl-TR",\n      "und-Cyrl-XK": "sr-Cyrl-XK",\n      "und-DE": "de-Latn-DE",\n      "und-DJ": "aa-Latn-DJ",\n      "und-DK": "da-Latn-DK",\n      "und-DO": "es-Latn-DO",\n      "und-DZ": "ar-Arab-DZ",\n      "und-Deva": "hi-Deva-IN",\n      "und-Deva-BT": "ne-Deva-BT",\n      "und-Deva-FJ": "hif-Deva-FJ",\n      "und-Deva-MU": "bho-Deva-MU",\n      "und-Deva-PK": "btv-Deva-PK",\n      "und-Dupl": "fr-Dupl-FR",\n      "und-EA": "es-Latn-EA",\n      "und-EC": "es-Latn-EC",\n      "und-EE": "et-Latn-EE",\n      "und-EG": "ar-Arab-EG",\n      "und-EH": "ar-Arab-EH",\n      "und-ER": "ti-Ethi-ER",\n      "und-ES": "es-Latn-ES",\n      "und-ET": "am-Ethi-ET",\n      "und-EU": "en-Latn-GB",\n      "und-Egyp": "egy-Egyp-EG",\n      "und-Elba": "sq-Elba-AL",\n      "und-Ethi": "am-Ethi-ET",\n      "und-FI": "fi-Latn-FI",\n      "und-FM": "chk-Latn-FM",\n      "und-FO": "fo-Latn-FO",\n      "und-FR": "fr-Latn-FR",\n      "und-GA": "fr-Latn-GA",\n      "und-GE": "ka-Geor-GE",\n      "und-GF": "fr-Latn-GF",\n      "und-GH": "ak-Latn-GH",\n      "und-GL": "kl-Latn-GL",\n      "und-GN": "fr-Latn-GN",\n      "und-GP": "fr-Latn-GP",\n      "und-GQ": "es-Latn-GQ",\n      "und-GR": "el-Grek-GR",\n      "und-GS": "und-Latn-GS",\n      "und-GT": "es-Latn-GT",\n      "und-GW": "pt-Latn-GW",\n      "und-Geor": "ka-Geor-GE",\n      "und-Glag": "cu-Glag-BG",\n      "und-Goth": "got-Goth-UA",\n      "und-Gran": "sa-Gran-IN",\n      "und-Grek": "el-Grek-GR",\n      "und-Grek-TR": "bgx-Grek-TR",\n      "und-Gujr": "gu-Gujr-IN",\n      "und-Guru": "pa-Guru-IN",\n      "und-HK": "zh-Hant-HK",\n      "und-HM": "und-Latn-HM",\n      "und-HN": "es-Latn-HN",\n      "und-HR": "hr-Latn-HR",\n      "und-HT": "ht-Latn-HT",\n      "und-HU": "hu-Latn-HU",\n      "und-Hang": "ko-Hang-KR",\n      "und-Hani": "zh-Hani-CN",\n      "und-Hano": "hnn-Hano-PH",\n      "und-Hans": "zh-Hans-CN",\n      "und-Hant": "zh-Hant-TW",\n      "und-Hebr": "he-Hebr-IL",\n      "und-Hebr-CA": "yi-Hebr-CA",\n      "und-Hebr-GB": "yi-Hebr-GB",\n      "und-Hebr-SE": "yi-Hebr-SE",\n      "und-Hebr-UA": "yi-Hebr-UA",\n      "und-Hebr-US": "yi-Hebr-US",\n      "und-Hira": "ja-Hira-JP",\n      "und-Hmng": "hnj-Hmng-LA",\n      "und-IC": "es-Latn-IC",\n      "und-ID": "id-Latn-ID",\n      "und-IL": "he-Hebr-IL",\n      "und-IN": "hi-Deva-IN",\n      "und-IQ": "ar-Arab-IQ",\n      "und-IR": "fa-Arab-IR",\n      "und-IS": "is-Latn-IS",\n      "und-IT": "it-Latn-IT",\n      "und-Ital": "ett-Ital-IT",\n      "und-JO": "ar-Arab-JO",\n      "und-JP": "ja-Jpan-JP",\n      "und-Java": "jv-Java-ID",\n      "und-Jpan": "ja-Jpan-JP",\n      "und-KG": "ky-Cyrl-KG",\n      "und-KH": "km-Khmr-KH",\n      "und-KM": "ar-Arab-KM",\n      "und-KP": "ko-Kore-KP",\n      "und-KR": "ko-Kore-KR",\n      "und-KW": "ar-Arab-KW",\n      "und-KZ": "ru-Cyrl-KZ",\n      "und-Kali": "eky-Kali-MM",\n      "und-Kana": "ja-Kana-JP",\n      "und-Khar": "pra-Khar-PK",\n      "und-Khmr": "km-Khmr-KH",\n      "und-Khoj": "sd-Khoj-IN",\n      "und-Knda": "kn-Knda-IN",\n      "und-Kore": "ko-Kore-KR",\n      "und-Kthi": "bh-Kthi-IN",\n      "und-LA": "lo-Laoo-LA",\n      "und-LB": "ar-Arab-LB",\n      "und-LI": "de-Latn-LI",\n      "und-LK": "si-Sinh-LK",\n      "und-LS": "st-Latn-LS",\n      "und-LT": "lt-Latn-LT",\n      "und-LU": "fr-Latn-LU",\n      "und-LV": "lv-Latn-LV",\n      "und-LY": "ar-Arab-LY",\n      "und-Lana": "nod-Lana-TH",\n      "und-Laoo": "lo-Laoo-LA",\n      "und-Latn-AF": "tk-Latn-AF",\n      "und-Latn-AM": "ku-Latn-AM",\n      "und-Latn-BG": "tr-Latn-BG",\n      "und-Latn-CN": "za-Latn-CN",\n      "und-Latn-CY": "tr-Latn-CY",\n      "und-Latn-DZ": "fr-Latn-DZ",\n      "und-Latn-ET": "en-Latn-ET",\n      "und-Latn-GE": "ku-Latn-GE",\n      "und-Latn-GR": "tr-Latn-GR",\n      "und-Latn-IL": "ro-Latn-IL",\n      "und-Latn-IR": "tk-Latn-IR",\n      "und-Latn-KM": "fr-Latn-KM",\n      "und-Latn-KZ": "de-Latn-KZ",\n      "und-Latn-LB": "fr-Latn-LB",\n      "und-Latn-MA": "fr-Latn-MA",\n      "und-Latn-MK": "sq-Latn-MK",\n      "und-Latn-MO": "pt-Latn-MO",\n      "und-Latn-MR": "fr-Latn-MR",\n      "und-Latn-RU": "krl-Latn-RU",\n      "und-Latn-SY": "fr-Latn-SY",\n      "und-Latn-TN": "fr-Latn-TN",\n      "und-Latn-TW": "trv-Latn-TW",\n      "und-Latn-UA": "pl-Latn-UA",\n      "und-Lepc": "lep-Lepc-IN",\n      "und-Limb": "lif-Limb-IN",\n      "und-Lina": "lab-Lina-GR",\n      "und-Linb": "grc-Linb-GR",\n      "und-Lisu": "lis-Lisu-CN",\n      "und-Lyci": "xlc-Lyci-TR",\n      "und-Lydi": "xld-Lydi-TR",\n      "und-MA": "ar-Arab-MA",\n      "und-MC": "fr-Latn-MC",\n      "und-MD": "ro-Latn-MD",\n      "und-ME": "sr-Latn-ME",\n      "und-MF": "fr-Latn-MF",\n      "und-MG": "mg-Latn-MG",\n      "und-MK": "mk-Cyrl-MK",\n      "und-ML": "bm-Latn-ML",\n      "und-MM": "my-Mymr-MM",\n      "und-MN": "mn-Cyrl-MN",\n      "und-MO": "zh-Hant-MO",\n      "und-MQ": "fr-Latn-MQ",\n      "und-MR": "ar-Arab-MR",\n      "und-MT": "mt-Latn-MT",\n      "und-MU": "mfe-Latn-MU",\n      "und-MV": "dv-Thaa-MV",\n      "und-MX": "es-Latn-MX",\n      "und-MY": "ms-Latn-MY",\n      "und-MZ": "pt-Latn-MZ",\n      "und-Mahj": "hi-Mahj-IN",\n      "und-Mand": "myz-Mand-IR",\n      "und-Mani": "xmn-Mani-CN",\n      "und-Mend": "men-Mend-SL",\n      "und-Merc": "xmr-Merc-SD",\n      "und-Mero": "xmr-Mero-SD",\n      "und-Mlym": "ml-Mlym-IN",\n      "und-Modi": "mr-Modi-IN",\n      "und-Mong": "mn-Mong-CN",\n      "und-Mroo": "mru-Mroo-BD",\n      "und-Mtei": "mni-Mtei-IN",\n      "und-Mymr": "my-Mymr-MM",\n      "und-Mymr-IN": "kht-Mymr-IN",\n      "und-Mymr-TH": "mnw-Mymr-TH",\n      "und-NA": "af-Latn-NA",\n      "und-NC": "fr-Latn-NC",\n      "und-NE": "ha-Latn-NE",\n      "und-NI": "es-Latn-NI",\n      "und-NL": "nl-Latn-NL",\n      "und-NO": "nb-Latn-NO",\n      "und-NP": "ne-Deva-NP",\n      "und-Narb": "xna-Narb-SA",\n      "und-Nbat": "arc-Nbat-JO",\n      "und-Nkoo": "man-Nkoo-GN",\n      "und-OM": "ar-Arab-OM",\n      "und-Ogam": "sga-Ogam-IE",\n      "und-Olck": "sat-Olck-IN",\n      "und-Orkh": "otk-Orkh-MN",\n      "und-Orya": "or-Orya-IN",\n      "und-Osma": "so-Osma-SO",\n      "und-PA": "es-Latn-PA",\n      "und-PE": "es-Latn-PE",\n      "und-PF": "fr-Latn-PF",\n      "und-PG": "tpi-Latn-PG",\n      "und-PH": "fil-Latn-PH",\n      "und-PK": "ur-Arab-PK",\n      "und-PL": "pl-Latn-PL",\n      "und-PM": "fr-Latn-PM",\n      "und-PR": "es-Latn-PR",\n      "und-PS": "ar-Arab-PS",\n      "und-PT": "pt-Latn-PT",\n      "und-PW": "pau-Latn-PW",\n      "und-PY": "gn-Latn-PY",\n      "und-Palm": "arc-Palm-SY",\n      "und-Pauc": "ctd-Pauc-MM",\n      "und-Perm": "kv-Perm-RU",\n      "und-Phag": "lzh-Phag-CN",\n      "und-Phli": "pal-Phli-IR",\n      "und-Phlp": "pal-Phlp-CN",\n      "und-Phnx": "phn-Phnx-LB",\n      "und-Plrd": "hmd-Plrd-CN",\n      "und-Prti": "xpr-Prti-IR",\n      "und-QA": "ar-Arab-QA",\n      "und-QO": "en-Latn-IO",\n      "und-RE": "fr-Latn-RE",\n      "und-RO": "ro-Latn-RO",\n      "und-RS": "sr-Cyrl-RS",\n      "und-RU": "ru-Cyrl-RU",\n      "und-RW": "rw-Latn-RW",\n      "und-Rjng": "rej-Rjng-ID",\n      "und-Runr": "non-Runr-SE",\n      "und-SA": "ar-Arab-SA",\n      "und-SC": "fr-Latn-SC",\n      "und-SD": "ar-Arab-SD",\n      "und-SE": "sv-Latn-SE",\n      "und-SI": "sl-Latn-SI",\n      "und-SJ": "nb-Latn-SJ",\n      "und-SK": "sk-Latn-SK",\n      "und-SM": "it-Latn-SM",\n      "und-SN": "fr-Latn-SN",\n      "und-SO": "so-Latn-SO",\n      "und-SR": "nl-Latn-SR",\n      "und-ST": "pt-Latn-ST",\n      "und-SV": "es-Latn-SV",\n      "und-SY": "ar-Arab-SY",\n      "und-Samr": "smp-Samr-IL",\n      "und-Sarb": "xsa-Sarb-YE",\n      "und-Saur": "saz-Saur-IN",\n      "und-Shaw": "en-Shaw-GB",\n      "und-Shrd": "sa-Shrd-IN",\n      "und-Sidd": "sa-Sidd-IN",\n      "und-Sind": "sd-Sind-IN",\n      "und-Sinh": "si-Sinh-LK",\n      "und-Sora": "srb-Sora-IN",\n      "und-Sund": "su-Sund-ID",\n      "und-Sylo": "syl-Sylo-BD",\n      "und-Syrc": "syr-Syrc-IQ",\n      "und-TD": "fr-Latn-TD",\n      "und-TF": "fr-Latn-TF",\n      "und-TG": "fr-Latn-TG",\n      "und-TH": "th-Thai-TH",\n      "und-TJ": "tg-Cyrl-TJ",\n      "und-TK": "tkl-Latn-TK",\n      "und-TL": "pt-Latn-TL",\n      "und-TM": "tk-Latn-TM",\n      "und-TN": "ar-Arab-TN",\n      "und-TO": "to-Latn-TO",\n      "und-TR": "tr-Latn-TR",\n      "und-TV": "tvl-Latn-TV",\n      "und-TW": "zh-Hant-TW",\n      "und-TZ": "sw-Latn-TZ",\n      "und-Tagb": "tbw-Tagb-PH",\n      "und-Takr": "doi-Takr-IN",\n      "und-Tale": "tdd-Tale-CN",\n      "und-Talu": "khb-Talu-CN",\n      "und-Taml": "ta-Taml-IN",\n      "und-Tavt": "blt-Tavt-VN",\n      "und-Telu": "te-Telu-IN",\n      "und-Tfng": "zgh-Tfng-MA",\n      "und-Tglg": "fil-Tglg-PH",\n      "und-Thaa": "dv-Thaa-MV",\n      "und-Thai": "th-Thai-TH",\n      "und-Thai-CN": "lcp-Thai-CN",\n      "und-Thai-KH": "kdt-Thai-KH",\n      "und-Thai-LA": "kdt-Thai-LA",\n      "und-Tibt": "bo-Tibt-CN",\n      "und-Tirh": "mai-Tirh-IN",\n      "und-UA": "uk-Cyrl-UA",\n      "und-UG": "sw-Latn-UG",\n      "und-UY": "es-Latn-UY",\n      "und-UZ": "uz-Latn-UZ",\n      "und-Ugar": "uga-Ugar-SY",\n      "und-VA": "it-Latn-VA",\n      "und-VE": "es-Latn-VE",\n      "und-VN": "vi-Latn-VN",\n      "und-VU": "bi-Latn-VU",\n      "und-Vaii": "vai-Vaii-LR",\n      "und-WF": "fr-Latn-WF",\n      "und-WS": "sm-Latn-WS",\n      "und-Wara": "hoc-Wara-IN",\n      "und-XK": "sq-Latn-XK",\n      "und-Xpeo": "peo-Xpeo-IR",\n      "und-Xsux": "akk-Xsux-IQ",\n      "und-YE": "ar-Arab-YE",\n      "und-YT": "fr-Latn-YT",\n      "und-Yiii": "ii-Yiii-CN",\n      "unr": "unr-Beng-IN",\n      "unr-Deva": "unr-Deva-NP",\n      "unr-NP": "unr-Deva-NP",\n      "unx": "unx-Beng-IN",\n      "ur": "ur-Arab-PK",\n      "uz": "uz-Latn-UZ",\n      "uz-AF": "uz-Arab-AF",\n      "uz-Arab": "uz-Arab-AF",\n      "uz-CN": "uz-Cyrl-CN",\n      "vai": "vai-Vaii-LR",\n      "ve": "ve-Latn-ZA",\n      "vec": "vec-Latn-IT",\n      "vep": "vep-Latn-RU",\n      "vi": "vi-Latn-VN",\n      "vic": "vic-Latn-SX",\n      "vls": "vls-Latn-BE",\n      "vmf": "vmf-Latn-DE",\n      "vmw": "vmw-Latn-MZ",\n      "vo": "vo-Latn-001",\n      "vro": "vro-Latn-EE",\n      "vun": "vun-Latn-TZ",\n      "wa": "wa-Latn-BE",\n      "wae": "wae-Latn-CH",\n      "wal": "wal-Ethi-ET",\n      "war": "war-Latn-PH",\n      "wbq": "wbq-Telu-IN",\n      "wbr": "wbr-Deva-IN",\n      "wls": "wls-Latn-WF",\n      "wo": "wo-Latn-SN",\n      "wtm": "wtm-Deva-IN",\n      "wuu": "wuu-Hans-CN",\n      "xav": "xav-Latn-BR",\n      "xcr": "xcr-Cari-TR",\n      "xh": "xh-Latn-ZA",\n      "xlc": "xlc-Lyci-TR",\n      "xld": "xld-Lydi-TR",\n      "xmf": "xmf-Geor-GE",\n      "xmn": "xmn-Mani-CN",\n      "xmr": "xmr-Merc-SD",\n      "xna": "xna-Narb-SA",\n      "xnr": "xnr-Deva-IN",\n      "xog": "xog-Latn-UG",\n      "xpr": "xpr-Prti-IR",\n      "xsa": "xsa-Sarb-YE",\n      "xsr": "xsr-Deva-NP",\n      "yao": "yao-Latn-MZ",\n      "yap": "yap-Latn-FM",\n      "yav": "yav-Latn-CM",\n      "ybb": "ybb-Latn-CM",\n      "yi": "yi-Hebr-001",\n      "yo": "yo-Latn-NG",\n      "yrl": "yrl-Latn-BR",\n      "yua": "yua-Latn-MX",\n      "za": "za-Latn-CN",\n      "zdj": "zdj-Arab-KM",\n      "zea": "zea-Latn-NL",\n      "zgh": "zgh-Tfng-MA",\n      "zh": "zh-Hans-CN",\n      "zh-AU": "zh-Hant-AU",\n      "zh-BN": "zh-Hant-BN",\n      "zh-Bopo": "zh-Bopo-TW",\n      "zh-GB": "zh-Hant-GB",\n      "zh-GF": "zh-Hant-GF",\n      "zh-HK": "zh-Hant-HK",\n      "zh-Hant": "zh-Hant-TW",\n      "zh-ID": "zh-Hant-ID",\n      "zh-MO": "zh-Hant-MO",\n      "zh-MY": "zh-Hant-MY",\n      "zh-PA": "zh-Hant-PA",\n      "zh-PF": "zh-Hant-PF",\n      "zh-PH": "zh-Hant-PH",\n      "zh-SR": "zh-Hant-SR",\n      "zh-TH": "zh-Hant-TH",\n      "zh-TW": "zh-Hant-TW",\n      "zh-US": "zh-Hant-US",\n      "zh-VN": "zh-Hant-VN",\n      "zmi": "zmi-Latn-MY",\n      "zu": "zu-Latn-ZA",\n      "zza": "zza-Latn-TR"\n    }\n  }\n}\n';});
;
define('requirejs-text/text!ecma402/cldr/supplemental/calendarPreferenceData.json',[],function () { return '{\n  "supplemental": {\n    "calendarPreferenceData": {\n      "001": "gregorian",\n      "AE": "gregorian islamic-umalqura islamic islamic-civil islamic-tbla",\n      "AF": "persian gregorian islamic islamic-civil islamic-tbla",\n      "BH": "gregorian islamic-umalqura islamic islamic-civil islamic-tbla",\n      "CN": "gregorian chinese",\n      "CX": "gregorian chinese",\n      "DJ": "gregorian islamic islamic-civil islamic-tbla",\n      "DZ": "gregorian islamic islamic-civil islamic-tbla",\n      "EG": "gregorian coptic islamic islamic-civil islamic-tbla",\n      "EH": "gregorian islamic islamic-civil islamic-tbla",\n      "ER": "gregorian islamic islamic-civil islamic-tbla",\n      "ET": "gregorian ethiopic",\n      "HK": "gregorian chinese",\n      "IL": "gregorian hebrew islamic islamic-civil islamic-tbla",\n      "IN": "gregorian indian",\n      "IQ": "gregorian islamic islamic-civil islamic-tbla",\n      "IR": "persian gregorian islamic islamic-civil islamic-tbla",\n      "JO": "gregorian islamic islamic-civil islamic-tbla",\n      "JP": "gregorian japanese",\n      "KM": "gregorian islamic islamic-civil islamic-tbla",\n      "KR": "gregorian dangi",\n      "KW": "gregorian islamic-umalqura islamic islamic-civil islamic-tbla",\n      "LB": "gregorian islamic islamic-civil islamic-tbla",\n      "LY": "gregorian islamic islamic-civil islamic-tbla",\n      "MA": "gregorian islamic islamic-civil islamic-tbla",\n      "MO": "gregorian chinese",\n      "MR": "gregorian islamic islamic-civil islamic-tbla",\n      "OM": "gregorian islamic islamic-civil islamic-tbla",\n      "PS": "gregorian islamic islamic-civil islamic-tbla",\n      "QA": "gregorian islamic-umalqura islamic islamic-civil islamic-tbla",\n      "SA": "gregorian islamic-umalqura islamic islamic-rgsa",\n      "SD": "gregorian islamic islamic-civil islamic-tbla",\n      "SG": "gregorian chinese",\n      "SY": "gregorian islamic islamic-civil islamic-tbla",\n      "TD": "gregorian islamic islamic-civil islamic-tbla",\n      "TH": "buddhist gregorian",\n      "TN": "gregorian islamic islamic-civil islamic-tbla",\n      "TW": "gregorian roc chinese",\n      "YE": "gregorian islamic islamic-civil islamic-tbla"\n    }\n  }\n}\n';});
;
/**
 * Commonly used routines throughout ECMA-402 package. Also referred to in the standard as "Abstract Operations"
 */
define('ecma402/impl/common',["./List", "./Record",
		"requirejs-text/text!../cldr/config/availableLocales.json",
		"requirejs-text/text!../cldr/supplemental/aliases.json",
		"requirejs-text/text!../cldr/supplemental/parentLocales.json",
		"requirejs-text/text!../cldr/supplemental/likelySubtags.json",
		"requirejs-text/text!../cldr/supplemental/calendarPreferenceData.json"
],
	function (List, Record, availableLocalesJson, aliasesJson, 
			parentLocalesJson, likelySubtagsJson, calendarPreferenceDataJson) {
		var aliases = JSON.parse(aliasesJson).supplemental.metadata.alias;
		var parentLocales = JSON.parse(parentLocalesJson).supplemental.parentLocales.parentLocale;
		var likelySubtags = JSON.parse(likelySubtagsJson).supplemental.likelySubtags;
		var calendarPreferenceData = JSON.parse(calendarPreferenceDataJson).supplemental.calendarPreferenceData;
		var common = {
			unicodeLocaleExtensions : /-u(-[a-z0-9]{2,8})+/g,
			/**
			 * Utility function to convert identifier strings to upper case as defined in ECMA-402 Section 6.1
			 * 
			 * @param {String} identifier The string to be converted
			 * @returns {String} The converted string
			 * @private
			 */
			_toUpperCaseIdentifier : function (identifier) {
				var match = /[a-z]/g;
				return identifier.replace(match, function (m) {
					return m.toUpperCase();
				}); // String
			},
			/**
			 * Utility function to convert identifier strings to lower case as defined in ECMA-402 Section 6.1
			 * 
			 * @param {String} identifier The string to be converted
			 * @returns {String} The converted string
			 * @private
			 */
			_toLowerCaseIdentifier : function (identifier) {
				var match = /[A-Z]/g;
				return identifier.replace(match, function (m) {
					return m.toLowerCase();
				}); // String
			},
			/**
			 * Utility function to retrieve the appropriate region code given a locale identifier.
			 * If just a language tag is given, then the likely subtags data from CLDR is checked
			 * to find the most likely region code.
			 * 
			 * @param {String} locale The locale identifier
			 * @returns {String} The 2 letter region code
			 * @private
			 */
			_getRegion : function (locale) {
				var region = "001";
				var regionPos = locale.search(/(?:-)([A-Z]{2})(?=(-|$))/);
				if (regionPos >= 0) {
					region = locale.substr(regionPos + 1, 2);
				} else {
					var likelySubtag = likelySubtags[locale];
					if (likelySubtag) {
						region = likelySubtag.substr(-2);
					}
				}
				return region;
			},
			/**
			 * Utility function to determine the supported calendars for a given region.
			 * Calendar preference data from CLDR is used to determine which locales are used
			 * in a given region.
			 * 
			 * @param {String} region The 2 letter region code
			 * @returns {String[]} An array containing the supported calendars for this region, in order of preference.
			 * @private
			 */
			_getSupportedCalendars : function (region) {
				var supportedCalendars = [ "gregory", "buddhist", "hebrew", "japanese", "roc",
				                           "islamic", "islamic-civil", "islamic-tbla", "islamic-umalqura"];
				var calendarPreferences = [];
				if (calendarPreferenceData[region]) {
					var prefs = calendarPreferenceData[region].toString().split(" ");
					prefs.forEach(function (pref) {
						var thisPref = pref.replace("gregorian", "gregory");
						if (supportedCalendars.indexOf(thisPref) !== -1) {
							calendarPreferences.push(thisPref);
						}
					});
				}
				/* Gregorian should always be supported */
				if (calendarPreferences.indexOf("gregory") === -1) {
					calendarPreferences.push("gregory");
				}
				return calendarPreferences;
			},

			/**
			 * IsStructurallyValidLanguageTag abstract operation as defined in ECMA-402 Section 6.2.2
			 * 
			 * @param {String} locale The language tag to check
			 * @returns {Boolean} Returns true if the string is a structurally valid language tag.
			 * @private
			 */
			isStructurallyValidLanguageTag : function (locale) {
				if (typeof locale !== "string") {
					return false; // Boolean
				}
				var identifier = this._toLowerCaseIdentifier(locale);
				var langtag = new RegExp(
						"^([a-z]{2,3}(-[a-z]{3}){0,3}|[a-z]{4,8})" + // language
						"(-[a-z]{4})?" + // script
						"(-([a-z]{2}|\\d{3}))?" + // territory
						"(-([a-z0-9]{5,8}|\\d[a-z0-9]{3}))*" + // variant
						"(-[a-wyz0-9](-[a-z0-9]{2,8})+)*(-x(-[a-z0-9]{1,8})+)?$"); // extension
				var privateuse = /x(-[a-z0-9]{1,8})+/;
				var grandfathered = new RegExp(
						"en-gb-oed|(i-(ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu))|" +
						"sgn-((be-(fr|nl))|(ch-de))");
				if (privateuse.test(identifier) || grandfathered.test(identifier)) {
					return true; // Boolean
				}

				/**
				 * Utility function to determine whether the given element is a unique variant
				 * within the context of a BCP 47 compliant language tag.
				 * 
				 * @param {String} element The element tag
				 * @returns {Boolean} Returns true if the given element is a unique variant.
				 * @private
				 */
				function _isUniqueVariant(element) {
					var firstSingletonPosition = identifier.search(/-[a-z0-9]-/);
					if (firstSingletonPosition > 0) {
						return identifier.indexOf(element) > firstSingletonPosition
							|| identifier.indexOf(element) === identifier.lastIndexOf(element,
							firstSingletonPosition); // Boolean
					}
					return identifier.indexOf(element) === identifier.lastIndexOf(element); // Boolean
				}

				/**
				 * Utility function to determine whether the given element is a unique singleton
				 * within the context of a BCP 47 compliant language tag.
				 * 
				 * @param {String} element The element tag
				 * @returns {Boolean} Returns true if the given element is a unique singleton.
				 * @private
				 */
				function _isUniqueSingleton(element) {
					var firstXPosition = identifier.search(/-x-/);
					if (firstXPosition > 0) {
						return identifier.indexOf(element) === identifier.lastIndexOf(element, firstXPosition);
					}
					return identifier.indexOf(element) === identifier.lastIndexOf(element); // Boolean
				}

				if (langtag.test(identifier)) { // represents a well-formed BCP 47 language tag
					var varianttag = /-[a-z0-9]{5,8}|\d[a-z0-9]{3}/g;
					var variants = varianttag.exec(identifier);
					var singletontag = /-[a-wyz0-9]-/g;
					var singletons = singletontag.exec(identifier);
					var variantsOK = !variants || variants.every(_isUniqueVariant); // has no duplicate variant tags
					var singletonsOK = !singletons || singletons.every(_isUniqueSingleton); // has no duplicate
					// singleton tags
					return variantsOK && singletonsOK;
				}
				return false; // Boolean
			},

			/**
			 * CanonicalizeLanguageTag abstract operation as defined in ECMA-402 Section 6.2.3
			 * 
			 * @param {String} locale The structurally valid language tag to canonicalize
			 * @returns {String} The canonical and case regularized form of the language tag.
			 * @private
			 */
			CanonicalizeLanguageTag : function (locale) {
				var result = locale.toLowerCase();
				var firstSingletonPosition = result.search(/(^|-)[a-z0-9]-/);
				var languageTag = /^([a-z]{2,3}(-[a-z]{3}){0,3}|[a-z]{4,8})(?=(-|$))/;
				var scriptTag = /(?:-)([a-z]{4})(?=(-|$))/;
				var regionTag = /(?:-)([a-z]{2}|\\d{3})(?=(-|$))/g;
				var variantTag = /(?:-)([a-z0-9]{5,8}|\d[a-z0-9]{3})/;
				var extlangTag = /^([a-z]{2,3}(-[a-z]{3}))(?=(-|$))/;
				/* Canonicalize the Language Tag */
				result = result.replace(languageTag, function (m) {
					var lookupAlias = aliases.languageAlias[m];
					if (lookupAlias && lookupAlias._reason !== "macrolanguage") {
						m = lookupAlias._replacement ? lookupAlias._replacement : m;
					}
					return m;
				}); // String
				// Canonicalize the Script Tag
				result = result.replace(scriptTag, function (m) {
					if (firstSingletonPosition === -1 || result.indexOf(m) < firstSingletonPosition) {
						m = m.substring(0, 2).toUpperCase() + m.substring(2);
						var script = m.substring(1);
						var lookupAlias = aliases.scriptAlias[script];
						if (lookupAlias) {
							m = lookupAlias._replacement ? "-" + lookupAlias._replacement : m;
						}
					}
					return m;
				}); // String
				// Canonicalize the Region Tag
				result = result.replace(regionTag, function (m) {
					if (firstSingletonPosition === -1 || result.indexOf(m) < firstSingletonPosition) {
						m = m.toUpperCase();
						var region = m.substring(1);
						var lookupAlias = aliases.territoryAlias[region];
						if (lookupAlias) {
							var repl = lookupAlias._replacement;
							if (repl.indexOf(" ") >= 0) {
								repl = repl.substring(0, repl.indexOf(" "));
							}
							m = repl ? "-" + repl : m;
						}
					}
					return m;
				}); // String
				// Canonicalize the Variant Tag
				result = result.replace(variantTag, function (m) {
					// Variant tags are upper case in CLDR's data.
					var variant = common._toUpperCaseIdentifier(m.substring(1));
					var lookupAlias = aliases.variantAlias[variant];
					if (lookupAlias) {
						var repl = lookupAlias._replacement;
						m = repl ? "-" + common._toLowerCaseIdentifier(repl) : m;
					}
					return m;
				}); // String
				// Canonicalize any whole tag combinations or grandfathered tags
				result = result.replace(result, function (m) {
					var lookupAlias = aliases.languageAlias[m];
					if (lookupAlias && lookupAlias._reason !== "macrolanguage") {
						m = lookupAlias._replacement ? lookupAlias._replacement : m;
					} else if (variantTag.test(m)){						
						var noVariantTag = m.replace(variantTag,"");
						lookupAlias = aliases.languageAlias[noVariantTag];
						if (lookupAlias && lookupAlias._reason !== "macrolanguage") {
							m = lookupAlias._replacement ? lookupAlias._replacement + m.match(variantTag)[0] : m;
						}
					}				
					return m;
				}); // String
				// Remove the prefix if an extlang tag exists
				if (extlangTag.test(result)) {
					result = result.replace(/^[a-z]{2,3}-/, "");
				}
				return result; // String
			},

			/**
			 * DefaultLocale abstract operation as defined in ECMA-402 Section 6.2.4
			 * 
			 * @returns {String} A string value representing the structurally valid (6.2.2)
			 *  and canonicalized (6.2.3) BCP 47 language tag for the host environments current locale.
			 * @private
			 */
			DefaultLocale : function () {
				var result = null;
				var global = (function () {return this; })();
				var navigator = global.navigator;
				if (navigator && navigator.languages) {
					var languageList = navigator.languages.slice(0);
					while (!result && languageList.length > 0) {
						var tag = languageList.shift();
						result = this.BestFitAvailableLocale(this.availableLocalesList, this
								.CanonicalizeLanguageTag(tag));						
					}
				}
				if (!result && navigator && this.isStructurallyValidLanguageTag(navigator.language)) {
					result = this.BestFitAvailableLocale(this.availableLocalesList, this
						.CanonicalizeLanguageTag(navigator.language));
				}
				if (!result && navigator && this.isStructurallyValidLanguageTag(navigator.userLanguage)) {
					result = this.BestFitAvailableLocale(this.availableLocalesList, this
						.CanonicalizeLanguageTag(navigator.userLanguage));
				}
				if (!result) {
					result = "root";
				}
				return result;
			},

			/**
			 * IsWellFormedCurrencyCode abstract operation as defined in ECMA-402 Section 6.3.1
			 * 
			 * @param {String} currency The currency code to check
			 * @returns {Boolean} Returns true if the string is a well formed currency code.
			 * @private
			 */
			IsWellFormedCurrencyCode : function (currency) {
				var wellFormed = /^[A-Za-z]{3}$/;
				return wellFormed.test(currency.toString()); // Boolean
			},

			/**
			 * CanonicalizeLocaleList abstract operation as defined in ECMA-402 Section 9.2.1
			 * 
			 * @param {*} locales The list of locales to canonicalize
			 * @returns {Object} The canonicalized list of locales, as a "List" object.
			 * @private
			 */
			CanonicalizeLocaleList : function (locales) {
				if (locales === undefined) {
					return new List();
				}
				if (locales === null) {
					throw new TypeError("Locale list can not be null");
				}
				var seen = new List();
				if (typeof locales === "string") {
					locales = new Array(locales);
				}
				var O = Object(locales);
				var lenValue = O.length;
				var len = lenValue >>> 0; // Convert to unsigned 32-bit integer
				for (var k = 0; k < len ; k++) {
					var Pk = k.toString();
					var kPresent = Pk in O;
					if (kPresent) {
						var kValue = O[Pk];
						if (typeof kValue !== "string" && typeof kValue !== "object") {
							throw new TypeError(kValue + " must be a string or an object.");
						}
						var tag = kValue.toString();
						if (!this.isStructurallyValidLanguageTag(tag)) {
							throw new RangeError(tag + " is not a structurally valid language tag.");
						}
						tag = this.CanonicalizeLanguageTag(tag);
						if (seen.indexOf(tag) < 0) {
							seen.push(tag);
						}
					}
				}
				return seen;
			},

			/**
			 * BestAvailableLocale abstract operation as defined in ECMA-402 Section 9.2.2
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {String} locale The locale identifier to check
			 * @returns {String} The best available locale, using the fallback mechanism of RFC 4647, section 3.4.
			 * @private
			 */
			BestAvailableLocale : function (availableLocales, locale) {
				var candidate = locale;
				while (true) {
					if (availableLocales.indexOf(candidate) >= 0) {
						return candidate;
					}
					var pos = candidate.lastIndexOf("-");
					if (pos < 0) {
						return undefined;
					}
					if (pos >= 2 && candidate.charAt(pos - 2) === "-") {
						pos -= 2;
					}
					candidate = candidate.substring(0, pos);
				}
			},

			/**
			 * LookupMatcher abstract operation as defined in ECMA-402 Section 9.2.3
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @returns {String} The best available locale identifier to meet the request
			 * @private
			 */
			LookupMatcher : function (availableLocales, requestedLocales) {
				var i = 0;
				var len = requestedLocales.length;
				var availableLocale = null;
				var locale = null;
				var noExtensionsLocale = null;
				while (i < len && availableLocale === null) {
					locale = requestedLocales[i];
					noExtensionsLocale = locale.replace(this.unicodeLocaleExtensions, "");
					availableLocale = this.BestAvailableLocale(availableLocales, noExtensionsLocale);
					i++;
				}
				var result = new Record();
				if (availableLocale) {
					result.set("locale", availableLocale);
					if (locale !== noExtensionsLocale) {
						result.set("extension", locale.match(this.unicodeLocaleExtensions)[0]);
						result.set("extensionIndex", locale.search(this.unicodeLocaleExtensions));
					}
				} else {
					result.set("locale", this.DefaultLocale());
				}

				return result;
			},

			/**
			 * BestFitAvailableLocale abstract operation.
			 * 
			 * Algorithm is similar to BestAvailableLocale, as in Section 9.2.2
			 * except that the following additional operations are performed:
			 * 1). CLDR macrolanguage replacements are done ( i.e. "cmn" becomes "zh" )
			 * 2). Known locale aliases, such as zh-TW = zh-Hant-TW, are resolved,
			 * 3). Explicit parent locales from CLDR's supplemental data are also considered.
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {String} locale The locale identifier to check
			 * @returns {String} The best fit available locale, using CLDR's locale fallback mechanism.
			 * @private
			 */

			BestFitAvailableLocale : function (availableLocales, locale) {
				var candidate = locale;
				while (true) {
					var langtag = candidate.substring(0, candidate.indexOf("-"));
					var lookupAlias = aliases.languageAlias[langtag];
					if (lookupAlias && lookupAlias._reason === "macrolanguage") {
						candidate = candidate.replace(langtag, lookupAlias._replacement);
					}
					lookupAlias = aliases.languageAlias[candidate];
					if (lookupAlias) {
						candidate = lookupAlias._replacement;
					}
					if (availableLocales.indexOf(candidate) >= 0) {
						return candidate;
					}
					var parentLocale = parentLocales[candidate];
					if (parentLocale) {
						candidate = parentLocale;
					} else {
						var pos = candidate.lastIndexOf("-");
						if (pos < 0) {
							return undefined;
						}
						if (pos >= 2 && candidate.charAt(pos - 2) === "-") {
							pos -= 2;
						}
						candidate = candidate.substring(0, pos);
					}
				}
			},

			/**
			 * BestFitMatcher abstract operation as defined in ECMA-402 Section 9.2.4
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @returns {String} The best available locale identifier to meet the request
			 * @private
			 */
			BestFitMatcher : function (availableLocales, requestedLocales) {
				var i = 0;
				var len = requestedLocales.length;
				var availableLocale = null;
				var locale = null;
				var noExtensionsLocale = null;
				while (i < len && availableLocale === null) {
					locale = requestedLocales[i];
					noExtensionsLocale = locale.replace(this.unicodeLocaleExtensions, "");
					availableLocale = this.BestFitAvailableLocale(availableLocales, noExtensionsLocale);
					i++;
				}
				var result = new Record();
				if (availableLocale) {
					result.set("locale", availableLocale);
					if (locale !== noExtensionsLocale) {
						result.set("extension", locale.match(this.unicodeLocaleExtensions)[0]);
						result.set("extensionIndex", locale.search(this.unicodeLocaleExtensions));
					}
				} else {
					result.set("locale", this.DefaultLocale());
				}
				return result;
			},

			/**
			 * ResolveLocale abstract operation as defined in ECMA-402 Section 9.2.5
			 * 
			 * Compares a BCP 47 language priority list requestedLocales against the locales in availableLocales
			 * and determines the best available language to meet the request.
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @param {Record} options Locale matching options (for example, "lookup" vs. "best fit" algorithm)
			 * @param {String[]} relevantExtensionKeys Array of relevant -u extension keys for the match
			 * @param {Object} localeData Hash table containing the preloaded locale data.
			 * @returns {Record} The locale information regarding best available locale that meets the request
			 * @private
			 */
			/* jshint maxcomplexity: 14 */
			ResolveLocale : function (availableLocales, requestedLocales, options, relevantExtensionKeys,
									  localeData) {
				var matcher = options.localeMatcher;
				var r = matcher === "lookup" ? this.LookupMatcher(availableLocales, requestedLocales) : this
					.BestFitMatcher(availableLocales, requestedLocales);
				var foundLocale = r.locale;
				var extension = "";
				var extensionSubtags = [];
				var extensionSubtagsLength = 0;
				var extensionIndex = 0;
				if (r.extension !== undefined) {
					extension = r.extension;
					extensionIndex = r.extensionIndex;
					extensionSubtags = extension.split("-");
					extensionSubtagsLength = extensionSubtags.length;
				}
				var result = new Record();
				result.set("dataLocale", foundLocale);
				var supportedExtension = "-u";
				var i = 0;
				var len = relevantExtensionKeys.length;
				while (i < len) {
					var key = relevantExtensionKeys[String(i)];
					var foundLocaleData = localeData[foundLocale];
					var keyLocaleData = foundLocaleData[key];
					var value = keyLocaleData["0"];
					var supportedExtensionAddition = "";
					if (typeof extensionSubtags !== "undefined") {
						var keyPos = extensionSubtags.indexOf(key);
						var valuePos;
						if (keyPos !== -1) {
							if (keyPos + 1 < extensionSubtagsLength
								&& extensionSubtags[String(keyPos + 1)].length > 2) {
								var requestedValue = extensionSubtags[String(keyPos + 1)];
								// fix for islamic-civil, islamic-umalqura & islamic-tbla calendars
								if (requestedValue === "islamic" && extensionSubtags[String(keyPos + 2)]) {
									requestedValue += "-" + extensionSubtags[String(keyPos + 2)];
								}
								valuePos = keyLocaleData.indexOf(requestedValue);
								if (valuePos !== -1) {
									value = requestedValue;
									supportedExtensionAddition = "-" + key + "-" + value;
								}
							} else {
								valuePos = keyLocaleData.indexOf("true");
								if (valuePos !== -1) {
									value = "true";
								}
							}
						}
					}
					var optionsValue = options[key];
					if (optionsValue !== undefined) {
						if (keyLocaleData.indexOf(optionsValue) !== -1) {
							if (optionsValue !== value) {
								value = optionsValue;
								supportedExtensionAddition = "";
							}
						}
					}
					result.set(key, value);
					supportedExtension += supportedExtensionAddition;
					i++;
				}
				if (supportedExtension.length > 2) {
					var preExtension = foundLocale.substring(0, extensionIndex);
					var postExtension = foundLocale.substring(extensionIndex);
					foundLocale = preExtension + supportedExtension + postExtension;
				}
				result.set("locale", foundLocale);
				return result;
			},
			/* jshint maxcomplexity: 10 */

			/**
			 * LookupSupportedLocales abstract operation as defined in ECMA-402 Section 9.2.6
			 * 
			 * Returns the subset of the provided BCP 47 language priority list requestedLocales for which
			 * availableLocales has a matching locale when using the BCP 47 lookup algorithm.
			 * Locales appear in the same order in the returned list as in requestedLocales.
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @returns {String[]} An array containing a list of matching locales
			 * @private
			 */
			LookupSupportedLocales : function (availableLocales, requestedLocales) {
				var len = requestedLocales.length;
				var subset = new List();
				var k = 0;
				while (k < len) {
					var locale = requestedLocales[k];
					var noExtensionsLocale = locale.replace(this.unicodeLocaleExtensions, "");
					var availableLocale = this.BestAvailableLocale(availableLocales, noExtensionsLocale);
					if (availableLocale !== undefined) {
						subset.push(locale);
					}
					k++;
				}
				var subsetArray = subset.toArray();
				return subsetArray;
			},

			/**
			 * BestFitSupportedLocales abstract operation as defined in ECMA-402 Section 9.2.7
			 * 
			 * Returns the subset of the provided BCP 47 language priority list requestedLocales for which
			 * availableLocales has a matching locale when using the best fit matcher algorithm.
			 * Locales appear in the same order in the returned list as in requestedLocales.
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @returns {String[]} An array containing a list of matching locales
			 * @private
			 */
			BestFitSupportedLocales : function (availableLocales, requestedLocales) {
				var len = requestedLocales.length;
				var subset = new List();
				var k = 0;
				while (k < len) {
					var locale = requestedLocales[k];
					var noExtensionsLocale = locale.replace(this.unicodeLocaleExtensions, "");
					var availableLocale = this.BestFitAvailableLocale(availableLocales, noExtensionsLocale);
					if (availableLocale !== undefined) {
						subset.push(locale);
					}
					k++;
				}
				var subsetArray = subset.toArray();
				return subsetArray;
			},

			/**
			 * SupportedLocales abstract operation as defined in ECMA-402 Section 9.2.8
			 * 
			 * Returns the subset of the provided BCP 47 language priority list requestedLocales for which
			 * availableLocales has a matching locale. Two algorithms are available to match the locales:
			 * the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent
			 * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.
			 * 
			 * @param {List} availableLocales The canonicalized list of available locales
			 * @param {List} requestedLocales The canonicalized list of requested locales
			 * @param {Object} options Specifies which lookup algorithm to use
			 * @returns {String[]} An array containing a list of matching locales
			 * @private
			 */
			SupportedLocales : function (availableLocales, requestedLocales, options) {
				var matcher;
				var subset;
				if (options !== undefined) {
					options = Object(options);
					matcher = options.localeMatcher;
					if (matcher !== undefined) {
						matcher = String(matcher);
						if (matcher !== "lookup" && matcher !== "best fit") {
							throw new RangeError("Matching algorithm must be 'lookup' or 'best fit'.");
						}
					}
				}
				if (matcher === undefined || matcher === "best fit") {
					subset = this.BestFitSupportedLocales(availableLocales, requestedLocales);
				} else {
					subset = this.LookupSupportedLocales(availableLocales, requestedLocales);
				}
				for (var P in Object.getOwnPropertyNames(subset)) {
					var desc = Object.getOwnPropertyDescriptor(subset, P);
					if (desc !== undefined) {
						desc.writable = false;
						desc.configurable = false;
						Object.defineProperty(subset, P, desc);
					}
				}
				Object.defineProperty(subset, "length", {
					writable : false,
					configurable : false
				});
				return subset;
			},

			/**
			 * GetOption abstract operation as defined in ECMA-402 Section 9.2.9
			 * 
			 * Extracts the value of the named property from the provided options object,
			 * converts it to the required type, checks whether it is one of a List of allowed values,
			 * and fills in a fallback value if necessary.
			 * 
			 * @param {Object} options The object containing the options to search
			 * @param {String} property The property to retrieve
			 * @param {String} type The type of the resulting option value
			 * @param {Array} values The list of allowed values
			 * @param {*} fallback The fallback value
			 * @returns {*} The resulting value as described above.
			 * @private
			 */
			GetOption : function (options, property, type, values, fallback) {
				var value = options[property];
				if (value !== undefined) {
					if (type === "boolean") {
						value = Boolean(value);
					}
					if (type === "string") {
						value = String(value);
					}
					if (values !== undefined) {
						for (var v in values) {
							if (values[v] === value) {
								return value;
							}
						}
						throw new RangeError("The specified value " + value + " for property " + property
							+ " is invalid.");
					}
					return value;
				}
				return fallback;
			},

			/**
			 * GetNumberOption abstract operation as defined in ECMA-402 Section 9.2.10
			 * 
			 * Extracts the value of the named property from the provided options object,
			 * converts it to a Number value, checks whether it is in the allowed range,
			 * and fills in a fallback value if necessary.
			 * 
			 * @param {Object} options The object containing the options to search
			 * @param {String} property The property to retrieve
			 * @param {Number} minimum The minimum numeric value for this option
			 * @param {Number} maximum The maximum numeric value for this option
			 * @param {*} fallback The fallback value
			 * @returns {Number} The resulting value as described above.
			 * @private
			 */
			GetNumberOption : function (options, property, minimum, maximum, fallback) {
				var value = options[property];
				if (value !== undefined) {
					value = Number(value);
					if (isNaN(value) || value < minimum || value > maximum) {
						throw new RangeError("The specified number value " + value + " is not in the allowed range");
					}
					return Math.floor(value);
				}
				return fallback;
			}
		};

		common.availableLocalesList = common.CanonicalizeLocaleList(JSON.parse(availableLocalesJson).availableLocales);
		return common;
	});;
define('ecma402/impl/List',[],function () {

	/**
	 * Simple implementation of the List abstract data type from ECMA 402.
	 * 
	 * @constructor
	 * @private
	 */
	var List = function () {
		this.length = 0;
	};

	List.prototype.forEach = function (f) {
		for (var i = 0; i < this.length; i++) {
			f(this[i]);
		}
	};
	
	List.prototype.push = function (item) {
		this[this.length] = item;
		this.length++;
	};

	List.prototype.indexOf = function (item) {
		for (var i = 0; i < this.length; i++) {
			if (this[i] === item) {
				return i;
			}
		}
		return -1;
	};

	List.prototype.toArray = function () {
		var i = 0;
		var result = new Array(this.length);
		while (i < this.length) {
			result[i] = this[i];
			i++;
		}
		return result;
	};

	return List;
});;
define('requirejs-text/text!ecma402/cldr/config/calendarDependencies.json',[],function () { return '{\n  "buddhist": {\n    "calendar": "buddhistCalendar"\n  },\n  "hebrew": {\n    "calendar": "hebrewCalendar"\n  },\n  "islamic": {\n    "calendar": "islamicCalendar"\n  },\n  "islamic-civil": {\n    "calendar": "civilTabularCalendar",\n    "option": "civil"\n   },\n  "islamic-tbla": {\n    "calendar": "civilTabularCalendar",\n    "option": "tbla"\n  },\n  "islamic-umalqura": {\n    "calendar": "umalquraCalendar"\n  },\n  "japanese": {\n    "calendar": "japaneseCalendar"\n  },\n  "roc": {\n    "calendar": "rocCalendar"\n  }\n}\n';});
;
define('ecma402/impl/calendars',[ "./Record",
		"requirejs-text/text!../cldr/config/calendarDependencies.json",
        "../calendars/gregorianCalendar"],
    /**
     * Functions and data related to implementation of calendars.
     * 
     * @private
     */
    function (Record, calendarDependenciesJson, gregorianCalendar) {
	var calendarMap = {
			"gregory" : gregorianCalendar
		};
	var dependencies = JSON.parse(calendarDependenciesJson);
	var calendars = {
		calendarMap : calendarMap,
		dependencies : dependencies,
		/**
		 * 
		 * Converts the given date to an object representing the date/time as represented
		 * in a particular calendar.
		 * 
		 * @param {Date} date The date to convert
		 * @param {String} calendar The BCP 47 tag representing the calendar type
		 * @param {String} timeZone String representing the time zone (UTC or local)
		 * @returns {Ojbect} An object representing the year,month,day,hour,minute,second in the given calendar.
		 * @private
		 */
		toLocalTime : function (date, calendar, timeZone) {
			if (dependencies[calendar] && dependencies[calendar].option) {
				return calendarMap[calendar].toLocalTime(date, timeZone, dependencies[calendar].option);
			}
			return calendarMap[calendar].toLocalTime(date, timeZone);
		},
		/**
		 * 
		 * In the Hebrew calendar, determine which month name string to use based on the year. The Hebrew
		 * calendar has a "leap month", so the set of month names used is variable.
		 * 
		 * @param {Number} year The year number
		 * @param {Number} month The year number
		 * @returns {String} The key for looking up the month name in the CLDR resource file.
		 * @private
		 */
		hebrewMonthResource : function (year, month) {
			var mr;
			if (calendarMap.hebrew.isLeapYear(year)) {
				mr = ["1", "2", "3", "4", "5", "6", "7-yeartype-leap", "8", "9", "10", "11", "12", "13"];
			} else {
				mr = ["1", "2", "3", "4", "5", "7", "8", "9", "10", "11", "12", "13"];
			}
			return mr[month - 1];
		}
	};
	return calendars;
});
;
define('ecma402/impl/Record',[],function () {

	/**
	 * Simple implementation of the Record abstract data type from ECMA 402.
	 * 
	 * @constructor
	 * @private
	 */
	var Record = function () {
		this.length = 0;
	};

	Record.prototype.set = function (field, val) {
		Object.defineProperty(this, field, {
			value : val,
			writable : true,
			enumerable : true,
			configurable : true
		});
	};
	return Record;
});;
define('ecma402/features',["requirejs-dplugins/has"], function (has) {
	has.add("intl-api", function (global) {
		return typeof global.Intl !== "undefined" && global.Intl.NumberFormat && global.Intl.DateTimeFormat;
	});
	return has;
});;
/** @module deliteful/StarRating */
define('deliteful/StarRating',[
	"dcl/dcl",
	"dpointer/events",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/register",
	"delite/FormValueWidget",
	"requirejs-dplugins/i18n!./StarRating/nls/StarRating",
	"delite/theme!./StarRating/themes/{{theme}}/StarRating.css"
], function (dcl, pointer, $,
			register, FormValueWidget, messages) {

	/**
	 * A widget that displays a rating, usually with stars, and that allows setting a different rating value
	 * by touching the stars.
	 * Its custom element tag is `d-star-rating`.
	 * 
	 * @class module:deliteful/StarRating
	 * @augments module:delite/FormValueWidget
	 */
	return register("d-star-rating", [HTMLElement, FormValueWidget], /** @lends module:deliteful/StarRating# */ {
		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-star-rating"
		 */
		baseClass: "d-star-rating",

		/**
		 * The maximum rating, that is also the number of stars to show.
		 * @member {number}
		 * @default 5
		 */
		max: 5,

		/**
		 * The current value of the Rating.
		 * @member {number}
		 * @default 0
		 */
		value: 0,

		/**
		 * Indicates whether the user is allowed to edit half values (0.5, 1.5, ...) or not.
		 * Ignored if readOnly is set to false.
		 * @member {boolean}
		 * @default false
		 */
		editHalfValues: false,

		/**
		 * Indicates whether the user is allowed to set the value to zero or not.
		 * @member {boolean}
		 * @default true
		 */
		allowZero: true,

		/* internal properties */

		/*=====
		_hoveredValue: null,
		_startHandles: null,
		_keyDownHandle: null,
		=====*/
		_hovering: false,
		_otherEventsHandles: [],

		render: function () {
			this.focusNode = this.ownerDocument.createElement("div");
			this.appendChild(this.focusNode);
			pointer.setTouchAction(this, "none");
			// init WAI-ARIA attributes
			this.focusNode.setAttribute("role", "slider");
			this.focusNode.setAttribute("aria-valuemin", 0);
			this.valueNode.style.display = "none";
			if (!this.valueNode.parentNode) {
				this.appendChild(this.valueNode);
			}
		},

		/* jshint maxcomplexity: 13 */
		refreshRendering: function (props) {
			if ("disabled" in props) {
				$(this).toggleClass(this.baseClass + "-disabled", this.disabled);
			}
			if ("max" in props) {
				this.focusNode.setAttribute("aria-valuemax", this.max);
			}
			if ("max" in props || "value" in props) {
				this._refreshStarsRendering();
			}
			if ("value" in props) {
				this.focusNode.setAttribute("aria-valuenow", this.value);
				this.focusNode.setAttribute("aria-valuetext",
						messages["aria-valuetext"].replace("${value}", this.value));
				this.valueNode.value = this.value;
			}
			if ("readOnly" in props || "disabled" in props) {
				this._refreshEditionEventHandlers();
			}
			if ("readOnly" in props || "disabled" in props || "allowZero" in props) {
				this._updateZeroArea();
			}
		},
		/* jshint maxcomplexity: 10 */

		_refreshStarsRendering: function () {
			var createChildren = this.focusNode.children.length - 1 !== 2 * this.max;
			if (createChildren) {
				this.focusNode.innerHTML = "";
			}
			this._updateStars(this.value, createChildren);
		},

		_refreshEditionEventHandlers: function () {
			var passive = this.disabled || this.readOnly;
			if (!passive && !this._keyDownHandle) {
				this._keyDownHandle = this.on("keydown", this._keyDownHandler.bind(this));
			} else if (passive && this._keyDownHandle) {
				this._keyDownHandle.remove();
				this._keyDownHandle = null;
			}
			if (!passive && !this._startHandles) {
				this._startHandles = [this.on("pointerover", this._pointerOverHandler.bind(this)),
									  this.on("pointerdown", this._wireHandlers.bind(this))];
			} else if (passive && this._startHandles) {
				while (this._startHandles.length) {
					this._startHandles.pop().remove();
				}
				this._startHandles = null;
			}
		},

		_removeEventsHandlers: function () {
			while (this._otherEventsHandles.length) {
				this._otherEventsHandles.pop().remove();
			}
		},

		_wireHandlers: function () {
			if (!this._otherEventsHandles.length) {
				this._otherEventsHandles.push(this.on("pointerup", this._pointerUpHandler.bind(this)));
				this._otherEventsHandles.push(this.on("pointerleave", this._pointerLeaveHandler.bind(this)));
				this._otherEventsHandles.push(this.on("pointercancel", this._pointerLeaveHandler.bind(this)));
			}
		},

		_pointerOverHandler: function (/*Event*/ event) {
			this._wireHandlers();
			if (!this._hovering && event.pointerType === "mouse") {
				this._hovering = true;
				$(this).addClass(this.baseClass + "-hovered");
			}
			var newValue = event.target.value;
			if (newValue !== undefined) {
				if (this._hovering) {
					if (newValue !== this._hoveredValue) {
						$(this).addClass(this.baseClass + "-hovered");
						this._updateStars(newValue, false);
						this._hoveredValue = newValue;
					}
				} else {
					// Set the previous value here, as this handler is called before _onFocus
					this._previousOnChangeValue = this.value;
					this.handleOnChange(newValue);
				}
			}
		},

		_pointerUpHandler: function (/*Event*/ event) {
			var value = event.target.value;
			if (value !== undefined) {
				this.handleOnChange(value);
			}
			if (!this._hovering) {
				this._removeEventsHandlers();
			} else {
				$(this).removeClass(this.baseClass + "-hovered");
			}
		},

		_pointerLeaveHandler: function () {
			if (this._hovering) {
				this._hovering = false;
				this._hoveredValue = null;
				$(this).removeClass(this.baseClass + "-hovered");
				this._updateStars(this.value, false);
			}
			this._removeEventsHandlers();
		},

		_keyDownHandler: function (/*Event*/ event) {
			var incrementArrow = this.effectiveDir === "ltr" ? "ArrowRight" : "ArrowLeft",
				decrementArrow = this.effectiveDir === "ltr" ? "ArrowLeft" : "ArrowRight";

			switch (event.key) {
			case incrementArrow:
			case "ArrowUp":
			case "Add":
				event.preventDefault();
				this._incrementValue();
				break;
			case decrementArrow:
			case "ArrowDown":
			case "Subtract":
				event.preventDefault();
				this._decrementValue();
				break;
			}
		},

		_incrementValue: function () {
			if (this.value < this.max) {
				this.value = this.value + (this.editHalfValues ? 0.5 : 1);
			}
		},

		_decrementValue: function () {
			if (this.value > (this.allowZero ? 0 : (this.editHalfValues ? 0.5 : 1))) {
				this.value = this.value - (this.editHalfValues ? 0.5 : 1);
			}
		},

		_updateStars: function (/*Number*/value, /*Boolean*/create) {
			var stars = this.focusNode.querySelectorAll("div");
			if (create) {
				this._zeroSettingArea = this.ownerDocument.createElement("div");
				this._zeroSettingArea.className = this.baseClass + "-zero";
				this._zeroSettingArea.value = 0;
				this.focusNode.appendChild(this._zeroSettingArea);
				this._updateZeroArea();
			}
			for (var i = 0; i < 2 * this.max; i++) {
				var starClass = this.baseClass + (i % 2 ? "-end " : "-start ");
				if ((i + 1) * 0.5 <= value) {
					starClass += this.baseClass + "-full";
				} else {
					starClass += this.baseClass + "-empty";
				}
				if (create) {
					var parent = this.ownerDocument.createElement("div");
					parent.value = this.editHalfValues ? (i + 1) / 2 : Math.ceil((i + 1) / 2);
					this.focusNode.appendChild(parent);
				} else {
					parent = stars[i + 1];
				}
				parent.className = this.baseClass + "-star-icon " + starClass;
			}
		},

		_updateZeroArea: function () {
			if (this.readOnly || !this.allowZero) {
				$(this._zeroSettingArea).addClass("d-hidden");
				delete this.focusNode.value;
			} else {
				$(this._zeroSettingArea).removeClass("d-hidden");
				// _zeroSettingArea might not fill the whole widget height
				// so pointer events can land in the underlying focus node
				this.focusNode.value = 0;
			}
		}
	});
});
;
/** @module delite/FormValueWidget */
define('delite/FormValueWidget',[
	"dcl/dcl",
	"./FormWidget",
	"./activationTracker"
], function (dcl, FormWidget) {

	/**
	 * Returns a method to set a new value and fire an event (change or input) if the value changed since the last
	 * call.  Widget should use `handleOnChange()` or `handleOnInput()`.
	 * @param {string} eventType - The event type. Can be "change" or "input".
	 * @param {string} prevValueProp - The name of the property to hold the previous value.
	 * @param {string} deferHandleProp - The name of the property to hold the defer method that fire the event.
	 * @returns {Function}
	 * @private
	 */
	function genHandler(eventType, prevValueProp, deferHandleProp) {
		// Set value and fire an input event if the value changed since the last call.
		// @param {*} newValue - The new value.
		return function (newValue) {
			this.value = newValue;

			// defer allows debounce, hidden value processing to run, and
			// also the onChange handler can safely adjust focus, etc.
			if (this[deferHandleProp]) {
				this[deferHandleProp].remove();
			}
			this[deferHandleProp] = this.defer(function () {
				delete this[deferHandleProp];
				if (typeof newValue !== typeof this[prevValueProp] ||
					this.compare(newValue, this[prevValueProp]) !== 0) { // ignore if value [eventually] set to orig val
					this[prevValueProp] = newValue;
					this.deliver();			// make sure rendering is in sync when event handlers are called
					this.emit(eventType);
				}
			});
		};
	}

	/**
	 * Base class intended for form widgets that have end user changeable values, i.e.
	 * widgets where the user can interactively change the value property by using the mouse, keyboard, touch, etc.
	 *
	 * FormValueWidget extends FormWidget to:
	 *
	 * 1. Provide helper functions to emit `change` and `input` events when the widget's value is interactively changed
	 *    by the end user.  Subclasses of FormValueWidget should call `handleOnChange()` and
	 *    `handleOnInput()` to fire `change` and `input` events as the value changes.  See
	 *    https://html.spec.whatwg.org/multipage/forms.html#common-input-element-events for details.
	 * 2. Provide handling for the `readOnly` property.
	 *
	 * @mixin module:delite/FormValueWidget
	 * @augments module:delite/FormWidget
	 */
	return dcl(FormWidget, /** @lends module:delite/FormValueWidget# */{
		/**
		 * If true, this widget won't respond to user input.  Similar to `disabled` except
		 * `readOnly` form values are submitted.  FormValueWidget automatically updates
		 * `focusNode`'s `readOnly` property to match the widget's `readOnly` property.
		 * @member {boolean}
		 * @default false
		 */
		readOnly: false,

		refreshRendering: function (oldValues) {
			if ("tabStops" in oldValues || "readOnly" in oldValues) {
				this.forEachFocusNode(function (node) {
					node.readOnly = this.readOnly;
				});
			}
		},

		/**
		 * Compare two values (of this widget).
		 * @param {*} val1
		 * @param {*} val2
		 * @returns {number}
		 * @protected
		 */
		compare: function (val1, val2) {
			if (typeof val1 === "number" && typeof val2 === "number") {
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			} else if (val1 > val2) {
				return 1;
			} else if (val1 < val2) {
				return -1;
			} else {
				return 0;
			}
		},

		createdCallback: function () {
			this.on("delite-activated", function () {
				// Called when user may be about to start input.
				// Saves the widget's current value, which is the most recent of:
				//
				//	1. the original value set on widget construction
				//	2. the value the user set when he previously used the widget
				//	3. the value the application set programatically
				//
				// This is all to avoid firing unnecessary change/input events in the corner case where the
				// user just selects and releases the Slider handle for example.
				this._previousOnChangeValue = this.value;
				this._previousOnInputValue = this.value;
			});
		},

		/**
		 * Sets value and fires a "change" event if the value changed since the last call.
		 *
		 * This method should be called when the value is committed,
		 * if that makes sense for the control, or else when the control loses focus.
		 * For example, it should be called when the user releases a slider's handle after dragging it,
		 * or when the user blurs a textbox.
		 * See https://html.spec.whatwg.org/multipage/forms.html#common-input-element-events for details.
		 *
		 * @param {*} newValue - The new value.
		 * @function
		 * @protected
		 */
		handleOnChange: genHandler("change", "_previousOnChangeValue", "_onChangeHandle"),

		/**
		 * Sets value and fires an "input" event if the value changed since the last call.
		 *
		 * This method should be called whenever the value is changed interactively by the end user.
		 * For example, it should be called repeatedly as the user drags the handle of a slider,
		 * or on every keystroke for a textbox.
		 * See https://html.spec.whatwg.org/multipage/forms.html#common-input-element-events for details.
		 *
		 * @param {*} newValue - The new value.
		 * @function
		 * @protected
		 */
		handleOnInput: genHandler("input", "_previousOnInputValue", "_onInputHandle"),

		afterFormResetCallback: function () {
			console.log(this.id, "FormValueWidget#afterFormResetCallback");
			if (this.value !== this.valueNode.value) {
				this.value = this.valueNode.value;
			}
		}
	});
});
;
/**
 * Tracks which nodes are currently "active".
 * A node is considered active if it or a descendant node has focus,
 * or if a non-focusable descendant was the most recent node
 * to get a touchstart/mousedown/pointerdown event.
 *
 * Emits non-bubbling `delite-activated` and `delite-deactivated` events on nodes
 * as they become active, or stop being active, as defined above.
 *
 * Call `activationTracker.on("active-stack", callback)` to track the stack of currently active nodes.
 *
 * Call `activationTracker.on("deactivated", func)` or `activationTracker.on("activated", ...)` to monitor when
 * when nodes become active/inactive.
 *
 * ActivationTracker also provides infrastructure for opening/closing popups merely by hovering/unhovering
 * a button.  Emits `delite-hover-activated` event on nodes that are hovered for `hoverDelay`
 * milliseconds, and emits `delite-hover-deactivated` event after a node
 * and its descendants (ex: DropDownButton's descendant is a Tooltip)
 * have been unhovered for `hoverDelay` milliseconds.  If the user unhovers a node and then re-hovers within
 * `hoverDelay` milliseconds, there's no `delite-hover-deactivated` event.
 *
 * TO IMPLEMENT: Generally, there is a delay between hovering a node and the "delite-hover-activated" event, and
 * if the user hovers a node and then unhovers within the delay, there's no "delite-hover-activated"
 * event.  However, clicking a node sends the "delite-hover-activated" event to it (and its ancestors)
 * immediately.
 *
 * TO IMPLEMENT: Make clicking a blank area of the screen cause immediate delite-hover-deactivated events
 * for nodes with running timers.  Likewise for keyboard click.
 *
 * TO IMPLEMENT: Similarly, waive the delay if there is already a popup open and then the user hovers
 * another button that shows a popup on hover.  To achieve this, all nodes that show a popup
 * on the "delite-hover-activated" event must be marked with the attribute "hover-shows-popup".
 * TODO: How to tell if another popup is opened?  It might have been opened by clicking rather than
 * by hover.  Or do we care about that case?
 *
 * TO IMPLEMENT: Remember whether popup was opened due to a hover event or a click event.  If it was opened
 * due to a click event then it shouldn't close until another click.
 *
 * @module delite/activationTracker
 * */
define('delite/activationTracker',[
	"dcl/advise",
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",	// hasClass()
	"decor/Evented",
	"./on",
	"dpointer/events",		// so can just monitor for "pointerdown"
	"requirejs-domready/domReady!"
], function (advise, dcl, $, Evented, on) {

	// Time of the last touch/mouse and focusin events
	var lastPointerDownTime;
	var lastFocusinTime;

	// Time of last touchend event.  Tells us if the mouseover event is real or emulated.
	var lastTouchendTime;

	// Last node that got pointerdown or focusin event, and the time it happened.
	var lastPointerDownOrFocusInNode;
	var lastPointerDownOrFocusInTime;

	var ActivationTracker = dcl(Evented, /** @lends module:delite/activationTracker */ {
		/**
		 * Amount of time in milliseconds after a node is hovered to send the delite-hover-activated event,
		 * and likewise the amount of time after a node is unhovered before sending the
		 * delite-hover-deactivated event.
		 */
		hoverDelay: 500,

		/**
		 * List of currently active nodes (focused node and its ancestors).
		 * @property {Element[]} activeStack
		 */
		activeStack: [],

		/**
		 * Currently hovered nodes and its ancestors.
		 * @property {Element[]} hoverStack
		 */
		hoverStack: [],

		/**
		 * Registers listeners on the specified window to detect when the user has
		 * touched / mouse-downed / focused somewhere.  This is called automatically.
		 *
		 * @param {Window} [targetWindow]
		 * @returns {Object} Handle with `remove()` method to deregister.
		 * @private
		 */
		registerWin: function (targetWindow) {
			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				doc = targetWindow.document,
				body = doc && doc.body;

			function pointerDownHandler(evt) {
				// workaround weird IE bug where the click is on an orphaned node
				// (first time clicking a Select/DropDownButton inside a TooltipDialog).
				// actually, strangely this is happening on latest chrome too.
				if (evt && evt.target && evt.target.parentNode == null) {
					return;
				}

				lastPointerDownTime = (new Date()).getTime();

				_this._pointerDownOrFocusHandler(evt.target, "mouse");
			}

			function focusHandler(evt) {
				// When you refocus the browser window, IE gives an event with an empty srcElement
				if (!evt.target.tagName) {
					return;
				}

				// IE reports that nodes like <body> have gotten focus, even though they don't have a
				// tabindex setting.  Ignore those events.
				var tag = evt.target.tagName.toLowerCase();
				if (tag === "#document" || tag === "body") {
					return;
				}

				_this._focusHandler(evt.target);
			}

			function blurHandler(evt) {
				_this._blurHandler(evt.target);
			}

			function touchendHandler() {
				lastTouchendTime = (new Date()).getTime();
			}

			function mouseOverHandler(evt) {
				// Ignore emulated mouseover events on iOS and android.  Otherwise, when clicking the
				// [x] to close a TooltipDialog it will immediately reopen (see HasDropDownHover.html).
				if (lastTouchendTime && (new Date()).getTime() < lastTouchendTime + 500) {
					return;
				}

				_this._mouseOverHandler(evt.target);
			}

			if (body) {
				// Listen for touches or mousedowns.
				body.addEventListener("pointerdown", pointerDownHandler, true);
				body.addEventListener("focus", focusHandler, true);	// need true since focus doesn't bubble
				body.addEventListener("blur", blurHandler, true);	// need true since blur doesn't bubble
				body.addEventListener("touchend", touchendHandler, true);
				body.addEventListener("mouseover", mouseOverHandler);

				return {
					remove: function () {
						body.removeEventListener("pointerdown", pointerDownHandler, true);
						body.removeEventListener("focus", focusHandler, true);
						body.removeEventListener("blur", blurHandler, true);
						body.addEventListener("mouseover", mouseOverHandler);
					}
				};
			}
		},

		/**
		 * Called when focus leaves a node.
		 * Usually ignored, _unless_ it *isn't* followed by touching another node,
		 * which indicates that we tabbed off the last field on the page,
		 * in which case every widget is marked inactive.
		 * @param {Element} node
		 * @private
		 */
		_blurHandler: function (node) { // jshint unused: vars
			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if (now < lastFocusinTime + 100) {
				return;
			}

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if (this._clearActiveWidgetsTimer) {
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if (now < lastPointerDownOrFocusInTime + 500) {
				// This blur event is coming late (after the call to _pointerDownOrFocusHandler() rather than before.
				// So let _pointerDownOrFocusHandler() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or pointerdown event,
			// mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(function () {
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}.bind(this), 0);
		},

		/**
		 * Given a node, return the stack of nodes starting with <body> and ending with that node.
		 * @param {Element} node
		 * @param {boolean} byKeyboard - node was navigated to by keyboard rather than mouse
		 * @private
		 */
		_getStack: function (node, byKeyboard) {
			var stack = [];

			try {
				while (node) {
					if (node._popupParent) {
						node = node._popupParent;
					} else if (node.tagName && node.tagName.toLowerCase() === "body") {
						// is this the root of the document or just the root of an iframe?
						if (node === document.body) {
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node = node.ownerDocument.defaultView.frameElement;
					} else {
						// Ignore clicks/hovers on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem).
						if (node.disabled && !byKeyboard) {
							stack = [];
						} else {
							stack.unshift(node);
						}
						node = node.parentNode;
					}
				}
			} catch (e) { /* squelch */
			}

			return stack;
		},

		/**
		 * Callback when node is focused or pointerdown'd.
		 * @param {Element} node - The node.
		 * @param {string} by - "mouse" if the focus/pointerdown was caused by a mouse down event.
		 * @private
		 */
		_pointerDownOrFocusHandler: function (node, by) {
			if (this._clearActiveWidgetsTimer) {
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// Compute stack of active widgets ending at node (ex: ComboButton --> Menu --> MenuItem).
			var newStack = this._getStack(node, by !== "mouse");

			this._setStack(newStack, by);

			// Keep track of most recent focusin or pointerdown event.
			lastPointerDownOrFocusInTime = (new Date()).getTime();
			lastPointerDownOrFocusInNode = node;
		},

		/**
		 * Callback when node is focused.
		 * @param {Element} node
		 * @private
		 */
		_focusHandler: function (node) {
			if (!node) {
				return;
			}

			if (node.nodeType === 9) {
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusinTime = (new Date()).getTime();

			// Also, if clicking a node causes its ancestor to be focused, ignore the focus event.
			// Example in the activationTracker.html functional test on IE, where clicking the spinner buttons
			// focuses the <fieldset> holding the spinner.
			if ((new Date()).getTime() < lastPointerDownTime + 100 &&
					node.contains(lastPointerDownOrFocusInNode.parentNode)) {
				return;
			}

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if (this._clearFocusTimer) {
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._pointerDownOrFocusHandler(node);
		},

		/**
		 * The stack of active nodes has changed.  Send out appropriate events and record new stack.
		 * @param {Element} newStack - Array of nodes, starting from the top (outermost) node.
		 * @param {string} by - "mouse" if the focus/pointerdown was caused by a mouse down event.
		 * @private
		 */
		_setStack: function (newStack, by) {
			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if (newStack[lastNewIdx] === oldStack[lastOldIdx]) {
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.activeStack = newStack;
			this.emit("active-stack", newStack);

			var node, i;

			// for all elements that have become deactivated
			for (i = lastOldIdx; i >= 0 && oldStack[i] !== newStack[i]; i--) {
				node = oldStack[i];
				on.emit(node, "delite-deactivated", {bubbles: false, by: by});
				this.emit("deactivated", node, by);
			}

			// for all elements that have become activated
			for (i++; i <= lastNewIdx; i++) {
				node = newStack[i];
				on.emit(node, "delite-activated", {bubbles: false, by: by});
				this.emit("activated", node, by);
			}
		},

		/**
		 * React to when a new node is hovered.  If a node is hovered long enough it
		 * will get a `delite-hover-activated` event, and if it and its descendants (ex:
		 * DropDownButton's descendant Tooltip) lose hover for long enough, it will get a
		 * `delite-hover-deactivated` event.
		 * @private
		 */
		_mouseOverHandler: function (node) {
			var oldStack = this.hoverStack, lastOldIdx = oldStack.length - 1;
			var newStack = this.hoverStack = this._getStack(node), lastNewIdx = newStack.length - 1;
			var i;

			// For all elements that have left the hover chain, stop timer to
			// send those elements delite-hover-activated event, or start timer to send
			// those elements delite-hover-deactivated event.
			for (i = lastOldIdx; i >= 0 && oldStack[i] !== newStack[i]; i--) {
				this.onNodeLeaveHoverStack(oldStack[i]);
			}

			// For all elements that have become hovered, start timer to send
			// those elements delite-hover-activated event, or clear timer to send
			// delite-hover-deactivated event.
			for (i++; i <= lastNewIdx; i++) {
				this.onNodeEnterHoverStack(newStack[i]);
			}
		},

		/**
		 * Called when a node enters the hover stack.
		 * @param {Element} hoveredNode
		 */
		onNodeEnterHoverStack: function (hoveredNode) {
			if (hoveredNode.hoverDeactivateTimer) {
				// This node previously got a delite-hover-activated event,
				// but didn't yet get a delite-hover-deactivated, so nothing really to do.
				clearTimeout(hoveredNode.hoverDeactivateTimer);
				delete hoveredNode.hoverDeactivateTimer;
			} else {
				// Set timer so that if node remains hovered, we send a delite-hover-activated event.
				hoveredNode.hoverActivateTimer = setTimeout(function () {
					delete hoveredNode.hoverActivateTimer;
					on.emit(hoveredNode, "delite-hover-activated", {bubbles: false});
				}.bind(this), this.hoverDelay);
			}
		},

		/**
		 * Called when a node leaves the hover stack.
		 * @param {Element} unhoveredNode
		 */
		onNodeLeaveHoverStack: function (unhoveredNode) {
			if (unhoveredNode.hoverActivateTimer) {
				// Node was hovered but it hadn't gotten a delite-hover-activated event yet, so nothing to do.
				clearTimeout(unhoveredNode.hoverActivateTimer);
				delete unhoveredNode.hoverActivateTimer;
			} else {
				// Set timer so that if node remains unhovered, we send a delite-hover-deactivated event.
				unhoveredNode.hoverDeactivateTimer = setTimeout(function () {
					delete unhoveredNode.hoverDeactivateTimer;
					unhoveredNode.hoverActivated = false;
					on.emit(unhoveredNode, "delite-hover-deactivated", {bubbles: false});
				}.bind(this), this.hoverDelay);
			}
		}
	});

	// Create singleton for top window
	var singleton = new ActivationTracker();
	singleton.registerWin(window);

	return singleton;
});
;
/** @module delite/FormWidget */
define('delite/FormWidget',[
	"dcl/dcl",
	"./Widget"
], function (dcl, Widget) {

	/**
	 * Base class for widgets that extend `HTMLElement`, but conceptually correspond to form elements.
	 *
	 * Most form widgets should extend FormValueWidget rather than extending FormWidget directly, but
	 * FormWidget should be the base class for form widgets that *don't* have an end user settable value,
	 * for example checkboxes and buttons.  Note that clicking a checkbox changes its state (i.e. the value of
	 * its `checked` property), but does not change its `value` property.
	 *
	 * Also note that both this widget and KeyNav define the `focus()` method, so if your widget extends both classes,
	 * take care that the `focus()` method you want takes precedence in the inheritance hierarchy.
	 *
	 * @mixin module:delite/FormWidget
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** @lends module:delite/FormWidget# */ {
		/**
		 * Name used when submitting form; same as "name" attribute or plain HTML elements.
		 * @member {string}
		 */
		name: "",

		/**
		 * Corresponds to the native HTML `<input>` element's attribute.
		 * @member {string}
		 */
		alt: "",

		/**
		 * Corresponds to the native HTML `<input>` element's attribute.
		 *
		 * For widgets that directly extend FormWidget (ex: checkboxes), the value is set programatically when the
		 * widget is created, and the end user merely changes the widget's state, i.e. the `checked` property.
		 *
		 * For widgets that extend FormValueWidget, the end user can interactively change the `value` property via
		 * mouse, keyboard, touch, etc.
		 *
		 * @member {string}
		 */
		value: "",

		/**
		 * The order in which fields are traversed when user presses the tab key.
		 * @member {number}
		 * @default 0
		 */
		tabIndex: 0,

		/**
		 * Comma separated list of tabbable nodes, i.e. comma separated list of widget properties that reference
		 * the widget DOM nodes that receive focus during tab operations.
		 *
		 * Aria roles are applied to these nodes rather than the widget root node.
		 *
		 * Note that FormWidget requires that all of the tabbable nodes be sub-nodes of the widget, rather than the
		 * root node.  This is because of its processing of `tabIndex`.
		 *
		 * @member {string}
		 * @default "focusNode"
		 */
		tabStops: "focusNode",

		/**
		 * If set to true, the widget will not respond to user input and will not be included in form submission.
		 * FormWidget automatically updates `valueNode`'s and `focusNode`'s `disabled` property to match the widget's
		 * `disabled` property.
		 * @member {boolean}
		 * @default false
		 */
		disabled: false,

		/**
		 * Sets the `required` property of the focus nodes, or their `aria-required` attribute if they do not support
		 * the `required` property.
		 * @member {boolean}
		 * @default false
		 */
		required: false,

		/**
		 * For widgets with a single tab stop, the Element within the widget, often an `<input>`,
		 * that gets the focus.  Widgets with multiple tab stops, such as a range slider, should set `tabStops`
		 * rather than setting `focusNode`.
		 *
		 * @member {HTMLElement} module:delite/FormWidget#focusNode
		 * @protected
		 */

		/**
		 * A form element, typically an `<input>`, embedded within the widget, and likely hidden.
		 * It is used to represent the widget's state/value during form submission.
		 *
		 * Subclasses of FormWidget like checkboxes and radios should update `valueNode`'s `checked` property.
		 *
		 * @member {HTMLElement} module:delite/FormWidget#valueNode
		 * @protected
		 * @default undefined
		 */

		_mapAttributes: dcl.superCall(function (sup) {
			return function () {
				var input = this.querySelector("input");
				if (input) {
					// Get value and name from embedded <input> node.
					if (input.value) {
						this.setAttribute("value", input.value);
					}
					if (input.name) {
						this.setAttribute("name", input.name);
					}
				} else {
					// Create this.valueNode as a convenience, but don't add to the DOM because that breaks widgets like
					// deliteful/Checkbox that unconditionally create their own this.valueNode:
					// You end up with two embedded <input> nodes.
					input = this.ownerDocument.createElement("input");
				}
				this.valueNode = input;
				return sup.call(this);
			};
		}),

		refreshRendering: function (oldValues) {
			/* jshint maxcomplexity:14 */

			// Handle disabled, required and tabIndex, across the tabStops and root node.
			// No special processing is needed for tabStops other than just to refresh disabled, required and tabIndex.

			// If the tab stops have changed then start by removing the tabIndex from all the old tab stops.
			if ("tabStops" in oldValues) {
				oldValues.tabStops.split(/, */).forEach(function (nodeName) {
					var node = this[nodeName];
					node.tabIndex = "-1";				// backup plan in case next line of code ineffective
					node.removeAttribute("tabindex");	// works for <div> etc. but not <input>
				}, this);
			}

			// Set tabIndex etc. for all tabbable nodes.
			// To keep things simple, if anything has changed then reapply all the properties.
			if ("tabStops" in oldValues || "tabIndex" in oldValues || "disabled" in oldValues
				|| "alt" in oldValues || "required" in oldValues || "id" in oldValues) {
				var inputIdUnset = true;
				var inputId;
				if ("id" in oldValues && this.id) {
					inputId = this.id + "-input";
				}

				this.forEachFocusNode(function (node) {
					if (this.disabled) {
						node.tabIndex = "-1";				// backup plan in case next line of code ineffective
						node.removeAttribute("tabindex");	// works for <div> etc. but not <input>
					} else {
						node.tabIndex = this._get("tabIndex");
					}
					node.alt = this.alt;

					// Set the disabled property for native elements like <input>, and also custom elements with a
					// disabled property.  Note that on IE every element has a disabled property, so it's hard to
					// test if it's real or not.
					node.disabled = this.disabled;
					node.required = this.required;

					// Set aria-disabled and required but try to avoid setting it redundantly.
					if (!(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(node.tagName))) {
						node.setAttribute("aria-disabled", "" + this.disabled);
						node.setAttribute("aria-required", "" + this.required);
					}

					// Set the focus node's id.
					if (/^(input|textarea|select|button|keygen)$/i.test(node.tagName) && inputId && inputIdUnset) {
						inputIdUnset = false;
						if (!node.id) {
							node.id = inputId;
						}
					}
				});
			}

			// Set properties on valueNode.
			var valueNode = this.valueNode !== this && this.valueNode;
			if (valueNode) {
				if ("value" in oldValues) {
					valueNode.value = this.value;
				}
				if ("disabled" in oldValues) {
					valueNode.disabled = this.disabled; // prevent submit
				}
				if ("name" in oldValues) {
					valueNode.name = this.name;
				}
				if ("required" in oldValues) {
					valueNode.required = this.required;
				}
			}
		},

		/**
		 * Put focus on this widget.
		 */
		focus: function () {
			var focusNode = this.firstFocusNode();
			if (!this.disabled && focusNode.focus) {
				try {
					focusNode.focus();
				} catch (e) {
					// squelch errors from hidden nodes
				}
			}
		},

		/**
		 * Helper method to get the first focusable node, usually `this.focusNode`.
		 *
		 * @protected
		 */
		firstFocusNode: function () {
			return this[this.tabStops.split(/, */)[0]];
		},

		/**
		 * Helper method to execute callback for each focusable node in the widget.
		 * Typically the callback is just called once, for `this.focusNode`.
		 * @param {Function} callback - The callback function.
		 * @protected
		 */
		forEachFocusNode: function (callback) {
			this.tabStops.split(/, */).map(function (nodeName) {
				var node = this[nodeName];
				if (node !== this) {	// guard against hard to debug infinite recursion
					callback.call(this, node);
				}
			}, this);
		},

		////////////////////////////////////////////////////////////////////////////////////////////
		// Override setAttribute() etc. to put aria-label etc. onto the focus node rather than the root
		// node, so that screen readers work properly.

		setAttribute: dcl.superCall(function (sup) {
			return function (name, value) {
				if (/^aria-/.test(name)) {
					this.forEachFocusNode(function (node) {
						node.setAttribute(name, value);
					});
				} else {
					sup.call(this, name, value);
				}
			};
		}),

		getAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name)) {
					return this.firstFocusNode().getAttribute(name);
				} else {
					return sup.call(this, name);
				}
			};
		}),

		hasAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name)) {
					return this.firstFocusNode().hasAttribute(name);
				} else {
					return sup.call(this, name);
				}
			};
		}),

		removeAttribute: dcl.superCall(function (sup) {
			return function (name) {
				if (/^aria-/.test(name)) {
					this.forEachFocusNode(function (node) {
						node.removeAttribute(name);
					});
				} else {
					sup.call(this, name);
				}
			};
		}),

		postRender: function () {
			// Move all initially specified aria- attributes to focus node(s).
			var attr, idx = 0;
			while ((attr = this.attributes[idx++])) {
				if (/^aria-/.test(attr.name)) {
					this.setAttribute(attr.name, attr.value);

					// force remove from root node not focus nodes
					HTMLElement.prototype.removeAttribute.call(this, attr.name);
				}
			}
		},

		attachedCallback: function () {
			// If the widget is in a form, reset the initial value of the widget when the form is reset.
			for (var form = this.parentNode; form; form = form.parentNode) {
				if (/^form$/i.test(form.tagName)) {
					this.on("reset", function () {
						this.defer(function () {
							this.afterFormResetCallback();
						});
					}.bind(this), form);
					break;
				}
			}
		},

		/**
		 * Callback after `<form>` containing this widget is reset.
		 * By the time this callback executes, `this.valueNode.value` will have already been reset according to
		 * the form's original value.
		 *
		 * @protected
		 */
		afterFormResetCallback: function () {
			if (this.checked !== this.valueNode.checked) {
				this.checked = this.valueNode.checked;
			}
		}
	});
});


;
define('delite/handlebars!xdeliteful/Button/Button.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template attach-point=\"focusNode\">\n\t<span attach-point=\"iconNode\" class=\"d-icon {{this.iconClass ? this.iconClass : 'd-hidden'}}\" aria-hidden=\"true\"> </span><span attach-point=\"labelNode\" d-hidden=\"{{!this.label}}\">{{label}}</span>\n</template>");
});;
/** @module deliteful/Button */
define('xdeliteful/Button',[
	"dcl/dcl",
	"requirejs-dplugins/has",
	"delite/register",
	"delite/Widget",
	"delite/Container",
	"requirejs-dplugins/has!bidi?./Button/bidi/Button",
	"delite/handlebars!./Button/Button.html",
	"delite/theme!./Button/themes/{{theme}}/Button.css"
], function (dcl, has, register, Widget,Container, BidiButton, template) {

	/**
	 * A Non-templated form-aware button widget.
	 * A Button can display a label, an icon, or both. Icon is specified via the iconClass property that
	 * takes the name of the class to apply to the button node to display the icon.
	 * @example
	 * <style>
	 *   .iconForButton {
	 *     background-image: url('images/cut.png');
	 *     width: 16px;
	 *     height: 16px;
	 *   }
	 * </style>
	 * <button is="d-button" iconClass="iconForButton">Click Me</button>
	 * @class module:deliteful/Button
	 * @augments module:delite/Widget
	 */
	var Button = dcl(Container, /** @lends module:deliteful/Button# */ {

		/**
		 * The text to display in the button.
		 * @member {string}
		 * @default ""
		 */
		label: "",

		/**
		 * The name of the CSS class to apply to DOMNode in button to make it display an icon.
		 * @member {string}
		 * @default ""
		 */
		iconClass: "",

		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-button"
		 */
		baseClass: "d-button",

		template: template,

		createdCallback: function () {
			// Get label from innerHTML, and then clear it since we are to put the label in a <span>
			if (!this.label) {
				this.label = this.textContent.trim();
				//this.innerHTML = "";
			}
		},

		computeProperties: function (props) {
			if ("title" in props || "label" in props) {
				this.title = this.title || this.label || "";
			}
		}
	});

	var ButtonElt = register("d-button", has("bidi") ? [HTMLButtonElement, Button, BidiButton] :
		[HTMLButtonElement, Button]);
	ButtonElt.Impl = Button;
	return ButtonElt;
});
;
define('xdeliteful/Button/bidi/Button',["dcl/dcl", "dpointer/events"], function (dcl) {

	// module:
	//		deliteful/Button/bidi/Button

	return dcl(null, {
		// summary:
		//		Support for control over text direction for Button widget,
		//		using Unicode Control Characters to control text direction.
		// description:
		//		Implementation for text direction support for label and tooltip.
		//		This class should not be used directly.
		//		Button widget loads this module when user sets "has: {'bidi': true }" in data-dojo-config.

		refreshRendering: function (oldVals) {
			if ("textDir" in oldVals || "label" in oldVals) {
				this.labelNode.textContent = this.applyTextDirection(this.label);
			}
			if (this.title && "textDir" in oldVals) {
				this.title = this.applyTextDirection(this.title);
			}
		},
		
		postRender: function () {
			this.on("pointerover", this._pointerOverHandler.bind(this));
		},
		
		_pointerOverHandler: function () {
			if (this.title) {
				this.title = this.applyTextDirection(this.title);
			}
		}
	});
});
;
/** @module deliteful/LinearLayout */
define('deliteful/LinearLayout',[
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/register",
	"delite/DisplayContainer",
	"delite/theme!./LinearLayout/themes/{{theme}}/LinearLayout.css"
], function ($, register, DisplayContainer) {
	/**
	 * A layout container based on CSS3 Flexible Box.
	 *
	 * Child elements in a LinearLayout container can be laid out horizontally or vertically.
	 * A child can have a flexible width or height depending on orientation.
	 * To enable flexibility of a child, add the CSS class "fill" on it.
	 * @example
	 * <d-linear-layout>
	 *   <div>...</div>
	 *   <div class="fill">...</div>
	 *   <div>...</div>
	 * </d-linear-layout>
	 * @class module:deliteful/LinearLayout
	 * @augments module:delite/DisplayContainer
	 */
	return register("d-linear-layout", [HTMLElement, DisplayContainer],
		/** @lends module:deliteful/LinearLayout# */{
		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-linear-layout"
		 */
		baseClass: "d-linear-layout",

		/**
		 * True if the container is vertical.
		 * @member {boolean}
		 * @default true
		 */
		vertical: true,

		refreshRendering: function (oldValues) {
			if ("vertical" in oldValues) {
				$(this).toggleClass("-d-linear-layout-v", this.vertical);
				$(this).toggleClass("-d-linear-layout-h", !this.vertical);
			}
		}
	});
});;
/** @module deliteful/SidePane */
define('deliteful/SidePane',[
	"dcl/dcl",
	"dpointer/events",
	"requirejs-dplugins/jquery!attributes/classes",
	"decor/sniff",
	"delite/register",
	"delite/DisplayContainer",
	"requirejs-dplugins/Promise!",
	"delite/theme!./SidePane/themes/{{theme}}/SidePane.css"
],
	function (dcl, pointer, $, has, register, DisplayContainer, Promise) {
		function prefix(v) {
			return "-d-side-pane-" + v;
		}
		function setVisibility(node, val) {
			if (val) {
				node.style.visibility = "visible";
				node.style.display = "block";
			} else {
				node.style.visibility = "hidden";
				node.style.display = "none";
			}
		}
		function getNextSibling(node) {
			do {
				node = node.nextElementSibling;
			} while (node && node.nodeType !== 1);
			return node;
		}

		/**
		 * Dispatched after SidePane is shown.
		 * @example
		 * mySidePane.on("sidepane-after-show", function (evt) {
		 *      firstField.focus();
		 * });
		 * @event module:deliteful/SidePane#sidepane-after-show
		 */

		/**
		 * A widget displayed on the side of the screen.
		 *
		 * It can be displayed on top of the page
		 * (mode=overlay) or can push the content of the page (mode=push or mode=reveal).
		 * SidePane is a widget hidden by default.
		 * This widget must be a sibling of html's body element.
		 * If mode is set to "push" or "reveal", the width of the SidePane can't be changed in the markup
		 * (15em by default).
		 * However it can be changed in SidePane.less (@PANE_WIDTH variable).
		 * In "push" and "reveal" mode, the pushed element is the first sibling of the SidePane which has
		 * of type element (nodeType == 1) and not a SidePane.
		 * @example
		 * <body>
		 *   <d-side-pane>
		 *       SidePane content
		 *   </d-side-pane>
		 *   <div>
		 *       Main application
		 *   </div>
		 * </body>
		 * @class module:deliteful/SidePane
		 * @augments module:delite/DisplayContainer
		 */
		return register("d-side-pane", [HTMLElement, DisplayContainer],
			/** @lends module:deliteful/SidePane#*/ {
			/**
			 * The name of the CSS class of this widget.
			 * @member {string}
			 * @default "d-side-pane"
			 */
			baseClass: "d-side-pane",

			/**
			 * Can be "overlay", "reveal" or "push".
			 * In overlay mode, the pane is shown on top of the page.
			 * In reveal and push modes, The page is moved to make the pane visible. The difference between
			 * these two modes is the animated transition: in reveal mode, the pane does not move, it is
			 * already under the page. In push mode, the pane slide with the page.
			 * @member {string}
			 * @default "push"
			 */
			mode: "push",

			/**
			 * Can be "start" or "end". If set to "start", the panel is displayed on the
			 * left side in LTR mode.
			 * @member {string}
			 * @default "push"
			 */
			position: "start",

			/**
			 * Enable/Disable animations.
			 * @member {boolean}
			 * @default true
			 */
			animate: true,

			/**
			 * Enables the swipe closing of the pane.
			 * @member {boolean}
			 * @default true
			 */
			swipeClosing: true,

			_transitionTiming: {default: 0, chrome: 50, ios: 20, android: 100, ff: 100},
			_timing: 0,
			_visible: false,
			_opening: false,
			_originX: NaN,
			_originY: NaN,

			attachedCallback: function () {
				this.parentNode.style.overflow = "hidden";
			},

			show: dcl.superCall(function (sup) {
				return function () {
					if (arguments.length > 0) {
						return sup.apply(this, arguments).then(function (value) {
							return this._open().then(function () {
								return value;
							});
						}.bind(this));
					} else {
						return this._open();
					}
				};
			}),

			hide: dcl.superCall(function (sup) {
				return function () {
					if (arguments.length > 0) {
						return sup.apply(this, arguments).then(function (value) {
							return this._close().then(function () {
								return value;
							});
						}.bind(this));
					} else {
						return this._close();
					}
				};
			}),
			/**
			 * This method is called to toggle the visibility of the SidePane.
			 * @returns {Promise} A promise that will be resolved when the display & transition effect will have been
			 * performed.
			 */
			toggle: function () {
				return this._visible ? this.hide() : this.show();
			},

			/**
			 * Open the pane.
			 * @private
			 */
			_open: function () {
				var promise;
				var nextElement = getNextSibling(this);
				var animate = this.animate && has("ie") !== 9;
				if (!this._visible) {
					if (animate) {
						$(this).addClass(prefix("animate"));
						if (nextElement) {
							$(nextElement).addClass(prefix("animate"));
						}
					}

					if (this.mode === "reveal") {
						if (nextElement) {
							promise = this._setAfterTransitionHandlers(nextElement);
						}
					} else {
						promise = this._setAfterTransitionHandlers(this);
					}

					setVisibility(this, true);

					if (animate) {
						this.defer(this._openImpl, this._timing);
					} else {
						this._openImpl();
						promise = new Promise(function (resolve) {
							this.defer(resolve, this._timing);
						}.bind(this));
					}
				}
				return (promise || Promise.resolve(true)).then(function () {
					this.emit("sidepane-after-show");
				}.bind(this));
			},

			/**
			 * Close the pane.
			 * @private
			 */
			_close: function () {
				var promise;
				if (this._visible) {
					if (this.mode === "reveal") {
						var nextElement = getNextSibling(this);
						if (nextElement) {
							promise = this._setAfterTransitionHandlers(nextElement);
						}
					} else {
						promise = this._setAfterTransitionHandlers(this);
					}

					if (this.animate && has("ie") !== 9) {
						// This defer should be useless but is needed for Firefox, see #25
						this.defer(function () {this._hideImpl(); }, this._timing);
					} else {
						this._hideImpl();
						setVisibility(this, false);
					}
				}
				return promise || Promise.resolve(true);
			},

			_setAfterTransitionHandlers: function (node) {
				var self = this, holder = { node: node};
				var promise = new Promise(function (resolve) {
					holder.handle =  function () { self._afterTransitionHandle(holder, resolve); };
				});
				node.addEventListener("webkitTransitionEnd", holder.handle);
				node.addEventListener("transitionend", holder.handle); // IE10 + FF
				return promise;
			},

			_afterTransitionHandle: function (holder, resolve) {
				$(this).removeClass(prefix("under"));
				if (!this._visible) {
					setVisibility(this, false);
				}
				holder.node.removeEventListener("webkitTransitionEnd", holder.handle);
				holder.node.removeEventListener("transitionend", holder.handle);
				resolve();
			},

			preRender: function () {
				this._transitionTiming = {default: 0, chrome: 20, ios: 20, android: 100, ff: 100};
				for (var o in this._transitionTiming) {
					if (has(o) && this._timing < this._transitionTiming[o]) {
						this._timing = this._transitionTiming[o];
					}
				}
			},

			postRender: function () {
				pointer.setTouchAction(this, "pan-y");
				this._resetInteractions();
				setVisibility(this, false);
			},

			_refreshMode: function (nextElement) {
				$(this).removeClass([prefix("push"), prefix("overlay"), prefix("reveal")].join(" "))
					.addClass(prefix(this.mode));

				if (nextElement && this._visible) {
					$(nextElement).toggleClass(prefix("translated"), this.mode !== "overlay");
				}

				if (this.mode === "reveal" && !this._visible) {
					// Needed by FF only for the first opening.
					$(this).removeClass(prefix("ontop"))
						.addClass(prefix("under"));
				}
				else if (this.mode === "overlay") {
					$(this).removeClass(prefix("under"))
						.addClass(prefix("ontop"));
				} else {
					$(this).removeClass([prefix("under"), prefix("ontop")].join(" "));
				}
			},

			_refreshPosition: function (nextElement) {
				$(this).removeClass([prefix("start"), prefix("end")].join(" "))
					.addClass(prefix(this.position));
				if (nextElement && this._visible) {
					$(nextElement).removeClass([prefix("start"), prefix("end")].join(" "))
						.addClass(prefix(this.position));
				}
			},

			refreshRendering: function (props) {
				if (!("mode" in props || "position" in props || "animate" in props)) {
					return;
				}
				var nextElement = getNextSibling(this);

				// Always remove animation during a refresh. Avoid to see the pane moving on mode changes.
				// Not very reliable on IE11.
				$(this).removeClass(prefix("animate"));

				if (nextElement) {
					$(nextElement).removeClass(prefix("animate"));
					$(nextElement).toggleClass("d-rtl", this.effectiveDir === "rtl");
				}

				if ("mode" in props) {
					this._refreshMode(nextElement);
				}

				if ("position" in props) {
					this._refreshPosition(nextElement);
				}

				$(this).toggleClass(prefix("hidden"), !this._visible)
					.toggleClass(prefix("visible"), this._visible);

				// Re-enable animation
				if (this.animate) {
					this.defer(function () {
						$(this).addClass(prefix("animate"));
						if (nextElement) {
							$(nextElement).addClass(prefix("animate"));
						}
					}, this._timing);
				}
			},

			_openImpl: function () {
				if (!this._visible) {
					this._visible = true;
					$(this).removeClass(prefix("hidden"))
						.addClass(prefix("visible"));

					if (this.mode === "push" || this.mode === "reveal") {
						var nextElement = getNextSibling(this);
						if (nextElement) {
							$(nextElement)
								.removeClass([prefix("nottranslated"), prefix("start"), prefix("end")].join(" "))
								.addClass([prefix(this.position), prefix("translated")].join(" "));
						}
					}
				}
			},

			_hideImpl: function () {
				if (this._visible) {
					this._visible = false;
					this._opening = false;
					$(this.ownerDocument.body).removeClass(prefix("no-select"));
					$(this).removeClass(prefix("visible"))
						.addClass(prefix("hidden"));
					if (this.mode === "push" || this.mode === "reveal") {
						var nextElement = getNextSibling(this);
						if (nextElement) {
							$(nextElement)
								.removeClass([prefix("translated"), prefix("start"), prefix("end")].join(" "))
								.addClass([prefix(this.position), prefix("nottranslated")].join(" "));
						}
					}
				}
			},

			_isLeft: function () {
				return (this.position === "start" && this.effectiveDir === "ltr") ||
					(this.position === "end" && this.effectiveDir === "rtl");
			},

			_pointerDownHandler: function (event) {
				this._originX = event.pageX;
				this._originY = event.pageY;

				if (this._visible || (this._isLeft() && !this._visible && this._originX <= 10) ||
					(!this._isLeft() && !this._visible && this._originX >= this.ownerDocument.width - 10)) {
					this._opening = !this._visible;
					this._pressHandle.remove();
					this._moveHandle = this.on("pointermove", this._pointerMoveHandler.bind(this));
					this._releaseHandle = this.on("pointerup", this._pointerUpHandler.bind(this));

					$(this.ownerDocument.body).addClass(prefix("no-select"));
				}
			},

			_pointerMoveHandler: function (event) {
				if (!this._opening && Math.abs(event.pageY - this._originY) > 10) {
					this._resetInteractions();
				} else {
					var pos = event.pageX;

					if (this._isLeft()) {
						if (this._visible) {
							if (this._originX < pos) {
								this._originX = pos;
							}

							if ((this.swipeClosing && this._originX - pos) > 10) {
								this._close();
								this._originX = pos;
							}
						}
					} else {
						if (this._visible) {
							if (this._originX > pos) {
								this._originX = pos;
							}
							if ((this.swipeClosing && pos - this._originX) > 10) {
								this._close();
								this._originX = pos;
							}
						}
					}
				}
			},

			_pointerUpHandler: function () {
				this._opening = false;
				$(this.ownerDocument.body).removeClass(prefix("no-select"));
				this._resetInteractions();
			},

			_resetInteractions: function () {
				if (this._releaseHandle) {
					this._releaseHandle.remove();
				}
				if (this._moveHandle) {
					this._moveHandle.remove();
				}
				if (this._pressHandle) {
					this._pressHandle.remove();
				}

				if (this.swipeClosing) {
					this._pressHandle = this.on("pointerdown", this._pointerDownHandler.bind(this));
				}

				this._originX = NaN;
				this._originY = NaN;
			}
		});
	});
;
/** @module deliteful/Panel */
define('deliteful/Panel',["dcl/dcl",
	"delite/register",
	"delite/Widget",
    "delite/theme!./Panel/themes/{{theme}}/Panel.css"
], function (dcl, register, Widget) {

	/**
	 * A container widget used inside an Accordion.
	 *
	 * @class module:deliteful/Panel
	 * @augments module:delite/Widget
	 * @example
	 * <d-panel id="panel" label="Title">
	 *   <div>...</div>
	 *   <div>...</div>
	 * </d-panel>
	 */
	return register("d-panel", [HTMLElement, Widget], /** @lends module:deliteful/Panel# */ {

		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-panel"
		 */
		baseClass: "d-panel",

		/**
		 * The label to be displayed in the panel's header.
		 * @member {string}
		 * @default ""
		 */
		label: "",

		/**
		 * CSS class to apply to the icon node in the header when this panel is open.
		 * @member {string}
		 * @default ""
		 */
		openIconClass: "",

		/**
		 * CSS class to apply to icon node in the header when this panel is closed.
		 * @member {string}
		 * @default ""
		 */
		closedIconClass: ""
	});
});;
/** @module deliteful/ViewStack */
define('deliteful/ViewStack',[
	"dcl/dcl",
	"decor/sniff",
	"requirejs-dplugins/Promise!",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/register",
	"delite/DisplayContainer",
	"delite/theme!./ViewStack/themes/{{theme}}/ViewStack.css",
	"requirejs-dplugins/css!./ViewStack/transitions/slide.css",
	"requirejs-dplugins/css!./ViewStack/transitions/reveal.css"
], function (dcl, has, Promise, $, register, DisplayContainer) {
	function setVisibility(node, val) {
		if (node) {
			if (val) {
				node.style.visibility = "visible";
				node.style.display = "";
			} else {
				node.style.visibility = "hidden";
				node.style.display = "none";
			}
		}
	}
	function setReverse(node) {
		if (node) {
			$(node).addClass("-d-view-stack-reverse");
		}
	}
	function cleanCSS(node) {
		if (node) {
			node.className = node.className.split(/ +/).filter(function (x) {
				return !/^-d-view-stack/.test(x);
			}).join(" ");
		}
	}
	function transitionClass(s) {
		return "-d-view-stack-" + s;
	}

	/**
	 * ViewStack container widget. Display one child at a time.
	 *
	 * The first child is displayed by default.
	 * The methods 'show' is used to change the visible child.
	 *
	 * Styling
	 * The following CSS attributes must not be changed.
	 *  ViewStack node:  position, box-sizing, overflow-x
	 *  ViewStack children:  position, box-sizing, width, height
	 *
	 * @example
	 * <d-view-stack id="vs">
	 *     <div id="childA">...</div>
	 *     <div id="childB">...</div>
	 *     <div id="childC">...</div>
	 * </d-view-stack>
	 * <button onclick="vs.show(childB, {transition: 'reveal', reverse: true})">...</button>
	 * @class module:deliteful/ViewStack
	 * @augments module:delite/DisplayContainer
	 */
	return register("d-view-stack", [HTMLElement, DisplayContainer], /** @lends module:deliteful/ViewStack# */{
		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-view-stack"
		 */
		baseClass: "d-view-stack",

		/**
		 * The transition type used if not specified in the second argument of the show method.
		 * Transitions type are: "none", "slide", "reveal", "flip", "fade".
		 * @member {string}
		 * @default "slide"
		 */
		transition: "slide",

		/**
		 * If true, the transition animation is reversed.
		 * This attribute is supported by "slide" and "reveal" transition types.
		 * @member {boolean}
		 * @default false
		 */
		reverse: false,

		/**
		 * The selected child id, can be set explicitly or through the show() method.
		 * The effect of setting this property (i.e. getting the value through the getter) might be
		 * asynchronous when an animated transition occurs.
		 * @member {string}
		 * @default ""
		 */
		selectedChildId: "",

		_pendingChild: null,

		_setSelectedChildIdAttr: function (child) {
			if (this.ownerDocument.getElementById(child)) {
				if (this.attached) {
					this.show(child);
				} else {
					this._pendingChild = child;
				}
			}
		},

		_getSelectedChildIdAttr: function () {
			return this._visibleChild ? this._visibleChild.id : "";
		},

		createdCallback: function () {
			this._transitionTiming = {default: 0, chrome: 20, ios: 20, android: 100, ff: 100, ie: 20};
			for (var o in this._transitionTiming) {
				if (has(o) && this._timing < this._transitionTiming[o]) {
					this._timing = this._transitionTiming[o];
				}
			}
		},

		attachedCallback: function () {
			var noTransition = {transition: "none"};
			if (this._pendingChild) {
				this.show(this._pendingChild, noTransition);
				this._pendingChild = null;
			} else if (!this._visibleChild && this.children.length > 0) {
				this.show(this.children[0], noTransition);
			}
		},

		_timing: 0,

		_setChildrenVisibility: function () {
			var cdn = this.children;
			if (!this._visibleChild && cdn.length > 0) {
				this._visibleChild = cdn[0];
			}
			for (var i = 0; i < cdn.length; i++) {
				setVisibility(cdn[i], cdn[i] === this._visibleChild);
			}
		},

		/*
		 * @private
		 */
		onAddChild: dcl.superCall(function (sup) {
			return function (node) {
				var res = sup.call(this, node);
				this._setChildrenVisibility();
				return res;
			};
		}),

		removeChild: dcl.superCall(function (sup) {
			return function (node) {
				sup.call(this, node);
				if (this._visibleChild === node) {
					this._visibleChild = null;
				}
			};
		}),

		postRender: function () {
			this._setChildrenVisibility();
		},

		/**
		 * Shows the immediately following sibling of the ViewStack visible element.
		 * The parameter 'params' is optional. If not specified, this.transition, and this.reverse are used.
		 * @param {Object} [params] - Optional params. A hash like {transition: "reveal", reverse: true}.
		 * The transition value can be "slide", "overlay", "fade" or "flip". Reverse transition applies to "slide"
		 * and "reveal". Transition is internally set to "none" if the ViewStack is not visible.
		 * @returns {Promise} A promise that will be resolved when the display and transition effect will have
		 * been performed.
		 */
		showNext: function (params) {
			//		Shows the next child in the container.
			return this._showPreviousNext("nextElementSibling", params);
		},

		/**
		 * Shows the immediately preceding sibling of the ViewStack visible element.
		 * The parameter 'params' is optional. If not specified, this.transition, and reverse = true are used.
		 * @param {Object} [params] - Optional params. A hash like {transition: "reveal", reverse: true}.
		 * The transition value can be "slide", "overlay", "fade" or "flip". Reverse transition applies to "slide"
		 * and "reveal". Transition is internally set to "none" if the ViewStack is not visible.
		 * Reverse is set to true if not specified.
		 * @returns {Promise} A promise that will be resolved when the display and transition effect will have
		 * been performed.
		 */
		showPrevious: function (params) {
			//		Shows the previous child in the container.
			var args = {reverse: true};
			dcl.mix(args, params || {});
			return this._showPreviousNext("previousElementSibling", args);
		},

		_showPreviousNext: function (direction, props) {
			var ret = null;
			if (!this._visibleChild && this.children.length > 0) {
				this._visibleChild = this.children[0];
			}
			if (this._visibleChild) {
				var target = this._visibleChild[direction];
				if (target) {
					ret = this.show(target, props);
				}
			}
			return ret;
		},

		_doTransition: function (origin, target, event, transition, reverse) {
			var promises = [];
			$(this).addClass("-d-view-stack-transition");
			if (transition !== "none") {
				if (origin) {
					promises.push(this._startNodeTransition(origin));
					$(origin).addClass(transitionClass(transition));
				}
				if (target) {
					promises.push(this._startNodeTransition(target));
					$(target).addClass(transitionClass(transition) + " -d-view-stack-in");
				}
				if (reverse) {
					setReverse(origin);
					setReverse(target);
				}

				// TODO: figure out why the delay is needed
				this.defer(function () {
					if (target) {
						$(target).addClass("-d-view-stack-transition");
					}
					if (origin) {
						$(origin).addClass("-d-view-stack-transition -d-view-stack-out");
					}
					if (reverse) {
						setReverse(origin);
						setReverse(target);
					}
					if (target) {
						$(target).addClass("-d-view-stack-in");
					}
				}, this._timing);
			} else {
				if (origin !== target) {
					setVisibility(origin, false);
				}
			}
			return Promise.all(promises).then(function () {
				$(this).removeClass("-d-view-stack-transition");
				$(target).removeClass("-d-view-stack-transition -d-view-stack-in");
				$(origin).removeClass("-d-view-stack-transition -d-view-stack-out");
			}.bind(this));
		},

		changeDisplay: function (widget, event) {
			// Resolved when display is completed.
			if (!widget || widget.parentNode !== this) {
				return Promise.resolve();
			}

			var origin = this._visibleChild;

			// Needed because the CSS state of a node can be incorrect
			// if a previous transitionend has been dropped
			cleanCSS(origin);
			cleanCSS(widget);

			setVisibility(widget, true);
			this._visibleChild = widget;

			var transition  = (origin === widget) ? "none" : (event.transition || this.transition);
			var reverse = this.effectiveDir === "ltr" ? event.reverse : !event.reverse;
			return this._doTransition(origin, widget, event, transition, reverse);
		},

		/**
		 * Shows a child of the ViewStack.  The parameter 'params' is optional.  If not specified,
		 * `this.transition`, and `this.reverse` are used.
		 * This method must be called to display a particular destination child on this container.
		 * @param {Element|string} dest - Element or Element id that points to the child this container must
		 * show or hide.
		 * @param {Object} [params] - A hash like {transition: "reveal", reverse: true}. The transition value
		 * can be "slide", "overlay", "fade" or "flip". Reverse transition applies to "slide" and
		 * "reveal". Transition is internally set to "none" if the ViewStack is not visible.
		 * @returns {Promise} A promise that will be resolved when the display and transition effect will have
		 * been performed.
		 */
		show: dcl.superCall(function (sup) {
			return function (dest, params) {
				// Check visibility of the ViewStack, forces transition:"none" if not visible.
				//  - Transitions events are broken if the ViewStack is not visible

				var parent = this;
				while (parent && parent.style.display  !== "none" && parent !== this.ownerDocument.body) {
					parent = parent.parentNode;
				}
				if (has("ie") === 9 || parent !== this.ownerDocument.body) {
					if (!params) {
						params = {};
					}
					params.transition = "none";
				}

				if (this._visibleChild && this._visibleChild.parentNode !== this) {
					// The visible child has been removed.
					this._visibleChild = null;
				}
				if (!this._visibleChild && this.children.length > 0) {
					// The default visible child is the first one.
					this._visibleChild = this.children[0];
				}
				return sup.apply(this, [dest, params]);
			};
		}),

		_startNodeTransition: function (node) {
			return new Promise(function (resolve) {
				node.addEventListener("transitionend", function after() {
					node.removeEventListener("transitionend", after);
					resolve();
				});
			}).then(this._afterNodeTransitionHandler.bind(this, node));
		},

		_afterNodeTransitionHandler: function (node) {
			var isVisibleChild = this._visibleChild === node;
			setVisibility(node, isVisibleChild);
			cleanCSS(node);
		}
	});
});

;
/**
 * CSS loading plugin for widgets.
 *
 * This plugin will load and wait for a css file. This can be handy to load the css
 * specific to a widget.
 *
 * This plugin uses the link load event and a work-around on old webkit browsers.
 * The work-around watches a stylesheet until its rules are
 * available (not null or undefined).
 *
 * This plugin will return the path of the inserted css file relative to requirejs baseUrl.
 *
 * @example:
 *      To load the css file `myproj/comp.css`:
 *      ```
 *      require(["requirejs-dplugins/css!myproj/comp.css"], function (){
 *          // Code placed here will wait for myproj/comp.css before running.
 *      });
 *      ```
 *
 *      Or as a widget dependency:
 *      ```
 *      define(["requirejs-dplugins/css!myproj/comp.css"], function (){
 *          // My widget factory
 *      });
 *      ```
 *
 * @module requirejs-dplugins/css
 */

define('requirejs-dplugins/css',[
	"./has",
	"./Promise!",
	"module"
], function (has, Promise, module) {
	"use strict";

	has.add("event-link-onload-api", function (global) {
		var wk = global.navigator.userAgent.match(/AppleWebKit\/([\d.]+)/);
		return !wk || parseInt(wk[1], 10) > 535;
	});
	var cache = {},
		lastInsertedLink;

	/**
	 * Return a promise that resolves when the specified link has finished loading.
	 * @param {HTMLLinkElement} link - The link element to be notified for.
	 * @returns {module:jQuery/Promise} - A promise.
	 * @private
	 */
	var listenOnLoad = function (link) {
		return new Promise(function (resolve) {
			if (has("event-link-onload-api")) {
				// We're using "readystatechange" because IE happily support both
				link.onreadystatechange = link.onload = function () {
					if (!link.readyState || link.readyState === "complete") {
						link.onreadystatechange = link.onload = null;
						resolve();
					}
				};
			} else {
				var poll = function () {
					// watches a stylesheet for loading signs.
					var sheet = link.sheet || link.styleSheet,
						styleSheets = document.styleSheets;
					if (sheet && Array.prototype.lastIndexOf.call(styleSheets, sheet) !== -1) {
						resolve();
					} else {
						setTimeout(poll, 25);
					}
				};
				poll();
			}
		});
	};

	var loadCss = {
		id: module.id,

		/*jshint maxcomplexity: 11*/
		/**
		 * Loads a css file.
		 * @param {string} path - The css file to load.
		 * @param {Function} require - A local require function to use to load other modules.
		 * @param {Function} callback - A function to call when the specified stylesheets have been loaded.
		 * @method
		 */
		load: function (path, require, callback) {
			if (has("builder")) {
				buildFunctions.addOnce(loadList, path);
				callback();
				return;
			}

			// Replace single css bundles by corresponding layer.
			var config = module.config();
			if (config.layersMap) {
				path = config.layersMap[path] || path;
			}

			var head = document.head || document.getElementsByTagName("head")[0],
				url = require.toUrl(path),
				link;

			// if the url has not already been injected/loaded, create a new promise.
			if (!cache[url]) {
				// hook up load detector(s)
				link = document.createElement("link");
				link.rel = "stylesheet";
				link.type = "text/css";
				link.href = url;
				head.insertBefore(link, lastInsertedLink ? lastInsertedLink.nextSibling : head.firstChild);
				lastInsertedLink = link;
				cache[url] = listenOnLoad(link);
			}

			cache[url].then(function () {
				// The stylesheet has been loaded, so call the callback
				callback(path);
			});
		}
	};

	if (has("builder")) {
		// build variables
		var loadList = [],
			writePluginFiles;

		var buildFunctions = {
			/**
			 * Write the layersMap configuration to the corresponding modules layer.
			 * The configuration will look like this:
			 * ```js
			 * require.config({
			 *     config: {
			 *         "requirejs-dplugins/css": {
			 *             layersMap: {
			 *                 "module1.css": "path/to/layer.css",
			 *                 "module2.css": "path/to/layer.css"
			 *             }
			 *         }
			 *     }
			 * });
			 * ```
			 *
			 * @param {Function} write - This function takes a string as argument
			 * and writes it to the modules layer.
			 * @param {string} mid - Current module id.
			 * @param {string} dest - Current css layer path.
			 * @param {Array} loadList - List of css files contained in current css layer.
			 */
			writeConfig: function (write, mid, dest, loadList) {
				var cssConf = {
					config: {}
				};
				cssConf.config[mid] = {
					layersMap: {}
				};
				loadList.forEach(function (path) {
					cssConf.config[mid].layersMap[path] = dest;
				});

				write("require.config(" + JSON.stringify(cssConf) + ");");
			},

			/**
			 * Concat and optimize all css files required by a modules layer and write the result.
			 * The node module `clean-css` is responsible for optimizing the css and correcting
			 * images paths.
			 *
			 * @param {Function} writePluginFiles - The write function provided by the builder to `writeFile`.
			 * and writes it to the modules layer.
			 * @param {string} dest - Current css layer path.
			 * @param {Array} loadList - List of css files contained in current css layer.
			 * @returns {boolean} Return `true` if the function successfully writes the layer.
			 */
			writeLayer: function (writePluginFiles, dest, loadList) {
				function tryRequire(paths) {
					var module;
					var path = paths.shift();
					if (path) {
						try {
							// This is a node-require so it is synchronous.
							module = require.nodeRequire(path);
						} catch (e) {
							return tryRequire(paths);
						}
					}
					return module;
				}

				var path = require.getNodePath(require.toUrl(module.id).replace(/[^\/]*$/, "node_modules/clean-css"));
				var CleanCSS = tryRequire([path, "clean-css"]);
				var fs = require.nodeRequire("fs");

				loadList = loadList.map(require.toUrl)
					.filter(function (path) {
						if (!fs.existsSync(path)) {
							console.log(">> Css file '" + path + "' was not found.");
							return false;
						}
						return true;
					});

				if (CleanCSS) {
					var layer = "";
					loadList.forEach(function (src) {
						var result = new CleanCSS({
							relativeTo: "./",
							target: dest
						}).minify("@import url(" + src + ");");
						// Support clean-css version 2.x and 3.x
						layer += result.styles || result;
					});

					writePluginFiles(dest, layer);
					return true;
				} else {
					console.log(">> WARNING: Node module clean-css not found. Skipping CSS inlining. If you" +
						" want CSS inlining run 'npm install clean-css' in your console.");
					loadList.forEach(function (src) {
						writePluginFiles(src, fs.readFileSync(src));
					});
					return false;
				}
			},

			/**
			 * Add the string to `ary` if it's not already in it.
			 * @param {Array} ary - Destination array.
			 * @param {string} element - Element to add.
			 */
			addOnce: function (ary, element) {
				if (ary.indexOf(element) === -1) {
					ary.push(element);
				}
			}
		};

		loadCss.writeFile = function (pluginName, resource, require, write) {
			writePluginFiles = write;
		};

		loadCss.onLayerEnd = function (write, data) {
			if (data.name && data.path) {
				var dest = data.path.replace(/\.js$/, ".css");
				var destMid = data.name + ".css";

				// Write layer file
				var success = buildFunctions.writeLayer(writePluginFiles, dest, loadList);
				// Write css config on the layer if the layer was successfully written.
				success && buildFunctions.writeConfig(write, module.id, destMid, loadList);
				// Reset loadList
				loadList = [];
			}
		};

		// Expose build functions to be used by delite/theme
		loadCss.buildFunctions = buildFunctions;
	}

	return loadCss;
});
;
define('delite/handlebars!deliteful/ProgressIndicator/ProgressIndicator.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template>\n\t<svg xmlns=\"http://www.w3.org/2000/svg\" attach-point=\"svgNode\">\n\t\t<defs>\n\t\t\t<symbol viewBox=\"0 0 30 30\" preserveAspectRatio=\"none\" attach-point=\"symbolNode\">\n\t\t\t\t<text x=\"48%\" y=\"67%\" attach-point=\"msgNode\"></text>\n\t\t\t</symbol>\n\t\t</defs>\n\t\t<g class=\"d-progress-indicator-lines\" attach-point=\"linesNode\">\n\t\t\t<line x1=\"50.0%\" y1=\"24.0%\" x2=\"50.0%\" y2=\"07.0%\"></line>\n\t\t\t<line x1=\"63.0%\" y1=\"28.0%\" x2=\"72.0%\" y2=\"13.0%\"></line>\n\t\t\t<line x1=\"73.0%\" y1=\"37.0%\" x2=\"88.0%\" y2=\"28.0%\"></line>\n\t\t\t<line x1=\"93.0%\" y1=\"50.0%\" x2=\"76.0%\" y2=\"50.0%\"></line>\n\t\t\t<line x1=\"73.0%\" y1=\"63.0%\" x2=\"88.0%\" y2=\"71.0%\"></line>\n\t\t\t<line x1=\"63.0%\" y1=\"72.0%\" x2=\"71.0%\" y2=\"87.0%\"></line>\n\t\t\t<line x1=\"50.0%\" y1=\"76.0%\" x2=\"50.0%\" y2=\"93.0%\"></line>\n\t\t\t<line x1=\"37.0%\" y1=\"72.0%\" x2=\"28.0%\" y2=\"87.0%\"></line>\n\t\t\t<line x1=\"27.0%\" y1=\"63.0%\" x2=\"13.0%\" y2=\"71.0%\"></line>\n\t\t\t<line x1=\"24.0%\" y1=\"50.0%\" x2=\"07.0%\" y2=\"50.0%\"></line>\n\t\t\t<line x1=\"27.0%\" y1=\"37.0%\" x2=\"13.0%\" y2=\"29.0%\"></line>\n\t\t\t<line x1=\"37.0%\" y1=\"27.0%\" x2=\"29.0%\" y2=\"13.0%\"></line>\n\t\t</g>\n\t\t<use x=\"28.5%\" y=\"28.5%\" width=\"43%\" height=\"43%\" attach-point=\"useNode\"></use>\n\t</svg>\n</template>");
});;
/** @module deliteful/ProgressIndicator */
define('deliteful/ProgressIndicator',[
	"dcl/dcl",
	"delite/hc",
	"delite/register",
	"delite/Widget",
	"delite/handlebars!./ProgressIndicator/ProgressIndicator.html",
	"delite/theme!./ProgressIndicator/themes/{{theme}}/ProgressIndicator.css"
], function (dcl, has, register, Widget, template) {
	/**
	 * A widget that displays a round spinning graphical representation that indicates that a task is ongoing.
	 *
	 * This widget starts hidden and the spinning animation starts when the widget becomes visible. Default widget
	 * size is 40x40px.
	 *
	 * @example <caption>Set the "active" property to true to make the widget visible when it starts.</caption>
	 * <d-progress-indicator active="true"></d-progress-indicator>
	 *
	 * @example <caption>Use style properties "width" and "height" to customize the widget size</caption>
	 * <d-progress-indicator active="true" style="width: 100%; height: 100%"></d-progress-indicator>
	 *
	 * @class module:deliteful/ProgressIndicator
	 * @augments module:delite/Widget
	 */
	return register("d-progress-indicator", [HTMLElement, Widget],
		/** @lends module:deliteful/ProgressIndicator# */ {

		/**
		 * Set to false to hide the widget and stop any ongoing animation.
		 * Set to true to show the widget: animation automatically starts unless you set a number to the "value"
		 * property.
		 * @member {boolean}
		 * @default false
		 */
		active: false,

		/**
		 * A value from 0 to 100 that indicates a percentage of progression of an ongoing task.
		 * Set the value to NaN to hide the number and start the spinning animation. Negative values are converted to 0
		 * and values over 100 are converted to 100.
		 * @member {number}
		 * @default NaN
		 */
		value: NaN,

		/**
		 * The relative speed of the spinning animation.
		 * Accepted values are "slow", "normal" and "fast". Other values are converted to "normal". Note that the
		 * actual/real speed of the animation depends of the device/os/browser capabilities.
		 * @member {string}
		 * @default "normal"
		 */
		speed: "normal",

		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-progress-indicator"
		 */
		baseClass: "d-progress-indicator",

		/* internal properties */
		_requestId: 0, //request animation id or clearTimeout param
		_lapsTime: 1000, //duration of an animation revolution in milliseconds
		_requestAnimationFunction: (
			(window.requestAnimationFrame && window.requestAnimationFrame.bind(window)) || // standard
			(window.webkitRequestAnimationFrame && window.webkitRequestAnimationFrame.bind(window)) || // webkit
			function (callBack) {// others (ie9)
				return this.defer(callBack, 1000 / 60);
			}),
		_cancelAnimationFunction: (
			window.cancelAnimationFrame || //standard
			window.webkitCancelRequestAnimationFrame || // webkit
			function (handle) {// others (ie9)
				handle.remove();
			}).bind(window),

		/* internal methods */
		_requestRendering: function (animationFrame) {
			//browser agnostic animation frame renderer
			//return a request id
			return this._requestAnimationFunction.call(this, animationFrame);//call on this to match this.defer
		},

		_cancelRequestRendering: function (requestId) {
			//browser agnostic animation frame canceler
			return this._cancelAnimationFunction(requestId);
		},

		_reset: function () {
			//reset text and opacity.
			//ensure that any pending frame animation request is done before doing the actual reset
			this._requestRendering(
				function () {
					//remove any displayed value
					this.msgNode.textContent = "";
					//reset the opacity
					for (var i = 0; i < 12; i++) {
						this.lineNodeList[i].style.opacity = (i + 1) * (1 / 12);
					}
				}.bind(this));
		},

		_stopAnimation: function () {
			//stops the animation (if already started)
			if (this._requestId) {
				this._cancelRequestRendering(this._requestId);
				this._requestId = 0;
			}
		},

		_startAnimation: function () {
			//starts the animation (if not already started)
			if (this._requestId) {
				//animation is already ongoing
				return;
			}
			//restore initial opacity and remove text
			this._reset();
			//compute the amount of opacity to subtract at each frame, on each line.
			//note: 16.7 is the average animation frame refresh interval in ms (~60FPS)
			var delta = 16.7 / this._lapsTime;
			//round spinning animation routine
			var frameAnimation = function () {
				//set lines opacity
				for (var i = 0, opacity; i < 12; i++) {
					opacity = (parseFloat(this.lineNodeList[i].style.opacity) - delta) % 1;
					this.lineNodeList[i].style.opacity = (opacity < 0) ? 1 : opacity;
				}
				//render the next frame
				this._requestId = this._requestRendering(frameAnimation);
			}.bind(this);
			//start the animation
			this._requestId = this._requestRendering(frameAnimation);
		},

		template: template,

		postRender: function () {
			this.lineNodeList = this.linesNode.querySelectorAll("line");
			var symbolId = this.baseClass + "-" + this.widgetId + "-symbol";
			this.symbolNode.id = symbolId;
			//set unique SVG symbol id
			this.useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + symbolId);
			//set non-overridable styles
			this.svgNode.style.width = "100%";
			this.svgNode.style.height = "100%";
			this.svgNode.style.textAnchor = "middle";

			//a11y high contrast:
			//widget color is declared on svg line nodes (stroke) and text node (fill).
			//Unlike the color style property, stroke and fill are not updated by the browser when windows high contrast
			//mode is enabled. To ensure the widget is visible when high contrast mode is enabled,
			//we set the color property on the root node and check if it is forced by the browser. In such case we
			//force the stroke and fill values to reflect the high contrast color.
			var hcColor = has("highcontrast");
			if (hcColor) {
				this.linesNode.style.stroke = hcColor; // text value color
				this.msgNode.style.fill = hcColor; // lines color
				//android chrome 31.0.1650.59 hack: force to refresh text color otherwise color doesn't change.
				this.msgNode.textContent = this.msgNode.textContent;
			}

			//set initial widget appearance
			this._reset();
		},

		computeProperties: function (props) {
			var correctedValue = null;
			if ("speed" in props) {
				//fast: 500ms
				//slow: 2000ms
				//normal: 1000ms (also default and fallback value)
				correctedValue = (this.speed === "fast") ? 500:(this.speed === "slow") ? 2000:1000;
				if (this._lapsTime !== correctedValue) {
					this._lapsTime = correctedValue;
				}
			}
			if ("value" in props && !isNaN(this.value)) {
				correctedValue = Math.max(Math.min(this.value, 100), 0);
				if (this.value !== correctedValue) {
					this.value = correctedValue;
				}
			}
		},

		refreshRendering: function (props) {
			//refresh value
			if ("value" in props) {
				if (isNaN(this.value)) {
					//NaN: start the animation
					if (this.active) {
						this._startAnimation();
					}
				} else {
					//ensure any ongoing animation stops
					this._stopAnimation();
					//ensure pending frame animation requests are done before any updates
					this._requestRendering(function () {
						//display the integer value
						this.msgNode.textContent = Math.floor(this.value);
						//minimum amount of opacity.
						var minOpacity = 0.2;
						//update lines opacity
						for (var i = 0, opacity; i < 12; i++) {
							opacity = Math.min(Math.max((this.value * 0.12 - i), 0), 1) * (1 - minOpacity);
							this.lineNodeList[i].style.opacity = minOpacity + opacity;
						}
					}.bind(this));
				}

			}
			//refresh speed
			if ("speed" in props) {
				//if animation is ongoing, restart the animation to take the new speed into account
				if (this._requestId) {
					this._stopAnimation();
					this._startAnimation();
				}
			}
			//refresh active
			if ("active" in props) {
				if (this.active) {
					if (isNaN(this.value)) {
						//NaN: start the animation
						this._startAnimation();
					}
				} else {
					this._stopAnimation();
				}
				//set visibility in frame to be in sync with opacity/text changes.
				//Avoids mis-display when setting visibility=visible just after value=0.
				this._requestRendering(function () {
					this.style.visibility = this.active ? "visible" : "hidden";
				}.bind(this));
			}
			
		},

		destroy: function () {
			this._stopAnimation();
		}
	});
});
;
/**
 * Test if computer is in high contrast mode (i.e. if CSS color settings are ignored)
 * Defines `has("highcontrast")` and sets `d-hc` CSS class on `<body>` if machine is in high contrast mode.
 *
 * Normally this code should not be used.  As long as widgets or applications avoid using background images for
 * icons, the browser will do everything for high contrast mode automatically.  The exception is for SVG,
 * which the browser does not adjust.
 *
 * If the OS is in high contrast mode and the browser obeys the OS setting,
 * `has("highcontrast")` is the color that text appears as.  Otherwise, `has("highcontrast")` is null.
 *
 * Module returns `has()` method.
 *
 * @module delite/hc
 */
define('delite/hc',[
	"requirejs-dplugins/has",
	"requirejs-domready/domReady!"
], function (has) {

	has.add("highcontrast", function () {
		if (typeof window === "undefined") {
			return false;
		}

		// note: if multiple documents, doesn't matter which one we use
		var div = document.createElement("div");
		try {
			div.style.cssText =
				"border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;";
			document.body.appendChild(div);

			var cs = getComputedStyle(div);

			// If it's high contrast mode then return the color and background color the browser is using.
			// Otherwise just return null
			return cs.borderTopColor === cs.borderRightColor ? cs.color : null;
		} catch (e) {
			console.warn("hccss: exception detecting high-contrast mode, document is likely hidden: " + e.toString());
			return null;
		} finally {
			document.body.removeChild(div);
		}
	});

	if (has("highcontrast")) {
		document.body.className = (document.body.className + " d-hc").trim();
	}

	return has;
});
;
/**
 * This module leverages `requirejs-dplugins/has` and sets `has()` flags that can be
 * used by multichannel widgets to determine the required channel:
 *
 * - `has("phone-like-channel")`: `true` for small screens, `false` otherwise.
 * - `has("tablet-like-channel")`: `true` for medium screens, `false` otherwise.
 * - `has("desktop-like-channel")`: `true` for large screens, `false` otherwise.
 * 
 * These flags are set depending on the screen size, using CSS media queries that
 * compare the actual screen width (the `device-width` media feature) with the corresponding
 * breakpoint values provided by `deliteful/channelBreakpoints`. 
 * 
 * Note that the screen size is the only criteria used for determining
 * the channel. When a channel flag is set to `true`, the other channel flags are set
 * to `false`.
 * 
 * The default values of the breakpoints can be configured using `require.config()`.
 * For details, see the documentation of `deliteful/channelBreakpoints`.
 * 
 * The channel can be configured statically using `require.config()`, for instance:
 * 
 * ```html
 * &lt;script>
 *   // configuring RequireJS
 *   require.config({
 *     ...
 *     config: {
 *       "requirejs-dplugins/has": {
 *         "phone-like-channel": false,
 *         "tablet-like-channel": true,
 *         "desktop-like-channel": false,
 *       }
 *     }
 *   });
 * &lt;/script>
 * ```
 * Note that only one channel flag should be set to `true`.
 * 
 * The module returns the `has()` function returned by the module `requirejs-dplugins/has`.
 * 
 * @module deliteful/features
 */
define('deliteful/features',["requirejs-dplugins/has", "deliteful/channelBreakpoints"],
	function (has, channelBreakpoints) {

	// Notes:
	// - Use the device-width media feature rather than width, such that, on
	// desktop/laptop, the selected channel does not depend on the actual size of the
	// viewport. Thus, the selected channel depends only on the static characteristics
	// of the device (its screen width), which fits the use-case of multichannel
	// widgets that need a statically determined channel. Otherwise it would be confusing
	// to get a different channel depending on whether the app is initially loaded
	// in a small or large viewport.
	// - We do not technically enforce the "small" breakpoint to be smaller than the
	// medium one. Hence the apparently redundant checks of both media queries
	// for the small and large channels.
	
	// The build system evaluates the function of plugin modules while running
	// in nodejs. Hence the need to test for presence of window. The value of
	// the has-features does not matter at build time. (#512)
	if (typeof window !== "undefined") {
		// matched by screens at least as large as the "small" breakpoint
		var mqAboveSmall = window.matchMedia("(min-device-width: " +
			channelBreakpoints.smallScreen + ")");
		// matched by screens at least as large as the "medium" breakpoint
		var mqAboveMedium = window.matchMedia("(min-device-width: " +
			channelBreakpoints.mediumScreen + ")");
	
		has.add("phone-like-channel", function () {
			return !mqAboveSmall.matches && !mqAboveMedium.matches;
		});
		has.add("tablet-like-channel", function () {
			return mqAboveSmall.matches && !mqAboveMedium.matches;
		});
		has.add("desktop-like-channel", function () {
			return mqAboveSmall.matches && mqAboveMedium.matches;
		});
	}

	// Does browser have support for CSS animations ?
	has.add("animationEndEvent", function () {
		var animationEndEvents = {
			"animation": "animationend", // > IE10, FF
			"-webkit-animation": "webkitAnimationEnd",   // > chrome 1.0 , > Android 2.1 , > Safari 3.2
			"-ms-animation": "MSAnimationEnd" // IE 10
		};
		// NOTE: returns null if event is not supported
		var fakeElement = document.createElement("fakeElement");
		for (var event in animationEndEvents) {
			if (fakeElement.style[event] !== undefined) {
				return animationEndEvents[event];
			}
		}
		return null;
	});

	return has;
});
;
/** @module deliteful/channelBreakpoints */
define('deliteful/channelBreakpoints',["module"],
	function (module) {
	
	var config = module.config();
	
	/**
	 * This module returns an object containing properties that define values for breakpoints
	 * of CSS media queries based on screen size:
	 * 
	 * - `smallScreen`: defines the screen size limit between phone-like and tablet-like
	 * channels.
	 * - `mediumScreen`: defines the screen size limit between tablet-like and desktop-like
	 * channels.
	 * 
	 * The values of the breakpoints are used by CSS media queries of `deliteful/features`
	 * for setting the `has()`-flags `"phone-like-channel"`, `"tablet-like-channel"`, and
	 * `"desktop-like-channel"`.
	 * 
	 * The default values of the breakpoints can be configured using `require.config()`,
	 * for instance:
	 * 
	 * ```html
	 * &lt;script>
	 *   // configuring RequireJS
	 *   require.config({
	 *     ...
	 *     config: {
	 *       "deliteful/channelBreakpoints": {
	 *         smallScreen: "280px",
	 *         mediumScreen: "724px"
	 *       }
	 *     }
	 *   });
	 * &lt;/script>
	 * ```
	 * 
	 * @module deliteful/channelBreakpoints
	 */
	return /** @lends module:deliteful/channelBreakpoints# */ {
		/**
		 * The maximum screen size value for small screens.
		 * Used as breakpoint by a CSS media query of `deliteful/features` as screen size
		 * threshold between the phone-like and the tablet-like channels.
		 * @member {string}
		 * @default "480px"
		 */
		smallScreen: config.smallScreen || "480px",
		
		/**
		 * The maximum screen size value for medium screens.
		 * Used as breakpoint by a CSS media query of `deliteful/features` as screen size
		 * threshold between the tablet-like and the desktop-like channels.
		 * @member {string}
		 * @default "1024px"
		 */
		mediumScreen: config.mediumScreen || "1024px"
	};
});
;
define('delite/handlebars!deliteful/Switch/Switch.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template class=\"d-switch d-switch-width d-switch-rounded\" role=\"presentation\">\n\t<input type=\"checkbox\" class=\"-d-switch-input d-switch-width\" attach-point=\"focusNode,valueNode\" checked=\"{{checked}}\" value=\"{{value}}\" name=\"{{name}}\">\n\t<div class=\"-d-switch-push -d-switch-transition {{this.checked ? 'd-switch-width' : ''}}\" attach-point=\"_pushNode\"></div><div class=\"-d-switch-knobglass\" attach-point=\"_knobGlassNode\" touch-action=\"none\"></div><div class=\"-d-switch-inner-wrapper -d-switch-transition\" attach-point=\"_innerWrapperNode\">&nbsp;\n\t\t<div class=\"-d-switch-inner -d-switch-pull -d-switch-transition\" attach-point=\"_innerNode\">\n\t\t\t<div class=\"-d-switch-block d-switch-leading d-switch-width\">{{this.checkedLabel}}&nbsp;</div><div class=\"-d-switch-block -d-switch-knob d-switch-rounded\" attach-point=\"_knobNode\">&nbsp;</div><div class=\"-d-switch-block d-switch-trailing d-switch-width\">{{this.uncheckedLabel}}&nbsp;</div>\n\t\t</div>\n\t</div>\n</template>");
});;
/** @module deliteful/Switch */
define('deliteful/Switch',[
	"requirejs-dplugins/has",
	"requirejs-dplugins/jquery!attributes/classes",
	"dpointer/events",
	"delite/register",
	"deliteful/Checkbox",
	"delite/handlebars!./Switch/Switch.html",
	"requirejs-dplugins/has!bidi?./Switch/bidi/Switch",
	"delite/theme!./Switch/themes/{{theme}}/Switch.css"
], function (has, $, pointer, register, Checkbox, template, BidiSwitch) {

	/**
	 * A form-aware switch widget that represents a toggle switch with a sliding knob.
	 * @example
	 * <d-switch checkedLabel="ON" uncheckedLabel="OFF" checked="true"></d-switch>
	 * @class module:deliteful/Switch
	 * @augments module:deliteful/Checkbox
	 */
	return register("d-switch", has("bidi") ? [HTMLElement, Checkbox, BidiSwitch] :
		[HTMLElement, Checkbox], /** @lends module:deliteful/Switch# */ {

		/**
		 * The label corresponding to the checked state.
		 * @member {string}
		 * @default ""
		 */
		checkedLabel: "",

		/**
		 * The label corresponding to the unchecked state.
		 * @member {string}
		 * @default ""
		 */
		uncheckedLabel: "",

		/**
		 * The component css base class.
		 * @member {string}
		 * @default "d-switch"
		 */
		baseClass: "d-switch",

		template: template,

		postRender: function () {
			this.on("pointerdown", this._pointerDownHandler.bind(this), this._knobGlassNode);
			this.on("click", this._clickPreventer.bind(this), this._knobGlassNode);
		},

		destroy: function () {
			this._cleanHandlers();
		},

		_clickPreventer: function (e) {
			e.preventDefault();
			e.stopPropagation();
		},

		_pointerDownHandler: function (e) {
			if (!this.disabled) {
				this._startX = this._curX = e.clientX;
				pointer.setPointerCapture(this._knobGlassNode, e.pointerId);
				if (!this._pHandlers) {
					this._pHandlers = [
						{e: "pointermove", l: this._pointerMoveHandler.bind(this)},
						{e: "pointerup", l: this._pointerUpHandler.bind(this)},
						{e: "lostpointercapture", l: this._lostPointerCaptureHandler.bind(this)}
					];
				}
				this._pHandlers.forEach(function (h) { this._knobGlassNode.addEventListener(h.e, h.l); }.bind(this));
				e.preventDefault();
				e.stopPropagation();
			}
		},

		_pointerMoveHandler: function (e) {
			var dx = e.clientX - this._curX,
				cs = window.getComputedStyle(this._pushNode),
				w = parseInt(cs.width, 10);
			if (!this._drag && Math.abs(e.clientX - this._startX) > 4) {
				this._drag = true;
				$(this._innerNode).removeClass("-d-switch-transition");
				$(this._pushNode).removeClass("-d-switch-transition");
				$(this._innerWrapperNode).removeClass("-d-switch-transition");
			}
			this._curX = e.clientX;
			if (this._drag) {
				// knobWidth and switchWidth are sometimes wrong if computed in 
				// attachedCallback on Chrome so do it here
				this._knobWidth = parseInt(window.getComputedStyle(this._knobNode).width, 10);
				this._switchWidth = parseInt(window.getComputedStyle(this).width, 10);
				var nw = this.effectiveDir === "ltr" ? w + dx : w - dx,
					max = this.checked ? this._switchWidth : this._switchWidth - this._knobWidth,
					min = this.checked ? this._knobWidth : 0;
				nw = Math.max(min, Math.min(max, nw));
				this._pushNode.style.width = nw + "px";
			}
			e.preventDefault();
			e.stopPropagation();
		},

		_pointerUpHandler: function (e) {
			var oldCheckedValue = this.checked;
			if (!this._drag) {
				this.checked = !this.checked;
			} else {
				this._drag = false;
				var cs = parseInt(window.getComputedStyle(this._pushNode).width, 10);
				var m = parseInt(window.getComputedStyle(this._pushNode).marginLeft, 10);
				this.checked = cs + m + this._knobWidth / 2 >= this._switchWidth / 2;
			}
			if (this.checked !== oldCheckedValue) {
				this.emit("change");
			}
			e.preventDefault();
			e.stopPropagation();
		},

		_lostPointerCaptureHandler: function () {
			this._cleanHandlers();
			this._drag = false;
			this._pushNode.style.width = "";
			this._innerNode.style.transform = "none";
			$(this._innerNode).addClass("-d-switch-transition");
			$(this._pushNode).addClass("-d-switch-transition");
			$(this._innerWrapperNode).addClass("-d-switch-transition");
		},

		_cleanHandlers: function () {
			this._pHandlers.forEach(function (h) { this._knobGlassNode.removeEventListener(h.e, h.l); }.bind(this));
		}
	});
});
;
define('deliteful/Switch/bidi/Switch',[
	"dcl/dcl",
	"dpointer/events"
], function (dcl) {

	return dcl(null, {
		refreshRendering: function (oldVals) {
			if ("dir" in oldVals || "textDir" in oldVals || "checkedLabel" in oldVals) {
				this._innerNode.firstChild.textContent = this.applyTextDirection(this.checkedLabel);
			}
			if ("dir" in oldVals || "textDir" in oldVals || "uncheckedLabel" in oldVals) {
				this._innerNode.lastChild.textContent = this.applyTextDirection(this.uncheckedLabel);
			}
			if (this.title && "textDir" in oldVals) {
				this.title = this.applyTextDirection(this.title);
			}
		},

		postRender: function () {
			this.on("pointerover", this._pointerOverHandler.bind(this));
		},

		_pointerOverHandler: function () {
			if (this.title) {
				this.title = this.applyTextDirection(this.title);
			}
		}
	});
});
;
define('delite/handlebars!deliteful/ToggleButton/ToggleButton.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template role=\"button\" type=\"button\" attach-point=\"focusNode\" aria-pressed=\"{{this.checked ? 'true' : 'false'}}\" on-click=\"{{toggle}}\" aria-label=\"{{this.checked ? this.checkedLabel : this.label}}\">\n    <span attach-point=\"iconNode\" aria-hidden=\"true\" class=\"d-icon {{this.checked &amp;&amp; this.checkedIconClass ? this.checkedIconClass : (this.iconClass ? this.iconClass : 'd-hidden')}}\"></span><span attach-point=\"labelNode\" d-shown=\"{{this.showLabel}}\">{{this.checked &amp;&amp; this.checkedLabel ? this.checkedLabel : this.label}}</span>\n</template>");
});;
/** @module deliteful/ToggleButton */
define('deliteful/ToggleButton',[
	"dcl/dcl",
	"delite/register",
	"requirejs-dplugins/has",
	"./Button",
	"./Toggle",
	"requirejs-dplugins/has!bidi?./ToggleButton/bidi/ToggleButton",
	"delite/handlebars!./ToggleButton/ToggleButton.html",
	"delite/theme!./ToggleButton/themes/{{theme}}/ToggleButton.css"
], function (dcl, register, has, Button, Toggle, BidiToggleButton, template) {

	/**
	 * A 2-state toggle button widget that represents a form-aware 2-states (pressed or unpressed) button with optional
	 * icons and labels for each state.
	 *
	 * A toggle button can display a different label depending on its state. By default, the label specified inline
	 * in the markup or via the 'label' property is displayed whatever the state is. It is however possible to set a
	 * label specific to the checked state via the 'checkedLabel' property.
	 *
	 * Similarly, a toggle button can display a different icon depending on its state. By default, the css class
	 * specified by the 'iconClass' property is applied whatever the state is. However, a css class specific to the
	 * checked state can be specified via the 'checkedIconClass' property.
	 *
	 * Moreover, a toggle button can show an icon only with no visible text, independently of
	 * the toggle button's state, checked or unchecked. To accomplish that,
	 * set the `showLabel` property (inherited from the `deliteful/Button` class). to `false`.
	 *
	 * @example <caption>Creating a checked toggle button</caption>
	 * <button is="d-toggle-button" checked="true">Foo</button>
	 * @example <caption>Specify a label for the checked state</caption>
	 * <button is="d-toggle-button" checked="true" checkedLabel="On">Off</button>
	 * @example <caption>Specify an icon for the checked state</caption>
	 * <style>
	 *   .iconOn {
	 *     background-image: url('images/on.png');
	 *     width: 16px;
	 *     height: 16px;
	 *   }
	 * </style>
	 * <button is="d-toggle-button" checked="true" checkedIconClass="iconOn">Off</button>
	 * @class module:deliteful/ToggleButton
	 * @augments module:deliteful/Toggle
	 * @augments module:deliteful/Button.Mixin
	 */
	var ToggleButton = dcl([Button.Impl, Toggle], /** @lends module:deliteful/ToggleButton# */ {
		/**
		 * The component css base class.
		 * @member {string}
		 * @default "d-toggle-button"
		 */
		baseClass: "d-toggle-button",

		/**
		 * The label to display when the button is checked. If not specified, the default label (either the one
		 * specified inline in markup or via the 'label' property) is used for both states.
		 * @member {string}
		 * @default ""
		 */
		checkedLabel: "",

		/**
		 * The name of the CSS class to apply to DOMNode in button to make it display an icon when the button is
		 * checked. If not specified, the class specified in the 'iconClass' property, if any, is used for both states.
		 * @member {string}
		 * @default ""
		 */
		checkedIconClass: "",

		template: template,

		refreshRendering: function (props) {
			/* jshint maxcomplexity: 11 */
			if (("label" in props || "checkedLabel" in props || "showLabel" in props || "checked" in props) &&
				(!this.title || this.title === ("label" in props ? props.label : this.label)
					|| this.title === ("checkedLabel" in props ? props.checkedLabel : this.checkedLabel))) {
				this.title = this.showLabel ? "" : (this.checked ? this.checkedLabel : this.label);
			}
		}
	});

	return register("d-toggle-button",  has("bidi") ? [HTMLButtonElement, ToggleButton, BidiToggleButton] :
		[HTMLButtonElement, ToggleButton]);
});
;
define('deliteful/ToggleButton/bidi/ToggleButton',[
	"dcl/dcl",
	"dpointer/events"
], function (dcl) {

	return dcl(null, {
		refreshRendering: function (oldVals) {
			if (this.checked && this.checkedLabel) {
				if ("checked" in oldVals || "textDir" in oldVals || "checkedLabel" in oldVals) {
					this.labelNode.textContent = this.applyTextDirection(this.checkedLabel);
				}
			}
			else if ("checked" in oldVals || "textDir" in oldVals || "label" in oldVals) {
				this.labelNode.textContent = this.applyTextDirection(this.label);
			}
			if (this.title && "textDir" in oldVals) {
				this.title = this.applyTextDirection(this.title);
			}
		},

		postRender: function () {
			this.on("pointerover", this._pointerOverHandler.bind(this));
		},

		_pointerOverHandler: function () {
			if (this.title) {
				this.title = this.applyTextDirection(this.title);
			}
		}
	});
});
;
/** @module deliteful/Toggle */
define('deliteful/Toggle',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",
	"delite/CssState"
], function (dcl, $, CssState) {

	/**
	 * A base class for 2-state form widgets.
	 * @class module:deliteful/Toggle
	 * @abstract
	 * @augments module:delite/CssState
	 */
	return dcl(CssState, /** @lends module:deliteful/Toggle# */ {
		/**
		 * Indicates whether this widget is checked.
		 * @member {boolean}
		 * @default false
		 */
		checked: false,

		/**
		 * The widget value that is sent to forms.
		 * @member {string}
		 * @default "on"
		 */
		value: "on",

		attachedCallback: function () {
			this._initState = this.checked;
		},

		afterFormResetCallback: function () {
			this.checked = this._initState;
		},

		postRender: function () {
			// CssState does not handle focused property any more
			this.on("focus", function () {  $(this).addClass("d-focused"); }.bind(this), this.focusNode);
			this.on("blur", function () { $(this).removeClass("d-focused"); }.bind(this), this.focusNode);
		},

		/**
		 * Toggles the state of this widget.
		 * @method
		 */
		toggle: function () {
			if (!this.disabled) {
				this.checked = !this.checked;
			}
		}
	});
});
;
/** @module delite/CssState */
define('delite/CssState',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass(), removeClass()
	"./Widget"
], function (dcl, $, Widget) {

	/**
	 * Update the visual state of the widget by setting CSS classes on widget root node
	 * based on widget properties:
	 *
	 * - `this.disabled` --> `d-disabled`
	 * - `this.readOnly` --> `d-readonly`
	 * - `this.selected` --> `d-selected` (ex: currently selected tab)
	 * - `this.checked == true` --> `d-checked` (ex: a checkbox or a ToggleButton in a checked state)
	 * - `this.checked == "mixed"` --> `d-mixed` (half-checked aka indeterminate checkbox)
	 * - `this.state == "Error"` --> `d-error` (ValidationTextBox value is invalid)
	 * - `this.state == "Incomplete"` --> `d-incomplete` (user hasn't finished typing value yet)
	 *
	 * @mixin module:delite/CssState
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** lends module:delite/CssState# */ {

		/**
		 * List of boolean properties to watch.
		 * @member {string[]} module:delite/CssState#booleanCssProps
		 * @default ["disabled", "readOnly", "selected", "focused", "opened"]
		 */
		booleanCssProps: ["disabled", "readOnly", "selected", "opened"],

		refreshRendering: function (oldVals) {
			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			this.booleanCssProps.forEach(function (name) {
				if (name in oldVals) {
					$(this).toggleClass("d-" + name.toLowerCase(), this[name]);
				}
			}, this);
			if ("checked" in oldVals) {
				$(this).removeClass(oldVals.checked === "mixed" ? "d-mixed" : "d-checked");
				if (this.checked) {
					$(this).addClass(this.checked === "mixed" ? "d-mixed" : "d-checked");
				}
			}
			if ("state" in oldVals) {
				$(this).removeClass("d-" + oldVals.state.toLowerCase()).addClass("d-" + this.state.toLowerCase());
			}
		}
	});
});
;
define('delite/handlebars!deliteful/RadioButton/RadioButton.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template role=\"presentation\">\n\t<span class=\"d-radio-button-icon\" aria-hidden=\"true\"></span>\n\t<input type=\"radio\" attach-point=\"focusNode,valueNode\" checked=\"{{checked}}\" value=\"{{value}}\" name=\"{{name}}\">\n</template>");
});;
/** @module deliteful/RadioButton */
define('deliteful/RadioButton',[
	"delite/register",
	"./Checkbox",
	"delite/handlebars!./RadioButton/RadioButton.html",
	"delite/theme!./RadioButton/themes/{{theme}}/RadioButton.css"
], function (register, Checkbox, template) {

	/**
	 * A radio button widget similar to an HTML5 input type="radio" element.
	 * @example
	 * <d-radio-button checked="true" name="categories" value="sport"></d-radio-button>
	 * <d-radio-button name="categories" value="SUV"></d-radio-button>
	 * @class module:deliteful/RadioButton
	 * @augments module:deliteful/Checkbox
	 */
	return register("d-radio-button", [HTMLElement, Checkbox], /** @lends module:deliteful/RadioButton# */ {

		/**
		 * The component css base class.
		 * @member {string}
		 * @default "d-radio-button"
		 */
		baseClass: "d-radio-button",

		template: template,

		_inputClickHandler: register.superCall(function (sup) {
			return function (evt) {
				sup.call(this, evt);
				// sync widget state to be sure state of other "same-group" buttons are in-sync in
				// user click handler (to be sure there's only one checked radio at the time the
				// user click handler is called)
				this.deliver();
			};
		}),

		toggle: register.superCall(function (sup) {
			return function () {
				if (!this.checked) {
					sup.call(this);
				}
			};
		}),

		refreshRendering: function (props) {
			if ("checked" in props && this.checked) {
				// this one has been checked, then unchecked previously checked radio in the same group
				if (!this._related) {
					// find radio buttons of the same "group"
					var inputs = (this.valueNode.form || this.ownerDocument)
						.querySelectorAll("input[type='radio'][name='" + this.name + "']");
					this._related =
						Array.prototype.filter.call(inputs, function (input) {
							return input !== this.valueNode && input.form === this.valueNode.form;
						}.bind(this)).map(this.getEnclosingWidget.bind(this));
				}
				this._related.forEach(function (r) {
					r.checked = !this.checked;
				}.bind(this));
			}
			if ("name" in props) {
				delete this._related;
			}
		}
	});
});;
define('delite/handlebars!deliteful/Checkbox/Checkbox.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template class=\"d-reset d-inline\" role=\"presentation\">\n\t<span class=\"d-checkbox-icon\" aria-hidden=\"true\"></span>\n\t<input type=\"checkbox\" attach-point=\"focusNode,valueNode\" checked=\"{{checked}}\" value=\"{{value}}\" name=\"{{name}}\">\n</template>");
});;
/** @module deliteful/Checkbox */
define('deliteful/Checkbox',[
	"dcl/dcl",
	"delite/register",
	"delite/FormWidget",
	"./Toggle",
	"delite/handlebars!./Checkbox/Checkbox.html",
	"delite/theme!./Checkbox/themes/{{theme}}/Checkbox.css"
], function (dcl, register, FormWidget, Toggle, template) {

	/**
	 * A 2-state checkbox widget similar to an HTML5 input type="checkbox" element.
	 * @example
	 * <d-checkbox checked="true"></d-checkbox>
	 * @class module:deliteful/Checkbox
	 * @augments module:delite/FormWidget
	 * @augments module:deliteful/Toggle
	 */
	return register("d-checkbox", [HTMLElement, FormWidget, Toggle], /** @lends module:deliteful/Checkbox# */ {

		/**
		 * The component css base class.
		 * @member {string}
		 * @default "d-checkbox"
		 */
		baseClass: "d-checkbox",

		template: template,

		postRender: function () {
			this._lbl4 = null;
			this.on("click", this._inputClickHandler.bind(this), this.focusNode);
			this.on("change", this._inputClickHandler.bind(this), this.focusNode);
		},

		_inputClickHandler: function () {
			this.checked = this.focusNode.checked;
		}
	});
});;
define('delite/handlebars!deliteful/Select/Select.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template class=\"d-select\" role=\"presentation\">\n\t<select class=\"d-select-inner\" attach-point=\"valueNode,focusNode\" value=\"{{value}}\" name=\"{{name}}\" size=\"{{size}}\" multiple=\"{{this.selectionMode === 'multiple'}}\" disabled=\"{{disabled}}\"></select>\n</template>");
});;
/** @module deliteful/Select */
define('deliteful/Select',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",
	"decor/sniff",
	"delite/register",
	"delite/FormWidget",
	"delite/StoreMap",
	"delite/Selection",
	"delite/handlebars!./Select/Select.html",
	"delite/theme!./Select/themes/{{theme}}/Select.css"
], function (dcl, $, has, register,
	FormWidget, StoreMap, Selection, template) {

	/**
	 * A form-aware and store-aware widget leveraging the native HTML5 `<select>`
	 * element.
	 * It has the following characteristics:
	 * * The corresponding custom tag is `<d-select>`.
	 * * Allows to select one or more items among a number of options (in single
	 * or multiple selection mode; see `selectionMode`).
	 * * Store support (limitation: to avoid graphic glitches, the updates to the
	 * store should not be done while the native dropdown of the select is open).
	 * The attributes of data items used for the `label`, `value`, and `disabled`
	 * attributes of option elements can be customized using respectively the
	 * `labelAttr`, `valueAttr`, and `disabledAttr` properties, or using
	 * `labelFunc`, `valueFunc`, and `disabledFunc` properties (for details, see
	 * the documentation of the `delite/StoreMap` superclass).
	 * * Form support (inherits from `delite/FormWidget`).
	 * * The item rendering has the limitations of the `<option>` elements of the
	 * native `<select>`, in particular it is text-only.
	 * 
	 * Remarks:
	 * * The option items must be added, removed or updated exclusively using
	 * the store API. Direct operations using the DOM API are not supported.
	 * * The handling of the selected options of the underlying native `<select>`
	 * must be done using the API inherited by deliteful/Select from delite/Selection.
	 * 
	 * @example <caption>Using store custom element in markup</caption>
	 * JS:
	 * require(["deliteful/Select", "requirejs-domready/domReady!"],
	 *   function () {
	 *   });
	 * HTML:
	 * <d-select id="select">
	 *    {text: "Option 1", value: "1"}
	 *    ...
	 * </d-select>
	 * @example <caption>Using programmatically created store</caption>
	 * JS:
	 * require(["dstore/Memory", "dstore/Trackable",
	 *         "deliteful/Select", "requirejs-domready/domReady!"],
	 *   function (Memory, Trackable) {
	 *     var store = new (Memory.createSubclass(Trackable))({});
	 *     select1.source = store;
	 *     store.add({text: "Option 1", value: "1"});
	 *     ...
	 *   });
	 * HTML:
	 * <d-select selectionMode="multiple" id="select"></d-select>
	 * 
	 * @class module:deliteful/Select
	 * @augments module:delite/FormWidget
	 * @augments module:delite/StoreMap
	 * @augments module:delite/Selection
	 */
	return register("d-select", [HTMLElement, FormWidget, Selection, StoreMap],
		// Have to keep StoreMap after Selection to get Store definition of getIdentity function
		/** @lends module:deliteful/Select# */ {
		
		// TODO: improve doc.
		
		// Note: the properties `store` and `query` are inherited from delite/Store, and
		// the property `disabled` is inherited from delite/FormWidget.
		
		/**
		 * The number of rows that should be visible at one time when the widget
		 * is presented as a scrollable list box. Corresponds to the `size` attribute
		 * of the underlying native HTML `<select>`.
		 * @member {number}
		 * @default 0
		 */
		size: 0,
		
		/**
		 * The name of the property of store items which contains the text
		 * of Select's options.
		 * @member {string}
		 * @default "text"
		 */
		textAttr: "text",
		
		/**
		 * The name of the property of store items which contains the value
		 * of Select's options.
		 * @member {string}
		 * @default "value"
		 */
		valueAttr: "value",
		
		/**
		 * The name of the property of store items which contains the disabled
		 * value of Select's options. To disable a given option, the `disabled`
		 * property of the corresponding data item must be set to a truthy value.
		 * Otherwise, the option is enabled if data item property is absent, or
		 * its value is falsy or the string "false".
		 * @member {string}
		 * @default "disabled"
		 */
		disabledAttr: "disabled",
		
		baseClass: "d-select",
		
		/**
		 * The chosen selection mode.
		 *
		 * Valid values are:
		 *
		 * 1. "single": Only one option can be selected at a time.
		 * 2. "multiple": Several options can be selected (by taping or using the
		 * control key modifier).
		 *
		 * Changing this value impacts the currently selected items to adapt the
		 * selection to the new mode. However, regardless of the selection mode,
		 * it is always possible to set several selected items using the
		 * `selectedItem` or `selectedItems` properties.
		 * The mode will be enforced only when using `setSelected` and/or
		 * `selectFromEvent` APIs.
		 *
		 * @member {string} module:deliteful/Select#selectionMode
		 * @default "single"
		 */
		// The purpose of the above pseudo-property is to adjust the documentation
		// of selectionMode as provided by delite/Selection.
		  
		template: template,

		afterFormResetCallback: function () {
			this.valueNode.selectedIndex =
				this.selectionMode === "single" ?
					// First option selected in "single" selection mode, and
					// no option selected in "multiple" mode
					0 : -1;
			this.value = this.valueNode.value;
		},

		postRender: function () {
			// To provide graphic feedback for focus, react to focus/blur events
			// on the underlying native select. The CSS class is used instead
			// of the focus pseudo-class because the browsers give the focus
			// to the underlying select, not to the widget.
			this.on("focus", function (evt) {
				$(this).toggleClass("d-select-focus", evt.type === "focus");
			}.bind(this), this.valueNode);
			this.on("blur", function (evt) {
				$(this).toggleClass("d-select-focus", evt.type === "focus");
			}.bind(this), this.valueNode);

			// Keep delite/Selection's selectedItem/selectedItems in sync after
			// interactive selection of options.
			this.on("change", function (event) {
				this._duringInteractiveSelection = true;
				var selectedItems = this.selectedItems,
					selectedOptions = this.valueNode.selectedOptions;
				// HTMLSelectElement.selectedOptions is not present in all browsers...
				// At least IE10/Win misses it. Hence:
				if (selectedOptions === undefined) {
					// Convert to array
					var options = Array.prototype.slice.call(this.valueNode.options);
					selectedOptions = options.filter(function (option) {
						return option.selected;
					});
				} else {
					// convert HTMLCollection into array (to be able to use array.indexOf)
					selectedOptions = Array.prototype.slice.call(selectedOptions);
				}
				var nSelectedItems = selectedItems ? selectedItems.length : 0,
					nSelectedOptions = selectedOptions ? selectedOptions.length : 0;
				var i;
				var selectedOption, selectedItem;
				// Identify the options which changed their selection state. Two steps:
				// Step 1. Search options previously selected (currently in widget.selectedItems)
				// which are no longer selected in the native select.
				for (i = 0; i < nSelectedItems; i++) {
					selectedItem = selectedItems[i];
					if (selectedOptions.indexOf(selectedItem.__visualItem) === -1) {
						this.selectFromEvent(event, selectedItem, selectedItem.__visualItem, true);
					}
				}
				// Step 2. Search options newly selected in the native select which are not
				// present in the current selection (widget.selectedItems).
				for (i = 0; i < nSelectedOptions; i++) {
					selectedOption = selectedOptions[i];
					if (selectedItems.indexOf(selectedOption.__dataItem) === - 1) {
						this.selectFromEvent(event, selectedOption.__dataItem, selectedOption, true);
					}
				}

				// Update widget's value after interactive selection
				this._set("value", this.valueNode.value);

				this._duringInteractiveSelection = false;
			}.bind(this), this.valueNode);
			
			// Thanks to the custom getter defined in deliteful/Select for widget's
			// `value` property, there is no need to add code for keeping the
			// property in sync after a form reset.
		},
		
		hasSelectionModifier: function () {
			// Override of the method from delite/Selection because the
			// default implementation is inappropriate: the "change" event
			// has no key modifier.
			return this.selectionMode === "multiple";
		},
		
		refreshRendering: function (props) {
			/* jshint maxcomplexity: 13 */
			if ("renderItems" in props) {
				// Populate the select with the items retrieved from the store.
				var renderItems = this.renderItems;
				var n = renderItems ? renderItems.length : 0;
				// TODO: CHECKME/IMPROVEME. Also called after adding, deleting or updating just one item.
				// Worth optimizing to avoid recreating from scratch?
				this.valueNode.innerHTML = ""; // Remove the existing options from the DOM
				if (n > 0) {
					var fragment = this.ownerDocument.createDocumentFragment();
					var renderItem, option;
					for (var i = 0; i < n; i++) {
						renderItem = renderItems[i];
						option = this.ownerDocument.createElement("option");
						// to allow retrieving the data item from the option element
						option.__dataItem = renderItem.__item; // __item is set by StoreMap.itemToRenderItem()
						// to allow retrieving the option element from widget's selectedItems
						// (which are data items, not render items).
						option.__dataItem.__visualItem = option;
						this.discardChanges(); // to avoid infinity loop
						
						// According to http://www.w3.org/TR/html5/forms.html#the-option-element, we 
						// could use equivalently the label or the text IDL attribute of the option element.
						// However, using the label attr. breaks the rendering in FF29/Win7!
						// This is https://bugzilla.mozilla.org/show_bug.cgi?id=40545.
						// Hence don't do
						// option.label = renderItem.label;
						// Instead:
						if (renderItem.text !== undefined) { // optional
							option.text = renderItem.text;
						}
						if (renderItem.value !== undefined) { // optional
							option.setAttribute("value", renderItem.value);
						} else if (has("ie") && renderItem.text !== undefined) { // #546
							option.setAttribute("value", renderItem.text);
						}
						// The selection API (delite/Selection) needs to be called consistently
						// for data items, not for render items.
						// renderItem.__item is the data item instance for which
						// StoreMap.itemToRenderItem() has created the render item.
						// For now there is no public API for accessing it.
						if (this.isSelected(renderItem.__item)) { // delite/Selection's API
							option.setAttribute("selected", "true");
						}
						if (renderItem.disabled !== undefined &&
							!!renderItem.disabled && renderItem.disabled !== "false") { // optional
							// Note that for an enabled option the attribute must NOT be set
							// (<option disabled="false"> is a disabled option!)
							option.setAttribute("disabled", "true");
						}
						
						fragment.appendChild(option);
					}
					this.valueNode.appendChild(fragment);
					
					if (this.selectionMode === "single") {
						// Since there is no native "change" event initially, initialize
						// the delite/Selection's selectedItem property with the currently
						// selected option of the native select.
						this.selectedItem =
							this.valueNode.options[this.valueNode.selectedIndex].__dataItem;
					} // else for the native multi-select: it does not have any
					// option selected by default.
					
					// Initialize widget's value
					this._set("value", this.valueNode.value);
				}
			}
		},
		
		getIdentity: dcl.superCall(function (sup) {
			return function (dataItem) {
				return sup.call(this, dataItem);
			};
		}),
		
		updateRenderers: function () {
			// Override of delite/Selection's method.
			// Trigger rerendering from scratch, in order to keep the rendering
			// in sync with the selection state of items. This method gets called
			// by delite/Selection after changes of selection state. However, the
			// re-rendering must not be triggered while the user clicks items,
			// because it would disturb user's interaction with a Select in
			// multiple mode (#510): with more options than the available height, after
			// scrolling and clicking an item, the rerendered Select may not have
			// the same scroll amount as before the click, which isn't ergonomical.
			// (Differently, in single selection mode, the popup closes right after
			// the interactive selection.)
			if (!this._duringInteractiveSelection) {
				this.notifyCurrentValue("renderItems");
			}
		},
		
		_setValueAttr: function (value) {
			if (this.valueNode) {
				this.valueNode.value = value;
			}
			this._set("value", value);
		},
		
		_setSelectionModeAttr: dcl.superCall(function (sup) {
			// Override of the setter from delite/Selection to forbid the values
			// "none" and "radio"
			return function (value) {
				if (value !== "single" && value !== "multiple") {
					throw new TypeError("'" + value +
						"' not supported for selectionMode; keeping the previous value of '" +
						this.selectionMode + "'");
				} else {
					this._set("selectionMode", value);
				}
				sup.call(this, value);
			};
		})
	});
});
;
define('delite/handlebars!deliteful/Combobox/Combobox.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template class=\"d-combobox\" role=\"presentation\">\n\t<input class=\"d-combobox-input\" role=\"combobox\" attach-point=\"inputNode,focusNode\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"none\" aria-autocomplete=\"list\" type=\"text\" readonly=\"{{this._inputReadOnly ? 'readonly' : ''}}\" placeholder=\"{{searchPlaceHolder}}\">\n\t<input class=\"d-hidden\" attach-point=\"valueNode\" readonly=\"\" name=\"{{name}}\" value=\"{{value}}\">\n\t<span class=\"d-combobox-arrow\" d-shown=\"{{hasDownArrow}}\" attach-point=\"buttonNode\" aria-hidden=\"true\"></span>\n</template>");
});;
/** @module deliteful/Combobox */
define('deliteful/Combobox',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes,event",	// addClass(), css(), on(), off()
	"dstore/Filter",
	"dojo/string",
	"delite/register",
	"delite/CssState",
	"delite/FormValueWidget",
	"delite/HasDropDown",
	"./list/List",
	"./features!desktop-like-channel?:./Combobox/ComboPopup",
	"delite/handlebars!./Combobox/Combobox.html",
	"requirejs-dplugins/i18n!./Combobox/nls/Combobox",
	"delite/theme!./Combobox/themes/{{theme}}/Combobox.css"
], function (
	dcl,
	$,
	Filter,
	string,
	register,
	CssState,
	FormValueWidget,
	HasDropDown,
	List,
	ComboPopup,
	template,
	messages
) {

	// Counter used to generate unique ids for the dropdown items, so that aria-activedescendant is set to
	// a reasonable value.
	var idCounter = 1;

	/**
	 * A form-aware and store-aware multichannel widget leveraging the `deliteful/list/List`
	 * widget for rendering the options.
	 *
	 * The corresponding custom tag is `<d-combobox>`.
	 *
	 * The property `list` allows to specify the List instance used by the widget.
	 * The customization of the mapping of data item attributes into render item
	 * attributes can be done on the `List` instance using the mapping API of `List`
	 * inherited from its superclass `delite/StoreMap`.
	 *
	 * The property `selectionMode` allows to choose between single and multiple
	 * choice modes.
	 *
	 * In single selection mode, if the property `autoFilter` is set to `true`
	 * (default is `false`) the widget allows to type one or more characters which
	 * are used for filtering the shown list items. By default, the filtering is
	 * case-insensitive, and an item is shown if its label contains the entered
	 * string. The default filtering policy can be customized thanks to the
	 * `filterMode` and `ignoreCase` properties.
	 *
	 * The widget provides multichannel rendering. Depending on the required channel, which
	 * is determined by the value of the channel flags of `deliteful/features`, the
	 * widget displays the popup containing the options in a different manner:
	 *
	 * - if `has("desktop-like-channel")` is `true`: in a popup below or above the root node.
	 * - otherwise (that is for `"phone-like-channel"` and `"tablet-like-channel"`): in an
	 * overlay centered on the screen, filled with an instance of `deliteful/Combobox/ComboPopup`.
	 *
	 * The channel flags are set by `deliteful/features` using CSS media queries depending on
	 * the screen size. See the `deliteful/features` documentation for information about the
	 * channel flags and about how to configure them statically and how to customize the values
	 * of the screen size breakpoints used by the media queries.
	 *
	 * The `value` property of the widget contains:
	 *
	 * - Single selection mode: the value of the selected list items. By default, the
	 * value of the first item is selected.
	 * - Multiple selection mode: an array containing the values of the selected items.
	 * Defaults to `[]`.
	 *
	 * If the widget is used in an HTML form, the submitted value contains:
	 *
	 * - Single selection mode: the same as widget's `value` property.
	 * - Multiple selection mode: a string containing a comma-separated list of the values
	 * of the selected items. Defaults to `""`.
	 *
	 * By default, the `label` field of the list render item is used as item value.
	 * A different field can be specified by using attribute mapping for `value` on the
	 * List instance.
	 *
	 * Remark: the option items must be added, removed or updated exclusively using
	 * List's store API. Direct operations using the DOM API are not supported.
	 *
	 * @example <caption>Markup</caption>
	 * JS:
	 * require(["deliteful/Combobox", "requirejs-domready/domReady!"],
	 *   function () {
	 *   });
	 * HTML:
	 * <d-combobox id="combobox1">
	 *   <d-list>
	 *   { "label": "France", "sales": 500, "profit": 50, "region": "EU" },
	 *   { "label": "Germany", "sales": 450, "profit": 48, "region": "EU" },
	 *   { "label": "UK", "sales": 700, "profit": 60, "region": "EU" },
	 *   { "label": "USA", "sales": 2000, "profit": 250, "region": "America" },
	 *   { "label": "Canada", "sales": 600, "profit": 30, "region": "America" },
	 *   { "label": "Brazil", "sales": 450, "profit": 30, "region": "America" },
	 *   { "label": "China", "sales": 500, "profit": 40, "region": "Asia" },
	 *   { "label": "Japan", "sales": 900, "profit": 100, "region": "Asia" }
	 *   </d-list>
	 * </d-combobox>
	 *
	 * @example <caption>Programmatic</caption>
	 * JS:
	 * require(["deliteful/List",
	 *   "deliteful/Combobox", ..., "requirejs-domready/domReady!"],
	 *   function (List, Combobox, ...) {
	 *     var dataStore = ...; // Create data store
	 *     var combobox = new Combobox({source: dataStore, selectionMode: "multiple"}).
	 *       placeAt(...);
	 *   });
	 *
	 * @class module:deliteful/Combobox
	 * @augments module:delite/HasDropDown
	 * @augments module:delite/FormValueWidget
	 */
	return register("d-combobox", [HTMLElement, HasDropDown, FormValueWidget, CssState],
		/** @lends module:deliteful/Combobox# */ {

		// TODO: handle the situation the list has a null/undefined store.
		// Would be nice to have a global policy for all subclasses of
		// delite/Store (in terms of error feedback).
		// TODO: future mechanism at the level of delite/Store-delite/StoreMap
		// to allow delegation from host widget to a different widget - to get
		// a clean mechanism to support all possible use-cases. (Probably also
		// requires changes in List).
		// TODO: improve API doc.
		// TODO: add (optional) placeholder?

		// Note: the property `disabled` is inherited from delite/FormWidget.

		baseClass: "d-combobox",

		template: template,

		/**
		 * If `true`, the list of options can be filtered thanks to an editable
		 * input element. Only used if `selectionMode` is "single".
		 * @member {boolean} module:deliteful/Combobox#autoFilter
		 * @default false
		 */
		autoFilter: false,

		/**
		 * The chosen filter mode. Only used if `autoFilter` is `true` and
		 * `selectionMode` is `"single"`.
		 *
		 * Valid values are:
		 *
		 * 1. "startsWith": the item matches if its label starts with the filter text.
		 * 2. "contains": the item matches if its label contains the filter text.
		 * 3. "is": the item matches if its label is the filter text.
		 *
		 * @member {string}
		 * @default "startsWith"
		 */
		filterMode: "startsWith",

		/**
		 * If `true`, the filtering of list items ignores case when matching possible items.
		 * Only used if `autoFilter` is `true` and `selectionMode` is `"single"`.
		 * @member {boolean} module:deliteful/Combobox#autoFilter
		 * @default true
		 */
		ignoreCase: true,

		/**
		 * The chosen selection mode.
		 *
		 * Valid values are:
		 *
		 * 1. "single": Only one option can be selected at a time.
		 * 2. "multiple": Several options can be selected.
		 *
		 * The value of this property determines the value of the `selectionMode`
		 * property of the List instance used by this widget for displaying the options:
		 * * The value "single" is mapped to "radio".
		 * * The value "multiple" is mapped to "multiple".
		 *
		 * Note that, regardless of the selection mode, it is always possible to set
		 * several selected items using the `selectedItem` or `selectedItems` properties
		 * of the List instance.
		 * The mode will be enforced only when using `setSelected()` and/or
		 * `selectFromEvent()` APIs of the List.
		 *
		 * @member {string}
		 * @default "single"
		 */
		selectionMode: "single",

		/**
		 * The `deliteful/list/List` element which provides and renders the options
		 * shown by the popup of the Combobox.
		 * Note that this property is set by default to a newly created instance of
		 * `deliteful/list/List`.
		 * @member {module:deliteful/list/List} module:deliteful/Combobox#list
		 * @default instance of deliteful/list/List
		 */
		list: null,

		// Flag used for binding the readonly attribute of the input element in the template
		_inputReadOnly: true,

		/**
		 * The value of the placeholder attribute of the input element used
		 * for filtering the list of options. The default value is provided by the
		 * "search-placeholder" key of the message bundle.
		 * @member {string}
		 * @default "Search"
		 */
		searchPlaceHolder: messages["search-placeholder"],

		/**
		 * The text displayed in the input element when no option is selected.
		 * The default value is provided by the "multiple-choice-no-selection" key of
		 * the message bundle. This message can contains placeholders for the
		 * Combobox attributes to be replaced by their runtime value. For example, the
		 * message can include the number of selected items by using the
		 * placeholder `${items}`.
		 * @member {string}
		 * @default localized version of "{items} selected"
		 */
		multipleChoiceMsg: messages["multiple-choice"],

		/**
		 * The text displayed in the input element when no option is selected.
		 * The default value is provided by the "multiple-choice-no-selection" key of
		 * the message bundle.
		 * @member {string}
		 * @default "Select option(s)"
		 */
		multipleChoiceNoSelectionMsg: messages["multiple-choice-no-selection"],

		/**
		 * The text displayed in the OK button when the combobox popup contains such a button.
		 * The default value is provided by the "ok-button-label" key of
		 * the message bundle.
		 * @member {string}
		 * @default "OK"
		 */
		okMsg: messages["ok-button-label"],

		/**
		 * The text displayed in the Cancel button when the combobox popup contains such a button.
		 * The default value is provided by the "cancel-button-label" key of
		 * the message bundle.
		 * @member {string}
		 * @default "Cancel"
		 */
		cancelMsg: messages["cancel-button-label"],

		/**
		 * Displays or not the down arrow button.
		 * @type {boolean}
		 * @default true
		 */
		hasDownArrow: true,

		/**
		 * Source for the inner list.
		 * @type {dstore/Store|decor/ObservableArray|Array} Source set.
		 */
		source: null,

		/**
		 * Minimum number of characters before the dropdown automatically opens.
		 * However, aside the above, depending of its value, the widget behavior changes slightly.
		 * In fact:
		 * - if minFilterChars = 0
		 * -- show the dropdown on pointer down.
		 * -- show the dropdown even if the user clears the input field.
		 * - if minFilterChars = 1
		 * -- do not show the dropdown on pointer down.
		 * -- clearing the input field will close the dropdown.
		 * @type {number}
		 * @default 1
		 */
		minFilterChars: 1,

		/**
		 * Text displayed in the Combobox's `<input>`.
		 * @type {string}
		 */
		displayedValue: "",

		/**
		 * It's `true` if the dropdown should be centered, and returns
		 * `false` if it should be displayed below/above the widget.
		 * It's `true` when the module `deliteful/Combobox/ComboPopup` has
		 * been loaded. Note that the module is loaded conditionally, depending
		 * on the channel has() features set by `deliteful/features`.
		 */
		_isMobile: !!ComboPopup,

		createdCallback: function () {
			// Declarative case (list specified declaratively inside the declarative Combobox)
			var list = this.querySelector("d-list");
			if (list) {
				if (!list.attached) {
					list.addEventListener("customelement-attached", this._attachedlistener = function () {
						list.removeEventListener("customelement-attached", this._attachedlistener);
						this.list = list;
						this.deliver();
					}.bind(this));
				} else {
					this.list = list;
				}
			}

			this.on("click", function () {
				// NOTE: This runs only when in mobile mode
				if (this._isMobile && !this.disabled) {
					this.openDropDown();
				}
			}.bind(this));

			this.on("mousedown", function (evt) {
				// NOTE: This runs only when in desktop mode
				if (!this._isMobile && (!this.minFilterChars || this._inputReadOnly)) {
					// event could be triggered by the down arrow element. If so, we do not react to it.
					if (evt.srcElement !== this.buttonNode && !this.disabled) {
						if (!this.opened) {
							this.openDropDown();
						} else {
							this.closeDropDown(true);
						}
					}
				}
			}.bind(this));
		},

		parseAttribute: dcl.superCall(function (sup) {
			return function (name, value) {
				var capitalize = /f(?=unc$)|a(?=ttr$)/;
				if (/Attr$|Func$/i.test(name)) {
					name = name.toLowerCase();	// needed only on IE9
					name = this._propCaseMap[name] ||
							name.replace(capitalize, capitalize.exec(name)[0].toUpperCase());
					return {
						prop: name,
						value: /Attr$/.test(name) ? value :
							this.parseFunctionAttribute(value, ["item", "store", "value"])
					};
				} else {
					return sup.apply(this, arguments);
				}
			};
		}),

		attachedCallback: function () {
			if (!this.list) {
				var regexp = /^(?!_)(\w)+(?=Attr$|Func$)/;
				var listArgs = {
					showNoItems: true
				};

				// attributes
				this._parsedAttributes.filter(function (attr) {
					return regexp.test(attr.prop);
				}).forEach(function (item) {
					listArgs[item.prop] = item.value;
				}.bind(this));

				// properties
				for (var prop in this) {
					var match = regexp.exec(prop);
					if (match && !(match.input in listArgs)) {
						listArgs[match.input] = this[match.input];
					}
				}

				this.list = new List(listArgs);
				this.deliver();
			}

			if (!this.list.id) {
				this.list.id = this.id ? this.id + "-list" : this.tag + "-" + this.widgetId + "-list";
			}
		},

		postRender: function () {
			this._prepareInput(this.inputNode);
		},

		computeProperties: function (oldValues, justCreated) {
			/* jshint maxcomplexity: 12 */
			// If value was specified as a string (like during creation from markup),
			// but selectionMode === multiple, need to convert it to an array.
			if (this.selectionMode === "multiple" && typeof this.value === "string") {
				this.value = this.value ? this.value.split(",") : [];

				// So computeProperties doesn't get called again and oldValues contains "value"
				// but not "displayedValue", which would trigger code below to run.
				this.discardComputing();
			}

			this._inputReadOnly = this.readOnly || !this.autoFilter ||
				this._isMobile || this.selectionMode === "multiple";

			// Sometimes, especially during creation, the app will specify a value without specifying a displayedValue.
			// In that case, copy this.value to this.displayedValue.  This code is fragile though; need to make
			// sure Combobox itself always sets displayedValue at the same time it sets value.
			var valueChanged = justCreated ? this.hasOwnProperty("_shadowValueAttr") : "value" in oldValues;
			var displayedValueChanged = justCreated ? this.hasOwnProperty("_shadowDisplayedValueAttr") :
				"displayedValue" in oldValues;
			if (valueChanged && !displayedValueChanged) {
				if (this.selectionMode === "single") {
					this.displayedValue = this.value;
				} else {
					var items = this.value;
					var n = items.length;
					if (n > 1) {
						this.displayedValue = string.substitute(this.multipleChoiceMsg, {items: n});
					} else if (n === 1) {
						this.displayedValue = items[0];
					} else {
						this.displayedValue = this.multipleChoiceNoSelectionMsg;
					}
				}

				// Call computeProperties() again to flush out the change record for "displayedValue".
				// That way, all the notifications are processed before the new Combobox() constructor
				// finishes running.
				this.deliverComputing();
			}
		},

		/* jshint maxcomplexity: 17 */
		refreshRendering: function (oldValues) {
			if ("list" in oldValues) {
				this._initList();
			}
			if ("selectionMode" in oldValues) {
				if (this.list) {
					this.list.selectionMode = this.selectionMode === "single" ?
						"radio" : "multiple";
				}
			}
			if ("_inputReadOnly" in oldValues) {
				// Note: Can't just put readonly={{_inputReadOnly}} in the template because we need to override
				// when delite/FormWidget sets the <input>'s readonly attribute based on this.readOnly.
				this.inputNode.readOnly = this._inputReadOnly;
				this._setSelectable(this.inputNode, !this._inputReadOnly);
			}

			// Update <input>'s value if necessary, but don't update the value because the user
			// typed a character into the <input> as that will move the caret to the end of the
			// <input>.
			if ("displayedValue" in oldValues) {
				if (this.displayedValue !== this.inputNode.value) {
					this.inputNode.value = this.displayedValue;
				}
				if (this._popupInput && this.displayedValue !== this._popupInput.value) {
					this._popupInput.value = this.displayedValue;
				}
			}
		},

		/**
		 * Configures inputNode such that the text is selectable or unselectable.
		 * @private
		 */
		_setSelectable: function (inputNode, selectable) {
			if (selectable) {
				inputNode.removeAttribute("unselectable");
				$(inputNode)
					.css("user-select", "") // maps to WebkitUserSelect, etc.
					.off("selectstart", false);
			} else {
				inputNode.setAttribute("unselectable", "on");
				$(inputNode)
					.css("user-select", "none") // maps to WebkitUserSelect, etc.
					.on("selectstart", false);
			}
		},

		afterFormResetCallback: function () {
			if (this.value !== this.valueNode.value) {
				if (this.selectionMode === "single") {
					this.value = this.valueNode.value || "";
				} else if (this.selectionMode === "multiple") {
					this.value = this.valueNode.value ? this.valueNode.value.split(",") : [];
				}

				// computeProperties() will do the wrong thing if it thinks value was set without displayedValue
				// being set.
				this.notifyCurrentValue("displayedValue");
			}
		},

		_initList: function () {
			if (this.list) {
				// TODO
				// This is a workaround waiting for a proper mechanism (at the level
				// of delite/Store - delite/StoreMap) to allow a store-based widget
				// to delegate the store-related functions to a parent widget (delite#323).
				if (!this.list.attached) {
					this.list.attachedCallback();
				}

				// Class added on the list such that Combobox' theme can have a specific
				// CSS selector for elements inside the List when used as dropdown in
				// the combo.
				$(this.list).addClass("d-combobox-list");

				// The drop-down is hidden initially
				$(this.list).addClass("d-hidden");

				// The role=listbox is required for the list part of a combobox by the
				// aria spec of role=combobox
				this.list.type = "listbox";

				this.list.selectionMode = this.selectionMode === "single" ?
					"radio" : "multiple";

				this._initHandlers();
			}
		},

		_initHandlers: function () {
			if (this._ListListeners) {
				this._ListListeners.forEach(function (handle) {
					handle.remove();
				});
			}

			this._ListListeners = [
				this.list.on("keynav-child-navigated", function (evt) {
					var navigatedChild = evt.newValue; // never null
					var rend = this.list.getEnclosingRenderer(navigatedChild);
					var item = rend.item;
					if (this.selectionMode === "single" && !this.list.isSelected(item)) {
						this.list.selectFromEvent(evt, item, rend, true);
					} // else do not change the selection state of an item already selected
					if (evt.triggerEvent && // only for keyboard navigation
						(evt.triggerEvent.type === "keydown" || evt.triggerEvent.type === "keypress")) {
						this._updateScroll(item, true);
					}
					this._setActiveDescendant(navigatedChild);
				}.bind(this)),

				this.list.on("click", function (evt) {
					if (this.selectionMode === "single") {
						var rend = this.list.getEnclosingRenderer(evt.target);
						if (rend && !this.list.isCategoryRenderer(rend)) {
							this.defer(function () {
								// deferred such that the user can see the selection feedback
								// before the dropdown closes.
								this.closeDropDown(true/*refocus*/);
							}.bind(this), 100); // worth exposing a property for the delay?
						}
					}
				}.bind(this)),

				// React to interactive changes of selected items
				this.list.on("selection-change", function () {
					this._validateInput();
					this.handleOnInput(this.value); // emit "input" event
				}.bind(this)),

				this.list.on("query-success", this._setSelectedItems.bind(this))
			];
		},

		/**
		 * Returns the label of a List item renderer.
		 * @private
		 */
		_getItemRendererLabel: function (itemRenderer) {
			return this._getItemLabel(itemRenderer.item);
		},

		/**
		 * Returns the value of a List item renderer. Defaults to its label
		 * if the underlying data item has no value.
		 * @private
		 */
		_getItemRendererValue: function (itemRenderer) {
			return this._getItemValue(itemRenderer.item);
		},

		/**
		 * Returns the label of a List render item.
		 * @private
		 */
		_getItemLabel: function (item) {
			return item.label;
		},

		/**
		 * Returns the value of a List render item. Defaults to its label
		 * if the underlying data item has no value.
		 * @private
		 */
		_getItemValue: function (item) {
			return "value" in item ? item.value : item.label;
		},

		loadDropDown: function () {
			var dropDown = this._isMobile ?
				this.createCenteredDropDown() :
				this.createAboveBelowDropDown();

			this.dropDownPosition = this._isMobile ?
				["center"] :
				["below", "above"]; // this is the default

			// Since the dropdown is not a child of the Combobox, it will not inherit
			// its dir attribute. Hence:
			var dir = this.getAttribute("dir");
			if (dir) {
				dropDown.setAttribute("dir", dir);
			}

			this.dropDown = dropDown; // delite/HasDropDown's property

			if (this._isMobile) {
				// Set correct (initial) value of aria-expanded on ComboPopup <input>.
				this._togglePopupList(dropDown.inputNode);
			}

			return dropDown;
		},

		/**
		 * Factory method which creates the widget used inside above/below drop-down.
		 * The default implementation simply returns `this.list`.
		 * @protected
		 */
		createAboveBelowDropDown: function () {
			// Use the List itself as content of the popup. Embedding it in a
			// LinearLayout has seemed useful for solving layout issues on iOS
			// (deliteful issue #270), but appears to be harmful on IE11 (deliteful
			// issue #382). Hence the List is not wrapped anymore inside a LinearLayout.
			return this.list;
		},

		/**
		 * Factory method which creates the widget used inside centered drop-down.
		 * The default implementation returns a new instance of deliteful/Combobox/ComboPopup
		 * (the present widget is set for its `combobox` property).
		 * The method can be overridden in order to create a subclass of ComboPopup (for
		 * specifying a custom template, for instance).
		 * @protected
		 */
		createCenteredDropDown: function () {
			return new ComboPopup({combobox: this});
		},

		/**
		 * Toggles the popup's visibility.
		 * If in mobile, toggles list visibility.
		 * If in desktop, closes or opens the popup.
		 */
		_togglePopupList: function (inputElement, suppressChangeEvent) {
			// Compute whether or not to show the list.  Note that in mobile mode ComboPopup doesn't display a
			// down arrow icon to manually show/hide the list, so on mobile,
			// if the Combobox has a down arrow icon, the list is always shown.
			var showList = inputElement.value.length >= this.minFilterChars ||
				(this._isMobile && this.hasDownArrow);
			if (this._isMobile) {
				// Mobile version.
				if (showList) {
					this.filter(inputElement.value);
				}
				this.list.setAttribute("d-shown", "" + showList);
				if (this.dropDown) {
					this.dropDown.inputNode.setAttribute("aria-expanded", "" + showList);
					this.list.emit("delite-size-change");
				}
			} else {
				// Desktop version.
				if (showList) {
					this.openDropDown();
				} else {
					this.closeDropDown(true /*refocus*/, suppressChangeEvent);
				}
			}
		},

		/**
		 * True iff the `<input>`'s value was set by user typing.
		 * We only filter the dropdown list when the value was set by the user typing into the `<input>`,
		 * and specifically avoid filtering the list to a single item when the user selects an item from
		 * list and then reopens the dropdown.
		 */
		_valueSetByUserInput: false,

		_setValueAttr: function (val) {
			if (val !== this.value) {
				this._set("value", val);
				this._valueSetByUserInput = false;
			}
		},
			
		/**
		 * Defines the milliseconds the widget has to wait until a new filter operation starts.
		 * @type {Number}
		 * @default 0
		 */
		filterDelay: 0,

		_prepareInput: function (inputElement) {
			this.on("input", function (evt) {
				// TODO
				// Would be nice to also have an "incrementalFilter" boolean property.
				// On desktop, this would allow to redo the filtering only for "change"
				// events, triggered when pressing ENTER. This would also fit for Chrome/Android,
				// where pressing the search key of the virtual keyboard also triggers a
				// change event. But there's no equivalent on Safari / iOS...

				// save what user typed at each keystroke.
				this.value = this.displayedValue = inputElement.value;
				this._valueSetByUserInput = true;
				this.handleOnInput(this.value); // emit "input" event.

				if (this._timeoutHandle !== undefined) {
					this._timeoutHandle.remove();
					delete this._timeoutHandle;
				}
				this._timeoutHandle = this.defer(function () {
					// Note: set suppressChangeEvent=true because we shouldn't get a change event because
					// the dropdown closed just because the user backspaced while typing in the <input>.
					this._togglePopupList(inputElement, true);
				}.bind(this), this.filterDelay);

				// Stop the spurious "input" events emitted while the user types
				// such that only the "input" events emitted via FormValueWidget.handleOnInput()
				// bubble to widget's root node.
				evt.stopPropagation();
				evt.preventDefault();
			}.bind(this), inputElement);
			this.on("change", function (evt) {
				// Stop the spurious "change" events emitted while the user types
				// such that only the "change" events emitted via FormValueWidget.handleOnChange()
				// bubble to widget's root node.
				evt.stopPropagation();
				evt.preventDefault();
			}.bind(this), inputElement);
			this.on("keydown", function (evt) {
				/* jshint maxcomplexity: 16 */
				// deliteful issue #382: prevent the browser from navigating to
				// the previous page when typing backspace in a readonly input
				if (inputElement.readOnly && evt.key === "Backspace") {
					evt.stopPropagation();
					evt.preventDefault();
				} else if (evt.key === "Enter") {
					evt.stopPropagation();
					evt.preventDefault();
					if (this.opened) {
						this.closeDropDown(true/*refocus*/);
					}
				} else if (evt.key === "Spacebar" && this.opened) {
					// Simply forwarding the key event to List doesn't allow toggling
					// the selection, because List's mechanism is based on the event target
					// which here is the input element outside the List. TODO: see deliteful #500.
					if (this.selectionMode === "multiple") {
						var rend = this.list.getEnclosingRenderer(this.list.navigatedDescendant);
						if (rend) {
							this.list.selectFromEvent(evt, rend.item, rend, true);
						}
					}
					if (this.selectionMode === "multiple" || !this.autoFilter) {
						evt.stopPropagation();
						evt.preventDefault();
					}
				} else if (evt.key === "ArrowDown" || evt.key === "ArrowUp" ||
					evt.key === "PageDown" || evt.key === "PageUp" ||
					evt.key === "Home" || evt.key === "End") {
					if (this._isMobile) {
						this.list.emit("keydown", evt);
					}
					evt.stopPropagation();
					evt.preventDefault();
				}
			}.bind(this), inputElement);
		},

		_validateInput: function () {
			if (this.selectionMode === "single") {
				this._validateSingle();
			} else {
				this._validateMultiple();
			}
		},

		_validateSingle: function () {
			var selectedItem = this.list.selectedItem;
			// selectedItem non-null because List in radio selection mode, but
			// the List can be empty, so:
			this.displayedValue = selectedItem ? this._getItemLabel(selectedItem) : "";
			this.value = selectedItem ? this._getItemValue(selectedItem) : "";

			// If user selects a choice from the dropdown with the same label as what's
			// currently typed into the <input>, make sure computeProperties() doesn't set
			// the <input> to the item's value (ex: "DE" rather than "Germany").
			this.notifyCurrentValue("displayedValue");
		},

		_validateMultiple: function () {
			var n;
			var selectedItems = this.list.selectedItems;
			n = selectedItems ? selectedItems.length : 0;
			var value = [];
			if (n > 1) {
				this.displayedValue = string.substitute(this.multipleChoiceMsg, {items: n});
				for (var i = 0; i < n; i++) {
					value.push(selectedItems[i] ? this._getItemValue(selectedItems[i]) : "");
				}
			} else if (n === 1) {
				var selectedItem = this.list.selectedItem;
				this.displayedValue = this._getItemLabel(selectedItem);
				value.push(this._getItemValue(selectedItem));
			} else { // no option selected
				this.displayedValue = this.multipleChoiceNoSelectionMsg;
			}

			// Only set this.value if the value has changed.  Otherwise it's a spurious
			// notification.  Stateful doesn't detect that two arrays are deep-equal because
			// ["foo"] !== ["foo"]
			if (!this.value || this.value.join(",") !== value.join(",")) {
				this.value = value;
			}

			// FormWidget.refreshRendering() also updates valueNode.value, but we need to
			// make sure this is already done when FormValueWidget.handleOnInput() runs.
			this.valueNode.value = value.toString();
			this.handleOnInput(this.value); // emit "input" event
		},

		/**
		 * Filters the embedded List to only show the items matching `filterTxt`.
		 * If `autoFilter` is `true` and `selectionMode` is `"single"`, the method
		 * is called automatically while the user types into the editable input
		 * element, with `filterTxt` being the currently entered text.
		 * @protected
		 */
		filter: function (inputText) {
			if (!this.autoFilter || inputText.length === 0 || !this._valueSetByUserInput) {
				// Display the full list.
				this.list.query = this._getDefaultQuery();
			} else {
				// Display the list filtered by what user typed into <input>.

				// Escape special chars in search string, see
				// http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex.
				var filterTxt = inputText.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
				if (this.filterMode === "startsWith") {
					filterTxt = "^" + filterTxt;
				} else if (this.filterMode === "is") {
					filterTxt = "^" + filterTxt + "$";
				} // nothing to add for "contains"

				var rexExp = new RegExp(filterTxt, this.ignoreCase ? "i" : "");
				this.list.query = this.getQuery({
					rexExp: rexExp,
					inputText: inputText
				});
			}

			if (this.source) {
				this.list.source = this.source;
			}
		},

		/**
		 * Sets the new list's query.
		 * This method can be overridden when using other store types.
		 * The default implementation uses `dstore/Filter.match()`.
		 * The matching is performed against the `list.labelAttr` or `list.labelFunc` attributes of
		 * the data store items.
		 * The method can be overridden for implementing other filtering strategies.
		 * @protected
		 * @param  {Object.<string, Object>} args Dictionary containing by default
		 * the regular expression and the original input text.
		 * @returns {Object} New query to set to the list.
		 */
		getQuery: function (args) {
			return (new Filter()).match(this.list.labelAttr || this.list.labelFunc, args.rexExp);
		},

		/**
		 * Consists in the default query to apply to the source.
		 * It can be a `function` or a `Object`.
		 * If it is a function, then it's invoked and the list's query will get the return value.
		 * If it is an Object, it's assigned to the list's query directly.
		 * It can be overridden depending of store used and the strategy to apply.
		 */
		defaultQuery: {},

		_getDefaultQuery: function () {
			return (typeof this.defaultQuery === "function") ?
				this.defaultQuery() : this.defaultQuery;
		},

		_setSelectedItems: function () {
			if (this.list.source && this.list.renderItems && this.value !== "") {
				var selectedItems = [],
					presetItems = this.value instanceof Array && this.value.length >= 1 ? this.value : [this.value];
				selectedItems = this.list.renderItems.filter(function (renderItem) {
					return presetItems.indexOf(this._getItemValue(renderItem)) >= 0;
				}.bind(this));

				this.list.selectedItems = selectedItems;
				if (selectedItems.length) {
					this._validateInput();
				}
			}
		},

		openDropDown: dcl.superCall(function (sup) {
			return function () {
				if (this._isMobile) {
					// We are opening the ComboPopup but may or may not want to show the list.
					// TogglePopupList will decide the right thing to do.
					this._togglePopupList(this.inputNode);
				} else {
					// On desktop, we definitely want to display the list.
					// Adjust the dropdown contents to be filtered by the current value of the <input>.
					this.filter(this.inputNode.value);
				}

				this._setSelectedItems();

				if (!this.opened) {
					// On desktop, leave focus in the original <input>.  But on mobile, focus the popup dialog.
					this.focusOnPointerOpen = this.focusOnKeyboardOpen = this._isMobile;

					if (!this._isMobile) {
						this.defer(function () {
							// Avoid losing focus when clicking the arrow (instead of the input element):
							// TODO: isn't this already handled by delite/HasDropDown#_dropDownPointerUpHandler() ?
							this.focusNode.focus();
						}.bind(this), 300);
					}
				}

				var promise = sup.apply(this, arguments);

				return promise.then(function () {
					// Avoid that List gives focus to list items when navigating, which would
					// blur the input field used for entering the filtering criteria.
					this.dropDown.focusDescendants = false;
					if (!this._isMobile) {
						// desktop version
						this._updateScroll(undefined, true);	// sets this.list.navigatedDescendant
						this._setActiveDescendant(this.list.navigatedDescendant);
					} else {
						if (this.hasDownArrow) {
							this.dropDown.inputNode.value = this.displayedValue;
						}
						this.dropDown.focus();
					}
				}.bind(this));
			};
		}),

		closeDropDown: dcl.superCall(function (sup) {
			return function (focus, suppressChangeEvent) {
				var input = this._popupInput || this.inputNode;
				input.removeAttribute("aria-activedescendant");

				// Closing the dropdown represents a commit interaction, unless the dropdown closes
				// automatically because the user backspaced, in which case suppressChangeEvent is true.
				if (!suppressChangeEvent) {
					this.handleOnChange(this.value); // emit "change" event
				}

				sup.apply(this, arguments);
			};
		}),

		// HasDropDown#_dropDownKeyUpHandler() override.
		// Do not call openDropDown if widget does not have a down arrow shown (auto-complete mode).
		// In this mode the popup will open when the user typed something and text.length > this.minFilterChars.
		_dropDownKeyUpHandler: dcl.superCall(function (sup) {
			return function () {
				if (this.hasDownArrow) {
					sup.call(this);
				}
			};
		}),

		/**
		 * Scrolls the list inside the popup such that the specified item, or
		 * the first selected item if no item is specified, is visible.
		 * @private
		 */
		_updateScroll: function (item, navigate) {
			// Since List is in focus-less mode, it does not give focus to
			// navigated items, thus the browser does not autoscroll.
			// TODO: see deliteful #498

			if (!item) {
				var selectedItems = this.list.selectedItems;
				item = selectedItems && selectedItems.length > 0 ?
					selectedItems[0] : null;
			}
			if (item) {
				// Make the first selected item (if any) visible.
				// Must be done after sup.apply, because List.getBottomDistance
				// relies on dimensions which are not available if the DOM nodes
				// are not (yet) visible, hence the popup needs to be shown before.
				var id = this.list.getIdentity(item);
				var renderer = this.list.getRendererByItemId(id);
				if (renderer) {
					this.list.scrollBy({y: this.list.getBottomDistance(renderer)});
					if (navigate) {
						this.list.navigatedDescendant = renderer.renderNode;
					}
				} // null if the list is empty because no item matches the auto-filtering
			}
		},

		_setActiveDescendant: function (nd) {
			if (nd) {
				if (!nd.id) {
					nd.id = "d-combobox-item-" + idCounter++;
				}

				var input = this._popupInput || this.inputNode;
				input.setAttribute("aria-activedescendant", nd.id);
			}
		}
	});
});
;
define('delite/handlebars!deliteful/Combobox/ComboPopup.html',["delite/handlebars","deliteful/LinearLayout","deliteful/Button"], function(handlebars){
	return handlebars.compile("<template role=\"presentation\">\n\t<d-linear-layout style=\"height: 100%\">\n\t\t<label class=\"d-combo-popup-header\" for=\"{{_tag}}-{{widgetId}}-input\">{{header}}</label>\n\t\t<input id=\"{{_tag}}-{{widgetId}}-input\" d-hidden=\"{{!(this.combobox.autoFilter &amp;&amp; this.combobox.selectionMode !== 'multiple')}}\" attach-point=\"inputNode\" class=\"d-combobox-input\" role=\"combobox\" autocomplete=\"off\" autocapitalize=\"none\" autocorrect=\"off\" aria-autocomplete=\"list\" aria-haspopup=\"true\" aria-owns=\"{{combobox.list.id}}\" type=\"text\" placeholder=\"{{combobox.searchPlaceHolder}}\">\n\t\t<div attach-point=\"listNode\"></div>\n\t\t<d-linear-layout d-hidden=\"{{combobox.selectionMode !== 'multiple'}}\" vertical=\"false\">\n\t\t\t<button is=\"d-button\" class=\"fill d-combo-cancel-button\" label=\"{{combobox.cancelMsg}}\" on-click=\"{{cancelHandler}}\"></button>\n\t\t\t<button is=\"d-button\" class=\"fill d-combo-ok-button\" label=\"{{combobox.okMsg}}\" on-click=\"{{okHandler}}\"></button>\n\t\t</d-linear-layout>\n\t</d-linear-layout>\n</template>");
});;
/** @module deliteful/Combobox/ComboPopup */
define('deliteful/Combobox/ComboPopup',[
	"delite/register",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass()
	"delite/Dialog",
	"delite/handlebars!./ComboPopup.html"
], function (register, $, Dialog, template) {
	/**
	 * Auxiliary widget used in some cases by deliteful/Combobox for displaying
	 * a popup containing conditionally a search field and OK/Cancel buttons.
	 * This widget is intended for being instantiated only by deliteful/Combobox;
	 * it should not be instantiated directly.  If needed, its template
	 * (deliteful/Combobox/ComboPopup.html) can be customized.
	 * @class module:deliteful/Combobox/ComboPopup
	 * @augments module:delite/Widget
	 */
	return register("d-combo-popup", [HTMLElement, Dialog], /** @lends module:deliteful/Combobox/ComboPopup# */ {

		baseClass: "d-combo-popup",

		template: template,

		/**
		 * The instance of `deliteful/Combobox` for which this widget is used.
		 * This property is set by Combobox when creating the popup, and it
		 * is used in the template of ComboPopup for accessing the properties
		 * of the Combobox.
		 * @member {boolean} module:deliteful/Combobox/ComboPopup#combobox
		 * @default null
		 * @protected
		 */
		combobox: null,

		/**
		 * Popup's header, to remind user what the popup is for (since it likely covers up the original label).
		 */
		header: "",

		computeProperties: function (oldValues) {
			if ("combobox" in oldValues) {
				// Find Combobox's label and use it as my header.
				var combobox = this.combobox;
				var headerNode = (combobox.focusNode.id &&
					this.ownerDocument.querySelector("label[for=" + combobox.focusNode.id + "]")) ||
					(combobox.hasAttribute("aria-labelledby") &&
					this.ownerDocument.getElementById(combobox.getAttribute("aria-labelledby")));
				this.header = headerNode ? headerNode.textContent.trim() : (combobox.getAttribute("aria-label") || "");
			}
		},

		refreshRendering: function (oldValues) {
			if ("combobox" in oldValues) {
				if (this.combobox) {
					var list = this.combobox.list;
					if (list) {
						list.placeAt(this.listNode, "replace");
						$(list).addClass("fill")
							.removeClass("d-hidden");
					}
					this.combobox._prepareInput(this.inputNode);
				}
			}
		},

		/**
		 * Called when clicking the OK button of the popup.
		 * @protected
		 */
		okHandler: function () {
			// NOTE: no need to validate since it's handled by the `selection-change` listener
			this.combobox.closeDropDown();
		},

		/**
		 * Called when clicking the Cancel button of the popup.
		 * @protected
		 */
		cancelHandler: function () {
			// INFO: resetting any selected items.
			this.combobox.list.selectedItems = [];
			this.combobox.closeDropDown();
			// cont: then ask to validate, so widget's value and inputNode get updated as well.
			this.combobox._validateMultiple(true);
		},

		/**
		 * Called by HasDropDown in order to get the focus on the widget's list.
		 * @protected
		 */
		focus: function () {
			if (this.combobox.autoFilter && this.combobox.selectionMode === "single") {
				this.inputNode.focus();
			} else {
				// first check if list is not hidden.
				if (!$(this.combobox.list).hasClass("d-hidden")
						&& this.combobox.list && this.combobox.list.containerNode.children.length > 0) {
					var id = this.combobox.list.getIdentity(
						this.combobox.list.selectedItems.length > 0 ? this.combobox.list.selectedItems[0] : "");
					var renderer = (id && id !== -1) ? this.combobox.list.getRendererByItemId(id) :
						this.combobox.list.getItemRendererByIndex(0);
					this.combobox.list.navigateTo(renderer);
				}
			}

		}
	});
});
;
/** @module delite/Dialog */
define('delite/Dialog',[
	"dcl/dcl",
	"./a11y",
	"./Widget"
], function (dcl, a11y, Widget) {
	/**
	 * Base class for modal dialogs, where tabbing from the last element loops to the first, and vice-versa.
	 * @mixin module:delite/Dialog
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** @lends module:delite/Dialog# */ {
		createdCallback: function () {
			this.on("keydown", this._dialogKeyDownHandler.bind(this));
		},

		focus: function () {
			// Focus on first field.
			this._getFocusItems();
			if (this._firstFocusItem && this._firstFocusItem !== this) {
				this._firstFocusItem.focus();
			}
		},

		/**
		 * Finds focusable items in dialog,
		 * and sets `this._firstFocusItem` and `this._lastFocusItem`.
		 *
		 * @protected
		 */
		_getFocusItems: function () {
			var elems = a11y._getTabNavigable(this);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		},

		_dialogKeyDownHandler: function (/*Event*/ evt) {
			if (evt.key === "Tab") {
				this._getFocusItems(this);
				var node = evt.target;
				if (this._firstFocusItem === this._lastFocusItem) {
					// don't move focus anywhere, but don't allow browser to move focus off of dialog either
					evt.preventDefault();
				} else if (node === this._firstFocusItem && evt.shiftKey) {
					// if we are shift-tabbing from first focusable item in dialog, send focus to last item
					this._lastFocusItem.focus();
					evt.preventDefault();
				} else if (node === this._lastFocusItem && !evt.shiftKey) {
					// if we are tabbing from last focusable item in dialog, send focus to first item
					this._firstFocusItem.focus();
					evt.preventDefault();
				}

				// In any case, call stopPropagation() so the popup.js doesn't see the TAB and close the Dialog.
				evt.stopPropagation();
			}
		}
	});
});
;
/** @module delite/HasDropDown */
define('delite/HasDropDown',[
	"dcl/dcl",
	"requirejs-dplugins/Promise!",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass(), removeClass(), hasClass()
	"./place",
	"./popup",
	"./register",
	"./Widget",
	"./activationTracker",		// for delite-deactivated event
	"dpointer/events"		// for "pointerenter", "pointerleave"
], function (dcl, Promise, $, place, popup, register, Widget) {
	
	/**
	 * Dispatched before popup widget is shown.
	 * @example
	 * document.addEventListener("delite-before-show", function (evt) {
	 *      console.log("about to show popup", evt.child);
	 * });
	 * @event module:delite/HasDropDown#delite-before-show
	 * @property {Element} child - reference to popup
	 */
	
	/**
	 * Dispatched after popup widget is shown.
	 * @example
	 * document.addEventListener("delite-after-show", function (evt) {
	 *      console.log("just displayed popup", evt.child);
	 * });
	 * @event module:delite/HasDropDown#delite-after-show
	 * @property {Element} child - reference to popup
	 */

	/**
	 * Dispatched before popup widget is hidden.
	 * @example
	 * document.addEventListener("delite-before-hide", function (evt) {
	 *      console.log("about to hide popup", evt.child);
	 * });
	 * @event module:delite/HasDropDown#delite-before-hide
	 * @property {Element} child - reference to popup
	 */
	
	/**
	 * Dispatched after popup widget is hidden.
	 * @example
	 * document.addEventListener("delite-after-hide", function (evt) {
	 *      console.log("just hid popup", evt.child);
	 * });
	 * @event module:delite/HasDropDown#delite-after-hide
	 * @property {Element} child - reference to popup
	 */
	
	/**
	 * Base class for widgets that need drop down ability.
	 * @mixin module:delite/HasDropDown
	 * @augments module:delite/Widget
	 */
	var HasDropDown = dcl(Widget, /** @lends module:delite/HasDropDown# */ {
		/**
		 * If specified, defines a node to set up the dropdown-opening behavior on,
		 * rather than the HasDropDown node itself.
		 * @member {Element}
		 * @protected
		 */
		behaviorNode: null,

		/**
		 * The button/icon/node to click to display the drop down.
		 * Useful for widgets like Combobox which contain an `<input>` and a
		 * down arrow icon, and only clicking the icon should open the drop down.
		 * If undefined, click handler set up on `this.behaviorNode` (if defined),
		 * or otherwise on `this`.
		 * @member {Element}
		 * @protected
		 */
		buttonNode: null,

		/**
		 * The widget to display as a popup.  Applications/subwidgets should *either*:
		 *
		 * 1. define this property
		 * 2. override `loadDropDown()` to return a dropdown widget or Promise for one
		 * 3. listen for a `delite-display-load` event, and then call event.setChild() with an Object like
		 *    `{child: dropDown}` or a Promise for such an Object
		 * @member {Element}
		 */
		dropDown: null,

		/**
		 * If true, make the drop down at least as wide as this widget.
		 * If false, leave the drop down at its default width.
		 * Has no effect when `dropDownPosition = ["center"]`.
		 * @member {boolean}
		 * @default true
		 */
		autoWidth: true,

		/**
		 * If true, make the drop down exactly as wide as this widget.  Overrides `autoWidth`.
		 * Has no effect when `dropDownPosition = ["center"]`.
		 * @member {boolean}
		 * @default false
		 */
		forceWidth: false,

		/**
		 * The maximum height for our dropdown.
		 * Any dropdown taller than this will have a scroll bar.
		 * Set to 0 for no max height, or -1 to limit height to available space in viewport.
		 * @member {number}
		 * @default -1
		 */
		maxHeight: -1,

		/**
		 * Controls the position of the drop down.
		 * It's an array of strings with the following values:
		 *
		 * - before: places drop down to the left of the target node/widget, or to the right in
		 * the case of RTL scripts like Hebrew and Arabic
		 * - after: places drop down to the right of the target node/widget, or to the left in
		 * the case of RTL scripts like Hebrew and Arabic
		 * - above: drop down goes above target node
		 * - below: drop down goes below target node
		 * - center: drop down is centered on the screen, like a dialog; when used, this should be
		 *   the only choice in the array
		 *
		 * The positions are tried, in order, until a position is found where the drop down fits
		 * within the viewport.
		 *
		 * @member {string[]}
		 * @default ["below", "above"]
		 */
		dropDownPosition: ["below", "above"],

		/**
		 * Focus the popup when opened by mouse or touch.  This flag should generally be left as `true` unless
		 * the popup is a menu.  Usually drop down menus don't get focus unless opened by the keyboard.
		 * @member {boolean}
		 * @default true
		 */
		focusOnPointerOpen: true,

		/**
		 * Focus the popup when opened by the keyboard.  This flag should be left as `true` except for widgets
		 * like Combobox where the focus is meant to always remain on the HasDropDown widget itself.
		 * @member {boolean}
		 * @default true
		 */
		focusOnKeyboardOpen: true,

		/**
`		 * Make the popup open just by hovering, and close when the user stops hovering this node
		 * and its popup.
		 * @member {boolean}
		 * @default false
		 */
		openOnHover: false,

		/**
		 * Whether or not the drop down is open.
		 * @member {boolean}
		 * @readonly
		 */
		opened: false,

		/**
		 * Callback when the user clicks the arrow icon.
		 * @private
		 */
		_dropDownClickHandler: function (e) {
			e.preventDefault();
			e.stopPropagation();

			if (this.disabled || this.readOnly) {
				return;
			}

			this.toggleDropDown();

			if (this._openDropDownPromise) {
				// Test if this is a fake mouse event caused by the user typing
				// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
				var keyboard = e.pointerType === "mouse" && !this.hovering;

				// Focus the drop down once it opens, unless it's a menu.
				this._focusDropDownOnOpen(keyboard);
			} else {
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// defer() needed to make it work on IE (test DateTextBox)
				if (this.focus) {
					this.defer(this.focus);
				}
			}
		},

		/**
		 * Helper function to focus the dropdown when it finishes loading and opening,
		 * based on `focusOnPointerOpen` and `focusOnKeyboardOpen` properties.
		 * @param {boolean} keyboard - True if the user opened the dropdown via the keyboard
		 */
		_focusDropDownOnOpen: function (keyboard) {
			this._openDropDownPromise.then(function (ret) {
				var dropDown = ret.dropDown;
				if (dropDown.focus && (keyboard ? this.focusOnKeyboardOpen : this.focusOnPointerOpen)) {
					this._focusDropDownTimer = this.defer(function () {
						dropDown.focus();
						delete this._focusDropDownTimer;
					});
				}
			}.bind(this));
		},

		preRender: function () {
			// Remove old listeners if we are re-rendering, just in case some of the listeners were put onto
			// the root node.  We don't want to make duplicate listeners.
			if (this._HasDropDownListeners) {
				this._HasDropDownListeners.forEach(function (handle) {
					handle.remove();
				});
			}
		},

		postRender: function () {
			this.behaviorNode = this.behaviorNode || this;
			this.buttonNode = this.buttonNode || this.behaviorNode;
			this.popupStateNode = this.focusNode || this.buttonNode;

			this.popupStateNode.setAttribute("aria-haspopup", "true");

			this._HasDropDownListeners = [
				// basic listeners
				this.on("click", this._dropDownClickHandler.bind(this), this.buttonNode),
				this.on("keydown", this._dropDownKeyDownHandler.bind(this), this.focusNode || this.behaviorNode),
				this.on("keyup", this._dropDownKeyUpHandler.bind(this), this.focusNode || this.behaviorNode),

				this.on("delite-deactivated", this._deactivatedHandler.bind(this), this.behaviorNode),

				// set this.hovering when mouse is over widget so we can differentiate real mouse clicks from synthetic
				// mouse clicks generated from JAWS upon keyboard events
				this.on("pointerenter", function () {
					this.hovering = true;
				}.bind(this), this.behaviorNode),
				this.on("pointerleave", function () {
					this.hovering = false;
				}.bind(this), this.behaviorNode)
			];

			if (this.openOnHover) {
				this._HasDropDownListeners.push(
					this.on("delite-hover-activated", function () {
						this.openDropDown();
					}.bind(this), this.buttonNode),
					this.on("delite-hover-deactivated", function () {
						this.closeDropDown();
					}.bind(this), this.buttonNode)
				);
			}
		},

		detachedCallback: function () {
			// If dropdown is open, close it, to avoid leaving delite/activationTracker in a strange state.
			// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
			if (this.opened) {
				this.closeDropDown(true);
			}

			if (this._previousDropDown) {
				popup.detach(this._previousDropDown);
				delete this._previousDropDown;
			}
		},

		destroy: function () {
			if (this.dropDown) {
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if (!this.dropDown._destroyed) {
					this.dropDown.destroy();
				}
				delete this.dropDown;
			}
		},

		/**
		 * Callback when the user presses a key while focused on the button node.
		 * @param {Event} e
		 * @private
		 */
		_dropDownKeyDownHandler: function (e) {
			/* jshint maxcomplexity:18 */

			if (this.disabled || this.readOnly) {
				return;
			}
			var dropDown = this._currentDropDown, target = e.target;
			if (dropDown && this.opened) {
				// Forward the keystroke to the dropdown widget.
				// deliteful/List (the dropdown for deliteful/Combobox)
				// listens for events on List#containerNode rather than the List root node.
				var forwardNode = dropDown.keyNavContainerNode || dropDown.containerNode || dropDown;
				if (dropDown.emit("keydown", e, forwardNode) === false) {
					/* false return code means that the drop down handled the key */
					e.stopPropagation();
					e.preventDefault();
					return;
				}
			}
			if (dropDown && this.opened && e.key === "Escape") {
				this.closeDropDown();
				e.stopPropagation();
				e.preventDefault();
			} else if (!this.opened &&
				(e.key === "ArrowDown" ||
					// ignore unmodified SPACE if KeyNav has search in progress
					((e.key === "Enter" || (e.key === "Spacebar" &&
						(!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
						//ignore enter and space if the event is for a text input
						((target.tagName || "").toLowerCase() !== "input" ||
							(target.type && target.type.toLowerCase() !== "text"))))) {
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events.
				this._openOnKeyUp = true;
				e.stopPropagation();
				e.preventDefault();
			}
		},

		/**
		 * Callback when the user releases a key while focused on the button node.
		 * @param {Event} e
		 * @private
		 */
		_dropDownKeyUpHandler: function () {
			if (this._openOnKeyUp) {
				delete this._openOnKeyUp;
				this.openDropDown();
				this._focusDropDownOnOpen(true);
			}
		},

		_deactivatedHandler: function () {
			// Called when focus has shifted away from this widget and its dropdown.

			// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
			// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
			// popup the keyboard on mobile.
			this.closeDropDown(false);
		},

		/**
		 * Creates/loads the drop down.
		 * Returns a Promise for the dropdown, or if loaded synchronously, the dropdown itself.
		 *
		 * Applications must either:
		 *
		 * 1. set the `dropDown` property to point to the dropdown (as an initialisation parameter)
		 * 2. override this method to create custom drop downs on the fly, returning a reference or promise
		 *    for the dropdown
		 * 3. listen for a `delite-display-load` event, and then call event.setChild() with an Object like
		 *    `{child: dropDown}` or a Promise for such an Object
		 *
		 * With option (2) or (3) the application is responsible for destroying the dropdown.
		 *
		 * @returns {Element|Promise} Element or Promise for the dropdown
		 * @protected
		 * @fires module:delite/DisplayContainer#delite-display-load
		 */
		loadDropDown: function () {
			if (this.dropDown) {
				return this.dropDown;
			} else {
				// tell app controller we are going to show the dropdown; it must return a pointer to the dropdown
				var dropdown;
				this.emit("delite-display-load", {
					setChild: function (val) { dropdown = val; }
				});
				return Promise.resolve(dropdown).then(function (value) { return value.child; });
			}
		},

		/**
		 * Toggle the drop-down widget; if it is open, close it, if not, open it.
		 * Called when the user presses the down arrow button or presses
		 * the down arrow key to open/close the drop down.
		 * @protected
		 */
		toggleDropDown: function () {
			if (this.disabled || this.readOnly) {
				return;
			}
			if (!this.opened) {
				return this.openDropDown();
			} else {
				return this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
			}
		},

		/**
		 * Creates the drop down if it doesn't exist, loads the data
		 * if there's an href and it hasn't been loaded yet, and
		 * then opens the drop down.  This is basically a callback when the
		 * user presses the down arrow button to open the drop down.
		 * @returns {Promise} Promise for the drop down widget that fires when drop down is created and loaded.
		 * @protected
		 * @fires module:delite/HasDropDown#delite-before-show
		 * @fires module:delite/HasDropDown#delite-after-show
		 */
		openDropDown: function () {
			// If openDropDown() has already been called, don't do anything
			if (this._openDropDownPromise) {
				return this._openDropDownPromise;
			}

			// will be set to true if closeDropDown() is called before the loadDropDown() promise completes
			var canceled;

			var loadDropDownPromise = this.loadDropDown();

			this._openDropDownPromise = Promise.resolve(loadDropDownPromise).then(function (dropDown) {
				if (this._previousDropDown && this._previousDropDown !== dropDown) {
					popup.detach(this._previousDropDown);
					delete this._previousDropDown;
				}

				if (canceled) { return; }
				delete this._cancelPendingDisplay;

				this._currentDropDown = dropDown;
				var behaviorNode = this.behaviorNode,
					self = this;

				this.emit("delite-before-show", {
					child: dropDown,
					cancelable: false
				});

				// Generate id for anchor if it's not already specified
				if (!this.id) {
					this.id = "HasDropDown_" + this.widgetId;
				}

				dropDown._originalStyle = dropDown.style.cssText;

				// Set width of drop down if necessary, so that dropdown width [including scrollbar]
				// matches width of behaviorNode.  Don't do anything for when dropDownPosition=["center"] though,
				// in which case popup.open() doesn't return a value.
				if (this.dropDownPosition[0] !== "center") {
					if (this.forceWidth) {
						dropDown.style.width = behaviorNode.offsetWidth + "px";
					} else if (this.autoWidth) {
						dropDown.style.minWidth = behaviorNode.offsetWidth + "px";
					}
				}

				var retVal = popup.open({
					parent: behaviorNode,
					popup: dropDown,
					around: behaviorNode,
					orient: this.dropDownPosition,
					maxHeight: this.maxHeight,
					onExecute: function () {
						self.closeDropDown(true);
					},
					onCancel: function () {
						self.closeDropDown(true);
					},
					onClose: function () {
						$(self.popupStateNode).removeClass("d-drop-down-open");
						this.opened = false;
					}
				});

				$(this.popupStateNode).addClass("d-drop-down-open");
				this.opened = true;

				this.popupStateNode.setAttribute("aria-owns", dropDown.id);

				// Set aria-labelledby on dropdown if it's not already set to something more meaningful
				if (dropDown.getAttribute("role") !== "presentation" && !dropDown.getAttribute("aria-labelledby")) {
					dropDown.setAttribute("aria-labelledby", this.behaviorNode.id);
				}

				this.emit("delite-after-show", {
					child: dropDown,
					cancelable: false
				});

				return {
					dropDown: dropDown,
					position: retVal
				};
			}.bind(this));

			// Setup a hook for closeDropDown() to abort an in-progress showDropDown() operation.
			this._cancelPendingDisplay = function () {
				if (loadDropDownPromise.cancel) { loadDropDownPromise.cancel(); }
				canceled = true;
				delete this._cancelPendingDisplay;
				delete this._openDropDownPromise;
			}.bind(this);

			return this._openDropDownPromise;
		},

		/**
		 * Closes the drop down on this widget.
		 * @param {boolean} [focus] - If true, refocus this widget.
		 * @protected
		 * @fires module:delite/HasDropDown#delite-before-hide
		 * @fires module:delite/HasDropDown#delite-after-hide
		 */
		closeDropDown: function (focus) {
			var dropdown = this._currentDropDown;

			if (this._cancelPendingDisplay) {
				this._cancelPendingDisplay();
			}
			if (this._openDropDownPromise) {
				delete this._openDropDownPromise;
			}

			if (this._focusDropDownTimer) {
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if (this.opened) {
				if (focus && this.behaviorNode.focus) {
					this.behaviorNode.focus();
				}

				this.emit("delite-before-hide", {
					child: dropdown,
					cancelable: false
				});

				popup.close(dropdown);
				this.opened = false;

				// Restore original height/width etc.  But don't put back display:none.
				// That is handled by the popup wrapper.
				dropdown.style.cssText = dropdown._originalStyle;
				if (dropdown.style.display === "none") {
					dropdown.style.display = "";
				}
				if (dropdown.style.visibility === "hidden") {
					dropdown.style.visibility = "";
				}

				this.emit("delite-after-hide", {
					child: dropdown,
					cancelable: false
				});
			}

			// Avoid complaint about aria-owns pointing to hidden element.
			this.popupStateNode.removeAttribute("aria-owns");

			this._previousDropDown = this._currentDropDown;
			delete this._currentDropDown;
		}
	});

	/**
	 * Widget to setup HasDropDown behavior on an arbitrary Element or Custom Element.
	 * @class module:delite/HasDropDown.HasDropDownCustomElement
	 * @augments module:delite/Widget
	 */
	HasDropDown.HasDropDownCustomElement = register("d-has-drop-down", [HTMLElement, HasDropDown], {});

	return HasDropDown;
});
;
/**
 * Show drop downs (ex: the select list of a ComboBox) or popups (ex: right-click context menus).
 * @module delite/popup
 */
define('delite/popup',[
	"dcl/advise",
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass(), removeClass(), hasClass()
	"./BackgroundIframe",
	"./DialogUnderlay",
	"./features", // has("config-bgIframe")
	"./on",
	"./place",
	"./Viewport",
	"./theme!" // d-popup class
], function (advise, dcl, $, BackgroundIframe, DialogUnderlay, has, on, place, Viewport) {

	function isDocLtr(doc) {
		return !(/^rtl$/i).test(doc.body.dir || doc.documentElement.dir);
	}

	// Mysterious code to workaround iOS problem where clicking a button  below an input will just keep the input
	// focused.  Button gets pointerdown event but not click event.  Test case: popup.html, press "show centered dialog"
	// and first click the <input>, then click the <button> below it.
	document.addEventListener("pointerdown", function () {
		document.body.scrollTop = document.body.scrollTop;
	}, true);

	/**
	 * Dispatched on a popup after the popup is shown.
	 * @event module:delite/popup#popup-after-show
	 */

	/**
	 * Dispatched on a popup before it's hidden.
	 * @event module:delite/popup#popup-before-hide
	 */

	/**
	 * Dispatched on a popup after the popup is shown or when it is repositioned
	 * due to the size of its content changing.
	 * @event module:delite/popup#popup-after-position
	 * @property {string} aroundCorner - Corner of the anchor node, one of:
	 * - "BL" - bottom left
	 * - "BR" - bottom right
	 * - "TL" - top left
	 * - "TR" - top right
	 * @property {string} nodeCorner - Corner of the popup node, one of:
	 * - "BL" - bottom left
	 * - "BR" - bottom right
	 * - "TL" - top left
	 * - "TR" - top right
	 * @property {Object} size - `{w: 20, h: 30}` type object specifying size of the popup.
	 */

	/**
	 * Dispatched on a popup after the popup is repositioned
	 * due to the size of its content changing.
	 * TODO: remove this?
	 * @event module:delite/popup#delite-repositioned
	 */

	/**
	 * Arguments to `delite/popup#open()` method.
	 * @typedef {Object} module:delite/popup.OpenArgs
	 * @property {module:delite/Widget} popup - The Widget to display.
	 * @property {module:delite/Widget} parent - The button etc. that is displaying this popup.
	 * @property {Element|Rectangle} around - DOM node (typically a button);
	 * place popup relative to this node.  (Specify this *or* `x` and `y` properties.)
	 * @property {number} x - Absolute horizontal position (in pixels) to place node at.
	 * (Specify this *or* `around` parameter.)
	 * @property {number} y - Absolute vertical position (in pixels) to place node at.
	 * (Specify this *or* `around` parameter.)
	 * @property {string[]} orient - When the `around` parameter is specified, `orient` should be a
	 * list of positions to try, ex. `[ "below", "above" ]`
	 * `delite/popup.open()` tries to position the popup according to each specified position, in order,
	 * until the popup appears fully within the viewport.  The default value is `["below", "above"]`.
	 * When an `(x,y)` position is specified rather than an `around` node, `orient` is either
	 * "R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	 * specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	 * fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	 * and the top-right corner.
	 *
	 * Alternately, `orient` can be an array `["center"]`, which pops up the specified node in the center of
	 * the viewport, like a dialog.  It will shrink the size of the node if necessary, in which case the node
	 * must be designed so that scrolling occurs in the right place.
	 *
	 * @property {Function} onCancel - Callback when user has canceled the popup by:
	 *
	 * 1. hitting ESC or TAB key
	 * 2. using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog),
	 * causing the widget to emit a "cancel" event
	 *
	 * @property {Function} onExecute - Callback when user has executed the popup
	 * by using the popup widget's proprietary execute mechanism (like an OK button in a dialog, or clicking a choice
	 * in a dropdown list), causing the widget to emit an "execute" or "change" event.
	 * @property {Function} onClose - Callback whenever this popup is closed.
	 * @property {Position} padding - Adding a buffer around the opening position.
	 * This is only used when `around` is not set.
	 * @property {number} maxHeight - The maximum height for the popup.
	 * Any popup taller than this will have scroll bars.
	 * Set to `Infinity` for no max height.  Default is to limit height to available space in viewport,
	 * above or below the `aroundNode` or specified `x/y` position.
	 */

	/**
	 * Function to destroy wrapper when popup widget is destroyed.
	 */
	function destroyWrapper() {
		if (this._popupWrapper) {
			this._popupWrapper.parentNode.removeChild(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	// TODO: convert from singleton to just a hash of functions; easier to doc that way.

	var PopupManager = dcl(null, /** @lends module:delite/popup */ {
		/**
		 * Stack of information about currently popped up widgets.
		 * See `open()` method to see the properties set in each Object in this stack (widget, wrapper, etc)
		 * (someone opened _stack[0], and then it opened _stack[1], etc.)
		 * @member {*} PopupManager._stack
		 */
		_stack: [],

		/**
		 * Z-index of the first popup.   (If first popup opens other popups they get a higher z-index.)
		 * @member {number} PopupManager._beginZIndex
		 */
		_beginZIndex: 1000,

		_idGen: 1,

		constructor: function () {
			Viewport.on("resize", this._repositionAll.bind(this));
			Viewport.on("scroll", this._viewportScrollHandler.bind(this));
		},

		/**
		 * We check for viewport scroll above, but this code checks for scrolling an inner `<div>`,
		 * thus moving the anchor node.  Using the scrollbar will close all the popups on the screen, but not
		 * if you scroll via a mousewheel or a mousepad double-finger gesture.
		 * @private
		 */
		_checkScroll: function () {
			if (this._firstAroundNode) {	// guard for when clearTimeout() on IE doesn't work
				var oldPos = this._firstAroundPosition,
					newPos = place.position(this._firstAroundNode),
					dx = newPos.x - oldPos.x,
					dy = newPos.y - oldPos.y;

				if (dx || dy) {
					this._firstAroundPosition = newPos;
					this._repositionAll();
				}

				this._aroundMoveListener = setTimeout(this._checkScroll.bind(this), dx || dy ? 10 : 50);
			}
		},

		/**
		 * Reposition all the popups. It may need to be called when popup's content changes.
		 * @param {boolean} measureSize force to calculate natural height and width of the popup.
		 * @private
		 * @fires module:delite/popup#delite-repositioned
		 */
		_repositionAll: function (measureSize) {
			this._stack.forEach(function (args) {
				this._size(args, measureSize);
				this._position(args);
				on.emit(args.popup, "delite-repositioned", {args: args});
			}, this);
		},

		/**
		 * Reposition all the popups due to viewport scroll.  The main purpose of the function is to handle
		 * automatic scrolling on mobile from the keyboard popping up or when the browser tries to scroll the
		 * focused element to the upper part of the screen.
		 * @private
		 */
		_viewportScrollHandler: function () {
			this._stack.forEach(function (args) {
				if (args.orient[0] !== "center") {	// no need to resize dialogs just due to viewport scroll
					this._size(args);
				}
				this._position(args);
			}, this);
		},

		/**
		 * Initialization for widgets that will be used as popups.
		 * Puts widget inside a wrapper DIV (if not already in one), and returns pointer to that wrapper DIV.
		 * @param {module:delite/Widget} widget
		 * @returns {HTMLElement} The wrapper DIV.
		 * @private
		 */
		_createWrapper: function (widget) {
			var wrapper = widget._popupWrapper;
			if (!wrapper) {
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = widget.ownerDocument.createElement("div");
				wrapper.className = "d-popup";
				wrapper.style.display = "none";
				wrapper.setAttribute("role", "region");
				wrapper.setAttribute("aria-label", widget["aria-label"] || widget.label || widget.name || widget.id);
				widget.ownerDocument.body.appendChild(wrapper);

				wrapper.appendChild(widget);
				widget.attachedCallback();

				// Original popup widget might be hidden (so user doesn't see it prematurely).
				// Clear that CSS now.  The wrapper itself is hidden.
				if (widget.style.display === "none") {
					widget.style.display = "";
				}
				if (widget.style.visibility === "hidden") {
					widget.style.visibility = "";
				}
				$(widget).removeClass("d-hidden d-invisible d-offscreen");

				widget._popupWrapper = wrapper;
				advise.after(widget, "destroy", destroyWrapper);
			}

			return wrapper;
		},

		/**
		 * Moves the popup widget off-screen.  Do not use this method to hide popups when not in use, because
		 * that will create an accessibility issue: the offscreen popup will still be in the tabbing order.
		 * @param {module:delite/Widget} widget
		 * @returns {HTMLElement}
		 */
		moveOffScreen: function (widget) {
			// Create wrapper if not already there, then besides setting visibility:hidden,
			// move it out of the viewport, see #5776, #10111, #13604
			var wrapper = this._createWrapper(widget);
			wrapper.style.display = "";
			$(wrapper).addClass("d-offscreen");
			return wrapper;
		},

		/**
		 * Detach specified popup widget from document
		 * @param {module:delite/Widget} widget
		 */
		detach: function (widget) {
			if (widget._popupWrapper) {
				widget._popupWrapper.parentNode.removeChild(widget._popupWrapper);
				delete widget._popupWrapper;
				widget.detachedCallback();
			} else if (widget.parentNode) {
				widget.parentNode.removeChild(widget);
				widget.detachedCallback();
			}
		},

		/**
		 * Hide this popup widget (until it is ready to be shown).
		 * Initialization for widgets that will be used as popups.
		 *
		 * Also puts widget inside a wrapper DIV (if not already in one).
		 *
		 * If popup widget needs to layout it should do so when it is made visible,
		 * and popup._onShow() is called.
		 * @param {module:delite/Widget} widget
		 */
		hide: function (widget) {
			widget.emit("popup-before-hide");

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			dcl.mix(wrapper.style, {
				display: "none",
				height: "auto"		// Open may have limited the height to fit in the viewport
			});
		},

		/**
		 * Compute the closest ancestor popup that's *not* a child of another popup.
		 * Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
		 * @returns {module:delite/Widget}
		 */
		getTopPopup: function () {
			var stack = this._stack;
			for (var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].popup; pi--) {
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		/**
		 * Popup the widget at the specified position.
		 *
		 * Note that whatever widget called delite/popup.open() should also require activationTracker and listen for
		 * delite-deactivated event to know that focus has moved somewhere
		 * else and thus the popup should be closed.
		 *
		 * @param {module:delite/popup.OpenArgs} args
		 * @returns {*} If orient !== center then returns the alignment of the popup relative to the anchor node.
		 * @example
		 * // Open at the mouse position
		 * popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		 * @example
		 * // Open the widget as a dropdown
		 * popup.open({parent: this, popup: menuWidget, around: this, onClose: function(){...}});
		 */
		open: function (args) {
			// Size and position the popup.
			this._prepareToOpen(args);
			this._size(args, true);
			var position = this._position(args);

			// Emit event on popup.
			args.popup.emit("popup-after-show", {
				around: args.around
			});

			return position;
		},

		/**
		 * Do the work to display a popup widget, except for positioning.
		 * @param {module:delite/popup.OpenArgs} args
		 * @returns {*}
		 * @private
		 */
		_prepareToOpen: function (args) {
			/* jshint maxcomplexity:12 */

			var stack = this._stack,
				widget = args.popup,
				around = args.around;

			// Generate id for popup if it doesn't already have one.
			if (!widget.id) {
				widget.id = args.around && args.around.id ? args.around.id + "_dropdown" : "popup_" + this._idGen++;
			}

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the delite-activated event, except that event isn't reliable on IE, see [22198].
			// TODO: check if this code still needed for delite
			while (stack.length && (!args.parent || !stack[stack.length - 1].popup.contains(args.parent))) {
				this.close(stack[stack.length - 1].popup);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
			// off screen) so we can do sizing calculations.
			var wrapper = this.moveOffScreen(widget);

			var wrapperClasses = ["d-popup"];
			((widget.baseClass || "") + " " + widget.className).split(/ +/).forEach(function (cls) {
				if (cls) {
					wrapperClasses.push(cls + "-popup");
				}
			});
			dcl.mix(wrapper, {
				id: widget.id + "_wrapper",
				className: wrapperClasses.join(" ")
			});
			wrapper.style.zIndex = this._beginZIndex + stack.length;
			wrapper._popupParent = args.parent ? args.parent : null;

			if (stack.length === 0 && around) {
				// First element on stack. Save position of aroundNode and setup listener for changes to that position.
				this._firstAroundNode = around;
				this._firstAroundPosition = place.position(around);
				this._aroundMoveListener = setTimeout(this._checkScroll.bind(this), 50);
			}

			if (has("config-bgIframe") && !widget.bgIframe) {
				// setting widget.bgIframe triggers cleanup in Widget.destroy()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			wrapper.style.visibility = "visible";
			widget.style.visibility = "visible";	// counteract effects from HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			var onKeyDown = function (evt) {
				if ((evt.key === "Escape" || evt.key === "Tab") && args.onCancel) {
					evt.stopPropagation();
					evt.preventDefault();
					args.onCancel();
				}
			}.bind(this);
			wrapper.addEventListener("keydown", onKeyDown);
			handlers.push({
				remove: function () {
					wrapper.removeEventListener("keydown", onKeyDown);
				}
			});

			// Watch for cancel/execute events on the popup and notify the caller.
			// Simple widgets like a Calendar will emit "change" events, whereas complex widgets like
			// a TooltipDialog/Menu will emit "execute" events.  No way to tell which event the widget will
			// emit, so listen for both.
			if (args.onCancel) {
				handlers.push(widget.on("cancel", args.onCancel));
			}
			if (args.onExecute) {
				handlers.push(widget.on("execute", args.onExecute));
				handlers.push(widget.on("change", function (event) {
					// Ignore change events from nodes inside the widget (for example, typing into an <input>),
					// but if the widget itself emits a change event then...
					if (event.target === widget) {
						args.onExecute();
					}
				}));
			}

			handlers.push(widget.on("delite-size-change", function () {
				this._repositionAll(true);
			}.bind(this)));

			var stackEntry = Object.create(args);
			stackEntry.wrapper = wrapper;
			stackEntry.handlers = handlers;
			stack.push(stackEntry);
		},

		/**
		 * Size or resize the popup specified by args.
		 * @param {module:delite/popup.OpenArgs} args
		 * @param {boolean} measureSize
		 * @returns {*} If orient !== center then returns the alignment of the popup relative to the anchor node.
		 * @private
		 */
		_size: function (args, measureSize) {
			/* jshint maxcomplexity:13 */
			var widget = args.popup,
				around = args.around,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				viewport = Viewport.getEffectiveBox(widget.ownerDocument);

			if (measureSize) {
				// Get natural size of popup (i.e. when not squashed to fit within viewport).  First, remove any
				// previous size restriction set on popup.  Note that setting popups's height and width to "auto"
				// erases scroll position, so should only be done when popup is first shown, before user has scrolled.
				widget.style.height = "auto";
				if (orient[0] === "center") {
					// Don't set width to "auto" when orient!=center because it interferes with HasDropDown's
					// autoWidth/forceWidth.
					// TODO: maybe this if() check is no longer necessary to due to parent if(measureSize)
					widget.style.width = "auto";
				}

				var cs = getComputedStyle(widget),
					verticalMargin = parseFloat(cs.marginTop) + parseFloat(cs.marginBottom),
					horizontalMargin = parseFloat(cs.marginLeft) + parseFloat(cs.marginRight);
				args._naturalHeight = widget.offsetHeight + verticalMargin;
				args._naturalWidth = widget.offsetWidth + horizontalMargin;
			}

			if (orient[0] === "center") {
				// Limit height and width so dialog fits within viewport.
				widget.style.height = args._naturalHeight > viewport.h * 0.9 ? Math.floor(viewport.h * 0.9) + "px" :
					"auto";
				widget.style.width = args._naturalWidth > viewport.w * 0.9 ? Math.floor(viewport.w * 0.9) + "px" :
					"auto";
			} else {
				// Limit height to space available in viewport either above or below aroundNode (whichever side has
				// more room).  This may make the popup widget display a scrollbar (or multiple scrollbars).
				var maxHeight;
				if ("maxHeight" in args && args.maxHeight !== -1) {
					maxHeight = args.maxHeight || Infinity;
				} else {
					var aroundPos = around ? around.getBoundingClientRect() : {
						top: args.y - (args.padding || 0),
						height: (args.padding || 0) * 2
					};
					maxHeight = Math.floor(Math.max(aroundPos.top, viewport.h -
						(aroundPos.top + aroundPos.height)));
				}

				widget.style.height = args._naturalHeight > maxHeight ? maxHeight - verticalMargin + "px" : "auto";
			}
		},

		/**
		 * Position the popup specified by args.
		 * @param args
		 * @returns {*} If orient !== center then returns the alignment of the popup relative to the anchor node.
		 * @private
		 */
		_position: function (args) {
			var widget = args.popup,
				wrapper = widget._popupWrapper,
				around = args.around,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.effectiveDir !== "rtl" : isDocLtr(widget.ownerDocument);

			// position the wrapper node
			if (orient[0] === "center") {
				place.center(wrapper);
				DialogUnderlay.showFor(wrapper);
			} else {
				var position = around ?
					place.around(wrapper, around, orient, ltr) :
					place.at(wrapper, args, orient === "R" ? ["TR", "BR", "TL", "BL"] : ["TL", "BL", "TR", "BR"],
						args.padding);

				// Emit event telling popup that it was [re]positioned.
				var event = {
					around: around
				};
				dcl.mix(event, position);
				widget.emit("popup-after-position", event);

				return position;
			}

		},

		/**
		 * Close specified popup and any popups that it parented.  If no popup is specified, closes all popups.
		 * @param {module:delite/Widget} [popup]
		 */
		close: function (popup) {
			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack===[A]...
			// so the while condition is constructed defensively.
			while ((popup && stack.some(function (elem) {
				return elem.popup === popup;
			})) ||
				(!popup && stack.length)) {
				var top = stack.pop(),
					widget = top.popup,
					onClose = top.onClose;

				if (widget.bgIframe) {
					// push the iframe back onto the stack.
					widget.bgIframe.destroy();
					delete widget.bgIframe;
				}

				var h;
				while ((h = top.handlers.pop())) {
					h.remove();
				}

				// Hide the widget and its wrapper unless it has already been destroyed in above onClose() etc.
				this.hide(widget);
				DialogUnderlay.hideFor(widget._popupWrapper);

				if (onClose) {
					onClose();
				}
			}

			if (stack.length === 0 && this._aroundMoveListener) {
				clearTimeout(this._aroundMoveListener);
				this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
			}
		}
	});

	return new PopupManager();
});
;
/**
 * Utility singleton to watch for viewport resizes, avoiding duplicate notifications
 * which can lead to infinite loops.
 *
 * Usage:
 * ```
 * Viewport.on("resize", myCallback)
 * Viewport.on("scroll", myOtherCallback)
 * ```
 * 
 * myCallback() is called without arguments in case it's Widget.resize(),
 * which would interpret the argument as the size to make the widget.
 *
 * @module delite/Viewport
 */
define('delite/Viewport',[
	"decor/Evented",
	"decor/sniff",	// has("ios")
	"requirejs-domready/domReady!"
], function (Evented, has) {
	var Viewport = new Evented();

	// Get the size of the viewport without size adjustment needed for iOS soft keyboard.
	// On android though, this returns the size of the visible area not including the keyboard.
	function getBox() {
		if (has("ios") < 8) {
			// Workaround iOS < 8 problem where window.innerHeight is too low when the document is scrolled so
			// much that the document ends before the bottom of the keyboard.  Workaround not needed and doesn't work,
			// on iOS 8.
			var bcr = document.body.getBoundingClientRect();
			return {
				w: Math.max(bcr.width, window.innerWidth),
				h: Math.max(bcr.height, window.innerHeight),
				t: window.pageYOffset,
				l: window.pageXOffset
			};
		} else {
			return {
				w: window.innerWidth,
				h: window.innerHeight,
				t: window.pageYOffset,
				l: window.pageXOffset
			};
		}
	}

	/**
	 * Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
	 * virtual keyboard.
	 * @function module:delite/Viewport.getEffectiveBox
	 */
	Viewport.getEffectiveBox = function () {
		/* jshint maxcomplexity:12 */

		var box = getBox();

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var focusedNode = document.activeElement,
			tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if (has("ios") && focusedNode && !focusedNode.readOnly && (tag === "textarea" || (tag === "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))) {

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen,
			// but is covered by keyboard.
			
			// By my measurements the effective viewport is the following size (compared to full viewport:
			// Portrait / landscape / window.screen.height:
			// iPhone 6 / iOS 8: 54% / 26% / 667
			// iPhone 5s / iOS 8: 53% / 27% / 568
			// iPhone 5s / iOS 7: 53% / 19% / 568
			// iPhone 5 / iOS 8: 52% / 27% / 568
			// iPhone 4s / iOS 7: 41% / 19% / 480
			// iPad 2 / iOS 7.1: 66% / 41%
			// iPhone 3s / iOS6: 43% / 29% (but w/hidden address bar because it hides all the time)

			if (has("ipad")) {
				// Numbers for iPad 2, hopefully it works for other iPads (including iPad mini) too.
				box.h *= (window.orientation === 0 || window.orientation === 180 ? 0.65 : 0.38);
			} else {
				// iPhone varies a lot by model, this should estimate the available space conservatively
				if (window.orientation === 0 || window.orientation === 180) {
					// portrait
					box.h *= (window.screen.height > 500 ? 0.54 : 0.42);
				} else {
					// landscape
					box.h *= (window.screen.height > 500 && has("ios") >= 8 ? 0.26 : 0.19);
				}
			}

			// Account for space taken by auto-completion suggestions.
			if (has("ios") >= 8 &&
				(!focusedNode.hasAttribute("autocorrect") || focusedNode.getAttribute("autocorrect") === "on") &&
				/^(color|number|search|tel|text)$/.test(focusedNode.type)) {
				box.h -= 40;
			}
		}

		return box;
	};

	var oldEffectiveSize = Viewport.getEffectiveBox(),
		oldEffectiveScroll = oldEffectiveSize;

	function checkForResize() {
		var newBox = Viewport.getEffectiveBox();
		if (newBox.h !== oldEffectiveSize.h || newBox.w !== oldEffectiveSize.w) {
			oldEffectiveSize = newBox;
			Viewport.emit("resize", newBox);
			return true;
		} else {
			return false;
		}
	}
	function checkForScroll() {
		var newBox = Viewport.getEffectiveBox();
		if (newBox.t !== oldEffectiveScroll.t || newBox.l !== oldEffectiveScroll.l) {
			oldEffectiveScroll = newBox;
			Viewport.emit("scroll", newBox);
			return true;
		} else {
			return false;
		}
	}

	// Poll for viewport resizes due to rotation, browser window size change, or the virtual keyboard
	// popping up/down.
	function poll() {
		var resized = checkForResize(),
			scrolled = checkForScroll();
		setTimeout(poll, resized || scrolled ? 10 : 50);
	}
	poll();

	return Viewport;
});
;
/** @module delite/DialogUnderlay */
define('delite/DialogUnderlay',[
	"./register",
	"./Widget",
	"./BackgroundIframe",
	"./Viewport",
	"./theme!./DialogUnderlay/themes/{{theme}}/DialogUnderlay.css"
], function (register, Widget, BackgroundIframe, Viewport) {

	// TODO: having show() methods on the instance and also on the module is confusing,
	// at least when looking at the API doc page.  Should one be renamed?

	/**
	 * A component used to block input behind a Dialog widget.
	 *
	 * Normally this widget should not be instantiated directly, but rather shown and hidden via
	 * `DialogUnderlay.show()` and `DialogUnderlay.hide()`.  And usually the module is not accessed directly
	 * at all, since the underlay is shown and hidden by `delite/popup`.
	 *
	 * @class module:delite/DialogUnderlay
	 */
	var DialogUnderlay = register("d-dialog-underlay", [HTMLElement, Widget],
			/** @lends module:delite/DialogUnderlay# */ {

		baseClass: "d-dialog-underlay",

		createdCallback: register.after(function () {
			// Automatically append the underlay to <body> on creation.
			this.ownerDocument.body.appendChild(this);
			this.attachedCallback();
		}),

		attachedCallback: function () {
			this._resizeListener = Viewport.on("resize", function () {
				if (this._open) {
					this.layout();
				}
			}.bind(this));
		},

		detachedCallback: function () {
			this._resizeListener.remove();
		},

		/**
		 * Sets the background to the size of the viewport (rather than the size
		 * of the document) since we need to cover the whole browser window, even
		 * if the document is only a few lines long.
		 * @private
		 */
		layout: function () {
			var s = this.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			s.display = "none";

			// then resize and show
			// could alternately use $(window).scrollTop() and $(window).height(), etc.
			var html = this.ownerDocument.documentElement;
			s.width = html.clientWidth + "px";
			s.height = html.clientHeight + "px";

			s.display = "";
		},

		/**
		 * Show the dialog underlay (instance method).
		 */
		show: function () {
			if (!this._open) {
				this.style.display = "block";
				this._open = true;
				this.layout();
				this.bgIframe = new BackgroundIframe(this);
			}
		},

		/**
		 * Hide the dialog underlay (instance method).
		 */
		hide: function () {
			if (this._open) {
				this.bgIframe.destroy();
				delete this.bgIframe;
				this.style.display = "none";
				this._open = false;
			}
		}
	});

	/**
	 * Static method to display the underlay with the given attributes set.  If the underlay is already displayed,
	 * then adjust its attributes as specified.
	 * @memberof module:delite/DialogUnderlay
	 * @param {Object} attrs - The parameters to create DialogUnderlay with.
	 * @param {number} zIndex - z-index of the underlay.
	 */
	DialogUnderlay.show = function (attrs, zIndex) {
		var underlay = DialogUnderlay._singleton;
		if (!underlay || underlay._destroyed) {
			underlay = DialogUnderlay._singleton = new DialogUnderlay(attrs);
		} else {
			if (attrs) {
				underlay.mix(attrs);
			}
		}
		underlay.style.zIndex = zIndex;
		underlay.show();
	};

	/**
	 * Static method to hide the underlay.
	 * @memberof module:delite/DialogUnderlay
	 */
	DialogUnderlay.hide = function () {
		// Guard code in case the underlay widget has already been destroyed
		// because we are being called during page unload (when all widgets are destroyed)
		var underlay = DialogUnderlay._singleton;
		if (underlay && !underlay._destroyed) {
			underlay.hide();
		}
	};

	// Stack representing the currently displayed dialogs with underlays.
	var ds = [];

	/**
	 * Call when new dialog (that needs an underlay) is shown.
	 * Displays the underlay, or if already displayed then adjusts it for this new dialog.
	 * @param dialog
	 * @memberof module:delite/DialogUnderlay
	 */
	DialogUnderlay.showFor = function (dialog) {
		if (ds.indexOf(dialog) >= 0) {
			return;
		}
		var zIndex = +getComputedStyle(dialog).zIndex;
		DialogUnderlay.show(null, zIndex - 1);
		ds.push(dialog);
	};

	/**
	 * Call when a dialog with an underlay is hidden.
	 * Hides the underlay, or if there are remaining dialogs on the page,
	 * then adjusts underlay for the new top dialog.
	 * @param dialog
	 * @memberof module:delite/DialogUnderlay
	 */
	DialogUnderlay.hideFor = function (dialog) {
		if (ds[ds.length - 1] === dialog) {
			// Removing the top (or only) dialog in the stack.

			ds.pop();

			var pd = ds[ds.length - 1];	// the new active dialog

			// Adjust underlay
			if (pd) {
				// Popping back to previous dialog, adjust underlay.
				var zIndex = +getComputedStyle(pd).zIndex;
				DialogUnderlay.show(null, zIndex - 1);
			} else {
				// Returning to original page.  Hide the underlay.
				DialogUnderlay.hide();
			}
		} else {
			// Removing a dialog out of order (#9944, #10705).
			// Don't need to mess with underlay or z-index or anything.
			var idx = ds.indexOf(dialog);
			if (idx !== -1) {
				ds.splice(idx, 1);
			}
		}
	};

	return DialogUnderlay;
});
;
/** @module delite/BackgroundIframe */
define('delite/BackgroundIframe',[
	"dcl/dcl",
	"./features"
], function (dcl, has) {
	/**
	 * Cache of iframes.
	 * @constructor
	 */
	var Frames = function () {
		var queue = [];

		this.pop = function () {
			var iframe;
			if (queue.length) {
				iframe = queue.pop();
				iframe.style.display = "";
			} else {
				iframe = document.createElement("iframe");
				iframe.src = "javascript:''";
				iframe.className = "d-background-iframe";
				iframe.setAttribute("role", "presentation");

				// Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
				iframe.tabIndex = -1;
			}
			return iframe;
		};

		this.push = function (iframe) {
			iframe.style.display = "none";
			queue.push(iframe);
		};
	};
	var _frames = new Frames();


	/**
	 * Makes a background iframe as a child of node.  Iframe fills area (and position) of node.
	 * @param {Element} node
	 * @class module:delite/BackgroundIframe
	 */
	return dcl(null, /** @lends module:delite/BackgroundIframe# */ {
		constructor: function (node) {
			if (has("config-bgIframe")) {
				var iframe = (this.iframe = _frames.pop());
				node.appendChild(iframe);
				iframe.style.width = "100%";
				iframe.style.height = "100%";
			}
		},

		/**
		 * Destroy the iframe.
		 */
		destroy: function () {
			if (this.iframe) {
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});
});
;
/**
 * Place an Element relative to a point, rectangle, or another Element.
 * @module delite/place
 */
define('delite/place',[
	"./Viewport" // getEffectiveBox
], function (Viewport) {

	/**
	 * @typedef {Object} module:delite/place.Position
	 * @property {number} x - Horizontal coordinate in pixels, relative to document body.
	 * @property {number} y - Vertical coordinate in pixels, relative to document body.
	 */

	/**
	 * Represents the position of the "anchor" node.   Popup node will be placed adjacent to this rectangle.
	 * @typedef {Object} module:delite/place.Rectangle
	 * @property {number} x - Horizontal coordinate in pixels, relative to document body.
	 * @property {number} y - Vertical coordinate in pixels, relative to document body.
	 * @property {number} w - Width in pixels.
	 * @property {number} h - Height in pixels.
	 */

	/**
	 * Meta-data about the position chosen for a popup node.
	 * Specifies the corner of the anchor node and the corner of the popup node that touch each other,
	 * plus sizing data.
	 * @typedef {Object} module:delite/place.ChosenPosition
	 * @property {string} aroundCorner - Corner of the anchor node:
	 * - "BL" - bottom left
	 * - "BR" - bottom right
	 * - "TL" - top left
	 * - "TR" - top right
	 * @property {string} corner - Corner of the popup node:
	 * - "BL" - bottom left
	 * - "BR" - bottom right
	 * - "TL" - top left
	 * - "TR" - top right
	 * @property {number} x - Horizontal position of popup in pixels, relative to document body.
	 * @property {number} y - Vertical position of popup in pixels, relative to document body.
	 * @property {number} w - Width of popup in pixels.
	 * @property {number} h - Height of popup in pixels.
	 * @property {Object} spaceAvailable - `{w: 30, h: 20}` type object listing the amount of space that
	 * was available fot the popup in the chosen position.
	 */

	/**
	 * Given a list of positions to place node, place it at the first position where it fits,
	 * of if it doesn't fit anywhere then the position with the least overflow.
	 * @param {Element} node
	 * @param {Array} choices - Array of objects like `{corner: "TL", pos: {x: 10, y: 20} }`.
	 * This example says to put the top-left corner of the node at (10,20).
	 * @returns {module:delite/place.ChosenPosition} Best position to place node.
	 * @private
	 */
	function _placeAt(node, choices) {
		// get {l: 10, t: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument),
			style = node.style;

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cut off.)
		if (!node.parentNode || String(node.parentNode.tagName).toLowerCase() !== "body") {
			node.ownerDocument.body.appendChild(node);
		}

		var best = null;
		choices.some(function (choice) {
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					"L": view.l + view.w - pos.x,
					"R": pos.x - view.l,
					"M": view.w
				}[corner.charAt(1)],
				h: {
					"T": view.t + view.h - pos.y,
					"B": pos.y - view.t,
					"M": view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			style.left = style.right = "auto";

			// get node's size
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if (style.display === "none") {
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = node.getBoundingClientRect();
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					"L": pos.x,
					"R": pos.x - bb.width,
					// M orientation is more flexible
					"M": Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.width >> 1)) - bb.width)
				}[corner.charAt(1)],
				startYpos = {
					"T": pos.y,
					"B": pos.y - bb.height,
					"M": Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.height >> 1)) - bb.height)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.width),
				endY = Math.min(view.t + view.h, startYpos + bb.height),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.width - width) + (bb.height - height);

			if (best == null || overflow < best.overflow) {
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// And then position the node.  Do this last,
		// due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			cs = getComputedStyle(node.ownerDocument.body);

		if (/^(relative|absolute)$/.test(cs.position)) {
			// compensate for margin on <body>, see #16148
			top -= cs.marginTop;
			side -= cs.marginLeft;
		}

		style.top = top + "px";
		style.left = side + "px";
		style.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = /** @lends module:delite/place */ {

		// TODO: it's weird that padding is specified as x/y rather than h/w.

		/**
		 * Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
		 * padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in
		 * corners[] where node is fully visible, or the corner where it's most visible.
		 *
		 * Node is assumed to be absolutely or relatively positioned.
		 * 
		 * @param {Element} node - The popup node to be positioned.
		 * @param {module:delite/place.Position} pos - The point (or if padding specified, rectangle) to place
		 * the node kitty-corner to.
		 * @param {string[]} corners - Array of strings representing order to try corners of the node in,
		 * like `["TR", "BL"]`.  Possible values are:
		 * - "BL" - bottom left
		 * - "BR" - bottom right
		 * - "TL" - top left
		 * - "TR" - top right
		 * @param {module:delite/place.Position} [padding] - Optional param to set padding, to put some buffer
		 * around the element you want to position.  Defaults to zero.
		 * @returns {module:delite/place.ChosenPosition} Position node was placed at.
		 * @example
		 * // Try to place node's top right corner at (10,20).
		 * // If that makes node go (partially) off screen, then try placing
		 * // bottom left corner at (10,20).
		 * place.at(node, {x: 10, y: 20}, ["TR", "BL"])
		 */
		at: function (node, pos, corners, padding) {
			var choices = corners.map(function (corner) {
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x, y: pos.y}
				};
				if (padding) {
					c.pos.x += corner.charAt(1) === "L" ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) === "T" ? padding.y : -padding.y;
				}
				return c;
			});

			return _placeAt(node, choices);
		},

		/**
		 * Position node adjacent to anchor such that it's fully visible in viewport.
		 * Adjacent means that one side of the anchor is flush with one side of the node.
		 * @param {Element} node - The popup node to be positioned.
		 * @param {Element|module:delite/place.Rectangle} anchor - Place node adjacent to this Element or rectangle.
		 * @param {string[]} positions - Ordered list of positions to try matching up.
		 * - before: places drop down to the left of the anchor node/widget, or to the right in the case
		 *   of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
		 *   with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
		 * - after: places drop down to the right of the anchor node/widget, or to the left in the case
		 *   of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
		 *   with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
		 * - before-centered: centers drop down to the left of the anchor node/widget, or to the right
		 *   in the case of RTL scripts like Hebrew and Arabic
		 * - after-centered: centers drop down to the right of the anchor node/widget, or to the left
		 *   in the case of RTL scripts like Hebrew and Arabic
		 * - above-centered: drop down is centered above anchor node
		 * - above: drop down goes above anchor node, left sides aligned
		 * - above-alt: drop down goes above anchor node, right sides aligned
		 * - below-centered: drop down is centered above anchor node
		 * - below: drop down goes below anchor node
		 * - below-alt: drop down goes below anchor node, right sides aligned
		 * @param {boolean} leftToRight - True if widget is LTR, false if widget is RTL.
		 * Affects the behavior of "above" and "below" positions slightly.
		 * @returns {module:delite/place.ChosenPosition} Position node was placed at.
		 * @example
		 * // Try to position node such that node's top-left corner is at the same position
		 * // as the bottom left corner of the aroundNode (ie, put node below
		 * // aroundNode, with left edges aligned).	If that fails try to put
		 * // the bottom-right corner of node where the top right corner of aroundNode is
		 * // (i.e., put node above aroundNode, with right edges aligned)
		 * place.around(node, aroundNode, {'BL':'TL', 'TR':'BR'});
		 */
		around: function (node, anchor, positions, leftToRight) {
			/* jshint maxcomplexity:12 */

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if (typeof anchor === "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor) {
				aroundNodePos = place.position(anchor);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if (/^(above|below)/.test(positions[0])) {
					var border = function (node) {
						var cs = getComputedStyle(node);
						return {
							t: parseFloat(cs.borderTopWidth),	// remove "px"
							b: parseFloat(cs.borderBottomWidth)	// remove "px"
						};
					};
					var anchorBorder = border(anchor),
						anchorChildBorder = anchor.firstElementChild ? border(anchor.firstElementChild) : {t: 0, b: 0},
						nodeBorder = border(node),
						nodeChildBorder = node.firstElementChild ? border(node.firstElementChild) : {t: 0, b: 0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t,
						nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -= Math.min(anchorBorder.t + anchorChildBorder.t,
						nodeBorder.t + nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			} else {
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor
			// nodes w/scrollbars)
			if (anchor.parentNode) {
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = getComputedStyle(anchor).position === "absolute";
				var parent = anchor.parentNode;
				// ignoring the body will help performance
				while (parent && parent.nodeType === 1 && parent.nodeName !== "BODY") {
					var parentPos = place.position(parent),
						pcs = getComputedStyle(parent);
					if (/^(relative|absolute)$/.test(pcs.position)) {
						sawPosAbsolute = false;
					}
					if (!sawPosAbsolute && /^(hidden|auto|scroll)$/.test(pcs.overflow)) {
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if (pcs.position === "absolute") {
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = aroundNodePos.w,
				height = aroundNodePos.h;

			// Convert positions arguments into choices argument for _placeAt()
			var choices = [];

			function push(aroundCorner, corner) {
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							"L": x,
							"R": x + width,
							"M": x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							"T": y,
							"B": y + height,
							"M": y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				});
			}

			positions.forEach(function (pos) {
				/* jshint maxcomplexity:25 */	// TODO: rewrite to avoid 25 max complexity
				var ltr = leftToRight;
				switch (pos) {
				case "above-centered":
					push("TM", "BM");
					break;
				case "below-centered":
					push("BM", "TM");
					break;
				case "after-centered":
					ltr = !ltr;
					/* falls through */
				case "before-centered":
					push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
					break;
				case "after":
					ltr = !ltr;
					/* falls through */
				case "before":
					push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
					push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
					break;
				case "below-alt":
					ltr = !ltr;
					/* falls through */
				case "below":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
					push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
					break;
				case "above-alt":
					ltr = !ltr;
					/* falls through */
				case "above":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
					push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
					break;
				}
			});

			var position = _placeAt(node, choices);
			position.aroundNodePos = aroundNodePos;

			return position;
		},

		/**
		 * Centers the specified node, like a Dialog.
		 * Node must fit within viewport.
		 *
		 * Node is assumed to be absolutely or relatively positioned.
		 *
		 * @param {Element} node - The popup node to be positioned.
		 */
		center: function (node) {
			// First move node off screen so we can get accurate size.
			// TODO: move this code [and RTL detect code) to separate methods, and leverage from popup.moveOffScreen()
			var style = node.style,
				rtl = (/^rtl$/i).test(node.dir || node.ownerDocument.body.dir ||
					node.ownerDocument.documentElement.dir);
			style.top = "-9999px";
			style[rtl ? "right" : "left"] = "-9999px";

			// Then set position so node is centered.
			var view = Viewport.getEffectiveBox(),
				bb = node.getBoundingClientRect();
			style.top = view.t + (view.h - bb.height) / 2 + "px";
			style.left = view.l + (view.w - bb.width) / 2 + "px";
			style.right = "auto";
		},

		/**
		 * Return node position relative to document (rather than to viewport).
		 * @param node
		 */
		position: function (node) {
			var bcr = node.getBoundingClientRect(),
				doc = node.ownerDocument,
				win = doc.defaultView;
			return {
				x: bcr.left + (win.pageXOffset || doc.documentElement.scrollLeft),
				y: bcr.top + (win.pageYOffset || doc.documentElement.scrollTop),
				h: bcr.height,
				w: bcr.width
			};
		}
	};

	return place;
});
;
define('dojo/string',[
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string

var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});
;
define('delite/handlebars!deliteful/Slider/Slider.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template touch-action=\"none\">\n\t<div attach-point=\"wrapperNode\">\n\t\t<div attach-point=\"progressBar\">\n\t\t\t<div attach-point=\"handleMin\" role=\"slider\"></div>\n\t\t\t<div attach-point=\"focusNode\" role=\"slider\"></div>\n\t\t</div>\n\t</div>\n</template>");
});;
/** @module deliteful/Slider */
define('deliteful/Slider',[
	"requirejs-dplugins/jquery!attributes/classes",
	"dpointer/events",
	"delite/register",
	"delite/FormValueWidget",
	"delite/CssState",
	"delite/handlebars!./Slider/Slider.html",
	"delite/theme!./Slider/themes/{{theme}}/Slider.css"
], function ($, dpointer, register, FormValueWidget, CssState, template) {
	/**
	 * @private
	 */
	function boxFromElement(domElt) {
		var ret = domElt.getBoundingClientRect();
		return {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};
	}

	/**
	 * The Slider widget allows selecting one value or a pair of values, from a range delimited by a minimum (min) and
	 * a maximum (max).
	 *
	 * The selected value depends on the position of the handle and the step, which specifies the value granularity.
	 * Slider can be vertical or horizontal. The position of the minimum and maximum depends on the text direction,
	 * and can be forced using the flip property. Handles can be move using pointers (mouse, touch) or keys
	 * (up, down, home or end).
	 *
	 * A change event is fired after the user select a new value, either by releasing a pointer, or by pressing a
	 * selection key. Before a change event, input events are fired while the user moves the Slider handle.
	 *
	 * The Slider Widget supports ARIA attributes aria-valuemin, aria-valuemax, aria-valuenow and aria-orientation.
	 *
	 * Most of the Slider behavior (default values, out of bound values reconciliations...) is similar to the
	 * HTML5.1 input type=range element [1], but it doesn't strictly conform to the specification, in particular for:
	 * - the "multiple" attribute (single/range Slider is directly determined from the content of the value property)
	 * - the "datalist" attribute (see https://github.com/ibm-js/deliteful/issues/252)
	 *
	 * Like the native input type=range element, this widget can be used in a form. It relies on a hidden input text
	 * element to provide the value to the form.
	 *
	 * [1] http://www.w3.org/TR/html5/forms.html#range-state-%28type=range%29
	 *
	 * @class module:deliteful/Slider
	 * @augments module:delite/FormValueWidget
	 * @augments module:delite/CssState
	 */
	return register("d-slider", [HTMLElement, FormValueWidget, CssState],
		// todo: HTML5 introduce the attribute "multiple" to handle multiple values
		/** @lends module:deliteful/Slider# */ {

			/**
			 * Indicates the minimum boundary of the allowed range of values. Must be a valid floating-point number.
			 * Invalid min value is defaulted to 0.
			 * @member {number}
			 * @default 0
			 */
			min: 0,

			/**
			 * Indicates the maximum boundary of the allowed range of values. Must be a valid floating-point number.
			 * Invalid max value is defaulted to 100.
			 * @member {number}
			 * @default 100
			 */
			max: 100,

			/**
			 * Specifies the value granularity. causes the slider handle to snap/jump to the closest possible value.
			 * Must be a positive floating-point number. Invalid step value is defaulted to 1.
			 * @member {number}
			 * @default 1
			 */
			step: 1,

			/**
			 * Applies only when the slider has two values. Allow sliding the area between the handles to change both
			 * values at the same time.
			 * @member {boolean}
			 * @default true
			 */
			slideRange: true,

			/**
			 * The slider direction:
			 * - false: horizontal
			 * - true: vertical
			 * @member {boolean}
			 * @default false
			 */
			vertical: false,

			/**
			 * Specifies if the slider should change its default: ascending <--> descending.
			 * @member {boolean}
			 * @default false
			 */
			flip: false,

			/**
			 * The name of the CSS class of this widget.
			 * @member {string}
			 * @default "d-slider"
			 */
			baseClass: "d-slider",

			/**
			 * Names of events and CSS properties whose values depend on the orientation of the Slider.
			 * `_orientationNames[true]` to get names when orientation is vertical.
			 * `_orientationNames[false]` to get names when orientation is horizontal.
			 * @private
			 */
			_orientationNames: {
				false: {
					start: "x",
					size: "w",
					clientStart: "clientX",
					progressBarStart: "left",
					progressBarSize: "width"
				},
				true: {
					start: "y",
					size: "h",
					clientStart: "clientY",
					progressBarStart: "top",
					progressBarSize: "height"
				}
			},

			/**
			 * Names of event and CSS properties to use with the current orientation of the Slider.
			 * _orientation.start = "x|y"
			 * _orientation.size = "w|h"
			 * _orientation.clientStart = "clientX|clientY"
			 * _orientation.progressBarSize = "width|height"
			 * @private
			 */
			_propNames: null,

			/**
			 * Used for various calculations: Indicates if current direction must be/is reversed.
			 * @private
			 */
			_reversed: false,

			template: template,

			render: register.superCall(function (sup) {
				return function () {
					sup.call(this);
					if (!this.valueNode.parentNode) {
						this.appendChild(this.valueNode);
					}
					this.handleMin.setAttribute("aria-valuemin", this.min);
					this.focusNode.setAttribute("aria-valuemax", this.max);
					this.tabStops = "handleMin,focusNode";
					this.handleMin._isActive = true;
					// prevent default browser behavior / accept pointer events
					// todo: use pan-x/pan-y according to this.vertical (once supported by dpointer)
					// https://github.com/ibm-js/dpointer/issues/8
					dpointer.setTouchAction(this, "none");
				};
			}),

			/**
			 * Update the handle(s) attribute `aria-orientation` to reflect the actual value of the
			 * `vertical` property.
			 * Update _propName with the properties name to use with the current orientation of the Slider.
			 * @private
			 */
			_refreshOrientation: function () {
				this.focusNode.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
				if (this.handleMin._isActive) {
					this.handleMin.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
				}
				this._propNames = this._orientationNames[this.vertical];
			},

			/**
			 * Refresh CSS classes.
			 * @private
			 */
			_refreshCSS: function () {
				function toCSS(baseClass, modifier) {
					return baseClass.split(/ /).map(function (c) {
						return c + modifier;
					}).join(" ");
				}
				// add V or H suffix to baseClass for styling purposes
				var rootBaseClass = toCSS(this.baseClass, this.vertical ? "-v" : "-h");
				var baseClass = this.baseClass + " " + rootBaseClass;
				// root node: do not remove all classes; user may define custom classes; CssState adds classes that
				// we do not want to lose.
				$(this).removeClass(toCSS(this.baseClass + "-v" + " " + this.baseClass + "-h", "-htl") + " " +
					toCSS(this.baseClass + "-v" + " " + this.baseClass + "-h", "-lth") + " " +
					this.baseClass + "-v" + " " + this.baseClass + "-h");
				$(this).addClass(rootBaseClass + " " + toCSS(baseClass, this._reversed ? "-htl" : "-lth"));
				this.wrapperNode.className = toCSS(baseClass, "-bar") + " " + toCSS(baseClass, "-container");
				this.progressBar.setAttribute("style", "");// reset left/width/height/top
				this.progressBar.className = toCSS(baseClass, "-bar") + " " + toCSS(baseClass, "-progress-bar");
				this.focusNode.className = toCSS(baseClass, "-handle") + " " + toCSS(baseClass, "-handle-max");
				if (this.handleMin._isActive) {
					this.handleMin.className = toCSS(baseClass, "-handle") + " " + toCSS(baseClass, "-handle-min");
				}
			},

			/* jshint maxcomplexity: 12 */
			computeProperties: function (props) {
				if ("value" in props || "min" in props || "max" in props || "step" in props) {
					var value = this._getValueAsArray(),
						isDual = value.length > 1,
						// convert and set default value(s) as needed
						minValue = this._convert2Float(value[0],
							this._calculateDefaultValue(isDual ? 0.25 : 0.5)),
						maxValue = this._convert2Float(value[value.length - 1],
							this._calculateDefaultValue(isDual ? 0.75 : 0.5)),
						// ensure minValue is less than maxValue
						maxV = Math.max(minValue, maxValue);
					minValue = Math.min(minValue, maxValue);
					maxValue = maxV;
					// correct step mismatch/underflow/overflow
					minValue = this._adjustValue(minValue, this.min);
					maxValue = this._adjustValue(maxValue, minValue);
					// set corrected value as needed
					this.value = isDual ? (minValue + "," + maxValue) : String(maxValue);
				}

				// Complicated since you can have flipped right-to-left and vertical is upside down by default.
				if ("vertical" in props || "flip" in props || "effectiveDir" in props) {
					var ltr = this.effectiveDir === "ltr";
					this._reversed = !((!this.vertical && (ltr !== this.flip)) || (this.vertical && this.flip));
				}
			},
			/* jshint maxcomplexity: 10 */

			refreshRendering: function (props) {
				if ("value" in props) {
					this._refreshValueRendering();
				}
				if ("vertical" in props) {
					this._refreshOrientation();
				}
				if ("name" in props) {
					var name = this.name;
					this.removeAttribute("name");
					// won't restore after a browser back operation since name changed nodes
					this.valueNode.setAttribute("name", name);
				}
				if ("max" in props) {
					this.focusNode.setAttribute("aria-valuemax", this.max);
				}
				if ("min" in props) {
					(this.handleMin._isActive ? this.handleMin : this.focusNode)
						.setAttribute("aria-valuemin", this.min);
				}
				if ("baseClass" in props || "vertical" in props || "_reversed" in props) {
					this._refreshCSS();
				}
				this._positionHandles();
			},

			/**
			 * Set handle(s) position relative to the progress bar.
			 * @private
			 */
			_positionHandles: function () {
				var currentVal = this._getValueAsArray();
				if (currentVal.length === 1) {
					currentVal = [this.min, currentVal[0]];
				}
				var toPercent = (currentVal[1] - this.min) * 100 /
						(this.max < this.min ? this.min : this.max - this.min),
					toPercentMin = (currentVal[0] - this.min) * 100 /
						(this.max < this.min ? this.min : this.max - this.min);
				this.progressBar.style[this._propNames.progressBarSize] = (toPercent - toPercentMin) + "%";
				this.progressBar.style[this._propNames.progressBarStart] =
					(this._reversed ? (100 - toPercent) : toPercentMin) + "%";
			},

			/**
			 * Add/remove and set handle as needed.
			 * @private
			 */
			_refreshValueRendering: function () {
				var currentVal = this._getValueAsArray();
				if (!this.handleMin._isActive && currentVal.length === 2) {
					this.handleMin.setAttribute("aria-valuemin", this.min);
					this.focusNode.setAttribute("aria-valuemax", this.max);
					this.tabStops = "handleMin,focusNode";
					this.handleMin._isActive = true;
				}
				if (this.handleMin._isActive && currentVal.length === 1) {
					this.handleMin.className = "d-hidden";
					this.handleMin.removeAttribute("aria-valuemin");
					this.focusNode.setAttribute("aria-valuemin", this.min);
					this.focusNode.setAttribute("aria-valuemax", this.max);
					this.handleMin._isActive = false;
				}
				// update aria attributes
				if (this.handleMin._isActive) {
					this.handleMin.setAttribute("aria-valuenow", currentVal[0]);
					this.handleMin.setAttribute("aria-valuemax", currentVal[1]);
					this.focusNode.setAttribute("aria-valuemin", currentVal[0]);
					this.focusNode.setAttribute("aria-valuenow", currentVal[1]);
				} else {
					this.focusNode.setAttribute("aria-valuenow", currentVal[0]);
				}
				// set input field value.
				this.valueNode.value = String(this.value);
			},

			createdCallback: function () {
				this._pointerCtx = {
					target: null, // the element that has focus when user manipulate a pointer
					offsetVal: 0, // Offset value when use points and drag a handle
					containerBox: null // to avoid recalculations when moving the slider with a pointer
				};

				this.on("pointerdown", this.pointerDownHandler.bind(this));
				this.on("pointermove", this.pointerMoveHandler.bind(this));
				this.on("lostpointercapture", this.lostCaptureHandler.bind(this));
				this.on("keydown", this.keyDownHandler.bind(this));
				this.on("keyup", this.keyUpHandler.bind(this));
			},

			postRender: function () {
				if (this.valueNode.value) { // INPUT value
					// browser back button or value coded on INPUT
					// the valueNode value has precedence over the widget markup value
					this.value = this.valueNode.value;
				}
			},

			attachedCallback: function () {
				// Chrome: avoids text selection of elements when mouse is dragged outside of the Slider.
				this.onmousedown = function (e) {
					e.preventDefault();
				};
			},

			/**
			 * HTML 5.1 input range spec:
			 * The min attribute, if specified, must have a value that is a valid floating-point number.
			 * The default minimum is 0.
			 * If the element has a min attribute, and the result of applying the algorithm to convert a
			 * string to a number to the value of the min attribute is a number, then that number is the element's
			 * minimum; otherwise, if the type attribute's current state defines a default minimum, then
			 * that is the minimum.
			 * @param value
			 * @private
			 */
			_setMinAttr: function (value) {
				this._set("min", this._convert2Float(value, 0));
			},

			/**
			 * HTML 5.1 input range spec:
			 * The max attribute, if specified, must have a value that is a valid floating-point number.
			 * The default maximum is 100.
			 * If the element has a max attribute, and the result of applying the algorithm to convert a
			 * string to a number to the value of the max attribute is a number, then that number is the element's
			 * maximum; otherwise, if the type attribute's current state defines a default maximum,
			 * then that is the maximum;
			 * @param value
			 * @private
			 */
			_setMaxAttr: function (value) {
				this._set("max", this._convert2Float(value, 100));
			},

			/**
			 * Must be a positive floating-point number. Invalid step value is defaulted to 1.
			 * @param value
			 * @private
			 */
			_setStepAttr: function (value) {
				value = this._convert2Float(value, 1);
				this._set("step", value <= 0 ? 1 : value);
			},

			/**
			 * HTML 5.1 spec (input range attributes):
			 * The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.
			 * @param value
			 * @param defaultValue
			 * @returns {Number|*}
			 * @private
			 */
			_convert2Float: function (value, defaultValue) {
				var v = parseFloat(value);
				return (isNaN(v) || v === Infinity) ? defaultValue : v;
			},

			/**
			 * HTML 5.1 input range spec:
			 * The default value is the minimum plus half the difference between the minimum and the
			 * maximum, unless the maximum is less than the minimum, in which case the default value
			 * is the minimum.
			 * @param ratio For a single handle, ratio is 0.5 ("half the difference between the minimum and the
			 * maximum"). For dual handle, it is 0.25 or 0.75.
			 * @private
			 */
			_calculateDefaultValue: function (ratio) {
				return this.max < this.min ? this.min : this.min + (this.max - this.min) * ratio;
			},

			/**
			 * Correct the value according to the HTML 5.1 input range spec.
			 * @param value the actual value to correct
			 * @param relativeMin the minimum value relative to the current value.
			 * @returns {Number|*}
			 * @private
			 */
			_adjustValue: function (value, relativeMin) {
				// value = (this.max > this.min) ? Math.min(this.max, value) : value;
				// When the element is suffering from a step mismatch, the user agent must round the element's value to
				// the nearest number for which the element would not suffer from a step mismatch, and which is greater
				// than or equal to the minimum, and, if the maximum is not less than the minimum, which is less than or
				// equal to the maximum, if there is a number that matches these constraints. If two numbers match these
				// constraints, then user agents must use the one nearest to positive infinity.
				if (value % this.step) {
					var x = Math.max(relativeMin, Math.round(value / this.step) * this.step);
					value = (this.max > relativeMin) ? Math.min(this.max, x) : x;
				}
				// When the element is suffering from an underflow, the user agent must set the element's
				// value to a valid floating-point number that represents the minimum. (spec)
				value = Math.max(relativeMin, value);
				// When the element is suffering from an overflow, if the maximum is not less than the minimum,
				// the user agent must set the element's value to a valid floating-point number that represents
				// the maximum. (spec)
				value = Math.min(this.max > this.min ? this.max : this.min, value);
				return value;
			},

			/**
			 * Convenience method to get the value as an array.
			 * @returns {Array}
			 * @private
			 */
			_getValueAsArray: function () {
				return String(this.value).split(/,/g);
			},

			/* jshint maxcomplexity: 11 */
			pointerDownHandler: function (e) {
				if (this._ignoreUserInput(e)) {
					return;
				}

				this._pointerCtx.target = null;
				this._pointerCtx.offsetVal = 0;
				this._pointerCtx.containerBox = boxFromElement(this.wrapperNode);
				var currentVal = this._getValueAsArray();
				var selectedVal = this._selectedValue(e, this._pointerCtx.containerBox);

				if (this._startSlideRange(e)) {
					// user is about to slide a range of values
					this._pointerCtx.target = this.progressBar;
					this._pointerCtx.offsetVal = selectedVal - currentVal[0];
				} else {
					// relativePos allow to determine which handle should get the focus and move, according to the
					// selected value:
					// relativePos > 0 => handleMin
					// relativePos < 0 => focusNode
					// relativePos = 0 => must be decided 
					var relativePos = Math.abs(selectedVal - currentVal[1]) - Math.abs(selectedVal - currentVal[0]);
					if (relativePos === 0 && (e.target === this.focusNode || e.target === this.handleMin)) {
						this._pointerCtx.target = document.elementFromPoint(e.clientX, e.clientY);
					} else {
						if (relativePos === 0) {
							// determine which handle can move to the position of the selected value.
							relativePos = currentVal[0] -
								Math.min(this.max - this.step, Math.max(this.min + this.step, selectedVal));
						}
						// get the handle which is closest from the selected value.
						this._pointerCtx.target = (relativePos > 0) ? this.handleMin : this.focusNode;
					}
					this._pointerCtx.target.focus();
					if (e.target !== this.focusNode && e.target !== this.handleMin) {
						this.handleOnInput(this._formatSelection(selectedVal, this._pointerCtx.target));
					}

				}
				if (e.target === this.focusNode || e.target === this.handleMin) {
					// track offset between current and selected value 
					this._pointerCtx.offsetVal = selectedVal -
						currentVal[(this.handleMin._isActive && (this._pointerCtx.target === this.focusNode)) ? 1 : 0];
				}
				// start capture on the target element
				dpointer.setPointerCapture(this._pointerCtx.target, e.pointerId);
				e.stopPropagation();
			},

			pointerMoveHandler: function (e) {
				if (e.target === this._pointerCtx.target) {
					this.handleOnInput(this._formatSelection(this._selectedValue(e, this._pointerCtx.containerBox) -
						this._pointerCtx.offsetVal, e.target));
					e.stopPropagation();
				}
			},

			lostCaptureHandler: function () {
				this._pointerCtx.target = null;
				this.handleOnChange(this.value);
			},

			/* jshint maxcomplexity: 13 */
			keyDownHandler: function (e) {
				if (this._ignoreUserInput(e)) {
					return;
				}
				var currentVal = this._getValueAsArray(),
					idx = (e.target === this.focusNode) ? currentVal.length - 1 : 0,
					multiplier = 1,
					newValue;
				switch (e.key) {
				case "Home":
					newValue = [this.min, currentVal[0]][idx];
					break;
				case "End":
					newValue = (e.target === this.handleMin) ? currentVal[1] : this.max;
					break;
				case "ArrowRight":
					multiplier = -1;
					/* falls through */
				case "ArrowLeft":
					newValue = parseFloat(currentVal[idx]) +
						multiplier * ((this.flip && !this.vertical) ? this.step : -this.step);
					break;
				case "ArrowDown":
					multiplier = -1;
					/* falls through */
				case "ArrowUp":
					newValue = parseFloat(currentVal[idx]) +
						multiplier * ((!this.flip || !this.vertical) ? this.step : -this.step);
					break;
				default:
					return;
				}
				this.handleOnInput(this._formatSelection(newValue, e.target));
				e.preventDefault();
			},

			keyUpHandler: function (e) {
				if (this._ignoreUserInput(e)) {
					return;
				}
				if (e.target === this.focusNode || e.target === this.handleMin) {
					this.handleOnChange(this.value);
				}
			},

			/**
			 * Return true if the user input should be ignored.
			 * @param event
			 * @returns {Boolean}
			 * @private
			 */
			_ignoreUserInput: function (event) {
				return this.disabled || this.readOnly || event.altKey || event.ctrlKey || event.metaKey;
			},

			/**
			 * Return true if all conditions required to slide a range of value are fulfilled.
			 * @param uiEvent
			 * @returns {boolean}
			 * @private
			 */
			_startSlideRange: function (uiEvent) {
				if (!(this.slideRange && this.handleMin._isActive) ||
					uiEvent.target === this.focusNode || uiEvent.target === this.handleMin) {
					return false;
				}
				var progressBarBox = boxFromElement(this.progressBar);
				var currentPos = uiEvent[this._propNames.clientStart] - progressBarBox[this._propNames.start];
				var maxPos = progressBarBox[this._propNames.size];
				return (currentPos >= 0 && currentPos <= maxPos);
			},

			/**
			 * Read UI Event coordinates and calculate the corresponding value, corrected with the step, without
			 * enforcing boundaries to allow user to slide the handle outside the boundaries to set value to min/max.
			 * @param uiEvent a UI event
			 * @param containerBox
			 * @private
			 */
			_selectedValue: function (uiEvent, containerBox) {
				function pixel2value(pixelValue, pixelMin, pixelMax, valMin, valMax) {
					return ((pixelValue - pixelMin) * (valMax - valMin)) / (pixelMax - pixelMin) + valMin;
				}

				var pixelMax = containerBox[this._propNames.size];
				var pixelValue = uiEvent[this._propNames.clientStart] - containerBox[this._propNames.start];
				return Math.round(pixel2value(pixelValue, this._reversed ? pixelMax : 0, this._reversed ? 0 : pixelMax,
					this.min, this.max) / this.step) * this.step;
			},

			/**
			 * format and return the selected value corrected from min/max boundaries in case the handle is released
			 * outside of the widget coordinates.
			 * @param newValue the new selected value
			 * @param sourceNode the node responsible of the new selected value
			 * @private
			 */
			_formatSelection: function (newValue, sourceNode) {
				var currentVal = this._getValueAsArray();
				var updatedValue = newValue;
				switch (sourceNode) {
				case this.focusNode:
					updatedValue = (currentVal.length === 1) ? String(newValue) :
						Math.min(currentVal[0], newValue) + "," + newValue;
					break;
				case this.handleMin:
					updatedValue = newValue + "," + Math.max(currentVal[1], newValue);
					break;
				case this.progressBar:
					var delta = currentVal[1] - currentVal[0];
					newValue = Math.max(this.min, Math.min(newValue + delta, this.max) - delta);
					updatedValue = newValue + "," + (newValue + delta);
					break;
				}
				return updatedValue;
			}
		});
});
;
/**
 * Plugin to load the specified CSS file, substituting {{theme}} with the theme for the current page.
 * This plugin will also load the common css file for the theme, `delite/themes/{{theme}}/common.css`,
 * even if no resource is provided (like in `delite/theme!`).
 *
 * For example, on an iPhone `theme!./css/{{theme}}/Button.css`
 * will load `./css/ios/Button.css` and `delite/themes/ios/common.css`.
 *
 * You can also pass an additional URL parameter string
 * `theme={theme widget}` to force a specific theme through the browser
 * URL input. The available theme ids are bootstrap, holodark (theme introduced in Android 3.0)
 * and ios. The theme names are case-sensitive. If the given
 * theme does not match, the bootstrap theme is used.
 *
 * ```
 * http://your.server.com/yourapp.html --> automatic detection
 * http://your.server.com/yourapp.html?theme=holodark --> forces Holodark theme
 * http://your.server.com/yourapp.html?theme=ios --> forces iPhone theme
 * ```
 *
 * You can also specify a particular user agent through the `ua=...` URL parameter.
 *  @module delite/theme
 */
define('delite/theme',[
	"require",
	"requirejs-dplugins/has",
	"module",
	"requirejs-dplugins/css"
], function (req, has, module, css) {

	"use strict";

	var config = module.config();

	var load = /** @lends module:delite/theme */ {
		/**
		 * A map of user-agents to theme files.
		 *
		 * The first array element is a regexp pattern that matches the userAgent string.
		 * The second array element is a theme folder widget.
		 * The matching is performed in the array order, and stops after the first match.
		 *
		 * Can be overridden by a module-level configuration setting passed to AMD loader:
		 *
		 * ```js
		 * require.config({
		 *     config: {
		 *         "delite/theme": {
		 *             themeMap: ...
		 *         }
		 *     }
		 * });
		 * ```
		 * @member {Array}
		 * @default [[/Holodark|Android/, "holodark"], [/iPhone/iPad/, "ios"], [/.*\/, "bootstrap"]]
		 */
		themeMap: config.themeMap || [
			// Temporarily comment out until more widgets support them
			// [/Holodark|Android/, "holodark"],
			// [/iPhone|iPad/, "ios"],
			[/.*/, "bootstrap"]			// chrome, firefox, IE
		],

		/**
		 * Compute the theme name, according to browser and this.themeMap.
		 * @private
		 */
		getTheme: function () {
			var theme = load.theme || config.theme;
			if (!theme) {
				var matches = location.search.match(/theme=(\w+)/);
				theme = matches && matches.length > 1 ? matches[1] : null;
			}
			if (!theme) {
				var ua = config.userAgent || (location.search.match(/ua=(\w+)/) ? RegExp.$1 : navigator.userAgent),
					themeMap = this.themeMap;
				for (var i = 0; i < themeMap.length; i++) {
					if (themeMap[i][0].test(ua)) {
						theme = themeMap[i][1];
						break;
					}
				}
			}
			load.theme = theme;
			return theme;
		},

		/**
		 * Load and install the specified CSS file for the given path, then call onload().
		 * @param {string} path - Simplified path. It will be expanded to convert {{theme}} to the current theme.
		 * @param {Function} require - AMD's require() method.
		 * @param {Function} onload - Callback function which will be called when the loading finishes
		 * and the stylesheet has been inserted.
		 * @private
		 */
		load: function (path, require, onload) {
			// Update config to be sure to get latest value.
			config = module.config();

			// Add CSS file which contains definitions common to the theme.
			// Use absolute MID (rather than relative MID) for benefit of builder, and since the MID specified
			// in path has already been converted to an absolute MID.
			var commonCss = module.id.replace(/\/.*/, "") + "/themes/{{theme}}/common.css";
			var resources = path ? [commonCss, path] : [commonCss];

			if (has("builder")) {
				resources.forEach(function (path) {
					css.buildFunctions.addOnce(loadList, path);
				});
				onload();
				return;
			}

			// Replace single css bundles by corresponding layer.
			if (config.layersMap) {
				resources = resources.map(function (path) {
					return config.layersMap[path] || path;
				});
			}

			// Convert list of logical resources into list of dependencies.
			// ex: Button/css/{{theme}}/Button.css --> requirejs-dplugins/css!Button/css/ios/Button.css
			var deps = resources.map(function (path) {
				return css.id + "!" + path.replace(/{{theme}}/, load.getTheme());
			});

			// Call css! plugin to insert the stylesheets.
			req(deps, function () {
				onload(arguments);
			});
		}
	};

	if (has("builder")) {
		var loadList = [];
		var writePluginFiles;

		load.writeFile = function (pluginName, resource, require, write) {
			writePluginFiles = write;
		};

		load.onLayerEnd = function (write, data) {
			function getLayerPath(theme) {
				var pathRE = /^(?:\.\/)?(([^\/]*\/)*)[^\/]*$/;
				return data.path.replace(pathRE, "$1themes/layer_" + (theme || "{{theme}}") + ".css");
			}

			if (data.name && data.path) {
				var success = load.themeMap.map(function (theme) {
					var themeDir = theme[1];
					var dest = getLayerPath(themeDir);
					var themedLoadList = loadList.map(function (path) {
						return path.replace(/{{theme}}/g, themeDir);
					});
					return css.buildFunctions.writeLayer(writePluginFiles, dest, themedLoadList);
				}).every(function (bool) {
					return bool;
				});

				// Write generic css config with {{theme}} on the layer (only if the layers were successfully
				// written).
				var destMid = data.name.replace(/^(([^\/]*\/)*)[^\/]*$/, "$1themes/layer_{{theme}}.css");
				success && css.buildFunctions.writeConfig(write, module.id, destMid, loadList);

				// Reset loadList
				loadList = [];
			}
		};
	}
	return load;
});
;
/**
 * Plugin that loads a handlebars template from a specified MID and returns a function to
 * generate DOM corresponding to that template.
 *
 * When that function is run, it returns another function,
 * meant to be run when the widget properties change.  The returned function will update the
 * DOM corresponding to the widget property changes.
 *
 * Both functions are meant
 * to be run in the context of the widget, so that properties are available through `this`.
 *
 * Could also theoretically be used by a build-tool to precompile templates, assuming you loaded
 * [jsdom](https://github.com/tmpvar/jsdom) to provide methods like `document.createElement()`.
 * But the problem is that the build tool has to load the definitions for the custom elements
 * referenced in the templates, in order to get the types of their properties.
 *
 * Template has a format like:
 *
 * ```html
 * <button>
 *   <span class="d-reset {{iconClass}}"></span>
 *   {{label}}
 * </button>
 * ```
 *
 * Usage is typically like:
 *
 * ```js
 * define([..., "delite/handlebars!./templates/MyTemplate.html"], function(..., template){
 *     ...
 *     template: template,
 *     ...
 * });
 * ```
 *
 * @module delite/handlebars
 */
define('delite/handlebars',[
	"module",
	"require",
	"requirejs-dplugins/has",
	"requirejs-dplugins/Promise!",
	"requirejs-text/text",
	"./Template"
], function (module, moduleRequire, has, Promise, textPlugin, Template) {

	/**
	 * Given a string like "hello {{foo}} world", generate JS code to output that string,
	 * ex: "hello" + this.foo + "world"
	 * @param {string} text
	 * @param {boolean} convertUndefinedToBlank - Useful so that class="foo {{item.bar}}" will convert to class="foo"
	 * rather than class="foo undefined", but for something like aria-valuenow="{{value}}", when value is undefined
	 * we need to leave it that way, to trigger removal of that attribute completely instead of setting
	 * aria-valuenow="".
	 * @returns {string} like "'hello' + this.foo + 'world'"
	 */
	function toJs(text, convertUndefinedToBlank) {
		var pos = 0, length = text.length, insideBraces = false, parts = [];

		while (pos < length) {
			var bracesIndex = text.indexOf(insideBraces ? "}}" : "{{", pos),
				str = text.substring(pos, bracesIndex === -1 ? length : bracesIndex);
			if (insideBraces) {
				// str is a property name or a JS expression.
				var prop = str.trim();
				if (/this\./.test(prop)) {
					// JS expression (ex: this.selectionMode === "multiple")
					parts.push("(" + prop + ")");
				} else {
					// Property (ex: selectionMode) or path (ex: item.foo)
					parts.push(convertUndefinedToBlank ? "(this." + prop + "== null ? '' : this." + prop + ")" :
						"this." + prop);
				}
			} else {
				// string literal, single quote it and escape special characters
				if (str) {
					parts.push("'" +
						str.replace(/(['\\])/g, "\\$1").replace(/\n/g, "\\n").replace(/\t/g, "\\t") + "'");
				}
			}
			pos = bracesIndex === -1 ? length : bracesIndex + 2;
			insideBraces = !insideBraces;
		}

		return parts.join(" + ");
	}

	var handlebars = /** @lends module:delite/handlebars */ {
		/**
		 * Given a template in DOM, returns the Object tree representing that template.
		 * @param {Element} templateNode - Root node of template.
		 * @param {string} [xmlns] - Used primarily for SVG nodes.
		 * @returns {Object} Object in format
		 * `{tag: string, xmlns: string, attributes: {}, children: Object[], attachPoints: string[]}`.
		 * @private
		 */
		parse: function (templateNode, xmlns) {
			// Get tag name, reversing the tag renaming done in toDom()
			var tag = templateNode.hasAttribute("is") ? templateNode.getAttribute("is") :
					templateNode.tagName.replace(/^template-/i, "").toLowerCase(),
				elem = Template.getElement(tag);

			// Process attributes
			var attributes = {}, connects = {}, attachPoints;
			var i = 0, item, attrs = templateNode.attributes;
			while ((item = attrs[i++])) {
				var name = item.name.replace("template-", ""), value = item.value;
				if (value || typeof elem[name.toLowerCase()] === "boolean") {
					switch (name) {
					case "xmlns":
						xmlns = value;
						break;
					case "is":
						// already handled above
						break;
					case "attach-point":
					case "data-attach-point":		// in case user wants to use HTML validator
						attachPoints = value.split(/, */);
						break;
					default:
						if (/^on-/.test(name)) {
							// on-click="{{handlerMethod}}" sets connects.click = "handlerMethod"
							connects[name.substring(3)] = value.replace(/\s*({{|}})\s*/g, "");
						} else {
							attributes[name] = this.parseValueAttribute(tag, elem, name, value);
						}
					}
				}
			}

			return {
				tag: tag,
				xmlns: xmlns,
				attributes: attributes,
				connects: connects,
				children: handlebars.parseChildren(templateNode, xmlns),
				attachPoints: attachPoints
			};
		},

		/**
		 * Parse markup for a normal attribute, ex: value="foo".  Does not handle on-click="..." or attach-point="...".
		 * Returns the value to set for the corresponding property (if there's a shadow property), or otherwise
		 * the value to set for the attribute.
		 * For example, for markup of value="fred", returns "fred", and for selected="selected", returns true.
		 * @param {string} tag - Name of tag, ex: "div".
		 * @param {Element} elem - Example element.
		 * @param {string} name - The name of the attribute.
		 * @param {string} value - The value of the attribute.
		 * @returns {string} Javascript expression representing the value, ex: "true" or "5 + this.bar".
		 * @private
		 */
		parseValueAttribute: function (tag, elem, name, value) {
			// map x="hello {{foo}} world" --> "hello " + this.foo + " world";
			var propName = Template.getProp(tag, name),
				propType = typeof elem[propName];
			if (propName && propType !== "string" && !/{{/.test(value) && propName !== "style.cssText") {
				// This attribute corresponds to a non-string property, and the value specified is a
				// literal like vertical="false", so *don't* convert value to string.
				if (propType === "boolean") {
					// Convert autocorrect="on" and selected="selected" and just <option selected> to set
					// corresponding properties to true.  Also convert autocorrect="off" to set
					// corresponding property to false.
					return value === "off" || value === "false" ? "false" : "true";
				} else {
					return value;
				}
			} else {
				return toJs(value, name === "class");
			}
		},

		/**
		 * Scan child nodes, both text and Elements.
		 * @param {Element} templateNode
		 * @param {string} [xmlns] - Used primarily for SVG nodes.
		 * @returns {Array}
		 * @private
		 */
		parseChildren: function (templateNode, xmlns) {
			var children = [];

			// Index of most recent non-whitespace node added to children array
			var lastRealNode;

			// Scan all the children, populating children[] array.
			// Trims starting and ending whitespace nodes, but not whitespace in the middle, so that
			// the following example only ends up with one whitespace node between hello and world:
			//
			// <div>\n\t<span>hello</span> <span>world</span>\n</div>
			for (var child = templateNode.firstChild; child; child = child.nextSibling) {
				var childType = child.nodeType;
				if (childType === 1) {
					// Standard DOM node, recurse
					lastRealNode = children.length;
					children.push(handlebars.parse(child, xmlns));
				} else if (childType === 3) {
					// Text node likely containing variables like {{foo}}.
					if (/^[ \t\n]*$/.test(child.nodeValue)) {
						// Whitespace node.  Note: avoided using trim() since that removes &nbsp; nodes.
						if (lastRealNode === undefined) {
							// Skip leading whitespace nodes
							continue;
						}
					} else {
						lastRealNode = children.length;
					}
					children.push(toJs(child.nodeValue, true));
				}
			}

			return children.slice(0, lastRealNode + 1); // slice() removes trailing whitespace nodes
		},


		/**
		 * Neutralize custom element tags.
		 * Rename all the elements in the template so that:
		 * 1. browsers with native document.createElement() support don't start instantiating custom elements
		 *    in the template, creating internal nodes etc.
		 * 2. prevent <select size={{size}}> from converting to <select size=0> on webkit
		 * 3. prevent <img src={{foo}}> from starting an XHR for a URL called {{foo}} (webkit, maybe other browsers)
		 * @private
		 */
		neutralizeTags: function (templateText) {
			// Regex will not match <!-- comment -->.
			templateText = templateText.replace(
				/(<\/? *)([-a-zA-Z0-9]+)/g, "$1template-$2");

			// For self-closing tags like <input> that have been converted to <template-input>, we need to add a
			// closing </template-input> tag.
			templateText = templateText.replace(
				/* jshint maxlen:200 */
				/<template-(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)([^>]*?)\/?>/g,
				"<template-$1$2></template-$1>");

			// Also rename style attribute, because IE will drop style="..." if the ... is an illegal value
			// like "height: {{foo}}px".
			templateText = templateText.replace(/style=/g, "template-style=");

			return templateText;
		},

		/**
		 * Given a template string, returns the DOM tree representing that template.  Will only run in a browser.
		 * @param {string} templateText - HTML text for template.
		 * @returns {Element} Root element of tree.
		 * @private
		 */
		toDom: function (templateText) {
			templateText = handlebars.neutralizeTags(templateText);

			// Create DOM tree from template.
			// If template contains SVG nodes then parse as XML, to preserve case of attributes like viewBox.
			// Otherwise parse as HTML, to allow for missing closing tags, ex: <ul> <li>1 <li>2 </ul>.
			var root;
			if (/<template-svg/.test(templateText)) {
				var parser = new DOMParser();
				root = parser.parseFromString(templateText, "text/xml").firstChild;
				while (root.nodeType !== 1) {
					// Skip top level comment and move to "real" template root node.
					// Needed since there's no .firstElementChild or .nextElementSibling for SVG nodes on FF.
					root = root.nextSibling;
				}
			} else {
				// Use innerHTML because Safari doesn't support DOMParser.parseFromString(str, "text/html")
				var container = document.createElement("div");
				container.innerHTML = templateText;
				root = container.firstElementChild; // use .firstElementChild to skip possible top level comment
			}

			return root;
		},

		/**
		 * Given a template, returns a function to generate DOM corresponding to that template,
		 * and setup listeners (using `Stateful#observe()`) to propagate changes in the widget
		 * properties to the templates.
		 *
		 * This method is usually only called directly when your template contains custom elements,
		 * and a call to handlebars!myTemplate.html might try to compile the template before the custom
		 * elements were loaded.
		 *
		 * @param {string} template - See module description for details on template format.
		 * @returns {Function} - Function that optionally takes a top level node, or creates it if not passed in, and
		 * then creates the rest of the DOMNodes in the template.
		 */
		compile: function (templateText) {
			var templateDom = handlebars.toDom(templateText);
			var tree = handlebars.parse(templateDom);
			var template = new Template(tree);
			return template.func;
		},

		/**
		 * Similar to compile() but before compiling the template, loads the modules specified in the
		 * template via the `requires=...` attribute.
		 * @param {string} templateText - See module description for details on template format.
		 * @param {Function} require - AMD's require() method.
		 * @returns {Promise} Promise for the function that compile() would have returned.
		 */
		requireAndCompile: function (templateText, require) {
			var templateDom = handlebars.toDom(templateText),
				requires = templateDom.getAttribute("requires") ||
					templateDom.getAttribute("data-requires") || "";
			templateDom.removeAttribute("requires");
			templateDom.removeAttribute("data-requires");

			return new Promise(function (resolve) {
				require(requires.split(/,\s*/), function () {
					var tree = handlebars.parse(templateDom);
					var template = new Template(tree);
					resolve(template.func);
				});
			});
		},

		/**
		 * Returns a function to generate the DOM specified by the template.
		 * Also loads any AMD dependencies specified on the template's root node via the `requires` property.
		 * This is the function run when you use this module as a plugin.
		 * @param {string} mid - Absolute path to the resource.
		 * @param {Function} require - AMD's require() method.
		 * @param {Function} onload - Callback function which will be called with the compiled template.
		 * @param {Object} loaderConfig - Configuration object from the loader with `isBuild === true`
		 * when doing a build.
		 * @private
		 */
		load: function (mid, require, onload) {
			textPlugin.load(mid, require, function (templateText) {
				this.requireAndCompile(templateText, require).then(onload);
			}.bind(this));
		}
	};

	if (has("builder")) {
		var fs = require.nodeRequire("fs"),
			jsdom = require.nodeRequire("jsdom").jsdom;

		// Info about the MID being currently processed
		var templateText, templateRequires;

		handlebars.load = function (mid, require, onload) {
			templateText = fs.readFileSync(require.toUrl(mid), "utf8");
			onload();
		};

		// Inline the template text and list of dependencies into the layer file.
		handlebars.write = function (pluginName, moduleName, write) {
			var dom = jsdom(templateText),
				template = dom.querySelector("template"),
				requiresAttr = template.getAttribute("requires") || template.getAttribute("data-requires");
			templateRequires = requiresAttr ? requiresAttr.split(/,\s*/) : [];
			template.removeAttribute("requires");
			template.removeAttribute("data-requires");

			var moduleRequires = [module.id].concat(templateRequires);
			var moduleText = "define(" + JSON.stringify(moduleRequires) +  ", function(handlebars){\n" +
				"\treturn handlebars.compile(" + JSON.stringify(template.outerHTML) + ");\n" +
				"});";
			write.asModule(pluginName + "!" + moduleName, moduleText);
		};

		// Notify builder to take dependencies specified in requires="..." attribute, and inline them into the layer.
		handlebars.addModules = function (pluginName, resource, addModules) {
			addModules(templateRequires);

		};
	}

	return handlebars;
});
;
/** @module delite/Widget */
define('delite/Widget',[
	"dcl/dcl",
	"requirejs-dplugins/jquery!attributes/classes",	// addClass(), removeClass()
	"./features",
	"decor/Invalidating",
	"./CustomElement",
	"./register",
	"./features!bidi?./Bidi"
], function (dcl, $, has, Invalidating, CustomElement, register, Bidi) {
	// Used to generate unique id for each widget
	var cnt = 0;

	/**
	 * Base class for all widgets, i.e. custom elements that appear visually.
	 *
	 * Provides stubs for widget lifecycle methods for subclasses to extend, like `render()`,
	 * `postRender()`, and `destroy()`, and also public API methods like `observe()`.
	 * @mixin module:delite/Widget
	 * @augments module:delite/CustomElement
	 * @augments module:decor/Invalidating
	 * @mixes module:delite/Bidi
	 */
	var Widget = dcl([CustomElement, Invalidating], /** @lends module:delite/Widget# */ {

		/**
		 * Root CSS class of the widget (ex: "d-text-box")
		 * @member {string}
		 * @protected
		 */
		baseClass: "",

		/**
		 * This widget or a widget it contains has focus, or is "active" because
		 * it was recently clicked.
		 * @member {boolean}
		 * @default false
		 * @protected
		 */
		focused: false,

		/**
		 * Unique id for this widget, separate from id attribute (which may or may not be set).
		 * Useful when widget creates subnodes that need unique id's.
		 * @member {number}
		 * @constant
		 * @readonly
		 * @protected
		 */
		widgetId: 0,

		/**
		 * Controls the layout direction of the widget, for example whether the arrow of
		 * a Combobox appears to the right or the left of the input field.
		 *
		 * Values are "ltr" and "rtl", or "" which means that the value is inherited from the
		 * setting on the document root (either `<html>` or `<body>`).
		 *
		 * @member {string}
		 */
		dir: "",

		/**
		 * Actual direction of the widget, which can be set explicitly via `dir` property or inherited from the
		 * setting on the document root (either `<html>` or `<body>`).
		 * Value is either "ltr" or "rtl".
		 * @member {string}
		 * @readonly
		 */
		effectiveDir: "",

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		createdCallback: function () {
			this.widgetId = ++cnt;
		},

		// deliver() is called on widget creation, either from CustomElement#attachedCallback() (for the declarative
		// case) or the widget constructor (for the programmatic case).  At that point, Invalidating's observers haven't
		// been set up yet, so Stateful#deliver() won't call computeProperties() or refreshRendering().  But instead,
		// Widget calls Invalidating#initializeInvalidating(), which calls computeProperties(this, true) and
		// refreshRendering(this, true).
		deliver: dcl.after(function () {
			this.initializeInvalidating();
		}),

		computeProperties: function (props) {
			if ("dir" in props) {
				if ((/^(ltr|rtl)$/i).test(this._get("dir"))) {
					this.effectiveDir = this._get("dir").toLowerCase();
				} else {
					this.effectiveDir = this.getInheritedDir();
				}
			}
		},

		shouldInitializeRendering: function (oldVals) {
			// render the template on widget creation and also whenever app changes template prop
			return !this.rendered || "template" in oldVals;
		},

		initializeRendering: function () {
			this.rendered = false;
			this.preRender();
			this.render();
			this.postRender();
			this.rendered = true;
		},

		/**
		 * Get the direction setting for the page itself.
		 * @returns {string} "ltr" or "rtl"
		 * @protected
		 */
		getInheritedDir: function () {
			return (this.ownerDocument.body.dir || this.ownerDocument.documentElement.dir || "ltr").toLowerCase();
		},

		// Override Invalidating#refreshRendering() to execute the template's refreshRendering() code, etc.
		refreshRendering: function (oldVals, justRendered) {
			if (this._templateHandle && !justRendered) {
				// Refresh the template based on changed values, but not right after the template is rendered,
				// because that would be redundant.
				this._templateHandle.refresh(oldVals);
			}

			if ("baseClass" in oldVals) {
				$(this).removeClass(oldVals.baseClass).addClass(this.baseClass);
			}
			if ("effectiveDir" in oldVals) {
				$(this).toggleClass("d-rtl", this.effectiveDir === "rtl");
			}
			if ("dir" in oldVals) {
				this.style.direction = this._get("dir");
			}
		},

		attachedCallback: dcl.after(function () {
			// Call attachedCallback() on any widgets in the template
			if (this._templateHandle && !has("document-register-element")) {
				this._templateHandle.attach();
			}
		}),

		/**
		 * Processing before `render()`.
		 *
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @protected
		 */
		preRender: function () {
		},

		/**
		 * Value returned by delite/handlebars! or compatible template engine.
		 * Specifies how to build the widget DOM initially and also how to update the DOM when
		 * widget properties change.
		 * @member {Function}
		 * @protected
		 */
		template: null,

		/**
		 * Construct the UI for this widget, filling in subnodes and/or text inside of this.
		 * Most widgets will leverage delite/handlebars! to set `template`, rather than defining this method.
		 * @protected
		 */
		render: function () {
			// Tear down old rendering (if there is one).
			if (this._templateHandle) {
				this._templateHandle.destroy();
				delete this._templateHandle;
			}

			// Render the widget.
			if (this.template) {
				this._templateHandle = this.template(this.ownerDocument, register);
				if (this.attached && !has("document-register-element")) {
					this._templateHandle.attach();
				}
			}
		},

		/**
		 * Helper method to set a class (or classes) on a given node, removing the class (or classes) set
		 * by the previous call to `setClassComponent()` *for the specified component and node*.  Used mainly by
		 * template.js to set classes without overwriting classes set by the user or other code (ex: CssState).
		 * @param {string} component - Specifies the category.
		 * @param {string} value - Class (or classes) to set.
		 * @param {HTMLElement} [node] - The node to set the property on; defaults to widget root node.
		 * @protected
		 */
		setClassComponent: function (component, value, node) {
			if (!node) { node = this; }
			var oldValProp = "_" + component + "Class";
			$(node).removeClass(node[oldValProp] || "").addClass(value);
			node[oldValProp] = value;
		},

		/**
		 * Helper method to set/remove an attribute based on the given value:
		 *
		 * - If value is undefined, the attribute is removed.  Useful for attributes like aria-valuenow.
		 * - If value is boolean, the attribute is set to "true" or "false".  Useful for attributes like aria-selected.
		 * - If value is a number, it's converted to a string.
		 *
		 * @param {Element} node - The node to set the property on.
		 * @param {string} name - Name of the property.
		 * @param {string} value - Value of the property.
		 * @protected
		 */
		setOrRemoveAttribute: function (node, name, value) {
			if (value === undefined) {
				node.removeAttribute(name);
			} else {
				node.setAttribute(name, "" + value);
			}
		},

		/**
		 * Processing after the DOM fragment is created.
		 *
		 * Called after the DOM fragment has been created, but not necessarily
		 * added to the document.  Do not include any operations which rely on
		 * node dimensions or placement.
		 *
		 * This method is automatically chained, so subclasses generally do not need to use `dcl.superCall()`,
		 * `dcl.advise()`, etc.
		 * @protected
		 */
		postRender: function () {
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		detachedCallback: function () {
			// Call detachedCallback() on any widgets in the template
			if (this._templateHandle && !has("document-register-element")) {
				this._templateHandle.detach();
			}
			if (this.bgIframe) {
				this.bgIframe.destroy();
				delete this.bgIframe;
			}
		},

		/**
		 * Returns the parent widget of this widget, or null if there is no parent widget.
		 */
		getParent: function () {
			return this.parentNode ? this.getEnclosingWidget(this.parentNode) : null;
		},

		// Override CustomElement#on() to handle on("focus", ...) when the widget conceptually gets focus.
		on: dcl.superCall(function (sup) {
			return function (type, func, node) {
				// Treat on(focus, "...") like on("focusin", ...) since
				// conceptually when widget.focusNode gets focus, it means the widget itself got focus.
				// Ideally we would set up a wrapper function to ignore focus changes between nodes inside the widget,
				// but evt.relatedTarget in null on FF.
				type = {focus: "focusin", blur: "focusout"}[type] || type;

				return sup.call(this, type, func, node);
			};
		}),

		/**
		 * Place this widget somewhere in the dom, and allow chaining.
		 *
		 * @param {string|Element|DocumentFragment} reference - Element, DocumentFragment,
		 * or id of Element to place this widget relative to.
		 * @param {string|number} [position] Numeric index or a string with the values:
		 * - number - place this widget as n'th child of `reference` node
		 * - "first" - place this widget as first child of `reference` node
		 * - "last" - place this widget as last child of `reference` node
		 * - "before" - place this widget as previous sibling of `reference` node
		 * - "after" - place this widget as next sibling of `reference` node
		 * - "replace" - replace specified reference node with this widget
		 * - "only" - replace all children of `reference` node with this widget
		 * @returns {module:delite/Widget} This widget, for chaining.
		 * @protected
		 * @example
		 * // create a Button with no srcNodeRef, and place it in the body:
		 * var button = new Button({ label:"click" }).placeAt(document.body);
		 * @example
		 * // place a new button as the first element of some div
		 * var button = new Button({ label:"click" }).placeAt("wrapper","first");
		 * @example
		 * // create a contentpane and add it to a TabContainer
		 * var tc = document.getElementById("myTabs");
		 * new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)
		 */
		placeAt: function (reference, position) {
			if (typeof reference === "string") {
				reference = this.ownerDocument.getElementById(reference);
			}

			/* jshint maxcomplexity:14 */
			if (position === "replace") {
				reference.parentNode.replaceChild(this, reference);
			} else if (position === "only") {
				// SVG nodes, strict elements, and DocumentFragments don't support innerHTML
				for (var c; (c = reference.lastChild);) {
					reference.removeChild(c);
				}
				reference.appendChild(this);
			} else if (/^(before|after)$/.test(position)) {
				reference.parentNode.insertBefore(this, position === "before" ? reference : reference.nextSibling);
			} else {
				// Note: insertBefore(node, null) is equivalent to appendChild().  Second "null" arg needed only on IE.
				var parent = reference.containerNode || reference,
					children = parent.children || Array.prototype.filter.call(parent.childNodes, function (node) {
						return node.nodeType === 1;	// no .children[] on DocumentFragment :-(
					});
				parent.insertBefore(this, children[position === "first" ? 0 : position] || null);
			}

			if (!this.attached) {
				// run attach code for this widget and any descendant custom elements too
				this.attachedCallback(true);
			}

			return this;
		},


		/**
		 * Returns the widget whose DOM tree contains the specified DOMNode, or null if
		 * the node is not contained within the DOM tree of any widget
		 * @param {Element} node
		 */
		getEnclosingWidget: function (node) {
			do {
				if (node.nodeType === 1 && node.render) {
					return node;
				}
			} while ((node = node.parentNode));
			return null;
		}
	});

	if (has("bidi")) {
		Widget = dcl(Widget, Bidi);
	}

	// Setup automatic chaining for lifecycle methods, except for render().
	// destroy() is chained in Destroyable.js.
	dcl.chainAfter(Widget, "preRender");
	dcl.chainAfter(Widget, "postRender");

	return Widget;
});
;
/**
 *	When has("bidi") is true, delite/Widget will mix in the properties in this module.
 *	It enables support for the `textdir` property to control text direction independently from the GUI direction.
 * @module delite/Bidi
 */
define('delite/Bidi',[
	"./features"
], function (has) {

	// UCC - constants that will be used by bidi support.
	var LRE = "\u202A",
		RLE = "\u202B",
		PDF = "\u202C";

	return /** @lends module:delite/Bidi */ {

		/**
		 * Bi-directional support, the main variable which is responsible for the direction of the text.
		 * The text direction can be different than the GUI direction by using this parameter in creation
		 * of a widget.
		 *
		 * Allowed values:
		 *
		 * 1. "ltr"
		 * 2. "rtl"
		 * 3. "auto" - contextual the direction of a text defined by first strong letter.
		 *
		 * By default is as the page direction.
		 */
		textDir: "",

		/**
		 * Return the direction setting for the page itself, or if `has("inherited-dir")` is defined and the widget is
		 * attached to the page, then return the dir setting inherited from any ancestor node.
		 * @returns {string} "ltr" or "rtl"
		 * @protected
		 */
		getInheritedDir: function () {
			return this._inheritedDir || this.ownerDocument.body.dir || this.ownerDocument.documentElement.dir || "ltr";
		},

		attachedCallback: function () {
			if (has("inherited-dir")) {
				// Now that the widget is attached to the DOM, need to retrigger computation of effectiveDir.
				this._inheritedDir = window.getComputedStyle(this, null).direction;
				this.notifyCurrentValue("dir");
				this.deliver();
			}
		},

		/**
		 * Returns the right direction of text.
		 *
		 * If textDir is ltr or rtl, returns the value.
		 * If it's auto, calls to another function that's responsible
		 * for checking the value, and defining the direction.
		 *
		 * @param {string} text
		 * @returns {string} ltr or rtl
		 * @protected
		 */
		getTextDir: function (text) {
			var textDir = this.textDir;
			return textDir === "auto" ? this._checkContextual(text) :
				(/^(rtl|ltr)$/i).test(textDir) ? textDir : this.effectiveDir;
		},

		/**
		 * Finds the first strong (directional) character, return ltr if isLatin or rtl if isBidiChar.
		 *
		 * @param {string} text
		 * @returns {string} ltr or rtl
		 * @private
		 */
		_checkContextual: function (text) {
			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as default.
			return fdc ? (fdc[0] <= "z" ? "ltr" : "rtl") : this.effectiveDir;
		},

		/**
		 * Set element.dir according to this.textDir.
		 *
		 * @param {HTMLElement} element - The text element to be set. Should have dir property.
		 * @protected
		 */
		applyTextDir: function (element) {
			if (this.textDir) {
				var textDir = this.textDir;
				if (textDir === "auto") {
					// convert "auto" to either "ltr" or "rtl"
					var tagName = element.tagName.toLowerCase();
					var text = (tagName === "input" || tagName === "textarea") ? element.value : element.textContent;
					textDir = this._checkContextual(text);
				}
				element.dir = textDir;
			}
			else {
				element.dir = this.effectiveDir;
			}
		},

		/**
		 * Enforce base direction of the given text according to this.textDir.
		 *
		 * @param {string} text
		 * @returns {string}
		 * @protected
		 */
		applyTextDirection: function (text) {
			if (this.textDir) {
				return this.wrapWithUcc(this.removeUcc(text));
			} else {
				return this.removeUcc(text);
			}
		},

		/**
		 * Returns specified text with UCC added to enforce widget's textDir setting.
		 *
		 * @param {string} text
		 * @returns {string}
		 * @protected
		 */
		wrapWithUcc: function (text) {
			return (this.getTextDir(text) === "ltr" ? LRE : RLE) + text + PDF;
		},

		/**
		 * Removes UCC from specified text.
		 *
		 * @param {string} text
		 * @returns {string}
		 * @protected
		 */
		removeUcc: function (text) {
			return text && text.replace(/[\u200E\u200F\u202A-\u202C]/g, "");
		},

		/**
		 * Wraps by UCC (Unicode control characters) option's text according to this.textDir.
		 *
		 * This function saves the original text value for later restoration if needed,
		 * for example if the textDir will change etc.
		 *
		 * @param {HTMLOptionElement} node - The node we wrapping the text for.
		 * @protected
		 */
		enforceTextDirWithUcc: function (node) {
			node.originalText = node.text;
			node.innerHTML = this.applyTextDirection(node.innerHTML);
		},

		/**
		 * Restores the text of origObj, if needed, after enforceTextDirWithUcc, for example
		 * after `myWidget.textDir = "ltr"`.  The function then removes the originalText from origObj!
		 *
		 * @param {HTMLOptionElement} origObj - The node to restore.
		 * @protected
		 */
		restoreOriginalText: function (origObj) {
			if (origObj.originalText) {
				origObj.text = origObj.originalText;
				delete origObj.originalText;
			}
		}
	};
});
;
/** @module delite/Template */
define('delite/Template',["./register"], function (register) {

	// Get list of properties that the javascript expression depends on.
	// For example, for "this.label + ' hi ' + this.foo", returns ["label", "foo"].
	// For nested props (ex: this.item.foo), return top level prop (ex: item).
	function propertiesReferenced(expr) {
		var matches = expr.match(/this\.(\w+)/g);
		if (matches) {
			// use hash to remove duplicates, then convert to array to return
			return Object.keys(matches.reduce(function (hash, thisVar) {
				hash[thisVar.substring(5)] = true;	// "this.foo" --> "foo"
				return hash;
			}, {}));
		} else {
			return [];
		}
	}

	/**
	 * Given an AST representation of the template, generates a function that:
	 *
	 * 1. generates DOM corresponding to the template
	 * 2. returns an object including a function to be called to update that DOM
	 *    when widget properties have changed.
	 *
	 * The function is available through `this.func`, i.e.:
	 *
	 * ```js
	 * var template = new Template(ast);
	 * template.func(document, register);
	 * ```
	 *
	 * See the reference documentation for details on the AST format.
	 *
	 * @param {Object} tree - AST representing the template.
	 * @param {string} rootNodeName - Name of variable for the root node of the tree, typically `this`.
	 * @param {boolean} createRootNode - If true, create node; otherwise assume node exists in variable `nodeName`.
	 * @class module:delite/Template
	 */
	var Template = register.dcl(null, /** @lends module:delite/Template# */ {
		constructor: function (tree, rootNodeName, createRootNode) {
			this.buildText = [];	// code to build the initial DOM
			this.attachText = [];	// code to run in attachedCallback()
			this.detachText = [];	// code to run in detachedCallback()
			this.destroyText = [];	// code to run in tear down template, removing listeners etc.
			this.observeText = [];	// code to update the DOM when widget properties change

			this.generateNodeCode(rootNodeName || "this", createRootNode, tree);

			// Generate text of function.
			this.text = this.buildText.join("\n") + "\n" +
				"return {\n" +
					"\tattach: function(){\n\t\t" +
						this.attachText.join("\n\t\t") +
					"\n\t},\n" +
					"\tdetach: function(){\n\t\t" +
						this.detachText.join("\n\t\t") +
					"\n\t},\n" +
					"\trefresh: function(props){\n\t\t" +
						this.observeText.join("\n\t\t") +
					"\n\t}.bind(this),\n" +
					"\tdestroy: function(){\n" +
						this.destroyText.join("\n\t\t") +
						"\n\t\twhile(this.firstChild){ this.removeChild(this.firstChild); }\n" +
					"\t}.bind(this)\n" +
				"};\n";

			/* jshint evil:true */
			this.func = new Function("document", "register", this.text);
		},

		/**
		 * Text of the generated function.
		 * @member {string}
		 * @readonly
		 */
		text: "",

		/**
		 * Generated function.
		 * @member {Function}
		 * @readonly
		 */
		func: null,

		/**
		 * Generate code that executes `statement` if any of the properties in `dependencies` change.
		 * @param {string[]} dependencies - List of variables referenced in `statement`.
		 * Must have at least one entry.
		 * @param {string} statement - Content inside if() statement.
		 * @private
		 */
		generateWatchCode: function (dependencies, statement) {
			if (dependencies.length) {
				this.observeText.push(
					"if(" + dependencies.map(function (prop) {
						return "'" + prop + "' in props";
					}).join(" || ") + ")",
					"\t" + statement + ";"
				);
			}
		},

		/**
		 * Generate JS code to create and add children to a node named nodeName.
		 * @param {string} nodeName
		 * @param {Object[]} children
		 * @private
		 */
		generateNodeChildrenCode: function (nodeName, children) {
			children.forEach(function (child, idx) {
				var childName = (nodeName === "this" ? "" : nodeName) + "c" + (idx + 1);
				if (child.tag) {
					// Standard DOM node, recurse
					this.generateNodeCode(childName, true, child);
					this.buildText.push(
						nodeName + ".appendChild(" + childName + ");"
					);
				} else {
					// JS code to compute text value
					var textNodeName = childName + "t" + (idx + 1),
						js = child,
						dependsOn = propertiesReferenced(js);

					// Generate code to create DOM text node.
					this.buildText.push(
						"var " + textNodeName + " = document.createTextNode(" + js + ");",
						nodeName + ".appendChild(" + textNodeName + ");"
					);

					// watch for widget property changes and update DOM text node
					this.generateWatchCode(dependsOn, textNodeName + ".nodeValue = " + js);
				}
			}, this);
		},

		/**
		 * Generate JS code to create a node called nodeName based on templateNode, then
		 * set its properties, attributes, and children, according to descendants of templateNode.
		 * @param {string} nodeName - The node will be in a variable with this name.
		 * @param {boolean} createNode - If true, create node; otherwise assume node exists in variable `nodeName`
		 * @param {Object} templateNode - An object representing a node in the template, as described in module summary.
		 * @private
		 */
		generateNodeCode: function (nodeName, createNode, templateNode) {
			/* jshint maxcomplexity:16 */

			// Helper string for setting up attach-point(s), ex: "this.foo = this.bar = ".
			var ap = (templateNode.attachPoints || []).map(function (n) {
				return "this." + n + " = ";
			}).join("");

			// Create node
			if (createNode) {
				this.buildText.push(
					"var " + nodeName + " = " + ap + (templateNode.xmlns ?
					"document.createElementNS('" + templateNode.xmlns + "', '" + templateNode.tag + "');" :
					"register.createElement('" + templateNode.tag + "');")
				);
				if (/-/.test(templateNode.tag)) {
					this.attachText.push(nodeName + ".attachedCallback();");
					this.detachText.push(nodeName + ".detachedCallback();");
				}
			} else if (ap) {
				// weird case that someone set attach-point on root node
				this.buildText.push(ap + nodeName + ";");
			}

			// Setup code to delete attach points created above.
			this.destroyText.push((templateNode.attachPoints || []).map(function (n) {
				return "delete this." + n + ";\n";
			}).join("").trim());

			// Set attributes/properties
			for (var attr in templateNode.attributes) {
				var js = templateNode.attributes[attr],
					dependsOn = propertiesReferenced(js);

				// Generate code to set this property or attribute
				var propName = Template.getProp(templateNode.tag, attr);

				if (attr === "class" && !templateNode.xmlns) {
					// Special path for class to not overwrite classes set by application or by other code.
					this.buildText.push("this.setClassComponent('template'+this.widgetId, " + js + ", " + nodeName +
						");");
					this.generateWatchCode(dependsOn,
							"this.setClassComponent('template'+this.widgetId, " + js + ", " + nodeName + ")");
				} else {
					this.buildText.push(propName ? nodeName + "." + propName + " = " + js + ";" :
						nodeName + ".setAttribute('" + attr + "', " + js + ");");
					this.generateWatchCode(dependsOn, propName ? nodeName + "." + propName + " = " + js :
						"this.setOrRemoveAttribute(" + nodeName + ", '" + attr + "', " + js + ")");
				}
			}

			// If this node is a custom element, make it immediately display the property changes I've made
			if (/-/.test(templateNode.tag)) {
				this.buildText.push(nodeName + ".deliver();");
				this.observeText.push(nodeName + ".deliver();");
			}

			// Setup connections.
			for (var type in templateNode.connects) {
				var handler = templateNode.connects[type];
				var callback = /^[a-zA-Z0-9_]+$/.test(handler) ?
					"this." + handler + ".bind(this)" :		// standard case, connecting to a method in the widget
					"function(event){" + handler + "}";	// connect to anon func, ex: on-click="g++;". used by dapp.

				if (nodeName === "this") {
					// Special case, because on template teardown need to manually remove listeners.
					this.buildText.push("var h_" + type + " = this.on('" + type + "', " + callback + ");");
					this.destroyText.push("h_" + type + ".remove();");
				} else {
					this.buildText.push("this.on('" + type + "', " + callback + ", " + nodeName  + ");");
				}
			}

			// Create descendant Elements and text nodes.
			if (templateNode.children) {
				this.generateNodeChildrenCode(nodeName, templateNode.children);
			}
		}
	});

	// Export helper funcs so they can be used by handlebars.js

	/**
	 * Return cached reference to Element with given tag name.
	 * @function module:delite/Template.getElement
	 * @param {string} tag
	 * @returns {Element}
	 */
	var elementCache = {};
	Template.getElement = function (tag) {
		if (!(tag in elementCache)) {
			elementCache[tag] = register.createElement(tag);
		}
		return elementCache[tag];
	};

	/**
	 * Given a tag and attribute name, return the associated property name,
	 * or undefined if no such property exists, for example:
	 *
	 * - getProp("div", "tabindex") --> "tabIndex"
	 * - getProp("div", "role") --> undefined
	 *
	 * Note that in order to support SVG, getProp("svg", "class") returns null instead of className.
	 *
	 * @function module:delite/Template.getProp
	 * @param {string} tag - Tag name.
	 * @param {string} attrName - Attribute name.
	 * @returns {string}
	 */
	var attrMap = {};
	Template.getProp = function (tag, attrName) {
		if (!(tag in attrMap)) {
			var proto = Template.getElement(tag),
				map = attrMap[tag] = {};
			for (var prop in proto) {
				map[prop.toLowerCase()] = prop;
			}
			map.style = "style.cssText";
		}
		return attrMap[tag][attrName];
	};

	return Template;
});;
/**
 * Pointer Events utilities
 */
define('dpointer/handlers/utils',[

], function () {
	"use strict";

	var utils = {
		events: { // pointer events names
			DOWN: "pointerdown",
			UP: "pointerup",
			CANCEL: "pointercancel",
			MOVE: "pointermove",
			OVER: "pointerover",
			OUT: "pointerout",
			ENTER: "pointerenter",
			LEAVE: "pointerleave",
			GOTCAPTURE: "gotpointercapture",
			LOSTCAPTURE: "lostpointercapture"
		},
		TouchAction: { // touch action
			ATTR_NAME: "touch-action",
			AUTO: 0,  // 0000
			PAN_X: 1, // 0001
			PAN_Y: 2, // 0010
			NONE: 3   // 0011
		}
	};

	// Properties and their default value used to create synthetic "Pointer Events" 
	var eventPropDesc = {
		// MouseEvent interface properties
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		ctrlKey: null,
		shiftKey: null,
		altKey: null,
		metaKey: null,
		button: 0,
		relatedTarget: null,
		// MouseEvent non standard properties
		which: 0,
		pageX: 0,
		pageY: 0,
		buttons: 0,
		// PointerEvent interface properties
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tiltX: 0,
		tiltY: 0,
		pointerType: "",
		isPrimary: false
	};

	// Pointer Events properties depending on the event type
	var eventTypeDesc = {
		pointerover: {bubbles: true, cancelable: true},
		pointerenter: {bubbles: false, cancelable: false},
		pointerdown: {bubbles: true, cancelable: true},
		pointermove: {bubbles: true, cancelable: true},
		pointerup: {bubbles: true, cancelable: true},
		pointercancel: {bubbles: true, cancelable: false},
		pointerout: {bubbles: true, cancelable: true},
		pointerleave: {bubbles: false, cancelable: false},
		gotpointercapture: {bubbles: true, cancelable: false},
		lostpointercapture: {bubbles: true, cancelable: false}
	};

	// Check if all properties can be redefined using a UIEvent.
	// Synthetic Pointer Event are created from a UIEvent.
	// "MouseEvent" would be too restrictive when it comes to redefine properties. 
	// "Event" may be better for performance and lest restrictive to redefine properties, but it causes weird/unstable
	// behavior on some Samsung/Android 4.2.2 browsers (fast moving of a Slider cause event.target to be null at
	// some point...)
	var canRedefineUIEvent = (function () {
		try {
			defineEventProperties(document.createEvent("UIEvent"), {});
			return true;
		} catch (error) {
			eventPropDesc.view = null;
			eventPropDesc.detail = 0;
			return false;
		}
	})();

	/**
	 * Pointer Event constructor.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param nativeEvent underlying event which contributes to this pointer event.
	 * @param props event properties (optional). Note that "bubbles", "cancelable", "view" and "detail" are ignored. 
	 * @returns Event a  Pointer event
	 */
	utils.Pointer = function (pointerType, nativeEvent, props) {
		var event;
		// set bubbles and cancelable value according to pointer event type
		props.bubbles = eventTypeDesc[pointerType].bubbles;
		props.cancelable = eventTypeDesc[pointerType].cancelable;
		// create the base event
		if (canRedefineUIEvent) {
			event = document.createEvent("UIEvent");
			event.initUIEvent(
				pointerType, props.bubbles, props.cancelable, nativeEvent.view || null, nativeEvent.detail || 0
			);
		} else {
			// fallback (iOS 7 disallows to redefine property value/getter)
			event = document.createEvent("Event");
			event.initEvent(pointerType, props.bubbles, props.cancelable);
			// view and detail properties are not available in Event constructor 
			props.view = nativeEvent.view || null;
			props.detail = nativeEvent.detail || 0;
		}
		// redefine event properties
		defineEventProperties(event, props);
		// map functions
		mapNativeFunctions(event, nativeEvent);

		return event;
	};

	/**
	 * @param e event
	 * @param props event properties
	 * @returns Event
	 */
	function defineEventProperties(e, props) {
		props.pressure = props.pressure || (props.buttons ? 0.5 : 0);
		var propsDesc = {};
		Object.keys(eventPropDesc).forEach(function (name) {
			if (name in e) {
				this[name] = {
					get: function () {
						return props[name] || eventPropDesc[name];
					}
				};
			} else {
				this[name] = {
					value: props[name] || eventPropDesc[name]
				};
			}
		}, propsDesc);
		Object.defineProperties(e, propsDesc);
		return e;
	}

	/**
	 * creates a synthetic click event with properties based on another event.
	 *
	 * @param sourceEvent the underlying event which contributes to the creation of this event.
	 * @param dblClick set to true to generate a dblclick event, otherwise a click event is generated
	 * @returns {Event} the event (click or dblclick)
	 */
	utils.createSyntheticClick = function (sourceEvent, dblClick) {
		var e = document.createEvent("MouseEvents");
		if (e.isTrusted === undefined) { // Android 4.1.1 does not implement isTrusted
			Object.defineProperty(e, "isTrusted", {
				value: false,
				enumerable: true,
				writable: false,
				configurable: false
			});
		}
		e.initMouseEvent(dblClick ? "dblclick" : "click", true, // bubbles
			true, // cancelable
			sourceEvent.view,
			dblClick ? 2 : 1,
			sourceEvent.screenX,
			sourceEvent.screenY,
			sourceEvent.clientX,
			sourceEvent.clientY,
			sourceEvent.ctrlKey,
			sourceEvent.altKey,
			sourceEvent.shiftKey,
			sourceEvent.metaKey, 0, // button property (touch: always 0)
			null); // no related target
		return e;
	};

	/**
	 * returns true for a native click event, false for a synthetic click event.
	 *
	 * @param e an event
	 * @returns true if native event, false for synthetic event.
	 */
	utils.isNativeClickEvent = function (e) {
		return (e.isTrusted === undefined || e.isTrusted);
	};

	/**
	 * returns the value of MouseEvent.buttons from MouseEvent.which.
	 *
	 * @param whichValue value of a MouseEvent.which property
	 * @returns Number the value MouseEvent.buttons should have
	 */
	utils.which2buttons = function (whichValue) {
		switch (whichValue) {
		case 0:
			return 0;
		case 1:
			return 1;
		case 2:
			return 4;
		case 3:
			return 2;
		default:
			return Math.pow(2, (whichValue - 1));
		}
	};

	/**
	 * Registers the event handler eventListener on target element targetElement
	 * for events of type eventName.
	 *
	 * @param targetElement DOM element to attach the event listener
	 * @param eventName the event type name ("mousedown", "touchstart"...)
	 * @param eventListener an event listener function
	 * @param useCapture set to true to set the handler at the event capture phase
	 */
	utils.addEventListener = function (targetElement, eventName, eventListener, useCapture) {
		targetElement.addEventListener(eventName, eventListener, useCapture);
	};

	/**
	 * Unregister an existing handler.
	 *
	 * @param targetElement DOM element where the event listener is attached
	 * @param eventName  the event type name ("mousedown", "touchstart"...)
	 * @param eventListener the event listener function to remove
	 * @param useCapture set to true if the handler is set at the event capture phase
	 */
	utils.removeEventListener = function (targetElement, eventName, eventListener, useCapture) {
		targetElement.removeEventListener(eventName, eventListener, useCapture);
	};

	/**
	 * Dispatch an event.
	 *
	 * @param targetElement DOM element
	 * @param event event
	 */
		// possible optimization:
		// Chrome: use getEventListeners() to dispatch event ONLY if there is a listener for the target event type
		// other: hook HTMLElement.prototype.addEventListener to keep a record of active [element|event type]
	utils.dispatchEvent = function (targetElement, event) {
		if (!targetElement) {
			// handle case when  moving a pointer outside the window (elementFromTouch return null)
			return false;
		}
		if (!(targetElement.dispatchEvent)) {
			throw new Error("dispatchEvent not supported on targetElement");
		}
		return targetElement.dispatchEvent(event);
	};

	/**
	 * Dispatch pointerleave events.
	 *
	 * @param target DOM element
	 * @param relatedTarget DOM element
	 * @param syntheticEvent the pointerleave event to dispatch
	 */
	utils.dispatchLeaveEvents = function (target, relatedTarget, syntheticEvent) {
		if (target != null &&
			relatedTarget != null &&
			target !== relatedTarget && !(target.compareDocumentPosition(relatedTarget) & 16)) {
			return this.dispatchEvent(target, syntheticEvent) &&
				this.dispatchLeaveEvents(target.parentNode, relatedTarget, syntheticEvent);
		}
		return true;
	};

	/**
	 * Dispatch pointerenter events.
	 *
	 * @param target DOM element
	 * @param relatedTarget DOM element
	 * @param syntheticEvent the pointerenter event to dispatch
	 */
	utils.dispatchEnterEvents = function (target, relatedTarget, syntheticEvent) {
		if (target != null &&
			relatedTarget != null &&
			target !== relatedTarget && !(target.compareDocumentPosition(relatedTarget) & 16)) {
			return this.dispatchEnterEvents(target.parentNode, relatedTarget, syntheticEvent) &&
				this.dispatchEvent(target, syntheticEvent);
		}
		return true;
	};

	/**
	 * @param e event
	 * @param nativeEvent underlying event which contributes to this pointer event.
	 */
	function mapNativeFunctions(e, nativeEvent) {
		if (e.type === utils.GOTCAPTURE || e.type === utils.LOSTCAPTURE) {
			return; //no default action on pointercapture events
		}
		if (e.bubbles) {
			var _stopPropagation = e.stopPropagation;
			e.stopPropagation = function () {
				nativeEvent.stopPropagation();
				_stopPropagation.apply(this);
			};
			if (e.stopImmediatePropagation) {
				var _stopImmediatePropagation = e.stopImmediatePropagation;
				e.stopImmediatePropagation = function () {
					nativeEvent.stopImmediatePropagation();
					_stopImmediatePropagation.apply(this);
				};
			}
		}
		if (eventTypeDesc[e.type].cancelable) {
			var _preventDefault = e.preventDefault;
			e.preventDefault = function () {
				nativeEvent.preventDefault();
				_preventDefault.apply(this);
			};
		}
	}

	return utils;
});;
define('dpointer/handlers/touchTracker',[
	"./utils"
], function (utils) {
	"use strict";

	var TouchInfo = function (touchAction, pageX, pageY) {
		this.touchAction = touchAction;
		this.lastNativeEvent = null; // undefined
		this.lastTouch = null; // undefined
		this.capturedTarget = null; // undefined, rename capturedTarget
		this.lastTargetElement = null;
		this.firstMove = {
			startX: pageX,
			startY: pageY
		};
		this.enforceTouchAction = (touchAction === utils.TouchAction.AUTO);
	};

	// touchId of the primary pointer, or -1 if no primary pointer set.
	var primaryTouchId = -1,
		t = {},
		canScroll = function (a1, b1, a2, b2) {
			return Math.abs(a2 - a1) / Math.abs(b2 - b1) > 0.7;
		};

	return {

		register: function (touchId, touchAction, touch) {
			// the first touch to register becomes the primary pointer
			if (primaryTouchId === -1) {
				primaryTouchId = touchId;
			}
			t[touchId] = new TouchInfo(touchAction, touch.pageX, touch.pageY);
		},

		unregister: function (touchId) {
			if (primaryTouchId === touchId) {
				primaryTouchId = -1;
			}
			return (delete t[touchId]);
		},

		update: function (touch, touchEvent, targetElement) {
			t[touch.identifier].lastTouch = touch;
			t[touch.identifier].lastNativeEvent = touchEvent;
			t[touch.identifier].lastTargetElement = targetElement;
		},

		isActive: function (touchId) {
			return (touchId in t);
		},

		isPrimary: function (touchId) {
			return (touchId === primaryTouchId);
		},

		getTouchAction: function (touchId) {
			return t[touchId].touchAction;
		},

		updateScroll: function (touch) {
			if (t[touch.identifier].firstMove) {
				var touchInfo = t[touch.identifier];
				if (touchInfo.touchAction === utils.TouchAction.PAN_Y) {
					touchInfo.enforceTouchAction =
						canScroll(touchInfo.firstMove.startY, touchInfo.firstMove.startX, touch.pageY, touch.pageX);
				} else {
					if (touchInfo.touchAction === utils.TouchAction.PAN_X) {
						touchInfo.enforceTouchAction =
							canScroll(touchInfo.firstMove.startX, touchInfo.firstMove.startY, touch.pageX, touch.pageY);
					}
				}
				touchInfo.firstMove = false;
			}
		},


		isTouchActionEnforced: function (touchId) {
			return t[touchId].enforceTouchAction;
		},

		getLastTouch: function (touchId) {
			return t[touchId].lastTouch;
		},

		getTargetElement: function (touchId) {
			return t[touchId].lastTargetElement;
		},

		getTouchEvent: function (touchId) {
			return t[touchId].lastNativeEvent;
		},

		hasPrimary: function () {
			return (primaryTouchId !== -1);
		},

		getPrimaryTouchEvent: function () {
			return t[primaryTouchId].lastNativeEvent;
		},

		getPrimaryTouch: function () {
			return t[primaryTouchId].lastTouch;
		},

		// touch target depends whether capture has been set on the pointer
		identifyTouchTarget: function (touchId, nonCapturedElement) {
			return (t[touchId] && t[touchId].capturedTarget) || nonCapturedElement;
		},

		identifyPrimaryTouchTarget: function (nonCapturedElement) {
			return this.identifyTouchTarget(primaryTouchId, nonCapturedElement);
		},

		hasCapture: function (touchId) {
			return !!(t[touchId].capturedTarget);
		},

		setCapture: function (touchId, targetElement) {
			// 1. check if pointer is active, otw throw DOMException with the name InvalidPointerId.
			if (!this.isActive(touchId)) {
				throw new Error("InvalidPointerId");
			}
			// todo: 2. pointer must have active buttons, otherwise return
			// 3. register capture on this element.
			t[touchId].capturedTarget = targetElement;
		},

		releaseCapture: function (touchId, targetElement) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this.isActive(touchId)) {
				throw new Error("InvalidPointerId");
			}
			if (targetElement && targetElement !== t[touchId].capturedTarget) {
				// explicit release but capture element doesn't match
				return false;
			}
			if (t[touchId].capturedTarget) {
				t[touchId].capturedTarget = null;
				return true;
			} else {
				return false;
			}
		}
	};
});;
/**
 * this module listen to touch events and generates corresponding pointer events.
 *
 * http://www.w3.org/TR/touch-events/#list-of-touchevent-types
 * todo: pointerenter/pointerleave: generate on capture when target is the originated element.
 */
define('dpointer/handlers/touch',[
	"./features",
	"./touchTracker",
	"./utils"
], function (has, tracker, utils) {
	"use strict";

	var TouchEvents = {
			touchstart: "touchstart",
			touchmove: "touchmove",
			touchend: "touchend",
			touchcancel: "touchcancel"
		},
		DoubleTap = { // allow to track click and determine if a double click/tap event can be fired.
			TAP_DELAY: 250, // maximum delay between 2 clicks in ms, after this delay a dblclick won't be generated
			lastClickTS: 0, // timestamp of the last click
			hasFirstClick: false, // are we waiting for a second click?
			targetElement: null, // element which received the click
			isEligible: function (target) {
				return this.hasFirstClick && (this.targetElement === target) &&
					((new Date().getTime()) - this.lastClickTS < this.TAP_DELAY);
			}
		};

	/**
	 * touchstart event handler.
	 *
	 * @param e touch event
	 */
	function touchstart(e) {
		var touch, touchTarget, touchAction;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			touchTarget = null;
			touchAction = determineTouchActionFromAttr(touch.target);
			// before doing anything, we check if there is already an active primary pointer:
			// if default touch action!=auto on the target element, the touch action must be
			// handled by the user agent. The current event is related to a new pointer which contributes to a
			// multi touch gesture: we must absorb this event and cancel the primary pointer to let the user agent
			// handle the default action.
			if (tracker.hasPrimary() && (touchAction === utils.TouchAction.AUTO)) {
				// fire pointerout > pointercancel for current primary pointer
				var lastNativeEvent = tracker.getPrimaryTouchEvent();
				var lastTouch = tracker.getPrimaryTouch();
				touchTarget = tracker.identifyPrimaryTouchTarget(lastTouch.target);
				utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, lastNativeEvent, lastTouch, {}));
				utils.dispatchEvent(touchTarget, createPointer(utils.events.CANCEL, lastNativeEvent, lastTouch, {}));
				releaseCapture(lastTouch.identifier); //implicit release
				// cancel the primary pointer to avoid duplicate generation of PointerOut > PointerCancel
				tracker.unregister(lastTouch.identifier);
			} else {
				if (touchAction !== utils.TouchAction.AUTO) {
					if (DoubleTap.isEligible(touch.target)) {
						e.preventDefault(); // prevent zoom on double tap
					}
				}
				// primary touch pointer must be defined in case an event handler on pointerdown decides
				// to set a pointer capture on the element, so we must:
				// - register the pointer *before* firing the events.
				// - update the tracker *before* firing the events.
				tracker.register(touch.identifier, touchAction, touch);
				tracker.update(touch, e, touch.target);
				// fire pointerover > pointerdown
				utils.dispatchEvent(touch.target, createPointer(utils.events.OVER, e, touch, {}));
				utils.dispatchEvent(touch.target, createPointer(utils.events.DOWN, e, touch, {}));
			}
		}
	}

	/**
	 * touchmove event handler.
	 *
	 * @param e touch event
	 */
	function touchmove(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			tracker.updateScroll(touch);
			// browser default actions
			if (tracker.isTouchActionEnforced(touch.identifier)) {
				var lastNativeEventType = tracker.getTouchEvent(touch.identifier).type;
				switch (lastNativeEventType) {
				case TouchEvents.touchstart:
					// (1) fire PointerOut > PointerCancel
					utils.dispatchEvent(touch.target, createPointer(utils.events.OUT, e, touch, {}));
					utils.dispatchEvent(touch.target, createPointer(utils.events.CANCEL, e, touch, {}));
					break;
				case TouchEvents.touchmove:
					// (2) do not fire synthetic event: absorb the touchmove.
					break;
				default:
					// events flow already ended (previous touchmove already removed pointer from tracker to
					// prevent PointerEvent to be fired)
				}
				releaseCapture(touch.identifier); //implicit release
				tracker.unregister(touch.identifier);
			} else { // always map PointerMove when touch action is set (none/pan-x/pan-y)
				var touchTarget = tracker.identifyTouchTarget(touch.identifier, elementFromTouch(touch));
				var lastElementFromPoint = tracker.getTargetElement(touch.identifier);
				// check if the pointer is moving out from the current target element
				if (touchTarget !== lastElementFromPoint) {
					// expected sequence of events:
					// PointerOut (on previous elt) > PointerMove (on current elt) >  PointerOver (on current elt)
					utils.dispatchEvent(lastElementFromPoint,
						createPointer(utils.events.OUT, e, touch, {relatedTarget: touchTarget}));
					// generate pointerleave event(s)
					utils.dispatchLeaveEvents(lastElementFromPoint, touchTarget,
						createPointer(utils.events.LEAVE, e, touch, {relatedTarget: touchTarget}));
					// generate pointermove
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					// generate pointerover
					utils.dispatchEvent(touchTarget,
						createPointer(utils.events.OVER, e, touch, {relatedTarget: lastElementFromPoint}));
					// generate pointerenter event(s)
					utils.dispatchEnterEvents(touchTarget, lastElementFromPoint,
						createPointer(utils.events.ENTER, e, touch,
							{relatedTarget: lastElementFromPoint}));
				} else {
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
				}
				tracker.update(touch, e, touchTarget);
				// touch default actions must be prevented.
				// Let user agent handle it if it supports the touch-action CSS property.
				if (!has("css-touch-action")) {
					e.preventDefault();
				}
			}
		}
	}

	/**
	 * touchend event handler.
	 *
	 * @param e touch event
	 */
	function touchend(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			var lastNativeEventType = tracker.getTouchEvent(touch.identifier).type;
			// elementFromPoint may return null on android when user makes a pinch 2 zoom gesture
			// in that case we use the current touch.target.
			var elementFromPoint = elementFromTouch(touch) || touch.target;
			var touchTarget = tracker.identifyTouchTarget(touch.identifier, elementFromPoint);
			if (tracker.isTouchActionEnforced(touch.identifier)) {
				// default action handled by user agent
				switch (lastNativeEventType) {
				case TouchEvents.touchmove:
					// (3) do not generate pointer event
					break;
				case TouchEvents.touchstart:
					// (5) fire pointermove > pointerup > pointerOut
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				default:
					// unexpected behavior:
					// touchend event with touch action=auto and lastNativeEventType=[" + lastNativeEventType + "]");
				}
			} else {
				switch (lastNativeEventType) {
				case TouchEvents.touchstart:
					// (6) fire pointermove > pointerup > fast click > pointerout
					utils.dispatchEvent(touchTarget, createPointer(utils.events.MOVE, e, touch, {}));
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					e.preventDefault();
					fireSyntheticClick(touchTarget, touch);
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				case TouchEvents.touchmove:
					// (4) fire pointerup > fast click > pointerout
					utils.dispatchEvent(touchTarget, createPointer(utils.events.UP, e, touch, {}));
					// fire synthetic click only if pointer is released on the origin element
					// (touch.target is the target element from the touchstart)
					if (elementFromPoint === touch.target) {
						e.preventDefault();
						fireSyntheticClick(touchTarget, touch);
					}
					utils.dispatchEvent(touchTarget, createPointer(utils.events.OUT, e, touch, {}));
					break;
				default:
					// unexpected behavior:
					// "touchend event with touch action!=auto and lastNativeEventType=[" + lastNativeEventType + "]"
				}
			}
			releaseCapture(touch.identifier); // implicit release
			tracker.unregister(touch.identifier);
		}
	}

	/**
	 * touchcancel event handler.
	 *
	 * @param e touch event
	 */
	function touchcancel(e) {
		var touch;
		for (var l = e.changedTouches.length, i = 0; i < l; i++) {
			touch = e.changedTouches.item(i);
			if (!tracker.isActive(touch.identifier)) {
				return;
			}
			utils.dispatchEvent(tracker.identifyTouchTarget(touch.identifier, elementFromTouch(touch)),
				createPointer(utils.events.CANCEL, e, touch, {}));
			releaseCapture(touch.identifier); // implicit release
			tracker.unregister(touch.identifier);
		}
	}

	/**
	 * create a synthetic Pointer event based on a touch event.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param touchEvent the underlying touch event which contributes to the creation of the pointer event.
	 * @param touch the underlying touch element which contributes to the creation of the pointer event.
	 * @param props event properties (optional)
	 * @returns {utils.Pointer}
	 */
	function createPointer(pointerType, touchEvent, touch, props) {
		props = props || {};
		// Mouse Event properties
		props.screenX = touch.screenX;
		props.screenY = touch.screenY;
		props.clientX = touch.clientX;
		props.clientY = touch.clientY;
		props.ctrlKey = touchEvent.ctrlKey;
		props.altKey = touchEvent.altKey;
		props.shiftKey = touchEvent.shiftKey;
		props.metaKey = touchEvent.metaKey;
		props.pageX = touch.pageX;
		props.pageY = touch.pageY;
		if (tracker.hasCapture(touch.identifier)) {  // W3C spec 10.1
			props.relatedTarget = null;
		}
		// normalize button/buttons values
		// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
		props.button = (pointerType === utils.events.MOVE) ? -1 : 0;
		props.buttons = 1;
		props.which = props.button + 1;
		// Pointer Events properties
		props.pointerId = touch.identifier + 2; // avoid id collision: 1 is reserved for mouse events mapping
		props.pointerType = "touch";
		props.isPrimary = tracker.isPrimary(touch.identifier);
		return new utils.Pointer(pointerType, touchEvent, props);
	}

	/**
	 * Create and dispatch synthetic events click and dblclick (if eligible).
	 *
	 * @param target
	 * @param touch
	 */
	function fireSyntheticClick(target, touch) {
		// IE10 always generates a click for every pointer when there is multiple touches
		// todo: investigate how IE11 handles clicks when there is multiple touches
		if (tracker.isPrimary(touch.identifier)) {
			// here we choose to fire click/dblclick only for primary pointer
			utils.dispatchEvent(target, utils.createSyntheticClick(touch));
			// dispatch double tap if eligible
			if (DoubleTap.isEligible(target)) {
				utils.dispatchEvent(target, utils.createSyntheticClick(touch, true));
				DoubleTap.hasFirstClick = false;
			} else {
				// remember first click
				DoubleTap.hasFirstClick = true;
				DoubleTap.lastClickTS = (new Date().getTime());
				DoubleTap.targetElement = target;
			}
		}
	}

	/**
	 * returns the deeply nested dom element at window coordinates from a touch element.
	 *
	 * @param touch the touch element
	 * @return HTMLElement the DOM element.
	 */
	function elementFromTouch(touch) {
		return touch.target.ownerDocument.elementFromPoint(touch.clientX, touch.clientY);
	}

	function releaseCapture(touchId, targetElement) {
		if (tracker.releaseCapture(touchId, targetElement)) {
			// 4. Fire a lostpointercapture event at the targetElement
			utils.dispatchEvent(
				tracker.getLastTouch(touchId).target,
				createPointer(utils.events.LOSTCAPTURE,
					tracker.getTouchEvent(touchId),
					tracker.getLastTouch(touchId), {}
				)
			);
			return true;
		}
		return false;
	}

	/**
	 * With touch events there is no CSS property touch-action: Touch action
	 * is specified by the value of the HTML attribute touch-action.
	 * This function returns the touch action which applies to the element, based on "touch action"
	 * from its ancestors.
	 * To be used only when underlying native events are touch events.
	 *
	 * @param targetNode DOM element
	 * @return Number touch action value which applies to the element (auto: 0, pan-x:1, pan-y:2, none: 3)
	 */
	function determineTouchActionFromAttr(targetNode) {
		// touch-action default value: allow default behavior (no prevent default on touch).
		var nodeValue = utils.TouchAction.AUTO;
		// find ancestors with "touch action" and define behavior accordingly.
		do {
			switch (targetNode.getAttribute && targetNode.getAttribute(utils.TouchAction.ATTR_NAME)) {
			case "auto":
				nodeValue = nodeValue | utils.TouchAction.AUTO;
				break;
			case "pan-x":
				nodeValue = nodeValue | utils.TouchAction.PAN_X;
				break;
			case "pan-y":
				nodeValue = nodeValue | utils.TouchAction.PAN_Y;
				break;
			case "none":
				nodeValue = nodeValue | utils.TouchAction.NONE;
				break;
			}
		} while ((nodeValue !== utils.TouchAction.NONE) && (targetNode = targetNode.parentNode));
		return nodeValue;
	}

	return {
		/**
		 * register touch events handlers.
		 *
		 * @param targetElement target element for touch event listeners
		 */
		registerHandlers: function (targetElement) {
			targetElement = targetElement || window.document;
			utils.addEventListener(targetElement, TouchEvents.touchstart, touchstart, true);
			utils.addEventListener(targetElement, TouchEvents.touchmove, touchmove, true);
			utils.addEventListener(targetElement, TouchEvents.touchend, touchend, true);
			utils.addEventListener(targetElement, TouchEvents.touchcancel, touchcancel, true);
		},

		/**
		 * deregister touch events handlers.
		 *
		 * @param targetElement target element for touch  event listeners
		 */
		deregisterHandlers: function (targetElement) {
			utils.removeEventListener(targetElement, TouchEvents.touchstart, touchstart, true);
			utils.removeEventListener(targetElement, TouchEvents.touchmove, touchmove, true);
			utils.removeEventListener(targetElement, TouchEvents.touchend, touchend, true);
			utils.removeEventListener(targetElement, TouchEvents.touchcancel, touchcancel, true);
		},

		/**
		 * Set Pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @param pointerId Id of the capturing Pointer
		 */
		setPointerCapture: function (targetElement, pointerId) {
			var touchId = pointerId - 2;
			tracker.setCapture(touchId, targetElement);
			// 4. Fire a gotpointercapture event at the targetElement
			utils.dispatchEvent(
				tracker.getLastTouch(touchId).target,
				createPointer(utils.events.GOTCAPTURE,
					tracker.getTouchEvent(touchId),
					tracker.getLastTouch(touchId), {}
				)
			);
			return true;
		},

		/**
		 * Release Pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @param pointerId Id of the capturing Pointer
		 */
		releasePointerCapture: function (targetElement, pointerId) {
			return releaseCapture(pointerId - 2, targetElement);
		},

		/**
		 * @param targetNode DOM element
		 * @return Number touch action value which applies to the element (auto: 0, pan-x:1, pan-y:2, none: 3)
		 */
		determineTouchAction: function (targetNode) {
			return determineTouchActionFromAttr(targetNode);
		}
	};
});;
/**
 * This module listens to mouse events and generates corresponding pointer events.
 *
 * http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-mouseevents
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
 */
define('dpointer/handlers/mouse',[
	"./utils"
], function (utils) {
	"use strict";

	var MouseEvents = {
			mousedown: "mousedown",
			mousemove: "mousemove",
			mouseout: "mouseout",
			mouseover: "mouseover",
			mouseup: "mouseup"
		},
		isScrolling = false; // indicates if the mouse is scrolling an element with CSS overflow=auto|scroll.

	/**
	 * mousedown event handler.
	 *
	 * @param e mouse event
	 */
	function mousedown(e) {
		MouseTracker.update(e);
		utils.dispatchEvent(e.target, createPointer(utils.events.DOWN, e, {}));
		// Firefox continues to send mouse event while dragging the scrollbar:
		// if overflow CSS style is set at target element, fire a PointerCancel,
		// then track and absorb subsequent mouse events until a mouseup occurs
		var overflow = (window.getComputedStyle(e.target).overflow);
		if (overflow && (overflow === "auto" || overflow === "scroll")) {
			isScrolling = true;
			utils.dispatchEvent(e.target, createPointer(utils.events.CANCEL, e, {}));
		}
	}

	/**
	 * mousemove event handler.
	 *
	 * @param e mouse event
	 */
	function mousemove(e) {
		if (isScrolling) {
			return;
		}
		utils.dispatchEvent(MouseTracker.identifyTarget(e.target), createPointer(utils.events.MOVE, e, {}));
		MouseTracker.update(e);
	}

	/**
	 * mouseout event handler.
	 *
	 * @param e mouse event
	 */
	function mouseout(e) {
		if (isScrolling || MouseTracker.hasCapture()) {
			return;
		}
		if (e.relatedTarget) {
			utils.dispatchEvent(e.target, createPointer(utils.events.OUT, e, {}));
			// generate pointerleave events
			utils.dispatchLeaveEvents(e.target, e.relatedTarget,
				createPointer(utils.events.LEAVE, e));
		}
		MouseTracker.update(e);
	}

	/**
	 * mouseover event handler.
	 *
	 * @param e mouse event
	 */
	function mouseover(e) {
		if (isScrolling || MouseTracker.hasCapture()) {
			return;
		}
		if (e.relatedTarget) {
			utils.dispatchEvent(e.target, createPointer(utils.events.OVER, e, {}));
			// generate pointerenter events
			utils.dispatchEnterEvents(e.target, e.relatedTarget,
				createPointer(utils.events.ENTER, e));
		}
		MouseTracker.update(e);
	}

	/**
	 * mouseup event handler.
	 *
	 * @param e mouse event
	 */
	function mouseup(e) {
		if (isScrolling) {
			isScrolling = false;
		} else {
			utils.dispatchEvent(MouseTracker.identifyTarget(e.target), createPointer(utils.events.UP, e, {}));
			MouseTracker.implicitReleaseCapture();
			MouseTracker.update(e);
		}
	}

	/**
	 * Create a synthetic pointer from a mouse event.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param mouseEvent the underlying mouse event which contributes to the creation of the pointer event.
	 * @param props event properties (optional)
	 * @returns {utils.Pointer}
	 */
	function createPointer(pointerType, mouseEvent, props) {
		props = props || {};
		// Mouse Events properties
		props.screenX = mouseEvent.screenX;
		props.screenY = mouseEvent.screenY;
		props.clientX = mouseEvent.clientX;
		props.clientY = mouseEvent.clientY;
		props.ctrlKey = mouseEvent.ctrlKey;
		props.altKey = mouseEvent.altKey;
		props.shiftKey = mouseEvent.shiftKey;
		props.metaKey = mouseEvent.metaKey;
		props.pageX = mouseEvent.pageX;
		props.pageY = mouseEvent.pageY;
		// normalize button/buttons values
		// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
		var buttonValue = mouseEvent.button,
			buttonsValue = (mouseEvent.buttons !== undefined) ? mouseEvent.buttons :
				utils.which2buttons(mouseEvent.which);

		if (mouseEvent.type === "mousemove") {
			buttonValue = -1;
		}
		props.button = buttonValue;
		props.buttons = buttonsValue;
		props.which = buttonValue + 1;
		if (MouseTracker.hasCapture()) {  // Pointer events Spec 10.1: related target must be null on pointer capture
			props.relatedTarget = null;
		} else {
			props.relatedTarget = mouseEvent.relatedTarget;
		}
		// Pointer Events properties
		props.pointerId = 1;
		props.pointerType = "mouse";
		props.isPrimary = true;
		return new utils.Pointer(pointerType, mouseEvent, props);
	}

	var MouseTracker = {
		_lastNativeEvent: null,
		_captureTarget: null,
		register: function () {
		},
		update: function (mouseEvent) {
			this._lastNativeEvent = mouseEvent;
		},
		setCapture: function (targetElement) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this._lastNativeEvent) {
				throw "InvalidPointerId";
			}
			// 2. at least one button must be pressed
			if (this._lastNativeEvent.buttons === 0) {
				return false;
			}
			// 3. set PointerCapture=true
			this._captureTarget = targetElement;
			// 4. Fire a gotpointercapture event at the targetElement
			utils.dispatchEvent(this._lastNativeEvent.target,
				createPointer(utils.events.GOTCAPTURE, this._lastNativeEvent, {}));
			return true;
		},
		hasCapture: function () {
			return !!(this._captureTarget);
		},
		identifyTarget: function (nonCapturedElement) {
			return (this._captureTarget) || nonCapturedElement;
		},
		releaseCapture: function (targetElement, implicit) {
			// 1. check if pointerId is active, otw throw DOMException with the name InvalidPointerId.
			if (!this._lastNativeEvent) {
				throw "InvalidPointerId";
			}
			// 2. if pointer capture not set at targetElement, return
			if (!implicit && (this._captureTarget !== targetElement)) {
				return false;
			}
			// 3. release capture
			if (this._captureTarget) {
				// 4. Fire a lostpointercapture event at the targetElement
				utils.dispatchEvent(this._captureTarget,
					createPointer(utils.events.LOSTCAPTURE, this._lastNativeEvent, {}));
				this._captureTarget = null;
			}
			return true;
		},
		implicitReleaseCapture: function () {
			return this.releaseCapture(null, true);
		}
	};

	return {
		/**
		 * register mouse events handlers.
		 *
		 * @param targetElement target element for mouse event listeners
		 */
		registerHandlers: function (targetElement) {
			targetElement = targetElement || window.document;
			utils.addEventListener(targetElement, MouseEvents.mousedown, mousedown, true);
			utils.addEventListener(targetElement, MouseEvents.mousemove, mousemove, true);
			utils.addEventListener(targetElement, MouseEvents.mouseout, mouseout, true);
			utils.addEventListener(targetElement, MouseEvents.mouseover, mouseover, true);
			utils.addEventListener(targetElement, MouseEvents.mouseup, mouseup, true);
		},

		/**
		 * deregister mouse events handlers.
		 * @param targetElement target element for mouse event listeners
		 */
		deregisterHandlers: function (targetElement) {
			utils.removeEventListener(targetElement, MouseEvents.mousedown, mousedown, true);
			utils.removeEventListener(targetElement, MouseEvents.mousemove, mousemove, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseout, mouseout, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseover, mouseover, true);
			utils.removeEventListener(targetElement, MouseEvents.mouseup, mouseup, true);
		},

		/**
		 * set pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @returns true if pointer is captured.
		 */
		setPointerCapture: function (targetElement) {
			return MouseTracker.setCapture(targetElement);
		},

		/**
		 * release pointer capture.
		 *
		 * @param targetElement DOM element to be captured by the pointer
		 * @returns true is pointer is released.
		 */
		releasePointerCapture: function (targetElement) {
			return MouseTracker.releaseCapture(targetElement, false);
		}
	};
});;
/**
 * 
 */
define('dpointer/handlers/features',[
	"requirejs-dplugins/has"
], function (has) {
	if (typeof document !== "undefined") {
		has.add("touch-events", "ontouchstart" in document); // UA supports Touch Events
		has.add("pointer-events", "onpointerdown" in document); // UA supports Pointer Events
		has.add("mspointer-events", "onmspointerdown" in document); // UA supports Pointer Events (IE10+IE11 preview)
		has.add("touch-device", /(mobile)|(android)/i.test(navigator.userAgent)); // mobile device
		has.add("css-touch-action", "touchAction" in document.body.style);// touch-action CSS
		has.add("css-ms-touch-action", "msTouchAction" in document.body.style);// -ms-touch-action CSS
	}
	return has;
});;
/**
 * Pointer Events shim
 */
define('dpointer/events',[
	"./handlers/features",
	"./handlers/utils",
	"./handlers/touch",
	"./handlers/mouse",
	"./handlers/features!mspointer-events?./handlers/mspointer"
], function (has, utils, touch, mouse, mspointer) {
	"use strict";

	var pointerEvents = {_targetElement: null};

	/**
	 * Enable Pointer events. Register native event handlers. Importing this module automatically register native
	 * event handlers on window.document, unless you specify a target element.
	 *
	 * @param targetElement DOM element on which to attach handlers.
	 * @default window.document
	 */
	pointerEvents.enable = function (targetElement) {
		targetElement = targetElement || window.document;
		if (this._targetElement) {
			return;// already initialized
		}
		if (!has("pointer-events")) {
			if (has("mspointer-events")) {
				mspointer.registerHandlers(targetElement);
			} else {
				if (has("touch-events") && has("touch-device")) {
					touch.registerHandlers(targetElement);
				} else {
					mouse.registerHandlers(targetElement);
				}
			}
		}
		this._targetElement = targetElement;
	};

	/**
	 * Disable Pointer events. Unregister native event handlers.
	 */
	pointerEvents.disable = function () {
		if (this._targetElement) {
			touch.deregisterHandlers(this._targetElement);
			mouse.deregisterHandlers(this._targetElement);
			mspointer && mspointer.deregisterHandlers(this._targetElement);
		}
		this._targetElement = null;
	};

	/**
	 * Set the attribute touch-action on the target element.
	 * Supported touch-actions are "auto" (user agent handles touch actions
	 * default behaviors), "none" (disable user agent default behavior), pan-x and pan-y.
	 *
	 * @param targetElement a DOM element
	 * @param actionType touch action type: "auto", "none", "pan-x" or "pan-y"
	 */
	pointerEvents.setTouchAction = function (targetElement, actionType) {
		targetElement.setAttribute(utils.TouchAction.ATTR_NAME, actionType);
	};

	/**
	 * Set pointer capture on a DOM element.
	 *
	 * @param targetElement DOM element
	 * @param pointerId Pointer ID
	 */
	pointerEvents.setPointerCapture = function (targetElement, pointerId) {
		// todo: Internet Explorer automatically set pointer capture on form controls when touch-action is none
		// todo: manage a list of element type to apply pointer capture automatically when touch-action=none is set??
		if (!this._targetElement) {
			return false;// not initialized
		}
		if (has("pointer-events")) {
			return targetElement.setPointerCapture(pointerId);// use native Pointer Events method
		} else {
			if (has("mspointer-events")) {
				return targetElement.msSetPointerCapture(pointerId);// use native Pointer Events method
			} else {
				if (pointerId === 1) { // mouse always gets ID = 1
					return mouse.setPointerCapture(targetElement);
				} else {
					return touch.setPointerCapture(targetElement, pointerId);
				}
			}
		}
	};

	/**
	 * Unset pointer capture on a DOM element.
	 *
	 * @param targetElement DOM element
	 * @param pointerId Pointer ID
	 */
	pointerEvents.releasePointerCapture = function (targetElement, pointerId) {
		if (!this._targetElement) {
			return false;
		}
		if (has("pointer-events")) {
			return targetElement.releasePointerCapture(pointerId);
		} else {
			if (has("mspointer-events")) {
				return targetElement.msReleasePointerCapture(pointerId);
			} else {
				if (pointerId === 1) {
					return mouse.releasePointerCapture(targetElement);
				} else {
					return touch.releasePointerCapture(targetElement, pointerId);
				}
			}
		}
	};

	/**
	 * CSS rule to define touch-action or -ms-touch-action when touch-action attribute is set on Elements.
	 *
	 * @param styleName should be touch-action or -ms-touch-action
	 */
	function insertTouchActionCSSRule(styleName) {
		var styleElement = document.createElement("style"),
			attributeName = utils.TouchAction.ATTR_NAME;
		styleElement.textContent = "[" + attributeName + "='none']  { " + styleName + ": none; }" +
			"[" + attributeName + "='auto']  { " + styleName + ": auto; }" +
			"[" + attributeName + "='pan-x'] { " + styleName + ": pan-x; }" +
			"[" + attributeName + "='pan-y'] { " + styleName + ": pan-y; }" +
			"[" + attributeName + "='pan-x pan-y'],[" + styleName + "='pan-y pan-x'] " +
			"{ " + styleName + ": pan-x pan-y; }";
		document.head.insertBefore(styleElement, document.head.firstChild);
	}

	// CSS rule when user agent implements W3C Pointer Events or when a polyfill is in place.
	if (has("pointer-events")) {
		insertTouchActionCSSRule("touch-action");
	}

		// CSS rule for IE10 and IE11 preview
	if (has("mspointer-events")) {
		insertTouchActionCSSRule("-ms-touch-action");
	}
	// CSS rule to map CSS attribute in case user agent has native support for touch-action or -ms-touch-action
	// CSS property.
	if (has("css-touch-action")) {
		insertTouchActionCSSRule("touch-action");
	} else {
		// CSS rule for IE10 and IE11 preview
		if (has("css-ms-touch-action")) {
			insertTouchActionCSSRule("-ms-touch-action");
		}
	}

	// start listening to native events
	pointerEvents.enable();

	return pointerEvents;
});;
/**
 * this module listen to prefixed "ms" pointer events generates corresponding pointer events.
 *
 * http://msdn.microsoft.com/en-us/library/windows/apps/hh441233.aspx
 */
define('dpointer/handlers/mspointer',[
	"./utils"
], function (utils) {
	"use strict";

	var msPointerEvents = {
		MSPointerDown: "MSPointerDown",
		MSPointerMove: "MSPointerMove",
		MSPointerUp: "MSPointerUp",
		MSPointerOut: "MSPointerOut",
		MSPointerOver: "MSPointerOver",
		MSPointerCancel: "MSPointerCancel",
		MSGotPointerCapture: "MSGotPointerCapture",
		MSLostPointerCapture: "MSLostPointerCapture"
	};

	/**
	 * MSPointerDown event handler.
	 *
	 * @param e event
	 */
	function msPointerDown(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.DOWN, e, {}));
	}

	/**
	 * MSPointerMove event handler.
	 *
	 * @param e event
	 */
	function msPointerMove(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.MOVE, e, {}));
	}

	/**
	 * MSPointerUp event handler.
	 *
	 * @param e event
	 */
	function msPointerUp(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.UP, e, {}));
	}

	/**
	 * MSPointerOut event handler.
	 *
	 * @param e event
	 */
	function msPointerOut(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.OUT, e, {}));
		// generate  pointerleave events
		utils.dispatchLeaveEvents(e.target, e.relatedTarget, createPointer(utils.events.LEAVE, e));
	}

	/**
	 * MSPointerOver event handler.
	 *
	 * @param e event
	 */
	function msPointerOver(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.OVER, e, {}));
		// generate  pointerenter events
		utils.dispatchEnterEvents(e.target, e.relatedTarget, createPointer(utils.events.ENTER, e));
	}

	/**
	 * MSPointerCancel event handler.
	 *
	 * @param e event
	 */
	function msPointerCancel(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.CANCEL, e, {}));
	}

	/**
	 * MSGotPointerCapture event handler.
	 *
	 * @param e event
	 */
	function msGotPointerCapture(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.GOTCAPTURE, e, {}));
	}

	/**
	 * MSLostPointerCapture event handler.
	 *
	 * @param e event
	 */
	function msLostPointerCapture(e) {
		utils.dispatchEvent(e.target, createPointer(utils.events.LOSTCAPTURE, e, {}));
	}

	/**
	 * create a synthetic pointer from a MS Pointer Event.
	 *
	 * @param pointerType pointer event type name ("pointerdown", "pointerup"...)
	 * @param msPointerEvent the underlying ms pointer event which contributes to the creation of the pointer event.
	 * @param props event properties (optional)
	 * @returns {utils.Pointer}
	 */
	function createPointer(pointerType, msPointerEvent, props) {
		props = props || {};
		// Mouse events properties
		props.detail = msPointerEvent.detail;
		props.screenX = msPointerEvent.screenX;
		props.screenY = msPointerEvent.screenY;
		props.clientX = msPointerEvent.clientX;
		props.clientY = msPointerEvent.clientY;
		props.ctrlKey = msPointerEvent.ctrlKey;
		props.altKey = msPointerEvent.altKey;
		props.shiftKey = msPointerEvent.shiftKey;
		props.metaKey = msPointerEvent.metaKey;
		props.button = msPointerEvent.button;
		props.buttons = msPointerEvent.buttons;
		props.relatedTarget = msPointerEvent.relatedTarget;
		// Pointer Events properties
		props.pointerId = msPointerEvent.pointerId;
		props.width = msPointerEvent.width;
		props.height = msPointerEvent.height;
		props.pressure = msPointerEvent.pressure;
		props.tiltX = msPointerEvent.tiltX;
		props.tiltY = msPointerEvent.tiltY;
		props.pointerType = normalizePointerType(msPointerEvent.pointerType);
		props.hwTimestamp = msPointerEvent.hwTimestamp;
		props.isPrimary = msPointerEvent.isPrimary;
		// fix wrong button value on IE10 and IE11 preview
		if ((props.button === -1) && (props.pointerType === "touch")) {
			props.buttons = 1;
		}
		return new utils.Pointer(pointerType, msPointerEvent, props);
	}

	/**
	 * for IE10 and IE11 preview.
	 * http://msdn.microsoft.com/en-us/library/ie/dn304886%28v=vs.85%29.aspx
	 *
	 * @param pointerType
	 * @returns {*}
	 */
	function normalizePointerType(pointerType) {
		switch (pointerType) {
		case 2:
			return "touch";
		case 3:
			return "pen";
		case 4:
			return "mouse";
		default:
			return pointerType;
		}
	}

	return {
		/**
		 * register MS Pointer events handlers.
		 *
		 * @param targetElement target element for event listeners
		 */
		registerHandlers: function (targetElement) {
			targetElement = targetElement || window.document;
			utils.addEventListener(targetElement, msPointerEvents.MSPointerDown, msPointerDown, true);
			utils.addEventListener(targetElement, msPointerEvents.MSPointerMove, msPointerMove, true);
			utils.addEventListener(targetElement, msPointerEvents.MSPointerUp, msPointerUp, true);
			utils.addEventListener(targetElement, msPointerEvents.MSPointerOut, msPointerOut, true);
			utils.addEventListener(targetElement, msPointerEvents.MSPointerOver, msPointerOver, true);
			utils.addEventListener(targetElement, msPointerEvents.MSPointerCancel, msPointerCancel, true);
			utils.addEventListener(targetElement, msPointerEvents.MSGotPointerCapture, msGotPointerCapture, true);
			utils.addEventListener(targetElement, msPointerEvents.MSLostPointerCapture, msLostPointerCapture, true);
		},

		/**
		 * deregister MSPointer events handlers.
		 *
		 * @param targetElement target element for event listeners
		 */
		deregisterHandlers: function (targetElement) {
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerDown, msPointerDown, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerMove, msPointerMove, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerUp, msPointerUp, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerOut, msPointerOut, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerOver, msPointerOver, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSPointerCancel, msPointerCancel, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSGotPointerCapture, msGotPointerCapture, true);
			utils.removeEventListener(targetElement, msPointerEvents.MSLostPointerCapture, msLostPointerCapture, true);
		}
	};
});;
/**
 * This module sets has() flags based on the current browser and platform:
 *
 * - `has("webkit")`, `has("chrome")`, `has("safari")`
 * - `has("ff")`
 * - `has("ie")`, `has("edge")`
 * - `has("ios")`
 * - `has("android")`
 * - `has("wp")`
 * - `has("mac")`
 *
 * It returns the `has()` function.
 * @module decor/sniff
 */
define('decor/sniff',["./features"], function (has) {
	/* jshint maxcomplexity:20 */

	if (has("host-browser")) {
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion;

		// Platform detection
		has.add("mac", /Macintosh/.test(dav));
		if (dua.match(/(iPhone|iPod|iPad)/)) {
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("android", parseFloat(dua.split("Android ")[1]) || undefined);

		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);

		has.add("wp", parseFloat(dua.split("Windows Phone ")[1]) || undefined);

		// Browser detection
		var version;
		if ((version = parseFloat(dua.split("Edge/")[1]))) {
			has.add("edge", version);
		} else if ((version = parseFloat(dua.split("WebKit/")[1]))) {
			has.add("webkit", version);
			has.add("chrome", parseFloat(dua.split("Chrome/")[1]) || undefined);
			has.add("safari", /Safari/.test(dav) && !has("chrome") && !has("android") ?
					parseFloat(dav.split("Version/")[1]) : undefined);
		} else if (/Trident/.test(dav)) {
			// IE8+
			has.add("ie", document.documentMode || parseFloat(dav.split("rv:")[1]));
		} else if ((version = parseFloat(dua.split("Firefox/")[1]))) {
			has.add("ff", version);
		}
	}

	return has;
});
;
/** @module decor/schedule */
define('decor/schedule',["./features"], function (has) {
	"use strict";

	/**
	 * Calls a function at the end of microtask.
	 * @function module:decor/schedule
	 * @param {Function} callback The function to call at the end of microtask.
	 */

	/* global setImmediate */
	var inFlight,
		SCHEDULEID_PREFIX = "_schedule",
		seq = 0,
		uniqueId = Math.random() + "",
		callbacks = {},
		pseudoDiv = has("mutation-observer-api") && document.createElement("div");
	function runCallbacks() {
		for (var anyWorkDone = true; anyWorkDone;) {
			anyWorkDone = false;
			for (var id in callbacks) {
				var callback = callbacks[id];
				delete callbacks[id];
				callback();
				anyWorkDone = true;
			}
		}
		inFlight = false;
	}
	if (has("mutation-observer-api")) {
		pseudoDiv.id = 0;
		new MutationObserver(runCallbacks).observe(pseudoDiv, {attributes: true});
	} else if (!has("setimmediate-api") && has("host-browser")) {
		window.addEventListener("message", function (event) {
			if (event.data === uniqueId) {
				runCallbacks();
			}
		});
	}
	return function (callback) {
		var id = SCHEDULEID_PREFIX + seq++;
		callbacks[id] = callback;
		if (!inFlight) {
			has("mutation-observer-api") ? ++pseudoDiv.id :
				has("setimmediate-api") ? setImmediate(runCallbacks) :
				window.postMessage(uniqueId, "*");
			inFlight = true;
		}
		return {
			remove: function () {
				delete callbacks[id];
			}
		};
	};
});
;
define('decor/features',["requirejs-dplugins/has"], function (has) {
	/* global Platform */
	has.add("console-api", typeof console !== "undefined");
	has.add("host-browser", typeof window !== "undefined");
	has.add("object-observe-api", typeof Object.observe === "function" && typeof Array.observe === "function");
	has.add("object-is-api", !!Object.is);
	has.add("setimmediate-api", typeof setImmediate === "function");
	has.add("mutation-observer-api",
		typeof MutationObserver !== "undefined"
			&& (/\[\s*native\s+code\s*\]/i.test(MutationObserver) // Avoid polyfill version of MutationObserver
				|| !/^\s*function/.test(MutationObserver)));
	has.add("polymer-platform", typeof Platform !== "undefined");
	return has;
});
;
/** @module liaison/ObservableArray */
define('decor/ObservableArray',[
	"requirejs-dplugins/has",
	"./Observable"
], function (has, Observable) {
	"use strict";

	/**
	 * The same argument list of Array, taking the length of the new array or the initial list of array elements.
	 * @typedef {number|...Anything} module:liaison/ObservableArray~CtorArguments
	 */

	/**
	 * An observable array, working as a shim
	 * of {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
	 * @class
	 * @alias module:liaison/ObservableArray
	 * @augments module:decor/Observable
	 * @param {module:decor/ObservableArray~CtorArguments} [args]
	 *     The length of the new array or the initial list of array elements.
	 */
	var ObservableArray,
		augmentedMethods,
		defineProperty = Object.defineProperty,
		EMPTY_ARRAY = [],
		REGEXP_GLOBAL_OBJECT = /\[\s*object\s+global\s*\]/i; // Global object in node.js

	(function () {
		var observableArrayMarker = "_observableArray";

		if (has("object-observe-api")) {
			// For useNative case, make ObservableArray an instance of Array instead of an inheritance,
			// so that Array.observe() emits splices for .length update
			ObservableArray = function (length) {
				var self = [];
				Observable.call(self);
				// Make ObservableArray marker not enumerable, configurable or writable
				defineProperty(self, observableArrayMarker, {value: 1});
				defineProperty(self, "set", Object.getOwnPropertyDescriptor(Observable.prototype, "set"));
				if (typeof length === "number" && arguments.length === 1) {
					self.length = length;
				} else {
					EMPTY_ARRAY.push.apply(self, arguments);
				}
				return self;
			};
		} else {
			// TODO(asudoh):
			// Document that ObservableArray cannot be observed by Observable.observe()
			// without "splice" in accept list.
			// We need to create large amount of change records to do so,
			// when splice happens with large amount of removals/adds
			ObservableArray = function (length) {
				var beingConstructed = this && !REGEXP_GLOBAL_OBJECT.test(this) && !this.hasOwnProperty("length"),
					// If this is called as regular function (instead of constructor), work with a new instance
					self = beingConstructed ? [] : new ObservableArray();
				if (beingConstructed) {
					Observable.call(self);
					// Make ObservableArray marker not enumerable, configurable or writable
					defineProperty(self, observableArrayMarker, {value: 1});
					// Make those methods not enumerable
					for (var s in augmentedMethods) {
						defineProperty(self, s, {
							value: augmentedMethods[s],
							configurable: true,
							writable: true
						});
					}
				}
				if (typeof length === "number" && arguments.length === 1) {
					self.length = length;
				} else {
					EMPTY_ARRAY.push.apply(self, arguments);
				}
				return self;
			};
		}

		/**
		 * @method module:liaison/ObservableArray.test
		 * @param {Array} a The array to test.
		 * @returns {boolean} true if o is an instance of {@link module:liaison/ObservableArray ObservableArray}.
		 */
		ObservableArray.test = function (a) {
			return a && a[observableArrayMarker];
		};
	})();

	/**
	 * @method module:liaison/ObservableArray.canObserve
	 * @param {Array} a The array to test.
	 * @returns {boolean}
	 *     true if o can be observed with {@link module:liaison/ObservableArray.observe ObservableArray.observe()}.
	 */
	if (has("object-observe-api")) {
		ObservableArray.canObserve = function (a) {
			return typeof (a || {}).splice === "function";
		};
	} else {
		ObservableArray.canObserve = ObservableArray.test;
	}

	if (!has("object-observe-api")) {
		(function () {
			/**
			 * Adds and/or removes elements from an array
			 * and automatically emits a change record compatible
			 * with {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
			 * @param {number} index Index at which to start changing the array.
			 * @param {number} removeCount [An integer indicating the number of old array elements to remove.
			 * @param {...Anything} [var_args] The elements to add to the array.
			 * @return {Array} An array containing the removed elements.
			 * @memberof module:liaison/ObservableArray#
			 */
			function splice(index, removeCount) {
				/* jshint validthis: true */
				if (index < 0) {
					index = this.length + index;
				}
				var oldLength = this.length,
					changeRecord = {
						index: index,
						removed: this.slice(index, index + removeCount),
						addedCount: arguments.length - 2
					},
					result = EMPTY_ARRAY.splice.apply(this, arguments),
					lengthRecord = oldLength !== this.length && {
						type: "update",
						object: this,
						name: "length",
						oldValue: oldLength
					},
					notifier = Observable.getNotifier(this);
				notifier.performChange("splice", function () {
					lengthRecord && notifier.notify(lengthRecord);
					return changeRecord;
				});
				return result;
			}

			augmentedMethods = /** @lends module:liaison/ObservableArray# */ {
				splice: splice,

				/**
				 * Sets a value and automatically emits change record(s)
				 * compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {string} name The property name.
				 * @param value The property value.
				 * @returns The value set.
				 */
				set: function (name, value) {
					var args;
					if (name === "length") {
						args = new Array(Math.max(value - this.length, 0));
						args.unshift(Math.min(this.length, value), Math.max(this.length - value, 0));
						splice.apply(this, args);
					} else if (!isNaN(name) && +name >= this.length) {
						args = new Array(name - this.length);
						args.push(value);
						args.unshift(this.length, 0);
						splice.apply(this, args);
					} else {
						Observable.prototype.set.call(this, name, value);
					}
					return value;
				},

				/**
				 * Removes the last element from an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @returns The element removed.
				 */
				pop: function () {
					return splice.call(this, -1, 1)[0];
				},

				/**
				 * Adds one or more elements to the end of an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {...Anything} var_args The elements to add to the end of the array.
				 * @returns The new length of the array.
				 */
				push: function () {
					var args = [this.length, 0];
					EMPTY_ARRAY.push.apply(args, arguments);
					splice.apply(this, args);
					return this.length;
				},

				/**
				 * Reverses the order of the elements of an array
				 * and automatically emits a splice type of change record.
				 * @returns {Array} The array itself.
				 */
				reverse: function () {
					var changeRecord = {
							type: "splice",
							object: this,
							index: 0,
							removed: this.slice(),
							addedCount: this.length
						},
						result = EMPTY_ARRAY.reverse.apply(this, arguments);
					// Treat this change as a splice instead of updates in each entry
					Observable.getNotifier(this).notify(changeRecord);
					return result;
				},

				/**
				 * Removes the first element from an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @returns The element removed.
				 */
				shift: function () {
					return splice.call(this, 0, 1)[0];
				},

				/**
				 * Sorts the elements of an array in place
				 * and automatically emits a splice type of change record.
				 * @returns {Array} The array itself.
				 */
				sort: function () {
					var changeRecord = {
							type: "splice",
							object: this,
							index: 0,
							removed: this.slice(),
							addedCount: this.length
						},
						result = EMPTY_ARRAY.sort.apply(this, arguments);
					// Treat this change as a splice instead of updates in each entry
					Observable.getNotifier(this).notify(changeRecord);
					return result;
				},

				/**
				 * Adds one or more elements to the front of an array
				 * and automatically emits a change record compatible with
				 * {@link http://wiki.ecmascript.org/doku.php?id=harmony:observe ECMAScript Harmony Array.observe()}.
				 * @param {...Anything} var_args The elements to add to the front of the array.
				 * @returns The new length of the array.
				 */
				unshift: function () {
					var args = [0, 0];
					EMPTY_ARRAY.push.apply(args, arguments);
					splice.apply(this, args);
					return this.length;
				}
			};
		})();
	}

	/**
	 * Observes an ObservableArray for changes.
	 * Internally calls {@link module:decor/Observable.observe Observable.observe()}
	 * observing for the following types of change records:
	 * [
	 *     "add",
	 *     "update",
	 *     "delete",
	 *     "splice"
	 * ]
	 * All change records will be converted to "splice" and are sorted by index and merged to smaller number
	 * of change records.
	 * @method
	 * @param {Object} observable The {@link module:liaison/ObservableArray ObservableArray} to observe.
	 * @param {module:decor/Observable~ChangeCallback} callback The change callback.
	 * @returns {Handle} The handle to stop observing.
	 * @throws {TypeError} If the 1st argument is non-object or null.
	 */
	ObservableArray.observe = (function () {
		function intersect(start1, end1, start2, end2) {
			return end1 <= start2 ? end1 - start2 : // Adjacent or distant
				end2 <= start1 ? end2 - start1 : // Adjacent or distant
				Math.min(end1, end2) - Math.max(start1, start2); // Intersected or contained
		}
		function normalize(record) {
			return record.type !== "add" && record.type !== "update" ? record :
				{
					type: "splice",
					object: record.object,
					index: +record.name,
					removed: [record.oldValue],
					addedCount: 1
				};
		}
		function observeSpliceCallback(callback, records) {
			var merged = [];
			records.forEach(function (incoming) {
				incoming = normalize(incoming);
				var doneIncoming = false,
					indexAdjustment = 0;
				for (var i = 0; i < merged.length; ++i) {
					var entry;
					if (!has("object-observe-api") || !Object.isFrozen(merged[i])) {
						entry = merged[i];
						entry.index += indexAdjustment;
					} else {
						entry = merged[i] = {
							type: "splice",
							object: merged[i].object,
							index: merged[i].index + indexAdjustment,
							removed: merged[i].removed,
							addedCount: merged[i].addedCount
						};
					}
					/* jshint maxlen:150 */
					var amount = intersect(entry.index, entry.index + entry.addedCount, incoming.index, incoming.index + incoming.removed.length);
					if (amount >= 0) {
						// Merge splices
						merged.splice(i--, 1);
						var removed,
							addedCount = entry.addedCount - amount + incoming.addedCount;
						if (entry.index < incoming.index) {
							removed = incoming.removed.slice(Math.max(amount, 0));
							EMPTY_ARRAY.unshift.apply(removed, entry.removed);
						} else {
							removed = incoming.removed.slice(0, amount > 0 ? entry.index - incoming.index : incoming.length);
							EMPTY_ARRAY.push.apply(removed, entry.removed);
							// Append happens when second splice's range contains first splice's range
							EMPTY_ARRAY.push.apply(removed, incoming.removed.slice(entry.index + entry.addedCount - incoming.index));
						}
						/* jshint maxlen:120 */
						if (removed.length === 0 && addedCount === 0) {
							doneIncoming = true;
						} else {
							incoming = {
								type: "splice",
								object: entry.object,
								index: Math.min(entry.index, incoming.index),
								removed: removed,
								addedCount: addedCount
							};
						}
						indexAdjustment -= entry.addedCount - entry.removed.length; // entry is subsumed by incoming
					} else if (incoming.index < entry.index) {
						// Insert the new splice
						var adjustment = incoming.addedCount - incoming.removed.length;
						entry.index += adjustment;
						indexAdjustment += adjustment;
						merged.splice(i++, 0, incoming);
						doneIncoming = true;
					}
				}
				if (!doneIncoming) {
					merged.push(incoming);
				}
			});
			if (merged.length > 0) {
				callback(merged);
			}
		}
		if (has("object-observe-api")) {
			return function (observableArray, callback) {
				Array.observe(observableArray, callback = observeSpliceCallback.bind(observableArray, callback));
				return {
					deliver: Object.deliverChangeRecords.bind(Object, callback),
					remove: Array.unobserve.bind(Array, observableArray, callback)
				};
			};
		} else {
			return function (observableArray, callback) {
				var h = Object.create(Observable.observe(observableArray,
					callback = observeSpliceCallback.bind(observableArray, callback), [
					"add",
					"update",
					"delete",
					"splice"
				]));
				h.deliver = Observable.deliverChangeRecords.bind(Observable, callback);
				return h;
			};
		}
	})();

	return ObservableArray;
});
;
/** @module decor/Invalidating */
define('decor/Invalidating',[
	"dcl/dcl",
	"./Stateful",
	"./Destroyable"
], function (dcl, Stateful, Destroyable) {
	/**
	 * Mixin class for widgets
	 * that want to calculate computed properties at once and/or to render UI at once upon multiple property changes.
	 * @class module:decor/Invalidating
	 */
	var Invalidating = dcl([Stateful, Destroyable], /** @lends module:decor/Invalidating# */ {
		// Call initializeInvalidating() right after class is constructed.  Note though that this code won't run for
		// custom elements, since they call createdCallback() rather than constructor().
		// Instead, delite/Widget calls initializeInvalidating() directly.
		constructor: dcl.after(function () {
			this.initializeInvalidating();
		}),

		/**
		 * Make initial calls to `computeProperties()`, `initializeRendering()`, and `refreshRendering()`,
		 * and setup observers so those methods are called whenever properties are modified in the future.
		 * Normally this method is called automatically by the constructor, and should not be called manually,
		 * but the method is exposed for custom elements since they do not call the `constructor()` method.
		 * @protected
		 */
		initializeInvalidating: function () {
			if (!this._hComputing && !this._hRendering) {
				// Make initial call to computeProperties() and setup listener for future calls to computeProperties().
				// Any call to computeProperties(), including the initial call, may trigger more immediate calls to
				// computeProperties().
				this.own(this._hComputing = this.observe(function (oldValues) {
					this.computeProperties(oldValues);
					this.deliverComputing();
				}));
				this.computeProperties(this, true);

				// Make initial call to initializeRendering() and refreshRendering(), and setup listener for future
				// calls.
				this.initializeRendering(this);
				this.refreshRendering(this, true);
				this.own(this._hRendering = this.observe(function (oldValues) {
					var shouldInitializeRendering = this.shouldInitializeRendering(oldValues);
					if (shouldInitializeRendering) {
						this.initializeRendering(oldValues);
						this.refreshRendering(this, true);
					} else {
						this.refreshRendering(oldValues);
					}
				}));
			}
		},

		/**
		 * Synchronously deliver change records for computed properties
		 * so that `computeProperties()` is called if there are pending change records.
		 */
		deliverComputing: function () {
			this._hComputing && this._hComputing.deliver();
			return this._hComputing;
		},

		/**
		 * Discard change records for computed properties.
		 */
		discardComputing: function () {
			this._hComputing && this._hComputing.discardChanges();
			return this._hComputing;
		},

		/**
		 * Function to return if rendering should be initialized.
		 * (Instead of making partial changes for post-initialization)
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterCreation True if this call is right after instantiation.
		 * @return {boolean} True if rendering should be initialized.
		 */
		shouldInitializeRendering: function () {},

		/**
		 * Callback function to calculate computed properties upon property changes.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterCreation True if this call is right after instantiation.
		 */
		computeProperties: function () {},

		/**
		 * Callback function to initialize rendering.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 */
		initializeRendering: function () {},

		/**
		 * Callback function to render UI upon property changes.
		 * @param {Object} oldValues The hash table of old property values, keyed by property names.
		 * @param {boolean} isAfterInitialRendering True if this call is right after `initializeRendering()`.
		 */
		refreshRendering: function () {}
	});

	dcl.chainAfter(Invalidating, "computeProperties");
	dcl.chainAfter(Invalidating, "refreshRendering");

	return Invalidating;
});
;
/** @module decor/Evented */
define('decor/Evented',["dcl/dcl", "dcl/advise"], function (dcl, advise) {
	/**
	 * Base class to add `on()` and `emit()` methods to a class for listening for events and emitting events.
	 * @example
	 * var EventedSubClass = dcl(Evented, {...});
	 * var instance = new EventedSubClass();
	 * instance.on("open", function (event) {
	 *     ... do something with event
	 * });
	 * instance.emit("open", {name: "some event", ...});
	 * @mixin module:decor/Evented
	 */
	return dcl(null, /** @lends module:decor/Evented# */ {
		/**
		 * Setup listener to be called when specified event is fired.
		 * @param {string} type - Name of event.
		 * @param {Function} listener - Callback for when event occurs.
		 * @returns {Object} Handle with `destroy()` method to stop listening to event.
		 */
		on: function (type, listener) {
			return advise.before(this, "on" + type, listener);
		},

		/**
		 * Emit specified event.
		 * @param {string} type - Name of event.
		 * @param {...anything} var_args Parameters to pass to the listeners for this event.
		 */
		emit: function (type) {
			var func = "on" + type;
			if (this[func]) {
				var args = Array.prototype.slice.call(arguments, 1);
				this[func].apply(this, args);
			}
		}
	});
});
;
/** @module xnode/manager/NodeServiceManager **/
define('xnode/manager/NodeServiceManager',[
    "dcl/dcl",
    "xide/manager/ServerActionBase",
    "xide/manager/BeanManager",
    'xide/types',
    'xide/factory',
    'xide/data/Memory',
    'xide/client/WebSocket',
    'xdojo/has',
    'xide/factory/Clients',
    'dojo/Deferred',
    'xdojo/has!xnode-ui?./NodeServiceManagerUI'
], function (dcl, ServerActionBase, BeanManager, types,factory,Memory,WebSocket,has,Clients,Deferred,NodeServiceManagerUI) {
    var bases = [ServerActionBase, BeanManager];

    if(NodeServiceManagerUI){
        bases.push(NodeServiceManagerUI);
    }
    /**
     * Manager dealing with Node-Services though PHP shell (XPHP). This is is a typical
     * 'bean-manager' implementation.
     *
     * @class module: xnode/manager/NodeServiceManager
     */

    var NodeServiceManager = dcl(bases, {
        declaredClass:"xnode.manager.NodeServiceManager",
        serviceClass: 'XIDE_NodeJS_Service',
        cookiePrefix: 'nodeJSServices',
        singleton: true,
        serviceView: null,
        clients: null,
        beanNamespace: 'serviceConsoleView',
        consoles: {},
        /**
         * Create a socket client to the service (service shell) if applicable.
         * @param item
         * @returns {*}
         */
        createClient: function (item) {
            if (!item.info) {
                console.error('NodeJs service has no host info');
                return;
            }
            !this.clients && (this.clients = {});
            var hash = this.getViewId(item);
            if (this.clients[hash]) {
                return this.clients[hash];
            }
            var client = new WebSocket({});
            this.clients[hash] = client;
            client.init({
                options: {
                    host: item.info.host,
                    port: item.info.port,
                    debug: {
                        "all": false,
                        "protocol_connection": true,
                        "protocol_messages": true,
                        "socket_server": true,
                        "socket_client": true,
                        "socket_messages": true,
                        "main": true
                    }
                }
            });
            client.connect();
            return client;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public API
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getStore: function () {
            return this.store;
        },
        /***
         * Common function that this instance is in a valid state
         * @returns {boolean}
         */
        isValid: function () {
            return this.store != null;
        },
        /***
         * Init our store
         * @param data
         * @returns {xide.data.Memory}
         */
        initStore: function (data) {
            var sdata = {
                identifier: "name",
                label: "Name",
                items: data
            };

            this.store = new Memory({
                data: sdata,
                idProperty:'name'
            });
            return this.store;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Main entries, called by the context
        //
        /////////////////////////////////////////////////////////////////////////////////////
        init: function () {
            var dfd = new Deferred();
            var self = this;
            if(this.serviceObject && this.serviceObject.__init) {
                this.serviceObject.__init.then(function () {
                    self.ls().then(function () {
                        dfd.resolve();
                    });
                });
            }else if(this.services){//exported apps have the services already
                return this.ls();
            }
            return dfd;

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getDefaults: function (readyCB) {
            return this.callMethodEx(null, 'getDefaults', null, readyCB, true);
        },
        checkServer: function (settings, readyCB) {
            return this.callMethodEx(null, 'checkServer', [settings], readyCB, true);
        },
        runServer: function (settings, readyCB) {
            return this.callMethodEx(null, 'runDebugServer', [settings], readyCB, true);
        },
        runDebug: function (settings, readyCB) {
            return this.callMethodEx(null, 'run', [settings], readyCB, true);
        },
        stopServer: function (services, readyCB) {
            return this.callMethodEx(null, 'stop', [services], readyCB, true);
        },
        startServer: function (services, readyCB) {
            return this.callMethodEx(null, 'start', [services], readyCB, true);
        },
        /***
         * ls is enumerating all drivers in a given scope
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @param emit   {Boolean}
         * @returns {*}
         */
        ls: function (readyCB, errorCB, emit) {
            var thiz = this;
            var dfd = null;
            function ready(data) {
                thiz.rawData = data;
                thiz.initStore(data);
                if (emit !== false) {
                    thiz.publish(types.EVENTS.ON_NODE_SERVICE_STORE_READY, {store: thiz.store});
                }
                if (readyCB) {
                    readyCB(data);
                }
            }
            if(this.services){
                dfd = new Deferred();
                ready(this.services);
                dfd.resolve();
                return dfd;
            }
            dfd = this.runDeferred(null, 'ls');
            try {
                dfd.then(function (data) {
                    ready(data);
                });
            }catch(e){
                logError(e,"error loading store");
            }
            return dfd;
        }
    });
    return NodeServiceManager;
});
;
define('xide/factory/Clients',[
    'xide/factory',
    'xide/utils',
    'xide/types',
    'xide/client/WebSocket'
], function (factory,utils,types,WebSocket)
{
    var debug = false;
    /**
     * Low Level Web-Socket-Client factory method
     * @param ctrArgs
     * @param host
     * @param port
     * @param delegate
     */
    factory.createClient=function(ctrArgs,host,port,delegate){};
    /***
     * High-Level Web-Socket-Client factory method
     * @param store
     * @param serviceName
     * @param ctrArgs
     * @param clientClass : optional client class prototype, default : WebSocket
     * @returns {xide/client/WebSocket} | null
     */
    factory.createClientWithStore=function(store,serviceName,ctrArgs,clientClass){

        var service = utils.queryStoreEx(store,{
                name:serviceName
            },true,true),
            _ctorArgs = {};

        utils.mixin(_ctorArgs,ctrArgs);

        if(!service||service.length===0){
            console.error('create client with : failed, no such service :  ' + serviceName );
            return;
        }

        //service=service[0];

        /*
        if(!service.info && service.status==types.SERVICE_STATUS.OFFLINE){
            console.error('create client with store : failed! Service has no info for '  + serviceName);
            return;
        }
        */
        if(service.status!==types.SERVICE_STATUS.ONLINE){
            debug && console.error('create client with store : failed! Service ' +  serviceName + ' is not online ');
            //return;
        }

        var host = 'http://' + service.host,
            port = service.port,
            channel='',
            _clientProto = clientClass || WebSocket;

        if(service.info){
            host=service.info.host;
            port=service.info.port;
        }

        try{
            var client = new _clientProto(_ctorArgs);
            utils.mixin(client,_ctorArgs);
            client.init({
                options:{
                    host:host,
                    port:port,
                    channel:channel,
                    debug:{
                        "all": false,
                        "protocol_connection": true,
                        "protocol_messages": true,
                        "socket_server":true,
                        "socket_client":true,
                        "socket_messages":true,
                        "main":true
                    }
                }
            });
            client.connect();
            return client;
        }catch(e){
            debug && console.error('create client with store : failed : ' + e) && logError(e);
        }
    };
    return factory;
});;
define('xide/client/WebSocket',[
    "dcl/dcl",
    'xide/utils',
    'xide/utils/_LogMixin',
    'xide/client/ClientBase',
    'xdojo/has'
], function (dcl, utils, _logMixin, ClientBase,has) {
    var debug = false;
    return dcl([ClientBase, _logMixin], {
        declaredClass:"xide.client.WebSocket",
        _socket: null,
        debugConnect: true,
        autoReconnect: true,
        reconnect: function () {
            debug && console.log('reconnect!');
        },
        close: function () {
            this.destroy();
        },
        onLostConnection:function(){
            debug && console.log('lost connection');
        },
        onConnected:function(){
            debug && console.log('on connected');
        },
        connect_sock_js: function (_options) {
            this.options = utils.mixin(this.options, _options);
            var host = this.options.host;
            //host = host.replace('http://','wss://');
            var port = this.options.port;
            if (this.options.debug) {
                this.initLogger(this.options.debug);
            }
            if (!host) {
                console.error('something wrong with data!',_options);
                return;
            }
            debug && console.log("Connecting to " + host + ':' + port, "socket_client");
            var protocol = [
                'websocket',
                'xdr-streaming',
                'xhr-streaming',
                'iframe-eventsource',
                'iframe-htmlfile',
                'xdr-polling',
                'xhr-polling',
                'iframe-xhr-polling',
                'jsonp-polling'
            ];

            var options = {
                debug: debug,
                devel: true,
                noCredentials:true,
                nullOrigin:true
            };
            options.transports = protocol;
            var sock = new SockJS(host + ":" + port, null, options);
            var thiz = this;

            sock.onopen = function () {
                thiz.onConnected();
                if (thiz.delegate.onConnected) {
                    thiz.delegate.onConnected();
                }
            };

            sock.onmessage = function (e) {
                if (thiz.delegate.onServerResponse) {
                    thiz.delegate.onServerResponse(e);
                }
            };

            sock.onerror=function(){
                console.error('error');
            }
            sock.onclose = function (e) {
                if (thiz.autoReconnect) {
                    debug &&  console.log('closed ' + host + ' try re-connect');
                    if (thiz.delegate.onLostConnection) {
                        thiz.delegate.onLostConnection(e);
                    }
                    thiz.reconnect();
                }else{
                    debug && console.log('closed ' + host);
                }
            };
            this._socket = sock;
        },
        connect_socket_io: function (_options) {
            this.options = utils.mixin(this.options, _options);
            var host = this.options.host;
            //host = host.replace('http://','wss://');
            var port = this.options.port;
            if (this.options.debug) {
                this.initLogger(this.options.debug);
            }
            if (!host) {
                console.error('something wrong with data!',_options);
                return;
            }
            debug && console.log("Connecting to " + host + ':' + port, "socket_client");
            var protocol = [
                'websocket',
                'xdr-streaming',
                'xhr-streaming',
                'iframe-eventsource',
                'iframe-htmlfile',
                'xdr-polling',
                'xhr-polling',
                'iframe-xhr-polling',
                'jsonp-polling'
            ];

            var options = {
                debug: debug,
                devel: true,
                noCredentials:true,
                nullOrigin:true
            };
            options.transports = protocol;
            var sock = new SockJS(host + ":" + port, null, options);
            var thiz = this;

            sock.onopen = function () {
                thiz.onConnected();
                if (thiz.delegate.onConnected) {
                    thiz.delegate.onConnected();
                }
            };

            sock.onmessage = function (e) {
                if (thiz.delegate.onServerResponse) {
                    thiz.delegate.onServerResponse(e);
                }
            };

            sock.onerror=function(){
                console.error('error');
            }
            sock.onclose = function (e) {
                if (thiz.autoReconnect) {
                    debug &&  console.log('closed ' + host + ' try re-connect');
                    if (thiz.delegate.onLostConnection) {
                        thiz.delegate.onLostConnection(e);
                    }
                    thiz.reconnect();
                }else{
                    debug && console.log('closed ' + host);
                }
            };
            this._socket = sock;
        },
        connect: function (_options) {
            return this.connect_sock_js(_options);
            /*
            this.options = utils.mixin(this.options, _options);
            //debugger;
            var host = this.options.host;
            //host = host.replace('http://','wss://');
            var port = this.options.port;
            if (this.options.debug) {
                this.initLogger(this.options.debug);
            }
            if (!host) {
                console.error('something wrong with data!',_options);
                return;
            }
            debug && console.log("Connecting to " + host + ':' + port, "socket_client");
            var protocol = [
                'websocket',
                'xdr-streaming',
                'xhr-streaming',
                'iframe-eventsource',
                'iframe-htmlfile',
                'xdr-polling',
                'xhr-polling',
                'iframe-xhr-polling',
                'jsonp-polling'
            ];


            var sock = io(host + ":" + port);

            sock.on('connect', function(){
                thiz.onConnected();
                if (thiz.delegate.onConnected) {
                    thiz.delegate.onConnected();
                }
            });
            sock.on('event', function(data){

            });
            sock.on('disconnect', function(){});


            var options = {
                debug: debug,
                devel: true,
                noCredentials:true,
                nullOrigin:true
            };
            options.transports = protocol;

            //var sock = new SockJS(host + ":" + port, null, options);
            var thiz = this;

            sock.onopen = function () {

            };

            sock.onmessage = function (e) {
                if (thiz.delegate.onServerResponse) {
                    thiz.delegate.onServerResponse(e);
                }
            };

            sock.onerror=function(){
                console.error('error');
            }
            sock.onclose = function (e) {
                if (thiz.autoReconnect) {
                    debug &&  console.log('closed ' + host + ' try re-connect');
                    if (thiz.delegate.onLostConnection) {
                        thiz.delegate.onLostConnection(e);
                    }
                    thiz.reconnect();
                }else{
                    debug && console.log('closed ' + host);
                }
            };
            this._socket = sock;
            */
        },
        emit: function (signal, dataIn, tag) {
            dataIn.tag = tag || 'notag';
            var data = JSON.stringify(dataIn);
            var res = this._socket.send(data);
            debug && console.log('send ',res);
        },

        onSignal: function (signal, callback) {
            this._socket.on('data', callback);
        }
    });
});;
define('xide/client/ClientBase',[
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'dojo/_base/unload',
    'xide/utils'
], function (dcl,EventedMixin,Base, unload,utils) {
    var Module = dcl([Base.dcl,EventedMixin.dcl], {
        declaredClass:"xide.client.ClientBase",
        options: null,
        _socket: null,
        onConnectionReady: function () {
        },
        onClosed: function () {
        },
        destroy: function () {
            if (this._socket && this._socket.close) {
                this._socket.close();
                this.onClosed();
            }
        },
        _defaultOptions: function () {
            return {};
        },
        init: function (args) {
            this.options = utils.mixin(this._defaultOptions(), args.options);
            //disconnect on onload
            unload.addOnUnload(function () {
                this.pageUnloaded=true;
                this.destroy();
            }.bind(this));
        }
    });

    dcl.chainAfter(Module,"destroy");
    return Module;
});;
define('dojo/_base/unload',["./kernel", "./lang", "../on"], function(dojo, lang, on){

// module:
//		dojo/unload

var win = window;

var unload = {
	// summary:
	//		This module contains the document and window unload detection API.

	addOnWindowUnload: function(/*Object|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		registers a function to be triggered when window.onunload
		//		fires.
		// description:
		//		The first time that addOnWindowUnload is called Dojo
		//		will register a page listener to trigger your unload
		//		handler with. Note that registering these handlers may
		//		destroy "fastback" page caching in browsers that support
		//		it. Be careful trying to modify the DOM or access
		//		JavaScript properties during this phase of page unloading:
		//		they may not always be available. Consider
		//		addOnUnload() if you need to modify the DOM or do
		//		heavy JavaScript work since it fires at the equivalent of
		//		the page's "onbeforeunload" event.
		// example:
		//	|	unload.addOnWindowUnload(functionPointer)
		//	|	unload.addOnWindowUnload(object, "functionName");
		//	|	unload.addOnWindowUnload(object, function(){ /* ... */});

		if (!dojo.windowUnloaded){
			on(win, "unload", (dojo.windowUnloaded = function(){
				// summary:
				//		signal fired by impending window destruction. You may use
				//		dojo.addOnWindowUnload() to register a listener for this
				//		event. NOTE: if you wish to dojo.connect() to this method
				//		to perform page/application cleanup, be aware that this
				//		event WILL NOT fire if no handler has been registered with
				//		addOnWindowUnload(). This behavior started in Dojo 1.3.
				//		Previous versions always triggered windowUnloaded(). See
				//		addOnWindowUnload for more info.
			}));
		}
		on(win, "unload", lang.hitch(obj, functionName));
	},

	addOnUnload: function(/*Object?|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		registers a function to be triggered when the page unloads.
		// description:
		//		The first time that addOnUnload is called Dojo will
		//		register a page listener to trigger your unload handler
		//		with.
		//
		//		In a browser environment, the functions will be triggered
		//		during the window.onbeforeunload event. Be careful of doing
		//		too much work in an unload handler. onbeforeunload can be
		//		triggered if a link to download a file is clicked, or if
		//		the link is a javascript: link. In these cases, the
		//		onbeforeunload event fires, but the document is not
		//		actually destroyed. So be careful about doing destructive
		//		operations in a dojo.addOnUnload callback.
		//
		//		Further note that calling dojo.addOnUnload will prevent
		//		browsers from using a "fast back" cache to make page
		//		loading via back button instantaneous.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {unload: function(){ console.log("unloading...");}, data: "mydata"};
		//	|		unload.addOnUnload(afunc);
		//	|		unload.addOnUnload(foo, "unload");
		//	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
		//	|	});

		on(win, "beforeunload", lang.hitch(obj, functionName));
	}
};

dojo.addOnWindowUnload = unload.addOnWindowUnload;
dojo.addOnUnload = unload.addOnUnload;

return unload;

});
;
/** @module xide/model/Base **/
define('xide/model/Base',[
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/utils"
], function (dcl,declare,utils) {
    
    var Implementation = {
        declaredClass:"xide/model/Base",
        /**
         * Mixin constructor arguments into this.
         * This could have been done in another base class but performance matters
         * @todo use a mixin from lodash
         * @constructor
         */
        constructor: function (args) {
            utils.mixin(this, args);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Public interface, keep it small and easy
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * Return a human friendly name
         * @abstract
         * @returns {string|null}
         */
        getLabel: function () {
            return null;
        },
        /**
         * Return a unique ID.
         * @abstract
         * @returns {string|null}
         */
        getID: function () {
            return null;
        }
    };

    var Module = declare("xide/model/Base",null,Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});

;
define('xide/utils/_LogMixin',[
    'dcl/dcl',
    'xide/utils',
    'xide/model/Base'
], function (dcl, utils,Base) {
    return dcl(Base.dcl,{
        declaredClass:"xide.utils._LogMixin",
        debug_conf: null,
        initLogger: function (debug_config) {
            this.debug_conf = debug_config;
        },
        log: function (msg, msg_context) {
            if (!msg_context) msg_context = this._debugContext()["main"];
            if (this.showDebugMsg(msg_context)) {
                console.log(msg);
            }
        },
        showDebugMsg: function (msg_context) {
            if (this.debug_conf != null) {
                if (this.debug_conf["all"]) {
                    return true;
                }
                else {
                    if (this.debug_conf[msg_context]) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            } else {
                console.log("No debug config, showing all.");
                this.debug_conf = {
                    "all": true
                };
                return true;
            }
        }
    });
});;
/** @module xide/data/Memory **/
define('xide/data/Memory',[
    "dojo/_base/declare",
    'dstore/Memory',
    'xide/data/_Base'
], function (declare, Memory,_Base) {
    /**
     * Base memory class
     * @class module:xide/data/Memory
     * @extends module:xide/data/_Base
     * @extends module:dstore/Memory
     */
    return declare('xide.data.Memory',[Memory, _Base], {
        /**
         * XIDE specific override to ensure the _store property. This is because the store may not use dmodel in some
         * cases like running server-side but the _store property is expected to be there.
         * @param item {object}
         * @returns {*}
         */
        putSync:function(item){
            var self = this;
            item = this.inherited(arguments);
            item && !item._store && Object.defineProperty(item, '_store', {
                get: function () {
                    return self;
                }
            });
            return item;
        }
    });
});
;
define('xide/data/_Base',[
    "dojo/_base/declare",
    'dstore/QueryResults',
    'xide/mixins/EventedMixin',
    'xide/encoding/MD5',
    'xdojo/has',
    'xide/lodash',
    'dojo/when',
    'dojo/Deferred'
], function (declare, QueryResults, EventedMixin, MD5, has, lodash, when, Deferred) {
    /**
     * Mixin in XIDE basics to dstore classes.
     * @class module:xide/data/_Base
     * @extends module:xide/mixins/EventedMixin
     * @lends module:dstore/Memory
     */
    return declare("xide/data/_Base",EventedMixin, {
        __all:null,
        allowCache:true,
        _find:function (query) {
            var result = lodash.filter(this.data,query);
            if(lodash.isArray(result)){
                return result;
            }else if(lodash.isObject(result)){
                return [result];
            }
            return [];
        },
        notify:function(){

        },
        _query:function(query){
            var dfd = new Deferred();
            var collection = this.filter(query);
            when(collection.fetch(), function (data) {
                dfd.resolve(data);
            });
            return dfd;
        },
        constructor: function () {
            var store = this;
            if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {

                this.queryEngine = function (query, options) {
                    options = options || {};

                    var filterQuerierFactory = store._getQuerierFactory('filter');
                    var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

                    var sortQuerierFactory = store._getQuerierFactory('sort');
                    var sort = passthrough;
                    if (sortQuerierFactory) {
                        sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
                            return {
                                property: criteria.attribute,
                                descending: criteria.descending
                            };
                        }));
                    }

                    var range = passthrough;
                    if (!isNaN(options.start) || !isNaN(options.count)) {
                        range = function (data) {
                            var start = options.start || 0,
                                count = options.count || Infinity;

                            var results = data.slice(start, start + count);
                            results.total = data.length;
                            return results;
                        };
                    }

                    return function (data) {
                        return range(sort(filter(data)));
                    };
                };
            }
            var objectStore = this;
            // we call notify on events to mimic the old dojo/store/Trackable
            store.on('add,update,delete', function (event) {
                var type = event.type;
                var target = event.target;
                objectStore.notify(
                    (type === 'add' || type === 'update') ? target : undefined,
                    (type === 'delete' || type === 'update') ?
                        ('id' in event ? event.id : store.getIdentity(target)) : undefined);
            });
        },
        /**
         * Override destroy to also call destroy an item's individual destroy function. Needed for temporary stores.
         * Then, delete query cache.
         * @returns {*}
         */
        destroy:function(){
            this._emit('destroy',this);
            _.each(this.query(), function (item) {
                if (item.destroyOnRemove === true) {
                    item.destroy && item.destroy();
                }
            });
            delete this._queryCache;
            this._queryCache=null;
        },
        refreshItem:function(item,property){
            this.emit('update',{
                target: item,
                property:property
            });
        },
        query: function (query, options,allowCache) {
            //no query, return all
            if(lodash.isEmpty(query)){
                var self = this;
                return _.map(this.data,function(item){
                    return self.getSync(item[self.idProperty]);
                },this);
            }else if(!_.some(query,function (value) { return value == null})){
                //no empty props in query, return lodash.filter
                //return this._find(query);
            }


            var hash = query ? MD5(JSON.stringify(query),1) : null;
            if(has('xcf-ui')) {
                if (hash && !has('host-node') && allowCache !== false) {
                    !this._queryCache && (this._queryCache = {});
                    if (this._queryCache[hash]) {
                        return this._queryCache[hash];
                    }
                }
            }
            /*
            if(!query && !options && allowCache!==false && this.allowCache){
                return this.data;
            }*/

            // summary:
            //		Queries the store for objects. This does not alter the store, but returns a
            //		set of data from the store.
            // query: String|Object|Function
            //		The query to use for retrieving objects from the store.
            // options: dstore/api/Store.QueryOptions
            //		The optional arguments to apply to the resultset.
            // returns: dstore/api/Store.QueryResults
            //		The results of the query, extended with iterative methods.
            //
            // example:
            //		Given the following store:
            //
            //	...find all items where "prime" is true:
            //
            //	|	store.query({ prime: true }).forEach(function(object){
            //	|		// handle each object
            //	|	});
            options = options || {};
            query = query || {};

            var results = this.filter(query);
            var queryResults;

            // Apply sorting
            var sort = options.sort;
            if (sort) {
                if (Object.prototype.toString.call(sort) === '[object Array]') {
                    var sortOptions;
                    while ((sortOptions = sort.pop())) {
                        results = results.sort(sortOptions.attribute, sortOptions.descending);
                    }
                } else {
                    results = results.sort(sort);
                }
            }

            var tracked;
            var _track = false;
            if (_track && results.track && !results.tracking) {
                // if it is trackable, always track, so that observe can
                // work properly.
                results = results.track();
                tracked = true;
            }
            if ('start' in options) {
                // Apply a range
                var start = options.start || 0;
                // object stores support sync results, so try that if available
                queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
                    start: start,
                    end: options.count ? (start + options.count) : Infinity
                });
                queryResults.total = queryResults.totalLength;
            }
            queryResults = queryResults || new QueryResults(results[results.fetchSync ? 'fetchSync' : 'fetch']());
            queryResults.observe = function (callback, includeObjectUpdates) {
                // translate observe to event listeners
                function convertUndefined(value) {
                    if (value === undefined && tracked) {
                        return -1;
                    }
                    return value;
                }

                var addHandle = results.on('add', function (event) {
                    callback(event.target, -1, convertUndefined(event.index));
                });
                var updateHandle = results.on('update', function (event) {
                    if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
                        callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
                    }
                });
                var removeHandle = results.on('delete', function (event) {
                    callback(event.target, convertUndefined(event.previousIndex), -1);
                });
                var handle = {
                    remove: function () {
                        addHandle.remove();
                        updateHandle.remove();
                        removeHandle.remove();
                    }
                };
                handle.cancel = handle.remove;
                return handle;
            };
            if(!has('xcf-ui') && hash && !has('host-node') && allowCache!==false){
                !this._queryCache && (this._queryCache={});
                this._queryCache[hash]=queryResults;
            }
            return queryResults;
        }
    });
});;
/** @module xide/lodash **/
define('xide/lodash',[],function(){

    /**
     * temp. wanna be shim for lodash til dojo-2/loader lands here
     */
    if(typeof _ !=="undefined"){
        return _;
    }else{
        console.error('error loading lodash',global['_']);
    }
});
;
define('xide/encoding/MD5',["./_base"], function(base) {

/*	A port of Paul Johnstone's MD5 implementation
 *	http://pajhome.org.uk/crypt/md5/index.html
 *
 *	Copyright (C) Paul Johnston 1999 - 2002.
 *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * 	Distributed under the BSD License
 *
 *	Dojo port by Tom Trenka
 */

	var chrsz=8;

	//	MD5 rounds functions
	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function C(q,a,b,x,s,t){ return base.addWords(R(base.addWords(base.addWords(a, q), base.addWords(x, t)), s), b); }
	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }

	//	the core MD5 rounds method
	function core(x,len){
		x[len>>5]|=0x80<<((len)%32);
		x[(((len+64)>>>9)<<4)+14]=len;
		var a= 1732584193;
		var b=-271733879;
		var c=-1732584194;
		var d= 271733878;
		for(var i=0; i<x.length; i+=16){
			var olda=a;
			var oldb=b;
			var oldc=c;
			var oldd=d;

			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
			c=FF(c,d,a,b,x[i+10],17,-42063);
			b=FF(b,c,d,a,x[i+11],22,-1990404162);
			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
			d=FF(d,a,b,c,x[i+13],12,-40341101);
			c=FF(c,d,a,b,x[i+14],17,-1502002290);
			b=FF(b,c,d,a,x[i+15],22, 1236535329);

			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
			c=GG(c,d,a,b,x[i+11],14, 643717713);
			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
			d=GG(d,a,b,c,x[i+10],9 , 38016083);
			c=GG(c,d,a,b,x[i+15],14,-660478335);
			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
			b=GG(b,c,d,a,x[i+12],20,-1926607734);

			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
			c=HH(c,d,a,b,x[i+11],16, 1839030562);
			b=HH(b,c,d,a,x[i+14],23,-35309556);
			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
			b=HH(b,c,d,a,x[i+10],23,-1094730640);
			a=HH(a,b,c,d,x[i+13],4 , 681279174);
			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
			d=HH(d,a,b,c,x[i+12],11,-421815835);
			c=HH(c,d,a,b,x[i+15],16, 530742520);
			b=HH(b,c,d,a,x[i+ 2],23,-995338651);

			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
			c=II(c,d,a,b,x[i+14],15,-1416354905);
			b=II(b,c,d,a,x[i+ 5],21,-57434055);
			a=II(a,b,c,d,x[i+12],6 , 1700485571);
			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
			c=II(c,d,a,b,x[i+10],15,-1051523);
			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
			d=II(d,a,b,c,x[i+15],10,-30611744);
			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
			b=II(b,c,d,a,x[i+13],21, 1309151649);
			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
			d=II(d,a,b,c,x[i+11],10,-1120210379);
			c=II(c,d,a,b,x[i+ 2],15, 718787259);
			b=II(b,c,d,a,x[i+ 9],21,-343485551);

			a=base.addWords(a, olda);
			b=base.addWords(b, oldb);
			c=base.addWords(c, oldc);
			d=base.addWords(d, oldd);
		}
		return [a,b,c,d];
	}

	function hmac(data, key){
		var wa=base.stringToWord(key);
		if(wa.length>16){
			wa=core(wa, key.length*chrsz);
		}
		var l=[], r=[];
		for(var i=0; i<16; i++){
			l[i]=wa[i]^0x36363636;
			r[i]=wa[i]^0x5c5c5c5c;
		}
		var h=core(l.concat(base.stringToWord(data)), 512+data.length*chrsz);
		return core(r.concat(h), 640);
	}

	//	public function
	base.MD5=function(/* string */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=core(base.stringToWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.MD5._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return base.wordToHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return base.wordToString(wa);	//	string
			}
			default:{
				return base.wordToBase64(wa);	//	string
			}
		}
	};

	return base.MD5;
});
;
define('xide/encoding/_base',[
	"dojo/_base/lang"

], function(lang){

	//	These functions are 32-bit word-based.  See _sha-64 for 64-bit word ops.
	var base = {};//lang.getObject("dojox.encoding.digests", true);

	base.outputTypes={
		// summary:
		//		Enumeration for input and output encodings.
		Base64:0, Hex:1, String:2, Raw:3
	};

	//	word-based addition
	base.addWords=function(/* word */a, /* word */b){
		// summary:
		//		add a pair of words together with rollover
		var l=(a&0xFFFF)+(b&0xFFFF);
		var m=(a>>16)+(b>>16)+(l>>16);
		return (m<<16)|(l&0xFFFF);	//	word
	};

	//	word-based conversion method, for efficiency sake;
	//	most digests operate on words, and this should be faster
	//	than the encoding version (which works on bytes).
	var chrsz=8;	//	16 for Unicode
	var mask=(1<<chrsz)-1;

	base.stringToWord=function(/* string */s){
		// summary:
		//		convert a string to a word array
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
		}
		return wa;	//	word[]
	};

	base.wordToString=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a string
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
		}
		return s.join("");	//	string
	};

	base.wordToHex=function(/* word[] */wa){
		// summary:
		//		convert an array of words to a hex tab
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
		}
		return s.join("");	//	string
	};

	base.wordToBase64=function(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	convert to UTF-8
	base.stringToUtf8 = function(input){
		var output = "";
		var i = -1;
		var x, y;

		while(++i < input.length){
			x = input.charCodeAt(i);
			y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
			if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF){
				x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
				i++;
			}

			if(x <= 0x7F)
				output += String.fromCharCode(x);
			else if(x <= 0x7FF)
				output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F), 0x80 | (x & 0x3F));
			else if(x <= 0xFFFF)
				output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
			else if(x <= 0x1FFFFF)
				output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07), 0x80 | ((x >>> 12) & 0x3F), 0x80 | ((x >>> 6) & 0x3F), 0x80 | (x & 0x3F));
		}
		return output;
	};

	return base;
});
;
define('dstore/QueryResults',['dojo/_base/lang', 'dojo/when'], function (lang, when) {
	function forEach(callback, instance) {
		return when(this, function(data) {
			for (var i = 0, l = data.length; i < l; i++){
				callback.call(instance, data[i], i, data);
			}
		});
	}
	return function (data, options) {
		var hasTotalLength = options && 'totalLength' in options;
		if(data.then) {
			data = lang.delegate(data);
			// a promise for the eventual realization of the totalLength, in
			// case it comes from the resolved data
			var totalLengthPromise = data.then(function (data) {
				// calculate total length, now that we have access to the resolved data
				var totalLength = hasTotalLength ? options.totalLength :
						data.totalLength || data.length;
				// make it available on the resolved data
				data.totalLength = totalLength;
				// don't return the totalLength promise unless we need to, to avoid
				// triggering a lazy promise
				return !hasTotalLength && totalLength;
			});
			// make the totalLength available on the promise (whether through the options or the enventual
			// access to the resolved data)
			data.totalLength = hasTotalLength ? options.totalLength : totalLengthPromise;
			// make the response available as well
			data.response = options && options.response;
		} else {
			data.totalLength = hasTotalLength ? options.totalLength : data.length;
		}

		data.forEach = forEach;

		return data;
	};
});
;
/** @module dstore/Memory **/
define('dstore/Memory',[
	'dojo/_base/declare',
	'dojo/_base/array',
	'./Store',
	'./Promised',
	'./SimpleQuery',
	'./QueryResults'
], function (declare, arrayUtil, Store, Promised, SimpleQuery, QueryResults) {
    /**
     * @class module:dstore/Memory
     */
	return declare([Store, Promised, SimpleQuery ], {
		constructor: function () {
			// summary:
			//		Creates a memory object store.
			// options: dstore/Memory
			//		This provides any configuration information that will be mixed into the store.
			//		This should generally include the data property to provide the starting set of data.

			// Add a version property so subcollections can detect when they're using stale data
			this.storage.version = 0;
		},

		postscript: function () {
			this.inherited(arguments);

			// Set the data in `postscript` so subclasses can override `data` in their constructors
			// (e.g., a LocalStorage store that retrieves its data from localStorage)
			this.setData(this.data || []);
		},

		// data: Array
		//		The array of all the objects in the memory store
		data: null,

		autoEmitEvents: false, // this is handled by the methods themselves

		getSync: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
			return this.storage.fullData[this.storage.index[id]];
		},
		putSync: function (object, options) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number

			options = options || {};

			var storage = this.storage,
				index = storage.index,
				data = storage.fullData;

			var Model = this.Model;
			if (Model && !(object instanceof Model)) {
				// if it is not the correct type, restore a
				// properly typed version of the object. Note that we do not allow
				// mutation here
				object = this._restore(object);
			}
			var id = this.getIdentity(object);
			if (id == null) {
				this._setIdentity(object, ('id' in options) ? options.id : Math.random());
				id = this.getIdentity(object);
			}
			storage.version++;

			var eventType = id in index ? 'update' : 'add',
				event = { target: object },
				previousIndex,
				defaultDestination;
			if (eventType === 'update') {
				if (options.overwrite === false) {
					throw new Error('Object already exists');
				} else {
					data.splice(previousIndex = index[id], 1);
					defaultDestination = previousIndex;
				}
			} else {
				defaultDestination = this.defaultNewToStart ? 0 : data.length;
			}

			var destination;
			if ('beforeId' in options) {
				var beforeId = options.beforeId;

				if (beforeId === null) {
					destination = data.length;
				} else {
					destination = index[beforeId];

					// Account for the removed item
					if (previousIndex < destination) {
						--destination;
					}
				}

				if (destination !== undefined) {
					event.beforeId = beforeId;
				} else {
					console.error('options.beforeId was specified but no corresponding index was found');
					destination = defaultDestination;
				}
			} else {
				destination = defaultDestination;
			}
			data.splice(destination, 0, object);

			// the fullData has been changed, so the index needs updated
			var i = isFinite(previousIndex) ? Math.min(previousIndex, destination) : destination;
			for (var l = data.length; i < l; ++i) {
				index[this.getIdentity(data[i])] = i;
			}

			this.emit(eventType, event);

			return object;
		},
		addSync: function (object, options) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// options: dstore/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an 'id'
			//		property if a specific id is to be used.
			// returns: Number
			(options = options || {}).overwrite = false;
			// call put with overwrite being false
			return this.putSync(object, options);
		},
		removeSync: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
			// returns: Boolean
			//		Returns true if an object was removed, falsy (undefined) if no object matched the id
			var storage = this.storage;
			var index = storage.index;
			var data = storage.fullData;
			if (id in index) {
				var removed = data.splice(index[id], 1)[0];
				// now we have to reindex
				this._reindex();
				this._ignoreChangeEvents !==true && this.emit('delete', {id: id, target: removed});
				return true;
			}
		},
		setData: function (data) {
			// summary:
			//		Sets the given data as the source for this store, and indexes it
			// data: Object[]
			//		An array of objects to use as the source of data. Note that this
			//		array will not be copied, it is used directly and mutated as
			//		data changes.

			if (this.parse) {
				data = this.parse(data);
			}
			if (data.items) {
				// just for convenience with the data format ItemFileReadStore expects
				this.idProperty = data.identifier || this.idProperty;
				data = data.items;
			}
			var storage = this.storage;
			storage.fullData = this.data = data;
			this._reindex();
		},

		_reindex: function () {
			var storage = this.storage;
			var index = storage.index = {};
			var data = storage.fullData;
			var Model = this.Model;
			var ObjectPrototype = Object.prototype;
			for (var i = 0, l = data.length; i < l; i++) {
				var object = data[i];
				if (Model && !(object instanceof Model)) {
					var restoredObject = this._restore(object,
							// only allow mutation if it is a plain object
							// (which is generally the expected input),
							// if "typed" objects are actually passed in, we will
							// respect that, and leave the original alone
							object.__proto__ === ObjectPrototype);
					if (object !== restoredObject) {
						// a new object was generated in the restoration process,
						// so we have to update the item in the data array.
						data[i] = object = restoredObject;
					}
				}
				index[this.getIdentity(object)] = i;
			}
			storage.version++;
		},

		fetchSync: function () {
			var data = this.data;
			if (!data || data._version !== this.storage.version) {
				// our data is absent or out-of-date, so we requery from the root
				// start with the root data
				data = this.storage.fullData;
				var queryLog = this.queryLog;
				// iterate through the query log, applying each querier
				for (var i = 0, l = queryLog.length; i < l; i++) {
					data = queryLog[i].querier(data);
				}
				// store it, with the storage version stamp
				data._version = this.storage.version;
				this.data = data;
			}
			return new QueryResults(data);
		},

		fetchRangeSync: function (kwArgs) {
			var data = this.fetchSync(),
				start = kwArgs.start,
				end = kwArgs.end;
			return new QueryResults(data.slice(start, end), {
				totalLength: data.length
			});
		},

		_includePropertyInSubCollection: function (name) {
			return name !== 'data' && this.inherited(arguments);
		}
	});
});
;
define('dstore/SimpleQuery',[
	'dojo/_base/declare',
	'dojo/_base/array'
], function (declare, arrayUtil) {

	// module:
	//		dstore/SimpleQuery

	function makeGetter(property, queryAccessors) {
		if (property.indexOf('.') > -1) {
			var propertyPath = property.split('.');
			var pathLength = propertyPath.length;
			return function (object) {
				for (var i = 0; i < pathLength; i++) {
					object = object && (queryAccessors && object.get ? object.get(propertyPath[i]) : object[propertyPath[i]]);
				}
				return object;
			};
		}
		// else
		return function (object) {
			return object.get ? object.get(property) : object[property];
		};
	}

	var comparators = {
		eq: function (value, required) {
			return value === required;
		},
		'in': function(value, required) {
			// allow for a collection of data
			return arrayUtil.indexOf(required.data || required, value) > -1;
		},
		ne: function (value, required) {
			return value !== required;
		},
		lt: function (value, required) {
			return value < required;
		},
		lte: function (value, required) {
			return value <= required;
		},
		gt: function (value, required) {
			return value > required;
		},
		gte: function (value, required) {
			return value >= required;
		},
		match: function (value, required, object) {
			return required.test(value, object);
		},
		contains: function (value, required, object, key) {
			var collection = this;
			return arrayUtil.every(required.data || required, function (requiredValue) {
				if (typeof requiredValue === 'object' && requiredValue.type) {
					var comparator = collection._getFilterComparator(requiredValue.type);
					return arrayUtil.some(value, function (item) {
						return comparator.call(collection, item, requiredValue.args[1], object, key);
					});
				}
				return arrayUtil.indexOf(value, requiredValue) > -1;
			});
		}
	};

	return declare(null, {
		// summary:
		//		Mixin providing querier factories for core query types

		_createFilterQuerier: function (filter) {
			// create our matching filter function
			var queryAccessors = this.queryAccessors;
			var collection = this;
			var querier = getQuerier(filter);

			function getQuerier(filter) {
				var type = filter.type;
				var args = filter.args;
				var comparator = collection._getFilterComparator(type);
				if (comparator) {
					// it is a comparator
					var firstArg = args[0];
					var getProperty = makeGetter(firstArg, queryAccessors);
					var secondArg = args[1];
					if (secondArg && secondArg.fetchSync) {
						// if it is a collection, fetch the contents (for `in` and `contains` operators)
						secondArg = secondArg.fetchSync();
					}
					return function (object) {
						// get the value for the property and compare to expected value
						return comparator.call(collection, getProperty(object), secondArg, object, firstArg);
					};
				}
				switch (type) {
					case 'and': case 'or':
						for (var i = 0, l = args.length; i < l; i++) {
							// combine filters, using and or or
							var nextQuerier = getQuerier(args[i]);
							if (querier) {
								// combine the last querier with a new one
								querier = (function(a, b) {
									return type === 'and' ?
										function(object) {
											return a(object) && b(object);
										} :
										function(object) {
											return a(object) || b(object);

										};
								})(querier, nextQuerier);
							} else {
								querier = nextQuerier;
							}
						}
						return querier;
					case 'function':
						return args[0];
					case 'string':
						// named filter
						var filterFunction = collection[args[0]];
						if (!filterFunction) {
							throw new Error('No filter function ' + args[0] + ' was found in the collection');
						}
						return filterFunction;
					case undefined:
						return function () {
							return true;
						};
					default:
						throw new Error('Unknown filter operation "' + type + '"');
				}
			}
			return function (data) {
				return arrayUtil.filter(data, querier);
			};
		},

		_getFilterComparator: function (type) {
			// summary:
			//		Get the comparator for the specified type
			// returns: Function?

			return comparators[type] || this.inherited(arguments);
		},

		_createSelectQuerier: function (properties) {
			return function (data) {
				var l = properties.length;
				return arrayUtil.map(data, properties instanceof Array ?
					// array of properties
					function (object) {
						var selectedObject = {};
						for (var i = 0; i < l; i++) {
							var property = properties[i];
							selectedObject[property] = object[property];
						}
						return selectedObject;
					} :
					// single property
					function (object) {
						return object[properties];
					});
			};
		},

		_createSortQuerier: function (sorted) {
			var queryAccessors = this.queryAccessors;
			return function (data) {
				data = data.slice();
				data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
					for (var i = 0; i < sorted.length; i++) {
						var comparison;
						var sorter = sorted[i];
						if (typeof sorter == 'function') {
							comparison = sorter(a, b);
						} else {
							var getProperty = sorter.get || (sorter.get = makeGetter(sorter.property, queryAccessors));
							var descending = sorter.descending;
							var aValue = getProperty(a);
							var bValue = getProperty(b);

							aValue != null && (aValue = aValue.valueOf());
							bValue != null && (bValue = bValue.valueOf());

							comparison = aValue === bValue
								? 0
								: (!!descending === (aValue === null || aValue > bValue && bValue !== null) ? -1 : 1);
						}

						if (comparison !== 0) {
							return comparison;
						}
					}
					return 0;
				});
				return data;
			};
		}
	});
});
;
define('dstore/Promised',[
	'dojo/_base/declare',
	'dojo/Deferred',
	'./QueryResults',
	'dojo/when'
], function (declare, Deferred, QueryResults, when) {
	// module:
	//		this is a mixin that can be used to provide async methods,
	// 		by implementing their sync counterparts
	function promised(method, query) {
		return function() {
			var deferred = new Deferred();
			try {
				deferred.resolve(this[method].apply(this, arguments));
			} catch (error) {
				deferred.reject(error);
			}
			if (query) {
				// need to create a QueryResults and ensure the totalLength is
				// a promise.
				var queryResults = new QueryResults(deferred.promise);
				queryResults.totalLength = when(queryResults.totalLength);
				return queryResults;
			}
			return deferred.promise;
		};
	}
	return declare(null, {
		get: promised('getSync'),
		put: promised('putSync'),
		add: promised('addSync'),
		remove: promised('removeSync'),
		fetch: promised('fetchSync', true),
		fetchRange: promised('fetchRangeSync', true)
	});
});
;
/** @module dstore/Store **/
define('dstore/Store',[
	'dojo/_base/lang',
	'dojo/_base/array',
	'dojo/aspect',
	'dojo/has',
	'dojo/when',
    'dojo/_base/declare',
	'dstore/QueryMethod',
	'dstore/Filter',
	'dojo/Evented'
], function (lang, arrayUtil, aspect, has, when, declare, QueryMethod, Filter, Evented) {

	// module:
	//		dstore/Store
	/* jshint proto: true */
	// detect __proto__, and avoid using it on Firefox, as they warn about
	// deoptimizations. The watch method is a clear indicator of the Firefox
	// JS engine.
	has.add('object-proto', !!{}.__proto__ && !({}).watch);
	var hasProto = has('object-proto');

	function emitUpdateEvent(type) {
		return function (result, args) {
			var self = this;
			when(result, function (result) {
				var event = { target: result },
					options = args[1] || {};
				if ('beforeId' in options) {
					event.beforeId = options.beforeId;
				}
				self.emit(type, event);
			});

			return result;
		};
	}

	/**
     * Base store class
     * @class module:dstore/Store
     * @extends module:dojo/Evented
     */
	return declare(Evented, {
		constructor: function (options) {
			// perform the mixin
			options && declare.safeMixin(this, options);
            if (this.Model && this.Model.createSubclass) {

				// we need a distinct model for each store, so we can
				// save the reference back to this store on it.
				// we always create a new model to be safe.
                var self = this;
                this.Model = this.Model.createSubclass([],{

                }).extend({
					// give a reference back to the store for saving, etc.
                    _store:this
				});
			}

			// the object the store can use for holding any local data or events
			this.storage = new Evented();
			var store = this;
			if (this.autoEmitEvents) {
				// emit events when modification operations are called
				aspect.after(this, 'add', emitUpdateEvent('add'));
				aspect.after(this, 'put', emitUpdateEvent('update'));
				aspect.after(this, 'remove', function (result, args) {
					when(result, function () {
						store.emit('delete', {id: args[0]});
					});
					return result;
				});
			}
		},

		// autoEmitEvents: Boolean
		//		Indicates if the events should automatically be fired for put, add, remove
		//		method calls. Stores may wish to explicitly fire events, to control when
		//		and which event is fired.
		autoEmitEvents: true,

		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: 'id',

		// queryAccessors: Boolean
		//		Indicates if client-side query engine filtering should (if the store property is true)
		//		access object properties through the get() function (enabling querying by
		//		computed properties), or if it should (by setting this to false) use direct/raw
		// 		property access (which may more closely follow database querying style).
		queryAccessors: true,

		getIdentity: function (object) {
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: String|Number

			return object.get ? object.get(this.idProperty) : object[this.idProperty];
		},

		_setIdentity: function (object, identityArg) {
			// summary:
			//		Sets an object's identity
			// description:
			//		This method sets an object's identity and is useful to override to support
			//		multi-key identities and object's whose properties are not stored directly on the object.
			// object: Object
			//		The target object
			// identityArg:
			//		The argument used to set the identity

			if (object.set) {
				object.set(this.idProperty, identityArg);
			} else {
				object[this.idProperty] = identityArg;
			}
		},

		forEach: function (callback, thisObject) {
			var collection = this;
			return when(this.fetch(), function (data) {
				for (var i = 0, item; (item = data[i]) !== undefined; i++) {
					callback.call(thisObject, item, i, collection);
				}
				return data;
			});
		},
		on: function (type, listener) {
			return this.storage.on(type, listener);
		},
		emit: function (type, event) {
			event = event || {};
			event.type = type;
			try {
				return this.storage.emit(type, event);
			} finally {
				// Return the initial value of event.cancelable because a listener error makes it impossible
				// to know whether the event was actually canceled
				return event.cancelable;
			}
		},

		// parse: Function
		//		One can provide a parsing function that will permit the parsing of the data. By
		//		default we assume the provide data is a simple JavaScript array that requires
		//		no parsing (subclass stores may provide their own default parse function)
		parse: null,

		// stringify: Function
		//		For stores that serialize data (to send to a server, for example) the stringify
		//		function can be specified to control how objects are serialized to strings
		stringify: null,

		// Model: Function
		//		This should be a entity (like a class/constructor) with a 'prototype' property that will be
		//		used as the prototype for all objects returned from this store. One can set
		//		this to the Model from dmodel/Model to return Model objects, or leave this
		//		to null if you don't want any methods to decorate the returned
		//		objects (this can improve performance by avoiding prototype setting),
		Model: null,

		_restore: function (object, mutateAllowed) {
			// summary:
			//		Restores a plain raw object, making an instance of the store's model.
			//		This is called when an object had been persisted into the underlying
			//		medium, and is now being restored. Typically restored objects will come
			//		through a phase of deserialization (through JSON.parse, DB retrieval, etc.)
			//		in which their __proto__ will be set to Object.prototype. To provide
			//		data model support, the returned object needs to be an instance of the model.
			//		This can be accomplished by setting __proto__ to the model's prototype
			//		or by creating a new instance of the model, and copying the properties to it.
			//		Also, model's can provide their own restore method that will allow for
			//		custom model-defined behavior. However, one should be aware that copying
			//		properties is a slower operation than prototype assignment.
			//		The restore process is designed to be distinct from the create process
			//		so their is a clear delineation between new objects and restored objects.
			// object: Object
			//		The raw object with the properties that need to be defined on the new
			//		model instance
			// mutateAllowed: boolean
			//		This indicates if restore is allowed to mutate the original object
			//		(by setting its __proto__). If this isn't true, than the restore should
			//		copy the object to a new object with the correct type.
			// returns: Object
			//		An instance of the store model, with all the properties that were defined
			//		on object. This may or may not be the same object that was passed in.
			var Model = this.Model;
			if (Model && object) {
				var prototype = Model.prototype;
				var restore = prototype._restore;
				if (restore) {
					// the prototype provides its own restore method
					object = restore.call(object, Model, mutateAllowed);
				} else if (hasProto && mutateAllowed) {
					// the fast easy way
					// http://jsperf.com/setting-the-prototype
					object.__proto__ = prototype;
				} else {
					// create a new object with the correct prototype
					object = lang.delegate(prototype, object);
				}
			}
			return object;
		},

		create: function (properties) {
			// summary:
			//		This creates a new instance from the store's model.
			//	properties:
			//		The properties that are passed to the model constructor to
			//		be copied onto the new instance. Note, that should only be called
			//		when new objects are being created, not when existing objects
			//		are being restored from storage.
			return new this.Model(properties);
		},

		_createSubCollection: function (kwArgs) {
			var newCollection = lang.delegate(this.constructor.prototype);

			for (var i in this) {
				if (this._includePropertyInSubCollection(i, newCollection)) {
					newCollection[i] = this[i];
				}
			}

			return declare.safeMixin(newCollection, kwArgs);
		},

		_includePropertyInSubCollection: function (name, subCollection) {
			return !(name in subCollection) || subCollection[name] !== this[name];
		},

		// queryLog: __QueryLogEntry[]
		//		The query operations represented by this collection
		queryLog: [],	// NOTE: It's ok to define this on the prototype because the array instance is never modified

		filter: new QueryMethod({
			type: 'filter',
			normalizeArguments: function (filter) {
				var Filter = this.Filter;
				if (filter instanceof Filter) {
					return [filter];
				}
				return [new Filter(filter)];
			}
		}),

		Filter: Filter,

		sort: new QueryMethod({
			type: 'sort',
			normalizeArguments: function (property, descending) {
				var sorted;
				if (typeof property === 'function') {
					sorted = [ property ];
				} else {
					if (property instanceof Array) {
						sorted = property.slice();
					} else if (typeof property === 'object') {
						sorted = [].slice.call(arguments);
					} else {
						sorted = [{ property: property, descending: descending }];
					}

					sorted = arrayUtil.map(sorted, function (sort) {
						// copy the sort object to avoid mutating the original arguments
						sort = lang.mixin({}, sort);
						sort.descending = !!sort.descending;
						return sort;
					});
					// wrap in array because sort objects are a single array argument
					sorted = [ sorted ];
				}
				return sorted;
			}
		}),

		select: new QueryMethod({
			type: 'select'
		}),

		_getQuerierFactory: function (type) {
			var uppercaseType = type[0].toUpperCase() + type.substr(1);
			return this['_create' + uppercaseType + 'Querier'];
		}

/*====,
		get: function (id) {
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
		},
		put: function (object, directives) {
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for storing objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		add: function (object, directives) {
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// directives: dstore/Store.PutDirectives?
			//		Additional directives for creating objects.
			// returns: Object
			//		The object that was stored, with any changes that were made by
			//		the storage system (like generated id)
		},
		remove: function (id) {
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
		},
		transaction: function () {
			// summary:
			//		Starts a new transaction.
			//		Note that a store user might not call transaction() prior to using put,
			//		delete, etc. in which case these operations effectively could be thought of
			//		as "auto-commit" style actions.
			// returns: dstore/Store.Transaction
			//		This represents the new current transaction.
		},
		getChildren: function (parent) {
			// summary:
			//		Retrieves the children of an object.
			// parent: Object
			//		The object to find the children of.
			// returns: dstore/Store.Collection
			//		A result set of the children of the parent object.
		}
====*/
	});
});


/*====
	var Collection = declare(null, {
		// summary:
		//		This is an abstract API for a collection of objects, which can be filtered,
		//		sorted, and sliced to create new collections. This is considered to be base
		//		interface for all stores and  query results in dstore. Note that the objects in the
		//		collection may not be immediately retrieved from the underlying data
		//		storage until they are actually accessed through forEach() or fetch().

		filter: function (query) {
			// summary:
			//		Filters the collection, returning a new subset collection
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// returns: Collection
		},
		sort: function (property, descending) {
			// summary:
			//		Sorts the current collection into a new collection, reordering the objects by the provided sort order.
			// property: String|Function
			//		The property to sort on. Alternately a function can be provided to sort with
			// descending?: Boolean
			//		Indicate if the sort order should be descending (defaults to ascending)
			// returns: Collection
		},
		fetchRange: function (kwArgs) {
			// summary:
			//		Retrieves a range of objects from the collection, returning a promise to an array.
			// kwArgs.start: Number
			//		The starting index of objects to return (0-indexed)
			// kwArgs.end: Number
			//		The exclusive end of objects to return
			// returns: Collection
		},
		forEach: function (callback, thisObject) {
			// summary:
			//		Iterates over the query results, based on
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach.
			//		Note that this may executed asynchronously (in which case it will return a promise),
			//		and the callback may be called after this function returns.
			// callback:
			//		Function that is called for each object in the query results
			// thisObject:
			//		The object to use as |this| in the callback.
			// returns:
			//		undefined|Promise
		},
		fetch: function () {
			// summary:
			//		This can be called to materialize and request the data behind this collection.
			//		Often collections may be lazy, and won't retrieve their underlying data until
			//		forEach or fetch is called. This returns an array, or for asynchronous stores,
			//		this will return a promise, resolving to an array of objects, once the
			//		operation is complete.
			//	returns Array|Promise
		},
		on: function (type, listener) {
			// summary:
			//		This registers a callback for notification of when data is modified in the query results.
			// type: String
			//		There are four types of events defined in this API:
			//		- add - A new object was added
			//		- update - An object was updated
			//		- delete - An object was deleted
			// listener: Function
			//		The listener function is called when objects in the query results are modified
			//		to affect the query result. The listener function is called with a single event object argument:
			//		| listener(event);
			//
			//		- The event object as the following properties:
			//		- type - The event type (of the four above)
			//		- target - This indicates the object that was create or modified.
			//		- id - If an object was removed, this indicates the object that was removed.
			//		The next two properties will only be available if array tracking is employed,
			//		which is usually provided by dstore/Trackable
			//		- previousIndex - The previousIndex parameter indicates the index in the result array where
			//		the object used to be. If the value is -1, then the object is an addition to
			//		this result set (due to a new object being created, or changed such that it
			//		is a part of the result set).
			//		- index - The inex parameter indicates the index in the result array where
			//		the object should be now. If the value is -1, then the object is a removal
			//		from this result set (due to an object being deleted, or changed such that it
			//		is not a part of the result set).

		}
	});

	Collection.SortInformation = declare(null, {
		// summary:
		//		An object describing what property to sort on, and the direction of the sort.
		// property: String
		//		The name of the property to sort on.
		// descending: Boolean
		//		The direction of the sort.  Default is false.
	});
	Store.Collection = Collection;

	Store.PutDirectives = declare(null, {
		// summary:
		//		Directives passed to put() and add() handlers for guiding the update and
		//		creation of stored objects.
		// id: String|Number?
		//		Indicates the identity of the object if a new object is created
		// beforeId: String?
		//		If the collection of objects in the store has a natural ordering,
		//		this indicates that the created or updated object should be placed before the
		//		object whose identity is specified as the value of this property. A value of null indicates that the
		//		object should be last.
		// parent: Object?,
		//		If the store is hierarchical (with single parenting) this property indicates the
		//		new parent of the created or updated object.
		// overwrite: Boolean?
		//		If this is provided as a boolean it indicates that the object should or should not
		//		overwrite an existing object. A value of true indicates that a new object
		//		should not be created, the operation should update an existing object. A
		//		value of false indicates that an existing object should not be updated, a new
		//		object should be created (which is the same as an add() operation). When
		//		this property is not provided, either an update or creation is acceptable.
	});

	Store.Transaction = declare(null, {
		// summary:
		//		This is an object returned from transaction() calls that represents the current
		//		transaction.

		commit: function () {
			// summary:
			//		Commits the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the commit.
		},
		abort: function (callback, thisObject) {
			// summary:
			//		Aborts the transaction. This may throw an error if it fails. Of if the operation
			//		is asynchronous, it may return a promise that represents the eventual success
			//		or failure of the abort.
		}
	});

	var __QueryLogEntry = {
		type: String
			The query type
		arguments: Array
			The original query arguments
		normalizedArguments: Array
			The normalized query arguments
		querier: Function?
			A client-side implementation of the query that takes an item array and returns an item array
	};
====*/
;
define('dstore/QueryMethod',[], function () {
	/*=====
	var __QueryMethodArgs = {
		// type: String
		//		The type of the query. This identifies the query's type in the query log
		//		and the name of the corresponding query engine method.
		// normalizeArguments: Function?
		//		A function that normalizes arguments for consumption by a query engine
		// applyQuery: Function?
		//		A function that takes the query's new subcollection and the query's log entry
		//		and applies it to the new subcollection. This is useful for collections that need
		//		to both declare and implement new query methods.
		// querierFactory: Function?
		//		A factory function that provides a default querier implementation to use when
		//		a collection does not define its own querier factory method for this query type.
	};
	=====*/
	return function QueryMethod(/*__QueryMethodArgs*/ kwArgs) {
		// summary:
		//		The constructor for a dstore collection query method
		// description:
		//		This is the constructor for a collection query method. It encapsulates the following:
		//		* Creating a new subcollection for the query results
		//		* Logging the query in the collection's `queryLog`
		//		* Normalizing query arguments
		//		* Applying the query engine
		// kwArgs:
		//		The properties that define the query method
		// returns: Function
		//		Returns a function that takes query arguments and returns a new collection with
		//		the query associated with it.

		var type = kwArgs.type,
			normalizeArguments = kwArgs.normalizeArguments,
			applyQuery = kwArgs.applyQuery,
			defaultQuerierFactory = kwArgs.querierFactory;

		return function () {
			// summary:
			//		A query method whose arguments are determined by the query type
			// returns: dstore/Collection
			//		A collection representing the query results

			var originalArguments = Array.prototype.slice.call(arguments),
				normalizedArguments = normalizeArguments
					? normalizeArguments.apply(this, originalArguments)
					: originalArguments,
				logEntry = {
					type: type,
					arguments: originalArguments,
					normalizedArguments: normalizedArguments
				},
				querierFactory = this._getQuerierFactory(type) || defaultQuerierFactory;

			if (querierFactory) {
				// Call the query factory in store context to support things like
				// mapping a filter query's string argument to a custom filter method on the collection
				logEntry.querier = querierFactory.apply(this, normalizedArguments);
			}

			var newCollection = this._createSubCollection({
				queryLog: this.queryLog.concat(logEntry)
			});

			return applyQuery ? applyQuery.call(this, newCollection, logEntry) : newCollection;
		};
	};
});
;
/** @module xide/manager/BeanManager */
define('xide/manager/BeanManager',[
    'dcl/dcl',
    "dojo/_base/lang",
    "xdojo/has",
    "xide/utils",
    'xide/encoding/MD5',
    'xide/registry',
    'xide/data/TreeMemory'
], function (dcl, lang, has, utils, MD5, registry, TreeMemory) {

    /**
     * @class module:xide/manager/BeanManager
     */
    var Base = dcl(null, {
        declaredClass: 'xide.manager.BeanManager',
        beanNamespace: 'beanNS',
        beanName: 'beanName',
        beanPriority: -1,
        /**
         *
         * @param title
         * @param scope
         * @param parentId
         * @param path
         * @param isDir
         * @param beanType
         * @returns {{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        createItemStruct: function (title, scope, parentId, path, isDir, beanType) {
            return {
                name: title,
                isDir: isDir,
                parentId: parentId,
                path: path,
                beanType: beanType,
                scope: scope
            };
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard impl of the bean interface
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getMetaValue: function (item, title) {
            var path = this.itemMetaPath || 'user';
            return utils.getCIInputValueByName(utils.getAt(item, path), title);
        },
        /***
         * @returns {dojo.data.ItemFileWriteStore}
         */
        getStore: function () {
            return this.store;
        },
        /***
         * Common function that this instance is in a valid state
         * @returns {boolean}
         */
        isValid: function () {
            return this.store != null;
        },
        /***
         * @TODO:remove
         * Inits the store with the driver data
         * @param data
         * @returns {module:xide/data/TreeMemory}
         */
        initStore: function (data) {
            this.store = new TreeMemory({
                data: data.items,
                idProperty: 'path'
            });
            this.onStoreReady(this.store);
            return this.store;
        },
        /**
         * Stub
         */
        onStoreReady: function () {
        },
        _onReloaded: function (newModule) {
            this.mergeNewModule(newModule.prototype);
            var _class = this.declaredClass;
            var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class);
            if (_module) {
                if (_module.prototype && _module.prototype.solve) {
                    this.mergeNewModule(_module.prototype);
                }
            }
        }
    });

    if (has('host-browser')) {
        /**
         * @class module:xide/manager/BeanManager
         */
        return dcl(Base, {
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  UX related utils
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /***
             * Determine a parent container for new views. Currently
             * the 'Application' holds a 'mainView' instance which
             * prepares us a tab container.
             *
             * @returns {*}
             */
            getViewTarget: function () {
                var mainView = this.ctx.getApplication().mainView;
                return mainView.getNewAlternateTarget();
            },
            getRightTopTarget: function (clear, open, style, className) {
                var mainView = this.ctx.getApplication().mainView;
                return mainView.getRightTopTarget(clear, open, style, className);
            },
            getLayoutRightMain: function (clear, open) {
                var mainView = this.ctx.getApplication().mainView;
                return mainView.getLayoutRightMain(clear, open);
            },
            getRightBottomTarget: function (clear, open) {
                var mainView = this.ctx.getApplication().mainView;
                return mainView.getRightBottomTarget(clear, open);
            },
            /***
             * getViewId generates a unique id upon a driver's scope and the drivers path.
             * @param item
             * @param suffix {string}
             * @returns {string}
             */
            getViewId: function (item, suffix) {
                return this.beanNamespace + MD5(utils.toString(item.scope) + utils.toString(item.path), 1) + (suffix != null ? suffix : '');
            },
            /**
             *
             * @param item
             */
            getView: function (item, suffix) {
                var id = this.getViewId(item, suffix);
                return registry.byId(id);
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Data related
            //
            /////////////////////////////////////////////////////////////////////////////////////

            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Server methods
            //
            /////////////////////////////////////////////////////////////////////////////////////
            createGroup: function (scope, name, readyCB) {
                return this.callMethodEx(null, 'createGroup', [scope, name], readyCB, true);
            },
            removeGroup: function (scope, path, name, readyCB) {
                return this.callMethodEx(null, 'removeGroup', [scope, path, name], readyCB, true);
            },
            removeItem: function (scope, path, name, readyCB) {
                return this.callMethodEx(null, 'removeItem', [scope, path, name], readyCB, true);
            },
            /**
             * Shared for consumer
             * @param ci
             * @param newValue
             * @param oldValue
             * @param storeRef
             */
            updateCI: function (ci, newValue, oldValue, storeRef) {
                if (ci && storeRef) {
                    this.updateItemMetaData(
                        utils.toString(storeRef.scope), //the scope of the driver
                        utils.toString(storeRef.path),  //the relative path of the driver
                        this.itemMetaStorePath || '/inputs',  //the path of the CIS in the meta db
                        {
                            id: utils.toString(ci.id)
                        },
                        {
                            value: newValue
                        }
                    );
                }
            },
            /**
             * updateItemMetaData updates a CI in the drivers meta data store
             * @param scope {string}
             * @param driverMetaPath {string}
             * @param dataPath {string} : /inputs
             * @param query
             * @param value
             * @param readyCB
             * @param errorCB
             * @returns {*}
             */
            updateItemMetaData: function (scope, driverMetaPath, dataPath, query, value, readyCB, errorCB) {
                return this.callMethodEx(null, 'updateItemMetaData', [scope, driverMetaPath, dataPath, query, value], readyCB, false);
            },
            mergeNewModule: function (source) {
                for (var i in source) {
                    var o = source[i];
                    if (o && _.isFunction(o)) {
                        this[i] = o;
                    }
                }
            }
        });
    }else{
        return Base;
    }
});;
/** @module xide/data/TreeMemory **/
define('xide/data/TreeMemory',[
    "dojo/_base/declare",
    'xide/data/Memory',
    'dstore/Tree',
    'dojo/Deferred',
    'dstore/QueryResults'
], function (declare, Memory, Tree, Deferred, QueryResults) {

    /**
     * @class module:xide/data/TreeMemory
     * @deprecated
     * @extends module:xide/data/_Base
     * @extends module:dstore/Tree
     */
    return declare('xide.data.TreeMemory', [Memory, Tree], {
        _state: {
            filter: null
        },
        parentProperty: 'parentId',
        reset: function () {
            this._state.filter = null;
            this.resetQueryLog();
        },
        resetQueryLog: function () {
            this.queryLog = [];
        },
        fetchRange: function () {
            // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
            // so we need to extend this as well.
            var results = this._fetchRange(arguments);
            return new QueryResults(results.then(function (data) {
                return data;
            }), {
                totalLength: results.then(function (data) {
                    return data.length;
                })
            });
        },
        filter: function (data) {
            var _res = this.inherited(arguments);
            this._state.filter = data;
            return _res;
        },
        _fetchRange: function (kwArgs) {
            var deferred = new Deferred();
            var _res = this.fetchRangeSync(kwArgs);
            if (this._state.filter) {
                //the parent query
                if (this._state.filter['parent']) {
                    var _item = this.getSync(this._state.filter[this.parentProperty]);
                    if (_item) {
                        this.reset();
                        var _query = {};
                        if (this.getChildrenSync) {
                            _res = this.getChildrenSync(_item);
                        } else {
                            _query[this.parentProperty] = _item[this.idProperty];
                            _res = this.root.query(_query);
                        }
                    }
                }


                //the group query
                if (this._state && this._state.filter && this._state.filter['group']) {
                    var _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res = _item.items;
                    }
                }
            }
            deferred.resolve(_res);
            return deferred;
        },
        getChildren: function (object) {
            var filter = {};
            filter[this.parentProperty] = this.getIdentity(object);
            return this.root.filter(filter);
        },
        children: function (parent) {
            var all = this.root.data, out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj[this.parentProperty] == parent[this.idProperty]) {
                    out.push(obj);
                }
            }
            return all;
        },
        mayHaveChildren: function (parent) {
            if (parent._mayHaveChildren === false) {
                return false;
            }
            return true;
        }
    });
});
;
define('dstore/Tree',[
	'dojo/_base/declare'
	/*=====, 'dstore/Store'=====*/
], function (declare /*=====, Store=====*/) {
	return declare(null, {
		constructor: function () {
			this.root = this;
		},

		mayHaveChildren: function (object) {
			// summary:
			//		Check if an object may have children
			// description:
			//		This method is useful for eliminating the possibility that an object may have children,
			//		allowing collection consumers to determine things like whether to render UI for child-expansion
			//		and whether a query is necessary to retrieve an object's children.
			// object:
			//		The potential parent
			// returns: boolean

			return 'hasChildren' in object ? object.hasChildren : true;
		},

		getRootCollection: function () {
			// summary:
			//		Get the collection of objects with no parents
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: null });
		},

		getChildren: function (object) {
			// summary:
			//		Get a collection of the children of the provided parent object
			// object:
			//		The parent object
			// returns: dstore/Store.Collection

			return this.root.filter({ parent: this.getIdentity(object) });
		}
	});
});
;
/** module:xide/registry **/
define('xide/registry',[
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
    "xdojo/has"
], function(array, win, has){
	/**
	 * @TODOS:
	 * - add namespaces
	 * - remove window
	 * - augment consumer API
	 * - use std array
	 * - add framework constraint
	 * - move dom api out of here
	 * - define widget.id better
	 * - add search by class
     */
	var _widgetTypeCtr = {}, hash = {};
	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,
		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
                if(has('xblox')) {
                    this.remove(widget.id);
                    this.add(widget);
                }else{
                    throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
                }
			}
			hash[widget.id] = widget;
			this.length++;
		},
		/**
		 * Remove a widget from the registry. Does not destroy the widget; simply
		 * removes the reference.
		 * @param id
         */
		remove: function(id){
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},
		/**
		 *
		 * @param id {String|Widget}
		 * @returns {String|Widget}
         */
		byId: function( id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},
		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		/**
		 * Convert registry into a true Array
		 * @example:
		 *	Work with the widget .domNodes in a real Array
		 *	array.map(registry.toArray(), function(w){ return w.domNode; });
		 * @returns {obj[]}
         */
		toArray: function(){
			return _.values(_.mapKeys(hash, function(value, key) { value.id = key; return value; }));
		},
		/**
		 * Generates a unique id for a given widgetType
		 * @param widgetType {string}
		 * @returns {string}
         */
		getUniqueId: function(widgetType){
			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return id;
		},
		/**
		 * Search subtree under root returning widgets found.
		 * Doesn't search for nested widgets (ie, widgets inside other widgets).
		 * @param root {HTMLElement} Node to search under.
		 * @param skipNode {HTMLElement} If specified, don't search beneath this node (usually containerNode).
         * @returns {Array}
         */
		findWidgets: function(root, skipNode){
			var outAry = [];
			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}
			getChildrenHelper(root);
			return outAry;
		},
		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			// Destroy all the widgets, top down
			_.each(registry.findWidgets(win.body()),function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},
		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};
	return registry;
});
;
/** @module xide/manager/ServerActionBase */
define('xide/manager/ServerActionBase',[
    'dcl/dcl',
    'dojo/_base/declare',
    'xdojo/has',
    'dojo/Deferred',
    'xide/manager/RPCService',
    'xide/manager/ManagerBase',
    'xide/types',
    'xide/utils'
], function (dcl, declare, has, Deferred, RPCService, ManagerBase, types, utils) {
    var Singleton = null;
    /**
     * Class dealing with JSON-RPC-2, used by most xide managers
     * @class module:xide.manager.ServerActionBase
     * @augments {module:xide/manager/ManagerBase}
     */
    var Implementation = {
        declaredClass: "xide.manager.ServerActionBase",
        serviceObject: null,
        serviceUrl: null,
        singleton: true,
        serviceClass: null,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        base64_encode: function (data) {

            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var self = this;
            if (this.serviceObject.__init) {
                if (this.serviceObject.__init.isResolved()) {
                    return self._runDeferred(serviceClassIn, method, args, options);
                }
                var dfd = new Deferred();
                this.serviceObject.__init.then(function () {
                    self._runDeferred(serviceClassIn, method, args, options).then(function () {
                        dfd.resolve(arguments);
                    });
                });
                return dfd;
            }
            return self._runDeferred(serviceClassIn, method, args, options);
        },
        /**
         * Public main entry, all others below are deprecated
         * @param serviceClassIn
         * @param method
         * @param args
         * @param options
         * @returns {Deferred}
         */
        _runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred(),
                promise;
            options = options || this.defaultOptions;
            //check we the RPC method is in the SMD
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this.getService(),
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data, error) {
                var dfd = deferred;
                if (options.returnProm) {
                    dfd = promise;
                }
                dfd._data = data;
                if (error) {
                    if (options.onError) {
                        return options.onError(error);
                    }
                }
                dfd.resolve(data);
            };

            promise = service[serviceClass][method](args);
            promise.then(function (res) {
                res = res || {};
                var error = res.error || {};
                //the server has some messages for us
                if (options.checkMessages) {
                    if (error && error.code == 3) {
                        thiz.onMessages(error);
                    }
                }
                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (error.code == 1) {
                        options.displayError && thiz.onError(error, serviceClass + '::' + method);
                        deferred.reject(error);
                        return;
                    }
                } else {
                    if (error.code == 1 && options.displayError) {
                        thiz.onError(error, serviceClass + '::' + method);
                    }
                    if (error && error.code && error.code !== 0) {
                        resolve(res, error);
                        return;
                    }
                }
                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }
                resolve(res);
            }, function (err) {
                thiz.onError(err);
            });

            if (options.returnProm) {
                return promise;
            }
            return deferred;
        },
        getService: function () {
            return this.serviceObject;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method, serviceClass) {
            var _service = this.getService(),
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        findServiceUrl: function (declaredClass) {
            var config = window['xFileConfig'];
            if (config && config.mixins) {
                for (var i = 0; i < config.mixins.length; i++) {
                    var obj = config.mixins[i];
                    if (obj.declaredClass === declaredClass && obj.mixin && obj.mixin.serviceUrl) {
                        return decodeURIComponent(obj.mixin.serviceUrl);
                    }
                }
            }
            return null;
        },
        init: function () {
            this.check();
        },
        _initService: function () {
            var thiz = this;
            if (!has('host-browser')) {
                return false;
            }
            try {
                var obj = Singleton;
                if (this.singleton) {
                    if (obj && obj.serviceObject) {
                        this.serviceObject = obj.serviceObject;
                        return;
                    }
                    if (!this.options) {
                        this.options = {};
                    }
                    this.options.singleton = this.singleton;
                }
                if (!this.serviceObject) {
                    if (!this.serviceUrl) {
                        console.error('have no service url : ' + this.declaredClass);
                        return;
                    }
                    var url = decodeURIComponent(this.serviceUrl);
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl), this.options);

                    this.serviceObject.runDeferred = function () {
                        return thiz.runDeferred.apply(thiz, arguments);
                    };


                    this.serviceObject.sync = this.sync;

                    if (this.singleton) {
                        obj.serviceObject = this.serviceObject;
                    }
                    if (this.config) {
                        obj.serviceObject.config = this.config;
                    }
                    !this.ctx.serviceObject && (this.ctx.serviceObject = this.serviceObject);
                }
            } catch (e) {
                console.error('error in rpc service creation : ' + e);
                logError(e);
            }
        },
        check: function () {
            if (!this.serviceObject) {
                this._initService();
            }
        },
        onError: function (err, suffix) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            if (suffix) {
                err.message = suffix + ' -> ' + err.message;
            }
            this.publish(types.EVENTS.ERROR, {
                error: err
            }, this);
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.getService()) {
                return false;
            }
            if (!this.hasMethod(method, serviceClass) && omit === true) {
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },
        prepareCall: function () {
            var params = {};
            //Mixin mandatory fields
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.serviceObject.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                    this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        callMethodEx: function (serviceClassIn, method, args, readyCB, omitError) {
            serviceClassIn = serviceClassIn || this.serviceClass;
            if (!serviceClassIn) {
                console.error('have no service class! ' + this.declaredClass, this);
            }
            //init smd
            this.check();

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            var thiz = this;
            return this.serviceObject[this.getServiceClass(serviceClassIn)][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClassIn);
                    logError(e, 'server method failed ' + e);

                }
                //rpc batch results
                if (res && res.error && res.error.code == 3) {
                    thiz.onMessages(res.error);
                }

                if (res && res.error && res.error && res.error.code != 0) {
                    thiz.onError(res.error);
                    return;
                }
                if (omitError == true) {
                    thiz.publish(types.EVENTS.STATUS, {message: 'Ok!'}, this);
                }

            }, function (err) {
                thiz.onError(err);
            });
        },
        callMethodEx2: function (serverClassIn, method, args, readyCB, omitError) {
            this.check();
            //check this method exists
            if (!this.checkCall(serverClassIn, method, omitError)) {
                return;
            }
            //setup signing in serviceObject
            this.prepareCall();
            return this.serviceObject[this.getServiceClass(serverClassIn)][method](args);
        },
        callMethod: function (method, args, readyCB, omitError) {
            args = args || [[]];
            var serviceClass = this.serviceClass;
            try {
                var thiz = this;
                //method not listed in SMD
                if (this.serviceObject[serviceClass][method] == null) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                this.serviceObject[this.serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, "Error calling RPC method");
                    }
                    //rpc batch call
                    if (res && res.error && res.error.code == 3) {
                        this.onMessages(res.error);
                    }
                    if (res && res.error && res.error && res.error.code == 1) {
                        this.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        this.publish(types.EVENTS.STATUS, struct, this);
                    }
                }.bind(this), function (err) {
                    this.onError(err);
                }.bind(this));
            } catch (e) {
                thiz.onError(e);
                logError(e, "Error calling RPC method");
            }
        }
    };

    var Module = dcl(ManagerBase, Implementation);
    Module.declare = declare(null, Implementation);
    Singleton = Module;
    return Module;
});;
/** @module xide/manager/ManagerBase **/
define('xide/manager/ManagerBase',[
    'dcl/dcl',
    'xide/mixins/EventedMixin',
    'xide/model/Base',
    'xide/utils',
    "dojo/_base/xhr",
    "dojo/_base/kernel"
], function (dcl,EventedMixin,Base,utils,xhr,dojo) {
    /**
     * @class module:xide/manager/ManagerBase
     * @augments module:dojo/Stateful
     * @augments module:xide/mixins/EventedMixin
     * @interface
     */
    var Module =dcl([Base.dcl,EventedMixin.dcl],{
        declaredClass:"xide.manager.ManagerBase",
        /**
         * @type module:xide/manager/ContextBase
         * @member ctx A pointer to a xide context
         */
        ctx: null,
        init: function () {
            this.initReload && this.initReload();
        },
        /**
         *
         * @param title
         * @param scope
         * @param parent
         * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}}
         */
        _getText: function (url,options) {
            var result;
            options = utils.mixin({
                url: url,
                sync: true,
                handleAs: 'text',
                load: function (text) {
                    result = text;
                }
            },options);

            var def = xhr.get(options);
            if(!options.sync){
                return def;
            }
            return '' + result + '';
        },
        /**
         * Return context
         * @returns {module:xcf/manager/Context}
         */
        getContext:function(){
            return this.ctx;
        }
    });

    dcl.chainAfter(Module,'init');
    return Module;
});;
define('dojo/_base/xhr',[
	"./kernel",
	"./sniff",
	"require",
	"../io-query",
	/*===== "./declare", =====*/
	"../dom",
	"../dom-form",
	"./Deferred",
	"./config",
	"./json",
	"./lang",
	"./array",
	"../on",
	"../aspect",
	"../request/watch",
	"../request/xhr",
	"../request/util"
], function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = [{}];

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			miArgs.push(formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			miArgs.push(args.content);
		}
		if(args.preventCache){
			miArgs.push({"dojo.preventCache": new Date().valueOf()});
		}
		ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){
			if(has('debug')) {
				var debugData = rDfd.response.getHeader('xapp_debug_data');
				if (debugData && typeof xappServerDebug !== 'undefined') {
					xappServerDebug(debugData, rDfd, dfd);
				}
			}
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({
			url:url,
			sync:true,
			headers:{
				"X-Requested-With": null
			},
			load:function(text){
			result = text;
		}});
		return result;
	};
    dojo.getText = function(url){
        return dojo.xhrGet({
            url: url,
            sync: false,
            headers: {
                "X-Requested-With": null
            }
        });
    };

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
        getText: dojo.getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
});
;
define('dojo/request/util',[
	'exports',
	'../errors/RequestError',
	'../errors/CancelError',
	'../Deferred',
	'../io-query',
	'../_base/array',
	'../_base/lang',
	'../promise/Promise'
], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise){
	exports.deepCopy = function deepCopy(target, source){
		for(var name in source){
			var tval = target[name],
				sval = source[name];
			if(tval !== sval){
				if(tval && typeof tval === 'object' && sval && typeof sval === 'object'){
					exports.deepCopy(tval, sval);
				}else{
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data || response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;
		
		if(data && !skipData){
			if(typeof data === 'object'){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
});
;
define('dojo/errors/CancelError',["./create"], function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	
	return create("CancelError", null, null, { dojoType: "cancel" });
});
;
define('dojo/errors/create',["../_base/lang"], function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
});
;
define('dojo/errors/RequestError',['./create'], function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
});
;
define('dojo/request/xhr',[
	'../errors/RequestError',
	'./watch',
	'./handlers',
	'./util',
	'../has'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && !document.addEventListener && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData === 'function';
	});

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;
		response.text = _xhr.responseText;

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		if(!error){
			try{
				handlers(response);
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(util.checkStatus(_xhr.status)){
			this.resolve(response);
		}else{
			error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);

			this.reject(error);
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(evt){
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				}
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onProgress, false);

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			has('native-formdata') && options && options.data && options.data instanceof FormData
		);
		url = response.url;
		options = response.options;

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response);
		}

		var data = options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			var headers = options.headers,
				contentType = 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
});
;
define('dojo/request/handlers',[
	'../json',
	'../_base/kernel',
	'../_base/array',
	'../has',
	'../has!dom?../selector/_loader' // only included for has() qsa tests
], function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];

		handleXML = function(response){
			var result = response.data;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(response.text, 'application/xml');
			}

			if(!result || !result.documentElement){
				var text = response.text;
				array.some(dp, function(p){
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
					}catch(e){ return false; }
					return true;
				});
			}

			return result;
		};
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
});
;
define('dojo/json',["./has"], function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
});
;
define('dojo/request/watch',[
	'./util',
	'../errors/RequestTimeoutError',
	'../errors/CancelError',
	'../_base/array',
	'../has!host-browser?../_base/window:',
	'../has!host-browser?dom-addeventlistener?:../on:'
], function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
});
;
define('dojo/errors/RequestTimeoutError',['./create', './RequestError'], function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
});
;
define('dojo/_base/json',["./kernel", "../json"], function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
});
;
define('dojo/_base/config',["../has", "require"], function(has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// useCustomLogger: Anything?
	//		If set to a value that evaluates to true such as a string or array and
	//		isDebug is true and Firebug is not available or running, then it bypasses
	//		the creation of Firebug Lite allowing you to define your own console object.
	useCustomLogger: undefined,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if(has("dojo-config-api")){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		var global = (function () { return this; })();
		result = has("dojo-loader") ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
});

;
define('dojo/_base/Deferred',[
	"./kernel",
	"../Deferred",
	"../promise/Promise",
	"../errors/CancelError",
	"../has",
	"./lang",
	"../when"
], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
});
;
define('dojo/dom-form',["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
});
;
define('dojo/io-query',["dojo/_base/lang"], function(lang){

// module:
//		dojo/io-query

var backstop = {};

return {
// summary:
//		This module defines query string processing functions.

	objectToQuery: function objectToQuery(/*Object*/ map){
		// summary:
        //		takes a name/value mapping object and returns a string representing
        //		a URL-encoded version of that object.
        // example:
        //		this object:
        //
        //	|	{
        //	|		blah: "blah",
        //	|		multi: [
        //	|			"thud",
        //	|			"thonk"
        //	|		]
        //	|	};
        //
        //		yields the following query string:
        //
        //	|	"blah=blah&multi=thud&multi=thonk"

        // FIXME: need to implement encodeAscii!!
        var enc = encodeURIComponent, pairs = [];
        for(var name in map){
            var value = map[name];
            if(value != backstop[name]){
                var assign = enc(name) + "=";
                if(lang.isArray(value)){
                    for(var i = 0, l = value.length; i < l; ++i){
                        pairs.push(assign + enc(value[i]));
                    }
                }else{
                    pairs.push(assign + enc(value));
                }
            }
        }
        return pairs.join("&"); // String
    },

	queryToObject: function queryToObject(/*String*/ str){
        // summary:
        //		Create an object representing a de-serialized query section of a
        //		URL. Query keys with multiple values are returned in an array.
        //
        // example:
        //		This string:
        //
        //	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
        //
        //		results in this object structure:
        //
        //	|		{
        //	|			foo: [ "bar", "baz" ],
        //	|			thinger: " spaces =blah",
        //	|			zonk: "blarg"
        //	|		}
        //
        //		Note that spaces and other urlencoded entities are correctly
        //		handled.

        // FIXME: should we grab the URL string if we're not passed one?
        var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
        for(var i = 0, l = qp.length, item; i < l; ++i){
            item = qp[i];
            if(item.length){
                var s = item.indexOf("=");
                if(s < 0){
                    name = dec(item);
                    val = "";
                }else{
                    name = dec(item.slice(0, s));
                    val  = dec(item.slice(s + 1));
                }
                if(typeof ret[name] == "string"){ // inline'd type check
                    ret[name] = [ret[name]];
                }

                if(lang.isArray(ret[name])){
                    ret[name].push(val);
                }else{
                    ret[name] = val;
                }
            }
        }
        return ret; // Object
    }
};
});;
define('xide/manager/RPCService',[
    'dojo/_base/declare',
    'dojo/_base/kernel',
    'dojo/_base/lang',
    'xide/rpc/Service',
    'xide/rpc/JsonRPC',
    'dojo/has',
    'dojo/Deferred',
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xide/encoding/SHA1'
], function (declare,dojo,lang, Service, JsonRPC, has, Deferred,utils,types,EventedMixin,SHA1) {
    /**
     * Provides tools to deal with 'persistence' (open files, editors, ..etc to be restored). It also acts as interface.
     * @class module:xide/manager/RPCService
     * @extends module:xide/mixins/EventedMixin
     *
     **/
    return declare("xide.manager.RPCService", [Service,EventedMixin], {
        extraArgs: null,
        signatureField: 'sig',
        signatureToken: null,
        correctTarget: true,
        sync: false,
        defaultOptions: {
            omit: true,
            checkMessages: true,
            checkErrors: true
        },
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, {message: err.message.join('<br/>')});
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok');
                }
            }
            var struct = {
                error: err
            };
            this.publish(types.EVENTS.ERROR, struct, this);
        },
        prepareCall: function () {
            var params = {};
            if (this.config && this.config.RPC_PARAMS) {
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                this.extraArgs = params;
                if (this.config.RPC_PARAMS.rpcUserField) {
                    params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;

                    this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                    this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                }
            }
        },
        runDeferred: function (serviceClassIn, method, args, options) {
            var deferred = new Deferred();
            options = options || this.defaultOptions;

            //check this method exists
            if (!this.checkCall(serviceClassIn, method, options.omit)) {
                return deferred.reject('method doesnt exists: ' + method + ' for service class:' + this.serviceClass + ' in ' + this.declaredClass);
            }

            //setup signing in serviceObject
            this.prepareCall();

            //variable shortcuts
            var service = this,
                serviceClass = this.getServiceClass(serviceClassIn),
                thiz = this;

            var resolve = function (data) {
                deferred.resolve(data);
            };

            var promise = service[serviceClass][method](args);
            promise.then(function (res) {

                //the server has some messages for us
                if (options.checkMessages) {
                    if (res && res.error && res.error.code == 3) {
                        thiz.onMessages(res.error);
                    }
                }

                //check for error messages (non-fatal) and abort
                if (options.checkErrors) {
                    if (res && res.error && res.error && res.error.code != 0) {
                        thiz.onError(res.error);
                        deferred.reject(res.error);
                        return;
                    }
                }

                //until here all is ok, tell everybody
                if (options.omit) {
                    thiz.publish(types.EVENTS.STATUS, {
                        message: 'Ok!',
                        what: arguments
                    }, this);
                }


                //final delivery
                resolve(res);


            }, function (err) {
                thiz.onError(err);
            });

            return deferred;
        },
        getParameterMap: function (serviceClass, serviceClassMethod) {

            var services = this._smd.services;
            var smd = services[serviceClass + '.' + serviceClassMethod];
            if (smd && smd.parameters) {
                return smd.parameters;
            }
            return [];
        },
        _getRequest: function (method, args) {
            var smd = this._smd;
            var envDef = Service.envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || method.params || []).concat(smd.parameters || []);

            if (envDef.namedParams) {
                // the serializer is expecting named params
                if ((args.length == 1) && lang.isObject(args[0])) {
                    // looks like we have what we want
                    args = args[0];
                } else {
                    // they provided ordered, must convert
                    var data = {};
                    var params = method.parameters || method.params;
                    for (var i = 0; i < params.length; i++) {
                        if (typeof args[i] != "undefined" || !params[i].optional) {
                            data[params[i].name] = args[i];
                        }
                    }
                    args = data;
                }
                if (method.strictParameters || smd.strictParameters) {
                    //remove any properties that were not defined
                    for (i in args) {
                        var found = false;
                        for (var j = 0; j < parameters.length; j++) {
                            if (parameters[i].name == i) {
                                found = true;
                            }
                        }
                        if (!found) {
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for (i = 0; i < parameters.length; i++) {
                    var param = parameters[i];
                    if (!param.optional && param.name && args != null && !args[param.name]) {
                        if (param["default"]) {
                            args[param.name] = param["default"];
                        } else if (!(param.name in args)) {
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            } else if (parameters && parameters[0] && parameters[0].name && (args.length == 1) && dojo.isObject(args[0])) {
                // looks like named params, we will convert
                if (envDef.namedParams === false) {
                    // the serializer is expecting ordered params, must be ordered
                    args = Service.toOrdered(parameters, args);
                } else {
                    // named is ok
                    args = args[0];
                }
            }

            if (lang.isObject(this._options)) {
                args = dojo.mixin(args, this._options);
            }

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: this.sync,//dojox.rpc._sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || Service.getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function (method) {
            var args = [];
            var i;
            if (arguments.length == 2 && lang.isArray(arguments[1])) {
                args = arguments[1];
            } else {
                for (i = 1; i < arguments.length; i++) {
                    args.push(arguments[i]);
                }
            }
            var request = this._getRequest(method, args);
            if (this.correctTarget) {
                request.target = this._smd.target;
            }


            if (this.extraArgs) {
                var index = 0;
                for (var key in this.extraArgs) {

                    request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                    request.target += key + '=' + this.extraArgs[key];
                }
            }
            if (this.signatureToken) {
                request.target += request.target.indexOf('?') != -1 ? '&' : '?';
                var signature = SHA1._hmac(request.data, this.signatureToken, 1);

                /*                  var aParams = {
                 "service": serviceClass + ".get",
                 "path":path,
                 "callback":"asdf",
                 "raw":"html",
                 "attachment":"0",
                 "send":"1",
                 "user":this.config.RPC_PARAMS.rpcUserValue
                 };

                 var pStr  =  dojo.toJson(aParams);
                 var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);

                 console.error('sign ' + pStr + ' with ' + this.config.RPC_PARAMS.rpcSignatureToken + ' to ' + signature);
                 */
                //var pStr  =  dojo.toJson(request.data);

                var signature = SHA1._hmac(request.data, this.signatureToken, 1);
                //console.error('sign ' + request.data + ' with ' +  this.signatureToken + ' to ' + signature);
                request.target += this.signatureField + '=' + signature;
            }

            var deferred = Service.transportRegistry.match(request.transport).fire(request);
            deferred.addBoth(function (results) {
                return request._envDef.deserialize.call(this, results);
            });
            return deferred;
        },
        getServiceClass: function (serviceClassIn) {
            return serviceClassIn || this.serviceClass;
        },
        hasMethod: function (method,serviceClass) {

            var _service = this,
                _serviceClass = serviceClass || this.getServiceClass();

            return _service &&
                _serviceClass &&
                _service[_serviceClass] != null &&
                _service[_serviceClass][method] != null;
        },
        checkCall: function (serviceClass, method, omit) {
            serviceClass = this.getServiceClass(serviceClass);
            if (!this.hasMethod(method,serviceClass) && omit === true) {
                debugger;
                this.onError({
                    code: 1,
                    message: ['Sorry, server doesnt know ' + method]
                });
                return false;
            }
            return true;
        },


        /************************************************
         *
         * @param data
         * @returns {*}
         */
        base64_encode: function (data) {
            // From: http://phpjs.org/functions
            // +   original by: Tyler Akins (http://rumkin.com)
            // +   improved by: Bayron Guevara
            // +   improved by: Thunder.m
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   bugfixed by: Pellentesque Malesuada
            // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // +   improved by: Rafa Kukawski (http://kukawski.pl)
            // *     example 1: base64_encode('Kevin van Zonneveld');
            // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
            // mozilla has this native
            // - but breaks in 2.0.0.12!
            //if (typeof this.window.btoa === 'function') {
            //    return btoa(data);
            //}
            var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
                ac = 0,
                enc = '',
                tmp_arr = [];

            if (!data) {
                return data;
            }

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);

            enc = tmp_arr.join('');

            var r = data.length % 3;

            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);

        },
        callMethodEx: function (serviceClass, method, args, readyCB, errorCB, omitError) {

            /***
             * Check we the RPC method is in the SMD
             */

            var thiz = this;
            if (!this[serviceClass] || this[serviceClass][method] == null) {
                if (omitError === true && errorCB) {
                    errorCB({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method + ' in class' + serviceClass]
                    });
                }
                return null;
            }

            /***
             * Build signature
             */
            var params = {};


            /**
             * Mixin mandatory fields
             */
            if (this.config && this.config.RPC_PARAMS) {
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.extraArgs = params;
                this.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            }


            this[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }

                if (res && res.error && res.error && res.error.code != 0 && errorCB) {
                    errorCB(res.error);
                    return;
                }
                if (omitError == true) {

                }

            }, function (err) {
                errorCB(err);
            });
        },
        callMethod: function (serviceClass, method, args, readyCB, errorCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            try {
                var thiz = this;
                if (this[serviceClass][method] == null) {
                    if (omitError === true && errorCB) {
                        debugger;
                        errorCB({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = lang.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                this[serviceClass][method](args).then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        console.dir(e);

                    }
                    if (res && res.error && res.error && res.error.code == 1 && errorCB) {
                        errorCB(res.error);
                        return;
                    }

                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        //thiz.publish(types.EVENTS.STATUS,struct ,this);
                    }

                }, function (err) {
                    thiz.onError(err);
                });
            } catch (e) {
                console.error('crash! ' + e);
            }
        }

    });
});;
define('xide/encoding/SHA1',["./_base"], function(base){

	var chrsz=8,	//	change to 16 for unicode.
		mask=(1<<chrsz)-1;

	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
	function FT(t,b,c,d){
		if(t<20){ return (b&c)|((~b)&d); }
		if(t<40){ return b^c^d; }
		if(t<60){ return (b&c)|(b&d)|(c&d); }
		return b^c^d;
	}
	function KT(t){ return (t<20)?1518500249:(t<40)?1859775393:(t<60)?-1894007588:-899497514; }

	function core(x,len){
		x[len>>5]|=0x80<<(24-len%32);
		x[((len+64>>9)<<4)+15]=len;

		var w=new Array(80), a=1732584193, b=-271733879, c=-1732584194, d=271733878, e=-1009589776;
		for(var i=0; i<x.length; i+=16){
			var olda=a, oldb=b, oldc=c, oldd=d, olde=e;
			for(var j=0;j<80;j++){
				if(j<16){ w[j]=x[i+j]; }
				else { w[j]=R(w[j-3]^w[j-8]^w[j-14]^w[j-16],1); }
				var t = base.addWords(base.addWords(R(a,5),FT(j,b,c,d)),base.addWords(base.addWords(e,w[j]),KT(j)));
				e=d; d=c; c=R(b,30); b=a; a=t;
			}
			a=base.addWords(a,olda);
			b=base.addWords(b,oldb);
			c=base.addWords(c,oldc);
			d=base.addWords(d,oldd);
			e=base.addWords(e,olde);
		}
		return [a, b, c, d, e];
	}

	function hmac(data, key){
		var wa=toWord(key);
		if(wa.length>16){ wa=core(wa, key.length*chrsz); }

		var ipad=new Array(16), opad=new Array(16);
		for(var i=0;i<16;i++){
			ipad[i]=wa[i]^0x36363636;
			opad[i]=wa[i]^0x5c5c5c5c;
		}

		var hash=core(ipad.concat(toWord(data)),512+data.length*chrsz);
		return core(opad.concat(hash), 512+160);
	}

	function toWord(s){
		var wa=[];
		for(var i=0, l=s.length*chrsz; i<l; i+=chrsz){
			wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(32-chrsz-i%32);
		}
		return wa;	//	word[]
	}

	function toHex(wa){
		//	slightly different than the common one.
		var h="0123456789abcdef", s=[];
		for(var i=0, l=wa.length*4; i<l; i++){
			s.push(h.charAt((wa[i>>2]>>((3-i%4)*8+4))&0xF), h.charAt((wa[i>>2]>>((3-i%4)*8))&0xF));
		}
		return s.join("");	//	string
	}

	function _toString(wa){
		var s=[];
		for(var i=0, l=wa.length*32; i<l; i+=chrsz){
			s.push(String.fromCharCode((wa[i>>5]>>>(32-chrsz-i%32))&mask));
		}
		return s.join("");	//	string
	}

	function toBase64(/* word[] */wa){
		// summary:
		//		convert an array of words to base64 encoding, should be more efficient
		//		than using dojox.encoding.base64
		var p="=", tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s=[];
		for(var i=0, l=wa.length*4; i<l; i+=3){
			var t=(((wa[i>>2]>>8*(3-i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*(3-(i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*(3-(i+2)%4))&0xFF);
			for(var j=0; j<4; j++){
				if(i*8+j*6>wa.length*32){
					s.push(p);
				} else {
					s.push(tab.charAt((t>>6*(3-j))&0x3F));
				}
			}
		}
		return s.join("");	//	string
	};

	//	public function
	base.SHA1=function(/* String */data, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		Computes the SHA1 digest of the data, and returns the result according to output type.
		var out=outputType||base.outputTypes.Base64;
		var wa=core(toWord(data), data.length*chrsz);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	//	make this private, for later use with a generic HMAC calculator.
	base.SHA1._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){
		// summary:
		//		computes the digest of data, and returns the result according to type outputType
		var out=outputType || base.outputTypes.Base64;
		var wa=hmac(data, key);
		switch(out){
			case base.outputTypes.Raw:{
				return wa;	//	word[]
			}
			case base.outputTypes.Hex:{
				return toHex(wa);	//	string
			}
			case base.outputTypes.String:{
				return _toString(wa);	//	string
			}
			default:{
				return toBase64(wa);	//	string
			}
		}
	};

	return base.SHA1;
});
;
define('xide/rpc/JsonRPC',[
	"./Service",
    "dojo/errors/RequestError",
	"xide/utils/StringUtils"
], function(Service, RequestError,utils){
	function jsonRpcEnvelope(version){
		return {
			serialize: function(smd, method, data, options){
				//not converted to json it self. This  will be done, if
				//appropriate, at the transport level
	
				var d = {
					id: this._requestId++,
					method: method.name,
					params: data
				};
				if(version){
					d.jsonrpc = version;
				}
				return {
					data: JSON.stringify(d),
					handleAs:'json',
					contentType: 'application/json',
					transport:"POST"
				};
			},
			deserialize: function(obj){
				if ('Error' == obj.name // old xhr
					|| obj instanceof RequestError // new xhr
				){
					obj = utils.fromJson(obj.responseText);
				}
				if(obj.error) {
					var e = new Error(obj.error.message || obj.error);
					e._rpcErrorObject = obj.error;
					return e;
				}
				return obj.result;
			}
		};
	}
    Service.envelopeRegistry.register(
		"JSON-RPC-1.0",
		function(str){
			return str == "JSON-RPC-1.0";
		},
		utils.mixin({namedParams:false}, jsonRpcEnvelope()) // 1.0 will only work with ordered params
	);
    Service.envelopeRegistry.register(
		"JSON-RPC-2.0",
		function(str){
			return str == "JSON-RPC-2.0";
		},
        utils.mixin({namedParams:true }, jsonRpcEnvelope("2.0")) // 2.0 supports named params
	);

});
;
define('xide/rpc/Service',[
    "dojo/_base/kernel",
    "dojo/_base/lang",
    "dojo/_base/xhr",
    "dojo/_base/declare",
    "xide/rpc/AdapterRegistry",
    "dojo/_base/url",
    "xide/utils",
    "xide/lodash"
], function(dojo,lang,xhr,declare,AdapterRegistry,url,utils,_){
    var transportRegistry = new AdapterRegistry(true);
    var envelopeRegistry = new AdapterRegistry(true);
    var _nextId  = 1;
    var _sync = false;

    function getTarget(smd, method){
        var dest=smd._baseUrl;
        if(smd.target){
            dest = new dojo._Url(dest,smd.target) + '';
        }
        if(method.target){
            dest = new dojo._Url(dest,method.target) + '';
        }
        return dest;
    }

    function toOrdered(parameters, args){
        if(dojo.isArray(args)){ return args; }
        var data=[];
        for(var i=0;i<parameters.length;i++){
            data.push(args[parameters[i].name]);
        }
        return data;
    }

    var service = declare("xide.rpc.Service", null, {
        constructor: function(smd, options){

            // summary:
            //		Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
            //		as a definition for the service
            // description:
            //		dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
            //		dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
            //		a "No match found" error.
            // smd: object
            //		Takes a number of properties as kwArgs for defining the service.  It also
            //		accepts a string.  When passed a string, it is treated as a url from
            //		which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
            //		object.  It accepts serviceUrl, to manually define a url for the rpc service
            //		allowing the rpc system to be used without an smd definition. strictArgChecks
            //		forces the system to verify that the # of arguments provided in a call
            //		matches those defined in the smd.  smdString allows a developer to pass
            //		a jsonString directly, which will be converted into an object or alternatively
            //		smdObject is accepts an smdObject directly.

            var url;
            var self = this;
            var singleton = options ? options.singleton : false;
            function processSmd(smd){
                smd._baseUrl = new dojo._Url((dojo.isBrowser ? location.href : dojo.config.baseUrl) ,url || '.') + '';
                self._smd = smd;
                if(options && options.services==='methods'){
                    smd.services = smd.methods;
                    delete smd.methods;
                    smd.transport = "POST";
                    if(options.mixin){
                        lang.mixin(smd,options.mixin);
                    }
                    options = null;
                }

                //generate the methods
                for(var serviceName in self._smd.services){
                    var pieces = serviceName.split("."); // handle "namespaced" services by breaking apart by .
                    var current = self;
                    for(var i=0; i< pieces.length-1; i++){
                        // create or reuse each object as we go down the chain
                        current = current[pieces[i]] || (current[pieces[i]] = {});
                    }
                    current[pieces[pieces.length-1]]=	self._generateService(serviceName, self._smd.services[serviceName]);
                }
            }
            if(smd){
                //ifthe arg is a string, we assume it is a url to retrieve an smd definition from
                if( (_.isString(smd)) || (smd instanceof dojo._Url)){
                    if(smd instanceof dojo._Url){
                        url = smd + "";
                    }else{
                        url = smd;
                    }

                    this.__init = xhr.getText(url);
                    var self = this;
                    this.__init.then(function(data){
                        processSmd(utils.fromJson(data));
                    });
                    /*

                    if(!text){
                        throw new Error("Unable to load SMD from " + smd);
                    }else{
                        processSmd(utils.fromJson(text));
                    }
                    */

                }else{
                    processSmd(smd);
                }
            }
            this._options = (options ? options : {});
            this._requestId = 0;
        },

        _generateService: function(serviceName, method){
            if(this[method]){
                throw new Error("WARNING: "+ serviceName+ " already exists for service. Unable to generate function");
            }
            method.name = serviceName;

            var func = dojo.hitch(this, "_executeMethod",method);

            var transport = transportRegistry.match(method.transport || this._smd.transport);
            if(transport.getExecutor){
                func = transport.getExecutor(func,method,this);
            }
            var schema = method.returns || (method._schema = {}); // define the schema
            var servicePath = '/' + serviceName +'/';
            // schemas are minimally used to track the id prefixes for the different services
            schema._service = func;
            func.servicePath = servicePath;
            func._schema = schema;
            func.id = _nextId++;
            return func;
        },
        _getRequest: function(method,args){
            var smd = this._smd;
            var envDef = envelopeRegistry.match(method.envelope || smd.envelope || "NONE");
            var parameters = (method.parameters || []).concat(smd.parameters || []);
            if(envDef.namedParams){
                // the serializer is expecting named params
                if((args.length==1) && dojo.isObject(args[0])){
                    // looks like we have what we want
                    args = args[0];
                }else{
                    // they provided ordered, must convert
                    var data={};
                    for(var i=0;i<method.parameters.length;i++){
                        if(typeof args[i] != "undefined" || !method.parameters[i].optional){
                            data[method.parameters[i].name]=args[i];
                        }
                    }
                    args = data;
                }
                if(method.strictParameters||smd.strictParameters){
                    //remove any properties that were not defined
                    for(i in args){
                        var found=false;
                        for(var j=0; j<parameters.length;j++){
                            if(parameters[j].name==i){ found=true; }
                        }
                        if(!found){
                            delete args[i];
                        }
                    }

                }
                // setting default values
                for(i=0; i< parameters.length; i++){
                    var param = parameters[i];
                    if(!param.optional && param.name && !args[param.name]){
                        if(param["default"]){
                            args[param.name] = param["default"];
                        }else if(!(param.name in args)){
                            throw new Error("Required parameter " + param.name + " was omitted");
                        }
                    }
                }
            }else if(parameters && parameters[0] && parameters[0].name && (args.length==1) && dojo.isObject(args[0])){
                // looks like named params, we will convert
                if(envDef.namedParams === false){
                    // the serializer is expecting ordered params, must be ordered
                    args = toOrdered(parameters, args);
                }else{
                    // named is ok
                    args = args[0];
                }
            }

            if(dojo.isObject(this._options)){
                args = dojo.mixin(args, this._options);
            }
            delete args['mixin'];

            var schema = method._schema || method.returns; // serialize with the right schema for the context;
            var request = envDef.serialize.apply(this, [smd, method, args]);
            request._envDef = envDef;// save this for executeMethod
            var contentType = (method.contentType || smd.contentType || request.contentType);

            // this allows to mandate synchronous behavior from elsewhere when necessary, this may need to be changed to be one-shot in FF3 new sync handling model
            return dojo.mixin(request, {
                sync: _sync,
                contentType: contentType,
                headers: method.headers || smd.headers || request.headers || {},
                target: request.target || getTarget(smd, method),
                transport: method.transport || smd.transport || request.transport,
                envelope: method.envelope || smd.envelope || request.envelope,
                timeout: method.timeout || smd.timeout,
                callbackParamName: method.callbackParamName || smd.callbackParamName,
                rpcObjectParamName: method.rpcObjectParamName || smd.rpcObjectParamName,
                schema: schema,
                handleAs: request.handleAs || "auto",
                preventCache: method.preventCache || smd.preventCache,
                frameDoc: this._options.frameDoc || undefined
            });
        },
        _executeMethod: function(method){
            var args = [];
            var i;
            for(i=1; i< arguments.length; i++){
                args.push(arguments[i]);
            }
            var request = this._getRequest(method,args);
            var deferred = transportRegistry.match(request.transport).fire(request);

            deferred.addBoth(function(results){
                return request._envDef.deserialize.call(this,results);
            });
            return deferred;
        }
});

    service.transportRegistry = transportRegistry;
    service.envelopeRegistry = envelopeRegistry;
    service._nextId = _nextId;
    service.getTarget = getTarget;
    service.toOrdered= toOrdered;
    service._sync = _sync;
    envelopeRegistry.register("URL", function(str){ return str == "URL"; },{
		serialize:function(smd, method, data ){
			var d = dojo.objectToQuery(data);
			return {
				data: d,
				transport:"POST"
			};
		},
		deserialize:function(results){
			return results;
		},
		namedParams: true
	});
    envelopeRegistry.register("JSON",function(str){ return str == "JSON"; },{
        serialize: function(smd, method, data){
            var d = dojo.toJson(data);

            return {
                data: d,
                handleAs: 'json',
                contentType : 'application/json'
            };
        },
        deserialize: function(results){
            return results;
        }
    });
    envelopeRegistry.register("PATH",function(str){ return str == "PATH"; },{
        serialize:function(smd, method, data){
			var i;
			var target = getTarget(smd, method);
			if(dojo.isArray(data)){
				for(i = 0; i < data.length;i++){
					target += '/' + data[i];
				}
			}else{
				for(i in data){
					target += '/' + i + '/' + data[i];
				}
			}
			return {
				data:'',
				target: target
			};
		},
		deserialize:function(results){
			return results;
		}
	});
    //post is registered first because it is the default;
    transportRegistry.register("POST",function(str){ return str == "POST"; },{
		fire:function(r){
			r.url = r.target;
			r.postData = r.data;
			return dojo.rawXhrPost(r);
		}
	});
    transportRegistry.register("GET",function(str){ return str == "GET"; },{
		fire: function(r){
			r.url=  r.target + (r.data ? '?' + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data : '');
			return xhr.get(r);
		}
	});
    //only works ifyou include dojo.io.script
    /*
    transportRegistry.register("JSONP",function(str){ return str == "JSONP"; },{
        fire: function(r){
            r.url = r.target + ((r.target.indexOf("?") == -1) ? '?' : '&') + ((r.rpcObjectParamName) ? r.rpcObjectParamName + '=' : '') + r.data;
            r.callbackParamName = r.callbackParamName || "callback";
            return dojo.io.script.get(r);
        }
    });*/
    if(dojo._contentHandlers) {
        dojo._contentHandlers.auto = function (xhr) {
            // automatically choose the right handler based on the returned content type
            var handlers = dojo._contentHandlers;
            var retContentType = xhr.getResponseHeader("Content-Type");
            var results = !retContentType ? handlers.text(xhr) :
                retContentType.match(/\/.*json/) ? handlers.json(xhr) :
                    retContentType.match(/\/javascript/) ? handlers.javascript(xhr) :
                        retContentType.match(/\/xml/) ? handlers.xml(xhr) : handlers.text(xhr);
            return results;
        };
    }
    return service;
});
;
define('dojo/_base/url',["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});
;
define('xide/rpc/AdapterRegistry',["dojo/_base/kernel", "dojo/_base/lang"], function (dojo, lang) {
    var AdapterRegistry = dojo.AdapterRegistry = function (/*Boolean?*/ returnWrappers) {
        // summary:
        //		A registry to make contextual calling/searching easier.
        // description:
        //		Objects of this class keep list of arrays in the form [name, check,
        //		wrap, directReturn] that are used to determine what the contextual
        //		result of a set of checked arguments is. All check/wrap functions
        //		in this registry should be of the same arity.
        // example:
        //	|	// create a new registry
        //	|	require(["dojo/AdapterRegistry"],
        //	|	function(AdapterRegistry){
        //	|		var reg = new AdapterRegistry();
        //	|		reg.register("handleString",
        //	|			function(str){
        //	|				return typeof val == "string"
        //	|			},
        //	|			function(str){
        //	|				// do something with the string here
        //	|			}
        //	|		);
        //	|		reg.register("handleArr",
        //	|			dojo.isArray,
        //	|			function(arr){
        //	|				// do something with the array here
        //	|			}
        //	|		);
        //	|
        //	|		// now we can pass reg.match() *either* an array or a string and
        //	|		// the value we pass will get handled by the right function
        //	|		reg.match("someValue"); // will call the first function
        //	|		reg.match(["someValue"]); // will call the second
        //	|	});

        this.pairs = [];
        this.returnWrappers = returnWrappers || false; // Boolean
    };

    lang.extend(AdapterRegistry, {
        register: function (/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override) {
            // summary:
            //		register a check function to determine if the wrap function or
            //		object gets selected
            // name:
            //		a way to identify this matcher.
            // check:
            //		a function that arguments are passed to from the adapter's
            //		match() function.  The check function should return true if the
            //		given arguments are appropriate for the wrap function.
            // directReturn:
            //		If directReturn is true, the value passed in for wrap will be
            //		returned instead of being called. Alternately, the
            //		AdapterRegistry can be set globally to "return not call" using
            //		the returnWrappers property. Either way, this behavior allows
            //		the registry to act as a "search" function instead of a
            //		function interception library.
            // override:
            //		If override is given and true, the check function will be given
            //		highest priority. Otherwise, it will be the lowest priority
            //		adapter.
            this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
        },

        match: function (/* ... */) {
            // summary:
            //		Find an adapter for the given arguments. If no suitable adapter
            //		is found, throws an exception. match() accepts any number of
            //		arguments, all of which are passed to all matching functions
            //		from the registered pairs.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[1].apply(this, arguments)) {
                    if ((pair[3]) || (this.returnWrappers)) {
                        return pair[2];
                    } else {
                        return pair[2].apply(this, arguments);
                    }
                }
            }
            throw new Error("No match found");
        },

        unregister: function (name) {
            // summary:
            //		Remove a named adapter from the registry
            // name: String
            //		The name of the adapter.
            // returns: Boolean
            //		Returns true if operation is successful.
            //		Returns false if operation fails.

            // FIXME: this is kind of a dumb way to handle this. On a large
            // registry this will be slow-ish and we can use the name as a lookup
            // should we choose to trade memory for speed.
            for (var i = 0; i < this.pairs.length; i++) {
                var pair = this.pairs[i];
                if (pair[0] == name) {
                    this.pairs.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
    });

    return AdapterRegistry;
});
;
define('xcf/mainr',[
    "xcf/types",
    "xcf/types/Types",
    "xcf/model/Command",
    "xcf/model/Device",
    "xcf/model/Driver",
    "xcf/model/ModelBase",
    "xcf/model/Variable",
    "xcf/factory/Blocks",
    "xcf/manager/BeanManager",
    "xcf/manager/DeviceManager",
    "xcf/manager/BlockManager",
    "xcf/manager/DriverManager",
    "xcf/manager/DriverManager_Server"
], function () {});;
define('xcf/manager/DriverManager_Server',[
    'dcl/dcl',
    'dojo/_base/declare',
    'xide/types',
    'xide/utils'
], function(dcl,declare,types,utils){

    function isItemPath(startNeedle,path){
        var _start = startNeedle;
        if (path.indexOf(_start) != -1) {
            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length);
            return libPath;
        }
        return null;
    }

    return dcl(null,{
        declaredClass:'xcf.manager.DriverManager_Server',
        onDriverBlocksChanged:function(dataPath,shortPath){

        },
        onFileChanged:function(evt){
            if(evt.type!=='changed'){
                return;
            }
            if(evt._didb){
                return;
            }
            evt._didb=true;
            var path = utils.replaceAll('\\', '/', evt.path);
            path = utils.replaceAll('//', '/', path);
            path = path.replace(/\\/g,"/");
            var isDriver = isItemPath('system/driver',path);
            if(isDriver && isDriver.indexOf('.xblox')!==-1){
                console.log('driver blocks changed ' + isDriver + ' @ '+ path, evt);
                this.onDriverBlocksChanged(path,isDriver);
            }
        },
        /**
         *
         * @param storeItem
         * @param readyCB
         */
        createDriverInstance:function(storeItem,readyCB){

            var thiz=this;
            var baseDriverPrefix = this.driverScopes['system_drivers'];
            var baseDriverRequire = baseDriverPrefix + 'DriverBase';
            require([baseDriverRequire],function(baseDriver){

                baseDriver.prototype.declaredClass=baseDriverRequire;
                var meta = storeItem['user'];
                var driverPrefix = thiz.driverScopes[storeItem['scope']];
                var driver  = utils.getCIInputValueByName(meta,types.DRIVER_PROPERTY.CF_DRIVER_CLASS);
                if(!driver){
                    console.error('cant find driver class in meta');
                    return;
                }
                var requirePath  = driverPrefix + driver;
                requirePath=requirePath.replace('.js','');
                requirePath=requirePath.replace('./','');
                require([requirePath],function(driverProtoInstance){
                    var baseClass = baseDriver;
                    var driverProto = declare([baseClass],driverProtoInstance.prototype);
                    var driverInstance = new driverProto();
                    driverInstance.baseClass = baseClass.prototype.declaredClass;
                    driverInstance.modulePath = utils.replaceAll('//','/',requirePath);
                    driverInstance.delegate=thiz;
                    storeItem.instance = driverInstance;
                    if(readyCB){
                        readyCB(driverInstance);
                    }
                    try{
                        driverInstance.start();
                    }catch(e){

                    }
                    return driverInstance;
                });
            });
        }
    });
});
;
/** @module xcf/manager/DriverManager **/
define('xcf/manager/DriverManager',[
    'dcl/dcl',
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/_base/json",
    'xide/types',
    'xcf/types/Types',
    'xide/utils',
    'xcf/manager/BeanManager',
    "xcf/model/Variable",
    'xcf/manager/DriverManager_Server',
    'xide/data/TreeMemory',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xdojo/has',
    'xcf/model/Driver',
    "xide/manager/ServerActionBase",
    "xide/data/Reference",
    'dojo/Deferred',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    'xdojo/has!xcf-ui?./DriverManager_UI',
    'xdojo/has!xcf-ui?xide/views/_CIDialog'
], function (dcl, declare, lang, json, types, fTypes, utils,
    BeanManager, Variable, DriverManager_Server,
    TreeMemory, ObservableStore, Trackable, has, Driver, ServerActionBase, Reference, Deferred, ReloadMixin,
    EventedMixin, DriverManager_UI, _CIDialog) {

        var bases = [
            ServerActionBase,
            BeanManager,
            DriverManager_Server
        ],
            debug = false,
            isServer = !has('host-browser'),
            runDrivers = has('runDrivers'),
            debugDeviceMessages = false;
        has('xcf-ui') && bases.push(DriverManager_UI);

        /**
         * @class module:xcf/manager/DriverManager
         * @extends module:xcf/manager/BeanManager
         * @extends module:xcf/manager/DriverManager_UI
         */
        return dcl(bases, {
            onStoreCreated: function (evt) {
                var type = evt.type,
                    store = evt.store,
                    items = store.query({
                        isDir: false
                    });

                if (type !== types.ITEM_TYPE.DRIVER) {
                    return;
                }
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (item._completed != null || item.name === 'Default') {
                        continue;
                    }
                    item._completed = true;
                    if (has('xcf-ui')) {
                        this.completeDriver(store, item, item);
                    }
                }
            },
            removeDriverInstance: function (instance, device) {
                try {
                    var info = this.getContext().getDeviceManager().toDeviceControlInfo(device),
                        driver = this.getDriverById(instance.device.info.driverId),
                        driverStore = driver._store,
                        parentId = driver.path,
                        deviceId = device.path,
                        instanceId = parentId + '_instances_instance_' + deviceId,
                        instanceReferenceItem = driverStore.getSync(instanceId);

                    instanceReferenceItem && driverStore.removeSync(instanceId);

                    //"Audio-Player/VLC.meta.json_instances_instance_Audio-Player/VLC.meta.json"
                    var instanceReference = _.find(driver.instances, {
                        path: instanceId
                    });

                    if (instanceReference) {
                        driver.instances.remove(instanceReference);
                    }
                    device.removeReference(instanceReferenceItem);
                    if (instanceReferenceItem) {
                        instanceReferenceItem.refresh();
                        driverStore.getSync(parentId + '_instances').refresh();
                    } else {
                        debug && console.error('bad!! cant find reference for instance', arguments);
                    }
                } catch (e) {
                    logError(e, 'error removing driver instance');
                }
            },
            /**
             * @param driver {module:xcf/model/Driver}
             * @returns {module:xblox/model/Scope}
             */
            createDriverBlockScope: function (driver) {
                var blocks = utils.clone(driver.blox && driver.blox.blocks ? driver.blox.blocks : []);
                var scope = driver.blockScope = this.ctx.getBlockManager().createScope({
                    id: driver.id,
                    device: null,
                    driver: driver,
                    instance: null,
                    ctx: this.ctx,
                    getContext: function () {
                        return this.instance;
                    }
                }, blocks, function (error) {
                    if (error) {
                        console.error(error + ' : in ' + driver.name + ' , re-save driver!');
                    }
                });
                return scope;
            },
            /**
             *
             * @param device
             * @param driver
             */
            addDeviceInstance: function (device, driver) {
                return;
                driver.directory = true;
                var store = driver._store,
                    parentId = driver.path,
                    deviceManager = this.ctx.getDeviceManager(),
                    instances = store.getSync(parentId + '_instances');

                instances = instances || store.putSync({
                    path: parentId + '_instances',
                    name: 'Instances',
                    isDir: true,
                    type: 'leaf',
                    parentId: parentId,
                    virtual: true,
                    isCommand: false,
                    icon: 'fa-folder',
                    children: []
                });



                var deviceName = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE),
                    deviceId = device.path,
                    instance = store.putSync(new Reference({
                        name: deviceName,
                        isCommand: false,
                        path: instances.path + '_instance_' + deviceId,
                        isDir: false,
                        type: 'driver_instance',
                        parentId: instances.path,
                        device: device,
                        driver: driver,
                        _mayHaveChildren: false,
                        icon: device.iconClass,
                        state: device.state
                    }));

                instances.children.push(instance);

                device.addReference(instance, {
                    properties: {
                        "name": true,
                        "enabled": true,
                        "state": true,
                        "iconClass": true
                    },
                    onDelete: false
                }, true);


                !driver.instances && (driver.instances = []);

                var instanceReference = _.find(driver.instances, {
                    path: instance.path
                });

                if (instanceReference) {
                    console.log('instance already added ');
                    driver.instances.remove(instanceReference);
                }

                driver.instances.push(instance);
            },
            declaredClass: "xcf.manager.DriverManager",
            /***
             * The Bean-Manager needs a unique name of the bean:
             */
            beanNamespace: 'driver',
            /***
             * The Bean-Manager has some generic function like creating Dialogs for adding new items, please
             * provide a title for the interface.
             */
            beanName: 'Driver',
            /**
             * the icon class for bean edit views
             */
            beanIconClass: 'fa-exchange',
            /**
             * Bean group type
             */
            groupType: types.ITEM_TYPE.DRIVER_GROUP,
            /**
             * Bean item type
             */
            itemType: types.ITEM_TYPE.DRIVER,
            /**
             * The name of the CI in the meta database for the title or name.
             */
            itemMetaTitleField: types.DRIVER_PROPERTY.CF_DRIVER_NAME,
            /**
             * the default scope for new items
             */
            defaultScope: 'system_drivers',
            /***
             * The RPC server class:
             */
            serviceClass: 'XCF_Driver_Service',
            /***
             * A copy of all divers raw da4ta from the server
             */
            rawData: null,
            /***
             * @type {module:xide/data/TreeMemory}
             */
            store: null,
            /***
             * @type {module:xcf/views/DriverTreeView}
             */
            treeView: null,
            /**
             * array of driver store scopes : TODO : tbr
             */
            driverScopes: null,
            _isLoading: false,
            /**
             *
             * @param driver
             * @returns {dojo/Deferred}
             */
            getDriverModule: function (driver) {
                var dfd = new Deferred();
                var driverMeta = driver['user'],
                    script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS);

                var driverScope = driver['scope'];
                script = script ? script.replace('./', '') : '';
                var packageUrl = require.toUrl(driverScope);
                packageUrl = utils.removeURLParameter(packageUrl, 'bust');
                packageUrl = utils.removeURLParameter(packageUrl, 'time');
                if (has('debug') && isServer) {
                    packageUrl = packageUrl.replace('?', '');
                }
                packageUrl = packageUrl.replace('/main.js', '');
                var isRequireJS = !require.cache;
                if (isRequireJS) {
                    packageUrl = packageUrl.replace('/.js', '/');
                }

                var requirePath = packageUrl + '/' + script;
                if (has('debug') && !isServer) {
                    requirePath += requirePath.indexOf('?') == -1 ? '?' : '&';
                    requirePath += 'time' + new Date().getTime();
                }

                if (isServer) {
                    requirePath = requirePath.replace('?', '');
                }

                try {
                    require([requirePath], function (driverModule) {
                        dfd.resolve(driverModule);
                    });
                }
                catch (e) {
                    console.error('error loading driver module from  ' + packageUrl + '---' + script, e);
                    logError(e, 'error loading driver module');
                    dfd.reject(e.message);
                }
                return dfd;
            },
            loadDriverModule: function (driver) {
                var baseDriverPrefix = this.driverScopes['system_drivers'],
                    baseDriverRequire = baseDriverPrefix + 'DriverBase';

                var urlBase = require.toUrl(this.driverScopes['system_drivers']);
                var self = this;
                var ctx = self.ctx,
                    dfd = new Deferred(),
                    _require = require;

                _require([baseDriverRequire], function (baseDriver) {

                    var driverPrefix = self.driverScopes[driver.scope],
                        isRequireJS = !require.cache;

                    if (isRequireJS) {
                        require({
                            config: {
                                urlArgs: null
                            }
                        });
                    } else {
                        require({
                            cacheBust: null
                        });
                    }

                    var packageUrl = require.toUrl(driverPrefix);
                    if (isRequireJS) {
                        packageUrl = packageUrl.replace('/.js', '/');
                    }
                    var driverMeta = driver['user'];
                    var script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS);
                    script = script.replace('./', '');
                    script = script.replace('.js', '');
                    script = driver.scope + '/' + script;
                    script = script.replace('', '').trim();
                    try {
                        _require.undef(script);
                        _require([script], function (driverProtoInstance) {
                            driverProtoInstance.declaredClass = script;
                            var driverProto = dcl([baseDriver, EventedMixin.dcl, ReloadMixin.dcl, driverProtoInstance], {});
                            driverProto.getFields = driverProtoInstance.getFields;
                            function onReloaded(newModule, oldModule) {
                                driverProtoInstance.getFields = newModule.getFields;
                                newModule.onReloaded = onReloaded;
                                oldModule.onReloaded = onReloaded;
                            }
                            driverProtoInstance.onReloaded = onReloaded;
                            dfd.resolve(driverProtoInstance);
                        });
                    } catch (e) {
                    }

                });
                return dfd;
            },
            getBlock: function (url) {
                var parts = utils.parse_url(url);
                parts = utils.urlArgs(parts.host);//go on with query string
                var _driver = this.getItemById(parts.driver.value),
                    block = null;

                if (_driver && _driver.blockScope) {
                    block = _driver.blockScope.getBlockById(parts.block.value);
                }
                return block;
            },
            getDriverByUrl: function (url) {
                var parts = utils.parse_url(url);
                parts = utils.urlArgs(parts.host);//go on with query string
                return this.getItemById(parts.driver.value);
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Device messaging
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /**
             * Secondary entry for incoming device messages. This is a regular callback
             * for the system event xcf.types.EVENTS.ON_DEVICE_MESSAGE emitted by the
             * DeviceManager. It comes with the device info, a driver instance and the
             * unfiltered device message.
             *
             * This function is primarily in charge to :
             * 1. split the message by a delimiter (driver settings)
             * 2. pass the device messages to the actual driver
             * 3. pass the device message to blox
             * 4.
             *
             * @param evt
             */
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  CI related
            //
            /////////////////////////////////////////////////////////////////////////////////////
            _driverQueryCache: null,
            _getDriverById: function (id, store) {
                if (!store || !store.getSync) {
                    return;
                }
                var items = store.query();
                if (!_.isArray(items)) {
                    items = [items];
                }
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (item.isDir) {
                        continue;
                    }
                    var meta = item['user'];
                    var _id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID);
                    if (!_id) {
                        continue;
                    }
                    if (_id.value == id) {
                        return store.getSync(item.path);
                    }
                }
                return null;
            },
            getDriverById: function (id, store) {
                if (store) {
                    return this._getDriverById(id, store);
                }
                var options = [];
                var result = null;
                var self = this;
                var driver = null;
                if (!has('xcf-ui') && !has('host-node')) {
                    !this._driverQueryCache && (this._driverQueryCache = {});
                    if (this._driverQueryCache[id]) {
                        return this._driverQueryCache[id];
                    }
                }

                function search(_store) {
                    return self._getDriverById(id, _store);
                }

                for (var scope in this.stores) {
                    var store = this.stores[scope];
                    result = search(store);
                    if (result) {
                        driver = result;
                        break;
                    }
                }
                if (!has('xcf-ui') && driver && !has('host-node')) {
                    this._driverQueryCache[id] = driver;
                }

                return driver;
            },
            getDriverByPath: function (path) {

                var options = [];
                var result = null;

                function search(store) {
                    var items = utils.queryStore(store, {
                        isDir: false
                    });
                    if (!_.isArray(items)) {
                        items = [items];
                    }
                    for (var i = 0; i < items.length; i++) {
                        var driver = items[i];
                        if (driver.path == path) {
                            return driver;
                        }
                    }
                    return null;
                }

                for (var scope in this.stores) {
                    var store = this.stores[scope];
                    result = search(store);
                    if (result) {
                        return result;
                    }
                }
                return null;
            },

            getItemById: function (itemId) {
                return this.getDriverById(itemId);
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Data related
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /**
             *  Callback when a blox scope has been created. This is being used
             *  to deserialize the driver's CI meta settings into a blox scope : variables, commands
             * @param scope
             */
            onNewDriverScopeCreated: function (scope) { },
            onScopeCreated: function (evt) { },
            onDeviceDisconnected: function (evt) { },
            onDriverCreated: function (store) {
                has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
            },
            onDriverRemoved: function (store, item) {
                has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
            },
            onStoreReady: function (store) {
                has('xcf-ui') && types.registerEnumeration('Driver', this.getDriversAsEnumeration(store));
            },
            /***
             * Init the store with the driver data
             * @param data
             * @param scope {string}
             * @param track {boolean}
             * @returns {module:xide/data/TreeMemory}
             */
            createStore: function (data, scope, track) {
                //@TODO: weird bug
                if (data && !data.items && data['0']) {
                    data = {
                        items:data['0'].items
                    };
                }

                var storeClass = declare('driverStore', [TreeMemory, Trackable, ObservableStore], {});
                var store = new storeClass({
                    data: [],
                    Model: Driver,
                    idProperty: 'path',
                    scope: scope,
                    id: utils.createUUID(),
                    observedProperties: [
                        "name",
                        "enabled"
                    ]
                });

                if (data && data.items) {
                    store.setData(data.items);
                    _.each(data.items, function (item) {
                        item._store = store;
                    });
                }
                if (scope && track !== false) {
                    this.setStore(scope, store);
                }
                return store;
            },
            /***
             * Inits the store with the driver data
             * @param data
             * @param scope {string}
             * @param track {boolean}
             * @returns {module:xide/data/TreeMemory}
             */
            initStore: function (data, scope, track) {
                var store = this.createStore(data, scope, track);
                return store;
            },
            getStore: function (scope) {
                scope = scope || 'system_drivers';
                var store = this.stores[scope];
                if (store) {
                    return store;
                }
                return this.ls(scope);
            },
            /***
             * ls is enumerating all drivers in a given scope
             * @param scope{string}
             * @returns {Deferred}
             */
            ls: function (scope, track) {
                var dfd = new Deferred();
                function data(data) {
                    try {
                        var store = this.createStore(data, scope, track);
                        //track!==false && this.setStore(scope,store);
                        this.onStoreReady(store);
                        track !== false && this.publish(types.EVENTS.ON_STORE_CREATED, {
                            data: data,
                            owner: this,
                            store: store,
                            type: this.itemType
                        });
                        dfd.resolve(store);
                    } catch (e) {
                        logError(e, 'error ls drivers');
                    }
                }
                if (this.prefetch && this.prefetch[scope]) {
                    data.apply(this, [this.prefetch[scope]]);
                    delete this.prefetch[scope];
                    return dfd;
                }
                if (has('php')) {
                    this.runDeferred(null, 'ls', [scope]).then(data.bind(this));
                } else {
                    if (!isServer) {
                        var def = this._getText(require.toUrl(scope).replace('main.js', '') + scope + '.json', {
                            sync: false,
                            handleAs: 'json'
                        }).then(data.bind(this));
                    } else {
                        dfd.resolve({ items: [] });
                    }
                }
                return dfd;
            },
            /***
             * Common manager function, called by the context of the application
             */
            init: function () {
                var thiz = this;
                var EVENTS = types.EVENTS;

                this.subscribe([
                    EVENTS.ON_SCOPE_CREATED,
                    EVENTS.ON_STORE_CREATED
                ]);

                //replay block exceptions to log messages
                this.subscribe(EVENTS.ON_BLOCK_EXPRESSION_FAILED, function (evt) {
                    thiz.publish(EVENTS.ON_SERVER_LOG_MESSAGE, {
                        data: {
                            type: 'Expression',
                            device: evt.deviceInfo
                        },
                        level: 'error',
                        message: 'Expression Failed: ' + evt.item.title + ' : ' + evt.item.value
                    });
                });

                this.driverScopes = {
                    "system_drivers": "system_drivers/",
                    "user_drivers": "user_drivers/"
                };
            }
        });
    });
;
/** @module xide/mixins/ReloadMixin **/
define('xide/mixins/ReloadMixin',[
    "xdojo/declare",
    "dcl/dcl",
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin'
], function (declare,dcl,types, utils,EventedMixin) {

    /**
     * Mixin which adds functions for module reloading to the consumer. All functions
     * of the reloaded module will be overridden with the re-loaded module's version.
     * Recommended: turn off web-cache and use turn on 'cacheBust' in your Dojo-Config.
     *
     *
     *  <b>Usage</b> :
     *  1. call initReload manually (subscribes to types.EVENTS.ON_MODULE_RELOADED which is triggered by module:xide/manager/Context )
     *  2. that's it actually.
     *  3. optionally add a function 'onReloaded' to your sub class and refresh yourself, ie: re-create widgets or simply test
     *  a piece of code
     *
     *
     * @mixin module:xide/mixins/ReloadMixin
     * @requires module:xide/mixins/EventedMixin
     */
    var Impl = {
        /**
         *
         * Not used yet, but at @TODO: some flags to describe the hot-replace for reloaded modules
         *
         */
        _mergeFunctions: true,
        _mergeMissingVariables: true,
        /**
         * Cross instanceOf equal check, tries:
         *
         *  1. native
         *  2. Dojo::isInstanceOf
         *  3. baseClasses
         *
         * @param cls {Object}
         * @returns {boolean}
         */
        isInstanceOf_: function (cls) {

            try {

                //Try native and then Dojo declare's _Stateful::isInstanceOf
                if (!!this instanceof cls
                    || (this.isInstanceOf && this.isInstanceOf(cls))) {

                    return true;

                }else{

                    //manual lookup, browse all base classes and their superclass
                    var bases = utils.getAt(this, 'constructor._meta.bases', []),//save get, return base::at[path] or empty array
                        _clsClass = cls.prototype.declaredClass;    //cache

                    //save space
                    return _.findWhere(bases, function (_base) {

                        return _base == cls    //direct cmp
                        || utils.getAt(_base, 'superclass.declaredClass') === _clsClass   //mostly here
                        || utils.getAt(_base, 'prototype.declaredClass') === _clsClass;    //sometimes

                    });

                }

            } catch (e) {
                //may crash, no idea why!
                console.log('ReloadMixin :: this.isInstanceOf_ crashed ' + e);
            }

            return false;

        },
        /**
         * @TODO: use flag guarded mixin
         *
         * @param target
         * @param source
         */
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (_.isFunction(source[i])) {
                    target[i] = null;//be nice
                    target[i] = source[i];//override
                }
                //support missing properties
                if (_.isArray(source[i])) {
                    if (target[i] == null) {
                        target[i] = source[i];
                    }
                }
            }
        },
        /**
         * Event callback for xide/types/EVENTS/ON_MODULE_RELOADED when a module has been reloaded.
         * @member
         * @param evt
         */
        onModuleReloaded: function (evt) {
            //console.log('on module reloaded');
            var newModule = evt.newModule;
            if (!newModule || !newModule.prototype || evt._processed) {
                return;
            }
            var moduleProto = newModule.prototype,
                moduleClass = moduleProto.declaredClass,
                matchedByClass = false,
                thisClass = this.declaredClass,
                thiz=this;

            if(!moduleClass){
                return;
            }
            if (moduleClass && thisClass) {
                //determine by dotted normalized declaredClass
                matchedByClass = utils.replaceAll('/', '.', thisClass) === utils.replaceAll('/', '.', moduleClass);
            }
            if (matchedByClass) {
                thiz.mergeFunctions(thiz, moduleProto);
                if (thiz.onReloaded) {
                    evt._processed = true;
                    thiz.onReloaded(newModule);
                }
            } else if (evt.module && utils.replaceAll('//', '/', evt.module) === thisClass) {//not sure this needed left
                //dcl module!
                thiz.mergeFunctions(thiz, moduleProto);
            }
        },
        /**
         * Public entry; call that in your sub-class to init this functionality!
         */
        initReload: function () {
            this.subscribe(types.EVENTS.ON_MODULE_RELOADED);
        }
    };

    //package via declare
    var _class = declare(null,Impl);

    //static access to Impl.
    _class.Impl = Impl;

    _class.dcl = dcl(EventedMixin.dcl,Impl);

    return _class;

});;
/** @module xide/data/Reference **/
define('xide/data/Reference',[
    "dcl/dcl",
    "xide/utils",
    "xide/lodash",
    "xide/mixins/EventedMixin"
], function (dcl, utils, lodash, EventedMixin) {
    var debug = false;
    /**
     * @class module:xide/data/Reference
     */
    var Implementation = {
        /**
         * @type {Array<module:xide/data/Source>}
         */
        _sources: [],
        /**
         * Activate destruction by default upon store destroy.
         */
        destroyOnRemove: true,
        /**
         * @type {module:xide/data/_Base|null} The store.
         */
        _store: null,
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  deprecated API
        //
        removeSource: function (source) {
        },
        updateSource: function (sources) {
        },
        onSourceUpdate: function (source) {
        },
        onSourceRemoved: function (source) {
        },
        onSourceDelete: function (source) {
        },
        //  deprecated API - end
        /**
         * Placeholder
         * @param args
         */
        onItemChanged: function (args) {
        },
        destroy: function () {
            if (this.item && !this.item.removeReference) {
                debug && console.error('item has no removeReference');
            } else {
                this.item && this.item.removeReference(this);
            }
            this.inherited && this.inherited(arguments);
            if (this._sources) {
                for (var i = 0; i < this._sources.length; i++) {
                    var link = this._sources[i];
                    if (link.item) {
                        link.item.removeReference && link.item.removeReference(this);
                    }
                }
                this._sources = null;
            }
        },
        hasSource: function (source) {
            return lodash.find(this._sources, {item: source});
        },
        addSource: function (source, settings) {
            if (this.hasSource(source)) {
                debug && console.warn('already have source');
                return;
            }
            this._sources.push({
                item: source,
                settings: settings
            });
            if (settings && settings.onDelete) {
                this.addHandle('delete', source._store.on('delete', function (evt) {
                    if (evt.target == source) {
                        this._store.removeSync(this[this._store.idProperty]);
                    }
                }.bind(this)));
            }
        },
        updateSources: function (args) {
            for (var i = 0; i < this._sources.length; i++) {
                var link = this._sources[i];
                var item = link.item;
                var settings = link.settings;
                if (args.property && settings.properties && settings.properties[args.property]) {
                    item._store.silent(true);
                    item.set(args.property, args.value);
                    item._store.silent(false);
                    item._store.emit('update', {target: item});
                }
            }
        },
        constructor: function (properties) {
            this._sources = [];
            utils.mixin(this, properties);
        }
    };
    var Module = dcl([EventedMixin.dcl], Implementation);
    Module.Implementation = Implementation;
    return Module;
});;
define('dstore/Trackable',[
	'dojo/_base/lang',
	'dojo/_base/declare',
	'dojo/aspect',
	'dojo/when',
	'dojo/promise/all',
	'dojo/_base/array',
	'dojo/on'
	/*=====, './api/Store' =====*/
], function (lang, declare, aspect, when, whenAll, arrayUtil, on /*=====, Store =====*/) {

	// module:
	//		dstore/Trackable
	var revision = 0;

	function createRange(newStart, newEnd) {
		return {
			start: newStart,
			count: newEnd - newStart
		};
	}

	function registerRange(ranges, newStart, newEnd) {
		for (var i = ranges.length - 1; i >= 0; --i) {
			var existingRange = ranges[i],
				existingStart = existingRange.start,
				existingEnd = existingStart + existingRange.count;

			if (newStart > existingEnd) {
				// existing range completely precedes new range. we are done.
				ranges.splice(i + 1, 0, createRange(newStart, newEnd));
				return;
			} else if (newEnd >= existingStart) {
				// the ranges overlap and must be merged into a single range
				newStart = Math.min(newStart, existingStart);
				newEnd = Math.max(newEnd, existingEnd);
				ranges.splice(i, 1);
			}
		}

		ranges.unshift(createRange(newStart, newEnd));
	}

	function unregisterRange(ranges, start, end) {
		for (var i = 0, range; (range = ranges[i]); ++i) {
			var existingStart = range.start,
				existingEnd = existingStart + range.count;

			if (start <= existingStart) {
				if (end >= existingEnd) {
					// The existing range is within the forgotten range
					ranges.splice(i, 1);
				} else {
					// The forgotten range overlaps the beginning of the existing range
					range.start = end;
					range.count = existingEnd - range.start;

					// Since the forgotten range ends before the existing range,
					// there are no more ranges to update, and we are done
					return;
				}
			} else if (start < existingEnd) {
				if (end > existingStart) {
					// The forgotten range is within the existing range
					ranges.splice(i, 1, createRange(existingStart, start), createRange(end, existingEnd));

					// We are done because the existing range bounded the forgotten range
					return;
				} else {
					// The forgotten range overlaps the end of the existing range
					range.count = start - range.start;
				}
			}
		}
	}

	var trackablePrototype = {
		track: function () {
			var store = this.store || this;

			// monitor for updates by listening to these methods
			var handles = [];
			var eventTypes = {add: 1, update: 1, 'delete': 1};
			// register to listen for updates
			for (var type in eventTypes) {
				handles.push(
					this.on(type, (function (type) {
						return function (event) {
							notify(type, event);
						};
					})(type))
				);
			}

			function makeFetch() {
				return function () {
					var self = this;
					var fetchResults = this.inherited(arguments);
					when(fetchResults, function (results) {
						results = self._results = results.slice();
						if (self._partialResults) {
							// clean this up, as we don't need this anymore
							self._partialResults = null;
						}
						self._ranges = [];
						registerRange(self._ranges, 0, results.length);
					});
					return fetchResults;
				};
			}
			function makeFetchRange() {
				return function (kwArgs) {
					var self = this,
						start = kwArgs.start,
						end = kwArgs.end,
						fetchResults = this.inherited(arguments);
					// only use this if we don't have all the data
					if (!this._results) {
						when(fetchResults, function (results) {
							return when(results.totalLength, function (totalLength) {
								var partialResults = self._partialResults || (self._partialResults = []);
								end = Math.min(end, start + results.length);

								partialResults.length = totalLength;

								// copy the new ranged data into the parent partial data set
								var spliceArgs = [ start, end - start ].concat(results);
								partialResults.splice.apply(partialResults, spliceArgs);
								registerRange(self._ranges, start, end);

								return results;
							});
						});
					}
					return fetchResults;
				};
			}

			// delegate rather than call _createSubCollection because we are not ultimately creating
			// a new collection, just decorating an existing collection with item index tracking.
			// If we use _createSubCollection, it will return a new collection that may exclude
			// important, defining properties from the tracked collection.
			var observed = declare.safeMixin(lang.delegate(this), {
				_ranges: [],

				fetch: makeFetch(),
				fetchRange: makeFetchRange(),

				releaseRange: function (start, end) {
					if (this._partialResults) {
						unregisterRange(this._ranges, start, end);

						for (var i = start; i < end; ++i) {
							delete this._partialResults[i];
						}
					}
				},

				on: function (type, listener) {
					var self = this,
						inheritedOn = this.getInherited(arguments);
					return on.parse(observed, type, listener, function (target, type) {
						return type in eventTypes ?
							aspect.after(observed, 'on_tracked' + type, listener, true) :
							inheritedOn.call(self, type, listener);
					});
				},

				tracking: {
					remove: function () {
						while (handles.length > 0) {
							handles.pop().remove();
						}

						this.remove = function () {};
					}
				},
				// make sure track isn't called twice
				track: null
			});
			if (this.fetchSync) {
				// only add these if we extending a sync-capable store
				declare.safeMixin(observed, {
					fetchSync: makeFetch(),
					fetchRangeSync: makeFetchRange()
				});

				// we take the presence of fetchSync to indicate that the results can be
				// retrieved cheaply, and then we can just automatically fetch and start
				// tracking results
				observed.fetchSync();
			}

			// Create a function that applies all queriers in the query log
			// in order to determine whether a new or updated item belongs
			// in the results and at what position.
			var queryExecutor;
			arrayUtil.forEach(this.queryLog, function (entry) {
				var existingQuerier = queryExecutor,
					querier = entry.querier;

				if (querier) {
					queryExecutor = existingQuerier
						? function (data) { return querier(existingQuerier(data)); }
						: querier;
				}
			});

			var defaultEventProps = {
					'add': { index: undefined },
					'update': { previousIndex: undefined, index: undefined },
					'delete': { previousIndex: undefined }
				},
				findObject = function (data, id, start, end) {
					start = start !== undefined ? start : 0;
					end = end !== undefined ? end : data.length;
					for (var i = start; i < end; ++i) {
						if (store.getIdentity(data[i]) === id) {
							return i;
						}
					}
					return -1;
				};

			function notify(type, event) {

				revision++;
				var target = event.target;
				event = lang.delegate(event, defaultEventProps[type]);

				when(observed._results || observed._partialResults, function (resultsArray) {
					/* jshint maxcomplexity: 32 */

					function emitEvent() {
						// TODO: Eventually we will want to aggregate all the listener events
						// in an event turn, but we will wait until we have a reliable, performant queueing
						// mechanism for this (besides setTimeout)
						var method = observed['on_tracked' + type];
						method && method.call(observed, event);
					}

					if (!resultsArray) {
						// without data, we have no way to determine the indices effected by the change,
						// so just pass along the event and return.
						emitEvent();
						return;
					}

					var i, j, l, ranges = observed._ranges, range;
					/*if(++queryRevision != revision){
						throw new Error('Query is out of date, you must observe() the' +
						' query prior to any data modifications');
					}*/

					var targetId = 'id' in event ? event.id : store.getIdentity(target);
					var removedFrom = -1,
						removalRangeIndex = -1,
						insertedInto = -1,
						insertionRangeIndex = -1;
					if (type === 'delete' || type === 'update') {
						// remove the old one
						for (i = 0; removedFrom === -1 && i < ranges.length; ++i) {
							range = ranges[i];
							for (j = range.start, l = j + range.count; j < l; ++j) {
								var object = resultsArray[j];
								// often ids can be converted strings (if they are used as keys in objects),
								// so we do a coercive equality check
								/* jshint eqeqeq: false */
								if (store.getIdentity(object) == targetId) {
									removedFrom = event.previousIndex = j;
									removalRangeIndex = i;
									resultsArray.splice(removedFrom, 1);

									range.count--;
									for (j = i + 1; j < ranges.length; ++j) {
										ranges[j].start--;
									}

									break;
								}
							}
						}
					}

					if (type === 'add' || type === 'update') {
						if (queryExecutor) {
							// with a queryExecutor, we can determine the correct sorted index for the change

							if (queryExecutor([target]).length) {
								var begin = 0,
									end = ranges.length - 1,
									sampleArray,
									candidateIndex = -1,
									sortedIndex,
									adjustedIndex;
								while (begin <= end && insertedInto === -1) {
									// doing a binary search for the containing range
									i = begin + Math.round((end - begin) / 2);
									range = ranges[i];

									sampleArray = resultsArray.slice(range.start, range.start + range.count);

									if ('beforeId' in event) {
										candidateIndex = event.beforeId === null
											? sampleArray.length
											: findObject(sampleArray, event.beforeId);
									}

									if (candidateIndex === -1) {
										// If the original index came from this range, put back in the original slot
										// so it doesn't move unless it needs to (relying on a stable sort below)
										if (removedFrom >= Math.max(0, range.start - 1)
											&& removedFrom <= (range.start + range.count)) {
											candidateIndex = removedFrom;
										} else {
											candidateIndex = store.defaultNewToStart ? 0 : sampleArray.length;
										}
									}
									sampleArray.splice(candidateIndex, 0, target);

									sortedIndex = arrayUtil.indexOf(queryExecutor(sampleArray), target);
									adjustedIndex = range.start + sortedIndex;

									if (sortedIndex === 0 && range.start !== 0) {
										end = i - 1;
									} else if (sortedIndex >= (sampleArray.length - 1) &&
											adjustedIndex < resultsArray.length) {
										begin = i + 1;
									} else {
										insertedInto = adjustedIndex;
										insertionRangeIndex = i;
									}
								}
								if (insertedInto === -1 && begin > 0 && begin < ranges.length) {
									var betweenRanges = true;
								}
							}
						} else {
							// we don't have a queryExecutor, so we can't provide any information
							// about where it was inserted or moved to. If it is an update, we leave
							// its position alone. otherwise, we at least indicate a new object

							var range,
								possibleRangeIndex = -1;
							if ('beforeId' in event) {
								if (event.beforeId === null) {
									insertedInto = resultsArray.length;
									possibleRangeIndex = ranges.length - 1;
								} else {
									for (i = 0, l = ranges.length; insertionRangeIndex === -1 && i < l; ++i) {
										range = ranges[i];

										insertedInto = findObject(
											resultsArray,
											event.beforeId,
											range.start,
											range.start + range.count
										);

										if (insertedInto !== -1) {
											insertionRangeIndex = i;
										}
									}
								}
							} else {
								if (type === 'update') {
									insertedInto = removedFrom;
									insertionRangeIndex = removalRangeIndex;
								} else {
									if (store.defaultNewToStart) {
										insertedInto = 0;
										possibleRangeIndex = 0;
									} else {
										// default to the bottom
										insertedInto = resultsArray.length;
										possibleRangeIndex = ranges.length - 1;
									}
								}
							}

							if (possibleRangeIndex !== -1 && insertionRangeIndex === -1) {
								range = ranges[possibleRangeIndex];
								if (range && range.start <= insertedInto
									&& insertedInto <= (range.start + range.count)) {
									insertionRangeIndex = possibleRangeIndex;
								}
							}
						}

						// an item only truly has a known index if it is in a known range
						if (insertedInto > -1 && insertionRangeIndex > -1) {
							event.index = insertedInto;
							resultsArray.splice(insertedInto, 0, target);

							// update the count and start of the appropriate ranges
							ranges[insertionRangeIndex].count++;
							for (i = insertionRangeIndex + 1; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						} else if (betweenRanges) {
							// the begin index will be after the inserted item, and is
							// where we can begin incrementing start values
							event.beforeIndex = ranges[begin].start;
							for (i = begin; i < ranges.length; ++i) {
								ranges[i].start++;
							}
						}
					}
					// update the total
					event.totalLength = resultsArray.length;

					emitEvent();
				});
			}

			return observed;
		}
	};

	var Trackable =  declare(null, trackablePrototype);

	Trackable.create = function (target, properties) {
		// create a delegate of an existing store with trackability functionality mixed in
		target = declare.safeMixin(lang.delegate(target), trackablePrototype);
		declare.safeMixin(target, properties);
		return target;
	};
	return Trackable;
});
;
define('dojo/promise/all',[
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});
;
/** @module xide/data/ObservableStore **/
define('xide/data/ObservableStore',[
    "dojo/_base/declare",
    "xide/mixins/EventedMixin",
    "xide/lodash"
], function (declare, EventedMixin, _) {
    /**
     * Mixin to deal with dmodel
     * @class module:xide/data/ObservableStore
     * @lends module:xide/data/_Base
     * @lends module:dstore/Store
     * @lends module:xide/data/Memory
     */
    return declare('xide/data/Observable', EventedMixin, {
        /**
         * @type {boolean} Toggle to mute notifications during batch operations.
         */
        _ignoreChangeEvents: true,
        /**
         * @type {Array<String>} List of default properties to be observed by dmodel.property.observe.
         */
        observedProperties: [],
        /**
         * Get/Set toggle to prevent notifications for mass store operations. Without there will be performance drops.
         * @param silent {boolean|null}
         */
        silent: function (silent) {
            if (silent === undefined) {
                return this._ignoreChangeEvents;
            }
            if (silent === true || silent === false && silent !== this._ignoreChangeEvents) {
                this._ignoreChangeEvents = silent;
            }
        },
        /**
         * XIDE Override and extend putSync for adding the _store property and observe a new item's properties.
         * @param item
         * @param publish
         * @returns {*}
         */
        putSync: function (item, publish) {
            this.silent(!publish);
            var res = this.inherited(arguments);
            var self = this;
            publish !== false && this.emit('added', res);
            res && !res._store && Object.defineProperty(res, '_store', {
                get: function () {
                    return self;
                }
            });
            this._observe(res);
            this.silent(false);
            return res;
        },
        /**
         * Extend and override removeSync to silence notifications during batch operations.
         * @param id {string}
         * @param silent {boolean|null}
         * @returns {*}
         */
        removeSync: function (id, silent) {
            this.silent(silent);
            var _item = this.getSync(id);
            _item && _item.onRemove && _item.onRemove();
            var res = this.inherited(arguments);
            this.silent(false);
            return res;
        },
        /**
         *
         * @param item
         * @param property
         * @param value
         * @param source
         * @private
         */
        _onItemChanged: function (item, property, value, source) {
            if (this._ignoreChangeEvents) {
                return;
            }
            var args = {
                target: item,
                property: property,
                value: value,
                source: source
            };
            this.emit('update', args);
            item.onItemChanged && item.onItemChanged(args);
        },
        /**
         * Observe an item's properties specified in this.observedProperties and item.observed, called upon putSync.
         * @param item {module:xide/data/Model}
         * @private
         */
        _observe: function (item) {
            var props = this.observedProperties;
            item.observed && (props = props.concat(item.observed));
            _.each(props, function (property) {
                item.property && item.property(property).observe(function (value) {
                    this._onItemChanged(item, property, value, this);
                }.bind(this));
            }.bind(this));
        },
        /**
         * Override setData to bring in dmodel's observe for new items.
         * @param data {object[]}
         * @returns {*}
         */
        setData: function (data) {
            var res = this.inherited(arguments);
            this.silent(true);
            data && _.each(data, this._observe, this);
            this.silent(false);
            return res;
        }
    });
});;
define('xcf/manager/BlockManager',[
    'dcl/dcl',
    'xide/types',
    'xide/manager/ManagerBase',
    'xblox/manager/BlockManager',
    "xide/lodash"
], function (dcl, types, ManagerBase, BlockManager,_) {
    return dcl([ManagerBase, BlockManager], {
        declaredClass: "xcf.manager.BlockManager",
        //nulled for server mode
        onReady: function () {},
        addDriverFunctions: function (target, source) {
            for (var i in source) {
                if (i === 'constructor' || i === 'inherited') {
                    continue;
                }
                if (_.isFunction(source[i])) {
                    target[i] = source[i];
                }
            }
        },
        /**
         * One time call per blox scope creation. This adds various functions
         * to the blox's owner object. This enables expressions to access the
         * object but also block specific functions like getVariable
         * @param obj
         * @param scope
         * @param owner
         */
        setScriptFunctions: function (obj, scope, owner) {
            var thiz = owner;
            if (!scope.context) {
                scope.context = obj;//set the context of the blox scope
            }
            if (!obj.blockScope) {
                obj.blockScope = scope;
            }
            //add shortcuts to the device
            if (scope.context) {

                if (scope.context.instance) {//no real driver instance!
                    scope.device = scope.context.instance;//but we have a device less instance
                    /*scope.context = scope.context.instance;*/
                    /*this.addDriverFunctions(obj,scope.context.instance);*/

                } else {
                    /*this.addDriverFunctions(obj,scope.context.instance);*/

                    /*
                     scope.device = {//we have a real device : add 'sendMessage'
                     _object: obj,
                     _scope: scope,
                     sendMessage: function (message) {

                     //case when we've been constructed with no real device
                     if (this._scope && this._scope.context && this._scope.context.instance) {
                     this._scope.context.instance.sendMessage(message);
                     return;
                     }
                     //console.log('sending device message : ' + message);
                     //xlog('sending message : ' + message);
                     //xtrace('test');
                     //xtrace('test');
                     //console.trace("Device.Manager.Send.Message : " + message, this);//sending device message
                     }
                     }
                     */
                }
            }
            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Commands
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if (!obj.callCommand) {
                obj.callCommand = function (title) {
                    var _block = this.blockScope.getBlockByName(title);
                    if (_block) {
                        _block.solve(this.blockScope);
                    }
                };
            }
            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Variables
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if (!obj.setVariable) {
                obj.setVariable = function (title, value, save, publish, source) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {
                        _variable.value = value;
                        _variable.set('value', value);
                    } else {
                        return;
                    }
                    if (publish !== false) {
                        thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                            item: _variable,
                            scope: scope,
                            driver: obj,
                            owner: thiz,
                            save: save === true,
                            source: source || types.MESSAGE_SOURCE.BLOX  //for prioritizing
                        });
                    }
                };
            }
            /**
             * Add getVariable
             * @param title
             */
            if (!obj.getVariable) {
                obj.getVariable = function (title) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {
                        return _variable.value;
                    }
                    return '';
                };
            }
            this.inherited(arguments);
        },
        onReloaded: function () {
            this.init();
        },
        getDeviceVariablesAsEventOptions: function () {},
        /**
         * Callback for VariableSwitch::getFields('variable').
         *
         * @param evt {object}
         * @param evt.CI {xide/types/ConfigurableInformation}
         * @param evt.owner {xblox/model/variables/Variable} The variable
         */
        onCreateVariableCI: function (evt) {}
    });
});
;
define('xblox/manager/BlockManager',[
    'dcl/dcl',
    'dojo/has',
    'dojo/Deferred',
    'dojo/promise/all',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xblox/model/ModelBase',
    'xblox/model/Scope',
    'xblox/model/BlockModel',
    'xide/mixins/ReloadMixin',
    'xide/manager/ManagerBase',
    'xblox/data/Store',
    "xdojo/has!xblox-ui?xblox/manager/BlockManagerUI",
    "xide/lodash"
],function (dcl,has,Deferred,all,types,utils,factory,ModelBase,Scope,BlockModel,ReloadMixin,ManagerBase,Store,BlockManagerUI,_){

    var bases = has('host-browser') && has("xblox-ui") ? [BlockManagerUI,ManagerBase,ReloadMixin.dcl] : [ManagerBase,ReloadMixin.dcl];
    var debug = false;

    return dcl(bases,{
        declaredClass:"xblox/manager/BlockManager",
        serviceObject:null,
        loaded:{},
        test:function(){

        },
        /***
         *  scope: storage for all registered variables / commands
         */
        scope:null,
        scopes:null,
        //track original create block function
        _createBlock:null,
        _registerActions:function(){},
        toScope:function(data){
            try {
                data = utils.getJson(data);
            } catch (e) {
                console.error('BlockManager::toScope: failed,err='+e);
                return null;
            }

            if(!data){
                console.error('correct data');
                data = {
                    "blocks": [
                    ],
                    "variables": []
                };
            }
            var scopeId = utils.createUUID();
            var blockInData = data;
            //check structure
            if (_.isArray(data)) {// a flat list of blocks

            } else if (_.isObject(data)) {
                scopeId = data.scopeId || scopeId;
                blockInData = data.blocks || [];
            }
            var scopeUserData = {
                owner:this
            };
            var blockScope = this.getScope(scopeId, scopeUserData, true);
            var allBlocks = blockScope.blocksFromJson(blockInData);
            for (var i = 0; i < allBlocks.length; i++) {
                var obj = allBlocks[i];
                obj._lastRunSettings = {
                    force: false,
                    highlight: true
                };
            }
            blockScope.serviceObject = this.serviceObject;
            return blockScope;
        },
        /**
         *
         * @param files{Object[]} array of items to load in this format
         * @example:
         * @returns {Deferred.promise}
         */
        loadFiles:function(files){

            var thiz=this,
                _createDfd = function(mount,path,force,publish)
                {
                    return thiz.load(mount,path,force);
                },
                _promises = [],
                dfd = new Deferred();

            //build promise chain for 'all'
            for (var i = 0; i < files.length; i++) {
                var item = files[i];
                _promises.push(_createDfd(item.mount, item.path, item.force, item.publish));
            }

            //run and resolve head
            all(_promises).then(function(results){
                debug && console.log('got all block files ',results);
                dfd.resolve(results);
            });

            return dfd.promise;
        },
        load:function(mount,path,forceReload){
            var dfd = new Deferred(),
                thiz = this,
                _mount = utils.replaceAll('/','',mount),
                _path = utils.replaceAll('./','',path);

            var full = _mount + _path;
            full = full.trim();

            if(this.loaded[full] && forceReload===true){
                this.removeScope(this.loaded[full].id);
                this.loaded[full]=null;
            }

            if(forceReload !==true && this.loaded[full]){
                dfd.resolve(this.loaded[full]);
                return dfd.promise;
            }
            var _ready = function(data){
                var scope = thiz.toScope(data);
                if(scope){
                    thiz.loaded[full] = scope;

                    scope.mount = mount;//track file info
                    scope.path = path;
                }
                dfd.resolve(scope);
            };
            this.ctx.getFileManager().getContent(_mount,_path,_ready,false);
            return dfd.promise;
        },
        onBlocksReady:function(scope){
            var blocks = scope.allBlocks();
            for (var i = 0; i < blocks.length; i++) {
                var obj = blocks[i];
                this.setScriptFunctions(obj,scope,this);
            }
            /**
             * pick 'On Load' blocks
             */

            var loadBlocks = scope.getBlocks({
                group:'On Load'
            });
            if(loadBlocks && loadBlocks.length>0){
                for (var i = 0; i < loadBlocks.length; i++) {
                    var loadBlock  = loadBlocks[i];
                    if(loadBlock.onLoad){
                        loadBlock.onLoad();
                    }
                }
            }
        },
        getBlock:function(){

        },
        setScriptFunctions:function(obj,scope,owner){

            var thiz=owner;
            //scope.context = obj;//set the context of the blox scope
            if(!obj.blockScope) {
                obj.blockScope = scope;
            }
            debug && console.log('set script functions ' + scope.id,obj);
            scope.serviceObject = this.serviceObject;
            ///////////////////////////////////////////////////////////////////////////////
            //
            //  Variables
            //
            ///////////////////////////////////////////////////////////////////////////////
            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            if(!obj.setVariable) {
                obj.setVariable = function (title, value, save, publish, source) {
                    var _scope = this.blockScope;
                    var _variable = _scope.getVariable(title);
                    if (_variable) {
                        _variable.value = value;
                        debug && console.log('setting variable '+title + ' to ' + value);
                    } else {
                        debug && console.log('no such variable : ' + title);
                        return;
                    }
                    if (publish !== false) {

                        thiz.publish(types.EVENTS.ON_VARIABLE_CHANGED, {
                            item: _variable,
                            scope: scope,
                            driver: obj,
                            owner: thiz,
                            save: save === true,
                            source: source || types.MESSAGE_SOURCE.BLOX  //for prioritizing
                        });
                    }
                };
            }
            /**
             * Add getVariable
             * @param title
             */
            if(!obj.getVariable) {
                obj.getVariable = function (title) {
                    var _scope = this.blockScope;
                    var _variable = _scope.getVariable(title);
                    if (_variable) {
                        return _variable.value;
                    }
                    return '';
                };
            }

        },
        hasScope:function(id) {
            if (!this.scopes) {
                this.scopes = {};
            }
            if (this.scopes[id]) {
                return this.scopes[id];
            }
            return null;
        },
        getScope:function(id,userData,publish){
            if(!this.scopes){
              this.scopes={};
            }
            if(!this.scopes[id]){
                this.scopes[id]=this.createScope({
                    id:id,
                    ctx:this.ctx
                });
                this.scopes[id].userData=userData;
                if(publish!==false){
                    try{
                        factory.publish(types.EVENTS.ON_SCOPE_CREATED,this.scopes[id]);
                    }catch(e){
                        console.error('bad, scope creation failed ' +e ,e);
                    }
                }
            }
            return this.scopes[id];
        },
        /**
         *
         * @param id
         * @returns {null}
         */
        removeScope:function(id){
            if(!this.scopes){
                this.scopes={};
            }
            for (var scopeId in this.loaded){
                if(this.loaded[scopeId].id==id){
                    delete this.loaded[scopeId];
                }
            }
            if (this.scopes[id]) {
                this.scopes[id]._destroy();
                delete this.scopes[id];
            }
            return null;
        },
        /**
         *
         * @param mixed
         * @param data
         * @returns {*}
         */
        createScope:function(mixed,data,errorCB){
            data = data || [];
            var blockStore = new Store({
                data: [],
                Model:BlockModel,
                id:utils.createUUID(),
                __events:{

                },
                observedProperties:[
                    "name",
                    "enabled",
                    "value"
                ],
                getLabel:function(item){
                    return item.name;
                },
                labelAttr:'name'
            });
            blockStore.reset();
            blockStore.setData([]);
            var args = {
                owner:this,
                blockStore:blockStore,
                serviceObject:this.serviceObject,
                config:this.config
            };
            utils.mixin(args,mixed);
            try {
                var scope = new Scope(args);
                data && scope.initWithData(data,errorCB);
                scope.init();
            }catch(e){
                logError(e,'error creating scope, data:',mixed);
            }

            return scope;
        },
        onReloaded:function(){
            debug && console.log('on reloaded');
        },
        init:function() {
            this.scope = {
                variables:[],
                blocks: []
            };
            ModelBase.prototype.types=types;
            ModelBase.prototype.factory=factory;
            if(this.onReady){
                this.onReady();
            }
        }
    });
});;
/** @module xblox/data/Store **/
define('xblox/data/Store',[
    "dojo/_base/declare",
    'xide/data/TreeMemory',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'dojo/Deferred'
], function (declare, TreeMemory, ObservableStore, Trackable, Deferred) {
    return declare("xblox.data.Store", [TreeMemory, Trackable, ObservableStore], {
        idProperty: 'id',
        parentField: 'parentId',
        parentProperty: 'parentId',
        filter: function (data) {
            var _res = this.inherited(arguments);
            delete this._state.filter;
            this._state.filter = data;
            return _res;
        },
        getRootItem:function(){
            return {
                canAdd:function(){
                    return true
                },
                id:this.id +'_root',
                group:null,
                name:'root',
                isRoot:true,
                parentId:null
            }
        },
        getChildren: function (object) {
            return this.root.filter({parentId: this.getIdentity(object)});
        },
        _fetchRange: function (kwArgs) {
            var deferred = new Deferred();
            var _res = this.fetchRangeSync(kwArgs);
            var _items;
            if (this._state.filter) {
                //the parent query
                if (this._state.filter['parentId']) {
                    var _item = this.getSync(this._state.filter.parentId);
                    if (_item) {
                        this.reset();
                        _items = _item.items;
                        if (_item.getChildren) {
                            _items = _item.getChildren();
                        }
                        deferred.resolve(_items);
                        _res = _items;
                    }
                }

                //the group query
                if (this._state && this._state.filter && this._state.filter['group']) {
                    _items = this.getSync(this._state.filter.parent);
                    if (_item) {
                        this.reset();
                        _res = _item.items;
                    }
                }
            }
            deferred.resolve(_res);
            return deferred;
        },
        mayHaveChildren: function (parent) {
            if (parent.mayHaveChildren) {
                return parent.mayHaveChildren(parent);
            }
            return parent.items != null && parent.items.length > 0;
        }
    });
});;
define('xblox/model/BlockModel',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/data/Model',
    'xide/data/Source'
], function(dcl,declare,Model,Source){
    /**
     * Contains provides implements functions to deal with sub blocks.
     */
    return declare('xblox.model.BlockModel',[Model,Source],{
        declaredClass:'xblox.model.BlockModel',
        icon:'fa-play',
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },
        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },
        getBlockIcon:function(){
            return '<span class="' +this.icon + '"></span>';
        }
    });
});;
/** @module xide/data/Source **/
define('xide/data/Source',[
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/utils',
    'xide/lodash'
], function (dcl, declare, utils, lodash) {

    var _debug = true;
    /**
     * @class module:xide/data/Source
     * @augments module:xide/data/Model
     */
    var Implementation = {
        /**
         * @type {Array<module:xide/data/Reference>|null}
         */
        _references: null,
        /**
         * @type {module:xide/data/Reference|null}
         */
        _originReference: null,
        /**
         * @type {module:xide/data/_Base|null} The store.
         */
        _store: null,
        onReferenceUpdate: function () {
        },
        onReferenceRemoved: function () {
        },
        onReferenceDelete: function () {
        },
        updateReference: function () {
        },
        destroy: function () {
            this._references = null;
        },
        getReferences: function () {
            return this._references ? utils.pluck(this._references, 'item') : [];
        },
        hasReference: function (source) {
            return lodash.find(this._references, {item: source});
        },
        addReference: function (reference, settings, addSource) {
            !this._references && (this._references = []);
            if (this.hasReference(reference)) {
                _debug && console.warn('already have reference');
                return;
            }
            this._references.push({
                item: reference,
                settings: settings
            });
            if (settings && settings.onDelete) {
                if (reference._store) {
                    reference._store.on('delete', function (evt) {
                        if (evt.target == reference) {
                            this._store.removeSync(this[this._store.idProperty]);
                            this._references.remove(evt.target);
                        }
                    }.bind(this));
                }
            }
            if (addSource) {
                if (reference.addSource) {
                    reference.addSource(this, settings);
                }
            }
        },
        removeReference: function (Reference) {
            this._references && lodash.each(this._references, function (ref) {
                if (ref && ref.item == Reference) {
                    this._references && this._references.remove(ref);
                    return true;
                }
            }, this);
        },
        updateReferences: function (args) {
            var property = args.property,
                value = args.value;

            if (!this._references) {
                this._references = [];
            }
            for (var i = 0; i < this._references.length; i++) {
                var link = this._references[i],
                    item = link.item,
                    settings = link.settings,
                    store = item._store;

                if (this._originReference == item) {
                    continue;
                }
                if (args.property && settings.properties && settings.properties[args.property]) {
                    if (store) {
                        store.silent(true);
                    }
                    try {
                        if (item.onSourceChanged) {
                            item.onSourceChanged(property, value, args.type);
                        } else {
                            item.set(property, value);
                        }

                    } catch (e) {
                        _debug && console.error('error updating reference! ' + e, e);
                    }
                    if (store) {
                        store.silent(false);
                        store.emit('update', {target: item});
                    }
                }
            }
        },
        constructor: function (properties) {
            this._references = [];
            utils.mixin(this, properties);
        },
        onItemChanged: function (args) {
            this.updateReferences(args);
        }
    };
    //exports for declare & dcl
    var Module = declare('xgrid.data.Source', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    Module.Implementation = Implementation;
    return Module;
});
;
define('xide/data/Model',[
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/aspect',
    'dojo/when',
    'xide/utils'
], function (dcl,Deferred, aspect, when,utils) {


    function getSchemaProperty(object, key) {
        // this function will retrieve the individual property definition
        // from the schema, for the provided object and key
        var definition = object.schema[key];
        if (definition !== undefined && !(definition instanceof Property)) {
            definition = new Property(definition);
            definition._parent = object;
        }
        if (definition) {
            definition.name = key;
        }
        return definition;
    }

    function validate(object, key) {
        /*
         // this performs validation, delegating validation, and coercion
         // handling to the property definitions objects.
         var hasOwnPropertyInstance,
         property = object.hasOwnProperty('_properties') && object._properties[key];

         hasOwnPropertyInstance = property;

         if (!property) {
         // or, if we don't our own property object, we inherit from the schema
         property = getSchemaProperty(object, key);
         if (property && property.validate) {
         property = lang.delegate(property, {
         _parent: object,
         key: key
         });
         }
         }

         if (property && property.validate) {
         return when(property.validate(), function (isValid) {
         if (!isValid) {
         // errors, so don't perform set
         if (!hasOwnPropertyInstance) {
         // but we do need to store our property
         // instance if we don't have our own
         (object.hasOwnProperty('_properties') ?
         object._properties :
         object._properties = new Hidden())[key] = property;
         }
         }
         return isValid;
         });
         }
         */
        return true;
    }

    function whenEach(iterator) {
        // this is responsible for collecting values from an iterator,
        // and waiting for the results if promises are returned, returning
        // a new promise represents the eventual completion of all the promises
        // this will consistently preserve a sync (non-promise) return value if all
        // sync values are provided
        var deferred;
        var remaining = 1;
        // start the iterator
        iterator(function (value, callback, key) {
            if (value && value.then) {
                // it is a promise, have to wait for it
                remaining++;
                if (!deferred) {
                    // make sure we have a deferred
                    deferred = new Deferred();
                }
                value.then(function (value) {
                    // result received, call callback, and then indicate another item is done
                    doneItem(callback(value, key));
                }).then(null, deferred.reject);
            } else {
                // not a promise, just a direct sync callback
                callback(value, key);
            }
        });
        if (deferred) {
            // if we have a deferred, decrement one more time
            doneItem();
            return deferred.promise;
        }
        function doneItem() {
            // called for each promise as it is completed
            remaining--;
            if (!remaining) {
                // all done
                deferred.resolve();
            }
        }
    }
    var slice = [].slice;
    var Model = dcl(null,{
        declaredClass:'xide/data/Model',
        //	summary:
        //		A base class for modelled data objects.

        //	schema: Object | dstore/Property
        //		A hash map where the key corresponds to a property definition.
        //		This can be a string corresponding to a JavaScript
        //		primitive values (string, number, boolean), a constructor, a
        //		null (to allow any type), or a Property object with more advanced
        //		definitions.
        schema: {},

        //	additionalProperties: boolean
        //		This indicates whether properties are allowed that are not
        //		defined in the schema.
        additionalProperties: true,

        //	_scenario: string
        //		The scenario that is used to determine which validators should
        //		apply to this model. There are two standard values for _scenario,
        //		"insert" and "update", but it can be set to any arbitrary value
        //		for more complex validation scenarios.
        _scenario: 'update',

        constructor: function (options) {
            this.init(options);
        },

        refresh:function(silent,property){
            var _store = this._store;
            _store && _store.refreshItem(this,silent,property);
        },
        getStore:function(){
            return this._store;
        },
        getParent:function(){
            return this._store.getSync(this[this._store['parentProperty']]);
        },
        init: function (values) {
            // if we are being constructed, we default to the insert scenario
            this._scenario = 'insert';
            // copy in the default values
            values = this._setValues(values);
            // set any defaults
            for (var key in this.schema) {
                var definition = this.schema[key];
                if (definition && typeof definition === 'object' && 'default' in definition &&
                    !values.hasOwnProperty(key)) {
                    var defaultValue = definition['default'];
                    values[key] = typeof defaultValue === 'function' ? defaultValue.call(this) : defaultValue;
                }
            }
        },

        _setValues: function (values) {
            return utils.mixin(this, values);
        },

        _getValues: function () {
            return this._values || this;
        },

        save: function (/*Object*/ options) {
            //	summary:
            //		Saves this object, calling put or add on the attached store.
            //	options.skipValidation:
            //		Normally, validation is performed to ensure that the object
            //		is not invalid before being stored. Set `skipValidation` to
            //		true to skip it.
            //	returns: any

            var object = this;
            return when((options && options.skipValidation) ? true : this.validate(), function (isValid) {
                if (!isValid) {
                    throw object.createValidationError(object.errors);
                }
                var scenario = object._scenario;
                // suppress any non-date from serialization output
                object.prepareForSerialization();
                return object._store && when(object._store[scenario === 'insert' ? 'add' : 'put'](object),
                        function (returned) {
                            // receive any updates from the server
                            object.set(returned);
                            object._scenario = 'update';
                            return object;
                        });
            });
        },

        remove: function () {
            var store = this._store;
            return store.remove(store.getIdentity(this));
        },

        prepareForSerialization: function () {
            //	summary:
            //		This method is responsible for cleaing up any properties on the instance
            //		object to ensure it can easily be serialized (by JSON.stringify at least)
            this._scenario = undefined;
            if (this._inherited) {
                this._inherited.toJSON = toJSONHidden;
            }
        },

        createValidationError: function (errors) {
            //	summary:
            //		This is called when a save is attempted and a validation error was found.
            //		This can be overriden with locale-specific messages
            //	errors:
            //		Errors that were found in validation
            return new Error('Validation error');
        },

        property: function (/*String...*/ key, nextKey) {
            //	summary:
            //		Gets a new reactive property object, representing the present and future states
            //		of the provided property. The returned property object gives access to methods for changing,
            //		retrieving, and observing the property value, any validation errors, and property metadata.
            //	key: String...
            //		The name of the property to retrieve. Multiple key arguments can be provided
            //		nested property access.

            // create the properties object, if it doesn't exist yet
            var properties = this.hasOwnProperty('_properties') ? this._properties :
                (this._properties = new Hidden());
            var property = properties[key];
            // if it doesn't exist, create one, delegated from the schema's property definition
            // (this gives an property instance, owning the current property value and listeners,
            // while inheriting metadata from the schema's property definitions)
            if (!property) {
                property = getSchemaProperty(this, key);
                // delegate, or just create a new instance if no schema definition exists
                property = properties[key] = property ? utils.delegate(property) : new Property();
                property.name = key;
                // give it the correct initial value
                property._parent = this;
            }
            if (nextKey) {
                // go to the next property, if there are multiple
                return property.property.apply(property, slice.call(arguments, 1));
            }
            return property;
        },

        get: function (/*string*/ key) {
            // TODO: add listener parameter back in
            //	summary:
            //		Standard get() function to retrieve the current value
            //		of a property, augmented with the ability to listen
            //		for future changes

            var property, definition = this.schema[key];
            // now we need to see if there is a custom get involved, or if we can just
            // shortcut to retrieving the property value
            definition = property || this.schema[key];
            if (definition && definition.valueOf &&
                (definition.valueOf !== simplePropertyValueOf || definition.hasCustomGet)) {
                // we have custom get functionality, need to create at least a temporary property
                // instance
                property = property || (this.hasOwnProperty('_properties') && this._properties[key]);
                if (!property) {
                    // no property instance, so we create a temporary one
                    property = utils.delegate(getSchemaProperty(this, key), {
                        name: key,
                        _parent: this
                    });
                }
                // let the property instance handle retrieving the value
                return property.valueOf();
            }
            // default action of just retrieving the property value
            return this._getValues()[key];
        },

        set: function (/*string*/ key, /*any?*/ value) {
            //	summary:
            //		Only allows setting keys that are defined in the schema,
            //		and remove any error conditions for the given key when
            //		its value is set.
            if (typeof key === 'object') {
                startOperation();
                try {
                    for (var i in key) {
                        value = key[i];
                        if (key.hasOwnProperty(i) && !(value && value.toJSON === toJSONHidden)) {
                            this.set(i, value);
                        }
                    }
                } finally {
                    endOperation();
                }
                return;
            }
            var definition = this.schema[key];
            if (!definition && !this.additionalProperties) {
                // TODO: Shouldn't this throw an error instead of just giving a warning?
                return console.warn('Schema does not contain a definition for', key);
            }
            var property = this.hasOwnProperty('_properties') && this._properties[key];
            if (!property &&
                // we need a real property instance if it is an object or if we have a custom put method
                ((value && typeof value === 'object') ||
                (definition && definition.put !== simplePropertyPut))) {
                property = this.property(key);
            }
            if (property) {
                // if the property instance exists, use this to do the set
                property.put(value);
            } else {
                if (definition && definition.coerce) {
                    // if a schema definition exists, and has a coerce method,
                    // we can use without creating a new instance
                    value = definition.coerce(value);
                }
                // we can shortcut right to just setting the object property
                this._getValues()[key] = value;
                // check to see if we should do validation
                if (definition && definition.validateOnSet !== false) {
                    validate(this, key);
                }
            }

            return value;
        },

        observe: function (/*string*/ key, /*function*/ listener, /*object*/ options) {
            //	summary:
            //		Registers a listener for any changes in the specified property
            //	key:
            //		The name of the property to listen to
            //	listener:
            //		Function to be called for each change
            //	options.onlyFutureUpdates
            //		If this is true, it won't call the listener for the current value,
            //		just future updates. If this is true, it also won't return
            //		a new reactive object
            return this.property(key).observe(listener, options);
        },

        validate: function (/*string[]?*/ fields) {
            //	summary:
            //		Validates the current object.
            //	fields:
            //		If provided, only the fields listed in the array will be
            //		validated.
            //	returns: boolean | dojo/promise/Promise
            //		A boolean or a promise that resolves to a boolean indicating whether
            //		or not the model is in a valid state.

            /*
             var object = this,
             isValid = true,
             errors = [],
             fieldMap;

             if (fields) {
             fieldMap = {};
             for (var i = 0; i < fields.length; i++) {
             fieldMap[i] = true;
             }
             }
             return when(whenEach(function (whenItem) {
             // iterate through the keys in the schema.
             // note that we will always validate every property, regardless of when it fails,
             // and we will execute all the validators immediately (async validators will
             // run in parallel)
             for (var key in object.schema) {
             // check to see if we are allowed to validate this key
             if (!fieldMap || (fieldMap.hasOwnProperty(key))) {
             // run validation
             whenItem(validate(object, key), function (isValid, key) {
             if (!isValid) {
             notValid(key);
             }
             }, key);
             }
             }
             }), function () {
             object.set('errors', isValid ? undefined : errors);
             // it wasn't async, so we just return the synchronous result
             return isValid;
             });
             function notValid(key) {
             // found an error, mark valid state and record the errors
             isValid = false;
             errors.push.apply(errors, object.property(key).errors);
             }
             */
        },

        isValid: function () {
            //	summary:
            //		Returns whether or not there are currently any errors on
            //		this model due to validation failures. Note that this does
            //		not run validation but merely returns the result of any
            //		prior validation.
            //	returns: boolean

            var isValid = true,
                key;

            for (key in this.schema) {
                var property = this.hasOwnProperty('_properties') && this._properties[key];
                if (property && property.errors && property.errors.length) {
                    isValid = false;
                }
            }
            return isValid;
        }
    });

    //xhack: make dstore happy
    Model.createSubclass=function(mixins, props){
        var sub = dcl([this].concat(mixins), props || {});
        sub.extend = function(props){
            utils.mixin(this.prototype,props);
            return this;
        }
        return sub;
    }
    // define the start and end markers of an operation, so we can
    // fire notifications at the end of the operation, by default
    function startOperation() {
        setCallDepth++;
    }
    function endOperation() {
        // if we are ending this operation, start executing the queue
        if (setCallDepth < 2 && onEnd) {
            onEnd();
            onEnd = null;
        }
        setCallDepth--;
    }
    var setCallDepth = 0;
    var callbackQueue;
    var onEnd;
    // the default nextTurn executes at the end of the current operation
    // The intent with this function is that it could easily be replaced
    // with something like setImmediate, setTimeout, or nextTick to provide
    // next turn handling
    (Model.nextTurn = function (callback) {
        // set the callback for the end of the current operation
        onEnd = callback;
    }).atEnd = true;

    var Reactive = dcl(Model, {
        //	summary:
        //		A reactive object is a data model that can contain a value,
        //		and notify listeners of changes to that value, in the future.
        observe: function (/*function*/ listener, /*object*/ options) {
            //	summary:
            //		Registers a listener for any changes in the current value
            //	listener:
            //		Function to be called for each change
            //	options.onlyFutureUpdates
            //		If this is true, it won't call the listener for the current value,
            //		just future updates. If this is true, it also won't return
            //		a new reactive object

            var reactive;
            if (typeof listener === 'string') {
                // a property key was provided, use the Model's method
                console.error('fff');
                return this.inherited(arguments);
            }
            if (!options || !options.onlyFutureUpdates) {
                // create a new reactive to contain the results of the execution
                // of the provided function
                reactive = new Reactive();
                if (this._has()) {
                    // we need to notify of the value of the present (as well as future)
                    reactive.value = listener(this.valueOf());
                }
            }
            // add to the listeners
            var handle = this._addListener(function (value) {
                var result = listener(value);
                if (reactive) {
                    // TODO: once we have a real notification API again, call that, instead
                    // of requesting a change
                    reactive.put(result);
                }
            });
            if (reactive) {
                reactive.remove = handle.remove;
                return reactive;
            } else {
                return handle;
            }
        },

        //	validateOnSet: boolean
        //		Indicates whether or not to perform validation when properties
        //		are modified.
        //		This can provided immediate feedback and on the success
        //		or failure of a property modification. And Invalid property
        //		values will be rejected. However, if you are
        //		using asynchronous validation, invalid property values will still
        //		be set.
        validateOnSet: false,

        //	validators: Array
        //		An array of additional validators to apply to this property
        validators: null,

        _addListener: function (listener) {
            // add a listener for the property change event
            return aspect.after(this, 'onchange', listener, true);
        },

        valueOf: function () {
            return this._get();
        },

        _get: function () {
            return this.value;
        },

        _has: function () {
            return this.hasOwnProperty('value');
        },
        setValue: function (value) {
            //	summary:
            //		This method is responsible for storing the value. This can
            //		be overriden to define a custom setter
            //	value: any
            //		The value to be stored
            //	parent: Object
            //		The parent object of this propery
            this.value = value;
        },

        put: function (/*any*/ value) {
            //	summary:
            //		Indicates a new value for this reactive object

            // notify all the listeners of this object, that the value has changed
            var oldValue = this._get();
            value = this.coerce(value);
            if (this.errors) {
                // clear any errors
                this.set('errors', undefined);
            }
            var property = this;
            // call the setter and wait for it
            startOperation();
            return when(this.setValue(value, this._parent), function (result) {
                if (result !== undefined) {
                    // allow the setter to change the value
                    value = result;
                }
                // notify listeners
                if (property.onchange) {
                    // queue the callback
                    property._queueChange(property.onchange, oldValue);
                }
                // if this was set to an object (or was an object), we need to notify.
                // update all the sub-property objects, so they can possibly notify their
                // listeners
                var key,
                    hasOldObject = oldValue && typeof oldValue === 'object' && !(oldValue instanceof Array),
                    hasNewObject = value && typeof value === 'object' && !(value instanceof Array);
                if (hasOldObject || hasNewObject) {
                    // we will iterate through the properties recording the changes
                    var changes = {};
                    if (hasOldObject) {
                        oldValue = oldValue._getValues ? oldValue._getValues() : oldValue;
                        for (key in oldValue) {
                            changes[key] = {old: oldValue[key]};
                        }
                    }
                    if (hasNewObject) {
                        value = value._getValues ? value._getValues() : value;
                        for (key in value) {
                            (changes[key] = changes[key] || {}).value = value[key];
                        }
                    }
                    property._values = hasNewObject && value;
                    for (key in changes) {
                        // now for each change, we can notify the property object
                        var change = changes[key];
                        var subProperty = property._properties && property._properties[key];
                        if (subProperty && subProperty.onchange) {
                            // queue the callback
                            subProperty._queueChange(subProperty.onchange, change.old);
                        }
                    }
                }
                if (property.validateOnSet) {
                    property.validate();
                }
                endOperation();
            });
        },

        coerce: function (value) {
            //	summary:
            //		Given an input value, this method is responsible
            //		for converting it to the appropriate type for storing on the object.

            var type = this.type;
            if (type) {
                if (type === 'string') {
                    value = '' + value;
                }
                else if (type === 'number') {
                    value = +value;
                }
                else if (type === 'boolean') {
                    // value && value.length check is because dijit/_FormMixin
                    // returns an array for checkboxes; an array coerces to true,
                    // but an empty array should be set as false
                    value = (value === 'false' || value === '0' || value instanceof Array && !value.length) ?
                        false : !!value;
                }
                else if (typeof type === 'function' && !(value instanceof type)) {
                    /* jshint newcap: false */
                    value = new type(value);
                }
            }
            return value;
        },

        addError: function (error) {
            //	summary:
            //		Add an error to the current list of validation errors
            //	error: String
            //		Error to add
            this.set('errors', (this.errors || []).concat([error]));
        },

        checkForErrors: function (value) {
            //	summary:
            //		This method can be implemented to simplify validation.
            //		This is called with the value, and this method can return
            //		an array of any errors that were found. It is recommended
            //		that you call this.inherited(arguments) to permit any
            //		other validators to perform validation
            //	value:
            //		This is the value to validate.
            var errors = [];
            if (this.type && !(typeof this.type === 'function' ? (value instanceof this.type) :
                    (this.type === typeof value))) {
                errors.push(value + ' is not a ' + this.type);
            }

            if (this.required && !(value != null && value !== '')) {
                errors.push('required, and it was not present');
            }
            return errors;
        },

        validate: function () {
            //	summary:
            //		This method is responsible for validating this particular
            //		property instance.
            var property = this;
            var model = this._parent;
            var validators = this.validators;
            var value = this.valueOf();
            var totalErrors = [];

            return when(whenEach(function (whenItem) {
                // iterator through any validators (if we have any)
                if (validators) {
                    for (var i = 0; i < validators.length; i++) {
                        whenItem(validators[i].checkForErrors(value, property, model), addErrors);
                    }
                }
                // check our own validation
                whenItem(property.checkForErrors(value, property, model), addErrors);
                function addErrors(errors) {
                    if (errors) {
                        // if we have an array of errors, add it to the total of all errors
                        totalErrors.push.apply(totalErrors, errors);
                    }
                }
            }), function () {
                if (totalErrors.length) {
                    // errors exist
                    property.set('errors', totalErrors);
                    return false;
                }
                // no errors, valid value, if there were errors before, remove them
                if(property.get('errors') !== undefined){
                    property.set('errors', undefined);
                }
                return true;
            });
        },
        _queueChange: function (callback, oldValue) {
            // queue up a notification callback
            if (!callback._queued) {
                // make sure we only queue up once before it is called by flagging it
                callback._queued = true;
                var reactive = this;
                // define a function for when it is called that will clear the flag
                // and provide the correct args
                var dispatch = function () {
                    callback._queued = false;
                    callback.call(reactive, reactive._get(), oldValue);
                };

                if (callbackQueue) {
                    // we already have a waiting queue of callbacks, add our callback
                    callbackQueue.push(dispatch);
                }
                if (!callbackQueue) {
                    // no waiting queue, check to see if we have a custom nextTurn
                    // or we are in an operation
                    if (!Model.nextTurn.atEnd || setCallDepth > 0) {
                        // create the queue (starting with this callback)
                        callbackQueue = [dispatch];
                        // define the callback executor for the next turn
                        Model.nextTurn(function () {
                            // pull out all the callbacks
                            for (var i = 0; i < callbackQueue.length; i++) {
                                // call each one
                                callbackQueue[i]();
                            }
                            // clear it
                            callbackQueue = null;
                        });
                    } else {
                        // no set call depth, so just immediately execute
                        dispatch();
                    }
                }
            }
        },
        toJSON: function () {
            return this._values || this;
        }
    });
    // a function that returns a function, to stop JSON serialization of an
    // object
    function toJSONHidden() {
        return toJSONHidden;
    }
    // An object that will be hidden from JSON serialization
    var Hidden = function () {};
    Hidden.prototype.toJSON = toJSONHidden;
    var Property = Model.Property = dcl(Reactive, {
        //	summary:
        //		A Property represents a time-varying property value on an object,
        //		along with meta-data. One can listen to changes in this value (through
        //		receive), as well as access and monitor metadata, like default values,
        //		validation information, required status, and any validation errors.

        //	value: any
        //		This represents the value of this property, which can be
        //		monitored for changes and validated

        init: function (options) {
            // handle simple definitions
            if (typeof options === 'string' || typeof options === 'function') {
                options = {type: options};
            }
            // and/or mixin any provided properties
            if (options) {
                utils.mixin(this, options);
            }
        },

        _get: function () {
            return this._parent._getValues()[this.name];
        },
        _has: function () {
            return this.name in this._parent._getValues();
        },
        setValue: function (value, parent) {
            parent._getValues()[this.name] = value;
        }
    });
    var simplePropertyValueOf = Property.prototype.valueOf;
    var simplePropertyPut = Property.prototype.put;
    return Model;
});;
/** @module xblox/model/Scope **/
define('xblox/model/Scope',[
    'dcl/dcl',
    './ModelBase',
    './Expression',
    'xide/factory',
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'dojo/_base/lang',
    'dojo/has',
    'xide/encoding/MD5',
    'xcf/model/Variable',
    'xdojo/has!host-node?nxapp/utils/_console'
], function (dcl, ModelBase, Expression, factory, utils, types, EventedMixin, lang, has, MD5, Variable, _console) {
    var console = typeof window !== 'undefined' ? window.console : typeof global !== 'undefined' ? global.console : _console
    if (_console) {
        console = _console
    }
    /*
     var console = typeof window !== 'undefined' ? window.console : console;
     if(tracer && tracer.error && console && console.error){
     console = _console;
     }
     */

    function mergeNewModule(block, source) {
        for (var i in source) {
            var o = source[i]
            if (o && _.isFunction(o) /* && lang.isFunction(target[i]) */) {
                block[i] = o// swap
            }
        }
    }

    var debug = false
    var isIDE = has('xcf-ui')
    /**
     * The scope acts as a real scope as usual. All registered variables and blocks are excecuted in this scope only.
     * @class module:xblox/model/Scope
     */
    var Module = dcl([ModelBase, EventedMixin.dcl], {
        declaredClass: 'xblox.model.Scope',
        variableStore: null,
        serviceObject: null,
        context: null,
        blockStore: null,
        /**
         *  @type {module:xblox/model/Expression}
         */
        expressionModel: null,
        start: function () {
            if (this.__didStartBlocks === true) {
                console.error('already started blocks')
                return
            }
            this.__didStartBlocks = true
            var responseVariable = this.getVariable('value')
            if (!responseVariable) {
                responseVariable = new Variable({
                    id: utils.createUUID(),
                    name: 'value',
                    value: '',
                    scope: this,
                    type: 13,
                    group: 'processVariables',
                    gui: false,
                    cmd: false
                })

                this.blockStore.putSync(responseVariable)
            }
            var autoBlocks = []
            var initBlocks = this.getBlocks({
                group: types.COMMAND_TYPES.INIT_COMMAND
            })

            var self = this;
            try {
                _.each(initBlocks, function (block) {
                    if (block.enabled !== false && block.__started !== true) {
                        block.solve(self);
                        block.__started = true
                    }
                }, this);
            } catch (e) {
                console.error('starting init blocks failed', e)
                logError(e, this)
            }
            autoBlocks = autoBlocks.concat(this.getBlocks({
                group: types.COMMAND_TYPES.BASIC_COMMAND
            }))

            // console.error('auto blocks : '+autoBlocks.length + ' ' + this.id);
            for (var i = 0; i < autoBlocks.length; i++) {
                var block = autoBlocks[i]
                if (block.enabled && block.start && block.startup && block.__started !== true) {
                    block.start()
                    block.__started = true
                }
            }
        },
        /**
         *
         * @returns {module:xblox/model/Expression}
         */
        getExpressionModel: function () {
            if (!this.expressionModel) {
                this.expressionModel = new Expression()
            }
            return this.expressionModel
        },
        /**
         *
         * @param block
         * @param url
         * @returns {*}
         */
        toFriendlyName: function (block, url) {
            if (!url || !block) {
                return null
            }
            var blockScope = this,
                ctx = this.ctx,
                driver = this.driver,
                deviceManager = ctx.getDeviceManager(),
                driverManager = ctx.getDriverManager()

            if (url.indexOf('://') == -1) {
                var _block = blockScope.getBlockById(url)
                if (_block) {
                    return _block.name
                }
                return url
            }
            var parts = utils.parse_url(url)// strip scheme

            parts = utils.urlArgs(parts.host)// go on with query string
            var _device = deviceManager.getItemById(parts.device.value)
            if (_device) {
                var info = deviceManager.toDeviceControlInfo(_device)
                driver = driverManager.getDriverById(info.driverId)
                var driverInstance = _device.driverInstance
                if (driverInstance || driver) {
                    blockScope = driver.blockScope ? driver.blockScope : driverInstance ? driverInstance.blockScope : blockScope
                    block = blockScope.getStore().getSync(parts.block.value)
                    if (block) {
                        return info.title + '/' + block.name
                    } else if (driverInstance && driverInstance.blockScope) {
                        block = driverInstance.blockScope.getBlock(parts.block.value)
                        if (block) {
                            return info.title + '/' + block.name
                        }
                    }
                }
            }
            return url
        },
        getContext: function () {
            return this.instance
        },
        toString: function () {
            var all = {
                blocks: null,
                variables: null
            }
            var blocks = this.blocksToJson()
            try {
                utils.fromJson(JSON.stringify(blocks))
            } catch (e) {
                debug && console.error('scope::toString : invalid data in scope')
                return
            }
            all.blocks = blocks
            return JSON.stringify(all, null, 2)
        },
        /**
         * @param data
         * @param errorCB {function}
         */
        initWithData: function (data, errorCB) {
            data && this.blocksFromJson(data, null, errorCB)
            this.clearCache()
        },
        // ///////////////////////////////////////////////////////
        //
        //  Service uplink related
        //
        // ///////////////////////////////////////////////////////
        /** @member {Object} */
        getService: function () {
            return this.serviceObject
        },
        // ///////////////////////////////////////////////////////
        //
        //  Store related
        //
        // ///////////////////////////////////////////////////////
        getStore: function () {
            return this.blockStore
        },
        reset: function () {
            this.getExpressionModel().reset()
        },
        /**
         *
         */
        empty: function () {
            this.clearCache()
            var store = this.blockStore
            var allBlocks = this.getBlocks()
            store.silent(true)
            _.each(allBlocks, function (block) {
                if (block) {
                    store.removeSync(block.id)
                } else {
                    debug && console.error('have no block')
                }
            })
            store.setData([])
            store.silent(false)
        },
        fromScope: function (source) {
            var store = this.blockStore
            store.silent(true)
            this.empty()
            var _t = source.blocksToJson()
            this.blocksFromJson(_t)
            store.silent(false)
        },
        /**
         *
         */
        clearCache: function () {
            this.getExpressionModel().reset()
        },
        /**
         * @returns {dojo/store/Memory}
         */
        getVariableStore: function () {
            return this.blockStore
        },
        getBlockStore: function () {
            return this.blockStore
        },
        getVariables: function (query) {
            if (!this.blockStore) {
                return []
            }
            var all = this.blockStore.data
            var out = []
            if (query && query.group === 'processVariables') {
                for (var i = 0; i < all.length; i++) {
                    if (all[i].group === 'processVariables') {
                        out.push(all[i])
                    }
                }
                return out
            }
            // query = query || {id:/\S+/};//all variables
            if (!query) {
                for (var i = 0; i < all.length; i++) {
                    var block = all[i],
                        cls = block.declaredClass
                    if (cls == 'xblox.model.variables.Variable' || cls == 'xcf.model.Variable') {
                        out.push(block)
                    }
                }
                return out
            }
            return this.blockStore.query(query)
        },
        loopBlock: function (block, settings) {
            if (block._destroyed == true) {
                console.error('block destroyed')
            }
            var interval = block.getInterval ? block.getInterval() : 0
            if (block && interval > 0 && block.enabled && block._destroyed !== true) {
                var thiz = this
                if (block._loop) {
                    clearInterval(block._loop)
                }
                block._loop = setInterval(function () {
                    if (!block.enabled || block._destroyed) {
                        clearInterval(block._loop)
                        block._loop = null
                        return
                    }
                    block.solve(thiz, settings || block._lastSettings)
                }, interval)
            }
        },
        getEventsAsOptions: function (selected) {
            var result = []
            for (var e in types.EVENTS) {
                var label = types.EVENTS[e]

                var item = {
                    label: label,
                    value: types.EVENTS[e]
                }
                result.push(item)
            }
            result = result.concat([{label: 'onclick', value: 'onclick'},
                {label: 'ondblclick', value: 'ondblclick'},
                {label: 'onmousedown', value: 'onmousedown'},
                {label: 'onmouseup', value: 'onmouseup'},
                {label: 'onmouseover', value: 'onmouseover'},
                {label: 'onmousemove', value: 'onmousemove'},
                {label: 'onmouseout', value: 'onmouseout'},
                {label: 'onkeypress', value: 'onkeypress'},
                {label: 'onkeydown', value: 'onkeydown'},
                {label: 'onkeyup', value: 'onkeyup'},
                {label: 'onfocus', value: 'onfocus'},
                {label: 'onblur', value: 'onblur'},
                {label: 'onchange', value: 'onchange'}])

            // select the event we are listening to
            for (var i = 0; i < result.length; i++) {
                var obj = result[i]
                if (obj.value === selected) {
                    obj.selected = true
                    break;
                }
            }
            return result
        },
        /**
         *
         * @returns {{}}
         */
        getVariablesAsObject: function () {
            var variables = this.getVariables()
            var result = {}
            for (var i = 0; i < variables.length; i++) {
                result[variables[i].title] = variables[i].value
            }
            return result
        },
        getVariablesAsOptions: function () {
            var variables = this.getVariables()
            var result = []
            if (variables) {
                for (var i = 0; i < variables.length; i++) {
                    result.push({
                        label: variables[i].label,
                        value: variables[i].variable
                    })
                }
            }
            return result
        },
        getCommandsAsOptions: function (labelField) {
            var items = this.getBlocks({
                declaredClass: 'xcf.model.Command'
            })
            var result = []
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    var item = {}
                    item[labelField || 'label'] = items[i].name
                    item['value'] = items[i].name
                    result.push(item)
                }
            }
            return result
        },
        _cached: null,
        getBlocks: function (query, allowCache) {
            if (!isIDE && allowCache !== false) {
                if (!this._cached) {
                    this._cached = {}
                }
                if (query) {
                    var hash = MD5(JSON.stringify(query), 1)
                    var cached = this._cached[hash]
                    if (cached) {
                        return cached
                    }
                }
            }
            // no store,
            if (!this.blockStore) {
                return []
            }
            query = query || {id: /\S+/}// all blocks
            var result = _.isEmpty(query) ? this.blockStore.data : this.blockStore.query(query, null, true);
            if (!isIDE && allowCache !== false) {
                var hash = MD5(JSON.stringify(query), 1)
                this._cached[hash] = result
            }
            return result
        },
        /***
         * Register a variable into the scope
         *
         * The variable title is unique within the scope
         *
         * @param variable  =>  xblox.model.Variable
         */
        registerVariable: function (variable) {
            this.variables[variable.title] = variable
            if (this.blockStore) {
                this.blockStore.putSync(variable)
            }
        },
        /***
         * Returns a variable from the scope
         *
         * @param title => variable title
         * @return variable
         */
        getVariable: function (title) {
            var _variables = this.getVariables()
            for (var i = 0; i < _variables.length; i++) {
                var obj = _variables[i]
                if (obj.name === title) {
                    return obj
                }
            }
            return null
        },
        /***
         * Returns a variable from the scope
         *
         * @param title => variable title
         * @return variable
         */
        getVariableById: function (id) {
            if (!id) {
                return null
            }
            var parts = id.split('/')
            var scope = this
            if (parts.length == 2) {
                var owner = scope.owner
                if (owner && owner.hasScope) {
                    if (owner.hasScope(parts[0])) {
                        scope = owner.getScope(parts[0])
                    } else {
                        console.error('have scope id but cant resolve it', this)
                    }
                }
                id = parts[1]
            }
            var _var = scope.blockStore.getSync(id)
            if (_var) {
                return _var
            }
            return null
        },
        /***
         * Register a block into the scope
         *
         * The block name is unique within the scope
         *
         * @param block   =>    xblox.model.Block
         */
        registerBlock: function (block, publish) {
            var store = this.blockStore
            if (store) {
                var added = store.getSync(block.id)
                if (added) {
                    debug && console.warn('block already in store! ' + block.id, block)
                    return added
                }
                var result = null
                // custom add block to store function
                if (block.addToStore) {
                    result = block.addToStore(store)
                } else {
                    result = store.putSync(block, publish)
                }
                return result
            }
        },
        /***
         * Return all blocks
         *
         * @returns {xblox.model.Block[]}
         */
        allBlocks: function (query, allowCache) {
            return this.getBlocks({}, allowCache)
        },
        /**
         * Returns whether there is any block belongs to a given group
         * @param group {String}
         * @returns {boolean}
         */
        hasGroup: function (group) {
            var all = this.allGroups({}, false)
            for (var i = 0; i < all.length; i++) {
                var obj = all[i]
                if (obj === group) {
                    return true
                }
            }
            return false
        },
        /**
         * Return all block groups
         * @returns {String[]}
         */
        allGroups: function () {
            var result = []
            var all = this.allBlocks({}, false)
            var _has = function (what) {
                for (var i = 0; i < result.length; i++) {
                    if (result[i] === what) {
                        return true
                    }
                }
                return false
            }
            for (var i = 0; i < all.length; i++) {
                var obj = all[i]
                if (obj.parentId) {
                    continue;
                }
                if (obj.group) {
                    if (!_has(obj.group)) {
                        result.push(obj.group)
                    }
                } else {
                    if (!_has('No Group')) {
                        result.push('No Group')
                    }
                }
            }
            return result
        },
        /**
         * Serializes all variables
         * @returns {Array}
         */
        variablesToJson: function () {
            var result = []
            var data = this.variableStore ? this.getVariables() : this.variables
            for (var e in data) {
                var variable = data[e]
                if (variable.serializeMe === false) {
                    continue;
                }
                if (variable.keys == null) {
                    continue;
                }
                var varOut = {}
                for (var prop in variable) {
                    // copy all serializables over
                    if (
                        this.isString(variable[prop]) ||
                        this.isNumber(variable[prop]) ||
                        this.isBoolean(variable[prop])
                    ) {
                        varOut[prop] = variable[prop]
                    }
                }

                result.push(varOut)
            }
            return result
        },
        isScript: function (val) {
            return this.isString(val) && (
                    val.indexOf('return') != -1 ||
                    val.indexOf(';') != -1 ||
                    val.indexOf('[') != -1 ||
                    val.indexOf('{') != -1 ||
                    val.indexOf('}') != -1
                )
        },
        /**
         * Serializes all variables
         * @returns {Array}
         */
        variablesToJavascriptEx: function (skipVariable, expression) {
            var result = []
            var data = this.variableStore ? this.getVariables() : this.variables
            for (var i = 0; i < data.length; i++) {
                var _var = data[i]
                if (_var == skipVariable) {
                    continue;
                }
                var _varVal = '' + _var.value

                // optimization
                if (skipVariable && skipVariable.value && skipVariable.value.indexOf(_var.title) == -1) {
                    continue;
                }
                if (expression && expression.indexOf(_var.title) == -1) {
                    continue;
                }

                if (_varVal.length == 0) {
                    continue;
                }
                if (!this.isScript(_varVal) && _varVal.indexOf("'") == -1) {
                    _varVal = "'" + _varVal + "'"
                }
                else if (this.isScript(_varVal)) {
                    _varVal = this.expressionModel.parseVariable(this, _var)
                }
                if (_varVal === "''") {
                    _varVal = "'0'"
                }
                result.push(_varVal)
            }
            return result
        },
        variablesToJavascript: function (skipVariable, expression) {
            var result = ''
            var data = this.variableStore ? this.getVariables() : this.variables || []
            for (var i = 0; i < data.length; i++) {
                var _var = data[i]
                if (_var == skipVariable) {
                    continue;
                }
                var _varVal = '' + _var.value

                // optimization
                if (skipVariable && skipVariable.value && skipVariable.value.indexOf(_var.title) == -1) {
                    continue;
                }
                if (expression && expression.indexOf(_var.title) == -1) {
                    continue;
                }

                if (_varVal.length == 0) {
                    continue;
                }
                if (!this.isScript(_varVal) && _varVal.indexOf("'") == -1) {
                    _varVal = "'" + _varVal + "'"
                }
                else if (this.isScript(_varVal)) {
                    // _varVal = "''";
                    _varVal = this.expressionModel.parseVariable(this, _var)
                }

                if (_varVal === "''") {
                    _varVal = "'0'"
                }
                result += 'var ' + _var.title + ' = ' + _varVal + ';'
                result += '\n'
            }

            return result
        },
        /**
         * Convert from JSON data. Creates all Variables in this scope
         * @param data
         * @returns {Array}
         */
        variablesFromJson: function (data) {
            var result = []
            for (var i = 0; i < data.length; i++) {
                var variable = data[i]
                variable['scope'] = this
                if (!variable.declaredClass) {
                    console.log('   variable has no class ')
                    continue;
                }
                var _class = utils.replaceAll('.', '/', variable.declaredClass)
                var variableClassProto = require(_class)
                if (!variableClassProto) {
                    continue;
                }
                result.push(new variableClassProto(variable))// looks like a leak but the instance is tracked and destroyed in this scope
            }
            return result
        },
        regenerateIDs: function (blocks) {
            var thiz = this
            var updateChildren = function (block) {
                var newId = utils.createUUID()
                var children = thiz.getBlocks({
                    parentId: block.id
                })
                if (children && children.length > 0) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i]
                        child.parentId = newId
                        updateChildren(child)
                    }
                }
                block.id = newId
            }
            for (var i = 0; i < blocks.length; i++) {
                var block = blocks[i]
                updateChildren(block)
            }
        },
        /**
         * Clone blocks
         * @param blocks
         * @returns {module:xblox/model/Block[]}
         */
        cloneBlocks2: function (blocks, forceGroup) {
            var blocksJSON = this.blocksToJson(blocks);
            var tmpScope = this.owner.getScope(utils.createUUID(), null, false);
            var newBlocks = tmpScope.blocksFromJson(blocksJSON, false);
            var store = this.blockStore;
            newBlocks = tmpScope.allBlocks();
            tmpScope.regenerateIDs(newBlocks);
            blocksJSON = tmpScope.blocksToJson(newBlocks);
            if (forceGroup) {
                for (var i = 0; i < blocksJSON.length; i++) {
                    var block = blocksJSON[i];
                    if (block.parentId == null) { // groups are only needed for top level blocks
                        block.group = forceGroup;
                    }
                }
            }
            var result = [];
            newBlocks = this.blocksFromJson(blocksJSON);// add it to our scope
            _.each(newBlocks, function (block) {
                result.push(store.getSync(block.id));
            })
            return result
        },
        /**
         * Clone blocks
         * @param blocks
         */
        cloneBlocks: function (blocks) {
            var blocksJSON = this.blocksToJson(blocks)
            var tmpScope = this.owner.getScope(utils.createUUID(), null, false)
            var newBlocks = tmpScope.blocksFromJson(blocksJSON, false)
            newBlocks = tmpScope.allBlocks()
            for (var i = 0; i < newBlocks.length; i++) {
                var block = newBlocks[i]
                block.id = utils.createUUID()
                block.parentId = null
            }

            this.blocksToJson(newBlocks)
            this.blocksFromJson(newBlocks)// add it us
            return newBlocks
        },
        /**
         *
         * @param block
         * @returns {Object}
         */
        blockToJson: function (block) {
            var blockOut = {
                // this property is used to recreate the child blocks in the JSON -> blocks process
                _containsChildrenIds: []
            }
            for (var prop in block) {
                if (prop == 'ctrArgs') {
                    continue;
                }

                if (typeof block[prop] !== 'function' && !block.serializeField(prop)) {
                    continue;
                }

                // copy all strings over
                if (this.isString(block[prop]) ||
                    this.isNumber(block[prop]) ||
                    this.isBoolean(block[prop])) {
                    blockOut[prop] = block[prop]
                }
                // flatten children to ids. Skip "parent" field
                if (prop != 'parent') {
                    if (this.isBlock(block[prop])) {
                        // if the field is a single block container, store the child block's id
                        blockOut[prop] = block[prop].id

                        // register this field name as children ID container
                        blockOut._containsChildrenIds.push(prop)
                    } else if (this.areBlocks(block[prop])) {
                        // if the field is a multiple blocks container, store all the children blocks' id
                        blockOut[prop] = []

                        for (var i = 0; i < block[prop].length; i++) {
                            blockOut[prop].push(block[prop][i].id)
                        }

                        // register this field name as children IDs container
                        blockOut._containsChildrenIds.push(prop)
                    }
                }
            }

            return blockOut
        },
        /**
         * Serializes all blocks to JSON data.
         * It needs a custom conversation because we're having cyclic
         * object dependencies.
         * @returns {Array}
         */
        blocksToJson: function (data) {
            try {
                var result = []
                data = (data && data.length) ? data : (this.blockStore ? this.blockStore.data : this.blocks)
                for (var b in data) {
                    var block = data[b]
                    if (block.keys == null) {
                        continue;
                    }
                    if (block.serializeMe === false) {
                        continue;
                    }
                    var blockOut = {
                        // this property is used to recreate the child blocks in the JSON -> blocks process
                        _containsChildrenIds: []
                    }

                    for (var prop in block) {
                        if (prop == 'ctrArgs') {
                            continue;
                        }

                        if (typeof block[prop] !== 'function' && !block.serializeField(prop)) {
                            continue;
                        }

                        // copy all strings over
                        if (this.isString(block[prop]) ||
                            this.isNumber(block[prop]) ||
                            this.isBoolean(block[prop])) {
                            blockOut[prop] = block[prop]
                        }

                        if (_.isObject(block[prop]) && block.serializeObject) {
                            if (block.serializeObject(prop) === true) {
                                blockOut[prop] = JSON.stringify(block[prop], null, 2)
                            }
                        }

                        // flatten children to ids. Skip "parent" field

                        if (prop != 'parent') {
                            if (this.isBlock(block[prop])) {
                                // if the field is a single block container, store the child block's id
                                blockOut[prop] = block[prop].id

                                // register this field name as children ID container
                                blockOut._containsChildrenIds.push(prop)
                            } else if (this.areBlocks(block[prop])) {
                                // if the field is a multiple blocks container, store all the children blocks' id
                                blockOut[prop] = []

                                for (var i = 0; i < block[prop].length; i++) {
                                    blockOut[prop].push(block[prop][i].id)
                                }

                                // register this field name as children IDs container
                                blockOut._containsChildrenIds.push(prop)
                            }
                        }
                    }
                    result.push(blockOut)
                }
            } catch (e) {
                console.error('from json failed : ' + e)
            }
            return result
        },
        _createBlockStore: function () {
        },
        blockFromJson: function (block) {
            block['scope'] = this
            if (block._containsChildrenIds == null) {
                block._containsChildrenIds = []
            }

            // Store all children references into "children"
            var children = {}
            for (var cf = 0; cf < block._containsChildrenIds.length; cf++) {
                var propName = block._containsChildrenIds[cf]
                children[propName] = block[propName]
                block[propName] = null
            }
            delete block._containsChildrenIds

            // Create the block
            if (!block.declaredClass) {
                console.log('   not a class ')
                return null
            }
            var blockClassProto = null
            var _class = null
            try {
                _class = utils.replaceAll('.', '/', block.declaredClass)
                blockClassProto = require(_class)
            } catch (e) {
                try {
                    _class = utils.replaceAll('/', '.', block.declaredClass)
                    blockClassProto = require(_class)
                } catch (e) {
                    debug && console.error('couldnt resolve class ' + _class)
                }
                debug && console.error('couldnt resolve class ' + _class)
            }
            if (!blockClassProto) {
                blockClassProto = dcl.getObject(block.declaredClass)
            }
            if (!blockClassProto) {
                debug && console.log('couldn`t resolve ' + _class)
                return null
            }

            var blockOut = null
            try {
                blockOut = factory.createBlock(blockClassProto, block)
            } catch (e) {
                debug && console.error('error in block creation ', e)
                logError(e)
                return null
            }

            // assign the children references into block._children
            blockOut._children = children

            return blockOut
        },
        /**
         * Convert from JSON data. Creates all blocks in this scope
         * @param data
         * @returns {Array}
         */
        blocksFromJson: function (data, check, errorCB) {
            var resultSelected = []
            var childMap = {}
            for (var i = 0; i < data.length; i++) {
                var block = data[i]
                block['scope'] = this

                if (block._containsChildrenIds == null) {
                    block._containsChildrenIds = []
                }

                // Store all children references into "children"
                var children = {}
                for (var cf = 0; cf < block._containsChildrenIds.length; cf++) {
                    var propName = block._containsChildrenIds[cf]
                    children[propName] = block[propName]
                    block[propName] = null
                }
                delete block._containsChildrenIds

                // Create the block
                if (!block.declaredClass) {
                    console.log('   not a class ')
                    continue;
                }
                var blockClassProto = null
                var _class = null
                try {
                    _class = utils.replaceAll('.', '/', block.declaredClass)
                    blockClassProto = require(_class)
                } catch (e) {
                    console.error('couldnt resolve class ' + _class)
                }
                if (!blockClassProto) {
                    blockClassProto = dcl.getObject(block.declaredClass)
                }
                if (!blockClassProto) {
                    console.log('couldnt resolve ' + _class)
                    continue;
                }

                var blockOut = null
                try {
                    blockOut = factory.createBlock(blockClassProto, block, null, false)
                } catch (e) {
                    console.error('error in block creation ', e + ' ' + block.declaredClass)
                    logError(e)
                    continue;
                }

                // assign the children references into block._children
                blockOut._children = children
                childMap[blockOut.id] = children
                resultSelected.push(blockOut)
            }

            // 2nd pass, update child blocks
            var allBlocks = this.allBlocks(null, false)
            for (var i = 0; i < allBlocks.length; i++) {
                var block = allBlocks[i]
                block._children = childMap[block.id]
                if (block._children) {
                    // get all the block container fields
                    for (var propName in block._children) {
                        if (typeof block._children[propName] == 'string') {
                            // single block
                            var child = this.getBlockById(block._children[propName])
                            if (!child) {
                                this.blockStore.removeSync(block._children[propName])
                                if (errorCB) {
                                    errorCB('   couldnt resolve child: ' + block._children[propName] + '@' + block.name + ':' + block.declaredClass)
                                }
                                console.log('   couldnt resolve child: ' + block._children[propName] + '@' + block.name + ':' + block.declaredClass)
                                continue;
                            }
                            block[propName] = child
                            child.parent = block
                            if (child.postCreate) {
                                child.postCreate()
                            }
                        }
                        else if (typeof block._children[propName] == 'object') {
                            // multiple blocks
                            block[propName] = []
                            for (var j = 0; j < block._children[propName].length; j++) {
                                var child = this.getBlockById(block._children[propName][j])
                                if (!child) {
                                    if (errorCB) {
                                        errorCB('   couldnt resolve child: ' + block._children[propName] + '@' + block.name + ':' + block.declaredClass)
                                    }
                                    console.log('   couldnt resolve child: ' + block._children[propName][j] + '@' + block.name + ':' + block.declaredClass)
                                    continue;
                                }
                                block[propName].push(child)
                                var _parent = this.getBlockById(child.parentId)
                                if (_parent) {
                                    child.parent = _parent
                                } else {
                                    console.error('child has no parent')
                                }
                            }
                        }
                    }
                    delete block._children
                }

                if (check !== false && block.parentId != null) {
                    var parent = this.getBlockById(block.parentId)
                    if (parent == null) {
                        debug && console.error('have orphan block!', block)
                        block.parentId = null
                    }
                }
                block.postCreate()
            }
            var result = this.allBlocks()
            return resultSelected
        },
        /**
         *
         * @param url {String}
         * @returns {module:xblox/model/Block[]}
         */
        resolveBlock: function (url) {
            var blockScope = this,
                ctx = this.ctx,
                driver = this.driver,
                device = this.device,
                deviceManager = ctx.getDeviceManager(),
                driverManager = ctx.getDriverManager()

            if (url.indexOf('://') == -1) {
                var _block = this.getBlockById(url)
                if (_block) {
                    return _block
                }
                return url
            }
            var parts = utils.parse_url(url)// strip scheme

            parts = utils.urlArgs(parts.host)// go on with query string
            var _device = deviceManager.getItemById(parts.device.value)
            // support device by name
            if (!_device) {
                var _instance = deviceManager.getInstanceByName(parts.device.value)
                if (_instance) {
                    _device = _instance.device
                }
            }
            if (_device) {
                var info = deviceManager.toDeviceControlInfo(_device);
                if (!info) {
                    console.warn('cant get device info for ' + _device.title, device);
                    return;
                }

                driver = driverManager.getDriverById(info.driverId)
                var driverInstance = _device.driverInstance
                if (driverInstance || driver) {
                    blockScope = driverInstance ? driverInstance.blockScope : driver.blockScope
                    var block = blockScope ? blockScope.getStore().getSync(parts.block.value) : null
                    if (block) {
                        return block
                    }
                }
            }
        },
        getBlock: function (id) {
            return this.getBlockById(id)
        },
        /***
         * Returns a block from the scope
         * @param name {String}
         * @return block {module:xblox/model/Block[]}
         */
        getBlockByName: function (name) {
            if (name.indexOf('://') !== -1) {
                var block = this.resolveBlock(name)
                if (block) {
                    return block
                }
            }
            var allBlocks = this.getBlocks()
            for (var i = 0; i < allBlocks.length; i++) {
                var block = allBlocks[i]
                if (block.name === name) {
                    return block
                }
            }
            var blocks = this.blockStore.query({
                name: name
            })
            return blocks && blocks.length > 0 ? blocks[0] : null
        },
        /***
         * Returns a block from the scope
         *
         * @param name  =>  block name
         * @return block
         */
        getBlockById: function (id) {
            return this.blockStore.getSync(id);
            /* || this.variableStore.getSync(id) */
        },
        /**
         * Returns an array of blocks
         * @param blocks {module:xblox/model/Block[]
         * @returns {module:xblox/model/Block[]}
         */
        _flatten: function (blocks) {
            var result = []
            for (var b in blocks) {
                var block = blocks[b]
                if (block.keys == null) {
                    continue;
                }
                result.push(block)
                for (var prop in block) {
                    if (prop == 'ctrArgs') {
                        continue;
                    }
                    // flatten children to ids. Skip "parent" field
                    if (prop !== 'parent') {
                        if (this.isBlock(block[prop])) {
                            // if the field is a single block container, store the child block's id
                            result.push(block[prop])
                        } else if (this.areBlocks(block[prop])) {
                            for (var i = 0; i < block[prop].length; i++) {
                                result.push(block[prop][i])
                            }
                        }
                    }
                }
            }
            return result
        },
        /**
         *
         * @param blocks {module:xblox/model/Block[]}
         * @returns {module:xblox/model/Block[]}
         */
        flatten: function (blocks) {
            var result = []
            for (var b in blocks) {
                var block = blocks[b]

                if (block.keys == null) {
                    continue;
                }
                var found = _.find(result, {
                    id: block.id
                })

                if (found) {
                    // console.error('already in array  : ' +found.name);
                } else {
                    result.push(block)
                }

                for (var prop in block) {
                    if (prop == 'ctrArgs') {
                        continue;
                    }
                    // flatten children to ids. Skip "parent" field
                    if (prop !== 'parent') {
                        var value = block[prop]
                        if (this.isBlock(value)) {
                            // if the field is a single block container, store the child block's id
                            found = _.find(result, {
                                id: value.id
                            })
                            if (found) {

                            } else {
                                result.push(value)
                            }
                        } else if (this.areBlocks(value)) {
                            for (var i = 0; i < value.length; i++) {
                                var sBlock = value[i]
                                found = _.find(result, {
                                    id: sBlock.id
                                })
                                if (found) {
                                } else {
                                    result.push(sBlock)
                                }
                                result = result.concat(this.flatten([sBlock]))
                            }
                        }
                    }
                }
            }
            result = _.uniq(result, false, function (item) {
                return item.id
            })
            return result
        },
        _getSolve: function (block) {
            return block.prototype ? block.prototype.solve : block.__proto__.solve
        },
        solveBlock: function (mixed, settings, force, isInterface) {
            settings = settings || {
                    highlight: false
                }
            var block = null
            if (this.isString(mixed)) {
                block = this.getBlockByName(mixed)
                if (!block) {
                    block = this.getBlockById(mixed)
                }
            } else if (this.isObject(mixed)) {
                block = mixed
            }
            var result = null
            if (block) {
                if (settings.force !== true && block.enabled == false) {
                    return null
                }
                if (settings.force === true) {
                    settings.force = false
                }
                var _class = block.declaredClass
                var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class)
                if (_module) {
                    if (_module.prototype && _module.prototype.solve) {
                        result = _module.prototype.solve.apply(block, [this, settings])
                    }
                } else {
                    result = block.solve(block.getScope(), settings, force, isInterface)
                    delete block.override
                    block.override = {}
                }
            } else {
                debug && console.error('solving block failed, have no block! ', mixed)
            }
            return result
        },
        /***
         * Solves all the commands into [items]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solve: function (scope, settings) {
            var ret = ''
            for (var n = 0; n < this.items.length; n++) {
                ret += this.items[n].solve(scope, settings)
            }
            return ret
        },
        /***
         * Parses an expression
         *
         * @param expression
         * @returns {String} parsed expression
         */
        /**
         *
         * @param expression
         * @param addVariables
         * @param variableOverrides
         * @param runCallback
         * @param errorCallback
         * @param context
         * @param args
         * @returns {*}
         */
        parseExpression: function (expression, addVariables, variableOverrides, runCallback, errorCallback, context, args, flags) {
            return this.getExpressionModel().parse(this, expression, addVariables, runCallback, errorCallback, context, variableOverrides, args, flags)
        },
        isString: function (a) {
            return typeof a == 'string'
        },
        isNumber: function (a) {
            return typeof a == 'number'
        },
        isBoolean: function (a) {
            return typeof a == 'boolean'
        },
        isObject: function (a) {
            return typeof a === 'object'
        },
        isBlock: function (a) {
            var ret = false

            if ((typeof a == 'object') && (a != null) && (a.length == undefined)) {
                if (a.serializeMe) {
                    ret = true
                }
            }
            return ret
        },
        areBlocks: function (a) {
            var ret = false

            if ((typeof a == 'object') && (a != null) && (a.length > 0)) {
                if (this.isBlock(a[0])) {
                    ret = true
                }
            }
            return ret
        },
        /**
         *
         * @private
         */
        _onVariableChanged: function (evt) {
            if (evt.item && this.getExpressionModel().variableFuncCache[evt.item.title]) {
                delete this.expressionModel.variableFuncCache[evt.item.title]
            }
        },

        init: function () {
            this.getExpressionModel()// create
            this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, this._onVariableChanged)
            var thiz = this

            this.subscribe(types.EVENTS.ON_MODULE_RELOADED, function (evt) {
                var mid = evt.module,
                    newModule = evt.newModule,
                    blocks = thiz.getBlocks(),
                    instances = blocks.filter(function (block) {
                        if (block.declaredClass == mid || block.declaredClass == utils.replaceAll('/', '.', mid)) {
                            return block
                        }
                        return null
                    })

                instances && _.each(instances, function (block) {
                    mergeNewModule(block, newModule.prototype)
                })
            })
        },
        /**
         *
         */
        _destroy: function () {
            var allblocks = this.allBlocks()
            for (var i = 0; i < allblocks.length; i++) {
                var obj = allblocks[i]
                if (!obj) {
                    continue;
                }
                try {
                    if (obj && obj.stop) {
                        obj.stop(true)
                    }

                    if (obj && obj.reset) {
                        obj.reset()
                    }
                    if (obj && obj._destroy) {
                        obj._destroy()
                    }
                    if (obj && obj.destroy) {
                        obj.destroy()
                    }

                    if (obj._emit) {
                        obj._emit(types.EVENTS.ON_ITEM_REMOVED, {
                            item: obj
                        })
                    }
                } catch (e) {
                    debug && console.error('Scope::_destroy: error destroying block ' + e.message, obj ? (obj.id + ' ' + obj.name) : 'empty')
                    debug && console.trace()
                }
            }
        },
        destroy: function () {
            this._destroy()
            this.reset()
            this._destroyed = true
            delete this.expressionModel
        },
        /**
         *
         * @param source
         * @param target
         * @param before
         * @param add
         * @returns {boolean}
         */
        moveTo: function (source, target, before, add) {
            console.log('move to : ', arguments);
            /**
             * treat first the special cases of adding an item
             */
            if (add) {
                // remove it from the source parent and re-parent the source
                if (target.canAdd && target.canAdd()) {
                    var sourceParent = this.getBlockById(source.parentId)
                    if (sourceParent) {
                        sourceParent.removeBlock(source, false)
                    }
                    return target.add(source, null, null);
                } else {
                    console.error('cant reparent')
                    return false
                }
            }

            // for root level move
            if (!target.parentId && add === false) {
                // if source is part of something, we remove it
                var sourceParent = this.getBlockById(source.parentId);
                if (sourceParent && sourceParent.removeBlock) {
                    sourceParent.removeBlock(source, false);
                    source.parentId = null;
                    source.group = target.group
                }

                var itemsToBeMoved = [];
                var groupItems = this.getBlocks({
                    group: target.group
                });

                var rootLevelIndex = [];
                var store = this.getBlockStore();

                var sourceIndex = store.storage.index[source.id];
                var targetIndex = store.storage.index[target.id];
                for (var i = 0; i < groupItems.length; i++) {
                    var item = groupItems[i];
                    // keep all root-level items

                    if (groupItems[i].parentId == null && // must be root
                        groupItems[i] != source// cant be source
                    ) {
                        var itemIndex = store.storage.index[item.id];
                        var add = before ? itemIndex >= targetIndex : itemIndex <= targetIndex;
                        if (add) {
                            itemsToBeMoved.push(groupItems[i]);
                            rootLevelIndex.push(store.storage.index[groupItems[i].id])
                        }
                    }
                }

                // remove them the store
                for (var j = 0; j < itemsToBeMoved.length; j++) {
                    store.remove(itemsToBeMoved[j].id)
                }

                // remove source
                this.getBlockStore().remove(source.id);

                // if before, put source first
                if (before) {
                    this.getBlockStore().putSync(source)
                }

                // now place all back
                for (var j = 0; j < itemsToBeMoved.length; j++) {
                    store.put(itemsToBeMoved[j])
                }

                // if after, place source back
                if (!before) {
                    this.getBlockStore().putSync(source)
                }
                return true;
                // we move from root to lower item
            } else if (!source.parentId && target.parentId && add == false) {
                source.group = target.group;

                // we move from root to into root item
            } else if (!source.parentId && !target.parentId && add) {
                if (target.canAdd && target.canAdd()) {
                    source.group = null;
                    target.add(source, null, null)
                }
                return true;

                // we move within the same parent
            } else if (source.parentId && target.parentId && add == false && source.parentId === target.parentId) {
                var parent = this.getBlockById(source.parentId);
                if (!parent) {
                    return false
                }
                var items = parent[parent._getContainer(source)];
                var cIndexSource = source.indexOf(items, source);
                var cIndexTarget = source.indexOf(items, target);
                var direction = cIndexSource > cIndexTarget ? -1 : 1;
                var distance = Math.abs(cIndexSource - (cIndexTarget + (before == true ? -1 : 1)))
                for (var i = 0; i < distance - 1; i++) {
                    source.move(direction);
                }
                return true;
                // we move within the different parents
            } else if (source.parentId && target.parentId && add == false && source.parentId !== target.parentId) {
                var sourceParent = this.getBlockById(source.parentId);
                if (!sourceParent) {
                    return false
                }

                var targetParent = this.getBlockById(target.parentId);
                if (!targetParent) {
                    return false
                }

                // remove it from the source parent and re-parent the source
                if (sourceParent && sourceParent.removeBlock && targetParent.canAdd && targetParent.canAdd()) {
                    sourceParent.removeBlock(source, false);
                    targetParent.add(source, null, null)
                } else {
                    return false
                }

                // now proceed as in the case above : same parents
                var items = targetParent[targetParent._getContainer(source)];
                if (items == null) {
                    console.error('weird : target parent has no item container')
                }
                var cIndexSource = targetParent.indexOf(items, source);
                var cIndexTarget = targetParent.indexOf(items, target);
                if (!cIndexSource || !cIndexTarget) {
                    console.error(' weird : invalid drop processing state, have no valid item indicies')
                    return
                }
                var direction = cIndexSource > cIndexTarget ? -1 : 1;
                var distance = Math.abs(cIndexSource - (cIndexTarget + (before == true ? -1 : 1)))
                for (var i = 0; i < distance - 1; i++) {
                    targetParent.move(source, direction)
                }
                return true
            }

            return false
        }

    })
    dcl.chainAfter(Module, 'destroy')
    return Module
})
;
/** @module xblox/model/Expression */
define('xblox/model/Expression',[
    "xdojo/declare",
    "xdojo/has",
    "xide/utils",
    "xide/types",
    "xblox/model/ModelBase"
], function (declare, has, utils, types, ModelBase, tracer, _console) {
    'use strict';
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if (isServer && tracer && console && console.error) {
        console = _console;
    }
    var _debug = false;
    /**
     * The expression
     * @class module:xblox.model.Expression
     * @extends module:xblox/model/ModelBase
     */
    return declare("xblox.model.Expression", [ModelBase], {
        id: null,
        context: null,
        // Constants
        variableDelimiters: {
            begin: "[",
            end: "]"
        },
        blockCallDelimiters: {
            begin: "{",
            end: "}"
        },
        expressionCache: null,
        variableFuncCache: null,
        constructor: function () {
            this.reset();
        },
        reset: function () {
            this.expressionCache = {};
            this.variableFuncCache = {};
        },
        /**
         * Replace variable calls width variable values
         * @param scope
         * @param expression
         * @param _evaluate
         * @param _escape
         * @param variableOverrides
         * @returns {*}
         */
        replaceVariables: function (scope, expression, _evaluate, _escape, variableOverrides, useVariableGetter, variableDelimiters, flags) {
            var FLAG = types.CIFLAG;
            variableDelimiters = variableDelimiters || this.variableDelimiters;
            flags = flags || FLAG.NONE;
            if (flags & FLAG.DONT_ESCAPE) {
                _escape = false;
            }
            if (flags & FLAG.DONT_PARSE) {
                _evaluate = false;
            }
            var occurrence = this.findOccurrences(expression, variableDelimiters);
            if (occurrence) {
                for (var n = 0; n < occurrence.length; n++) {
                    // Replace each variable call width the variable value
                    var oc = occurrence[n];
                    oc = oc.replace(variableDelimiters.begin, '');
                    oc = oc.replace(variableDelimiters.end, '');
                    var _var = this._getVar(scope, oc);
                    if (_var && _var.flags & FLAG.DONT_PARSE) {
                        _evaluate = false;
                    }
                    var value = null;
                    if (_var) {
                        if (useVariableGetter) {
                            expression = expression.replace(occurrence[n], 'this.getVariable(\'' + _var.name + '\')');
                            continue;
                        }
                        value = this.getValue(_var.value);
                        if (variableOverrides && _var.name in variableOverrides) {
                            value = variableOverrides[_var.name];
                        }
                        if (this.isScript(value) && _evaluate !== false) {
                            try {
                                //put other variables on the stack: should be avoided
                                var _otherVariables = scope.variablesToJavascript(_var, true);
                                if (_otherVariables) {
                                    value = _otherVariables + value;
                                }
                                var _parsed = (new Function("{\n" + value + "\n}")).call(scope.context || {});
                                //wasnt a script
                                if (_parsed === 'undefined' || typeof _parsed === 'undefined') {
                                    value = '' + _var.value;
                                } else {
                                    value = _parsed;
                                    !(flags & FLAG.DONT_ESCAPE) && (value = "'" + value + "'");
                                }
                            } catch (e) {
                                console.log(' parsed variable expression failed \n' + value, e);
                            }
                        } else {
                            if (!this.isNumber(value)) {
                                if (_escape !== false) {
                                    value = "'" + value + "'";
                                }
                            }
                        }
                    } else {
                        _debug && console.log('   expression failed, no such variable :' + occurrence[n] + ' ! setting to default ' + '');
                        value = occurrence[n];
                    }
                    expression = expression.replace(occurrence[n], value);
                }
            }
            return expression;
        },
        /**
         *
         * @param scope
         * @param expression
         * @param addVariables
         * @param runCallback
         * @param errorCallback
         * @param context
         * @param variableOverrides
         * @param args {[*]}
         * @param flags {CIFLAGS}
         * @returns {*}
         */
        parse: function (scope, expression, addVariables, runCallback, errorCallback, context, variableOverrides, args, flags) {
            expression = this.replaceAll("''", "'", expression);
            var expressionContext = context || scope.context || scope.getContext() || {};
            var useVariableGetter = expressionContext['getVariable'] != null;
            expression = this.replaceVariables(scope, expression, null, null, variableOverrides, useVariableGetter, null, flags);
            var isExpression = this.isScript(expression);
            if (!isExpression && (this.isString(expression) || this.isNumber(expression))) {
                if (runCallback) {
                    runCallback('Expression ' + expression + ' evaluates to ' + expression);
                }
                return expression;
            }
            if (expression.indexOf('return') == -1 && isExpression) {
                expression = 'return ' + expression;
            }
            addVariables = false;
            if (addVariables === true) {
                var _otherVariables = scope.variablesToJavascript(null, expression);
                if (_otherVariables) {
                    expression = _otherVariables + expression;
                    expression = this.replaceAll("''", "'", expression);//weird!
                }
            }
            var parsed = this;
            try {
                expression = this.replaceAll("''", "'", expression);
                var _function = this.expressionCache[expression];
                if (!_function) {
                    _debug && console.log('create function ' + expression);
                    _function = new Function("{" + expression + "; }");
                    this.expressionCache[expression] = _function;
                } else {

                }
                parsed = _function.apply(expressionContext, args);
            } catch (e) {
                console.error('invalid expression : \n' + expression, e);
                if (errorCallback) {
                    errorCallback('invalid expression : \n' + expression + ': ' + e, e);
                }
                parsed = '' + expression;
                return parsed;
            }
            if (parsed === true) {
                _debug && console.log('expression return true! : ' + expression);
            }

            if (runCallback) {
                runCallback('Expression ' + expression + ' evaluates to ' + parsed);
            }
            return parsed;
        },
        parseVariable: function (scope, _var, _prefix, escape, allowCache, context, args) {
            var value = '' + _var.value;
            _prefix = _prefix || '';
            if (allowCache !== false) {
                var _function = this.variableFuncCache[scope.id + '|' + _var.title];
                if (!_function) {
                    _function = new Function("{" + _prefix + value + "}");
                    this.variableFuncCache[scope.id + '|' + _var.title] = _function;
                }
            } else {
                _function = new Function("{" + _prefix + value + "}");
            }
            var _parsed = _function.apply(context || scope.context || {}, args || []);
            if (_parsed === 'undefined' || typeof _parsed === 'undefined') {
                value = '' + _var.value;
            } else {
                if (!this.isNumber(_parsed) && escape !== false) {
                    value = '' + _parsed;
                    value = "'" + value + "'";
                } else {
                    value = _parsed;
                }
            }
            return value;
        },
        // Replace block call with block result
        replaceBlockCalls: function (scope, expression) {
            var occurrences = this.findOccurrences(expression, this.blockCallDelimiters);
            if (occurrences) {
                for (var n = 0; n < occurrences.length; n++) {
                    // Replace each block call with block result
                    var blockName = this._removeDelimiters(occurrences[n], this.blockCallDelimiters);
                    var blockResult = scope.solveBlock(blockName).join("\n");
                    expression = expression.replace(occurrences[n], blockResult);
                }
            }
            return expression;
        },
        // gets a variable from the scope using text [variableName]
        _getVar: function (scope, string) {
            return scope.getVariable(this._getVarName(string));
        },
        _getVarName: function (string) {
            return this._removeDelimiters(string, this.variableDelimiters);
        },
        _removeDelimiters: function (text, delimiters) {
            return text.replace(delimiters.begin, '').replace(delimiters.end, '');
        },
        // escape regular expressions special chars
        _escapeRegExp: function (string) {
            var special = ["[", "]", "(", ")", "{", "}", "*", "+", "."];
            for (var n = 0; n < special.length; n++) {
                string = string.replace(special[n], "\\" + special[n]);
            }
            return string;
        },
        /**
         * Finds a term in an expression by start and end delimiters
         * @param expression
         * @param delimiters
         * @private
         */
        findOccurrences: function (expression, delimiters) {
            var d = {
                begin: this._escapeRegExp(delimiters.begin),
                end: this._escapeRegExp(delimiters.end)
            };
            return expression.match(new RegExp(d.begin + "(" + "[^" + d.end + "]*" + ")" + d.end, 'g'));
        }
    });
});;
/** @module xblox/model/ModelBase
 *  @description The base for block related classes, this must be kept small and light as possible
 */
define('xblox/model/ModelBase',[
    'dcl/dcl',
    "xide/utils",
    "xide/types",
    "xide/mixins/EventedMixin",
    "xide/lodash"
], function(dcl,utils,types,EventedMixin,_){
    /**
     * The model mixin for a block
     * @class module:xblox.model.ModelBase
     */
    var Module = dcl(EventedMixin.dcl,{
        declaredClass:'xblox.model.ModelBase',
        id:null,
        description:'',
        parent:null,
        parentId:null,
        group:null,
        order:0,
        _store:null,
        ////////////////////////////////////////////////////////////
        //
        //  Functions to expose out & in - lets
        //
        ////////////////////////////////////////////////////////////
        /**
         *
         * Implmented by the subclass. Each block must provide an output signature.
         * The format is currently the same as Dojo SMD
         *
         * @returns {Array}
         */
        outputs:function(){
           return [];
        },
        /**
         * Implemented by the subclass. Each block must provide an input signature.
         * The format is currently the same as Dojo SMD
         * @returns {Array}
         */
        takes:function(){
            return [];
        },
        /**
         * Implemented by the subclass. Each block must provide an needed input signature.
         * The format is currently the same as Dojo SMD. This is a filtered version of
         * 'takes'
         *
         * @returns {Array}
         */
        needs:function(){
            return [];
        },
        ////////////////////////////////////////////////////////////
        //
        //  Functions to expose outlets
        //
        ////////////////////////////////////////////////////////////
        /***
         * Standard constructor for all sub classing blocks
         * @param {array} args
         */
        constructor: function(args){
            //simple mixin of constructor arguments
            for (var prop in args) {
                if (args.hasOwnProperty(prop)) {
                    this[prop] = args[prop];
                }
            }
            if(!this.id){
                this.id = this.createUUID();
            }
            //short cuts
            this.utils=utils;
            this.types=types;
        },
        ////////////////////////////////////////////////////////////
        //
        //  Standard tools
        //
        ////////////////////////////////////////////////////////////
        keys: function (a) {
            var b = [];
            for (var c in a) {
                b.push(c);
            }
            return b;
        },
        values: function (b) {
            var a = [];
            for (var c in b) {
                a.push(b[c]);
            }
            return a;
        },
        toArray: function () {
            return this.map();
        },
        size: function () {
            return this.toArray().length;
        },
        createUUID:utils.createUUID,
        canEdit:function(){
            return true;
        },
        getFields:function(){
            return null;
        },
        isString: function (a) {
            return typeof a == "string"
        },
        isNumber: function (a) {
            return typeof a == "number"
        },
        isBoolean: function (a) {
            return typeof a == "boolean"
        },
        isObject:_.isObject,
        isArray:_.isArray,
        getValue:function(val){
            var _float = parseFloat(val);
            if(!isNaN(_float)){
               return _float;
            }
            if(val==='true' || val===true){
                return true;
            }
            if(val==='false' || val===false){
                return false;
            }
            return val;
        },
        isScript:function(val){
            return this.isString(val) &&(
                    val.indexOf('return')!=-1||
                    val.indexOf(';')!=-1||
                    val.indexOf('(')!=-1||
                    val.indexOf('+')!=-1||
                    val.indexOf('-')!=-1||
                    val.indexOf('<')!=-1||
                    val.indexOf('*')!=-1||
                    val.indexOf('/')!=-1||
                    val.indexOf('%')!=-1||
                    val.indexOf('=')!=-1||
                    val.indexOf('==')!=-1||
                    val.indexOf('>')!=-1||
                    val.indexOf('[')!=-1||
                    val.indexOf('{')!=-1||
                    val.indexOf('}')!=-1
                );
        },
        replaceAll:function(find, replace, str) {
            if(this.isString(str)){
                return str.split(find).join(replace);
            }
            return str;
        },
        isInValidState:function(){
            return true;
        },
        destroy:function(){}
    });
    dcl.chainAfter(Module,'destroy');
    return Module;
});;
/** @module xcf/manager/DeviceManager */
define('xcf/manager/DeviceManager',[
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/encoding/MD5',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xcf/manager/BeanManager',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin'/*NMD:Ignore*/,
    './DeviceManager_Server',
    './DeviceManager_DeviceServer',
    'xide/data/Memory',
    'xide/data/TreeMemory',
    'dojo/has',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xcf/model/Device',
    'dojo/Deferred',
    "xide/manager/ServerActionBase",
    "xide/data/Reference",
    'xide/utils/StringUtils',
    'xcf/mixins/LogMixin',
    'xdojo/has!xcf-ui?./DeviceManager_UI', /*NMD:Ignore*/
    'xdojo/has!xexpression?xexpression/Expression', /*NMD:Ignore*/
    'dojo/promise/all',
    "xide/console",
    "xide/lodash"
    //'xdojo/has!host-node?nxapp/utils/_console',
    //"xdojo/has!host-node?nxapp/utils"
], function (dcl, declare, lang, MD5,
    types, utils, factory, BeanManager, ReloadMixin, EventedMixin,
    DeviceManager_Server, DeviceManager_DeviceServer, Memory, TreeMemory, has,
    ObservableStore, Trackable, Device, Deferred, ServerActionBase, Reference, StringUtils,
    LogMixin,
    DeviceManager_UI, Expression, all, console, _, _console, xUtils) {
        /*
         var console = typeof window !== 'undefined' ? window.console : console;
         if(_console && _console.error && _console.warn){
         console = _console;
         }
         */
        var bases = [
            ServerActionBase,
            BeanManager,
            DeviceManager_Server,
            DeviceManager_DeviceServer,
            ReloadMixin.dcl,
            LogMixin
        ],
            _debugMQTT = false,
            _debug = false,
            _debugLogging = false,
            _debugConnect = false,
            isServer = !has('host-browser'),
            isIDE = has('xcf-ui'),
            DEVICE_PROPERTY = types.DEVICE_PROPERTY,
            runDrivers = has('runDrivers'),
            EVENTS = types.EVENTS;
        has('xcf-ui') && bases.push(DeviceManager_UI);
        /**
         * Common base class, for server and client.
         * @class module:xcf/manager/DeviceManager
         * @augments module:xide/mixins/EventedMixin
         * @extends module:xcf/manager/BeanManager
         * @extends module:xide/mixins/ReloadMixin
         * @extends module:xcf/manager/DeviceManager_DeviceServer
         */
        return dcl(bases, {
            declaredClass: "xcf.manager.DeviceManager",
            /***
             * The Bean-Manager needs a unique name of the bean:
             * @private
             */
            beanNamespace: 'device',
            /***
             * The Bean-Manager has some generic function like creating Dialogs for adding new items, please
             * provide a title for the interface.
             * @private
             */
            beanName: 'Device',
            beanUrlPattern: "{id}",
            breanScheme: "device://",
            beanPriority: 1,
            /**
             * the icon class for bean edit views
             * @private
             */
            beanIconClass: 'fa-sliders',
            /**
             * Bean group type
             * @private
             */
            groupType: types.ITEM_TYPE.DEVICE_GROUP,
            /**
             * Bean item type
             * @private
             */
            itemType: types.ITEM_TYPE.DEVICE,
            /**
             * The name of the CI in the meta database for the title or name.
             * @private
             */
            itemMetaTitleField: DEVICE_PROPERTY.CF_DEVICE_TITLE,
            /**
             * Name of the system scope
             * @private
             */
            systemScope: 'system_devices',
            /**
             * Name of the user scope
             * @private
             */
            userScope: 'user_devices',
            /**
             * Name of the app scope
             * @private
             */
            appScope: 'app_devices',
            /**
             * Name of the default scope for new created items
             * @private
             */
            defaultScope: 'system_devices',
            /***
             * The RPC server class:
             * @private
             */
            serviceClass: 'XCF_Device_Service',
            /***
             * A copy of all devices raw data from the server
             * @private
             */
            rawData: null,
            /***
             * @type {module:xide/data/_Base}
             * @private
             */
            store: null,
            /***
             * {xcf.views.DevicesTreeView}
             * @private
             */
            treeView: null,
            /***
             * {xide.client.WebSocket}
             */
            deviceServerClient: null,
            /***
             *  An array of started device instances.
             *  @private
             */
            deviceInstances: null,
            /***
             *  A map of scope names for module hot reloading
             *  @private
             */
            driverScopes: null,
            /***
             * autoConnectDevices does as it says, on app start, it connects to all known devices of the
             * project
             * @param autoConnectDevices
             * @private
             */
            autoConnectDevices: true,
            /**
             * Consoles is an array of {xide.views.ConsoleViews}. There is one console per device possible
             * @private
             */
            consoles: null,
            /**
             * lastUpTime is being used to recognize a computer suspend hibernate
             * @private
             */
            lastUpTime: null,
            /**
             * @private
             */
            reconnectDevice: 15000,
            /**
             * @private
             */
            reconnectDeviceServer: 5000,

            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Device-Related
            //
            /////////////////////////////////////////////////////////////////////////////////////
            onRunClassEvent: function (data) {
                var id = data.args.id;
                if (this.running && this.running[id]) {
                    var runData = this.running[id];
                    var delegate = runData.delegate;
                    if (!delegate) {
                        return;
                    }
                    if (data.error) {
                        if (delegate.onError) {
                            delegate.onError(data.error);
                        }
                    }
                    if (data.finish) {
                        if (delegate.onFinish) {
                            delegate.onFinish(data.finish);
                        }
                    }
                    if (data.progress) {
                        if (delegate.onProgress) {
                            delegate.onProgress(data.progress);
                        }
                    }
                }
            },
            getInstanceByName: function (name) {
                var instances = this.deviceInstances;
                var self = this;
                for (var instance in instances) {
                    var device = instances[instance].device;
                    if (!device) {
                        continue;
                    }
                    var title = self.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_TITLE);
                    if (title === name) {
                        return instances[instance];
                    }
                }
            },
            /**
             * Returns the file object for a device
             * @param device
             * @returns {module:xfile/model/File}
             */
            getFile: function (device) {
                var dfd = new Deferred();
                var ctx = this.ctx;
                if (_.isString(device)) {
                    device = this.getItemByPath(device + '.meta.json') || this.getItemByPath(device) || device;
                }
                var fileManager = ctx.getFileManager();
                var fileStore = fileManager.getStore(device.scope);
                var item = fileStore._getItem(device.path);
                if(item){
                    dfd.resolve(item);
                    return dfd;
                }
                fileStore.initRoot().then(function () {
                    fileStore._loadPath('.', true).then(function () {
                        fileStore.getItem(device.path,true).then(function (item) {
                            dfd.resolve(item);
                        });
                    });
                });
                return dfd;
            },
            getSourceHash: function () {
                var userDirectory = this.ctx.getUserDirectory();
                return userDirectory || "no_user_directory";
            },
            /**
             * Make sure we've a connection to our device-server
             * @public
             */
            checkDeviceServerConnection: function () {
                if (!this.ctx.getNodeServiceManager) {
                    return true;
                }
                var ctx = this.getContext();
                var nodeServiceManager = has('xnode') && ctx.getNodeServiceManager ? this.ctx.getNodeServiceManager() : null;
                if (!this.deviceServerClient && nodeServiceManager) {
                    var store = nodeServiceManager.getStore();
                    if (!store) {
                        return false;
                    }
                    this.createDeviceServerClient(store);
                } else {
                    return false;
                }
                return true;
            },
            /**
             *
             * @param target
             * @param source
             * @private
             */
            addDriverFunctions: function (target, source) {
                for (var i in source) {

                    if (i === 'constructor' ||
                        i === 'inherited' ||
                        i == 'getInherited' ||
                        i == 'isInstanceOf' ||
                        i == '__inherited' ||
                        i == 'onModuleReloaded' ||
                        i == 'start' ||
                        i == 'publish' ||
                        i == 'subscribe' ||
                        i == 'getInherited' ||
                        i == 'getInherited'
                    ) {
                        continue;
                    }
                    if (_.isFunction(source[i]) && !target[i]) {
                        target[i] = source[i];//swap
                    }
                }
            },
            /**
             *
             * @param driver
             * @param instance
             * @private
             */
            addLoggingFunctions: function (driver, instance) {
                var thiz = this;
                instance.log = function (level, type, message, data) {
                    data = data || {};
                    var oriData = lang.clone(data);
                    data.type = data.type || type || 'Driver';
                    if (instance.options) {
                        data.device = instance.options;
                    }
                    thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                        data: data,
                        level: level || 'info',
                        message: message,
                        details: oriData
                    });
                };
            },
            /**
             * An instance of a driver class has been created.
             * We mixin new functions: callCommand, set/get-Variable, log
             * @param driver
             * @param instance
             * @param device
             * @private
             */
            completeDriverInstance: function (driver, instance, device) {
                _debug && console.info('complete driver instance');
                var thiz = this,
                    scope = instance.blockScope,
                    store = scope.blockStore,
                    parentId = device.path,
                    commandsRoot = parentId + '_commands',
                    variablesRoot = parentId + '_variables';

                store.on('delete', function (evt) {
                    var _isVariable = evt.target.declaredClass.indexOf('Variable') !== -1,
                        _parent = _isVariable ? variablesRoot : commandsRoot,
                        referenceParent = device._store.getSync(_parent);

                    if (referenceParent) {
                        referenceParent.refresh();
                    }

                    var referenceId = _parent + '_reference_' + evt.target.id,
                        reference = device._store.getSync(referenceId);

                    if (reference) {
                        reference.refresh();
                    }
                });
                function createReference(block, driver, title, icon) {
                    var _isVariable = block.declaredClass.indexOf('Variable') !== -1;
                    var _parent = _isVariable ? variablesRoot : commandsRoot;
                    if (block.declaredClass.indexOf(_isVariable ? 'Variable' : 'Command') == -1) {
                        return;
                    }

                    var reference = new Reference({
                        enabled: true,
                        path: _parent + '_reference_' + block.id,
                        name: title,
                        id: block.id,
                        parentId: _parent,
                        _mayHaveChildren: false,
                        virtual: true,
                        tooltip: true,
                        icon: icon,
                        ref: {
                            driver: driver,
                            item: block,
                            device: device
                        },
                        type: types.ITEM_TYPE.BLOCK
                    });

                    reference = device._store.putSync(reference);

                    block.addReference(reference, {
                        properties: {
                            "name": true,
                            "enabled": true,
                            "value": true
                        },
                        onDelete: true
                    }, true);

                    reference.refresh();
                }

                store.on('added', function (block) {
                    createReference(block, driver, block.name, block.icon || 'fa-exclamation');
                });

                instance.setVariable = function (title, value, save, publish, highlight) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {
                        _variable.value = value;
                        if (highlight === false) {
                            _variable.__ignoreChangeMark = true;
                        }
                        _variable.set('value', value, save, publish, highlight);
                        if (highlight === false) {
                            _variable.__ignoreChangeMark = false;
                        }
                    } else {
                        _debug && console.log('no such variable : ' + title);
                        return;
                    }
                    thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                        item: _variable,
                        scope: this.blockScope,
                        driver: driver,
                        owner: thiz,
                        save: save === true,
                        publish: publish
                    });
                };
                /**
                 * Add getVariable
                 * @param title
                 */
                instance.getVariable = function (title) {
                    var _variable = this.blockScope.getVariable(title);
                    if (_variable) {
                        return _variable._getArg(_variable.value, false);
                    }
                    return '';
                };

                /**
                 * add log function
                 * @param level
                 * @param type
                 * @param message
                 * @param data
                 */
                instance.log = function (level, type, message, data) {
                    data = data || {};
                    var oriData = lang.clone(data);
                    data.type = data.type || type || 'Driver';
                    if (instance.options) {
                        data.device = instance.options;
                    }
                    thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                        data: data,
                        level: level || 'info',
                        message: message,
                        details: oriData
                    });
                };
                for (var i in driver) {
                    if (i === 'constructor' ||
                        i === 'inherited' ||
                        i == 'getInherited' ||
                        i == 'isInstanceOf' ||
                        i == '__inherited' ||
                        i == 'onModuleReloaded' ||
                        i == 'start' ||
                        i == 'publish' ||
                        i == 'subscribe' ||
                        i == 'getInherited' ||
                        i == 'getInherited'
                    ) {
                        continue;
                    }
                    if (lang.isFunction(driver[i]) && !instance[i] /*&& lang.isFunction(target[i])*/) {
                        instance[i] = driver[i];//swap
                    }
                }
            },
            getDevice: function (mixed) {
                var result = mixed;
                if (_.isString(mixed)) {
                    var byId = this.getItemById(mixed);
                    if (byId) {
                        result = byId;
                    } else {
                        var byPath = this.getItemByPath(mixed);
                        if (byPath) {
                            result = byPath;
                        }
                    }
                }
                return result;
            },
            /**
             * Stops a device with a device model item
             * @param _item {module:xcf/model/Device|string}
             */
            stopDevice: function (_item) {
                var device = this.getDevice(_item) || _item;
                if (!device) {
                    console.error('cant find device ' + _item);
                    return;
                }
                this.checkDeviceServerConnection();
                device._userStopped = true;
                var cInfo = this.toDeviceControlInfo(device);
                if (!cInfo) {
                    _debugConnect && console.error('cant find device::no device info', device.toString && device.toString());
                    return;
                }
                if (isServer && (!cInfo.serverSide && !device.isServer())) {
                    return;
                }
                var hash = cInfo.hash;
                if (this.deviceInstances[hash]) {
                    this._removeInstance(this.deviceInstances[hash], hash, device);
                    delete this.deviceInstances[hash];
                    _debugConnect && console.log('-- stop device ' + hash, this.deviceInstances);
                } else {
                    _debugConnect && console.log('cant find instance ' + hash);
                    return;
                }
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_STOP_DRIVER, cInfo);
                //this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.STOP_DEVICE, cInfo);
            },
            /**
             * @TODO: remove back compat
             * @param scope
             * @returns {*}
             */
            getStore: function (scope) {
                scope = scope || 'system_devices';
                var store = this.stores[scope];
                if (store) {
                    return store;
                }
                if (scope) {
                    return this.ls(scope);
                }
            },
            /**
             * Get all enabled devices
             * @param enabledOnly
             * @param addDriver
             * @returns {module:xcf/model/Device[]}
             */
            getDevices: function (enabledOnly, addDriver) {
                var store = this.getStore();
                if (!store) {
                    return [];
                }
                var items = utils.queryStore(store, {
                    isDir: false
                });
                if (items._S) {
                    items = [items];
                }

                var result = [];
                for (var i = 0; i < items.length; i++) {

                    var device = items[i];
                    var enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);

                    if ((enabledOnly === true && enabled == true || enabled == null) || enabledOnly === false) {
                        result.push(device);
                        if (addDriver == true) {
                            var driverId = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                            if (!driverId) {
                                _debug && console.error('device has no driver id!');
                                continue;
                            }
                            var driver = this.ctx.getDriverManager().getItemById(driverId);
                            if (driver) {
                                device['driver'] = driver;
                            }
                        }
                    }
                }
                return result;
            },
            getStores: function () {
                var stores = [];
                for (var scope in this.stores) {
                    var store = this.stores[scope];
                    if (store) {
                        stores.push(store);
                    }
                }
                return stores;
            },
            getStorePath: function (scope) {
                var ctx = this.getContext();
                var resourceManager = ctx.getResourceManager();
                if (scope === 'user_devices') {
                    return resourceManager.getVariable('USER_DIRECTORY');
                }
            },
            /**
             * Connect to all known devices
             * @private
             */
            connectToAllDevices: function () {
                if (!this.deviceServerClient) {
                    this.checkDeviceServerConnection();
                    return;
                }

                var stores = this.getStores(),
                    thiz = this;

                if (!this.getStores().length) {
                    return;
                }
                var all = [];

                function start(device) {
                    var deviceDfd = thiz.startDevice(device);
                    all.push(deviceDfd);
                    _debugConnect && console.log('start device ' + thiz.toDeviceControlInfo(device).title);
                }

                function connect(store) {
                    if (!store) {
                        console.error('have no device store');
                        return;
                    }
                    if (store.connected) {
                        return;
                    }
                    store.connected = true;
                    var items = utils.queryStore(store, {
                        isDir: false
                    });
                    if (items._S) {
                        items = [items];
                    }

                    if (!_.isArray(items)) {
                        items = [items];
                    }
                    for (var i = 0; i < items.length; i++) {
                        var device = items[i];
                        var enabled = thiz.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);
                        if (enabled == true || enabled == null) {
                            start(device);
                        }
                    }
                }

                if (this.deviceServerClient.dfd) {
                    this.deviceServerClient.dfd.then(function () {
                        _.each(stores, connect, this);
                    }.bind(this));
                } else {
                    _.each(stores, connect, this);
                }
                return all;
            },
            /**
             *
             * @param clientOptions
             * @param localDevice {module:xcf/model/Device}
             */
            updateDevice: function (clientOptions, localDevice) {
                if (localDevice) {
                    localDevice.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS, clientOptions.driverOptions);
                    localDevice.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_OPTIONS, clientOptions.options);
                    localDevice.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED, clientOptions.enabled);
                }
            },
            debug: function () {
                console.info('Debug info stores : ');
                _.each(this.stores, function (store) {
                    console.log('have store ' + store.scope);
                });
            },
            /**
             *
             * @private
             */
            _getLogText: function (str) {
                return moment().format("HH:mm:ss:SSS") + ' ::   ' + str + '';
            },
            _parse: function (scope, expression) {
                var str = '' + expression;
                if (str.indexOf('{{') > 0 || str.indexOf('}}') > 0) {
                    console.time('parse expression');
                    var _parser = new Expression();
                    str = _parser.parse(types.EXPRESSION_PARSER.FILTREX,
                        str, this, {
                            variables: scope.getVariablesAsObject(),
                            delimiters: {
                                begin: '{{',
                                end: '}}'
                            }
                        }
                    );
                    console.timeEnd('parse expression');
                } else {
                    var _text = scope.parseExpression(expression);
                    if (_text) {
                        str = _text;
                    }
                }
                return str;
            },
            /**
             *
             * @param driver
             * @param device
             * @private
             */
            runCommand: function (driver, device) {
            },
            /**
             * @private
             */
            _lastActions: null,
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Data related
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /**
             *
             * @param rawData
             * @private
             */
            onStoreReloaded: function (rawData) {
                this.completeDeviceStore();
            },
            getInstance: function (mixed) {
                var deviceInfo = mixed ? mixed._store ? this.toDeviceControlInfo(mixed) : mixed : null;
                if (!deviceInfo) {
                    return;
                }
                return this.getDriverInstance(deviceInfo, false);
            },
            /***
             * returns driver instance!
             * @param deviceInfo {module:xide/types~DeviceInfo}
             * @param fillSettings will convert and put CI settings into the driver's instance (member variable)
             * @returns {module:xcf/driver/DriverBase}
             * @private
             */
            getDriverInstance: function (deviceInfo, fillSettings) {
                if (!deviceInfo) {
                    console.error('getDriverInstance::have no device info');
                    return null;
                }
                for (var i in this.deviceInstances) {

                    var instance = this.deviceInstances[i];
                    var instanceOptions = instance.options;
                    if (!instanceOptions) {
                        continue;
                    }

                    if (instanceOptions.port === deviceInfo.port &&
                        instanceOptions.host === deviceInfo.host &&
                        instanceOptions.protocol === deviceInfo.protocol &&
                        instanceOptions.isServer === deviceInfo.isServer) {

                        if (fillSettings && instance.sendSettings && has('xcf-ui')) {
                            fillSettings = false;
                        }

                        if (fillSettings !== false) {
                            //get settings, if not cached already
                            if (instance && !instance.sendSettings) {
                                //pick driver
                                var driver = this.ctx.getDriverManager().getItemById(deviceInfo.driverId);//driverStore item
                                if (driver) {
                                    var meta = driver['user'];
                                    var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                                    if (commandsCI && commandsCI['params']) {
                                        instance.sendSettings = utils.getJson(commandsCI['params']);
                                    }

                                    var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                                    if (responseCI && responseCI['params']) {
                                        instance.responseSettings = utils.getJson(responseCI['params']);
                                    }
                                } else {
                                    _debug && console.warn('getDriverInstance:: cant find driver');
                                }
                            }
                        }
                        return instance;
                    }
                }
                return null;
            },
            _reconnectServerTimer: null,
            /**
             * @private
             */
            onDeviceServerConnectionLost: function () {

                if (this.deviceServerClient && this.deviceServerClient.pageUnloaded) {
                    return;
                }
                if (this.deviceServerClient) {
                    this.deviceServerClient.destroy();
                    this.deviceServerClient = null;
                }

                if (this._reconnectServerTimer) {
                    return;
                }
                var thiz = this;
                if (isIDE) {
                    thiz.ctx.getNotificationManager().postMessage({
                        message: 'Lost connection to device server, try reconnecting in 5 seconds',
                        type: 'error',
                        showCloseButton: true,
                        duration: 1000
                    });
                }
                this._reconnectServerTimer = setTimeout(function () {
                    thiz.checkDeviceServerConnection();
                    thiz._reconnectServerTimer = null;
                }, this.reconnectDeviceServer);

                console.log('lost device server connection');
                _.each(this.deviceInstances, function (instance) {

                    if (instance && instance.device && !instance.domNode) {
                        var device = instance.device;
                        var driverInstance = device.driverInstance;
                        driverInstance && driverInstance.onLostServer && driverInstance.onLostServer();
                        device.setState(types.DEVICE_STATE.LOST_DEVICE_SERVER);
                    }
                });

            },
            /**
             *
             * @param msg
             * @private
             */
            onMQTTMessage: function (msg) {
                var message = utils.getJson(msg.message);
                var isUs = false;
                var thiz = this;
                if (message) {
                    var sourceHost = message.sourceHost;
                    var sourcePort = message.sourcePort;
                    var mqttHost = msg.host;
                    var mqttPort = msg.port;
                    if (sourceHost && sourcePort) {
                        if (sourceHost === mqttHost && sourcePort == mqttPort) {
                            isUs = true;
                        }
                    }
                }

                if (!isUs) {

                    _debugMQTT && console.info('onMQTTMessage:');
                    //
                    var parts = msg.topic.split('/');
                    if (parts.length == 4 && parts[2] == 'Variable' && message.device) {
                        var _device = this.getDeviceStoreItem(message.device);
                        if (_device) {
                            _debugMQTT && console.info('\tonMQTTMessage: on mqtt variable topic ' + msg.topic);
                            var _deviceInfo = this.toDeviceControlInfo(message.device);
                            if (_deviceInfo) {
                                var driverInstance = this.getDriverInstance(_deviceInfo);
                                if (driverInstance) {
                                    var scope = driverInstance.blockScope;
                                    var _variable = scope.getVariable(parts[3]);
                                    if (_variable) {
                                        _debugMQTT && console.info('     received MQTT variable ' + _variable.name + ' = ' + message.value);
                                        if (has('xcf-ui')) {
                                            _variable.set('value', message.value);
                                            _variable.refresh();
                                        } else {
                                            delete _variable.value;
                                            _variable.value = message.value;
                                        }
                                        thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                                            item: _variable,
                                            scope: _variable.scope,
                                            owner: thiz,
                                            save: false,
                                            publish: true,
                                            source: 'mqtt',
                                            publishMQTT: false
                                        });

                                    }
                                } else {
                                    _debugMQTT && console.error('cant find driver instance ' + msg.topic);
                                }
                            } else {
                                _debugMQTT && console.error('cant find device info');
                            }
                        } else {
                            console.error('cant find device for : ' + msg.topic);
                        }
                    }
                } else {
                    _debugMQTT && console.error('same source');
                }
            },
            /**
             * Find a block by url in all instances
             * @param url
             * @returns {*}
             */
            getBlock: function (url) {
                for (var id in this.deviceInstances) {
                    var instance = this.deviceInstances[id];
                    if (!instance || !instance.device) {
                        continue;
                    }
                    var scope = instance.blockScope;
                    if (scope) {
                        var block = scope.resolveBlock(url);
                        if (block) {
                            return block;
                        }
                    }
                }
                return this.ctx.getDriverManager().getBlock(url);
            },
            /***
             * Callback when the NodeJS service manager initialized its service store. That may
             * happen multiple times as user can reload the store.
             *
             * @param evt
             * @private
             */
            onNodeServiceStoreReady: function (evt) {
                if (this.deviceServerClient) {
                    //this.deviceServerClient.destroy();
                    return this.deviceServerClient;
                }
                var store = evt.store, thiz = this;
                var client = this.createDeviceServerClient(store);
                var connect = has('drivers') && has('devices');
            },
            /**
             *
             * @param instance
             * @param modulePath
             * @private
             */
            onDriverUpdated: function (instance, modulePath) {
                return;
            },
            /**
             * Some file has changed, update driver instance
             * @param evt
             * @private
             */
            onModuleReloaded: function (evt) {
                if (this.deviceInstances.length == 0) {//nothing to do
                    return;
                }
                var modulePath = utils.replaceAll('//', '/', evt.module);
                var newModule = evt.newModule;
                var found = false;
                for (var i in this.deviceInstances) {

                    var instance = this.deviceInstances[i];

                    if (instance.modulePath === modulePath ||
                        instance.baseClass === modulePath) {
                        this.mergeFunctions(instance, newModule.prototype);
                        found = true;
                        _debug && console.log('Did update driver code : ' + modulePath, newModule.prototype);
                        if (instance.blockScope) {
                            instance.blockScope.expressionModel.expressionCache = {};
                        }
                        this.onDriverUpdated(instance, modulePath);
                    }
                }
            },
            /**
             *
             * @param instance
             * @param hash
             * @param device
             * @private
             */
            _removeInstance: function (instance, hash, device) {
                if (instance.destroy) {
                    instance.destroy();
                }
                instance.blockScope && instance.blockScope._destroy();
                delete this.deviceInstances[hash];
                this.ctx.getBlockManager().removeScope(instance.options.id);
                this.ctx.getDriverManager().removeDriverInstance(instance, device);
                device.reset();
            },
            /**
             *
             * @param deviceInfo
             * @private
             */
            removeDriverInstance: function (deviceInfo) {
                var instance = this.getDriverInstance(deviceInfo);
                if (instance) {
                    this.ctx.getBlockManager().removeScope(instance.options.id);
                    if (instance.blockScope) {
                        instance.blockScope.destroy();
                    }
                    instance.destroy();
                } else {
                    _debugConnect && console.error('remove instance : cant find!');
                }
                for (var i in this.deviceInstances) {
                    if (instance == this.deviceInstances[i]) {
                        delete this.deviceInstances[i];
                    }
                }
            },
            /**
             *
             * @param item {module:xcf/model/Device} the device
             * @param name {string} the name of the CI
             * @returns {string|int|object|null}
             */
            getMetaValue: function (item, name) {
                var meta = item['user'];
                if (meta) {
                    return utils.getCIInputValueByName(meta, name);
                }
                return null;
            },
            /**
             * Return device by host and port
             * @param host {string}
             * @param port {string}
             * @returns {module:xcf/model/Device|null}
             */
            getDeviceByHost: function (host, port) {
                var items = utils.queryStore(this.getStore(), {
                    isDir: false
                });
                for (var i = 0; i < items.length; i++) {
                    var device = items[i];
                    var _host = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_HOST);
                    var _port = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_PORT);
                    if (_host == host && _port == port) {
                        return device;
                    }
                }
                return null;
            },
            getDeviceByUrl: function (url) {
                var parts = utils.parse_url(url);
                parts = utils.urlArgs(parts.host);
                return this.getDeviceById(parts.device.value);
            },
            /**
             * Returns a device by id
             * @param id {string}
             * @returns {module:xcf/model/Device|null}
             */
            getDeviceById: function (id, store) {
                var self = this;

                function search(_store) {
                    var items = utils.queryStore(_store, {
                        isDir: false
                    });

                    if (items._S) {
                        items = [items];
                    }
                    for (var i = 0; i < items.length; i++) {
                        var device = items[i];
                        var _id = self.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                        if (_id == id) {
                            return device;
                        }
                    }
                    return null;
                }

                var _store = _.isString(store) ? this.getStore(store) : null;
                if (_store) {
                    return search(_store);
                } else {
                    for (var scope in this.stores) {
                        var item = search(this.stores[scope]);
                        if (item) {
                            return item;
                        }
                    }
                }
                return null;
            },
            /**
             * Returns a device by id
             * @param title {string}
             * @returns {module:xcf/model/Device|null}
             */
            getDeviceByName: function (title, store) {
                var self = this;

                function search(_store) {
                    var items = utils.queryStore(_store, {
                        isDir: false
                    });

                    if (items._S) {
                        items = [items];
                    }
                    for (var i = 0; i < items.length; i++) {
                        var device = items[i];
                        var _id = self.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_TITLE);
                        if (_id == title) {
                            return device;
                        }
                    }
                    return null;
                }

                var _store = _.isString(store) ? this.getStore(store) : null;
                if (_store) {
                    return search(_store);
                } else {
                    for (var scope in this.stores) {
                        var item = search(this.stores[scope]);
                        if (item) {
                            return item;
                        }
                    }
                }
                return null;
            },
            /**
             * Returns all devices by driver id
             * @param id {string} the driver id
             * @returns {module:xcf/model/Device[]}
             */
            getDevicesByDriverId: function (id) {
                var items = utils.queryStore(this.getStore(), {
                    isDir: false
                });
                if (items._S) {
                    items = [items];
                }
                for (var i = 0; i < items.length; i++) {
                    var device = items[i];
                    var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                    if (_id == id) {
                        return device;
                    }
                }
                return null;
            },
            _cachedItems: null,
            getDeviceStoreItem: function (deviceInfo) {
                if (!deviceInfo) {
                    return;
                }

                if (deviceInfo.hash && this._cachedItems) {
                    var _cached = this._cachedItems[deviceInfo.hash];
                    if (_cached) {
                        return _cached;
                    }
                }

                //already device
                //if (deviceInfo && deviceInfo._store) {
                //return deviceInfo;
                //}
                var scope = deviceInfo.deviceScope;
                var store = this.getStore(scope);
                if (!store) {
                    return;
                }

                var byPath = deviceInfo.devicePath ? this.getItemByPath(deviceInfo.devicePath) : null;
                if (byPath) {
                    return byPath;
                }
                var items = _.filter(store.data, function (item) {
                    return item.isDir !== true;
                });
                if (!items) {
                    _debug && !isServer && console.error('store returned nothing ' + deviceInfo.deviceScope);
                    return null;
                }
                if (items && !_.isArray(items)) {
                    items = [items];
                }
                for (var i = 0; i < items.length; i++) {
                    var device = items[i],
                        meta = device['user'],
                        host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                        port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                        id = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_ID),
                        protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);

                    if (port === deviceInfo.port &&
                        host === deviceInfo.host &&
                        protocol === deviceInfo.protocol &&
                        device.isServer() === deviceInfo.isServer &&
                        id === deviceInfo.id) {

                        var deviceStoreItem = store.getSync(device.path);
                        if (deviceStoreItem) {
                            device = deviceStoreItem;
                        }

                        if (deviceInfo.hash) {
                            if (!this._cachedItems) {
                                this._cachedItems = {};
                            }
                            this._cachedItems[deviceInfo.hash] = device;
                        }
                        return device;
                    }
                }
            },
            /**
             *
             * @param ci
             * @param storeRef
             * @private
             */
            onDriverSettingsChanged: function (ci, storeRef) {
                for (var i in this.deviceInstances) {

                    var instance = this.deviceInstances[i];
                    //get settings, if not cached already
                    if (instance && instance.driver == storeRef) {
                        //pick driver
                        var driver = storeRef;// this.ctx.getDriverManager().getItemById(instance.options.id);//driverStore item
                        var meta = driver['user'];
                        var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                        if (commandsCI && commandsCI['params'] && commandsCI == ci) {
                            instance.sendSettings = utils.getJson(commandsCI['params']);
                        }
                        var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                        if (responseCI && responseCI['params']) {
                            instance.responseSettings = utils.getJson(responseCI['params']);
                        }
                        break;
                    }
                }
            },
            /**
             * @private
             */
            onDeviceStateChanged: function (item, silent) {
                if (item._userStopped !== true && silent !== true && item.info && item.state && item.state == types.DEVICE_STATE.DISCONNECTED) {
                    this.ctx.getNotificationManager().postMessage({
                        message: 'Lost connection to ' + item.info.host + ', ...reconnecting',
                        type: 'error',
                        showCloseButton: false,
                        duration: 1500
                    });
                }
                if (silent !== true && item.info && item.state && item.state == types.DEVICE_STATE.CONNECTED) {
                    this.ctx.getNotificationManager().postMessage({
                        message: 'Connected to ' + item.info.host + '',
                        type: 'success',
                        showCloseButton: false,
                        duration: 2000
                    });
                }
            },
            /**
             *
             * @param item
             * @returns {*}
             * @private
             */
            connectDevice: function (item) {
                this.checkDeviceServerConnection();
                var cInfo = this.toDeviceControlInfo(item);
                if (!cInfo) {
                    console.error('couldnt start device, invalid control info');
                    return;
                }
                var hash = cInfo.hash;
                if (this.deviceInstances[hash]) {
                    _debugConnect && console.log('device already connected', cInfo);
                    item.setState(types.DEVICE_STATE.CONNECTED);
                    return this.deviceInstances[hash];
                }
                item.setState(types.DEVICE_STATE.CONNECTING);
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: 'Trying to connect to ' + cInfo.toString(),
                    type: 'info'
                });
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo);
            },
            /**
             * client application ready, mixin instances and block scopes
             * @param evt
             * @private
             */
            onAppReady: function (evt) {
                var appContext = evt.context;
                appContext.deviceManager = this;
                appContext.driverManager = this;
                if (appContext.blockManager) {
                    utils.mixin(appContext.blockManager.scopes, this.ctx.getBlockManager().scopes);
                }
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Server methods (NodeJs)
            //
            /////////////////////////////////////////////////////////////////////////////////////

            /**
             * @private
             */
            onHaveNoDeviceServer: function () {
                if (!this.ctx.getNotificationManager()) {
                    return;
                }
                var thiz = this;
                var msg = this.ctx.getNotificationManager().postMessage({
                    message: 'Have no device server connection',
                    type: 'error',
                    showCloseButton: true,
                    duration: 1500,
                    actions: {
                        reconnect: {
                            label: 'Reconnect',
                            action: function () {
                                thiz.checkDeviceServerConnection();
                                return msg.update({
                                    message: 'Reconnecting...',
                                    type: 'success',
                                    actions: false,
                                    duration: 1500
                                });
                            }
                        }
                    }
                });
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Server methods (PHP)
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /***
             * setDriverScriptContent is storing a driver's actual code in a given scope on the server
             * @param scope {string}
             * @param path  {string}
             * @param content  {string}
             * @param readyCB   {function}
             * @param errorCB   {function}
             * @returns {*}
             * @private
             */
            setDriverScriptContent: function (scope, path, content, readyCB, errorCB) {
                return this.callMethodEx(null, 'setDriverContent', [scope, path, content], readyCB, true);
            },
            /***
             * getDriverScriptContent is receiving a driver's actual code in a given scope
             * @param scope {string}
             * @param path  {string}
             * @param readyCB   {function}
             * @returns {*}
             */
            getDriverScriptContent: function (scope, path, readyCB) {
                return this.callMethodEx(null, 'getDriverContent', [scope, path], readyCB, true);
            },
            /**
             *
             * @param data
             * @param scope
             * @param track
             */
            createStore: function (data, scope, track) {
                var storeClass = has('xcf-ui') ? declare('deviceStore', [TreeMemory, Trackable, ObservableStore], {}) : declare('deviceStore', [Memory], {}),
                    self = this;
                var store = new storeClass({
                    data: data.items,
                    idProperty: 'path',
                    parentProperty: 'parentId',
                    Model: Device,
                    id: utils.createUUID(),
                    scope: scope,
                    ctx: this.getContext(),
                    mayHaveChildren: function (parent) {
                        if (parent._mayHaveChildren === false) {
                            return false;
                        }
                        if (parent.isDevice) {
                            var device = parent;
                            if (device.driverInstance) {
                                return true;
                            }
                            //no instance yet
                            var info = self.toDeviceControlInfo(device);
                            if (info) {
                                var driver = self.getContext().getDriverManager().getDriverById(info.driverId);
                                if (driver) {
                                    if (!driver.blockScope && has('xblox')) {
                                        this.ctx.getDriverManager().createDriverBlockScope(driver);
                                        self.completeDevice(device, driver);
                                    }
                                    return true;
                                }
                            } else {
                                console.error('cant get device info for ', device);
                            }

                        }
                        return true;
                    },
                    observedProperties: [
                        "name",
                        "state",
                        "iconClass",
                        "enabled"
                    ]
                });

                if (scope && track !== false) {
                    this.setStore(scope, store);
                }
                return store;
            },
            /**
             *
             * @param data
             * @param scope
             * @param track
             * @returns {exports|module.exports|module:xide/data/_Base}
             * @private
             */
            initStore: function (data, scope, track) {
                return this.createStore(data, scope, track);
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Utils
            //
            /////////////////////////////////////////////////////////////////////////////////////
            _deviceInfoCache: null,
            /**
             * Return handy info for a device
             * @param {module:xcf/model/Device|null} item
             * @returns {module:xide/types~DeviceInfo|null}
             */
            toDeviceControlInfo: function (item) {
                if (!item) {
                    return null;
                }
                var hash = item.hash;
                if (!has('xcf-ui') && hash && !has('host-node')) {
                    if (this._deviceInfoCache[hash]) {
                        return this._deviceInfoCache[hash];
                    }
                }
                if (!item._store && item.id) {
                    var _item = this.getItemById(item.id);
                    if (_item) {
                        item = _item;
                    }
                }
                if (!item || !item.path) {
                    _debug && console.error('not a device');
                    var _item = this.getDeviceStoreItem(item);
                    if (!_item) {
                        return null;
                    }
                }
                _debug && !item && console.error('toDeviceControlInfo: invalid device item');
                _debug && !item.user && console.error('toDeviceControlInfo: invalid device item, has no meta');
                var meta = item['user'],
                    host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                    port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                    enabled = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_ENABLED),
                    title = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_TITLE),
                    protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL),
                    driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                    options = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_OPTIONS),
                    loggingFlags = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS),
                    driverOptions = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS),
                    serverSide = item.isServerSide(),
                    isServer = item.isServer(),
                    result = null;

                this.fixDeviceCI(item);
                var driver = this.ctx.getDriverManager().getDriverById(driverId);
                if (driver) {
                    var driverMeta = driver['user'],
                        script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS),
                        responseCI = utils.getCIByChainAndName(driverMeta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES),
                        responseSettings = {},
                        driverScope = driver['scope'];

                    if (responseCI && responseCI['params']) {
                        responseSettings = utils.getJson(responseCI['params']);
                    }
                    result = {
                        host: host,
                        port: port,
                        protocol: protocol,
                        driver: script ? script.replace('./', '') : '',
                        driverId: driverId,
                        driverScope: driverScope,
                        id: item.id,
                        devicePath: item.path,
                        deviceScope: item.getScope(),
                        title: title,
                        options: options,
                        enabled: enabled,
                        driverOptions: driverOptions,
                        serverSide: serverSide,
                        isServer: isServer,
                        responseSettings: responseSettings,
                        source: isIDE ? 'ide' : 'server',
                        user_devices: this.ctx.getMount(item.getScope()),
                        system_devices: this.ctx.getMount('system_devices'),
                        system_drivers: this.ctx.getMount('system_drivers'),
                        user_drivers: this.ctx.getMount('user_drivers'),
                        loggingFlags: loggingFlags,
                        toString: function () {
                            return item.getScope() + '://' + this.host + ':' + this.port + '@' + this.protocol;
                        }
                    };

                    result.hash = MD5(JSON.stringify({
                        host: host,
                        port: port,
                        protocol: protocol,
                        driverId: driverId,
                        driverScope: driverScope,
                        id: item.id,
                        devicePath: item.path,
                        deviceScope: item.getScope(),
                        source: isIDE ? 'ide' : 'server',
                        user_devices: this.ctx.getMount(item.getScope()),
                        system_devices: this.ctx.getMount('system_devices'),
                        system_drivers: this.ctx.getMount('system_drivers'),
                        user_drivers: this.ctx.getMount('user_drivers')
                    }), 1);
                    var userDirectory = this.ctx.getUserDirectory();
                    if (userDirectory) {
                        result.userDirectory = userDirectory;
                    }
                } else {
                    _debug && console.error('cant find driver ' + driverId + ' for ' + item.toString());
                }
                item.info = result;
                if (!has('xcf-ui') && hash && !has('host-node')) {
                    this._deviceInfoCache[hash] = result;
                }

                return result;
            },
            /**
             * Return device model item by device id
             * @param itemId
             * @returns {module:xcf/model/Device} The device
             */
            getItemById: function (itemId) {
                function search(store) {
                    var data = store.data;
                    var device = _.find(data, {
                        id: itemId
                    });
                    if (!device) {
                        return null;
                    }
                    return store.getSync(device.path);
                }

                for (var scope in this.stores) {
                    var store = this.stores[scope];
                    var result = search(store);
                    if (result) {
                        return result;
                    }
                }
                _debug && console.error('Device Manager::getItemById : cant find device with id: ' + itemId);
            },
            /**
             *
             * @param evt
             * @private
             */
            onStoreCreated: function (evt) {
                var thiz = this,
                    ctx = thiz.ctx,
                    type = evt.type,
                    store = evt.store,
                    items = store ? utils.queryStore(store, { isDir: false }) : [],
                    driverManager = this.ctx.getDriverManager();

                if (items && !_.isArray(items)) {
                    items = [items];
                }

                if (type !== types.ITEM_TYPE.DEVICE) {
                    return;
                }
                for (var i = 0; i < items.length; i++) {
                    var item = store.getSync(items[i].path);
                    if (!item) {
                        console.error('cant find ' + items[i].path);
                        continue;
                    }
                    if (item._completed) {
                        continue;
                    }

                    item._completed = true;
                    item.isDevice = true;
                    var driverId = this.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                    if (!driverId) {
                        console.error('device has no driver id!');
                        continue;
                    }
                    var driver = driverManager.getItemById(driverId),
                        CIS = item.user;

                    //complete CIS
                    _.each(CIS.inputs, function (ci) {
                        ci.device = item;
                        ci.actionTarget = isIDE ? ctx.mainView.getToolbar() : null;
                        ci.ctx = ctx;
                    });
                    if (!_.isEmpty(driver)) {
                        if (isIDE) {
                            this.completeDevice(item, driver);
                            item.iconClass = item.getStateIcon();
                        }
                    }
                }
                all(this.connectToAllDevices()).then(function () {
                    thiz.publish('DevicesConnected', evt);
                });

            },
            /**
             *
             * indirect callback for ON_SERVER_LOG_MESSAGE which tells the device server to
             * log something for us. This might be triggered by xblox/model/logging/Log
             *
             * @param evt {object}
             * @param evt.data {object}
             * @param evt.data.device {module:xide/types~DeviceInfo|null}
             * @param evt.data.details {array}
             * @param evt.data.time {integer}
             * @param evt.data.type {string}
             * @param evt.data.level {string}
             */
            onClientMessage: function (evt) {
                this.checkDeviceServerConnection();
                if (this.deviceServerClient) {
                    _debugLogging && console.log('WRITE_LOG_MESSAGE ', evt);
                    this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.WRITE_LOG_MESSAGE, evt);
                }
            },
            /**
             *
             * @param evt
             */
            onClientLogMessage: function (evt) {
                if (!isServer) {
                    this.onClientMessage(evt);
                }
            },
            /**
             *
             * @param evt
             * @private
             */
            onVariableChanged: function (evt) {
                var variable = evt.item,
                    scope = evt.scope,
                    name = variable.name,
                    publish = evt.publish !== false;
                //_debugMQTT && console.log('DeviceManager/onVariableChanged/variable changed: '+name + ' - publish : ' + publish);

                if (name === 'value' || publish === false || !variable) {
                    return;
                }

                var value = variable.value,
                    driver = scope.driver,
                    device = scope.device;

                if (device && device.info) {
                    var deviceInfo = device.info,
                        mqttTopic = deviceInfo.host + '/' + deviceInfo.port + '/Variable/' + name;
                    _debugMQTT && evt.publishMQTT !== false && console.log('send mqtt message ' + mqttTopic);
                    evt.publishMQTT !== false && this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MQTT_PUBLISH, {
                        topic: mqttTopic,
                        data: {
                            value: value,
                            device: deviceInfo
                        }
                    });
                } else {
                    _debugMQTT && console.warn('onVariableChanged->MQTT : have no device');
                }
                //_debugMQTT && console.info('on variable changed ' + device.toString());
            },
            /***
             * Common manager function, called by the context of the application
             * @private
             */
            init: function () {
                var thiz = this;
                if (this.initUI) {
                    this.initUI();
                }
                this.stores = {};
                this._deviceInfoCache = {};
                this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, this.onVariableChanged);
                this.subscribe(types.EVENTS.ON_DEVICE_SERVER_CONNECTED, function () {
                    console.log('got device server connection');
                    var connect = has('drivers') && has('devices');
                    if (thiz.autoConnectDevices && connect) {
                        all(thiz.connectToAllDevices()).then(function () {
                            thiz.publish('DevicesConnected');
                        });
                    }
                });
                this.subscribe([
                    EVENTS.ON_NODE_SERVICE_STORE_READY,
                    EVENTS.ON_MODULE_RELOADED,
                    EVENTS.ON_DEVICE_DISCONNECTED,
                    EVENTS.ON_DEVICE_CONNECTED,
                    EVENTS.ON_CLIENT_LOG_MESSAGE,
                    EVENTS.ON_STORE_CREATED
                ]);
                this.deviceInstances = this.consoles = {};
                this.driverScopes = {
                    "system_drivers": "system_drivers/",
                    "user_drivers": "user_drivers/"
                };
                this.lastUpTime = (new Date()).getTime();
                setInterval(function () {
                    var current = (new Date()).getTime();
                    if (current - thiz.lastUpTime > 30000) {
                        thiz.lastUpTime = (new Date()).getTime();
                    }
                    thiz.lastUpTime = current;
                }, 1000);

                this.initReload();

            },
            onDeviceServerConnected: function () {
                var self = this;
                if (this.deviceInstances) {
                    _.each(this.deviceInstances, function (instance) {
                        if (instance && instance.device && !instance.domNode) {
                            var device = instance.device;
                            self.startDevice(device);
                        }
                    });
                }
            },
            //nulled in server mode
            addDeviceInstance: function (device, driver) {
            },
            /***
             * ls is enumerating all drivers in a given scope
             * @param scope {string}
             * @param track {boolean=true}
             * @returns {Deferred}
             */
            ls: function (scope, track) {
                var dfd = new Deferred();

                function data(data) {
                    try {
                        var store = this.createStore(data, scope, track);
                        //track !== false && this.setStore(scope, store);
                        this.onStoreReady(store);
                        track !== false && this.publish(types.EVENTS.ON_STORE_CREATED, {
                            data: data,
                            owner: this,
                            store: store,
                            type: this.itemType
                        });
                        dfd.resolve(store);

                    } catch (e) {
                        logError(e, 'error ls drivers');
                    }
                }

                if (this.prefetch && this.prefetch[scope]) {
                    data.apply(this, [this.prefetch[scope]]);
                    delete this.prefetch[scope];
                    return dfd;
                }

                if (has('php')) {
                    this.runDeferred(null, 'ls', [scope]).then(data.bind(this));
                } else {
                    if (!isServer) {
                        this._getText(require.toUrl(scope).replace('main.js', '') + scope + '.json', {
                            sync: false,
                            handleAs: 'json'
                        }).then(data.bind(this));
                    } else {
                        dfd.resolve({ items: [] });
                    }
                }
                return dfd;
            },
            /**
             *
             * @param scope
             * @returns {*}
             */
            hasStore: function (scope) {
                return this.stores[scope];
            },
            /**
             * @param item {module:xcf/model/Device}
             * @private
             */
            fixDeviceCI: function (item) {
                var DEVICE_PROPERTY = types.DEVICE_PROPERTY;
                var meta = item['user'];
                var driverOptions = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
                if (!driverOptions) {
                    meta.inputs.push({
                        "chainType": 0,
                        "class": "cmx.types.ConfigurableInformation",
                        "dataRef": "",
                        "dataSource": "",
                        "description": null,
                        "enabled": true,
                        "enumType": "-1",
                        "flags": -1,
                        "group": 'Common',
                        "id": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                        "name": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                        "order": 1,
                        "params": null,
                        "platform": null,
                        "title": "Driver Options",
                        "type": 5,
                        "uid": "-1",
                        "value": 0,
                        "data": [
                            {
                                value: 2,
                                label: 'Runs Server Side'
                            },
                            {
                                value: 4,
                                label: 'Show Debug Messages'
                            },
                            {
                                value: 8,
                                label: 'Allow Multiple Device Connections'
                            },
                            {
                                value: 16,
                                label: 'Server'
                            }

                        ],
                        "visible": true,
                        "device": item
                    });
                } else {
                    driverOptions.data = [
                        {
                            value: 2,
                            label: 'Runs Server Side'
                        },
                        {
                            value: 4,
                            label: 'Show Debug Messages'
                        },
                        {
                            value: 8,
                            label: 'Allow Multiple Device Connections'
                        },
                        {
                            value: 16,
                            label: 'Server'
                        }

                    ];

                    driverOptions.group = 'Common';
                }


                var loggingFlags = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS);
                if (!loggingFlags) {
                    meta.inputs.push({
                        "chainType": 0,
                        "class": "cmx.types.ConfigurableInformation",
                        "dataRef": "",
                        "dataSource": "",
                        "description": null,
                        "enabled": true,
                        "enumType": "-1",
                        "flags": -1,
                        "group": 'Logging',
                        "id": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                        "name": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                        "order": 1,
                        "params": null,
                        "platform": null,
                        "title": "Logging Flags",
                        "type": DEVICE_PROPERTY.CF_DEVICE_LOGGING_FLAGS,
                        "uid": "-1",
                        "value": 0,
                        "data": [
                            {
                                value: 2,
                                label: 'On Connected'
                            },
                            {
                                value: 4,
                                label: 'On Disconnected'
                            },
                            {
                                value: 8,
                                label: 'On Error'
                            },
                            {
                                value: 16,
                                label: 'Commands'
                            },
                            {
                                value: 32,
                                label: 'Responses'
                            }
                        ],
                        "visible": true,
                        "device": item
                    });
                } else {
                    loggingFlags.group = "Logging";
                }


                var protocolCI = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);
                if (protocolCI) {
                    protocolCI.type = 3;
                    protocolCI.options = [
                        {
                            label: "TCP",
                            value: "tcp"
                        },
                        {
                            label: "UDP",
                            value: "udp"
                        },
                        {
                            label: "Driver",
                            value: "driver"
                        },
                        {
                            label: "SSH",
                            value: "ssh"
                        },
                        {
                            label: "Serial",
                            value: "serial"
                        },
                        {
                            label: "MQTT",
                            value: "mqtt"
                        }
                    ];
                }

                if (!item.id) {
                    item.id = utils.getCIInputValueByName(meta, types.DEVICE_PROPERTY.CF_DEVICE_ID);
                }

                var optionsCI = utils.getCIByChainAndName(meta, 0, types.DEVICE_PROPERTY.CF_DEVICE_OPTIONS);
                if (!optionsCI) {
                    meta.inputs.push({
                        "chainType": 0,
                        "class": "cmx.types.ConfigurableInformation",
                        "dataRef": "",
                        "dataSource": "",
                        "description": null,
                        "enabled": true,
                        "enumType": "-1",
                        "flags": -1,
                        "group": 'Network',
                        "id": "options",
                        "name": "options",
                        "order": 1,
                        "params": null,
                        "platform": null,
                        "title": "Options",
                        "type": 28,
                        "uid": "-1",
                        "value": {},
                        "visible": true,
                        "device": item

                    });
                } else {
                    optionsCI.device = item;
                }
            }
        });
    });
;
define('xide/console',[], function () {
    return typeof window !=='undefined' ? window.console : typeof global !=='undefined' ? global.console : {

    }
});;
/** @module xcf/mixins/LogMixing **/
define('xcf/mixins/LogMixin',[
    "dcl/dcl",
    'xcf/types/Types',
    'xide/utils'
], function (dcl, types, utils) {
    var DEFAULT_LOGGING_FLAGS = types.DEFAULT_DEVICE_LOGGING_FLAGS;
    var Module = dcl(null, {
        /**
         *
         * @param deviceInfo {module:xide/types~DeviceInfo}
         * @param flag {LOGGING_FLAGS}
         * @param source {DEVICE_LOGGING_SOURCE}
         * @returns {boolean}
         */
        hasFlagEx: function (deviceInfo, flag, source) {
            var LOGGING_FLAGS = types.LOGGING_FLAGS,
                OUTPUT = types.LOG_OUTPUT,
                flags = deviceInfo.loggingFlags;
            flags = _.isString(flags) ? utils.fromJson(flags) : flags || {};

            var _flag = flags[source] ? flags[source] : DEFAULT_LOGGING_FLAGS[source];
            if (_flag == null) {
                return false;
            }

            if (!(_flag & flag)) {
                return false;
            }

            return true;
        }
    });
    Module.DEFAULT_LOGGING_FLAGS = DEFAULT_LOGGING_FLAGS;
    return Module;
});;
/** @module xcf/manager/DeviceManager_DeviceServer */
define('xcf/manager/DeviceManager_DeviceServer',[
    'dcl/dcl',
    'xide/encoding/MD5',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xdojo/has',
    'dojo/Deferred',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    'require',
    'xide/lodash',
    'xcf/model/Variable',
    'xide/utils/HexUtils',
    'xdojo/has!host-node?nxapp/utils/_console'
], function (dcl, MD5, types, utils, factory, has, Deferred, ReloadMixin, EventedMixin, require, _, Variable, HexUtils, _console) {

    var console = typeof window !== 'undefined' ? window.console : typeof global !== 'undefined' ? global.console : _console;
    if (_console) {
        console = _console;
    }
    var isServer = has('host-node'),
        isIDE = has('xcf-ui'),
        runDrivers = true;


    /*
     var console = typeof window !== 'undefined' ? window.console : console;
     if(_console && _console.error && _console.warn){
     //console = _console;
     }
     */

    //debug mqtt activity
    var _debugMQTT = false;
    //debug device - server messages
    var debug = false;
    // debug device server connectivity
    var debugDevice = false;
    var debugStrangers = false;
    var debugConnect = false;
    var debugServerCommands = false;
    var debugCreateInstance = false;
    var debugServerMessages = false;
    var debugByteMessages = false;



    if (typeof sctx !== 'undefined' && sctx && !isServer) {

        var id = utils.createUUID();
        var rm = sctx.getResourceManager();
        var ctx = sctx;
        var application = sctx.getApplication();
        var doExport = false;
        if(!doExport){
            return;
        }


        console.log('root : ' + ctx.getMount('root'));
        console.log('user : ' + rm.getVariable('USER_DIRECTORY'));
        console.log('system : ' + rm.getVariable('SYSTEM'));

        var ROOT = ctx.getMount('root');
        var USER = rm.getVariable('USER_DIRECTORY');
        var SYSTEM = ROOT + '/data/';
        var DIST = ROOT + '/server/nodejs/dist/';
        var TARGET = ROOT + '/mc007/';
        var linux32 = false;
        var linux64 = true;
        var osx = false;
        var arm = false;
        var windows = false;



        var options = {
            linux32: linux32,
            linux64: linux64,
            osx: osx,
            arm: arm,
            windows: windows,
            root: ROOT,
            system: SYSTEM,
            user: USER + '/',
            nodeServers: DIST,
            target: TARGET,
            debug: true,
            layout: has('debug') ? 'debug' : 'release',
            platform: rm.getVariable('PLATFORM')
        };
        console.log('options', options);
        var delegate = {
            onError: function (e) {
                console.error('have error : ', e);
            },
            onProgress: function (e) {
                console.info('have progress: ', e);
            },
            onFinish: function (e) {
                console.info('have finish: ', e);
            }
        };
        sctx.getDeviceManager().runAppServerClass('components/xideve/export/Exporter', {
            options: options
        }, delegate);


    }
    /***
     *
     * 1. startDevice
     *      ->createDriverInstance
     *          -> sendManagerCommand(CREATE_CONNECTION, cInfo);
     *              ->onDeviceConnected
     *                  serverVariables? ->
     *                      getDeviceServerVariables ->onSetDeviceServerVariables
     *
     *
     */

    /**
     *
     * @class module:xcf.manager.DeviceManager_DeviceServer
     * @augments module:xcf/manager/DeviceManager
     * @augments module:xide/mixins/EventedMixin
     */
    var Module = dcl(null, {
        declaredClass: "xcf.manager.DeviceManager_DeviceServer",
        running: null,
        /**
         * Callback when we are connected to a device.
         * We use this to fire all looping blocks
         * @param driverInstance {module:xcf/driver/DriverBase} the instance of the driver
         * @param deviceStoreItem {module:xcf/model/Device} the device model item
         * @param driver {module:xcf/model/Driver} the driver model item
         */
        onDeviceStarted: function (driverInstance, deviceStoreItem, driver) {
            if (!driverInstance || !deviceStoreItem || !driver) {
                debugConnect && console.log('onDeviceStarted failed, invalid params');
                return;
            }

            var info = this.toDeviceControlInfo(deviceStoreItem),
                serverSide = info.serverSide,
                _isServer = info.isServer;

            debugConnect && console.log('onDeviceStarted ' + info.toString(), driverInstance.id);

            //1. fire startup blocks
            var blockScope = driverInstance.blockScope;

            if (((isServer && (serverSide || _isServer)) || (!serverSide && !_isServer))) {
                blockScope.start();
            }
            //important to set this before publishing the connected event, otherwise it runs an infity loop
            driverInstance.__didStartBlocks = true;
            this.publish(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, {
                device: deviceStoreItem,
                instance: driverInstance,
                driver: driver,
                blockScope: blockScope
            });
            this.publish(types.EVENTS.ON_DEVICE_CONNECTED, {
                device: info,
                instance: driverInstance,
                driver: driver,
                blockScope: blockScope
            });
            this.ctx.getDriverManager().addDeviceInstance(deviceStoreItem, driver);
        },
        runClass: function (_class, args, delegate) {
            this.checkDeviceServerConnection();
            if (this.deviceServerClient) {
                var id = utils.createUUID();
                args.id = id;
                var dataOut = {
                    "class": _class,
                    args: args,
                    manager_command: types.SOCKET_SERVER_COMMANDS.RUN_CLASS
                };
                !this.running && (this.running = {});
                this.running[id] = {
                    "class": _class,
                    args: args,
                    delegate: delegate
                };
                this.deviceServerClient.emit(null, dataOut, types.SOCKET_SERVER_COMMANDS.RUN_CLASS);
            } else {
                this.onHaveNoDeviceServer();
            }
        },
        runAppServerClass: function (_class, args, delegate) {
            this.checkDeviceServerConnection();
            if (this.deviceServerClient) {
                var id = utils.createUUID();
                args.id = id;
                var dataOut = {
                    "class": _class,
                    args: args,
                    manager_command: types.SOCKET_SERVER_COMMANDS.RUN_APP_SERVER_CLASS
                };
                !this.running && (this.running = {});
                this.running[id] = {
                    "class": _class,
                    args: args,
                    delegate: delegate
                };
                this.deviceServerClient.emit(null, dataOut, types.SOCKET_SERVER_COMMANDS.RUN_APP_SERVER_CLASS);
            } else {
                this.onHaveNoDeviceServer();
            }
        },
        /**
         * Starts a device with a device store item
         * @param device
         * @param force
         */
        startDevice: function (device, force) {
            var thiz = this;
            if (!device) {
                console.error('start device invalid item');
                return null;
            }
            this.checkDeviceServerConnection();
            device.check();
            debugDevice = true;
            var dfd = new Deferred();
            if (device._startDfd && !device._startDfd.isResolved()) {
                if (!isServer) {
                    debugDevice && console.error('already starting ' + device.toString());
                    return device._startDfd;
                }
            } else {
                !device.driverInstance && device.reset();//fresh
            }

            force === true && device.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED, true, false);
            var enabled = device.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED);
            if (!enabled && force !== true && !isServer) {
                debugDevice && console.error('---abort start device : device is not enabled!' + device.toString());
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: 'Can`t start device because its not enabled! ' + device.toString(),
                    type: 'error'
                });
                setTimeout(function () {
                    dfd.reject();
                }, 10);
                return dfd;
            }

            var cInfo = this.toDeviceControlInfo(device);
            if (!cInfo) {
                console.error('invalid client info, assuming no driver found');
                dfd.reject('invalid client info, assuming no driver found');
                return dfd;
            }

            if (!cInfo) {
                console.error('couldnt start device, invalid control info ' + cInfo.toString());
                dfd.reject();
                return dfd;
            }

            var hash = cInfo.hash;
            var state = device.state;
            var wasLost = state === types.DEVICE_STATE.LOST_DEVICE_SERVER;
            if (this.deviceInstances[hash] && wasLost !== true) {
                debugDevice && console.warn('device already started : ' + cInfo.toString());
                dfd.resolve(this.deviceInstances[hash]);
                return dfd;
            }

            function buildMQTTParams(cInfo, driverInstance, deviceItem, driverItem) {
                if (!driverInstance) {
                    console.warn('buildMQTTParams:have no driver instance');
                }
                return {
                    driverScopeId: driverInstance && driverInstance.blockScope ? driverInstance.blockScope.id : 'have no driver instance',
                    driverId: driverInstance ? driverInstance.driver.id : 'have no driver id',
                    deviceId: device.path
                };
            }

            if (wasLost && this.deviceInstances[hash]) {
                thiz.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: 'Trying to re-connect to ' + cInfo.toString(),
                    type: 'info'
                });
                thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.CREATE_CONNECTION, cInfo);
                device.setState(types.DEVICE_STATE.CONNECTING);
                dfd.resolve(this.deviceInstances[hash]);
                return dfd;

            }

            device.setState(types.DEVICE_STATE.CONNECTING);
            device._userStopped = null;
            device._startDfd = dfd;
            var baseDriverPrefix = this.driverScopes['system_drivers'],
                baseDriverRequire = baseDriverPrefix + 'DriverBase';

            try {
                require([baseDriverRequire], function (baseDriver) {
                    baseDriver.prototype.declaredClass = baseDriverRequire;
                    var sub = thiz.createDriverInstance(cInfo, baseDriver, device).then(function (driverInstance) {
                        if (!driverInstance.id) {
                            driverInstance.id = utils.createUUID();
                        }
                        debugCreateInstance && console.info('created driver instance for ' + cInfo.toString());
                        cInfo.mqtt = buildMQTTParams(cInfo, driverInstance, device);
                        thiz.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                            text: 'Trying to connect to ' + cInfo.toString(),
                            type: 'info'
                        });

                        if (!isServer) {
                            if (!device.isServerSide() && !device.isServer()) {
                                thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.CREATE_CONNECTION, cInfo);
                            } else {
                                thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.START_DEVICE, cInfo);
                            }
                        } else {
                            //we're already starting
                            if (device._startDfd && !device._startDfd.isResolved()) {
                                thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.CREATE_CONNECTION, cInfo);
                            } else {
                                thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.START_DEVICE, cInfo);
                            }
                        }
                        dfd.resolve(thiz.deviceInstances[hash]);
                        delete cInfo.mqtt;
                    });
                    sub.then(function () {

                    }, function (e) {
                        debugCreateInstance && console.error('DeviceManager_DeviceServer::createDriverInstance error ', e);
                        dfd.resolve(null);
                    });
                }, function (e) {
                    console.error(e);
                });
            } catch (e) {
                logError(e, 'DeviceManager::startDevice: requiring base driver at ' + baseDriverRequire + ' failed! Base Driver - Prefix : ' + baseDriverPrefix);
            }

            return dfd;
        },
        /**
         * Creates a driver instance per device
         * @param deviceInfo {module:xide/types~DeviceInfo} The device info
         * @param driverBase {module:xcf/driver/DriverBase} The driver base class
         * @param device {module:xcf/model/Device} The device model item
         */
        createDriverInstance: function (deviceInfo, driverBase, device) {
            var hash = deviceInfo.hash,
                driverPrefix = this.driverScopes[deviceInfo.driverScope],
                isRequireJS = !require.cache,
                packageUrl = require.toUrl(driverPrefix);

            packageUrl = utils.removeURLParameter(packageUrl, 'bust');

            if (isRequireJS) {
                packageUrl = packageUrl.replace('/.js', '/');
            }

            var requirePath = decodeURIComponent(packageUrl) + deviceInfo.driver;
            requirePath = requirePath.replace('', '').trim();

            function updateDevice(device, deviceInfo) {

            }

            if (isServer) {
                updateDevice(device, deviceInfo);

            }

            var thiz = this,
                ctx = thiz.ctx,
                meta = device['user'],
                driverId = utils.getCIInputValueByName(meta, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                driverManager = ctx.getDriverManager(),
                driver = driverManager.getDriverById(driverId),
                dfd = new Deferred(),
                enabled = device.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED),
                serverSide = deviceInfo.serverSide;

            debugCreateInstance && console.log('create driver instance : ' + device.path + ":" + device.scope + ' from ' + requirePath, {
                driver: driver,
                device: device,
                deviceInfo: deviceInfo
            });

            if (device.isEnabled() === false && !isServer) {
                debugConnect && console.warn('device not enabled, abort ' + deviceInfo.toString());
                setTimeout(function () {
                    dfd.reject('device not enabled, abort ' + deviceInfo.toString());
                });
                return dfd;
            }

            if (isServer && (!device.isServerSide() && !device.isServer() && !deviceInfo.isServer && !deviceInfo.serverSide)) {
                var e = new Error();
                dfd.reject('DeviceManager_DeviceServer: wont create driver instance! I am server and device isnt server side : ' + deviceInfo.title);
                return dfd;
            }


            debugCreateInstance && console.info('------create driver instance with DriverBase at ' + requirePath + ' with driver prefix : ' + driverPrefix, this.driverScopes);

            try {
                driverManager.getDriverModule(driver).then(function (driverModule) {
                    var baseClass = driverBase;
                    var driverProto = dcl([baseClass, EventedMixin.dcl, ReloadMixin.dcl, driverModule], {});
                    var driverInstance = new driverProto();
                    driverInstance.declaredClass = requirePath;
                    driverInstance.options = deviceInfo;
                    driverInstance.baseClass = baseClass.prototype.declaredClass;
                    driverInstance.modulePath = utils.replaceAll('//', '/', driverPrefix + deviceInfo.driver).replace('.js', '');
                    driverInstance.delegate = thiz;
                    driverInstance.driver = driver;
                    driverInstance.serverSide = deviceInfo.serverSide;
                    driverInstance.utils = utils;
                    driverInstance.types = types;
                    driverInstance.device = device;
                    driverInstance.Module = driverModule;
                    driverInstance.id = utils.createUUID();
                    driverInstance.getDevice = function () {
                        return this.device;
                    };
                    driverInstance.getDeviceInfo = function () {
                        return this.getDevice().info;
                    };
                    var meta = driver['user'];
                    var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                    if (commandsCI && commandsCI['params']) {
                        driverInstance.sendSettings = utils.getJson(commandsCI['params']);
                    }

                    var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                    if (responseCI && responseCI['params']) {
                        driverInstance.responseSettings = utils.getJson(responseCI['params']);
                    }
                    try {
                        driverInstance.start();
                        driverInstance.initReload();
                    } catch (e) {
                        console.error('crash in driver instance startup! ' + device.toString());
                        logError(e, 'crash in driver instance startup!');
                    }

                    thiz.deviceInstances[hash] = driverInstance;
                    if (!driver.blox || !driver.blox.blocks) {
                        debugConnect && console.warn('Attention : INVALID driver, have no blocks', deviceInfo.toString());
                        driver.blox = {
                            blocks: []
                        };
                    }
                    device.driverInstance = driverInstance;
                    thiz.getDriverInstance(deviceInfo, true);//triggers to resolve settings
                    driverInstance._id = utils.createUUID();
                    dfd.resolve(driverInstance);
                    return driverInstance;

                });
            } catch (e) {
                console.error('DeviceManager::createDriverInstance:: requiring base driver at ' + requirePath + ' failed ' + e.message, utils.inspect(deviceInfo));
            }
            return dfd;
        },
        /**
         * Callback when server returns the variables of a device
         * @param data.device {module:xide/types~DeviceInfo}
         * @param data
         */
        onSetDeviceServerVariables: function (data) {
            var instance = this.getDriverInstance(data.device, true);
            var device = this.getDeviceStoreItem(data.device);
            if (!device) {
                debugDevice && console.log('did set device server variables failed, have no device', data);
                return;
            }

            if (!instance.blockScope) {
                var deviceInfo = device.info;
                var hash = deviceInfo.hash;
                var driver = instance.driver;
                var driverId = deviceInfo.driverId;
                var ctx = this.getContext();
                var serverSide = deviceInfo.serverSide;
                var scopeId = driverId + '_' + hash + '_' + device.path;
                if (!driver.blox || !driver.blox.blocks) {
                    debugConnect && console.warn('Attention : INVALID driver, have no blocks', deviceInfo.toString());
                    driver.blox = {
                        blocks: []
                    };
                }
                if (isServer && driver.blockPath) {
                    utils.getJson(utils.readFile(driver.blockPath));
                    driver.blox = utils.getJson(utils.readFile(driver.blockPath));
                }

                var scope = ctx.getBlockManager().createScope({
                    id: scopeId,
                    device: device,
                    driver: driver,
                    instance: instance,
                    serviceObject: this.serviceObject,
                    ctx: ctx,
                    serverSide: serverSide,
                    getContext: function () {
                        return this.instance;
                    }
                }, utils.clone(driver.blox.blocks), function (error) {
                    if (error) {
                        console.error(error + ' : in ' + driver.name + ' Resave Driver! in scope id ' + scopeId);
                    }
                });
                //important:
                instance.blockScope = scope;
                device.blockScope = scope;
                isIDE && this.completeDriverInstance(driver, instance, device);
            }

            if (instance) {
                var variables = data.variables,
                    _scope = instance.blockScope;
                device.serverVariables = data.variables;
                _.each(variables, function (variable) {
                    var _var = _scope.getVariable(variable.name);
                    if (_var) {
                        _var.value = variable.value;
                    }
                });
            }

            this.onDeviceConnected(data, false);
            device.setState(types.DEVICE_STATE.SYNCHRONIZING);
            device.setState(types.DEVICE_STATE.READY);
            device._startDfd && device._startDfd.resolve(device.driverInstance);
            delete device._userStopped;
            delete device.lastError;
            delete device._startDfd;
            device._startDfd = null;
        },
        /**
         *
         * @param device {module:xcf/model/Device}
         * @param driverInstance
         */
        getDeviceServerVariables: function (device, driverInstance) {
            var driver = driverInstance.driver;
            if (!driver.blox || !driver.blox.blocks) {
                debugConnect && console.warn('Attention : INVALID driver, have no blocks', device.toString());
                driver.blox = {
                    blocks: []
                };
            }
            var blocks = driver.blox.blocks;
            var basicVariables = [];
            _.each(blocks, function (block) {
                block.group === types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES && basicVariables.push(block);
            });
            var out = [];
            for (var i = 0; i < basicVariables.length; i++) {
                out.push({
                    name: basicVariables[i].name,
                    value: basicVariables[i].value,
                    initial: basicVariables[i].value
                });
            }
            device.setState(types.DEVICE_STATE.SYNCHRONIZING);
            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.GET_DEVICE_VARIABLES, {
                device: this.toDeviceControlInfo(device),
                variables: out
            });
        },
        /**
         *
         * @param data {Object}
         * @param data.device {module:xide/types~DeviceInfo}
         * @returns {*}
         */
        onDeviceConnected: function (data, setReadyState) {
            var deviceStoreItem = this.getDeviceStoreItem(data.device);
            if (data.isReplay && deviceStoreItem && deviceStoreItem.state === types.DEVICE_STATE.READY) {
                deviceStoreItem.setState(types.DEVICE_STATE.READY);
                return;
            }

            var instance = this.getDriverInstance(data.device, true) || data.instance;
            if (!instance) {
                debugStrangers && !isServer && console.error('--cant find device instance', this.deviceInstances);
                deviceStoreItem && deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
                return;
            }
            if (!deviceStoreItem) {
                debugDevice && console.error('onDeviceConnected:: deviceStoreItem is null');
                return;
            }

            //console.error('weird '+data.device.id + ' ' + data.device.state + ' ' + deviceStoreItem.isServerSide());

            var cInfo = this.toDeviceControlInfo(deviceStoreItem);
            if (!cInfo) {
                debugDevice && console.error('onDeviceConnected:: device info  is null');
                return;
            }

            if (isServer && !cInfo.serverSide) {
                debugDevice && console.error('onDeviceConnected:: device info is not server side, abort');
            }

            if (instance && !deviceStoreItem.serverVariables) {
                deviceStoreItem.setState(types.DEVICE_STATE.CONNECTED);
                this.getDeviceServerVariables(deviceStoreItem, instance);
                return;
            }
            if (!cInfo) {
                console.error('couldnt start device, invalid control info');
                return;
            }

            var hash = cInfo.hash;

            if (this.deviceInstances[hash]) {
                if (!instance.__didStartBlocks) {
                    this.onDeviceStarted(instance, deviceStoreItem, instance.driver);
                }
                deviceStoreItem.setState(types.DEVICE_STATE.READY);
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: 'Device is Ready <span class="text-success">' + cInfo.host + ':' + cInfo.port + '</span>',
                    type: 'success'
                });

                return this.deviceInstances[hash];
            }

            var thiz = this;
            var baseDriverPrefix = this.driverScopes['system_drivers'];
            var baseDriverRequire = baseDriverPrefix + 'DriverBase';
            //console.log('device conntected, load base driver with prefix : ' +baseDriverPrefix + ' and final require ' + baseDriverRequire);
            try {
                require([baseDriverRequire], function (baseDriver) {
                    baseDriver.prototype.declaredClass = baseDriverRequire;
                    thiz.createDriverInstance(cInfo, baseDriver, deviceStoreItem);
                });
            } catch (e) {
                console.error('requiring base driver at ' + baseDriverRequire + ' failed', e);
            }

        },
        onDeviceDisconnected: function (data) {
            if (!data && !data.device) {
                return;
            }

            var error = data.error;

            var code = error && error.code ? error.code : error || '';
            var deviceStoreItem = this.getDeviceStoreItem(data.device);
            if (!deviceStoreItem) {
                debugDevice && isIDE && console.error('deviceStoreItem is null');
                return;
            }
            if (data.stopped === true) {
                this.stopDevice(deviceStoreItem);
                return;
            }

            this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                text: 'Device has been disconnected ' + '<span class="text-warning">' + data.device.host + ':' + data.device.port + '</span>' + ' :  ' + '<span class="text-danger">' + code + '</span>',
                type: 'info'
            });

            var info = this.toDeviceControlInfo(deviceStoreItem);
            if (info && isServer && !info.serverSide) {
                return;
            }

            //kill old instance
            var instance = this.getDriverInstance(data.device, true);
            if (instance) {
                this.removeDriverInstance(data.device);
            }
            deviceStoreItem.reset();

            if (deviceStoreItem.state === types.DEVICE_STATE.DISABLED) {
                deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
                return;
            }

            deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED);
            deviceStoreItem.lastError = error;
            deviceStoreItem.refresh();

            function shouldRecconect(item) {
                if (item._userStopped || item.state === types.DEVICE_STATE.DISABLED) {
                    return false;
                }
                var enabled = thiz.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_ENABLED);
                if (!enabled) {
                    return false;
                }
                return true;
            }

            var serverSide = info.serverSide;

            if ((isServer && serverSide) || (!serverSide && !isServer)) {
                if (deviceStoreItem) {
                    var thiz = this;
                    if (deviceStoreItem.reconnectTimer) {
                        return;
                    }
                    deviceStoreItem.isReconnecting = true;
                    if (!deviceStoreItem.lastReconnectTime) {
                        deviceStoreItem.lastReconnectTime = thiz.reconnectDevice;
                    } else if (deviceStoreItem.lastReconnectTime > 3600) {
                        deviceStoreItem.lastReconnectTime = 3600;
                    }
                    if (!deviceStoreItem.reconnectRetry) {
                        deviceStoreItem.reconnectRetry = 0;
                    }

                    deviceStoreItem.reconnectTimer = setTimeout(function () {
                        deviceStoreItem.reconnectTimer = null;
                        deviceStoreItem.lastReconnectTime *= 2;
                        deviceStoreItem.reconnectRetry += 1;
                        if (deviceStoreItem.shouldReconnect()) {
                            if (info) {
                                deviceStoreItem.setState(types.DEVICE_STATE.CONNECTING);
                                debugConnect && console.info('trying to reconnect to ' + info.toString());
                            }
                            thiz.startDevice(deviceStoreItem);
                        }
                    }, deviceStoreItem.lastReconnectTime);
                }
            }

        },
        onCommandFinish: function (deviceInfo, message) {
            var driverInstance = this.getDriverInstance(deviceInfo, true);
            if (!driverInstance) {
                return;
            }

            var params = message.params || {};
            if (params.src && params.id) {
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if (block && block.onCommandFinish) {
                    var result = null;
                    var data = block.onCommandFinish(message);
                    try {
                        result = JSON.stringify(data, function (k, v) {
                            if (typeof v == 'object') {
                                return null;
                            }
                            return v;
                        }, 2);
                    } catch (e) {
                        logError(e, 'error serializing on command finish');
                    }
                    if (has('xcf-ui') && result) {
                        //console replay
                        var device = driverInstance.device,
                            hash = deviceInfo.hash,
                            viewId = hash + '-Console',
                            messages = [result],
                            consoleViews = this.consoles[viewId];

                        if (consoleViews) {
                            for (var h = 0; h < consoleViews.length; h++) {
                                var consoleView = consoleViews[h];
                                if (consoleView) {
                                    var split = true;
                                    var hex = false;

                                    if (consoleView.console) {
                                        var _consoleEditor = consoleView.console.getTextEditor();
                                        split = _consoleEditor.getAction("Console/Settings/Split").value;
                                        hex = _consoleEditor.getAction("Console/Settings/HEX").value;
                                    }

                                    if (!split && hex) {
                                        var hexStr = utils.bufferToHexString(deviceMessageData.data.bytes);
                                        consoleView.log(hexStr, split, false, types.LOG_OUTPUT.RESPONSE);
                                        continue;
                                    }
                                    for (var j = 0; j < messages.length; j++) {
                                        var _message = messages[j];
                                        if (_.isString(_message.string) && _message.string.length === 0) {
                                            continue;
                                        }
                                        if (hex) {
                                            _message = utils.stringToHex(_message);
                                        }
                                        consoleView.log(_message, split, true, types.LOG_OUTPUT.RESPONSE);
                                    }
                                }
                            }
                        }
                        if (messages && messages.length) {
                            this.publish(types.EVENTS.ON_DEVICE_MESSAGE_EXT, {
                                device: device,
                                deviceInfo: deviceInfo,
                                raw: result,
                                messages: messages,
                                bytes: []
                            });
                        }
                    }
                }
            }
        },
        onCommandProgress: function (deviceData, message) {
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }
            var params = message.params || {};
            if (params.src && params.id) {
                var scope = driverInstance.blockScope;
                if (scope) {
                    var block = scope.getBlockById(params.src);
                    if (block && block.onCommandProgress) {
                        block.onCommandProgress(message);
                    }
                } else {
                    debugServerMessages && console.warn('onCommandProgress: have no blockscope');
                }

            }
        },
        onCommandPaused: function (deviceData, message) {
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }
            var params = message.params || {};
            if (params.src && params.id) {
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if (block && block.onCommandPaused) {
                    block.onCommandPaused(message);
                }
            }
        },
        onCommandStopped: function (deviceData, message) {
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }
            var params = message.params || {};
            if (params.src && params.id) {
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if (block && block.onCommandStopped) {
                    block.onCommandStopped(message);
                }
            }
        },
        onCommandError: function (deviceData, message) {
            var driverInstance = this.getDriverInstance(deviceData, true);
            if (!driverInstance) {
                return;
            }
            var params = message.params || {};
            if (params.src && params.id) {
                var scope = driverInstance.blockScope;
                var block = scope.getBlockById(params.src);
                if (block && block.onCommandError) {
                    block.onCommandError(message);
                }
            }
        },
        /**
         * Primary callback when the device server has received a message from a device.
         * @param evt {object}
         * @param evt.event {string}
         * @param evt.data {string|object}
         * @param evt.data.data {object}
         */
        onDeviceServerMessage: function (evt) {
            var dataIn = evt['data'];
            var deviceMessageData = null;
            if (_.isString(dataIn) && dataIn.indexOf('{') != -1) {
                try {
                    deviceMessageData = utils.fromJson(dataIn);
                } catch (e) {
                    console.error('error parsing device message', evt);
                    return;
                }
            } else if (_.isObject(dataIn) && dataIn.data) {
                //emulated
                deviceMessageData = dataIn;
            }

            if (!deviceMessageData || !deviceMessageData.data || !deviceMessageData.data.device) {
                debug && console.error('bad device message : ', deviceMessageData);
                return;
            }
            var deviceInfo = deviceMessageData.data.device;
            if (!deviceInfo) {
                debug && console.error('onDeviceServerMessage: cant get device info');
                return;
            }
            if (isServer && !deviceInfo.serverSide) {
                return;
            }


            //pick driver instance
            var driverInstance = this.getDriverInstance(deviceMessageData.data.device, true);
            if (!driverInstance) {
                debugDevice && console.error(' onDeviceMessage : failed! Have no device instance for ' + deviceMessageData.data.device.host, deviceMessageData);
                return;
            }


            var device = this.getDeviceStoreItem(deviceInfo);

            if (!device) {
                debugStrangers && console.error('cant find device : ', deviceInfo.toString());
                return;
            }

            //important: use our info now
            deviceInfo = device.info;
            if (!deviceInfo) {
                console.error('invalid device : ' + device.toString());
            }

            var state = device.get('state');
            var serverSide = deviceInfo.serverSide;

            function clear(message) {
                delete message['resposeSettings'];
                delete message['driver'];
                delete message['lastResponse'];
                delete message['scope'];
                delete message['driverId'];
                delete message['device'];
                //delete message['src'];
                //delete message['id'];
                delete message['sourceHost'];
                delete message['sourcePort'];
            }

            var message = deviceMessageData.data.deviceMessage;
            if (message == null) {
                debugStrangers && console.warn('onDeviceServerMessage: abort, no message data');
                return;
            }
            var messages = [];
            if (_.isString(message)) {
                messages = driverInstance.split(message);
            } else if (_.isObject(message)) {
                clear(message);
                messages = [message];
            }

            var deviceMessages = messages;

            var _messages = driverInstance.onMessageRaw({
                device: deviceMessageData.data.device,
                message: message,
                bytes: deviceMessageData.data.bytes
            });

            if (_messages && !_messages.length) {
                _messages = null;
            }

            var bytes = [];

            for (var i = 0; i < messages.length; i++) {
                bytes.push(utils.stringToBuffer(messages[i]));
            }

            if (_messages && _messages.length) {
                messages = [];
                bytes = [];
                for (var j = 0; j < _messages.length; j++) {
                    var msg = _messages[j];
                    messages.push(msg.string);
                    bytes.push(msg.bytes);
                }
            }
            //replay on driver code instance
            if (messages && messages.length) {
                for (var k = 0; k < messages.length; k++) {
                    var _message = messages[k];
                    //driver replay as individual message
                    driverInstance.onMessage({
                        device: deviceMessageData.data.device,
                        message: _message,
                        raw: message,
                        bytes: bytes[k]
                    });


                    //driver replay as broadcast message
                    driverInstance.onBroadcastMessage({
                        device: deviceMessageData.data.device,
                        message: _message,
                        raw: message,
                        bytes: bytes[k]
                    });

                }
            }
            if (state !== types.DEVICE_STATE.READY) {
                device.set('state', types.DEVICE_STATE.READY);
            }
            var debugDevice = device.isDebug();
            //system replay:
            if (deviceMessageData.event) {

                //before publishing on the public system bus, we do bundle the driver instance
                //together with the origin event from the device server:
                deviceMessageData.data['driverInstance'] = driverInstance;
                //now tell everybody!
                //
                // 'deviceMessageData.event' is a system event and defined in xcf.types.EVENTS.ON_DEVICE_MESSAGE
                //
                // 'deviceMessageData.data' is the actual payload, build by the device server. it comes with this structure :
                //
                //  {
                //      device:{
                //          host:'192.168.1.20',
                //          port:'23',
                //          protocol:'tcp'
                //      },
                //      deviceMessage:'MV58\r@VOL:-220\r',
                //
                //  }
                //
                //  Current Subscribers : DriverManager & this
                //
                this.publish(deviceMessageData.event, deviceMessageData.data);
            }


            if (has('xcf-ui')) {
                //console replay
                var hash = deviceInfo.hash,
                    viewId = hash + '-Console',
                    messagesNew = [],
                    consoleViews = this.consoles[viewId];

                debug && console.log('on_device message ' + hash, driverInstance.options);
                //device.setState(types.DEVICE_STATE.READY);
                if (debugDevice) {
                    var text = deviceMessageData.data.deviceMessage;
                    if (_.isObject(text)) {

                        clear(text);
                        try {
                            text = JSON.stringify(text);
                        } catch (e) {
                            logError(e, 'error serialize message');
                        }
                    }

                    this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                        text: "Device Message from " + driverInstance.options.host + " : " + '<span class="text-info">' + text + '</span>'
                    });
                }
                if (consoleViews) {
                    for (var h = 0; h < consoleViews.length; h++) {
                        var consoleView = consoleViews[h];
                        if (consoleView) {
                            var split = true;
                            var hex = false;

                            if (consoleView.console) {
                                var _consoleEditor = consoleView.console.getTextEditor();
                                split = _consoleEditor.getAction("Console/Settings/Split").value;
                                hex = _consoleEditor.getAction("Console/Settings/HEX").value;
                            }

                            if (!split && hex) {

                                var hexStr = utils.bufferToHexString(deviceMessageData.data.bytes);
                                consoleView.log(hexStr, split, false, types.LOG_OUTPUT.RESPONSE);
                                continue;
                            }

                            messagesNew = [];
                            if (_.isString(message)) {
                                messagesNew = split ? _messages && _messages.length ? _messages : driverInstance.split(message) : [message];
                            } else if (_.isObject(message)) {
                                clear(message);
                                messagesNew = [message];
                            }

                            for (var j = 0; j < messagesNew.length; j++) {
                                var _message = messagesNew[j];
                                if (_.isString(_message.string) && _message.string.length === 0) {
                                    continue;
                                }
                                if (hex) {
                                    _message = utils.stringToHex(_message.string);
                                }
                                consoleView.log(_message, split, true, types.LOG_OUTPUT.RESPONSE);
                            }
                        }
                    }
                }
                if (messages && messages.length) {
                    this.publish(types.EVENTS.ON_DEVICE_MESSAGE_EXT, {
                        device: device,
                        deviceInfo: deviceInfo,
                        raw: message,
                        messages: messages,
                        bytes: deviceMessageData.data.bytes
                    });
                }
            }
            /****************   Forward to xblox    ******************/
            if (messages.length > 0 && driverInstance.blockScope) {
                var scope = driverInstance.blockScope;

                var responseBlocks = scope.blockStore._find({
                    group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_BLOCKS
                });
                var responseVariables = scope.blockStore._find({
                    group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES
                });

                var responseVariable = scope.getVariable('value');
                if (!responseVariable) {
                    responseVariable = new Variable({
                        id: utils.createUUID(),
                        name: 'value',
                        value: '',
                        scope: scope,
                        type: 13,
                        group: 'processVariables',
                        gui: false,
                        cmd: false
                    });
                    scope.blockStore.putSync(responseVariable);
                }
                for (var l = 0; l < messages.length; l++) {

                    if (messages[l].length === 0) {
                        continue;
                    }
                    responseVariable.value = new String(messages[l]);
                    responseVariable.value.setBytes(bytes[l]);
                    responseVariable.value.setString(messages[l]);
                    this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                        item: responseVariable,
                        scope: scope,
                        owner: this,
                        save: false,                         //dont save it
                        source: types.MESSAGE_SOURCE.DEVICE,  //for prioritizing
                        publishMQTT: false //just for local processing
                    });
                    //now run each top-variable block in 'conditional process'
                    for (var o = 0; o < responseVariables.length; o++) {
                        var _var = responseVariables[o];
                        if (responseVariables[o].title == 'value') {
                            continue;
                        }
                        var _varResult = null;
                        var _cValue = responseVariable.value;
                        if (typeof _cValue !== "number") {
                            _cValue = '' + _cValue;
                            _cValue = "'" + _cValue + "'";
                        }

                        _varResult = _cValue;
                        if (_var.target && _var.target != 'None' && _varResult !== null && _varResult != 'null' && _varResult != "'null'") {
                            var targetVariable = scope.getVariable(_var.target);
                            if (targetVariable) {
                                targetVariable.value = _varResult;

                                this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                                    item: targetVariable,
                                    scope: scope,
                                    owner: this,
                                    save: false,
                                    source: types.MESSAGE_SOURCE.BLOX  //for prioritizing
                                });
                            }
                        }
                    }

                    if ((isServer && serverSide) || (!serverSide && !isServer)) {

                        for (var m = 0; m < messages.length; m++) {
                            var __message = messages[m];
                            if (_.isObject(__message)) {
                                if (__message.src) {

                                    var block = scope.getBlockById(__message.src);
                                    if (block && block.onData) {
                                        block.onData(__message);
                                    }
                                }
                            }
                        }


                        if (!runDrivers) {
                            return;
                        }
                        //now run each top-level block in 'conditional process'
                        for (var n = 0; n < responseBlocks.length; n++) {
                            var block = responseBlocks[n];
                            if (block.enabled === false) {
                                continue;
                            }
                            block.override = {
                                args: _var ? [_var.value] : null
                            };
                            try {
                                scope.solveBlock(responseBlocks[n], {
                                    highlight: isServer ? false : true
                                });
                            } catch (e) {
                                logError(e, '----solving response block crashed ');
                                debug && console.trace();
                            }
                        }
                    }
                }
            }

        },
        /**
         * Device Server management interface
         * @param cmd
         * @param data
         */
        sendManagerCommand: function (cmd, data) {
            this.checkDeviceServerConnection();
            var dataOut = {
                manager_command: cmd
            };
            utils.mixin(dataOut, data);
            if (this.deviceServerClient) {
                var res = this.deviceServerClient.emit(null, dataOut, cmd);
                debugServerCommands && console.log('send manager command ' + cmd, [dataOut, res]);
                return res;
            } else {
                console.error('Send Manager Command ' + cmd + ' failed, have no  device Server client');
                this.onHaveNoDeviceServer();
            }
        },
        /**
         *
         * @param driverInstance
         * @param data
         * @param src
         * @param id
         * @param print
         * @param wait
         * @param stop
         * @param pause
         * @param command {module:xcf/model/Command}
         * @param args {object}
         */
        sendDeviceCommand: function (driverInstance, data, src, id, print, wait, stop, pause, command, args) {
            this.checkDeviceServerConnection();
            var options = driverInstance.getDeviceInfo();
            utils.mixin({
                src: src
            }, options);

            var dataOut = {
                command: data,
                device_command: command || types.SOCKET_SERVER_COMMANDS.DEVICE_SEND,
                options: options

            };
            utils.mixin(dataOut.options, {
                params: {
                    src: src,
                    id: id,
                    wait: wait,
                    stop: stop,
                    pause: pause,
                    args: args
                }
            });

            debug && console.log("Device.Manager.Send.Message : " + dataOut.command.substr(0, 30) + ' = hex = ' + utils.stringToHex(dataOut.command) + ' l = ' + dataOut.command.length, dataOut);//sending device message
            var device = this.getDevice(options.id);
            if (!device || !_.isObject(device)) {
                console.error('invalid device');
                return;
            }

            if (device._userStopped) {
                return;
            }
            if (device && (device.state === types.DEVICE_STATE.DISABLED ||
                device.state === types.DEVICE_STATE.DISCONNECTED ||
                device.state === types.DEVICE_STATE.CONNECTING
            )) {
                debug && console.error('send command when disconnected');
                return;
            }

            var message = utils.stringFromDecString(dataOut.command);
            if (device.isDebug()) {
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: "Did send message : " + '<span class="text-warnin">' + message.substr(0, 30) + '</span>' + " to " + '<span class="text-info">' + options.host + ":" + options.port + "@" + options.protocol + '</span>'
                });
            }

            //console replay
            var hash = MD5(JSON.stringify(driverInstance.options), 1);
            var viewId = hash + '-Console';
            if (this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, 'Device_Send');
                if (has('xcf-ui') && print !== false) {
                    var consoleViews = this.consoles[viewId];
                    _.each(consoleViews, function (view) {
                        var text = '<span class="text-info"><b>' + dataOut.command + '</span>';
                        view.printCommand(text, '');
                    });
                }
            } else {
                this.onHaveNoDeviceServer();
                console.error('this.deviceServerClient is null');
                console.error(' Send Device Command ' + data + 'failed, have no  device Server client');
            }
            if (!driverInstance.blockScope) {
                return;
            }
            var command = driverInstance.blockScope.getBlockById(src);
            this.publish(types.EVENTS.ON_DEVICE_COMMAND, {
                device: device,
                command: utils.stringFromDecString(data),
                deviceInfo: this.toDeviceControlInfo(device),
                name: command ? command.name : ""
            });
        },
        /**
         * Kick server
         * @param path {string} Absolute path to devices
         */
        loadDevices: function (path) {
            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.INIT_DEVICES, {
                path: path
            });
        },
        /**
         *
         * @param protocol CONNECTION_PROTOCOL
         * @param method {string} The method
         * @param args {array} The arguments for the protocol method being called on the server
         * @param device {object}
         * @returns module:dojo/Deferred
         */
        protocolMethod: function (protocol, method, args, device) {
            var dfd = new Deferred();
            var event = types.SOCKET_SERVER_COMMANDS.PROTOCOL_METHOD;
            var id = utils.createUUID();
            var task = event + '_' + id;
            var data = {
                protocol: protocol,
                method: method,
                options: {
                    args: args,
                    id: id,
                    device: device
                }
            };
            var self = this;
            var handler = function (e) {
                self.unsubscribe(task);
                clearTimeout(timer);
                dfd.resolve(e);
            };
            this.subscribe(task, handler);
            try {
                this.sendManagerCommand(event, data);
                var timer = setTimeout(function () {
                    self.unsubscribe(task);
                    dfd.reject('timeout');
                    console.error('protocol method timeout');
                }, 8000);
            } catch (e) {
                dfd.reject(e);
            }
            return dfd;

        },
        /**
         *
         * @param driverInstance
         * @param method
         * @param args
         * @param src
         * @param id
         */
        callMethod: function (driverInstance, method, args, src, id) {
            this.checkDeviceServerConnection();
            var sendOptions = {
                id: id,
                src: src
            };
            var dataOut = {
                method: method,
                args: args,
                device_command: types.SOCKET_SERVER_COMMANDS.CALL_METHOD,
                params: sendOptions,
                options: driverInstance.options
            };
            if (this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, types.SOCKET_SERVER_COMMANDS.CALL_METHOD);
            } else {
                this.onHaveNoDeviceServer();
            }
        },
        /**
         *
         * @param driverInstance
         * @param method
         * @param args
         * @param src
         * @param id
         */
        runShell: function (driverInstance, cmd, args, src, id) {
            var options = driverInstance.getDeviceInfo();
            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.RUN_SHELL, {
                cmd: cmd,
                args: args,
                options: utils.mixin(options, {
                    params: {
                        id: id,
                        src: src
                    }
                })
            });
            /*
             this.checkDeviceServerConnection();
             var options = driverInstance.options,
             sendOptions = {
             id:id,
             src:src
             },
             dataOut = {
             method:method,
             args: args,
             manager_command: 'Run_Shell',
             host: options.host,
             port: options.port,
             protocol: options.protocol,
             options:sendOptions
             };
             if(this.deviceServerClient) {
             this.deviceServerClient.emit(null, dataOut, 'Run_Shell');
             }else{
             this.onHaveNoDeviceServer();
             }*/
        },
        /**
         *
         * @param path
         * @param watch
         */
        watchDirectory: function (path, watch) {
            this.checkDeviceServerConnection();
            var dataOut = {
                path: path,
                watch: watch,
                manager_command: types.SOCKET_SERVER_COMMANDS.WATCH
            };
            if (this.deviceServerClient) {
                this.deviceServerClient.emit(null, dataOut, types.SOCKET_SERVER_COMMANDS.WATCH);
            } else {
                this.onHaveNoDeviceServer();
            }
        },
        handle: function (msg) {
            var userDirectory = this.ctx.getUserDirectory();
            var data = msg.data;
            return !(userDirectory && data && data.device && data.device.userDirectory && data.device.userDirectory !== userDirectory);
        },
        createDeviceServerClient: function (store) {
            var thiz = this;
            var dfd = new Deferred();
            this.deviceServerClient = null;
            this.deviceServerClient = factory.createClientWithStore(store, 'Device Control Server', {
                delegate: {
                    onConnected: function () {
                        thiz.onDeviceServerConnected();
                        dfd.resolve();
                        thiz.publish(types.EVENTS.ON_DEVICE_SERVER_CONNECTED);
                        if (isIDE) {
                            thiz.ctx.getNotificationManager().postMessage({
                                message: 'Connected to Device Server',
                                type: 'success',
                                duration: 3000
                            });
                        }
                    },
                    onLostConnection: function () {
                        thiz.onDeviceServerConnectionLost();
                    },
                    onServerResponse: function (data) {
                        var dataIn = data['data'];
                        var msg = null;
                        if (_.isString(dataIn)) {

                            try {
                                msg = JSON.parse(dataIn);
                            } catch (e) {
                                msg = dataIn;
                            }
                            debug && !msg && console.error('invalid incoming message', data);
                            msg = msg || {};

                            if (msg && msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_FINISH) {
                                thiz.onCommandFinish(msg.data.device, msg.data.deviceMessage);
                                return;
                            }
                            if (msg && msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_PROGRESS) {
                                thiz.onCommandProgress(msg.data.device, msg.data.deviceMessage);
                                return;
                            }
                            if (msg && msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_PAUSED) {
                                thiz.onCommandPaused(msg.data.device, msg.data.deviceMessage);
                                return;
                            }
                            if (msg && msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_STOPPED) {
                                thiz.onCommandStopped(msg.data.device, msg.data.deviceMessage);
                                return;
                            }
                            if (msg.data && msg.data.deviceMessage && msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_ERROR) {
                                thiz.onCommandError(msg.data.device, msg.data.deviceMessage);
                                return;
                            }
                            if (msg.event === types.EVENTS.ON_DEVICE_DISCONNECTED) {
                                thiz.publish(types.EVENTS.ON_DEVICE_DISCONNECTED, msg.data);
                                return;
                            }
                            if (msg.event === types.EVENTS.SET_DEVICE_VARIABLES) {
                                return thiz.onSetDeviceServerVariables(msg.data);
                            }

                            if (msg.event === types.EVENTS.ON_RUN_CLASS_EVENT) {
                                return thiz.onRunClassEvent(msg.data);
                            }
                            if (msg.event === types.EVENTS.ON_DEVICE_CONNECTED) {
                                thiz.publish(types.EVENTS.ON_DEVICE_CONNECTED, msg.data);
                                return;
                            }
                            if (msg.event === types.SOCKET_SERVER_COMMANDS.PROTOCOL_METHOD) {
                                var event = types.SOCKET_SERVER_COMMANDS.PROTOCOL_METHOD + '_' + msg.data.options.id;
                                thiz.publish(event, msg.data);
                                return;
                            }
                            if (msg.event === types.EVENTS.ON_SERVER_LOG_MESSAGE) {
                                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, msg.data);
                                return;
                            }
                            if (msg.event === types.EVENTS.ON_MQTT_MESSAGE) {
                                thiz.publish(types.EVENTS.ON_MQTT_MESSAGE, msg.data);
                                thiz.onMQTTMessage(msg.data);
                                return;
                            }
                            if (msg.event === types.EVENTS.ON_FILE_CHANGED) {
                                return thiz.ctx.onXIDEMessage(utils.fromJson(data.data));
                            }

                            if (!thiz.handle(msg)) {
                                return;
                            }
                        }
                        thiz.onDeviceServerMessage(data);
                    }
                }
            });
            if (!this.deviceServerClient) {
                debug && console.log('couldnt connect to device server');
                return;
            } else {
                debug && console.log('did connect to device server');
            }
            this.deviceServerClient.dfd = dfd;
            return this.deviceServerClient;
        }
    });

    dcl.chainAfter(Module, 'onDeviceStarted');
    dcl.chainAfter(Module, 'onDeviceDisconnected');
    return Module;

});
;
define('xcf/manager/DeviceManager_Server',["dcl/dcl"], function (dcl) {
    return dcl(null, {});
});;
/** @module xcf/manager/BeanManager **/
define('xcf/manager/BeanManager',[
    'dcl/dcl',
    'xdojo/has',
    "dojo/_base/lang",
    'xide/types',
    'xide/utils',
    'xide/manager/BeanManager',
    "dojo/Deferred",
    "xide/noob",
    "xdojo/has!xtrack?xide/interface/Track",
    'xdojo/has!xcf-ui?xide/views/ActionDialog',
    'xdojo/has!xcf-ui?xide/views/CIActionDialog',
    'xdojo/has!xcf-ui?xide/views/CIGroupedSettingsView'
], function (dcl,has,lang, types, utils, BeanManager, Deferred, noob,Track, ActionDialog, CIActionDialog, CIGroupedSettingsView) {
    /**
     * @class module:xcf/manager/BeanManager_Base
     * @extends {module:xide/manager/BeanManager}
     * @augments {module:xide/manager/ManagerBase}
     */
    var Base = dcl(BeanManager,{
        /**
         * Return device model item by device id
         * @param path
         * @returns {module:xcf/model/Device} The device
         */
        getItemByPath: function (path) {
            function search(store) {
                return store.getSync(path);
            }
            for (var scope in this.stores) {
                var store = this.stores[scope];
                var result = search(store);
                if (result) {
                    return result;
                }
            }
        },
        setStore: function (scope, store) {
            var current = this.stores[scope];
            if (current) {
                console.error('setting existing store '+scope);
                current.destroy();
                delete this.stores[scope];
            }
            this.stores[scope] = store;
            return store;
        },
        onCIUpdate: function (evt) {
            if (evt['owner'] === this) {
                this.updateCI(evt.ci, evt.newValue, evt.oldValue, evt.storeItem);
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        // std impl.
        //
        /////////////////////////////////////////////////////////////////////////////////////
        init: function () {
            this.stores = {};
            this.subscribe(types.EVENTS.ON_CI_UPDATE);
        }
    });

    if(has('xcf-ui')) {
        /**
         * @class module:xcf/manager/BeanManager
         * @extends {module:xcf/manager/BeanManager_Base}
         */
        return dcl(Base, {
            declaredClass: "xcf.manager.BeanManager",
            /**
             * Bean protocol impl.
             */
            getViewClass: function (trackImpl) {
                trackImpl = trackImpl || {};
                utils.mixin(trackImpl, {
                    startup: function () {
                        if (Track) {
                            this.getContext().getTrackingManager().track(
                                this.getTrackingCategory(),
                                this.getTrackingLabel(this.item),
                                this.getTrackingUrl(this.item),
                                types.ACTION.OPEN,
                                this.getContext().getUserDirectory()
                            );
                        }
                        if (this.inherited) {
                            return this.inherited(arguments);
                        }
                    }
                })
                return dcl([CIGroupedSettingsView, Track ? Track.dcl : noob.dcl], trackImpl);
            },
            /**
             *
             * @param bean
             * @returns {module:xfile/model/File|string}
             */
            getFile: function (bean) {
                var dfd = new Deferred();

                var ctx = this.getContext();
                var fileManager = ctx.getFileManager();
                var fileStore = fileManager.getStore(bean.scope);
                fileStore.initRoot().then(function () {
                    fileStore._loadPath('.', true).then(function () {
                        fileStore.getItem(bean.path, true).then(function (item) {
                            dfd.resolve(item);
                        });
                    });
                });
                return dfd;
            },
            /**
             * Url generator for device/driver/[command|block|variable]
             *
             * @param device {string} the device id
             * @param driver {string} the driver id
             * @param block {string} the block id
             * @param prefix {string} protocol schema
             * @returns {*}
             */
            toUrl: function (device, driver, block, prefix) {
                var pattern = (prefix || '') + "deviceScope={deviceScope}&device={deviceId}&driver={driverId}&driverScope={driverScope}&block={block}";
                return lang.replace(pattern,
                    {
                        deviceId: device.id,
                        deviceScope: device.scope,
                        driverId: driver.id,
                        driverScope: driver.scope,
                        block: block ? block.id : ""
                    });
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Bean Management
            //
            /////////////////////////////////////////////////////////////////////////////////////
            /**
             * Creates new group item dialog
             */
            newGroup: function () {
                var thiz = this,
                    currentItem = this.getItem(),
                    parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : '';

                var actionDialog = new CIActionDialog({
                    title: 'New ' + this.groupType,
                    delegate: {
                        onOk: function (dlg, data) {
                            var title = utils.getCIInputValueByName(data, 'Title');
                            var scope = utils.getCIInputValueByName(data, 'Scope');
                            var _final = parent + '/' + title;
                            thiz.createGroup(scope, _final, function () {
                                var newItem = thiz.createNewGroupItem(title, scope, parent);
                                thiz.store.putSync(newItem);
                                thiz.publish(types.EVENTS.ON_STORE_CHANGED, {
                                    owner: thiz,
                                    store: thiz.store,
                                    action: types.NEW_DIRECTORY,
                                    item: newItem
                                });
                            });
                        }
                    },
                    cis: [
                        utils.createCI('Title', 13, ''),
                        utils.createCI('Scope', 3, this.defaultScope, {
                            "options": [
                                {
                                    label: 'System',
                                    value: this.defaultScope
                                },
                                {
                                    label: 'User',
                                    value: this.userScope
                                }
                            ]
                        })
                    ]
                });
                actionDialog.startup();
                actionDialog.show();
            },
            onDeleteItem: function (item) {
                var isDir = utils.toBoolean(item.isDir) === true;
                var removeFn = isDir ? 'removeGroup' : 'removeItem';
                var thiz = this;
                var actionDialog = new ActionDialog({
                    title: 'Remove ' + this.beanName + (isDir ? ' Group' : '') + ' ' + "\"" + item.name + "\"  ",
                    style: 'max-width:400px',
                    titleBarClass: 'text-danger',
                    delegate: {
                        isRemoving: false,
                        onOk: function () {
                            thiz[removeFn](
                                utils.toString(item.scope),
                                utils.toString(item.path),
                                utils.toString(item.name),
                                function () {
                                    thiz.onItemDeleted(item);
                                    thiz.publish(types.EVENTS.ON_STORE_CHANGED, {
                                        owner: thiz,
                                        store: thiz.store,
                                        action: types.DELETE,
                                        item: item
                                    });
                                });
                        }
                    }
                });
                actionDialog.show();
            },
            /////////////////////////////////////////////////////////////////////////////////////
            //
            //  Bean server protocol
            //
            /////////////////////////////////////////////////////////////////////////////////////
            createNewGroupItem: function (title, scope, parent) {
                return this.createItemStruct(title, scope, parent, title, true, this.groupType);
            },
            createNewItem: function (title, scope, parent) {
                return this.createItemStruct(title, scope, parent, parent + "/" + title, false, this.itemType);
            },
            createItem: function (scope, path, title, meta, code) {
                return this.runDeferred(null, 'createItem', [scope, path, title, meta, code]);
            },
            /***
             * ls is enumerating all drivers in a given scope
             * @param scope {string}
             * @param track {boolean}
             * @returns {Deferred}
             */
            ls: function (scope, track) {
                return this.runDeferred(null, 'ls', [scope]).then(function (data) {
                    try {
                        this.rawData = data;
                        this.initStore(data);
                        this.publish(types.EVENTS.ON_STORE_CREATED, {
                            data: data,
                            owner: this,
                            store: this.store,
                            type: this.itemType
                        });
                    } catch (e) {
                        logError(e, 'error ls');
                    }
                }.bind(this));
            }
        });
    }else{
        return Base;
    }
});
;
/** module:xide/interface/Track **/
define('xide/interface/Track',['dcl/dcl','xdojo/declare'], function (dcl,declare) {
    /**
     * Rough interface to be implemented by sub class in order to collect a view
     * in a history.
     * @interface module:xide/interface/Track
     */
    var Interface = {
        declaredClass:'xide.interface.Track',
        getTrackingGroup:function(){},
        getTrackingPath:function(){},
        track:function(){return false;},
        registerUrls:function(){}
    }
    var Module = declare('xide.interface.Track',null,Interface);
    Module.dcl = dcl(null,Interface);
    return Module;
});;
define('xide/noob',['xdojo/declare','dcl/dcl'], function (declare,dcl) {

    var Module = declare("noob",null,{});
    Module.dcl = dcl(null,{});
    return Module;
});;
define('xcf/factory/Blocks',[
    'xblox/factory/Blocks',
    "xcf/model/Command",
    "xblox/model/functions/CallBlock",
    "xblox/model/functions/StopBlock",
    "xblox/model/functions/PauseBlock",
    "xide/factory"
], function (Blocks,Command,CallBlock,StopBlock,PauseBlock,factory){
    if(Blocks) {
        Blocks._getCommandBlocks = function (scope, owner, target, group) {
            var items = [];
            items.push({
                name: 'Commands',
                iconClass: 'el-icon-random',
                items: [
                    {
                        name: 'Call Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: CallBlock,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: ""
                        }
                    },
                    {
                        name: 'Stop Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: StopBlock,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: ""
                        }
                    },
                    {
                        name: 'Pause Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: PauseBlock,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: ""
                        }
                    },
                    {
                        name: 'New Command',
                        owner: owner,
                        iconClass: 'el-icon-video',
                        proto: Command,
                        target: target,
                        ctrArgs: {
                            scope: scope,
                            group: group,
                            condition: "",
                            name: 'No-Title'
                        }
                    }
                ]
            });
            return items;
        };
        return Blocks;
    }else{
        return factory;
    }
});;
/** @module xblox/model/functions/PauseBlock **/
define('xblox/model/functions/PauseBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    "xblox/model/Block"
], function(dcl,utils,types,Deferred,Block){
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Block,{
        declaredClass:"xblox.model.functions.PauseBlock",
        command:'Select command please',
        icon:'',
        args:null,
        _timeout:100,
        hasInlineEdits:true,
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {
            if (this.command){
                var _args = null;
                var block = scope.resolveBlock(this.command);
                if(block && block.pause){
                    var res = block.pause();
                    this.onSuccess(this,settings);
                }else{
                    this.onFailed(this,settings);
                }
                return res;
            }
        },
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode,options,value){
            var optionsString = "";
            return "<a " + optionsString + "  tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){
            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){
            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            var _out = this.getBlockIcon('D') + 'Pause Command : ' + text;
            return _out;
        },
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;
            var title = 'Command';
            if(this.command.indexOf('://')){
                title = this.scope.toFriendlyName(this,this.command);
            }
            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));
            return fields;
        }
    });
});;
/** @module xblox/model/Block **/
define('xblox/model/Block',[
    'dcl/dcl',
    "dojo/Deferred",
    "dojo/_base/lang",
    "dojo/has",
    "xblox/model/ModelBase",
    "xide/factory",
    "xide/utils",
    "xide/types",
    "xide/utils/ObjectUtils",
    "xide/lodash",
    "xdojo/has!xblox-ui?xblox/model/Block_UI"
], function (dcl, Deferred, lang, has, ModelBase, factory, utils, types, ObjectUtils, _, Block_UI) {

    var bases = [ModelBase];

    function index(what, items) {
        for (var j = 0; j < items.length; j++) {
            if (what.id === items[j].id) {
                return j;
            }
        }
    }

    function compare(left, right) {
        return index(left) - index(right);
    }

    if (!has('host-browser')) {
        bases.push(dcl(null, {
            getStatusIcon: function () {
            },
            getStatusClass: function () {
            },
            setStatusClass: function () {
            },
            onActivity: function () {
            },
            onRun: function () {
            },
            onFailed: function () {
            },
            onSuccess: function () {
            },
            getIconClass: function () {
            }
        }));
    }
    if (Block_UI) {
        bases.push(Block_UI);
    }

    /***
     * First things first, extend the core types for block flags:
     */
    utils.mixin(types, {
        /**
         * Flags to describe flags of the inner state of a block which might change upon the optimization. It also
         * contains some other settings which might be static, default or changed by the UI(debugger, etc...)
         *
         * @enum {integer} module:xide/types/BLOCK_FLAGS
         * @memberOf module:xide/types
         */
        BLOCK_FLAGS: {
            NONE: 0x00000000,	// Reserved for future use
            ACTIVE: 0x00000001,	// This behavior is active
            SCRIPT: 0x00000002,	// This behavior is a script
            RESERVED1: 0x00000004,	// Reserved for internal use
            USEFUNCTION: 0x00000008,	// Block uses a function and not a graph
            RESERVED2: 0x00000010,	// Reserved for internal use
            SINGLE: 0x00000020,	// Only this block will excecuted, child blocks not.
            WAITSFORMESSAGE: 0x00000040,	// Block is waiting for a message to activate one of its outputs
            VARIABLEINPUTS: 0x00000080,	// Block may have its inputs changed by editing them
            VARIABLEOUTPUTS: 0x00000100,	// Block may have its outputs changed by editing them
            VARIABLEPARAMETERINPUTS: 0x00000200,	// Block may have its number of input parameters changed by editing them
            VARIABLEPARAMETEROUTPUTS: 0x00000400,	// Block may have its number of output parameters changed by editing them
            TOPMOST: 0x00004000,	// No other Block includes this one
            BUILDINGBLOCK: 0x00008000,	// This Block is a building block (eg: not a transformer of parameter operation)
            MESSAGESENDER: 0x00010000,	// Block may send messages during its execution
            MESSAGERECEIVER: 0x00020000,	// Block may check messages during its execution
            TARGETABLE: 0x00040000,	// Block may be owned by a different object that the one to which its execution will apply
            CUSTOMEDITDIALOG: 0x00080000,	// This Block have a custom Dialog Box for parameters edition .
            RESERVED0: 0x00100000,	// Reserved for internal use.
            EXECUTEDLASTFRAME: 0x00200000,	// This behavior has been executed during last process. (Available only in profile mode )
            DEACTIVATENEXTFRAME: 0x00400000,	// Block will be deactivated next frame
            RESETNEXTFRAME: 0x00800000,	// Block will be reseted next frame

            INTERNALLYCREATEDINPUTS: 0x01000000,	// Block execution may create/delete inputs
            INTERNALLYCREATEDOUTPUTS: 0x02000000,	// Block execution may create/delete outputs
            INTERNALLYCREATEDINPUTPARAMS: 0x04000000,	// Block execution may create/delete input parameters or change their type
            INTERNALLYCREATEDOUTPUTPARAMS: 0x08000000,	// Block execution may create/delete output parameters or change their type
            INTERNALLYCREATEDLOCALPARAMS: 0x40000000,	// Block execution may create/delete local parameters or change their type

            ACTIVATENEXTFRAME: 0x10000000,	// Block will be activated next frame
            LOCKED: 0x20000000,	// Block is locked for utilisation in xblox
            LAUNCHEDONCE: 0x80000000	// Block has not yet been launched...
        },

        /**
         *  Mask for the messages the callback function of a block should be aware of. This goes directly in
         *  the EventedMixin as part of the 'emits' chain (@TODO)
         *
         * @enum module:xide/types/BLOCK_CALLBACKMASK
         * @memberOf module:xide/types
         */
        BLOCK_CALLBACKMASK: {
            PRESAVE: 0x00000001,	// Emits PRESAVE messages
            DELETE: 0x00000002,	// Emits DELETE messages
            ATTACH: 0x00000004,	// Emits ATTACH messages
            DETACH: 0x00000008,	// Emits DETACH messages
            PAUSE: 0x00000010,	// Emits PAUSE messages
            RESUME: 0x00000020,	// Emits RESUME messages
            CREATE: 0x00000040,	// Emits CREATE messages
            RESET: 0x00001000,	// Emits RESET messages
            POSTSAVE: 0x00000100,	// Emits POSTSAVE messages
            LOAD: 0x00000200,	// Emits LOAD messages
            EDITED: 0x00000400,	// Emits EDITED messages
            SETTINGSEDITED: 0x00000800,	// Emits SETTINGSEDITED messages
            READSTATE: 0x00001000,	// Emits READSTATE messages
            NEWSCENE: 0x00002000,	// Emits NEWSCENE messages
            ACTIVATESCRIPT: 0x00004000,	// Emits ACTIVATESCRIPT messages
            DEACTIVATESCRIPT: 0x00008000,	// Emits DEACTIVATESCRIPT messages
            RESETINBREAKPOINT: 0x00010000,	// Emits RESETINBREAKPOINT messages
            RENAME: 0x00020000,	// Emits RENAME messages
            BASE: 0x0000000E,	// Base flags :attach /detach /delete
            SAVELOAD: 0x00000301,	// Base flags for load and save
            PPR: 0x00000130,	// Base flags for play/pause/reset
            EDITIONS: 0x00000C00,	// Base flags for editions of settings or parameters
            ALL: 0xFFFFFFFF	// All flags
        }

    });
    /**
     * Base block class.
     *
     * @class module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     * @lends module:xblox/model/Block_UI
     */
    var Block = dcl(bases, {
        declaredClass: "xblox.model.Block",
        scopeId: null,
        isCommand: false,
        outlet: 0,
        _destroyed: false,
        /**
         * Switch to include the block for execution.
         * @todo, move to block flags
         * @type {boolean}
         * @default true
         */
        enabled: true,
        /**
         * Switch to include the block for serialization.
         * @todo, move to block flags
         * @type {boolean}
         * @default true
         */
        serializeMe: true,
        /**
         * Name is used for the interface, mostly as prefix within
         * this.toText() which includes also the 'icon' (as icon font).
         * This should be unique and expressive.
         *
         * This field can be changed by the user. Examples
         * 'Run Script' will result in result 'Run Script + this.script'
         *
         * @todo: move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {string|null}
         * @default null
         * @required false
         */
        name: null,
        /**
         * @todo: same as name, move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {string}
         * @default 'No Description'
         * @required true
         */
        shareTitle: '',
        /**
         * The blocks internal user description
         * Description is used for the interface. This should be short and expressive and supports plain and html text.
         *
         * @todo: same as name, move that in user space, combine that with a template system, so any block ui parts gets off from here!
         * @type {boolean}
         * @default 'No Description'
         * @required true
         */
        sharable: false,
        /**
         * Container holding a 'child' blocks. Subclassing block might hold that somewhere else.
         * @type {Block[]}
         * @default null
         * @required false
         */
        items: null,
        /**
         * Parent up-link
         * @type {string|Block}
         * @default null
         * @required false
         */
        parent: null,
        /**
         * @var temporary variable to hold remainin blocks to run
         */
        _return: null,
        /**
         * @var temporary variable to store the last result
         */
        _lastResult: null,
        _deferredObject: null,
        _currentIndex: 0,
        _lastRunSettings: null,
        _onLoaded: false,
        beanType: 'BLOCK',
        override: {},
        /**
         * ignore these due to serialization
         */
        ignoreSerialize: [
            '_didSubscribe',
            '_currentIndex',
            '_deferredObject',
            '_destroyed',
            '_return',
            'parent',
            '__started',
            'ignoreSerialize',
            '_lastRunSettings',
            '_onLoaded',
            'beanType',
            'sharable',
            'override',
            'virtual',
            '_scenario',
            '_didRegisterSubscribers',
            'additionalProperties',
            'renderBlockIcon',
            'serializeMe',
            '_statusIcon',
            '_statusClass',
            'hasInlineEdits',
            '_loop',
            'help',
            'owner',
            '_lastCommand',
            'allowActionOverride',
            'canDelete',
            'isCommand',
            'lastCommand',
            'autoCreateElse',
            '_postCreated',
            '_counter'
        ],
        _parseString: function (string, settings, block, flags) {
            try {
                settings = settings || this._lastSettings || {};
                flags = flags || settings.flags || types.CIFLAG.EXPRESSION;
                var scope = this.scope;
                var value = string;
                var parse = !(flags & types.CIFLAG.DONT_PARSE);
                var isExpression = (flags & types.CIFLAG.EXPRESSION);
                if (flags & types.CIFLAG.TO_HEX) {
                    value = utils.to_hex(value);
                }
                if (parse !== false) {
                    value = utils.convertAllEscapes(value, "none");
                }
                var override = settings.override || this.override || {};
                var _overrides = (override && override.variables) ? override.variables : null;
                var res = "";
                if (isExpression && parse !== false) {
                    res = scope.parseExpression(value, null, _overrides, null, null, null, override.args, flags);
                } else {
                    res = '' + value;
                }
            } catch (e) {
                console.error(e);
            }
            return res;
        },
        postCreate: function () {
        },
        /**
         *
         * @param clz
         * @returns {Array}
         */
        childrenByClass: function (clz) {
            var all = this.getChildren();
            var out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (obj.isInstanceOf(clz)) {
                    out.push(obj);
                }
            }
            return out;
        },
        /**
         *
         * @param clz
         * @returns {Array}
         */
        childrenByNotClass: function (clz) {
            var all = this.getChildren();
            var out = [];
            for (var i = 0; i < all.length; i++) {
                var obj = all[i];
                if (!obj.isInstanceOf(clz)) {
                    out.push(obj);
                }
            }
            return out;
        },
        /**
         *
         * @returns {null}
         */
        getInstance: function () {
            var instance = this.scope.instance;
            if (instance) {
                return instance;
            }
            return null;
        },
        pause: function () {
        },
        mergeNewModule: function (source) {
            for (var i in source) {
                var o = source[i];
                if (o && _.isFunction(o)) {
                    this[i] = o;//swap
                }
            }
        },
        __onReloaded: function (newModule) {
            this.mergeNewModule(newModule.prototype);
            var _class = this.declaredClass;
            var _module = lang.getObject(utils.replaceAll('/', '.', _class)) || lang.getObject(_class);
            if (_module) {
                if (_module.prototype && _module.prototype.solve) {
                    this.mergeNewModule(_module.prototype);
                }
            }
        },
        reparent: function () {
            var item = this;
            if (!item) {
                return false;
            }
            var parent = item.getParent();
            if (parent) {
            } else {
                var _next = item.next(null, 1) || item.next(null, -1);
                if (_next) {
                    item.group = null;
                    _next._add(item);
                }
            }
        },
        unparent: function (blockgroup, move) {
            var item = this;
            if (!item) {
                return false;
            }
            var parent = item.getParent();
            if (parent && parent.removeBlock) {
                parent.removeBlock(item, false);
            }

            item.group = blockgroup;
            item.parentId = null;
            item.parent = null;
            if (move !== false) {
                item._place(null, -1, null);
                item._place(null, -1, null);
            }
        },
        move: function (dir) {
            var item = this;
            if (!item) {
                return false;
            }
            var parent = item.getParent();
            var items = null;
            var store = item._store;
            if (parent) {
                items = parent[parent._getContainer(item)];
                if (!items || items.length < 2 || !this.containsItem(items, item)) {
                    return false;
                }
                var cIndex = this.indexOf(items, item);
                if (cIndex + (dir) < 0) {
                    return false;
                }
                var upperItem = items[cIndex + (dir)];
                if (!upperItem) {
                    return false;
                }
                items[cIndex + (dir)] = item;
                items[cIndex] = upperItem;
                return true;
            } else {
                item._place(null, dir);
                return true;
            }
        },
        _place: function (ref, direction, items) {
            var store = this._store,
                dst = this;
            ref = ref || dst.next(null, direction);
            if (!ref) {
                console.error('have no next', this);
                return;
            }
            ref = _.isString(ref) ? store.getSync(ref) : ref;
            dst = _.isString(dst) ? store.getSync(dst) : dst;
            items = items || store.storage.fullData;
            direction = direction == -1 ? 0 : 1;
            items.remove(dst);
            if (direction == -1) {
                direction = 0;
            }
            items.splice(Math.max(index(ref, items) + direction, 0), 0, dst);
            store._reindex();
        },
        index: function () {
            var item = this,
                parent = item.getParent(),
                items = null,
                group = item.group,
                store = this._store;

            if (parent) {
                items = parent[parent._getContainer(item)] || [];
                items = items.filter(function (item) {
                    return item.group === group;
                });
                if (!items || items.length < 2 || !this.containsItem(items, item)) {
                    return false;
                }
                return this.indexOf(items, item);
            } else {
                items = store.storage.fullData;
                items = items.filter(function (item) {
                    return item.group === group;
                });
                return this.indexOf(items, item);
            }
        },
        numberOfParents: function () {
            var result = 0;
            var parent = this.getParent();
            if (parent) {
                result++;
                result += parent.numberOfParents();
            }
            return result;
        },
        getTopRoot: function () {
            var last = this.getParent();
            if (last) {
                var next = last.getParent();
                if (next) {
                    last = next;
                }
            }
            return last;
        },
        next: function (items, dir) {
            items = items || this._store.storage.fullData;
            function _next(item, items, dir, step, _dstIndex) {
                var start = item.indexOf(items, item);
                var upperItem = items[start + (dir * step)];
                if (upperItem) {
                    if (!upperItem.parentId && upperItem.group && upperItem.group === item.group) {
                        _dstIndex = start + (dir * step);
                        return upperItem;
                    } else {
                        step++;
                        return _next(item, items, dir, step, _dstIndex);
                    }
                }
                return null;
            }
            return _next(this, items, dir, 1, 0);
        },
        /**
         *
         * @param createRoot
         * @returns {module:xblox/model/Block|null}
         */
        getParent: function (createRoot) {
            if (this.parentId) {
                return this.scope.getBlockById(this.parentId);
            }
        },
        getScope: function () {
            var scope = this.scope;
            if (this.scopeId && this.scopeId.length > 0) {
                var owner = scope.owner;
                if (owner && owner.hasScope) {
                    if (owner.hasScope(this.scopeId)) {
                        scope = owner.getScope(this.scopeId);
                    } else {
                        console.error('have scope id but cant resolve it', this);
                    }
                }
            }
            return scope;
        },
        /**
         *
         * @returns {null}
         */
        canAdd: function () {
            return null;
        },
        getTarget: function () {
            var _res = this._targetReference;
            if (_res) {
                return _res;
            }
            var _parent = this.getParent();
            if (_parent && _parent.getTarget) {
                _res = _parent.getTarget();
            }
            return _res;
        },
        // adds array2 at the end of array1 => useful for returned "solve" commands
        addToEnd: function (array1, array2) {
            if (array2 && array1.length != null && array2.length != null) {
                array1.push.apply(array1, array2);
            }
            return array1;
        },
        /**
         *
         * @param what
         * @param del delete block
         */
        removeBlock: function (what, del) {
            if (what) {
                if (del !== false && what.empty) {
                    what.empty();
                }
                if (del !== false) {
                    delete what.items;
                }
                what.parent = null;
                what.parentId = null;
                if (this.items) {
                    this.items.remove(what);
                }
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Accessors
        //
        /////////////////////////////////////////////////////////////////////////////////////
        _getContainer: function (item) {
            return 'items';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        empty: function (what) {
            try {
                this._empty(what)
            } catch (e) {

                debugger;
            }
        },
        /*
         * Empty : removes all child blocks, recursively
         * @param proto : prototype|instance
         * @param ctrArgs
         * @returns {*}
         */
        _empty: function (what) {
            var data = what || this.items;
            if (data) {
                for (var i = 0; i < data.length; i++) {
                    var subBlock = data[i];

                    if (subBlock && subBlock.empty) {
                        subBlock.empty();
                    }
                    if (subBlock && this.scope && this.scope.blockStore) {
                        this.scope.blockStore.remove(subBlock.id);
                    }
                }
            }
        },
        /**
         * This was needed. FF bug.
         * @param data
         * @param obj
         * @returns {boolean}
         */
        containsItem: function (data, obj) {
            var i = data.length;
            while (i--) {
                if (data[i].id === obj.id) {
                    return true;
                }
            }
            return false;
        },
        /**
         * This was needed. FF bug
         * @param data
         * @param obj
         * @returns {*}
         */
        indexOf: function (data, obj) {
            var i = data.length;
            while (i--) {
                if (data[i].id === obj.id) {
                    return i;
                }
            }
            return -1;
        },
        _getBlock: function (dir) {
            var item = this;
            if (!item || !item.parentId) {
                return false;
            }
            //get parent
            var parent = this.scope.getBlockById(item.parentId);
            if (!parent) {
                return null;
            }
            var items = parent[parent._getContainer(item)];
            if (!items || items.length < 2 || !this.containsItem(items, item)) {
                return null;
            }
            var cIndex = this.indexOf(items, item);
            if (cIndex + (dir) < 0) {
                return false;
            }
            var upperItem = items[cIndex + (dir)];
            if (upperItem) {
                return upperItem;
            }
            return null;
        },
        getPreviousBlock: function () {
            return this._getBlock(-1);
        },
        getNextBlock: function () {
            return this._getBlock(1);
        },
        _getPreviousResult: function () {
            var parent = this.getPreviousBlock() || this.getParent();
            if (parent && parent._lastResult != null) {
                if (this.isArray(parent._lastResult)) {
                    return parent._lastResult;
                } else {
                    return [parent._lastResult];
                }
            }
            return null;
        },
        getPreviousResult: function () {
            var parent = null;
            var prev = this.getPreviousBlock();
            if (!prev || !prev._lastResult || !prev.enabled) {
                parent = this.getParent();
            } else {
                parent = prev;
            }

            if (parent && !parent._lastResult) {
                var _newParent = parent.getParent();
                if (_newParent) {
                    parent = _newParent;
                }
            }

            if (parent && parent._lastResult != null) {
                if (this.isArray(parent._lastResult)) {
                    return parent._lastResult;
                } else {
                    return parent._lastResult;
                }
            }
            return null;
        },
        _getArg: function (val, escape) {
            var _float = parseFloat(val);
            if (!isNaN(_float)) {
                return _float;
            } else {
                if (val === 'true' || val === 'false') {
                    return val === 'true';
                } else if (val && escape && _.isString(val)) {
                    return '\'' + val + '\'';
                }
                return val;
            }
        },
        /**
         *
         * @returns {Array}
         */
        getArgs: function (settings) {
            var result = [];
            settings = settings || {};
            var _inArgs = settings.args || this._get('args');
            if (settings.override && settings.override.args) {
                _inArgs = settings.override.args;
            }
            if (_inArgs) {//direct json
                result = utils.getJson(_inArgs, null, false);
            }
            //try comma separated list
            if (result && result.length == 0 && _inArgs && _inArgs.length && _.isString(_inArgs)) {

                if (_inArgs.indexOf(',') !== -1) {
                    var splitted = _inArgs.split(',');
                    for (var i = 0; i < splitted.length; i++) {
                        //try auto convert to number
                        var _float = parseFloat(splitted[i]);
                        if (!isNaN(_float)) {
                            result.push(_float);
                        } else {
                            if (splitted[i] === 'true' || splitted[i] === 'false') {
                                result.push(utils.toBoolean(splitted[i]));
                            } else {
                                result.push(splitted[i]);//whatever
                            }
                        }
                    }
                    return result;
                } else {
                    result = [this._getArg(_inArgs)];//single argument
                }
            }

            !_.isArray(result) && (result = []);
            //add previous result
            var previousResult = this.getPreviousResult();
            if (previousResult != null) {
                if (_.isArray(previousResult) && previousResult.length == 1) {
                    result.push(previousResult[0]);
                } else {
                    result.push(previousResult);
                }
            }

            return result || [_inArgs];
        },
        /*
         * Remove : as expected, removes a block
         * @param proto : prototype|instance
         * @param ctrArgs
         * @returns {*}
         */
        remove: function (what) {
            this._destroyed = true;
            if (this.parentId != null && this.parent == null) {
                this.parent = this.scope.getBlockById(this.parentId);
            }
            if (this.parent && this.parent.removeBlock) {
                this.parent.removeBlock(this);
                return;
            }
            what = what || this;
            if (what) {
                if (what.empty) {
                    what.empty();
                }
                delete what.items;
                what.parent = null;
                if (this.items) {
                    this.items.remove(what);
                }
            }

        },
        prepareArgs: function (ctorArgs) {
            if (!ctorArgs) {
                ctorArgs = {};
            }
            //prepare items
            if (!ctorArgs['id']) {
                ctorArgs['id'] = this.createUUID();
            }
            if (!ctorArgs['items']) {
                ctorArgs['items'] = [];
            }
        },
        /**
         * Private add-block function
         * @param proto
         * @param ctrArgs
         * @param where
         * @param publish
         * @returns {*}
         * @private
         */
        _add: function (proto, ctrArgs, where, publish) {
            var block = null;
            try {
                //create or set
                if (ctrArgs) {
                    //use case : normal object construction
                    this.prepareArgs(ctrArgs);
                    block = factory.createBlock(proto, ctrArgs, null, publish);
                } else {
                    //use case : object has been created so we only do the leg work
                    if (ctrArgs == null) {
                        block = proto;
                    }
                    //@TODO : allow use case to use ctrArgs as mixin for overriding
                }
                ///////////////////////
                //  post work

                //inherit scope
                block.scope = this.scope;
                //add to scope
                if (this.scope) {
                    block = this.scope.registerBlock(block, publish);
                }
                if(has('debug')) {
                    if (block.id === this.id) {
                        console.error('adding new block to our self');
                        debugger;
                    }
                }
                block.parent = this;
                block.parentId = this.id;
                block.scope = this.scope;

                var container = where || this._getContainer();
                if (container) {
                    if (!this[container]) {
                        this[container] = [];
                    }
                    var index = this.indexOf(this[container], block);
                    if (index !== -1) {
                        console.error(' have already ' + block.id + ' in ' + container);
                    } else {
                        if (this.id == block.id) {
                            console.error('tried to add our self to ' + container);
                            return;
                        }
                        this[container].push(block);
                    }
                }
                block.group = null;
                return block;
            } catch (e) {
                logError(e, '_add');
            }
            return null;

        },
        getStore: function () {
            return this.getScope().getStore();
        },
        /**
         * Public add block function
         * @param proto {}
         * @param ctrArgs
         * @param where
         * @returns {*}
         */
        add: function (proto, ctrArgs, where) {
            var block = this._add(proto, ctrArgs, where);
            return block.getStore().getSync(block.id);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Run 
        //
        /////////////////////////////////////////////////////////////////////////////////////
        getContext: function () {
            if (this.scope.instance && this.scope.instance) {
                return this.scope.instance;
            }
            return null;
        },
        resolved: function () {
            if (this._deferredObject) {
                this._deferredObject.resolve();
                delete this._deferredObject;
            }
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        _solve: function (scope, settings) {
            settings = settings || {highlight: false};
            var ret = [];
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                this.addToEnd(ret, block.solve(scope, settings));
            }
            return ret;
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solve: function (scope, settings) {
            settings = settings || {highlight: false};
            var ret = [];
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                this.addToEnd(ret, block.solve(scope, settings));
            }
            return ret;
        },
        /***
         * Solves all the commands into items[]
         *
         * @param manager   =>  BlockManager
         * @return  list of commands to send
         */
        solveMany: function (scope, settings) {
            if (!this._lastRunSettings && settings) {
                this._lastRunSettings = settings;
            }
            settings = this._lastRunSettings || settings;
            this._currentIndex = 0;
            this._return = [];
            var ret = [], items = this[this._getContainer()];

            if (items.length) {
                var res = this.runFrom(items, 0, settings);
                this.onSuccess(this, settings);
                return res;
            } else {
                this.onSuccess(this, settings);
            }
            return ret;
        },
        runFrom: function (blocks, index, settings) {
            var thiz = this;
            blocks = blocks || this.items;
            if(!this._return){
                this._return = [];
            }
            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };
            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    onFinishBlock(block, results);
                });
            };

            if (blocks.length) {
                for (var n = index; n < blocks.length; n++) {
                    var block = blocks[n];
                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        this.addToEnd(this._return, block.solve(this.scope, settings));
                        break;
                    } else {
                        this.addToEnd(this._return, block.solve(this.scope, settings));
                    }
                }
            } else {
                this.onSuccess(this, settings);
            }
            return this._return;
        },
        serializeField: function (name) {
            return this.ignoreSerialize.indexOf(name) == -1;//is not in our array
        },
        onLoad: function () {
        },
        activate: function () {
        },
        deactivate: function () {
        },
        _get: function (what) {
            if (this.override) {
                return (what in this.override ? this.override[what] : this[what]);
            }
        },
        onDidRun: function () {
            if (this.override) {
                this.override.args && delete this.override.args;
                delete this.override;
            }
        },
        destroy: function () {
            this.stop(true);
            this.reset();
            this._destroyed = true;
        },
        reset: function () {
            this._lastSettings = {};
            clearTimeout(this._loop);
            this._loop = null;
            delete this.override;
            this.override = null;
            delete this._lastResult;
            this.override = {};
        },
        stop: function () {
            this.reset();
            this.getItems && _.invoke(this.getItems(), 'stop');
        }

    });
    Block.FLAGS = types.BLOCK_FLAGS;
    Block.EMITS = types.BLOCK_CALLBACKMASK;
    //that's really weird: using dynamic base classes nor Block.extend doesnt work.
    //however, move dojo complete out of blox
    if (!Block.prototype.onSuccess) {
        Block.prototype.onSuccess = function () {
        };
        Block.prototype.onRun = function () {
        };
        Block.prototype.onFailed = function () {
        };
    }
    dcl.chainAfter(Block, 'stop');
    dcl.chainAfter(Block, 'destroy');
    dcl.chainAfter(Block, 'onDidRun');
    return Block;
});;
/** @module xblox/model/functions/StopBlock **/
define('xblox/model/functions/StopBlock',[
    'dcl/dcl',
    'xide/utils',
    "xblox/model/Block"
], function(dcl,utils,Block){
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Block,{
        declaredClass:"xblox.model.functions.StopBlock",
        command:'Select command please',
        icon:'',
        args:null,
        _timeout:100,
        hasInlineEdits:true,
        solve:function(scope,settings) {
            if (this.command){
                var block = scope.resolveBlock(this.command);
                if(block && block.stop){
                    var res = block.stop();
                    this.onSuccess(this,settings);
                }else{
                    this.onFailed(this,settings);
                }
                return res;
            }
        },
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode){
            return "<a tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){
            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){
            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            return this.getBlockIcon('D') + 'Stop Command : ' + text;
        },
        onChangeField:function(what,value){
        },
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));
            return fields;
        }
    });
});;
define('xblox/model/functions/CallBlock',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    "xblox/model/Block",
    "xcf/model/Command"
], function(dcl,utils,types,Deferred,Block,Command){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.functions.CallBlock
    /**
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Command,{
        declaredClass:"xblox.model.functions.CallBlock",
        //command: (String)
        //  block action name
        command:'Select command please',
        icon:'',
        args:null,
        _timeout:100,

        isCommand:true,


        _commandHandles:null,
        /**
         * onCommandFinish will be excecuted which a driver did run a command
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandProgress:function(msg){

            var scope = this.getScope();
            var context = scope.getContext();//driver instance
            var result = {};
            var params = msg.params;

            if(params && params.id){
                this._emit('cmd:'+msg.cmd + '_' + params.id,{
                    msg:msg
                });
                msg.lastResponse && this.storeResult(msg.lastResponse);
                this._emit('progress',{
                    msg:msg,
                    id:params.id
                });
            }

            var command = this._lastCommand;

            this._lastResult = null;


            this._lastResult = msg ? msg.result : null;

            var items = this.getItems(types.BLOCK_OUTLET.PROGRESS);
            if(!this._lastSettings){
                this._lastSettings = {}
            }
            this._lastSettings.override = {};
            if(items.length) {
                this.runFrom(items,0,this._lastSettings);
            }
        },
        stop:function(){
            this._lastCommand && this._lastCommand.stop();
        },
        pause:function(){
            this._lastCommand && this._lastCommand.pause();
        },
        destroy:function(){
            _.invoke(this._commandHandles,'remove');
            delete this._commandHandles;
            delete this._lastCommand;
        },
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {
            if(!this._commandHandles){
                this._commandHandles=[];
            }else{
                _.invoke(this._commandHandles,'remove');
                this._commandHandles = [];
            }

            var timeout = this._timeout || 50;
            if(_.isString(timeout)){
                timeout = parseInt(timeout);
            }

            var dfd = new Deferred();

            var handles = this._commandHandles;

            settings = settings || {}

            setTimeout(function(){
                if (this.command){

                    var _args = null;
                    if(this.args){

                        settings.override = settings.override || {};
                        var args = scope.expressionModel.replaceVariables(scope,this.args,false,false,null,null,{
                            begin:"%%",
                            end:"%%"
                        });
                        try {
                            _args = utils.fromJson(args);
                        }catch(e){
                            _args = args;
                        }
                        settings.override['args']= _.isArray(_args) ? _args : [args];
                        settings.override['mixin']=_args;
                    }
                    this._lastCommand = scope.resolveBlock(this.command);
                    
                    if(this._lastCommand){
                        handles.push(this._lastCommand._on('paused',this.onCommandPaused,this));
                        handles.push(this._lastCommand._on('finished',this.onCommandFinish,this));
                        handles.push(this._lastCommand._on('stopped',this.onCommandStopped,this));
                        handles.push(this._lastCommand._on('error',this.onCommandError,this));
                        handles.push(this._lastCommand._on('progress',this.onCommandProgress,this));                    
                    }
                    
                    var res = scope.solveBlock(this.command,settings);
                    if(res){
                        this.onSuccess(this,settings);
                    }else{
                        this.onFailed(this,settings);
                    }
                    dfd.resolve(res);
                    return res;
                }
            }.bind(this),timeout);
            return dfd;
        },
        hasInlineEdits:true,
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode,options,value){
            var optionsString = "";
            return "<a " + optionsString + "  tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){
            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){
            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            var _out = this.getBlockIcon('D') + 'Call Command : ' + text;
            return _out;
        },
        //  standard call for editing
        getFields:function(){

            var fields = this.getDefaultFields();
            var thiz=this;

            var title = 'Command';

            if(this.command.indexOf('://')){
                title = this.scope.toFriendlyName(this,this.command);
            }

            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));

            fields.push(utils.createCI('arguments',27,this.args,{
                group:'Arguments',
                title:'Arguments',
                dst:'args'
            }));

            fields.push(utils.createCI('timeout',13,this._timeout,{
                group:'General',
                title:'Delay',
                dst:'_timeout'
            }));

            return fields;
        }
    });
});;
define('xblox/factory/Blocks',[
    'xide/factory',
    'xide/utils',
    'xide/types',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    "xblox/model/logic/CaseBlock",
    "xblox/model/Block",
    "xblox/model/functions/CallBlock",
    "xblox/model/functions/StopBlock",
    "xblox/model/functions/PauseBlock",
    "xblox/model/functions/SetProperties",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/logging/Log",
    "xblox/model/server/RunServerMethod",
    "xblox/model/server/Shell",
    "xblox/model/code/RunBlock",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    "xblox/model/mqtt/Subscribe",
    "xblox/model/mqtt/Publish",
    "xblox/model/File/ReadJSON",
    "xcf/factory/Blocks"
], function (factory,
             utils,
             types,
             ReloadMixin, EventedMixin,
             CaseBlock,
             Block,
             CallBlock,
             StopBlock,
             PauseBlock,
             SetProperties,
             CallMethod,
             RunScript,
             ForBlock,
             WhileBlock,
             VariableAssignmentBlock,
             IfBlock,
             ElseIfBlock,
             SwitchBlock,
             VariableSwitch,
             Log,
             RunServerMethod,
             Shell,
             RunBlock,
             OnEvent,
             OnKey,
             Subscribe,
             Publish,
             ReadJSON) {

    var cachedAll = null;
    /***
     *
     * @param mixed String|Prototype
     * @param ctorArgs
     * @param baseClasses
     * @param publish
     */
    factory.createBlock = function (mixed, ctorArgs, baseClasses, publish) {
        //complete missing arguments:
        Block.prototype.prepareArgs(ctorArgs);
        var block = factory.createInstance(mixed, ctorArgs, baseClasses);
        block.ctrArgs = null;
        var newBlock;
        try {
            if (block && block.init) {
                block.init();
            }
            //add to scope
            if (block.scope) {
                newBlock = block.scope.registerBlock(block, publish);
            }
            if (block.initReload) {
                block.initReload();
            }
        } catch (e) {
            logError(e, 'create block');
        }
        return newBlock || block;
    };
    factory.clearVariables = function () {
    };
    factory.getAllBlocks = function (scope, owner, target, group, allowCache) {
        if (allowCache !== false && cachedAll != null) {
            return cachedAll;
        } else if (allowCache == false) {
            cachedAll = null;
        }
        var items = factory._getFlowBlocks(scope, owner, target, group);
        items = items.concat(factory._getLoopBlocks(scope, owner, target, group));
        items = items.concat(factory._getCommandBlocks(scope, owner, target, group));
        items = items.concat(factory._getCodeBlocks(scope, owner, target, group));
        items = items.concat(factory._getEventBlocks(scope, owner, target, group));
        items = items.concat(factory._getLoggingBlocks(scope, owner, target, group));
        items = items.concat(factory._getServerBlocks(scope, owner, target, group));
        items = items.concat(factory._getMQTTBlocks(scope, owner, target, group));
        items = items.concat(factory._getFileBlocks(scope, owner, target, group));
        cachedAll = items;
        return items;
    };
    factory._getMQTTBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'MQTT',
            iconClass: 'fa-cloud',
            items: [
                {
                    name: 'Subscribe',
                    owner: owner,
                    iconClass: 'fa-bell',
                    proto: Subscribe,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Publish',
                    owner: owner,
                    iconClass: 'fa-send',
                    proto: Publish,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });
        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'MQTT'
        });
        return items;

    };

    factory._getFileBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'File',
            iconClass: 'fa-file',
            items: [
                {
                    name: '%%Read JSON',
                    owner: owner,
                    iconClass: 'fa-file',
                    proto: ReadJSON,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'File'
        });
        return items;

    };

    factory._getServerBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Server',
            iconClass: 'el-icon-repeat',
            items: [
                {
                    name: 'Run Server Method',
                    owner: owner,
                    iconClass: 'fa-plug',
                    proto: RunServerMethod,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Shell',
                    owner: owner,
                    iconClass: 'fa-code',
                    proto: Shell,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Server'
        });
        return items;
    };
    factory._getVariableBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Flow',
            iconClass: 'el-icon-random',
            items: [
                {
                    name: 'If...Else',
                    owner: owner,
                    iconClass: 'el-icon-fork',
                    proto: IfBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group,
                        condition: "[value]=='PW'"
                    }
                }/*,
                 {
                 name:'Switch',
                 owner:owner,
                 iconClass:'el-icon-fork',
                 proto:SwitchBlock,
                 target:target,
                 ctrArgs:{
                 scope:scope,
                 group:group
                 }
                 }
                 */
            ]
        });

        return items;
    };
    factory._getEventBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Events',
            iconClass: 'fa-bell',
            items: [
                {
                    name: 'On Event',
                    owner: owner,
                    iconClass: 'fa-bell',
                    proto: OnEvent,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'On Key',
                    owner: owner,
                    iconClass: 'fa-keyboard-o',
                    proto: OnKey,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });
        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Events'
        });

        return items;
    };
    factory._getLoggingBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Logging',
            iconClass: 'fa-bug',
            items: [
                {
                    name: 'Log',
                    owner: owner,
                    iconClass: 'fa-bug',
                    proto: Log,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Logging'
        });

        return items;
    };
    factory._getCodeBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Code',
            iconClass: 'fa-code',
            items: [
                {
                    name: 'Call Method',
                    owner: owner,
                    iconClass: 'el-icon-video',
                    proto: CallMethod,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Run Script',
                    owner: owner,
                    iconClass: 'fa-code',
                    proto: RunScript,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Run Block',
                    owner: owner,
                    iconClass: 'fa-code',
                    proto: RunBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Set Properties',
                    owner: owner,
                    iconClass: 'fa-code',
                    proto: SetProperties,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });
        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Code'
        });
        return items;
    };
    factory._getFlowBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Flow',
            iconClass: 'el-icon-random',
            items: [
                {
                    name: 'If...Else',
                    owner: owner,
                    iconClass: 'el-icon-fork',
                    proto: IfBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group,
                        condition: "[value]=='PW'"
                    }
                },
                {
                    name: 'Switch',
                    owner: owner,
                    iconClass: 'el-icon-fork',
                    proto: SwitchBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                },
                {
                    name: 'Variable Switch',
                    owner: owner,
                    iconClass: 'el-icon-fork',
                    proto: VariableSwitch,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Flow'
        });
        return items;
    };
    factory._getLoopBlocks = function (scope, owner, target, group) {
        var items = [];
        items.push({
            name: 'Loops',
            iconClass: 'el-icon-repeat',
            items: [
                {
                    name: 'While',
                    owner: owner,
                    iconClass: 'el-icon-repeat',
                    proto: WhileBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group,
                        condition: "[Volume]<=100"
                    }
                },
                {
                    name: 'For',
                    owner: owner,
                    iconClass: 'el-icon-repeat',
                    proto: ForBlock,
                    target: target,
                    ctrArgs: {
                        scope: scope,
                        group: group,
                        initial: '1',
                        comparator: "<=",
                        "final": '5',
                        modifier: '+1',
                        counterName: 'value'
                    }
                }
            ]
        });

        //tell everyone
        factory.publish(types.EVENTS.ON_BUILD_BLOCK_INFO_LIST, {
            items: items,
            group: 'Loops'
        });
        return items;
    };
    factory._getMathBlocks = function (scope, owner, dstItem, group) {
        var items = [];
        items.push({
            name: 'Math',
            owner: this,
            iconClass: 'el-icon-qrcode',
            dstItem: dstItem,
            items: [
                {
                    name: 'If...Else',
                    owner: dstItem,
                    iconClass: 'el-icon-compass',
                    proto: IfBlock,
                    item: dstItem,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });
        return items;
    };
    factory._getTimeBlocks = function (scope, owner, dstItem, group) {
        var items = [];
        items.push({
            name: 'Time',
            owner: this,
            iconClass: 'el-icon-qrcode',
            dstItem: dstItem,
            items: [
                {
                    name: 'If...Else',
                    owner: dstItem,
                    iconClass: 'el-icon-time',
                    proto: IfBlock,
                    item: dstItem,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }

            ]
        });
        return items;
    };
    factory._getTransformBlocks = function (scope, owner, dstItem, group) {
        var items = [];
        items.push({
            name: 'Time',
            owner: this,
            iconClass: 'el-icon-magic',
            dstItem: dstItem,
            items: [
                {
                    name: 'If...Else',
                    owner: dstItem,
                    iconClass: 'el-icon-time',
                    proto: IfBlock,
                    item: dstItem,
                    ctrArgs: {
                        scope: scope,
                        group: group
                    }
                }
            ]
        });
        return items;
    };
    return factory;
});;
/** @module xblox/model/File/ReadJSON **/
define('xblox/model/File/ReadJSON',[
    'dcl/dcl',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'xide/types',
    "xdojo/has!xblox-ui?xfile/data/DriverStore",
    'xdojo/has!xblox-ui?xfile/views/FileGridLight'
], function (dcl, Deferred, Block, utils, Contains, types, DriverStore, FileGridLight) {

    /**
     *
     * @param ext
     * @param config
     * @param options
     * @param fileServer
     * @returns {*}
     */
    function createStore(ext,options,fileServer) {
        return new DriverStore({
            data: [],
            config: {},
            mount: 'none',
            options: options,
            driver: fileServer,
            micromatch: "(*.json)|!(*.*)", // Only folders and json files
            //micromatch: "(*.mp3)|(*.wav)|(*.webm)|!(*.*)", // Only folders and json files
            glob: ext
        });
    }
    /**
     *
     * @class module:xblox/model/code/RunScript
     * @extends module:xblox/model/Block
     * @augments module:xblox/model/Block_UI
     */
    return dcl([Block, Contains], {
        declaredClass: "xblox.model.File.ReadJSON",
        name: 'Read JSON',
        deferred: false,
        sharable: false,
        context: null,
        icon: 'fa-file',
        observed: [
            'path'
        ],
        getContext: function () {
            return this.context || (this.scope.getContext ? this.scope.getContext() : this);
        },
        getFileContent: function (path) {
            var scope = this.getScope();
            var ctx = scope.ctx;
            var deviceManager = ctx.getDeviceManager();
            var fileServer = deviceManager.getInstanceByName('File-Server');
            return fileServer.callCommand('GetProg', {
                override: {
                    args: [path]
                }
            });
        },
        processJSON: function (data, settings) {
            var path = this.jsonPath;
            if (path) {
                this._lastResult = utils.getAt(data, path);
            } else {
                this._lastResult = data;
            }
            this.onSuccess(this, settings);
            this.runByType(types.BLOCK_OUTLET.FINISH, settings);
        },
        /**
         *
         * @param scope
         * @param settings
         * @param isInterface
         * @param run
         * @param error
         * @returns {Deferred}
         */
        solve: function (scope, settings, isInterface, run, error) {
            this._currentIndex = 0;
            this._return = [];
            settings = this._lastSettings = settings || this._lastSettings || {};
            var _script = ('' + this._get('path')),
                thiz = this,
                dfd = new Deferred(),
                self = this;

            this.onRunThis(settings);
            var expression = scope.expressionModel.replaceVariables(scope, _script, null, null);
            var getDfd = this.getFileContent(expression);
            getDfd.then(function (data) {
                var content = data.content;
                if (content) {
                    content = utils.getJson(content, true);
                    if (content) {
                        self.processJSON(content, settings);
                    }
                }
            }.bind(this));
            try {
                if (run) {
                    run('Expression ' + _script + ' evaluates to ' + expression);
                }
            } catch (e) {
                thiz.onDidRunItemError(dfd, e, settings);
                thiz.onFailed(thiz, settings);
                if (error) {
                    error('invalid expression : \n' + _script + ': ' + e);
                }
            }
            return dfd;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI impl.
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {
            var result = '<span style="">' + this.getBlockIcon() + ' ' + this.name + ' :: ' + '</span>';
            if (this.path) {
                result += this.path.substr(0, 50);
            }
            return result;
        },
        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var scope = this.getScope();
            var ctx = scope.ctx;
            var deviceManager = ctx.getDeviceManager();
            var fileServer = deviceManager.getInstanceByName('File-Server');//system's default
            var permissions = utils.clone(types.DEFAULT_FILE_GRID_PERMISSIONS);
            if (fileServer && DriverStore) {
                var FilePickerOptions = {
                    ctx: ctx,
                    owner: this,
                    selection: '/',
                    resizeToParent: true,
                    Module: FileGridLight,
                    permissions: permissions
                },
                options = {
                    fields: types.FIELDS.SHOW_ISDIR | types.FIELDS.SHOW_OWNER | types.FIELDS.SHOW_SIZE |
                    types.FIELDS.SHOW_FOLDER_SIZE |
                    types.FIELDS.SHOW_MIME |
                    types.FIELDS.SHOW_PERMISSIONS |
                    types.FIELDS.SHOW_TIME |
                    types.FIELDS.SHOW_MEDIA_INFO
                };
                FilePickerOptions.leftStore = createStore("/*",options,fileServer);
                FilePickerOptions.rightStore = createStore("/*",options,fileServer);
                fields.push(utils.createCI('path', 4, this.path, {
                    group: 'General',
                    title: 'Path',
                    dst: 'path',
                    filePickerOptions: FilePickerOptions,
                    widget: {
                        item: this
                    }
                }));
            }
            fields.push(utils.createCI('jsonPath', 13, this.jsonPath, {
                group: 'General',
                title: 'Select',
                dst: 'jsonPath'
            }));
            return fields;
        }
    });
});;
define('xblox/model/Contains',[
    'dcl/dcl',
    "dojo/promise/all",
    "xide/types"
], function (dcl, all, types) {
    /**
     * Contains provides implements functions to deal with sub blocks.
     */
    return dcl(null, {
        declaredClass: 'xblox.model.Contains',
        runByType: function (outletType, settings) {
            var items = this.getItemsByType(outletType);
            if (items.length) {
                this.runFrom(items, 0, settings);
            }
        },
        getItemsByType: function (outletType) {
            var items = this.items;
            if (!outletType) {
                return items;
            }
            var result = [];
            _.each(items, function (item) {
                if (item.outlet & outletType) {
                    result.push(item);
                }
            });
            return result;
        },
        getContainer: function () {
            return this[this._getContainer()];
        },
        /**
         * Store is asking this!
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            var items = this[this._getContainer()];
            return items != null && items.length > 0;
        },
        /**
         * Store function
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this[this._getContainer()];
        },
        //  standard call from interface
        canAdd: function () {
            return [];
        },
        /***
         * Generic: run sub blocks
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        _solve: function (scope, settings, run, error) {
            if (!this._lastRunSettings && settings) {
                this._lastRunSettings = settings;
            }
            settings = this._lastRunSettings || settings;
            this._currentIndex = 0;
            this._return = [];
            var ret = [], items = this[this._getContainer()];
            if (items.length) {
                var res = this.runFrom(items, 0, settings);
                this.onSuccess(this, settings);
                return res;
            } else {
                this.onSuccess(this, settings);
            }
            return ret;
        },
        onDidRunItem: function (dfd, result) {
            this._emit(types.EVENTS.ON_RUN_BLOCK_SUCCESS, this);
            dfd.resolve(result);
        },
        onDidRunItemError: function (dfd, result) {
            dfd.reject(result);
        },
        onRunThis: function () {
            this._emit(types.EVENTS.ON_RUN_BLOCK, this);
        },
        onDidRunThis: function (dfd, result, items, settings) {
            var thiz = this;
            //more blocks?
            if (items && items.length) {
                var subDfds = thiz.runFrom(items, 0, settings);
                all(subDfds).then(function () {
                    thiz.onDidRunItem(dfd, result, settings);
                }, function (err) {
                    thiz.onDidRunItem(dfd, err, settings);
                });

            } else {
                thiz.onDidRunItem(dfd, result, settings);
            }
        },
        ___solve: function (scope, settings, run, error) {
        }
    });
});;
/** @module xblox/model/mqtt/Publish **/
define('xblox/model/mqtt/Publish',[
    'dcl/dcl',
    'xdojo/has',
    'xide/utils',
    'xide/types',
    'xcf/model/Command'
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
], function (dcl, has, utils, types, Command, tracer, _console) {

    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */

    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if (isServer && tracer && console && console.error) {
        console = _console;
    }

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    /**
     * Base block class.
     *
     * @class module:xblox/model/mqtt/Publish
     * @extends module:xblox/model/Block
     */
    return dcl(Command, {
        declaredClass: "xblox.model.mqtt.Publish",
        //method: (String)
        //  block action name
        name: 'Publish',
        //method: (String)
        //  block action name
        topic: '',
        args: '',
        deferred: false,
        sharable: true,
        context: null,
        icon: 'fa-send',
        isCommand: true,
        qos: 0,
        retain: false,
        /**
         * @type {string|null}
         */
        path: null,
        onData: function (message) {
            if (message && message.topic && message.topic == this.topic) {
                var thiz = this,
                    ctx = this.getContext(),
                    items = this[this._getContainer()];

                var settings = this._lastSettings;
                var ret = [];
                if (items.length > 0) {

                    var value = message;
                    this.path = 'value';
                    if (this.path && _.isObject(message)) {
                        value = utils.getAt(message, this.path, message);
                    }

                    for (var n = 0; n < this.items.length; n++) {
                        var block = this.items[n];
                        if (block.enabled) {
                            block.override = {
                                args: [value]
                            };
                            ret.push(block.solve(this.scope, settings));
                        }
                    }
                }
                this.onSuccess(this, this._lastSettings);
                return ret;
            }
        },
        observed: [
            'topic'
        ],
        getContext: function () {
            return this.context || (this.scope.getContext ? this.scope.getContext() : this);
        },
        /**
         *
         * @param scope
         * @param settings
         * @param isInterface
         * @returns {boolean}
         */
        solve: function (scope, settings, isInterface) {
            this._currentIndex = 0;
            this._return = [];
            settings = this._lastSettings = settings || this._lastSettings;

            var instance = this.getInstance();
            if (isInterface == true && this._loop) {
                this.reset();
            }

            var args = this.args;
            var inArgs = this.getArgs(settings);
            if (inArgs[0]) {
                args = inArgs[0];
            }

            if (instance) {
                var value = utils.getJson(args, true, false);
                if (value === null || value === 0 || value === true || value === false || !_.isObject(value)) {
                    value = {
                        payload: this.args
                    }
                }

                var topic = scope.expressionModel.replaceVariables(scope, this.topic, false, false);

                instance.callMethod('publishTopic', utils.mixin({
                    topic: topic,
                    qos: this.qos,
                    retain: this.retain
                }, value), this.id, this.id);
            }

            settings = settings || {};
            this.onDidRun();
            this.onSuccess(this, settings);
            return true;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function (icon) {
            var out = '<span style="">' + this.getBlockIcon() + ' ' + this.makeEditable('name', 'top', 'text', 'Enter a name', 'inline') + ' :: ' + '</span>';
            if (this.topic) {
                out += this.makeEditable('topic', 'bottom', 'text', 'Enter a topic', 'inline');
                this.startup && (out += this.getIcon('fa-bell inline-icon text-warning', 'text-align:right;float:right;', ''));
                this.interval > 0 && (out += this.getIcon('fa-clock-o inline-icon text-warning', 'text-align:right;float:right', ''));
            }
            return out;
        },
        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(utils.createCI('qos', types.ECIType.ENUMERATION, this.qos, {
                    group: 'General',
                    title: 'QOS',
                    dst: 'qos',
                    widget: {
                        options: [
                            {
                                label: "0 - at most once",
                                value: 0
                            },
                            {
                                label: "1 - at least once",
                                value: 1
                            },
                            {
                                label: "2 - exactly once",
                                value: 2
                            }
                        ]
                    }
                })
            );
            fields.push(utils.createCI('arguments', 27, this.args, {
                group: 'Arguments',
                title: 'Arguments',
                dst: 'args'
            }));
            fields.push(utils.createCI('topic', types.ECIType.STRING, this.topic, {
                group: 'General',
                title: 'Topic',
                dst: 'topic',
                select: true
            }));
            fields.push(utils.createCI('retain', types.ECIType.BOOL, this.retain, {
                group: 'General',
                title: 'Retain',
                dst: 'retain'
            }));
            fields.remove(_.find(fields, {
                name: "send"
            }));

            fields.remove(_.find(fields, {
                name: "waitForResponse"
            }));
            return fields;
        }
    });
});;
/** @module xblox/model/mqtt/Subscribe **/
define('xblox/model/mqtt/Subscribe',[
    'dcl/dcl',
    'xdojo/has',
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'xide/types'
    //'dojo/has!host-node?dojo/node!tracer',
    //'dojo/has!host-node?nxapp/utils/_console'
], function(dcl,has,Block,utils,Contains,types,tracer,_console){

    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }
    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    /**
     * Base block class.
     *
     * @class module:xblox/model/mqtt/Subscribe
     * @extends module:xblox/model/Block
     */
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.mqtt.Subscribe",
        //method: (String)
        //  block action name
        name:'Subscribe',
        //method: (String)
        //  block action name
        topic:'Topic',
        args:'',
        deferred:false,
        sharable:true,
        context:null,
        icon:'fa-bell',
        /**
         * @type {string|null}
         */
        path:'',
        qos:0,
        stop:function(){
            var instance = this.getInstance();
            if(instance){
                instance.callMethod('unSubscribeTopic',utils.mixin({
                    topic:this.topic
                },utils.getJson(this.args || {})),this.id,this.id);
            }
        },
        onData:function(message){
            if(message && message.topic && message.topic==this.topic){
                delete message['src'];
                delete message['id'];
                var items = this[this._getContainer()];
                var settings = this._lastSettings;
                var ret=[];
                if(items.length>0){
                    var value = message;
                    var path = this.path && this.path.length ? this.path : (message.payload!==null) ? 'payload' : null;
                    if(path && _.isObject(message)){
                        value = utils.getAt(message,path,message);
                    }
                    for(var n = 0; n < this.items.length ; n++)
                    {
                        var block = this.items[n];
                        if(block.enabled) {
                            block.override ={
                                args: [value]
                            };
                            ret.push(block.solve(this.scope,settings));
                        }
                    }
                }
                this.onSuccess(this, this._lastSettings);
                return ret;
            }
        },
        observed:[
            'topic'
        ],
        getContext:function(){
            return this.context || (this.scope.getContext ?  this.scope.getContext() : this);
        },
        solve:function(scope,settings){
            this._currentIndex = 0;
            this._return=[];
            this._lastSettings = settings;
            var instance = this.getInstance();

            if(instance){
                instance.callMethod('subscribeTopic',utils.mixin({
                    topic:this.topic,
                    qos:this.qos
                },utils.getJson(this.args ||"{}")),this.id,this.id);
            }
            settings = settings || {};
            this.onRunThis(settings);
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){
            var result = '<span style="">' +
                this.getBlockIcon() + '' + this.makeEditable('topic','bottom','text','Enter a topic','inline') + ' :: '+'</span>';

            if(this.topic){
                result+= this.topic.substr(0,30);
            }
            return result;
        },
        //  standard call from interface
        canAdd:function(){
            return [];
        },
        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(
                utils.createCI('name',13,this.name,{
                    group:'General',
                    title:'Name',
                    dst:'name'
                })
            );

            fields.push(utils.createCI('arguments',27,this.args,{
                    group:'Arguments',
                    title:'Arguments',
                    dst:'args'
                }));

            fields.push(utils.createCI('topic',types.ECIType.STRING,this.topic,{
                    group:'General',
                    title:'Topic',
                    dst:'topic',
                    select:true
                }));

            fields.push(utils.createCI('name',types.ECIType.ENUMERATION,this.qos,{
                    group:'General',
                    title:'QOS',
                    dst:'qos',
                    widget: {
                        options: [
                            {
                                label:"0 - at most once",
                                value:0
                            },
                            {
                                label:"1 - at least once",
                                value:1
                            },
                            {
                                label:"2 - exactly once",
                                value:2
                            }
                        ]
                    }
                })
            );
            fields.push(utils.createCI('path',types.ECIType.STRING,this.path,{
                group:'General',
                title:'Value Path',
                dst:'path'
            }));
            return fields;
        }
    });
});;
define('xblox/model/events/OnKey',[
    'dcl/dcl',
    "dojo/_base/lang",
    "dojo/_base/array",
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    'xblox/model/Contains',
    'xblox/model/events/OnEvent',
    'xide/registry',
    'dojo/on'
], function(dcl,lang,array,Deferred,Block,utils,types,EventedMixin,Referenced,Contains,OnEvent,registry,on){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,EventedMixin.dcl,Referenced.dcl,Contains],{
        declaredClass:"xblox.model.events.OnKey",
        //method: (String)
        //  block action name
        name:'On Key',

        event:'',

        reference:'',

        references:null,

        description:'Triggers when a keyboard sequence ' + this.event +' has been entered',

        listeners:null,

        sharable:true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call from interface
        canAdd:function(){
            return [];
        },

        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(utils.createCI('Keyboard Sequence',types.ECIType.STRING,this.event,{
                group:'General',
                dst:'event',
                value:this.event,
                intermediateChanges:false
            }));

            fields.push(utils.createCI('Object/Widget',types.ECIType.WIDGET_REFERENCE,this.reference,{
                group:'General',
                dst:'reference',
                value:this.reference
            }));
            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-keyboard-o"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        onEvent:function(evt){
            this._lastResult=evt;
            this.solve(this.scope,this._lastRunSettings);

        },
        _addListerner:function(keys,handler,obj){
            if(this.listeners==null){
                this.listeners=[];
            }

            var my_defaults = {
                is_unordered    : true,
                prevent_repeat  : false,
                prevent_default : false,
                on_keyup:function(e){
                    console.log('up');
                },
                on_keydown:function(e){
                    console.log('down');
                },
                on_release:function(e){
                    console.log('release');
                }
            };
            var listener =null;
            listener = new window.keypress.Listener(obj, my_defaults);
            listener.simple_combo(keys, function(e) {
                if(handler){
                    handler(arguments);
                }
            });

            this.listeners.push(listener);
        },
        _subscribe:function(keys,handler,obj){

            if(!keys){
                return;
            }

            if(obj && obj.domNode){
                obj = obj.domNode;
            }

            this._addListerner(keys,handler,obj);

        },
        _registerEvent:function(evt){

            if(!evt || !evt.length){
                return;
            }
            var objects = this.resolveReference(this.deserialize(this.reference));
            var thiz=this;
            if (objects && objects.length) {
                for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    //try widget
                    if (obj && obj.id) {
                        var _widget = registry.byId(obj.id);
                        _widget=null;
                        if (_widget && _widget.on) {
                            var _event = this.event.replace('on','');
                            var _handle = _widget.on(_event,lang.hitch(this,function(e){
                                thiz.onEvent(e);
                            }));
                            this._events.push( _handle);
                        }else{

                            this._subscribe(evt, function(){thiz.onEvent(arguments)},obj);
                        }
                    }else{

                        this._subscribe(evt, function(){thiz.onEvent(arguments)},obj);
                    }
                }
            }else{
                this._subscribe(evt, function(){thiz.onEvent(arguments)});
            }
        },
        onLoad:function(){

            this._onLoaded=true;

            if(this.event && this.event.length && this.enabled){

                this._registerEvent(this.event);
            }
        },
        destroy:function(){
            this.inherited(arguments);
        },
        updateEventSelector:function(objects,cis){

            var options = [];

            if(!objects || !objects.length){
                options= this.scope.getEventsAsOptions(this.event);
            }else{

                options = [{label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if(ci['widget'] && ci['widget'].title==='Event'){
                    //console.log('event!');
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options',options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value',this.event);
                    this.publish(types.EVENTS.RESIZE,{});
                    break;
                }
            }
        },
        onReferenceChanged:function(newValue,cis){

            this._destroy();//unregister previous event(s)

            this.reference = newValue;
            var objects = this.resolveReference(this.deserialize(newValue));
            this._registerEvent(this.event);

        },
        onChangeField:function(field,newValue,cis){

            if(field=='event'){
                this._destroy();    //unregister previous event
                if(this._onLoaded){ // we've have been activated at load time, so re-register our event
                    this.event = newValue;
                    this._registerEvent(newValue);
                }
            }
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }

            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
            this._registerEvent(this.event);
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

            if(this.listeners){

                for (var i = 0; i < this.listeners.length; i++) {
                    var obj = this.listeners[i];
                    obj.stop_listening();
                    var combos = obj.get_registered_combos();
                    if(combos){
                        obj.unregister_many(combos);
                    }
                    obj.reset();

                    console.log('did destroy listener');

                }
            }
            this.listeners=[];
        },
        onFieldsRendered:function(block,cis){}


    });
});;
define('xblox/model/Referenced',[
    'dcl/dcl',
    "dojo/_base/declare",
    "xide/mixins/ReferenceMixin",
    "xide/utils"
], function (dcl,declare, ReferenceMixin,utils) {
    var Implementation = {
        /**
         * JSON String in that format : reference(string) | mode (string)
         */
        reference: null,
        /**
         * 'reference' is a JSON structure
         * @param value
         * @returns {*}
         */
        deserialize: function (value) {
            if (!value || value.length == 0) {
                return {};
            }
            try {
                return utils.fromJson(value);
            } catch (e) {
                return {};
            }
        }
    };
    /**
     * Holds information to locate an object by string or direct reference.
     * This must be used as mixin rather as base class!
     */
    var Module = declare('xblox.model.Referenced', [ReferenceMixin],Implementation);
    Module.dcl = dcl(ReferenceMixin.dcl,Implementation);
    return Module;
});;
define('xide/mixins/ReferenceMixin',[
    'dcl/dcl',
    "dojo/_base/declare",
    'xide/types',
    'xide/utils',
    'xide/registry'
], function (dcl, declare, types, utils, registry) {
    /**
     *
     * @param queryString
     * @param startNode
     * @param single
     * @returns {*}
     */
    utils.find = function (queryString, startNode, single) {
        var nodes = $(startNode).find(queryString);
        if (nodes && nodes.length > 0) {
            return single === false ? nodes : nodes[0];
        }
        return null;
    };

    /**
     *
     * @param scope
     * @param id
     * @returns {*}
     */
    function getElement(scope, id) {
        var dst = scope.document.getElementById(id);
        if (dst) {
            return dst;
        }
        return null;
    }

    var Implementation = {
        _targetReference: null,
        getTarget: function () {
            return this._targetReference || this.inherited(arguments);
        },
        skipWidgetCSSClasses: [
            'dijitButtonHover',
            'dijitHover',
            'dijit',
            'dijitInline',
            'dijitReset',
            'dijitCheckBoxChecked',
            'dijitChecked',
            'dijitLeft'
        ],
        _cssClassesToQuery: function (string) {
            var result = '';
            if (string) {
                var els = string.split(' ');
                for (var i = 0; i < els.length; i++) {

                    if (utils.contains(this.skipWidgetCSSClasses, els[i]) > -1 ||
                        els[i].toLowerCase().indexOf('hover') > -1) {
                        continue;
                    }
                    result += '' + els[i];
                }
            }
            return result.trim();
        },
        resolveReference: function (params,settings) {
            var override = null;
            try{
                override = this.getTarget();
            }catch(e){
                logError(e);
                return null;
            }
            var scope = this.scope;

            var query = params.reference;


            if (!params || !query || !query.length) {
                if (override) {
                    return [override];
                }
            }

            switch (params.mode) {
                //By id, try widget instance first, then try regular HTMLElement
                //
                case types.WIDGET_REFERENCE_MODE.BY_ID:
                {
                    if (this.scope && this.scope.document) {
                        var out = [];
                        if (query.indexOf(' ') !== -1) {

                            var ids = query.split(' ');
                            for (var i = 0; i < ids.length; i++) {
                                var el = getElement(scope, ids[i]);
                                if (el) {
                                    out.push(el);
                                }
                            }
                        } else {
                            return [getElement(scope, query)];
                        }
                        return out;
                    }

                    var _byRegistry = registry.byId(query);
                    var _byDoc = typeof document !=='undefined' ? document.getElementById(query) : null;
                    if(_byRegistry || _byDoc){
                        return _byRegistry ? [_byRegistry] : [_byDoc];
                    }
                    break;
                }
                //By declared widget class
                //
                case types.WIDGET_REFERENCE_MODE.BY_CLASS:
                {
                    var obj = dojo.getObject(query) || dcl.getObject(query);
                    if (obj) {
                        return [obj];
                    }
                    break;
                }
                // By css class list
                //
                case types.WIDGET_REFERENCE_MODE.BY_CSS:
                {
                    var _query = this._cssClassesToQuery(query);
                    this._parseString && (_query = this._parseString(_query,settings,null,settings && settings.flags ? settings.flags : types.CIFLAG.EXPRESSION) || _query);
                    var _$ = null;
                    if (this.scope && this.scope.global && this.scope.global['$']) {
                        _$ = this.scope.global['$'];
                    }else if(typeof $!=='undefined'){
                        _$ = $;
                    }
                    if (_$) {
                        var _elements = _$(_query);
                        if (_elements) {
                            return _elements;
                        }
                    }
                    var objects = utils.find(_query, null, false);
                    if (objects) {
                        return objects;
                    }
                    break;
                }
            }
            return null;
        }
    };
    var Module = declare('xblox.model.ReferenceMixin', null, Implementation);
    Module.dcl = dcl(null, Implementation);
    return Module;
});;
define('xblox/model/events/OnEvent',[
    'dcl/dcl',
    "dojo/_base/lang",
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    'xide/registry',
    'dojo/on',
    'xwire/_Base'
], function(dcl,lang,Deferred,Block,utils,types,EventedMixin,Referenced,registry,on,_Base){




    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl([Block,EventedMixin.dcl,Referenced.dcl,_Base],{
        declaredClass:"xblox.model.events.OnEvent",
        //method: (String)
        //  block action name
        name:'On Event',
        event:'',
        reference:'',
        references:null,
        sharable:true,
        _didSubscribe:false,
        filterPath:"item.name",
        filterValue:"",
        valuePath:"item.value",
        _nativeEvents:[
            "onclick",
            "ondblclick",
            "onmousedown",
            "onmouseup",
            "onmouseover",
            "onmousemove",
            "onmouseout",
            "onkeypress",
            "onkeydown",
            "onkeyup",
            "onfocus",
            "onblur",
            "onchange"
        ],

        stop:function(){

            this._destroy();

        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve:function(scope,settings,isInterface,error) {

            if(isInterface){
                this._destroy();
            }

            settings = this._lastSettings = settings || this._lastSettings;

            if(!this._didSubscribe){
                this._registerEvent(this.event);
                this.onSuccess(this, settings);
                return false;
            }

            this.onSuccess(this, settings);

            this._currentIndex=0;
            this._return=[];

            var ret=[], items = this[this._getContainer()];
            if(items.length) {
                //console.log('solve ',settings);
                var res = this.runFrom(items,0,settings);
                this.onSuccess(this, settings);
                return res;
            }else{
                this.onSuccess(this, settings);
            }
            return ret;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){
            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call from interface
        canAdd:function(){
            return [];
        },

        //  standard call for editing
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;

            var _ref = this.deserialize(this.reference);
            var isNative = utils.contains(this._nativeEvents,this.event)>-1;
            var options = null;
            if(!isNative){
                options = this.scope.getEventsAsOptions(this.event);
            }else{

                options = [
                    {label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}
                ];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }


            fields.push(utils.createCI('Event',types.ECIType.ENUMERATION,this.event,{
                group:'General',
                options:options,
                dst:'event',
                widget:{
                    search:true
                }
            }));

            fields.push(utils.createCI('Filter Path',13,this.filterPath,{
                group:'General',
                dst:'filterPath'
            }));

            fields.push(utils.createCI('Filter Value',13,this.filterValue,{
                group:'General',
                dst:'filterValue'
            }));

            fields.push(utils.createCI('Value Path',13,this.valuePath,{
                group:'General',
                dst:'valuePath'
            }));


            fields.push(utils.createCI('Object/Widget',types.ECIType.WIDGET_REFERENCE,this.reference,{
                group:'Widget',
                dst:'reference',
                value:this.reference
            }));
            return fields;
        },

        getBlockIcon:function(){
            return '<span class="fa-bell"></span>';
        },
        onEvent:function(evt){

            this._lastResult=evt;

            /*
            if(this.scope && evt.scope && evt.scope!==this.scope){
                return;
            }*/

            if(this.filterPath && this.filterValue){
                var value = this.getValue(evt,this.filterPath);
                if(value && this.filterValue !==value){
                    return;
                }
            }

            var eventValue = null;
            if(this.valuePath){

                if(!this._lastSettings){
                    this._lastSettings = {};
                }
                eventValue = this.getValue(evt,this.valuePath);
                if(eventValue!==null){
                    !this._lastSettings.override && (this._lastSettings.override = {});
                    this._lastSettings.override.args = [eventValue];
                }
            }

            //console.log('on event ',this._lastSettings);
            this.solve(this.scope,this._lastSettings);
        },
        _subscribe:function(evt,handler,obj){

            if(!evt){
                return;
            }
            var isNative = utils.contains(this._nativeEvents,evt);
            if(isNative==-1){

                if(this.__events && this.__events[evt]) {
                    var _handles = this.__events[evt];

                    _.each(_handles, function (e) {
                        this.unsubscribe(e.type, e.handler);
                        e.remove();
                    }, this);

                    _.each(_handles, function (e) {
                        this.__events[evt].remove(e);
                    }, this);
                }

                this.subscribe(evt, this.onEvent);
            }else{

                if(obj) {
                    var _event = evt.replace('on', ''),
                        thiz = this;

                    var handle = on(obj, _event, function (e) {
                        thiz.onEvent(e)
                    });
                    console.log('wire native event : ' + _event);
                    this._events.push(handle);
                }

            }

        },
        _registerEvent:function(evt){

            try {
                if (!evt || !evt.length) {
                    return;
                }
                console.log('register event : ' + evt + ' for ' + this.reference);
                var objects = this.resolveReference(this.deserialize(this.reference));
                var thiz = this;
                if (objects && objects.length) {
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];

                        //try widget
                        if (obj && obj.id) {
                            var _widget = registry.byId(obj.id);
                            if (_widget && _widget.on) {
                                var _event = this.event.replace('on', '');
                                console.log('found widget : ' + obj.id + ' will register event ' + _event);
                                var _handle = _widget.on(_event, lang.hitch(this, function (e) {
                                    console.log('event triggered : ' + thiz.event);
                                    thiz.onEvent(e);
                                }));
                                this._events.push(_handle);
                            } else {

                                this._subscribe(evt, this.onEvent, obj);
                            }
                        } else {

                            this._subscribe(evt, this.onEvent, obj);
                        }
                    }
                    console.log('objects found : ', objects);
                } else {
                    this._subscribe(evt, this.onEvent);
                }
            }catch(e){
                logError(e,'registering event failed');
            }
            this._didSubscribe=evt;
        },
        onLoad:function(){
            this._onLoaded=true;
            if(this.event && this.event.length && this.enabled){
                this._registerEvent(this.event);
            }
        },
        updateEventSelector:function(objects,cis){

            var options = [];

            if(!objects || !objects.length){
                options= this.scope.getEventsAsOptions(this.event);
            }else{

                options = [{label:"onclick", value:"onclick"},
                    {label:"ondblclick",value:"ondblclick"},
                    {label:"onmousedown",value:"onmousedown"},
                    {label:"onmouseup",value:"onmouseup"},
                    {label:"onmouseover",value:"onmouseover"},
                    {label:"onmousemove",value:"onmousemove"},
                    {label:"onmouseout",value:"onmouseout"},
                    {label:"onkeypress",value:"onkeypress"},
                    {label:"onkeydown",value:"onkeydown"},
                    {label:"onkeyup",  value:"onkeyup"},
                    {label:"onfocus",  value:"onfocus"},
                    {label:"onblur",  value:"onblur"},
                    {label:"onchange",  value:"onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if(obj.value===this.event){
                        obj.selected=true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if(ci['widget'] && ci['widget'].title==='Event'){
                    //console.log('event!');
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options',options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value',this.event);
                    this.publish(types.EVENTS.RESIZE,{});
                    break;
                }
            }
        },
        onReferenceChanged:function(newValue,cis){

            this._destroy();//unregister previous event(s)

            this.reference = newValue;
            var objects = this.resolveReference(this.deserialize(newValue));
            this.updateEventSelector(objects,cis);
            this._registerEvent(this.event);

        },
        onChangeField:function(field,newValue,cis){

            if(field=='event'){
                this._destroy();    //unregister previous event
                if(this._onLoaded){ // we've have been activated at load time, so re-register our event
                    this.event = newValue;
                    this._registerEvent(newValue);
                }
            }
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }

            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();//you never know
            this._registerEvent(this.event);
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){

            if(!this._events){this._events=[];}
            _.each(this._events, dojo.unsubscribe);
            this.unsubscribe(this.event,this.onEvent);
            this._lastResult=null;
            this._didSubscribe = false;
        }
    });
});;
/** @module xwire/_Base */
define('xwire/_Base',[
    'dcl/dcl',
    'xide/mixins/EventedMixin'
],function(dcl,EventedMixin){
    /**
     * @param {object} o An object.
     * @param {string} path The path from object, either dot-concatenated string or an array.
     * @returns The value of the object path.
     */
    function getObjectPath(o, path) {
        for (var comps = getPathComps(path), i = 0, l = comps.length; i < l; ++i) {
            var comp = comps[i];
            o = o == null ? o : o[comp];
        }
        return o;
    }

    /**
     * Utility to split an object path from a dot separated string into an array
     * @param path
     * @param create
     * @returns {Array}
     */
    function getPathComps(path, create) {
        return path === "" ? [] : typeof path.splice !== "function" ? path.split(".") : create ? path.slice() : path;
    }
    /**
     * Sets a value to an object path.
     * @param {object} o An object.
     * @param {string} path The path from object, either dot-concatenated string or an array.
     * @returns The value set. Undefined if value cannot be set.
     */
    function setObjectPath(o, path, value) {
        var comps = getPathComps(path, true),
            prop = comps.pop();
        o = comps.length > 0 ? getObjectPath(o, comps) : o;
        return Object(o) !== o || !path ? undefined : // Bail if the target is not an object
            typeof o.set === "function" ? o.set(prop, value) :
                (o[prop] = value);
    }

    /**
     * Abstract binding source
     * @class xwire/Source
     * @extends {module:xwire/_Base}
     * @extends {module:xide/mixins/EventedMixin}
     */
    var _base  = dcl([EventedMixin.dcl],{
        declaredClass:'xwire._Base',
        /***
         * Standard constructor for all subclassing bindings
         * @param {array} arguments
         */
        constructor: function(args){
            //simple mixin of constructor arguments
            for (var prop in args) {
                if (args.hasOwnProperty(prop)) {

                    this[prop] = args[prop];
                }
            }
        },
        getValue:function(object,path){
            return getObjectPath(object,path);
        },
        setValue:function(object,path,value){
            return setObjectPath(object,path,value);
        }

    });
    return _base;
});;
define('xblox/model/code/RunBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    'xide/types',
    'xide/utils'
], function(dcl,Block,types,utils){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod


    return dcl(Block,{
        declaredClass:"xblox.model.code.RunBlock",
        //method: (String)
        //  block action name
        name:'Run Block',

        file:'',
        //method: (String)
        //  block action name
        method:'',

        args:'',

        sharable:true,

        block:'',

        description:"Runs another Block",
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {

            var context = this.getContext();
            if (context && context[this.method]!=null)
            {
                var res = [];
                var _fn = context[this.method];
                try{
                    var _args = this._getArgs();
                    var _res = _fn.apply(context,_args||[]);
                    res = _res;
                    this.onSuccess(this,settings);
                    return res;
                }catch(e){
                    console.error('call method failed');
                    this.onFailed(this,settings);
                }
            }else{
                this.onFailed(this,settings);
                return [];
            }
            return [];
        },
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' ';
            if(this.method){
                result+= this.method.substr(0,20);
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){


            var fields = this.getDefaultFields();


            fields.push(utils.createCI('Block', types.ECIType.BLOCK_REFERENCE, this.block, {
                toolTip:'Enter  block, you can use also the block\'s share title',
                group: 'General',
                dst: 'block',
                value: this.block,
                title:'Block',
                scope:this.scope
            }));

            fields.push(utils.createCI('File', types.ECIType.FILE, this.file, {
                toolTip:'Leave empty to auto-select this file',
                group: 'General',
                dst: 'file',
                value: this.file,
                intermediateChanges: false,
                acceptFolders: false,
                acceptFiles: true,
                encodeFilePath: false,
                buildFullPath: true,
                filePickerOptions: {
                    dialogTitle: 'Select Block File',
                    filePickerMixin: {
                        beanContextName: this.id,
                        persistent: false,
                        globalPanelMixin: {
                            allowLayoutCookies: false
                        }
                    },
                    configMixin: {
                        beanContextName: this.id,
                        LAYOUT_PRESET: types.LAYOUT_PRESET.SINGLE,
                        PANEL_OPTIONS:{
                            ALLOW_MAIN_MENU:false,
                            ALLOW_NEW_TABS:true,
                            ALLOW_MULTI_TAB:false,
                            ALLOW_INFO_VIEW:true,
                            ALLOW_LOG_VIEW:false,
                            ALLOW_CONTEXT_MENU:true,
                            ALLOW_LAYOUT_SELECTOR:true,
                            ALLOW_SOURCE_SELECTOR:true,
                            ALLOW_COLUMN_RESIZE:true,
                            ALLOW_COLUMN_REORDER:true,
                            ALLOW_COLUMN_HIDE:true,
                            ALLOW_ACTION_TOOLBAR:true,
                            ALLOW_BREADCRUMBS:false
                        }
                    },
                    defaultStoreOptions: {
                        "fields": 1663,
                        "includeList": "xblox",
                        "excludeList": "*"
                    },
                    startPath: this.file
                }
            }));

            return fields;

            /*
            fields.push(utils.createCI('value',27,this.args,{
                    group:'General',
                    title:'Arguments',
                    dst:'args'
                }));

            return fields;
            */
        },
        getBlockIcon:function(){
            return '<span class="el-icon-share-alt"></span>';
        }


    });
});;
define('xblox/model/server/Shell',[
    "dcl/dcl",
    "xblox/model/server/ServerBlock",
    'xide/utils',
    'xcf/model/Command'
], function (dcl, ServerBlock, utils, Command) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl([Command, ServerBlock], {
        declaredClass: "xblox.model.server.Shell",
        description: 'Runs a JSON-RPC-2.0 method on the server',
        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Shell',

        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: '',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',

        sharable: true,
        /**
         * Callback when user edited the 'method' field. This will pre-populate the arguments field when empty
         * with the known SMD parameters : if possible.
         * @param newMethod
         * @param cis
         */
        onMethodChanged: function (newMethod, cis) {
            this.method = newMethod;
            //we auto populate the arguments field
            if (!utils.isValidString(this.args)) {

                var newServerParams = this.getServerParams();
                if (newServerParams) {
                    this._updateArgs(newServerParams, cis);
                }

            }
        },
        _getArgs: function () {


            /*
             var test = [
             {
             "name": "shellType",
             "default": "sh", "optional": false, "value": "notset"
             },
             {
             "name": "cmd",
             "optional": false,
             "value": "[CurrentDirectory]"
             },
             {
             "name": "cwd",
             "default": null,
             "optional": true,
             "value": "[CurrentDirectory]"
             }
             ];*/


            var _args = utils.getJson(this.args || '[]');
            var result = [];
            if (_args) {
                var isSMD = false;
                //now check this is still in 'SMD' format
                if (_args && _args[0] && _args[0]['optional'] != null) {
                    isSMD = true;
                }
                //if SMD true, evaluate the value field
                if (isSMD) {
                    for (var i = 0; i < _args.length; i++) {
                        var _arg = _args[i];
                        var _variableValue = _arg.value;
                        var isBase64 = _arg.name.indexOf('Base64') != -1;
                        if (isBase64) {
                            _variableValue = this.getService().base64_encode(_variableValue);
                        }

                        if (_arg.value !== 'notset') {
                            if (_arg.value.indexOf('[') != -1 && _arg.value.indexOf(']') != -1) {
                                _variableValue = this.scope.expressionModel.replaceVariables(this.scope, _arg.value, false, false);
                                if (_arg.name.indexOf('Base64') != -1) {
                                    _variableValue = this.getService().base64_encode(_variableValue);
                                }
                                result.push(_variableValue);
                            } else {
                                result.push(_variableValue || _arg['default']);
                            }

                        } else {
                            result.push(_arg['default'] || _variableValue);
                        }
                    }
                } else {

                }
            } else {
                return [this.args];
            }

            return result;

        },
        /**
         * Update this.args (string) with a SMD parameter set
         * @param params
         * @param cis
         * @private
         */
        _updateArgs: function (params, cis) {

            var argumentWidget = this.utils.getCIWidgetByName(cis, 'args');
            if (argumentWidget) {
                var _string = JSON.stringify(params);
                argumentWidget.editBox.set('value', _string);
                this.args = _string;

            }
        },
        /**
         * Find SMD for the current method
         * @returns {*}
         */
        getServerParams: function () {
            var service = this.getService();
            var params = service.getParameterMap(this.getServiceClass(), this.getServiceMethod());
            if (params) {
                for (var i = 0; i < params.length; i++) {
                    var param = params[i];
                    param.value = 'notset';
                }
            }
            return params;
        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, isInterface, send, run, error) {
            this._return = [];
            this._lastResult = null;
            var thiz = this;
            var ret = [];
            settings = this._lastSettings = settings || this._lastSettings;
            var instance = this.getInstance();
            var code = scope.expressionModel.replaceVariables(scope, this.method, false, false);
            instance.runShell(code, utils.mixin({}, {}), this.id, this.id, this);
            return;

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;
            fields.push(utils.createCI('value', 25, this.method, {
                group: 'General',
                title: 'Cmd',
                dst: 'method',
                delegate: {
                    runExpression: function (val, run, error) {
                        var old = thiz.method;
                        thiz.method = val;
                        var _res = thiz.solve(thiz.scope, null, run, error);
                    }
                }
            }));
            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        onChangeField: function (field, newValue, cis) {
            if (field === 'method') {
                this.onMethodChanged(newValue, cis);
            }
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {

            return this.getService() != null;
        },
        getService: function () {
            var service = this.scope.getService();
            if (!service) {
                console.error('have no service object');
            }
            return service;
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
                this.getService()[this.getServiceClass()] != null &&
                this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
                this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }
    });
});;
define('xblox/model/server/ServerBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xide/utils"
], function (dcl,Block,utils) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl(Block, {
        declaredClass:"xblox.model.server.ServerBlock",
        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Server Block',
        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: 'XShell::run',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',
        /**
         * Debugging
         * @member {function}
         */
        sharable:true,

        onReloaded: function () {
        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, run, error) {

            this._currentIndex = 0;
            this._return = [];

            var _script = '' + this.method;
            var thiz = this;

            if (_script && _script.length) {

                var _function = new Function("{" + _script + "}");
                var _args = this.getArgs();
                try {
                    var _parsed = _function.apply(this, _args || {});
                    this._lastResult = _parsed;

                    if (run) {
                        run('Expression ' + _script + ' evaluates to ' + _parsed);
                    }
                    if (_parsed !== 'false' && _parsed !== false) {
                        this.onSuccess(this, settings);
                    } else {
                        this.onFailed(this, settings);
                        return [];
                    }
                } catch (e) {
                    if (error) {
                        error('invalid expression : \n' + _script + ': ' + e);
                    }
                    this.onFailed(this, settings);
                    return [];
                }
            } else {
                console.error('have no script');
            }
            var ret = [], items = this[this._getContainer()];
            if (items.length) {
                this.runFrom(items, 0, settings);
            } else {
                this.onSuccess(this, settings);
            }

            return ret;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        getServerDefaultFields:function(target){

            var fields = target || [];

            fields.push(utils.createCI('args', 27, this.args, {
                group: 'General',
                title: 'Arguments',
                dst: 'args'
            }));

            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {
            return this.getService() != null;
        },
        getService: function () {
            return this.scope.getService();
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null &&
            this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }
    });
});;
define('xblox/model/server/RunServerMethod',[
    "dcl/dcl",
    "xblox/model/server/ServerBlock",
    'xide/utils'
], function (dcl, ServerBlock, utils) {
    /**
     * Runs a JSON-RPC-2.0 method on the server. This assumes that this block's scope has
     * a 'service object'
     */
    return dcl(ServerBlock, {
        declaredClass:"xblox.model.server.RunServerMethod",
        description: 'Runs a JSON-RPC-2.0 method on the server',

        /**
         * The name of the block, used in the UI
         * @member {string}
         */
        name: 'Run Server Method',

        /**
         * The full string of the service class method, ie: MyPHPServerClass::method
         * @member {string}
         */
        method: 'XShell::run',
        /**
         * Arguments for the server call
         * @member {string}
         */
        args: '',
        /**
         * Override in super class, this block runs async by default
         * @member {boolean}
         */
        deferred: true,
        /**
         * The default for the server RPC class
         * @member {string}
         */
        defaultServiceClass: 'XShell',
        /**
         * The default for the server RPC class method
         * @member {string}
         */
        defaultServiceMethod: 'run',

        sharable:true,
        /**
         * Callback when user edited the 'method' field. This will pre-populate the arguments field when empty
         * with the known SMD parameters : if possible.
         * @param newMethod
         * @param cis
         */
        onMethodChanged: function (newMethod, cis) {
            
            this.method = newMethod;

            //we auto populate the arguments field
            if (!utils.isValidString(this.args)) {

                var newServerParams = this.getServerParams();
                if (newServerParams) {
                    this._updateArgs(newServerParams, cis);
                }

            }
        },
        _getArgs: function () {


            /*
            var test = [
                {
                    "name": "shellType",
                    "default": "sh", "optional": false, "value": "notset"
                },
                {
                    "name": "cmd",
                    "optional": false,
                    "value": "[CurrentDirectory]"
                },
                {
                    "name": "cwd",
                    "default": null,
                    "optional": true,
                    "value": "[CurrentDirectory]"
                }
            ];*/


            var _args = utils.getJson(this.args || '[]');
            var result = [];
            if (_args) {
                var isSMD = false;
                //now check this is still in 'SMD' format
                if (_args && _args[0] && _args[0]['optional'] != null) {
                    isSMD = true;
                }
                //if SMD true, evaluate the value field
                if (isSMD) {
                    for (var i = 0; i < _args.length; i++) {
                        var _arg = _args[i];
                        var _variableValue = _arg.value;
                        var isBase64 = _arg.name.indexOf('Base64') != -1;
                        if(isBase64){
                            _variableValue = this.getService().base64_encode(_variableValue);
                        }

                        if (_arg.value !== 'notset') {
                            if (_arg.value.indexOf('[') != -1 && _arg.value.indexOf(']') != -1) {
                                _variableValue = this.scope.expressionModel.replaceVariables(this.scope, _arg.value, false, false);
                                if (_arg.name.indexOf('Base64') != -1) {
                                    _variableValue = this.getService().base64_encode(_variableValue);
                                }
                                result.push(_variableValue);
                            } else {
                                result.push(_variableValue || _arg['default']);
                            }

                        } else {
                            result.push(_arg['default'] || _variableValue);
                        }
                    }
                } else {

                }
            } else {
                return [this.args];
            }

            return result;

        },
        /**
         * Update this.args (string) with a SMD parameter set
         * @param params
         * @param cis
         * @private
         */
        _updateArgs: function (params, cis) {

            var argumentWidget = this.utils.getCIWidgetByName(cis, 'args');
            if (argumentWidget) {
                var _string = JSON.stringify(params);
                argumentWidget.editBox.set('value', _string);
                this.args = _string;

            }
        },
        /**
         * Find SMD for the current method
         * @returns {*}
         */
        getServerParams: function () {
            var service = this.getService();
            var params = service.getParameterMap(this.getServiceClass(), this.getServiceMethod());
            if (params) {
                for (var i = 0; i < params.length; i++) {
                    var param = params[i];
                    param.value = 'notset';
                }
            }
            return params;
        },
        onReloaded: function (evt) {

            console.log('sdfsd');
            this._solve()
        },
        _solve:function(scope,settings,run,error){

            console.log('solve223');

        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve: function (scope, settings, run, error) {



            this._return = [];
            this._lastResult=null;
            var thiz = this;
            var ret = [];

            //this._solve();



            //console.dir(this.scope);


            if(!this.isInValidState()){
                this.onFailed(this, settings);
                return ret;
            }

            var _args = this._getArgs();//returns SMD ready array of values
            var _cbSuccess = function (response) {
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onSuccess(thiz, settings);
            };
            var _cbError = function (response) {
                //console.error('   server method ' + thiz.method + ' with params ' + JSON.stringify(_args)  + 'failed ' + response);
                thiz._lastResult = thiz.utils.getJson(response) || [response];
                thiz.resolved(thiz._lastResult);
                thiz.onFailed(thiz, settings);
            };

            this.onRun(this, settings);

            var service = this.getService();
            var serviceObject = this.scope.serviceObject;
            //service.callMethodEx(this.getServiceClass(), this.getServiceMethod(), _args, _cbSuccess,_cbError);

            console.error('run deferred');

            var dfd = serviceObject.runDeferred(this.getServiceClass(),this.getServiceMethod(),_args);
            if(dfd){
                dfd.then(function(data){
                    console.error('returned ',data);
                });
            }

            return dfd;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {

            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if (this.method) {
                result += this.method.substr(0, 50);
            }
            return result;
        },

        //  standard call from interface
        canAdd: function () {
            return [];
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;

            fields.push(utils.createCI('value', 25, this.method, {
                group: 'General',
                title: 'Method',
                dst: 'method',
                description: 'This should be in the format : MyServerClass::myMethod',
                delegate: {
                    runExpression: function (val, run, error) {
                        var old = thiz.method;
                        thiz.method = val;
                        var _res = thiz.solve(thiz.scope, null, run, error);
                    }
                }
            }));
            fields = fields.concat(this.getServerDefaultFields());
            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-plug"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Store
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren: function (parent) {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren: function (parent) {
            return this.items;
        },

        onChangeField: function (field, newValue, cis) {
            if (field === 'method') {
                this.onMethodChanged(newValue, cis);
            }
        },

        /**
         * Check our scope has a service object
         * @returns {boolean}
         */
        isInValidState: function () {

            return this.getService() != null;
        },
        getService: function () {

            var service = this.scope.getService();

            if(!service){
                console.error('have no service object');
            }
            return service;
        },
        getServiceClass: function () {
            return this.method.split('::')[0] || this.defaultServiceClass;
        },
        getServiceMethod: function () {
            return this.method.split('::')[1] || this.defaultServiceMethod;
        },
        hasMethod: function (method) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null &&
            this.getService()[this.getServiceClass()][this.getServiceMethod()] != null
        },
        hasServerClass: function (_class) {
            return this.isInValidState() &&
            this.getService()[this.getServiceClass()] != null;
        },
        getServerFunction: function () {
            if (this.isInValidState() && this.getServiceClass() && this.getServiceMethod()) {
                return this.getService()[this.getServiceClass()][this.getServiceMethod()];
            }
            return null;
        }


    });
});;
define('xblox/model/logging/Log',[
    'dcl/dcl',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin'
], function (dcl, Deferred, Block, utils, types, EventedMixin) {
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl([Block, EventedMixin.dcl], {
        declaredClass: "xblox.model.logging.Log",
        name: 'Log Message',
        level: 'info',
        message: 'return "Message: " + arguments[0];',
        _type: 'XBlox',
        host: 'this host',
        sharable: true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText: function () {
            var _cls = 'text-primary';
            switch (this.level) {
                case 'info': {
                    _cls = 'text-info';
                    break;
                }
                case 'warn': {
                    _cls = 'text-warning';
                    break;
                }
                case 'error': {
                    _cls = 'text-danger';
                    break;
                }
            }
            var result = this.getBlockIcon() + " " + this.name + " : " + "<span class='" + _cls + " small'> " + ' :: ';
            if (this.message) {
                result += this.message;
            }
            return result + "</span>";
        },
        /***
         * Returns the block run result
         * @param expression
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {string}
         */
        _solveExpression: function (expression, scope, settings, run, error) {
            var _script = '' + expression;
            if (_script && _script.length) {
                _script = utils.convertAllEscapes(_script, "none");
                var _args = this.getArgs();
                try {
                    var _parsed = scope.parseExpression(_script, null, null, null, null, this, _args);
                    if (run) {
                        run('Expression ' + _script + ' evaluates to ' + _parsed);
                    }
                    return _parsed;
                } catch (e) {
                    if (error) {
                        error('invalid expression : \n' + _script + ': ' + e);
                    }
                    this.onFailed(this, settings);
                    return _script;
                }
            }
            return _script;
        },
        /**
         *
         * @param scope
         * @param settings
         * @param run
         * @param error
         */
        solve: function (scope, settings, run, error) {
            var dfd = new Deferred();
            var device = scope.device;
            var _message = this._solveExpression(this.message, scope, settings, run, error);
            var message = {
                message: _message,
                level: this.level,
                type: this._type,
                details: this.getArgs(),
                time: new Date().getTime(),
                data: {
                    device: device ? device.info : null
                },
                write: true
            };
            this.onSuccess(this, settings);
            dfd.resolve(_message);
            try {
                this.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, message);
            } catch (e) {
                this.onFailed(this, settings);
            }

            return dfd;

        },
        //  standard call from interface
        canAdd: function () {
            return null;
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;
            var options = [
                {
                    value: 'info',
                    label: 'Info'
                },
                {
                    value: 'warn',
                    label: 'Warning'
                },
                {
                    value: 'error',
                    label: 'Error'
                },
                {
                    value: 'debug',
                    label: 'Debug'
                },
                {
                    value: 'help',
                    label: 'Help'
                },
                {
                    value: 'verbose',
                    label: 'verbose'
                },
                {
                    value: 'silly',
                    label: 'Silly'
                }
            ];

            fields.push(utils.createCI('Level', 3, this.level, {
                group: 'General',
                options: options,
                dst: 'level'
            }));

            fields.push(
                utils.createCI('message', 25, this.message, {
                    group: 'General',
                    title: 'Message',
                    dst: 'message',
                    delegate: {
                        runExpression: function (val, run, error) {
                            thiz._solveExpression(val, thiz.scope, null, run, error);
                        }
                    }
                }));

            fields.push(
                utils.createCI('message', 13, this._type, {
                    group: 'General',
                    title: 'Type',
                    dst: '_type'
                }));

            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-bug"></span>';
        }
    });
});;
/** @module xblox/model/variables/VariableSwitch **/
define('xblox/model/variables/VariableSwitch',[
    'dcl/dcl',
    "xblox/model/logic/SwitchBlock",
    'xide/types',
    "xblox/model/logic/CaseBlock",
    "xblox/model/logic/DefaultBlock",
    "dojo/Deferred"
], function(dcl,SwitchBlock,types,CaseBlock,DefaultBlock,Deferred){
    /**
     *
     * The switch command model. These kind of commands takes a existing variable and applies some comparison.
     * Depending on the comparison results, the code into each case block is executed or not.
     * @class module:xblox/model/variables/VariableSwitch
     * @extends module:xblox/model/Block
     */
    return dcl(SwitchBlock,{
        declaredClass:"xblox.model.variables.VariableSwitch",
        name:'Switch on Variable',
        icon:'',
        variable:"PowerState",
        toText:function(){
            var _variable = this.scope.getVariableById(this.variable);
            var _text = _variable ? _variable.name : '';
            return this.getBlockIcon('H')  + this.name + ' ' + _text;
        },
        //  standard call for editing
        getFields:function(){
            //options:this.scope.getVariablesAsOptions(),
            var fields = this.getDefaultFields(false,false);
            fields = fields.concat([
                this.utils.createCI('Variable',3,this.variable,
                    {
                        group:'General',
                        widget:{
                            store:this.scope.blockStore,
                            labelField:'name',
                            valueField:'id',
                            query:[
                                {
                                    group:'basicVariables'
                                },
                                {
                                    group:'processVariables'
                                }
                            ]

                        },
                        dst:'variable'
                    }
                )
            ]);
            return fields;
        }
    });
});;
define('xblox/model/logic/DefaultBlock',[
    'dcl/dcl',
    'xblox/model/Block'
], function (dcl, Block) {
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block, {
        declaredClass: "xblox.model.logic.DefaultBlock",
        name: 'Default',
        icon: '',
        hasInlineEdits: false,
        toText: function () {
            return '&nbsp;<span class="fa-eject text-info"></span>&nbsp;&nbsp;<span>' + this.name + '</span>';
        },
        solve: function (scope, settings) {
            this.onSuccess(this, settings);
            return this._solve(scope, settings);
        }
    });
});;
/** @module xblox/model/logic/SwitchBlock **/
define('xblox/model/logic/SwitchBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xblox/model/logic/CaseBlock",
    "xblox/model/logic/DefaultBlock",
    "dojo/Deferred",
    "xide/lodash"
], function (dcl, Block, CaseBlock, DefaultBlock, Deferred, _) {
    /**
     *
     * @class module:xblox/model/logic/SwitchBlock
     * @extends module:xblox/model/Block
     */
    return dcl(Block, {
        declaredClass: "xblox.model.logic.SwitchBlock",
        items: null,
        name: 'Switch',
        icon: null,
        toText: function () {
            return this.getBlockIcon('H') + this.name + ' ';
        },
        /**
         *
         * @param what {module:xblox/model/Block}
         * @returns {*}
         */
        canAdd: function (what) {
            if(what && what.isInstanceOf){
                return what.isInstanceOf(CaseBlock) || what.isInstanceOf(DefaultBlock);
            }
            return [];
        },
        getFields: function () {
            return this.getDefaultFields(false, false);
        },
        /***
         * Solve the switchblock
         * @param scope
         * @param settings
         * @returns {string} execution result
         */
        solve: function (scope, settings) {
            this._stopped = false;
            var anyCase = false;    // check if any case is reached
            var ret = [];
            this.onSuccess(this, settings);
            // iterate all case blocks
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];

                if (block.declaredClass === 'xblox.model.logic.CaseBlock'/* instanceof CaseBlock*/) {
                    var caseret;
                    // solve each case block. If the comparison result is false, the block returns "false"
                    caseret = block.solve(scope, this, settings);
                    if (caseret != false) {
                        // If the case block return is not false, don't run "else" block
                        anyCase = true;
                        this.addToEnd(ret, caseret);
                        break;
                    }
                }
                if (this._stopped) {
                    break;
                }
            }
            // iterate all "else" blocks if none of the cases occurs
            if (!anyCase) {
                for (var n = 0; n < this.items.length; n++) {
                    var block = this.items[n];
                    if (!(block.declaredClass == 'xblox.model.logic.CaseBlock')) {
                        this.addToEnd(ret, block.solve(scope, settings));
                    }
                }
            }
            return ret;
        },
        /**
         * Store function override
         * @returns {Array}
         */
        getChildren: function () {
            return this.items;
        },
        stop: function () {
            this._stopped = true;
        },
        runAction: function (action) {
            var command = action.command;
            if (command === 'New/Case' || action.command === 'New/Default') {
                var store = this.scope.blockStore;
                var dfd = new Deferred();
                var newBlock = null;

                switch (command) {
                    case 'New/Case': {
                        newBlock = this.add(CaseBlock, {
                            comparator: "==",
                            expression: "on",
                            group: null
                        });
                        break;
                    }
                    case 'New/Default': {
                        newBlock = this.add(DefaultBlock, {
                            group: null
                        });
                        break;
                    }
                }
                dfd.resolve({
                    select: [newBlock],
                    focus: true,
                    append: false
                });
                newBlock.refresh();
                store._emit('added', {
                    target: newBlock
                });
            }
        },
        getActions: function (permissions, owner) {
            var result = [this.createAction({
                label: 'New Case',
                command: 'New/Case',
                icon: this.getBlockIcon('I'),
                tab: 'Home',
                group: 'File',
                mixin: {
                    addPermission: true,
                    custom: true,
                    quick: false
                }
            })];
            if (!_.find(this.items, {declaredClass: 'xblox.model.logic.DefaultBlock'})) {
                result.push(this.createAction({
                    label: 'Default',
                    command: 'New/Default',
                    icon: 'fa-eject',
                    tab: 'Home',
                    group: 'File',
                    mixin: {
                        addPermission: true,
                        custom: true,
                        quick: false
                    }
                }));
            }
            return result;
        }
    });
});;
define('xblox/model/logic/ElseIfBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/Contains"
], function (dcl, Block, Contains) {
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    // summary:
    //		The ElseIf Block model. Each ElseIf block contains a condition and a consequent to be run if the condition
    //          is true
    //
    //      This block should have an "IfBlock" parent

    // module:
    //		xblox.model.logic.ElseIfBlock
    return dcl([Block, Contains], {
        declaredClass: "xblox.model.logic.ElseIfBlock",
        //  condition: (String) expression to be evaluated
        condition: "",
        //  consequent: (Block) block to be run if the condition is true
        consequent: null,
        name: 'else if',
        icon: '',
        solve: function (scope, settings) {
            if (this._checkCondition(scope)) {
                return this._solve(scope, settings)
            }
            return false;
        },
        toText: function () {
            return "<span class='text-primary'>" + this.getBlockIcon('E') + this.name + " </span>" + "<span class='text-warning small'>" + (this.condition || "") + "<span>";
        },
        // checks the ElseIf condition
        _checkCondition: function (scope) {
            if (this.condition !== null) {
                return scope.parseExpression(this.condition);
            }
            return false;
        },
        getFields: function () {
            var thiz = this;
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(
                this.utils.createCI('condition', this.types.ECIType.EXPRESSION_EDITOR, this.condition, {
                    group: 'General',
                    title: 'Expression',
                    dst: 'condition',
                    delegate: {
                        runExpression: function (val, run, error) {
                            return thiz.scope.expressionModel.parse(thiz.scope, val, false, run, error);
                        }
                    }
                })
            );
            return fields;
        }
    });
});;
/** @module xblox/model/logic/IfBlock **/
define('xblox/model/logic/IfBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/Statement",
    "xblox/model/logic/ElseIfBlock",
    "dojo/Deferred",
    "xide/utils"
], function (dcl, Block, Statement, ElseIfBlock, Deferred, utils) {

    /**
     * Base block class.
     *
     * @class module:xblox/model/logic/IfBlock
     * @augments module:xblox/model/ModelBase
     * @extends module:xblox/model/Block
     */
    return dcl(Block, {
        declaredClass: "xblox.model.logic.IfBlock",
        // condition: (String) expression to be evaluated
        condition: 'Invalid Expression',

        // consequent: (Block) block to be run if the condition is true
        consequent: null,

        // elseIfBlocks: (optional) Array[ElseIfBlock] -> blocks to be run if the condition is false. If any of these blocks condition is
        //          true, the elseIf/else sequence stops
        elseIfBlocks: null,

        // alternate: (optional) (Block) -> block to be run if the condition is false and none of the "elseIf" blocks is true
        alternate: null,

        //  standard call from interface
        canAdd: function () {
            return [];
        },

        //  autoCreateElse : does auto creates the else part
        autoCreateElse: true,

        //  name : this name is displayed in the block row editor
        name: 'if',

        icon: '',
        //  add
        //
        // @param proto {mixed : Prototype|Object} : the new block's call prototype or simply a ready to use block
        // @param ctrArgs {Array} : constructor arguments for the new block
        // @param where {String} : consequent or alternate or elseif
        // @returns {Block}
        //
        add: function (proto, ctrArgs, where) {
            if (where == null) {
                where = 'consequent';
            }
            return this._add(proto, ctrArgs, where, false);
        },
        //  overrides default store integration
        __addToStore: function (store) {
            //add our self to the store
            store.put(this);
        },
        /**
         * Store function override
         * @returns {boolean}
         */
        mayHaveChildren: function () {
            return (this.items !== null && this.items.length) ||
                (this.elseIfBlocks !== null && this.elseIfBlocks.length) ||
                (this.consequent != null && this.consequent.length) ||
                (this.alternate != null && this.alternate.length);

        },
        /**
         * Store function override
         * @returns {Array}
         */
        getChildren: function () {
            var result = [];
            if (this.consequent) {
                result = result.concat(this.consequent);
            }
            if (this.elseIfBlocks) {
                result = result.concat(this.elseIfBlocks);
            }
            if (this.alternate) {
                result = result.concat(this.alternate);
            }
            return result;
        },
        /**
         * Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText: function () {
            return "<span class='text-primary'>" + this.getBlockIcon('E') + this.name + " </span>" + "<span class='text-warning small'>" + this.condition + "<span>";
        },
        _checkCondition: function (scope) {
            return scope.parseExpression(this.condition, null, null);
        },
        solve: function (scope, settings) {
            // 1. Check the condition
            var solvedCondition = this._checkCondition(scope);
            var elseIfBlocks = this.getElseIfBlocks();
            var others = this.childrenByNotClass(ElseIfBlock);
            var result = null;

            others = others.filter(function (block) {
                return !block.isInstanceOf(Statement);
            });

            // 2. TRUE? => run consequent
            if (solvedCondition == true || solvedCondition > 0) {
                this.onSuccess(this, settings);
                if (others && others.length) {
                    for (var i = 0; i < others.length; i++) {
                        result = others[i].solve(scope, settings);
                    }
                }
                return result;
            } else {
                // 3. FALSE?
                var anyElseIf = false;
                this.onFailed(this, settings);
                if (elseIfBlocks) {
                    // 4. ---- check all elseIf blocks. If any of the elseIf conditions is true, run the elseIf consequent and
                    //           stop the process
                    for (var n = 0; ( n < elseIfBlocks.length ) && (!anyElseIf); n++) {
                        var _elseIfBlock = elseIfBlocks[n];
                        if (_elseIfBlock._checkCondition(scope)) {
                            _elseIfBlock.onSuccess(_elseIfBlock, settings);
                            anyElseIf = true;
                            return _elseIfBlock.solve(scope, settings);
                        } else {
                            _elseIfBlock.onFailed(_elseIfBlock, settings);
                        }
                    }
                }

                var alternate = this.childrenByClass(Statement);
                // 5. ---- If none of the ElseIf blocks has been run, run the alternate
                if (alternate.length > 0 && (!anyElseIf)) {
                    result = null;
                    for (var i = 0; i < alternate.length; i++) {
                        result = alternate[i].solve(scope, settings);
                    }
                    return result;
                }
            }
            return [];
        },
        /**
         * Default override empty. We have 3 arrays to clean : items, alternate and consequent
         */
        empty: function () {
            this._empty(this.alternate);
            this._empty(this.consequent);
            this._empty(this.elseIfBlocks);
        },
        /**
         * Deletes us or children block in alternate or consequent
         * @param what
         */
        removeBlock: function (what) {
            if (what) {
                if (what && what.empty) {
                    what.empty();
                }
                delete what.items;
                what.parent = null;
                this.alternate.remove(what);
                this.consequent.remove(what);
                this.elseIfBlocks.remove(what);
            }
        },
        // evaluate the if condition
        _getContainer: function (item) {
            if (this.consequent.indexOf(item) != -1) {
                return 'consequent';
            } else if (this.alternate.indexOf(item) != -1) {
                return 'alternate';
            } else if (this.elseIfBlocks.indexOf(item) != -1) {
                return 'elseIfBlocks';
            }
            return '_';
        },
        /**
         * Default override, prepare all variables
         */
        init: function () {
            this.alternate = this.alternate || [];
            this.consequent = this.consequent || [];
            this.elseIfBlocks = this.elseIfBlocks || [];

            for (var i = 0; i < this.alternate.length; i++) {
                this.alternate[i].parentId = this.id;
                this.alternate[i].parent = this;
            }
            for (var i = 0; i < this.elseIfBlocks.length; i++) {
                this.elseIfBlocks[i].parentId = this.id;
                this.elseIfBlocks[i].parent = this;
            }
            for (var i = 0; i < this.consequent.length; i++) {
                this.consequent[i].parentId = this.id;
                this.consequent[i].parent = this;
            }
            //var store = this.scope.blockStore;
        },
        getFields: function () {
            var thiz = this;
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(
                this.utils.createCI('condition', this.types.ECIType.EXPRESSION_EDITOR, this.condition, {
                    group: 'General',
                    title: 'Expression',
                    dst: 'condition',
                    delegate: {
                        runExpression: function (val, run, error) {
                            return thiz.scope.expressionModel.parse(thiz.scope, val, false, run, error);
                        }
                    }
                })
            );
            return fields;
        },
        postCreate: function () {
            if (this._postCreated) {
                return;
            }
            this._postCreated = true;
        },
        toCode: function (lang, params) {
        },
        getElseIfBlocks: function () {
            return this.childrenByClass(ElseIfBlock);
        },
        runAction: function (action) {
            var store = this.scope.blockStore;
            var command = action.command;
            if (command === 'New/Else' || command === 'New/Else If') {
                var newBlockClass = command === 'New/Else If' ? ElseIfBlock : Statement;
                var args = utils.mixin({
                        name: 'else',
                        items: [],
                        dstField: 'alternate',
                        parentId: this.id,
                        parent: this,
                        scope: this.scope,
                        canAdd: function () {
                            return [];
                        },
                        canEdit: function () {
                            return false;
                        }
                    }, newBlockClass == ElseIfBlock ? {name: 'else if', dstField: 'elseIfBlocks'} : {
                        name: 'else', dstField: 'alternate'
                    }
                );

                var newBlock = this.add(newBlockClass, args, newBlockClass == Statement ? 'alternate' : 'elseIfBlocks');
                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false,
                    expand: true,
                    delay: 10
                };
                var dfd = new Deferred();
                store._emit('added', {
                    target: newBlock
                });
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }
        },
        getActions: function () {
            var result = [];
            if (this.alternate.length == 0) {
                result.push(this.createAction({
                    label: 'Else',
                    command: 'New/Else',
                    icon: this.getBlockIcon('I'),
                    tab: 'Home',
                    group: 'File',
                    mixin: {
                        addPermission: true,
                        custom: true
                    }
                }));
            }
            result.push(this.createAction({
                label: 'Else If',
                command: 'New/Else If',
                icon: this.getBlockIcon('I'),
                tab: 'Home',
                group: 'File',
                mixin: {
                    addPermission: true,
                    custom: true
                }
            }));
            return result;
        }
    });
});;
define('xblox/model/Statement',[
    "dcl/dcl",
    "xblox/model/Block"
], function(dcl,Block){

    // summary:
    //		The statement block is only a wrapper for items like in 'else'

    // module:
    //		xblox.model.Statement
    return dcl(Block,{
        declaredClass:"xblox.model.Statement",
        /**
         * Return block name
         * @returns {name|*}
         */
        toText:function(){
            return this.name;
        },
        /**
         *
         * @returns {items|*}
         */
        getChildren:function(){
            return this.items;
        }
    });
});;
/** @module xblox/model/variables/VariableAssignmentBlock **/
define('xblox/model/variables/VariableAssignmentBlock',[
    'dcl/dcl',
    "xblox/model/Block",
    "xide/utils",
    "xide/types",
    'dstore/legacy/DstoreAdapter',
    "xide/factory",
    'xdojo/has'
], function(dcl,Block,utils,types,DstoreAdapter,factory,has){

    var isServer = has('host-node');
    var BLOCK_INSERT_ROOT_COMMAND = 'Step/Insert';
    


    /**
     *
     * @class module:xblox/model/variables/VariableAssignmentBlock
     * @extends xblox/model/Block
     */
    var Module = dcl(Block,{
        declaredClass: "xblox.model.variables.VariableAssignmentBlock",

        //variable: (String)
        //  variable title
        variable:null,

        //value: (String)
        // Expression to be asigned
        value:null,
        name:'Set Variable',
        icon:'',
        hasInlineEdits:true,
        flags:0x00000004,
        toText:function(){
            var _variable = this.scope.getVariableById(this.variable);
            var _text = _variable ? _variable.name : '';
            if(this.variable && this.variable.indexOf('://')!==-1) {
                _text = '<span class="text-info">' +this.scope.toFriendlyName(this, this.variable)+'</span>';
            }
            return this.getBlockIcon('C') + this.name + ' ' + _text  + "<span class='text-muted small'> to <kbd class='text-warning'>" + this.makeEditable("value",'bottom','text','Enter the string to send','inline') + "</kbd></span>";
        },
        _getPreviousResult: function () {
            var parent = null;
            var prev = this.getPreviousBlock();
            if(!prev || !prev._lastResult || !prev.enabled){
                parent = this.getParent();
            }else{
                parent = prev;
            }

            if (parent && parent._lastResult != null) {
                if (this.isArray(parent._lastResult)) {
                    return parent._lastResult;
                } else {
                    return parent._lastResult;
                }
            }
            return null;
        },
        /***
         * Makes the assignation
         * @param scope
         */

        solve:function(scope,settings) {
            var value = this.value;
            var changed = false;
            if(!value){
                var _value = this.getArgs();
                if(_value.length>0){
                    value = _value[0];
                }
            }
            if (this.variable && value!==null){

                this.onRun(this,settings);
                //var _variable = scope.getVariable(this.variable).value = scope.parseExpression(this.value);
                var _variable = this.variable.indexOf('://')!==-1 ? this.scope.resolveBlock(this.variable) : scope.getVariableById(this.variable);
                //console.log('assign variable',settings);
                var _value = this._getArg(value);

                var _args = this.getArgs(settings) || [];
                //console.log('run with args ' , _args);

                if(!_variable){
                    //console.error('     no such variable : ' + this.variable);
                    return [];
                }
                var _parsed = null;
                if(this.isScript(_value)){
                    var override = this.override || {};
                    _parsed = scope.parseExpression(value,null,null,null,null,null,_args || override.args);
                    //_parsed = scope.parseExpression(_value);
                    _parsed = this.replaceAll("'",'',_parsed);
                    //_variable.value = scope.parseExpression(_value);
                    //_variable.value = this.replaceAll("'",'',_variable.value);

                    if(_variable.value!==_parsed){
                        changed = true;
                    }

                }else{

                    if(_args && _args.length==1 && value==null){
                        _value = _args[0];
                    }

                    if(_variable.value!==_value){
                        changed = true;
                    }

                    _variable.value = _value;
                    _parsed = _value;
                }


                _variable.set('value',_parsed);

                var publish = false;


                var context = this.getContext();
                if(context) {
                    var device = context.device;
                    if(device && device.info && isServer && device.info.serverSide) {
                        if (this.flags & types.VARIABLE_FLAGS.PUBLISH_IF_SERVER) {
                            publish = true;
                        }else{
                            publish=false;
                        }
                    }
                }

                if(this.flags & types.VARIABLE_FLAGS.PUBLISH && changed){
                    publish = true;
                }

                changed && factory.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED,{
                    item:_variable,
                    scope:this.scope,
                    save:false,
                    block:this,
                    name:_variable.name,
                    value:_value,
                    publish:publish,
                    result:_parsed
                });
                this.onSuccess(this,settings);
                return [];
            }
        },
        canAdd:function(){
            return null;
        },
        getFields:function(){

            var fields = this.inherited(arguments) || this.getDefaultFields(false);
            var thiz=this;

            /*
            fields.push(this.utils.createCI('Variable',3,this.variable,{
                    group:'General',
                    dst:'variable',
                    widget:{
                        store:new DstoreAdapter(this.scope.blockStore),
                        query:{
                            group:'basicVariables'
                        }
                    }
            }));
            */




            fields.push(this.utils.createCI('value',29,this.value,{
                    group:'General',
                    title:'Value',
                    dst:'value',
                    widget:{
                        allowACECache:true,
                        showBrowser:false,
                        showSaveButton:true,
                        editorOptions:{
                            showGutter:false,
                            autoSelect: false,
                            autoFocus: false,
                            hasConsole:false,
                            hasItemActions:function(){
                                return false
                            }
                        },
                        item:this
                    },
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
            }));




            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.variable,{
                group:'Variable',
                title:'Variable',
                dst:'variable',
                //options:this.scope.getVariablesAsOptions(),
                block:this,
                pickerType:'variable',
                value:this.variable,
                widget:{
                    store:this.scope.blockStore,
                    labelField:'name',
                    valueField:'id',
                    value:this.variable,
                    query:[
                        {
                            group:'basicVariables'
                        },
                        {
                            group:'processVariables'
                        }
                    ]

                }
            }));

            fields.push(this.utils.createCI('flags',5,this.flags,{
                group:'Variable',
                title:'Flags',
                dst:'flags',
                data:[
                    {
                        value: 0x00000002,
                        label: 'Publish to network',
                        title:"Publish to network in order to make a network variable"
                    },
                    {
                        value: 0x00000004,//2048
                        label: 'Publish if server',
                        title: 'Publish only on network if this is running server side'
                    }
                ],
                widget:{
                    hex:true
                }

            }));

            return fields;
        }
    });

    return Module;

});;
define('dstore/legacy/DstoreAdapter',[
	'dojo/_base/declare',
	'dojo/_base/array',
	'dojo/store/util/QueryResults'
	/*=====, "dstore/api/Store" =====*/
], function (declare, arrayUtil, QueryResults /*=====, Store =====*/) {
// module:
//		An adapter mixin that makes a dstore store object look like a legacy Dojo object store.

	function passthrough(data) {
		return data;
	}

	// No base class, but for purposes of documentation, the base class is dstore/api/Store
	var base = null;
	/*===== base = Store; =====*/

	var adapterPrototype = {

		// store:
		//		The dstore store that is wrapped as a Dojo object store
		store: null,

		constructor: function (store) {
			this.store = store;

			if (store._getQuerierFactory('filter') || store._getQuerierFactory('sort')) {
				this.queryEngine = function (query, options) {
					options = options || {};

					var filterQuerierFactory = store._getQuerierFactory('filter');
					var filter = filterQuerierFactory ? filterQuerierFactory(query) : passthrough;

					var sortQuerierFactory = store._getQuerierFactory('sort');
					var sort = passthrough;
					if (sortQuerierFactory) {
						sort = sortQuerierFactory(arrayUtil.map(options.sort, function (criteria) {
							return {
								property: criteria.attribute,
								descending: criteria.descending
							};
						}));
					}

					var range = passthrough;
					if (!isNaN(options.start) || !isNaN(options.count)) {
						range = function (data) {
							var start = options.start || 0,
								count = options.count || Infinity;

							var results = data.slice(start, start + count);
							results.total = data.length;
							return results;
						};
					}

					return function (data) {
						return range(sort(filter(data)));
					};
				};
			}
			var objectStore = this;
			// we call notify on events to mimic the old dojo/store/Trackable
			store.on('add,update,delete', function (event) {
				var type = event.type;
				var target = event.target;
				objectStore.notify(
					(type === 'add' || type === 'update') ? target : undefined,
					(type === 'delete' || type === 'update') ?
						('id' in event ? event.id : store.getIdentity(target)) : undefined);
			});
		},
		labelAttr:'title',
		getLabel:function(item){
			return this.store.getLabel(item);
		},
		query: function (query, options) {
			// summary:
			//		Queries the store for objects. This does not alter the store, but returns a
			//		set of data from the store.
			// query: String|Object|Function
			//		The query to use for retrieving objects from the store.
			// options: dstore/api/Store.QueryOptions
			//		The optional arguments to apply to the resultset.
			// returns: dstore/api/Store.QueryResults
			//		The results of the query, extended with iterative methods.
			//
			// example:
			//		Given the following store:
			//
			//	...find all items where "prime" is true:
			//
			//	|	store.query({ prime: true }).forEach(function(object){
			//	|		// handle each object
			//	|	});
			options = options || {};

			var results = this.store.filter(query);
			var queryResults;
			var tracked;
			var total;

			// Apply sorting
			var sort = options.sort;
			if (sort) {
				if (Object.prototype.toString.call(sort) === '[object Array]') {
					var sortOptions;
					while ((sortOptions = sort.pop())) {
						results = results.sort(sortOptions.attribute, sortOptions.descending);
					}
				} else {
					results = results.sort(sort);
				}
			}

			if (results.track && !results.tracking) {
				// if it is trackable, always track, so that observe can
				// work properly.
				results = results.track();
				tracked = true;
			}
			if ('start' in options) {
				// Apply a range
				var start = options.start || 0;
				// object stores support sync results, so try that if available
				queryResults = results[results.fetchRangeSync ? 'fetchRangeSync' : 'fetchRange']({
					start: start,
					end: options.count ? (start + options.count) : Infinity
				});
			}
			queryResults = queryResults || results[results.fetchSync ? 'fetchSync' : 'fetch']();
			total = queryResults.totalLength;
			queryResults = new QueryResults(queryResults);
			queryResults.total = total;
			queryResults.observe = function (callback, includeObjectUpdates) {
				// translate observe to event listeners
				function convertUndefined(value) {
					if (value === undefined && tracked) {
						return -1;
					}
					return value;
				}
				var addHandle = results.on('add', function (event) {
					callback(event.target, -1, convertUndefined(event.index));
				});
				var updateHandle = results.on('update', function (event) {
					if (includeObjectUpdates || event.previousIndex !== event.index || !isFinite(event.index)) {
						callback(event.target, convertUndefined(event.previousIndex), convertUndefined(event.index));
					}
				});
				var removeHandle = results.on('delete', function (event) {
					callback(event.target, convertUndefined(event.previousIndex), -1);
				});
				var handle = {
					remove: function () {
						addHandle.remove();
						updateHandle.remove();
						removeHandle.remove();
					}
				};
				handle.cancel = handle.remove;
				return handle;
			};
			return queryResults;
		},
		notify: function () {

		}
	};

	var delegatedMethods = [ 'get', 'put', 'add', 'remove', 'getIdentity' ];
	arrayUtil.forEach(delegatedMethods, function (methodName) {
		adapterPrototype[methodName] = function () {
			var store = this.store;
			// try sync first, since dojo object stores support that directly
			return (store[methodName + 'Sync'] || store[methodName]).apply(store, arguments);
		};
	});

	return declare(base, adapterPrototype);
});
;
define('dojo/store/util/QueryResults',["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}
	// if it is a promise it may be frozen
	if(results.then){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		if(!results[method]){
			results[method] = function(){
				var args = arguments;
				return when(results, function(results){
					Array.prototype.unshift.call(args, results);
					return QueryResults(array[method].apply(array, args));
				});
			};
		}
	}
	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(!results.total){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});
;
define('xblox/model/loops/WhileBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/variables/Variable"
], function(dcl,Block,Variable){

    // summary:
    //		The while block model. It repeats a block a number of times, while the condition is true.
    //

    // module:
    //		xblox.model.loops.WhileBlock
    return dcl(Block,{

        declaredClass:"xblox.model.loops.WhileBlock",
        // condition: (String) expression to be evaluated every step
        condition: null,
        /**
         * Blocks to be executed while the condition is true
         * @type {xblox.model.Block[]}
         * @inheritDoc
         */
        items: null,

        loopLimit: 1500,

        name:'While',

        wait:0,

        _currentIndex:0,

        sharable:true,

        icon:"",

        _timer:null,

        //  standard call from interface
        canAdd:function(){
            return [];
        },
        _solve:function(scope,settings){
            var ret=[];
            for(var n = 0; n < this.items.length ; n++)
            {
                this.items[n].solve(scope,settings);
            }
            return ret;
        },

        doStep:function(settings){

            if(this._currentIndex < this.loopLimit){

                var ret = [];

                var _cond = this._checkCondition(this.scope);
                if(_cond) {
                    this.onSuccess(this,settings);
                    this.addToEnd( ret , this._solve(this.scope,settings));
                    this._currentIndex++;
                }else{
                    if(this._timer){
                        clearInterval(this._timer);
                    }


                    this.onFailed(this,settings);
                }
            }else{
                console.error('--while block : reached loop limit');
                this.reset();
            }
        },
        reset:function(){
            if(this._timer){
                clearTimeout(this._timer);
                this._timer = null;
            }
            this._currentIndex=0;


        },
        // solves the while block (runs the loop)
        solve:function(scope,settings) {

            //console.log('solve while ');
            this.loopLimit = 1500;
            settings = settings || { };

            var iterations = 0;

            var ret = [],
                thiz = this;

            var delay = this._getArg(this.wait);

            this.reset();

            // has delay
            if(delay>0){

                this._timer = setInterval(function(){
                    thiz.doStep(settings);
                },delay);

                return [];
            }

            // Evaluate condition
            while ((this._checkCondition(scope)) && (iterations < this.loopLimit)) {
                this._solve(scope,settings);
                iterations++;
            }
            //cleanup

            this.reset();

            return ret;

        },

        /**
         * Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText:function(){
            return this.getBlockIcon('G') + this.name + ' ' + this.condition;
        },

        // checks the loop condition
        _checkCondition:function(scope) {
            return scope.parseExpression(this.condition);
        },
        /**
         * Store function override
         * @param parent
         * @returns {boolean}
         */
        mayHaveChildren:function(parent){
            return this.items!=null && this.items.length>0;
        },

        /**
         * Store function override
         * @param parent
         * @returns {Array}
         */
        getChildren:function(parent){
            var result=[];

            if(this.items){
                result=result.concat(this.items);
            }
            return result;
        },
        getFields:function(){


            var thiz=this;

            var fields = this.inherited(arguments) || this.getDefaultFields();

            fields.push(

                this.utils.createCI('condition',25,this.condition,{
                    group:'General',
                    title:'Expression',
                    dst:'condition',
                    delegate:{
                        runExpression:function(val,run,error){
                            return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                        }
                    }
                })
            );

            fields.push(this.utils.createCI('wait',13,this.wait,{
                    group:'General',
                    title:'Wait',
                    dst:'wait'
            }));
            return fields;
        }


    });
});;
/** @module xblox/model/variables/Variable */
define('xblox/model/variables/Variable',[
    'dcl/dcl',
    'xide/types',
    "xblox/model/Block"
], function(dcl,types,Block){
    /**
     *  The command model. A 'command' consists out of a few parameters and a series of
     *  expressions. Those expressions need to be evaluated before send them to the device
     *
     * @class module:xblox.model.variables.Variable
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     */
    return dcl(Block,{
        declaredClass:"xblox.model.variables.Variable",
        //name: String
        //  the variable's name, it should be unique within a scope
        name:null,

        //value: Current variable value
        value:null,

        register:true,

        readOnly:false,

        initial:null,
        
        isVariable:true,
        flags: 0x000001000,
        getValue:function(){
            return this.value;
        },
        canDisable:function(){
            return false;
        },
        canMove:function(){
            return false;
        },
        getIconClass:function(){
            return 'el-icon-quotes-alt';
        },
        getBlockIcon:function(){
            return '<span class="'+this.icon+'"></span> ';
        },
        toText:function(){
            return "<span class='text-primary'>" + this.getBlockIcon() +  this.makeEditable('name','right','text','Enter a unique name','inline') +"</span>";
        },
        solve:function(){

            var _result = this.scope.parseExpression(this.getValue(),true);
            //console.log('resolved variable ' + this.title + ' to ' + _result);
            return [];

        },
        getFields:function(){
            var fields = this.getDefaultFields();
            var thiz=this,
                defaultArgs = {
                    allowACECache:true,
                    showBrowser:false,
                    showSaveButton:true,
                    editorOptions:{
                        showGutter:false,
                        autoFocus:false,
                        hasConsole:false
                    },
                    aceOptions:{
                        hasEmmet:false,
                        hasLinking:false,
                        hasMultiDocs:false
                    },
                    item:this
                };

            fields.push(this.utils.createCI('title',types.ECIType.STRING,this.name,{
                group:'General',
                title:'Name',
                dst:'name'
            }));

            fields.push(this.utils.createCI('value',types.ECIType.EXPRESSION,this.value,{
                group:'General',
                title:'Value',
                dst:'value',
                delegate:{
                    runExpression:function(val,run,error){
                        return thiz.scope.expressionModel.parse(thiz.scope,val,false,run,error);
                    }
                }
            }));

            


            //this.types.ECIType.EXPRESSION_EDITOR
            /*
            fields.push(this.utils.createCI('initial',this.types.ECIType.EXPRESSION,this.initial,{
                group:'General',
                title:'Initial',
                dst:'initial',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));
            */
            return fields;
        }
    });
});;
define('xblox/model/loops/ForBlock',[
    "dcl/dcl",
    "xblox/model/Block",
    "xblox/model/variables/Variable",
    'xblox/model/Contains',
    "dojo/promise/all",
    "dojo/Deferred"
], function (dcl, Block, Variable, Contains, all, Deferred) {

    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    // summary:
    //		The for block model. It repeats a block a number of times, while the condition is true.
    //

    // module:
    //		xblox.model.loops.ForBlock
    return dcl([Block, Contains], {
        declaredClass: "xblox.model.loops.ForBlock",
        // initial: xcf.model.Expression
        // the initial value
        initial: null,
        // final: xcf.model.Expression
        // the final value to be compared with the counter. Once the final value equals to the counter, the loop stops
        "final": null,
        //comparator: xblox.model.Comparator
        // Comparison to be applied -> compare <counter variable> width <final>
        comparator: null,
        // modifier: xcf.model.Expression
        // expression to be applied to the counter on every step. Expression: "<counter><modifier>"
        modifier: null,

        //items: Array (xblox.model.Block)
        //  block to be executed while the condition compare <counter variable> width <final> is false
        items: null,

        //counterName: String
        // the counter variable name
        counterName: null,
        // (private) counter: xblox.model.Variable
        // counter to be compared and updated on every step
        _counter: null,
        name: 'For',
        sharable: true,
        icon: '',
        ignoreErrors: false,
        deferred: true,
        _forState: false,
        _currentForIndex: 0,
        runFrom: function (_blocks, index, settings) {
            var thiz = this,
                blocks = _blocks || this.items,
                allDfds = [];

            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };

            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    onFinishBlock(block, results);
                });
            };

            if (blocks.length) {
                for (var n = index; n < blocks.length; n++) {
                    var block = blocks[n];
                    if (block.enabled === false) {
                        continue;
                    }
                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        allDfds.push(block.solve(this.scope, settings));
                        break;
                    } else {
                        allDfds.push(block.solve(this.scope, settings));
                    }
                }

            } else {
                this.onSuccess(this, settings);
            }
            return allDfds;
        },
        runFromDirect: function (_blocks, index, settings) {
            var thiz = this,
                blocks = _blocks || this.items,
                allDfds = [];

            var onFinishBlock = function (block, results) {
                block._lastResult = block._lastResult || results;
                thiz._currentIndex++;
                thiz.runFrom(blocks, thiz._currentIndex, settings);
            };

            var wireBlock = function (block) {
                block._deferredObject.then(function (results) {
                    onFinishBlock(block, results);
                });
            };
            if (blocks.length) {
                for (var n = index; n < blocks.length; n++) {
                    var block = blocks[n];
                    if (block.enabled === false) {
                        continue;
                    }
                    if (block.deferred === true) {
                        block._deferredObject = new Deferred();
                        this._currentIndex = n;
                        wireBlock(block);
                        allDfds.push(block.solve(this.scope, settings));
                        break;
                    } else {
                        allDfds.push(block.solve(this.scope, settings));
                    }
                }
            } else {
                this.onSuccess(this, settings);
            }

            return allDfds;
        },
        solveSubs: function (dfd, result, items, settings) {
            var thiz = this;
            settings.override = settings.override || {};
            settings.override['args'] = [this._currentForIndex];
            //more blocks?
            if (items.length) {
                var subDfds = thiz.runFrom(items, 0, settings);
                all(subDfds).then(function (what) {
                }, function (err) {
                    thiz.onDidRunItem(dfd, err, settings);
                });
                return subDfds;

            } else {
                thiz.onDidRunItem(dfd, result, settings);
            }
        },
        solveSubsDirect: function (dfd, result, items, settings) {
            var thiz = this;
            settings.override = settings.override || {};
            settings.override['args'] = [this._currentForIndex];
            //more blocks?
            if (items.length) {
                return thiz.runFromDirect(items, 0, settings);
            }
        },
        _solve: function (scope, settings) {
            var dfd = new Deferred(),
                self = this;
            var result = this.solveSubs(dfd, null, this.items, settings);
            if (result) {
                all(result).then(function (res) {
                    var falsy = res.indexOf(false);
                    if (self.ignoreErrors !== true && falsy !== -1) {
                        dfd.resolve(false);
                    } else {
                        dfd.resolve(true);
                    }
                });
            } else {
                dfd.resolve(true);
            }

            return dfd;
        },
        step: function (scope, settings) {
            var state = this._checkCondition(scope, settings);
            var dfd = new Deferred();
            if (state) {
                //run blocks
                var subs = this._solve(scope, settings);
                subs.then(function (result) {
                    if (result == true) {
                        dfd.resolve(true);
                    } else {
                        dfd.resolve(false);
                    }
                });
            }
            return dfd;
        },
        loop: function (scope, settings) {
            var stepResult = this.step(scope, settings),
                self = this;
            stepResult.then(function (proceed) {
                self._updateCounter(scope);
                self._currentForIndex = self._counter.value;
                if (proceed == true) {
                    self.loop(scope, settings);
                } else {
                    self.onFailed(self, settings);
                }
            });
        },
        _solveDirect: function (scope, settings) {
            return this.solveSubsDirect(null, null, this.items, settings);
        },
        stepDirect: function (scope, settings) {
            return this._solveDirect(scope, settings);
        },
        loopDirect: function (scope, settings) {
            this.stepDirect(scope, settings)
            for (var index = parseInt(this.initial, 10); index < parseInt(this['final'], 10); index++) {
                this.stepDirect(scope, settings);
            }
        },

        // solves the for block (runs the loop)
        solve: function (scope, settings) {
            // 1. Create and initialize counter variable
            this._counter = new Variable({
                title: this.counterName,
                value: this.initial,
                scope: scope,
                register: false
            });
            //prepare
            this._forState = true;
            this._currentForIndex = this.initial;
            this.deferred ? this.loop(scope, settings) : this.loopDirect(scope, settings);
            return [];
        },
        // checks the loop condition
        _checkCondition: function (scope, settings) {
            var expression = '' + this._counter.value + this.comparator + this['final'];
            var result = scope.parseExpression(expression);
            if (result != false) {
                this.onSuccess(this, settings);
            }
            this._forState = result;
            return result;
        },
        // updates the counter
        _updateCounter: function (scope) {
            var value = this._counter.value;
            var expression = '' + value + this.modifier;
            value = scope.parseExpression(expression);
            // Detect infinite loops
            if (value == this._counter.value) {
                return false;
            } else {
                this._counter.value = value;
                return true;
            }
        },
        /**
         * Store function override
         * @returns {boolean}
         */
        mayHaveChildren: function () {
            return this.items != null && this.items.length > 0;
        },
        /**
         * Store function override
         * @returns {Array}
         */
        getChildren: function () {
            var result = [];
            if (this.items) {
                result = result.concat(this.items);
            }
            return result;
        },
        /**
         * should return a number of valid classes
         * @returns {Array}
         */
        canAdd: function () {
            return [];
        },
        /**
         * UI, Block row editor, returns the entire text for this block
         * @returns {string}
         */
        toText: function () {
            return this.getBlockIcon('F') + this.name + ' ' + this.initial + ' ' + this.comparator + ' ' + this['final'] + ' with ' + this.modifier;
        },
        /**
         * UI
         * @returns {*[]}
         */
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields = fields.concat([
                this.utils.createCI('initial', 13, this.initial, {
                    group: 'General',
                    title: 'Initial',
                    dst: 'initial'
                }),
                this.utils.createCI('Final', 13, this['final'], {
                    group: 'General',
                    title: 'Final',
                    dst: 'final'
                }),
                this.utils.createCI('comparator', 13, this.comparator, {
                    group: 'General',
                    title: 'Comparision',
                    dst: 'comparator'
                }),
                this.utils.createCI('modifier', 13, this.modifier, {
                    group: 'General',
                    title: 'Modifier',
                    dst: 'modifier'
                }),
                this.utils.createCI('Abort on Error', 0, this.ignoreErrors, {
                    group: 'General',
                    title: 'Ignore Errors',
                    dst: 'ignoreErrors'
                }),
                this.utils.createCI('Deferred', 0, this.deferred, {
                    group: 'General',
                    title: 'Use Deferred',
                    dst: 'deferred'
                })
            ]);
            return fields;
        }
    });
});;
/** @module xblox/model/code/RunScript **/
define('xblox/model/code/RunScript',[
    'dcl/dcl',
    'xdojo/has',
    "dojo/Deferred",
    "xblox/model/Block",
    'xide/utils',
    'xblox/model/Contains',
    'dojo/promise/all',
    'xide/types',
    'module'
    //'xdojo/has!host-node?dojo/node!tracer',
    //'xdojo/has!host-node?nxapp/utils/_console'
    //"xdojo/has!xblox-ui?dojo/text!./RunScript.html"
    //"xdojo/has!xblox-ui?dojo/text!xblox/docs/code/RunScript.md"
], function(dcl,has,Deferred,Block,utils,Contains,all,types,module,tracer,_console,Description,Help){

    
    var isServer = has('host-node');
    var console = typeof window !== 'undefined' ? window.console : global.console;
    if(isServer && tracer && console && console.error){
        console = _console;
    }
    /**
     *
     * @class module:xblox/model/code/RunScript
     * @extends module:xblox/model/Block
     */
    return dcl([Block,Contains],{
        declaredClass:"xblox.model.code.RunScript",
        name:'Run Script',
        method:'',
        args:'',
        deferred:false,
        sharable:true,
        context:null,
        icon:'fa-code',
        observed:[
            'method'
        ],
        getContext:function(){
            return this.context || (this.scope.getContext ?  this.scope.getContext() : this);
            return this.context || this;
        },
        /***
         * Returns the block run result
         * @param scope
         * @param settings
         * @param run
         * @param error
         * @returns {Array}
         */
        solve2:function(scope,settings,run,error) {
            this._currentIndex = 0;
            this._return=[];
            var _script = '' + this._get('method');
            var thiz=this,
                ctx = this.getContext();
            if(_script && _script.length) {

                var runScript = function() {
                    var _function = new Function("{" + _script + "}");
                    var _args = thiz.getArgs() || [];
                    try {
                        var _parsed = _function.apply(ctx, _args || {});
                        thiz._lastResult = _parsed;
                        if (run) {
                            run('Expression ' + _script + ' evaluates to ' + _parsed);
                        }
                        if (_parsed !== 'false' && _parsed !== false) {
                            thiz.onSuccess(thiz, settings,{
                                result:_parsed
                            });
                        } else {
                            thiz.onFailed(thiz, settings);
                            return [];
                        }
                    } catch (e) {
                        if (error) {
                            error('invalid expression : \n' + _script + ': ' + e);
                        }
                        thiz.onFailed(thiz, settings);
                        return [];
                    }
                };

                if(scope.global){
                    (function() {
                        window = scope.global;
                        var _args = thiz.getArgs() || [];
                        try {
                            var _parsed = null;
                            if(!ctx.runExpression) {
                                var _function = new Function("{" + _script + "}").bind(this);
                                _parsed = _function.apply(ctx, _args || {});
                            }else{
                                _parsed = ctx.runExpression(_script,null,_args);
                            }

                            thiz._lastResult = _parsed;

                            if (run) {
                                run('Expression ' + _script + ' evaluates to ' + _parsed);
                            }
                            if (_parsed !== 'false' && _parsed !== false) {
                                thiz.onSuccess(thiz, settings);
                            } else {
                                thiz.onFailed(thiz, settings);
                                return [];
                            }
                        } catch (e) {
                            thiz._lastResult = null;
                            if (error) {
                                error('invalid expression : \n' + _script + ': ' + e);
                            }
                            thiz.onFailed(thiz, settings);
                            return [];
                        }

                    }).call(scope.global);

                }else{
                    return runScript();
                }
            }else{
                console.error('have no script');
            }
            var ret=[], items = this[this._getContainer()];
            if(items.length) {
                this.runFrom(items,0,settings);
            }else{
                this.onSuccess(this, settings);
            }
            this.onDidRun();
            return ret;
        },
        /**
         *
         * @param scope
         * @param settings
         * @param run
         * @param error
         */
        solve:function(scope,settings,isInterface,send,run,error){

            this._currentIndex = 0;
            this._return=[];


            settings = settings || {};
            var _script = send || (this._get('method') ? this._get('method') : this.method);

            if(!scope.expressionModel){
                //console.error('mar',scope);
                throw new Error('na');
                return;
            }

            var thiz=this,
                ctx = this.getContext(),
                items = this[this._getContainer()],

                //outer
                dfd = new Deferred,
                listener = settings.listener,
                isDfd = thiz.deferred,
                expressionModel = scope.getExpressionModel();



            this.onRunThis(settings);

            function globalEval(text) {
                var ret;
                // Properly escape \, " and ' in the input, normalize \r\n to an escaped \n
                text = text.replace(/["'\\]/g, "\\$&").replace(/\r\n/g, "\\n");

                // You have to use eval() because not every expression can be used with an assignment operator
                var where = typeof window!=='undefined' ? window : global;

                where.execScript("globalEval.____lastInputResult____ = eval('" + text + "');} }");

                // Store the result and delete the property
                ret = globalEval.____lastInputResult____;
                delete globalEval.____lastInputResult____;

                return ret;
            }
            if(!expressionModel){
                console.error('scope has no expression model');
                return false;
            }
            var expression = expressionModel.replaceVariables(scope,_script,null,null);
            var _function = expressionModel.expressionCache[expression];
            if(!_function){
                _function = expressionModel.expressionCache[expression] = new Function("{" + expression + "}");
            }
            var _args = thiz.getArgs(settings) || [];
            try {
                if(isDfd){
                    ctx.resolve=function(result){
                        if(thiz._deferredObject) {
                            thiz._deferredObject.resolve();
                        }
                        thiz.onDidRunThis(dfd,result,items,settings);
                    }
                }
                var _parsed = _function.apply(ctx, _args || {});
                thiz._lastResult = _parsed;
                if (run) {
                    run('Expression ' + _script + ' evaluates to ' + _parsed);
                }
                if(!isDfd) {
                    thiz.onDidRunThis(dfd,_parsed,items,settings);
                }
                if (_parsed !== 'false' && _parsed !== false) {
                    thiz.onSuccess(thiz, settings);
                } else {
                    thiz.onFailed(thiz, settings);
                }
            } catch (e) {
                e=e ||{};
                thiz.onDidRunItemError(dfd,e,settings);
                thiz.onFailed(thiz,settings);
                if (error) {
                    error('invalid expression : \n' + _script + ': ' + e);
                }
            }
            return dfd;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        toText:function(){

            var result = '<span style="">' + this.getBlockIcon() + ' ' + this.name + ' :: '+'</span>';
            if(this.method){
                result+= this.method.substr(0,50);
            }
            return result;
        },
        canAdd:function(){
            return true;
        },
        getFields:function(){
            if(this.description === 'No Description'){
                this.description = Description;
            }
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz=this;
            fields.push(
                utils.createCI('name',13,this.name,{
                    group:'General',
                    title:'Name',
                    dst:'name'
                })
            );
            fields.push(
                utils.createCI('deferred',0,this.deferred,{
                    group:'General',
                    title:'Deferred',
                    dst:'deferred'
                })
            );
            fields.push(utils.createCI('arguments',27,this.args,{
                    group:'Arguments',
                    title:'Arguments',
                    dst:'args'
                }));

            fields.push(
                utils.createCI('value',types.ECIType.EXPRESSION_EDITOR,this.method,{
                    group:'Script',
                    title:'Script',
                    dst:'method',
                    select:true,
                    widget:{
                        allowACECache:true,
                        showBrowser:false,
                        showSaveButton:true,
                        editorOptions:{
                            showGutter:true,
                            autoFocus:false
                        },
                        item:this
                    },
                    delegate:{
                        runExpression:function(val,run,error){
                            var old = thiz.method;
                            thiz.method=val;
                            var _res = thiz.solve(thiz.scope,null,run,error);
                        }
                    }
                }));
            return fields;
        }
    });
});;
define('xblox/model/code/CallMethod',[
    'dcl/dcl',
    "xblox/model/Block",
    'xide/utils'
], function(dcl,Block,utils){

    // summary:
    //		The Call Block model.
    //      This block makes calls to another blocks in the same scope by action name

    // module:
    //		xblox.model.code.CallMethod
    return dcl(Block,{
        declaredClass:"xblox.model.code.CallMethod",
        //method: (String)
        //  block action name
        name:'Call Method',
        //method: (String)
        //  block action name
        method:'',
        args:'',

        sharable:true,
        /***
         * Returns the block run result
         * @param scope
         */
        solve:function(scope,settings) {
            var context = this.getContext();
            if (context && context[this.method]!=null)
            {


                var res = [];
                var _fn = context[this.method];
                try{
                    var _args = this.getArgs(settings);
                    console.log('args',_args);
                    var _res = _fn.apply(context,_args||[]);
                    res = _res;
                    this.onSuccess(this,settings);
                    return res;
                }catch(e){
                    console.error('call method ' + this.method + ' failed: '+e);
                    logError(e);
                    this.onFailed(this,settings);
                }
            }else{
                this.onFailed(this,settings);
                return [];
            }
            return [];
        },
        toText:function(){

            var result = this.getBlockIcon() + ' ' + this.name + ' ';
            if(this.method){
                result+= this.makeEditable('method','bottom','text','Enter a driver method','inline');
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){

            var fields = this.getDefaultFields();

            var context = this.getContext();
/*
            console.log('call method ', this.getScope().getContext());
            console.log('call method ', context);*/


            fields.push(utils.createCI('value',13,this.method,{
                    group:'General',
                    title:'Method',
                    dst:'method'
                }));

            fields.push(utils.createCI('value',27,this.args,{
                    group:'Arguments',
                    dst:'args',
                    widget:{
                        title:''
                    }
                }));

            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-caret-square-o-right"></span>';
        }
    });
});;
define('xblox/model/functions/SetProperties',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    "xblox/model/Block",
    "xide/lodash"
], function(dcl,utils,types,Deferred,Block,_){
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl(Block,{
        declaredClass:"xblox.model.functions.SetProperties",
        command:'Select block',
        icon:'',
        args:null,
        _timeout:100,
        hasInlineEdits:false,
        solve:function(scope,settings) {
            var dfd = new Deferred();
            if (this.command){
                var block = scope.resolveBlock(this.command);
                if(block && this.props){
                    for(var prop in this.props){
                        block.set(prop,this.props[prop]);
                        block[prop] = this.props[prop];
                        block.onChangeField && block.onChangeField(prop,this.props[prop]);
                    }
                    this.onSuccess(this,settings);
                }else{
                    this.onFailed(this,settings);
                }
                dfd.resolve([]);
                return dfd;
            }
            return dfd;
        },
        /**
         *
         * @param field
         * @param pos
         * @param type
         * @param title
         * @param mode: inline | popup
         * @returns {string}
         */
        makeEditable:function(field,pos,type,title,mode){
            var optionsString = "";
            return "<a " + optionsString + "  tabIndex=\"-1\" pos='" + pos +"' display-mode='" + (mode||'popup') + "' display-type='" + (type || 'text') +"' data-prop='" + field + "' data-title='" + title + "' class='editable editable-click'  href='#'>" + this[field] +"</a>";
        },
        getFieldOptions:function(field){
            if(field ==="command"){
                return this.scope.getCommandsAsOptions("text");
            }
        },
        toText:function(){
            var text = 'Unknown';
            var block = this.scope.getBlock(this.command);
            if(block){
                text = block.name;
            }
            if(this.command.indexOf('://')!==-1) {
                text = '<span class="text-info">' +this.scope.toFriendlyName(this,this.command) + '</span>';
            }
            return this.getBlockIcon('D') + 'Set Properties : ' + text;
        },
        serializeObject:function(field){
            return field === 'props';
        },
        onChangeField:function(field){
            if(field==='command'){
                delete this.props;
                this.props = {};
            }
        },
        init:function(){
            if(this.props && _.isString(this.props)){
                this.props = utils.fromJson(this.props);
            }

        },
        getFields:function(){
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(utils.createCI('value','xcf.widgets.CommandPicker',this.command,{
                    group:'General',
                    title:'Command',
                    dst:'command',
                    options:this.scope.getCommandsAsOptions(),
                    block:this,
                    pickerType:'command',
                    value:this.command
            }));
            var block = this.scope.resolveBlock(this.command);
            if(block && block.getFields){
                if(!this.props){
                    this.props = {};
                }
                var _fields = block.getFields();
                var descr = _.find(_fields,{
                    dst:"description"
                });
                _fields.remove(descr);
                _.each(_fields,function(_field){
                    _field.group = "Properties";
                    _field.value = utils.getAt(this.props,_field.dst,_field.value);
                    _field.dst = "props." + _field.dst;

                },this);
                fields = fields.concat(_fields);
            }
            return fields;
        }
    });
});;
define('xblox/model/logic/CaseBlock',[
    'dcl/dcl',
    'xide/utils',
    'xblox/model/Block',
    'dojo/Deferred',
    "xblox/model/logic/BreakBlock"
], function (dcl, utils, Block, Deferred, BreakBlock) {
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block, {
        declaredClass: "xblox.model.logic.CaseBlock",
        //comparator: xblox.model.Comparator
        // Comparison to be applied -> compare <switch variable> width <expression>
        comparator: null,
        //expression: xblox.model.Expression
        // expression to be compared
        expression: null,
        //items: Array (xblox.model.Block)
        //  block to be executed if the comparison result is true
        items: null,
        name: 'Case',
        icon: '',
        hasInlineEdits: true,
        toText: function () {
            var _comparator = '' + this.comparator;
            if (_comparator == '==') {
                //_comparator =''
            }
            return '<span style="text-indent: 1em;">&nbsp;&nbsp;&nbsp;' + this.getBlockIcon('I') + this.name + ' ' + this.makeEditable('comparator', 'right', 'text', 'Enter a comparison', 'inline') + (this.expression != null ? ' ' + this.makeEditable('expression', 'right', 'text', 'Enter a value to compare') : '') + '</span>';
        },
        canAdd: function () {
            return [];
        },
        /**
         *
         * @param scope
         * @param settings
         * @param switchblock
         * @returns {Array}
         * @private
         */
        _solve: function (scope, settings, switchblock) {
            settings = settings || {
                    highlight: false
                };
            var ret = [];
            for (var n = 0; n < this.items.length; n++) {
                var block = this.items[n];
                if (block.declaredClass.indexOf('BreakBlock') !== -1) {
                    switchblock.stop();
                }
                this.addToEnd(ret, block.solve(scope, settings));
            }

            return ret;
        },
        /***
         * Solves the case block
         * @param scope
         * @param settings
         * @param switchBlock   => parent SwitchCommand block
         */
        solve: function (scope, switchBlock, settings) {
            try {
                var _var = scope.getVariableById(switchBlock.variable);
                if (!_var && settings.args && settings.args[0]) {
                    _var = {value: settings.args[0]};
                }
                // Get the variable to evaluate
                var switchVarValue = '';
                if (_var) {
                    switchVarValue = this._getArg(_var.value, true);
                } else {
                    this.onFailed(this, settings);
                    // Comparation is false
                    return false;
                }
                //var compResult = scope.parseExpression("'" + switchVarValue+ "'" + this.comparator + this.expression);
                var compResult = scope.parseExpression("" + switchVarValue + "" + this.comparator + this._getArg(this.expression, true));
                if (compResult !== true) {
                    this.onFailed(this, settings);
                    // Comparation is false
                    return false;
                } else {
                    this.onSuccess(this, settings);
                    // Comparation is true. Return block.solve();
                    this._solve(scope, settings, switchBlock);
                    return true;
                }
            } catch (e) {
                logError(e);
            }
        },
        /**
         * Store function override
         * @returns {Array}
         */
        getChildren: function () {
            return this.items;
        },
        //  standard call for editing
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(utils.createCI('Expression', 13, this.expression, {
                group: 'General',
                title: 'Expression',
                dst: 'expression'
            }));

            function makeOption(value, label) {
                return {
                    label: label || value,
                    value: value
                }
            }

            fields.push(utils.createCI('Comparator', 3, this.comparator, {
                group: 'General',
                title: 'Comparator',
                dst: 'comparator',
                widget: {
                    options: [
                        /*makeOption('==',"Equals"),
                         makeOption('<=',"Smaller or equal"),
                         makeOption('=>',"Greater or equal"),
                         makeOption('!=',"Not equal"),
                         makeOption('<',"Smaller than"),
                         makeOption('>',"Greater than")*/
                        makeOption('=='),
                        makeOption('<='),
                        makeOption('=>'),
                        makeOption('!='),
                        makeOption('<'),
                        makeOption('>')
                    ],
                    editable: true
                }
            }));
            return fields;
        },
        runAction: function (action) {
            if (action.command === 'New/Break') {
                var dfd = new Deferred();
                var newBlock = this.add(BreakBlock, {
                    group: null
                });
                var defaultDfdArgs = {
                    select: [newBlock],
                    focus: true,
                    append: false
                };
                dfd.resolve(defaultDfdArgs);
                newBlock.refresh();
                return dfd;
            }
        },
        getActions: function () {
            return [this.createAction({
                label: 'Break',
                command: 'New/Break',
                tab: 'Home',
                icon: 'fa-stop',
                group: 'File',
                mixin: {
                    addPermission: true,
                    custom: true,
                    quick: false
                }
            })
            ]
        }
    });
});;
define('xblox/model/logic/BreakBlock',[
    'dcl/dcl',
    'xblox/model/Block'
], function (dcl, Block) {
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */

    // summary:
    //		The Case Block model. Each case block contains a comparation and a commands block.
    //      If the comparation result is true, the block is executed
    //
    //      This block should have an "SwitchBlock" parent

    // module:
    //		xblox.model.logic.CaseBlock
    return dcl(Block, {
        declaredClass: "xblox.model.logic.BreakBlock",
        name: 'Break',
        icon: 'fa-stop',
        hasInlineEdits: false,
        canAdd: false,
        toText: function () {
            return '&nbsp;<span class="fa-stop text-warning"></span>&nbsp;&nbsp;<span>' + this.name + '</span>';
        },
        /***
         * Solves the case block
         * @param scope
         * @param settings
         */
        solve: function (scope, settings) {
            this.onSuccess(this, settings);
        }
    });
});;
/** @module xcf/model/Variable */
define('xcf/model/Variable',[
    'dcl/dcl',
    'xide/types',
    "xblox/model/variables/Variable"
], function(dcl,types,Variable){
    /**
     *
     * Model for a variable. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Variable
     * @extends module:xblox/model/Variables/Variable
     * @augments module:xide/mixins/EventedMixin
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    return dcl(Variable,{
        declaredClass: "xcf.model.Variable",
        /**
         * @private
         */
        hasInlineEdits:true,
        /////////////////////////////////////////////////
        //
        //  On-Change related members
        //
        // 3.12.9.4. a group of options that define a task to be performed when the variable value is changed.
        //
        /////////////////////////////////////////////////
        /**
         * 3.12.9.4.1. on a change to the variable, any object (button, text field, etc.) which references
         * the variable should be evaluated and updated accordingly. If Cmd is selected this should deselect.
         * @private
         */
        gui:"off",
        /**
         * 3.12.9.4.2. on a change to the variable, any command which references the variable
         * should be executed. If GUI is selected this should deselect.
         * @private
         */
        cmd:"off",
        /**
         * 3.12.9.4.3. selecting this checkbox signifies that the variable value automatically gets saved
         * to an xml file whenever changed for recallability.  When active,
         * the Initialize field should show saved value and at startup the saved
         * value should be assigned to the variable from the Saved Values File.
         * @private
         */
        save:false,
        /**
         * @private
         */
        target:'None',
        /**
         * The name of the variable
         */
        name:'No Title',
        /**
         * The value of the variable
         */
        value:-1,
        /**
         * @private
         */
        observed:[
            'value',
            'initial',
            'name'
        ],

        solve:function(){
            var extra = "";
            if(this.group==='processVariables'){
                var _val = this.scope.getVariable("value");
                if(_val) {
                    _val = _val.value;
                    if(!this.isNumber(_val)){
                        _val = ''+_val;
                        _val = "'" + _val + "'";
                    }
                    extra = "var value = " + _val +";\n";
                }
            }
            var _result = this.scope.parseExpression(extra + this.getValue(),true);
            return _result;
        },
        /**
         * @private
         * @returns {boolean}
         */
        canEdit:function(){
            return true;
        },
        /**
         * @private
         * @returns {boolean}
         */
        canDisable:function(){
            return false;
        },
        /**
         * @private
         * @returns {*}
         */
        getFields:function(){
            var fields = this.getDefaultFields();
            fields.push(this.utils.createCI('title',13,this.name,{
                group:'General',
                title:'Name',
                dst:'name'
            }));


            var thiz=this,
                defaultArgs = {
                    allowACECache:true,
                    showBrowser:false,
                    showSaveButton:true,
                    editorOptions:{
                        showGutter:false,
                        autoFocus:false,
                        hasConsole:false
                    },
                    aceOptions:{
                        hasEmmet:false,
                        hasLinking:false,
                        hasMultiDocs:false
                    },
                    item:this
                };


            //this.types.ECIType.EXPRESSION_EDITOR
            fields.push(this.utils.createCI('value',this.types.ECIType.EXPRESSION,this.value,{
                group:'General',
                title:'Value',
                dst:'value',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));

            fields.push(this.utils.createCI('flags', 5, this.flags, {
                group: 'General',
                title: 'Flags',
                dst: 'flags',
                data: [
                    {
                        value: 0x000001000,
                        label: 'Dont parse',
                        title: "Do not parse the string and use it as is"
                    },
                    {
                        value: 0x00000800,//2048
                        label: 'Expression',
                        title: 'Parse it as Javascript'
                    }
                ],
                widget: {
                    hex: true
                }
            }));

/*
            //this.types.ECIType.EXPRESSION_EDITOR
            fields.push(this.utils.createCI('initial',this.types.ECIType.EXPRESSION,this.initial,{
                group:'General',
                title:'Initial',
                dst:'initial',
                widget:defaultArgs,
                delegate:{
                    runExpression:function(val,run,error){
                        if(thiz.group=='processVariables'){
                            var _val = thiz.scope.getVariable("value");
                            var extra = "";
                            if(_val) {
                                _val = _val.value;
                                if(!thiz.isNumber(_val)){
                                    _val = ''+_val;
                                    _val = "'" + _val + "'";
                                }
                                extra = "var value = " + _val +";\n";
                            }
                        }
                        return thiz.scope.expressionModel.parse(thiz.scope,extra + val,false,run,error);
                    }
                }
            }));
            */

            return fields;
        },
        onChangeField:function(field,newValue,cis) {
            if(field==='value'){
                this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                    item: this,
                    scope: this.scope,
                    save: false,
                    source: types.MESSAGE_SOURCE.GUI  //for prioritizing
                });
            }
        }
    });
});
;
define('xcf/model/ModelBase',[
    'dcl/dcl',
    "xblox/model/ModelBase"
], function(dcl,ModelBase){
    return dcl(ModelBase,{
        declaredClass:'xcf.model.ModelBase'
    });
});;
/** @module xcf/model/Driver */
define('xcf/model/Driver',[
    'xdojo/declare',
    "dcl/dcl",
    "xide/data/Model",
    "xide/utils"
], function(declare,dcl,Model,utils){
    /**
     *
     * Model for a driver. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Driver
     * @augments module:xide/mixins/EventedMixin
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    var Module = dcl(Model,{
        itemMetaPath:'user.meta',
        getStore:function(){
            return this._store;
        },
        getScope:function(){
            var store = this.getStore();
            return store ? store.scope : this.scope;
        },
        /**
         * Return a value by field from the meta database
         * @param title
         * @returns {string|int|boolean|null}
         */
        getMetaValue: function (title) {
            return utils.getCIInputValueByName(this.user,title);
        },
        /**
         * Set a value in the meta database
         * @param title {string} The name of the CI
         * @returns {void|null}
         */
        setMetaValue: function (what,value,publish) {
            var item = this;
            var meta = this.user;
            var ci = utils.getCIByChainAndName(meta, 0, what);
            if(!ci){
                return;
            }
            var oldValue = this.getMetaValue(what);
            utils.setCIValueByField(ci, 'value', value);
            this[what] = value;
            if(publish!==false){
                this.publish(types.EVENTS.ON_CI_UPDATE,{
                    owner: this.owner,
                    ci: ci,
                    newValue: value,
                    oldValue: oldValue
                });
            }
        },
        /**
         * Return the parent folder
         * @returns {module:xcf/model/Driver}
         */
        getParent:function(){
            return this._store.getSync(this.parentId);
        }
    });

    return Module;
});
;
/** @module xcf/model/Device */
define('xcf/model/Device',[
    "dcl/dcl",
    "xide/data/Model",
    'xide/data/Source',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',
    "xcf/types/Types"
], function(dcl,Model,Source,types,utils,EventedMixin){
    /**
     *
     * Model for a device. It extends the base model class
     * and acts a source.
     *
     * @module xcf/model/Device
     * @extends {module:xide/mixins/EventedMixin}
     * @augments module:xide/data/Model
     * @augments module:xide/data/Source
     */
    var Module = dcl([Model,Source.dcl,EventedMixin.dcl],{
        declaredClass:'xcf.model.Device',
        _userStopped:false,
        /**
         * @type {module:xide/types~DEVICE_STATE}
         * @link module:xide/types/DEVICE_STATE
         * @see module:xide/types/DEVICE_STATE
         */
        state:types.DEVICE_STATE.DISCONNECTED,
        /**
         * The driver instance
         * @private
         */
        driverInstance:null,
        /**
         * The block scope of the driver instance (if the device is connected and ready)
         * @private
         */
        blockScope:null,
        getParent:function(){
            return this.getStore().getSync(this.parentId);
        },
        isServerSide:function(){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            return (1 << types.DRIVER_FLAGS.RUNS_ON_SERVER & driverOptions) ? true : false;
        },
        isServer:function(){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            return (1 << types.DRIVER_FLAGS.SERVER & driverOptions) ? true : false;
        },
        setServer:function(isServer){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            driverOptions.value = driverOptions.value | (1 << types.DRIVER_FLAGS.SERVER);
            this.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,driverOptions.value);
        },
        setServerSide:function(isServer){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            driverOptions= driverOptions | (1 << types.DRIVER_FLAGS.RUNS_ON_SERVER);
            this.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,driverOptions);
        },
        isDebug:function(){
            var driverOptions = this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            return (1 << types.DRIVER_FLAGS.DEBUG & driverOptions) ? true : false;
        },
        check:function(){
            if(this._startDfd && this._userStopped===true){
                this.reset();
            }
        },
        getStore:function(){
            return this._store;
        },
        getScope:function(){
            var store = this.getStore();
            return store ? store.scope : this.scope;
        },
        isEnabled:function(){
            return this.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED) === true;
        },
        setEnabled:function(enabled){
            return this.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED,enabled);
        },
        shouldReconnect:function(){
            if (this._userStopped) {
                return false;
            }
            return this.isEnabled();
        },
        reset:function(){
            delete this._startDfd;
            this._startDfd = null;
            delete this['blockScope'];
            this['blockScope'] = null;
            delete this.serverVariables;
            this.serverVariables = null;
            delete this['driverInstance'];
            this['driverInstance'] = null;
            clearTimeout(this.reconnectTimer);
            delete this.lastReconnectTime;
            delete this.reconnectRetry;
            delete this.isReconnecting;
            this.setState(types.DEVICE_STATE.DISCONNECTED);
        },
        /**
         * @constructor
         * @alias module:xcf/model/Device
         */
        constructor:function(){},
        /**
         * Returns the block scope of the a driver's instance
         * @returns {module:xblox/model/Scope}
         */
        getBlockScope:function(){
            //return this.blockScope;
            return this.driverInstance && this.driverInstance.blockScope ? this.driverInstance.blockScope : this.blockScope;
        },
        /**
         * Returns the driver instance
         * @returns {model:xcf/driver/DriverBase}
         */
        getDriverInstance:function(){
            return this.driverInstance;
        },
        /**
         * Return the driver model item
         * @returns {module:xcf/model/Driver|null}
         */
        getDriver:function(){
            var scope = this.getBlockScope();
            if(scope){
                return scope.driver;
            }
            return null;
        },
        /**
         * Return a value by field from the meta database
         * @param title
         * @returns {string|int|boolean|null}
         */
        getMetaValue: function (title) {
            return utils.getCIInputValueByName(this.user,title);
        },
        /**
         * Set a value in the meta database
         * @param title {string} The name of the CI
         * @returns {void|null}
         */
        setMetaValue: function (what,value,publish) {
            var item = this;
            var meta = this.user;
            var ci = utils.getCIByChainAndName(meta, 0, what);
            if(!ci){
                return null;
            }
            var oldValue = this.getMetaValue(what);
            utils.setCIValueByField(ci, 'value', value);
            this[what] = value;
            if(publish!==false && oldValue!=value){
                var eventArgs = {
                    owner: this.owner,
                    ci: ci,
                    newValue: value,
                    oldValue: oldValue
                };
                return this.publish(types.EVENTS.ON_CI_UPDATE, eventArgs);
            }
        },
        /**
         * Return the internal state icon
         * @param state
         * @returns {string|null}
         */
        getStateIcon:function(state ){
            state = state || this.state;
            switch (state) {
                case types.DEVICE_STATE.DISCONNECTED:
                {
                    return 'fa-unlink iconStatusOff'
                }
                case types.DEVICE_STATE.READY:
                case types.DEVICE_STATE.CONNECTED:
                {
                    return 'fa-link iconStatusOn'
                }
                case types.DEVICE_STATE.SYNCHRONIZING:
                case types.DEVICE_STATE.CONNECTING:
                {
                    return 'fa-spinner fa-spin'
                }
                case types.DEVICE_STATE.LOST_DEVICE_SERVER:
                {
                    return 'fa-spinner fa-spin'
                }
            }
            return 'fa-unlink iconStatusOff';
        },
        /**
         * Set the state
         * @param state
         * @param silent
         */
        setState:function(state,silent){
            if(state===this.state){
                return;
            }
            var oldState = this.state,
                icon = this.getStateIcon(state);
            this.state = state;
            this.set('iconClass',icon);
            this.set('state',state);
            this._emit(types.EVENTS.ON_DEVICE_STATE_CHANGED,{
                old:oldState,
                state:state,
                icon:icon,
                "public":true
            });
            this.refresh('state');
        }
    });
    Module.createSubclass = Model.createSubclass;
    return Module;
});
;
/** @module xcf/model/Command */
define('xcf/model/Command',[
    'dcl/dcl',
    "xblox/model/Block",
    "xblox/model/Contains",
    'xide/utils',
    'xide/types',
    'dojo/Deferred',
    'xblox/types/Types'/*NMD:Ignore*/,
    'xide/lodash'
], function (dcl, Block, Contains, utils, types, Deferred, BTypes,_) {
    var debug = false;
    /**
     * The command model. A 'command' consists out of a few parameters and a series of
     *  XCF - Command - Block expressions. Those expressions need to be evaluated before send them to the device
     * @class module:xcf/model/Command
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return dcl([Block, Contains], {
        declaredClass: "xcf.model.Command",
        /**
         *  3.12.10.3. The Startup checkbox indicates whether or not the associated command
         *  should be automatically sent at startup once communications have been established
         *  with the device.
         * @type {Boolean}
         */
        startup: false,
        /**
         * 3.12.10.3. The Auto field is used to set a time interval at which the command is
         * automatically continually sent when necessary for applications such as polling.
         * @type {Boolean}
         */
        auto: null,
        /**
         * 3.12.10.3. Send field containing the actual string or hexadecimal sequence used to communicate with the device.
         * @type {String}
         */
        send: '',
        /**
         * Name of the block
         * @type {String}
         */
        name: 'No Title',
        observed: [
            'send'
        ],
        interval: 0,
        flags: 0x00000800,
        _runningDfd: null,
        __started: false,
        isCommand: true,
        getItems: function (outletType) {
            return this.getItemsByType(outletType);
        },
        /**
         * onCommandFinish will be excecuted which a driver did run a command
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandFinish: function (msg) {
            var result = {};
            var dfd = null;
            if (msg.params && msg.params.id) {
                var id = msg.params.id;
                dfd = this.getDeferred(id);
                delete this._solving[id];
                msg.lastResponse && this.storeResult(msg.lastResponse);
                this._emit('finished', {
                    msg: msg,
                    result: this._lastResult
                });
            }
            var items = this.getItems(types.BLOCK_OUTLET.FINISH);
            if (items.length) {
                this.runFrom(items, 0, this._lastSettings);
            }
            this.resolve(result);
            this.onSuccess(this, this._lastSettings);
            if (dfd) {
                dfd.resolve(this._lastResult);
            }
            return this._lastResult;
        },
        /**
         * onCommandPaused
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandPaused: function (msg) {
            var params = msg.params;
            if (params && params.id) {
                msg.lastResponse && this.storeResult(msg.lastResponse);
                this._emit('paused', {
                    msg: msg,
                    result: this._lastResult,
                    id: params.id
                });
            }
            var items = this.getItems(types.BLOCK_OUTLET.PAUSED);
            if (items.length) {
                this.runFrom(items, 0, this._lastSettings);
            }
        },
        /**
         * onCommandPaused
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandStopped: function (msg) {
            this.reset();
            var params = msg.params;
            if (params && params.id) {
                this._emit('stopped', {
                    msg: msg,
                    result: this._lastResult,
                    id: params.id
                });
            }
            var items = this.getItems(types.BLOCK_OUTLET.STOPPED);
            if (items.length) {
                this.runFrom(items, 0, this._lastSettings);
            }
        },
        /**
         * onCommandFinish will be excecuted which a driver did run a command
         * @param msg {object}
         * @param msg.id {string} the command job id
         * @param msg.src {string} the source id, which is this block id
         * @param msg.cmd {string} the command string being sent
         */
        onCommandProgress: function (msg) {
            var params = msg.params;
            if (params && params.id) {
                msg.lastResponse && this.storeResult(msg.lastResponse);
                this._emit('progress', {
                    msg: msg,
                    result: this._lastResult,
                    id: params.id
                });
            }
            var items = this.getItems(types.BLOCK_OUTLET.PROGRESS);
            if (items.length) {
                this.runFrom(items, 0, this._lastSettings);
            }
        },
        storeResult: function (lastResponse) {
            var data = utils.getJson(lastResponse);
            var result = null;
            if (data && data.result && _.isString(data.result)) {
                var str = data.result;
                var isJSON = str.indexOf('{') !== -1 || str.indexOf('[') !== -1;
                var lastResult = str;
                if (isJSON) {
                    var tmp = utils.getJson(str, true, false);
                    if (tmp) {
                        lastResult = tmp;
                    }
                }
                if (lastResult !== null) {
                    this._lastResult = result = lastResult;
                } else {
                    this._lastResult = null;
                }
            }
            return result;
        },
        resolve: function (data) {
            data = data || this._lastResult;
            if (this._runningDfd) {
                this._runningDfd.resolve(data);
            }
        },
        onCommandError: function (msg) {
            var params = msg.params;
            if (params.id) {
                msg.lastResponse && this.storeResult(msg.lastResponse);
                this._emit('cmd:' + msg.cmd + '_' + params.id, msg);
                this._emit('error', {
                    msg: msg,
                    result: this._lastResult,
                    id: params.id
                });
            }
            this.onFailed(this, this._settings);
            var items = this.getItems(types.BLOCK_OUTLET.ERROR);
            if (items.length) {
                this.runFrom(items, 0, this._lastSettings);
            }
        },
        sendToDevice: function (msg, settings, stop, pause, id) {
            if(this._destroyed){
                return;
            }
            msg = this.replaceAll("'", '', msg);
            id = id || utils.createUUID();
            var self = this;
            var wait = (this.flags & types.CIFLAG.WAIT) ? true : false;
            this.lastCommand = '' + msg;
            if (!this.scope.instance) {
                debug && console.warn('have no device!');
                this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                    text: 'Command ' + this.name + ' : have no device',
                    type: 'error',
                    delay: 1000
                });
                return false;
            } else {
                if (wait) {
                    this._on('cmd:' + msg + '_' + id, function (msg) {
                        if (msg.error) {
                            self.onFailed(self, settings);
                        } else {
                            self.onSuccess(self, settings);
                        }
                    });
                }
                this.scope.instance.sendMessage(msg, null, this.id, id, wait, stop, pause,this.getSendOptions());
            }
            return id;
        },
        reset: function () {
            delete this._runningDfd;
            this._lastSettings = {};
            if(this._loop){
                clearTimeout(this._loop);
                this._loop = null;
            }
            delete this.override;this.override=null;
            delete this._lastResult;this.override = null;
            this.override = {};
        },
        _solving: null,
        addDeferred: function (id) {
            if (!this._solving) {
                this._solving = {};
            }
            this._solving[id] = new Deferred();
            return this._solving[id];
        },
        getDeferred: function (id) {
            if (!this._solving) {
                this._solving = {};
            }
            return this._solving[id];
        },
        getSendOptions:function(){
            var result = {};
            var DriverModule = this.getDriverModule();
            if (DriverModule && DriverModule.getCommandArgs) {
                result = DriverModule.getCommandArgs(this) || result;
            }
            return result;
        },
        _resolve: function (string, settings,useDriverModule) {
            if(_.isNumber(string) || _.isBoolean(string)){
                return string;
            }
            var scope = this.scope;
            var value = string || this._get('send');
            settings = settings || {};
            var flags = settings.flags || this.flags;
            var parse = !(flags & types.CIFLAG.DONT_PARSE);
            var isExpression = (flags & types.CIFLAG.EXPRESSION);
            if (flags & types.CIFLAG.TO_HEX) {
                value = utils.to_hex(value);
            }

            if (parse !== false) {
                value = utils.convertAllEscapes(value, "none");
            }

            settings = settings || this._lastSettings || {};
            var override = settings.override || this.override || {};
            var _overrides = (override && override.variables) ? override.variables : null;
            if (_overrides) {
                for (var prop in _overrides) {
                    if (_.isNumber(_overrides[prop])) {
                        _overrides[prop] = Math.round(_overrides[prop]);
                    }
                }
            }
            var res = "";
            var DriverModule = this.getDriverModule();
            if (DriverModule && DriverModule.resolveBefore && useDriverModule!==false) {
                value = DriverModule.resolveBefore(this, value) || value;
            }
            if (isExpression && parse !== false) {
                res = scope.parseExpression(value, null, _overrides, null, null, null, override.args);
            } else {
                res = '' + value;
            }
            if (DriverModule && DriverModule.resolveAfter && useDriverModule!==false) {
                res = DriverModule.resolveAfter(this, res) || res;
            }
            return res;
        },
        /**
         *
         * @param scope
         * @param settings
         * @param isInterface
         * @param send
         * @returns {*}
         */
        solve: function (scope, settings, isInterface, send) {
            var dfd = null;
            scope = scope || this.scope;
            settings = this._lastSettings = settings || this._lastSettings || {};
            if (settings && settings.override && settings.override.mixin) {
                utils.mixin(this.override, settings.override.mixin);
            }
            var value = send || this._get('send') || this.send;
            var parse = !(this.flags & types.CIFLAG.DONT_PARSE);
            var wait = (this.flags & types.CIFLAG.WAIT) ? true : false;
            var id = utils.createUUID();

            if (this.flags & types.CIFLAG.TO_HEX) {
                value = utils.to_hex(value);
            }

            if (parse !== false) {
                value = utils.convertAllEscapes(value, "none");
            }

            if (!this.enabled && isInterface !== true) {
                this.reset();
                return;
            }

            //we're already running
            if (isInterface === true && this._loop) {
                this.reset();
            }
            if (wait !== true) {
                this.onRun(this, settings);
            } else {
                this.onRun(this, settings, {
                    timeout: false
                });
                dfd = this.addDeferred(id);
            }
            if (this.items && this.items.length > 0) {
                if (value && value.length > 0) {
                    var res = this._resolve(this.send, settings);
                    if (res && res.length > 0) {
                        if (!this.sendToDevice(res, settings)) {
                            this.onFailed(this, settings);
                        } else {
                            this.onSuccess(this, settings);
                        }
                    }
                }
                if (wait) {
                    return dfd;
                }
                var ret = [];
                for (var n = 0; n < this.items.length; n++) {
                    var block = this.items[n];
                    if (block.enabled) {
                        ret.push(block.solve(scope, settings));
                    }
                }
                return ret;
            } else if (value.length > 0) {
                var res = this._resolve(this.send, settings);
                if (res && res.length > 0) {
                    if (!this.sendToDevice(res, settings, null, null, id)) {
                        this.onFailed(this, settings);
                    }
                }
                if (wait !== true) {
                    this.onSuccess(this, settings);

                } else {
                    this._settings = settings;
                }
                if (isInterface) {
                    if (this.auto && this.getInterval() > 0) {
                        this.scope.loopBlock(this, settings);
                    }
                }
                return !wait ? [res] : dfd;
            }
            return false;
        },
        canAdd: function () {
            return [];
        },
        /**
         * Store function override
         * @returns {boolean}
         */
        mayHaveChildren: function () {
            return this.items != null && this.items.length > 0;
        },

        /**
         * Store function override
         * @returns {Array}
         */
        getChildren: function () {
            return this.items;
        },
        hasInlineEdits: true,
        toText: function (icon, label, detail, breakDetail) {
            var out = "";
            if (icon !== false) {
                out += "<span class='text-primary inline-icon'>" + this.getBlockIcon() + "</span>";
            }
            label !== false && (out += "" + this.makeEditable('name', 'bottom', 'text', 'Enter a unique name', 'inline') + "");
            breakDetail === true && (out += "<br/>");
            detail !== false && (out += ("<span class='text-muted small'> Send:<kbd class='text-warning'>" + this.makeEditable('send', 'bottom', 'text', 'Enter the string to send', 'inline')) + "</kbd></span>");
            if (icon !== false) {
                this.startup && (out += this.getIcon('fa-bell inline-icon text-warning', 'text-align:right;float:right;', ''));
                this.auto && this.getInterval() > 0 && (out += this.getIcon('fa-clock-o inline-icon text-warning', 'text-align:right;float:right', ''));
            }
            out = this.getDriverToText(out) || out;
            return out;
        },
        getInterval: function () {
            return parseInt(this.interval,10);
        },
        start: function () {
            if (this.startup && !this.auto) {
                this.solve(this.scope);
            } else if (this.auto && this.getInterval() > 0) {
                this.scope.loopBlock(this);
            }
        },
        /**
         * Return the driver's code module
         * @returns {module:xcf/driver/DriverBase|null}
         */
        getDriverModule: function () {
            var DriverModule = null;
            var instance = this.getInstance();
            if (instance) {
                DriverModule = instance.Module;
            } else {
                var driver = this.getScope().driver;
                if (driver && driver.Module) {
                    DriverModule = driver.Module;
                }
            }
            return DriverModule;
        },
        getDriverToText:function(text){
            var DriverModule = this.getDriverModule();
            if(DriverModule && DriverModule.toText){
                return DriverModule.toText(this,text);
            }
        },
        getDriverFields: function (fields) {
            var DriverModule = this.getDriverModule();
            var result = [];
            if (DriverModule && DriverModule.getFields) {
                result = DriverModule.getFields(this, fields) || [];
            }
            return result;
        },
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            var thiz = this;
            fields.push(this.utils.createCI('name', 13, this.name, {
                group: 'General',
                title: 'Name',
                dst: 'name',
                order: 200
            }));
            fields.push(this.utils.createCI('startup', 0, this.startup, {
                group: 'General',
                title: 'Send on Startup',
                dst: 'startup',
                order: 199
            }));
            fields.push(this.utils.createCI('auto', 0, this.auto, {
                group: 'General',
                title: 'Auto Send',
                dst: 'auto',
                order: 198
            }));
            fields.push(this.utils.createCI('interval', 13, this.interval, {
                group: 'General',
                title: 'Interval',
                dst: 'interval',
                order: 197
            }));
            fields.push(this.utils.createCI('send', types.ECIType.EXPRESSION_EDITOR, this.send, {
                group: 'Send',
                title: 'Send',
                dst: 'send',
                widget: {
                    instantChanges: false,
                    allowACECache: true,
                    showBrowser: false,
                    showSaveButton: true,
                    style: 'height:inherit;',
                    editorOptions: {
                        showGutter: false,
                        autoFocus: false
                    },
                    aceOptions: {
                        hasEmmet: false,
                        hasLinking: false,
                        hasMultiDocs: false
                    },
                    item: this
                },
                delegate: {
                    runExpression: function (val, run, error) {
                        return thiz.scope.expressionModel.parse(thiz.scope, val, false, run, error);
                    }
                }
            }));
            fields.push(this.utils.createCI('flags', 5, this.flags, {
                group: 'General',
                title: 'Flags',
                dst: 'flags',
                data: [
                    {
                        value: 0x000001000,
                        label: 'Dont parse',
                        title: "Do not parse the string and use it as is"
                    },
                    {
                        value: 0x00000800,//2048
                        label: 'Expression',
                        title: 'Parse it as Javascript'
                    },
                    {
                        value: 0x000008000,
                        label: 'Wait',
                        title: "Wait for response"
                    }
                ],
                widget: {
                    hex: true
                }
            }));
            fields = fields.concat(this.getDriverFields(fields));
            return fields;
        },
        icon: 'fa-exclamation',
        getIconClass: function () {
            return 'el-icon-play-circle';
        },
        getBlockIcon: function () {
            return '<span class="' + this.icon + '"></span> ';
        },
        canEdit: function () {
            return true;
        },
        onChangeField: function (field, newValue, cis) {
            var interval = this.getInterval();
            if (field == 'auto') {
                if (newValue === true) {
                    interval > 0 && this.scope.loopBlock(this);
                } else {
                    if (this._loop) {
                        this.reset();
                    }
                }
            }
            if (field == 'enabled') {
                if (newValue === false) {
                    this.reset();
                } else {
                    if (interval) {
                        this.scope.loopBlock(this);
                    }
                }
            }
            if (field == 'interval') {
                if (interval > 0 && this.auto) {
                    this.scope.loopBlock(this);
                } else {
                    this.reset();
                }
            }
            this.inherited(arguments);
        },
        destroy: function () {
            this.reset();
        },
        pause: function () {
            var last = this.lastCommand || this._resolve(this.send, this._lastSettings);
            if (last!==null) {
                this.sendToDevice(last, this._lastSettings, false, true);
            }
        },
        stop: function (isDestroy) {
            if(isDestroy ===true){
                return;
            }
            this.onSuccess(this, {
                highlight: true
            });
            this.resolve('');
            var last = this.lastCommand || this._resolve(this.send, this._lastSettings);
            if (!_.isEmpty(last)) {
                this.sendToDevice(last, this._lastSettings, true, false);
            }
            delete this._runningDfd;
        }
    });
});;
/** @module xblox/types **/
define('xblox/types/Types',[
    'xide/types/Types',
    'xide/utils'
], function (types, utils) {

    /**
     * The block's capabilities. This will be evaluated in the interface but also
     * by the run-time (speed ups).
     *
     * @enum {integer} module:xide/types/BLOCK_CAPABILITIES
     * @memberOf module:xide/types
     */
    var BLOCK_CAPABILITIES = {
        /**
         * No other block includes this one.
         * @constant
         * @type int
         */
        TOPMOST: 0x00004000,
        /**
         * The block's execution context can be changed to another object.
         * @constant
         * @type int
         */
        TARGET: 0x00040000,
        /**
         * The block may create additional input terminals ('reset', 'pause', ...).
         * @constant
         * @type int
         */
        VARIABLE_INPUTS: 0x00000080,
        /**
         * The block may create additional output terminals ('onFinish', 'onError').
         * @constant
         * @type int
         */
        VARIABLE_OUTPUTS: 0x00000100,
        /**
         * The block may create additional ouput parameters ('result', 'error',...).
         * @constant
         * @type int
         */
        VARIABLE_OUTPUT_PARAMETERS: 0x00000200,
        /**
         * The block may create additional input parameters.
         * @constant
         * @type int
         */
        VARIABLE_INPUT_PARAMETERS: 0x00000400,
        /**
         * The block can contain child blocks.
         * @constant
         * @type int
         */
        CHILDREN: 0x00000020,
        /**
         * Block provides standard signals ('paused', 'error').
         * @constant
         * @type int
         */
        SIGNALS: 0x00000080
    }
    /**
     * Flags to describe a block's execution behavior.
     *
     * @enum {integer} module:xide/types/RUN_FLAGS
     * @memberOf module:xide/types
     */
    var RUN_FLAGS = {
        /**
         * The block can execute child blocks.
         * @constant
         * @type int
         */
        CHILDREN: 0x00000020,
        /**
         * Block is waiting for a message => EXECUTION_STATE::RUNNING
         * @constant
         * @type int
         */
        WAIT: 0x000008000
    };

    /**
     * Flags to describe a block's execution state.
     *
     * @enum {integer} module:xide/types/EXECUTION_STATE
     * @memberOf module:xide/types
     */
    var EXECUTION_STATE = {
        /**
         * The block is doing nothing and also has done nothing. The is the default state
         * @constant
         * @type int
         */
        NONE:0x00000000,
        /**
         * The block is running.
         * @constant
         * @type int
         */
        RUNNING: 0x00000001,
        /**
         * The block is an error state.
         * @constant
         * @type int
         */
        ERROR: 0x00000002,
        /**
         * The block is in an paused state.
         * @constant
         * @type int
         */
        PAUSED: 0x00000004,
        /**
         * The block is an finished state, ready to be cleared to "NONE" at the next frame.
         * @constant
         * @type int
         */
        FINISH: 0x00000008,
        /**
         * The block is an stopped state, ready to be cleared to "NONE" at the next frame.
         * @constant
         * @type int
         */
        STOPPED: 0x00000010,
        /**
         * The block has been launched once...
         * @constant
         * @type int
         */
        ONCE: 0x80000000,
        /**
         * Block will be reseted next frame
         * @constant
         * @type int
         */
        RESET_NEXT_FRAME: 0x00800000,
        /**
         * Block is locked and so no further inputs can be activated.
         * @constant
         * @type int
         */
        LOCKED: 0x20000000	// Block is locked for utilisation in xblox
    }

    types.BLOCK_MODE = {
        NORMAL: 0,
        UPDATE_WIDGET_PROPERTY: 1
    };

    /**
     * Flags to describe a block's belonging to a standard signal.
     * @enum {integer} module:xblox/types/BLOCK_OUTLET
     * @memberOf module:xblox/types
     */
    types.BLOCK_OUTLET = {
        NONE: 0x00000000,
        PROGRESS: 0x00000001,
        ERROR: 0x00000002,
        PAUSED: 0x00000004,
        FINISH: 0x00000008,
        STOPPED: 0x00000010
    };

    utils.mixin(types.EVENTS, {
        ON_RUN_BLOCK: 'onRunBlock',
        ON_RUN_BLOCK_FAILED: 'onRunBlockFailed',
        ON_RUN_BLOCK_SUCCESS: 'onRunBlockSuccess',
        ON_BLOCK_SELECTED: 'onItemSelected',
        ON_BLOCK_UNSELECTED: 'onBlockUnSelected',
        ON_BLOCK_EXPRESSION_FAILED: 'onExpressionFailed',
        ON_BUILD_BLOCK_INFO_LIST: 'onBuildBlockInfoList',
        ON_BUILD_BLOCK_INFO_LIST_END: 'onBuildBlockInfoListEnd',
        ON_BLOCK_PROPERTY_CHANGED: 'onBlockPropertyChanged',
        ON_SCOPE_CREATED: 'onScopeCreated',
        ON_VARIABLE_CHANGED: 'onVariableChanged',
        ON_CREATE_VARIABLE_CI: 'onCreateVariableCI'
    });


    types.BlockType = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };
    types.BLOCK_CAPABILITIES = BLOCK_CAPABILITIES;
    types.EXECUTION_STATE = EXECUTION_STATE;
    types.RUN_FLAGS = RUN_FLAGS;


    return types;
});;
define('xcf/types/Types',[
    'xaction/types',
    'xide/types/Types',
    'xide/types',
    'xide/utils/ObjectUtils',
    'xide/utils',
    'xide/utils/HexUtils'
], function (aTypes,cTypes,types,ObjectUtils,utils,HexUtils) {
    
    if(!String.prototype.setBytes) {
        String.prototype.setBytes = function (bytes) {
            this.bytes = bytes;
        };
    }
    if(!String.prototype.getBytes){
        String.prototype.getBytes = function() {
            if(this.bytes){
                return this.bytes;
            }else{
                return HexUtils.stringToBuffer(this);
            }
        };
    }
    if (!String.prototype.getString) {
        String.prototype.getString = function () {
            return this.string;
        };
    }
    if (!String.prototype.setString) {
        String.prototype.setString = function (string) {
            this.string = string;
        };
    }

    if(!String.prototype.hexString){
        String.prototype.hexString= function() {
            var bytes = this.getBytes();
            return HexUtils.bufferToHexString(bytes);
        };
    }

    /**
     * Variable Flags
     *
     * @enum {int} VARIABLE_FLAGS
     * @global
     */
    types.VARIABLE_FLAGS = {
        PUBLISH:0x00000002,
        PUBLISH_IF_SERVER:0x00000004
    };
    /**
     * Flags to define logging outputs per device or view
     *
     * @enum {int} LOGGING_FLAGS
     * @global
     */
    types.LOGGING_FLAGS = {
        /**
         * No logging
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Log in the IDE's global console
         * @constant
         * @type int
         */
        GLOBAL_CONSOLE: 0x00000001,
        /**
         * Log in the IDE's status bar
         * @constant
         * @type int
         */
        STATUS_BAR: 0x00000002,
        /**
         * Create notification popup in the IDE
         * @constant
         * @type int
         */
        POPUP: 0x00000004,
        /**
         * Log to file
         * @constant
         * @type int
         */
        FILE: 0x00000008,
        /**
         * Log into the IDE's dev tool's console
         * @constant
         * @type int
         */
        DEV_CONSOLE: 0x00000010,
        /**
         * Log into the device's IDE console
         * @constant
         * @type int
         */
        DEVICE_CONSOLE: 0x00000020
    };

    /**
     * Help struct for jsDoc
     * @typedef {object} module:xide/types~DeviceInfo
     * @type Object
     * @property {string} host The IP address
     * @property {string} port The port
     * @property {string} scope The scope of the device
     * @property {string} driverId The id of the driver
     * @property {string} protocol The protocol, ie: tcp, serial,..
     * @property {string} devicePath The absolute path to the device's meta file
     * @property {string} id The device model id
     * @property {string} title The title of the device
     * @property {string} source Additional field to carry a source. That might be 'ide' or 'server'.
     * @property {string} deviceScope Field to store the device's scope: user_devices or system_devices
     * @property {string} driverScope Field to store the device's driver scope: user_drivers or system_drivers
     * @property {string} user_devices Absolute path to the user's devices
     * @property {string} system_devices Absolute path to the system devices
     * @property {string} user_drivers Absolute path to the user's drivers
     * @property {string} system_drivers Absolute path to the drivers drivers
     * @property {string} loggingFlags Absolute path to the user's drivers
     * @property {int} serverSide The device's driver runs server side if 1, otherwise 0
     * @property {string} hash A hash for client side. Its build of MD5(host,port,protocol,driverId,driverScope,id,devicePath,deviceScope,source,user_devices,system_devices,system_drivers,user_drivers)
     * @property {DRIVER_FLAGS} driverOptions The driver flags
     * @property {LOGGING_FLAGS} loggingFlags The device's logging flags
     * @property {object} responseSettings Contains the constants for receiving data from a device its being set at initialization time and has this structure:
     * @property {boolean} responseSettings.start 
     */
    
    
    utils.mixin(types.ITEM_TYPE, {
        DEVICE: 'Device',
        DEVICE_GROUP: 'Device Group',
        DRIVER: 'Driver',
        DRIVER_GROUP: 'Driver Group',
        PROTOCOL: 'Protocol',
        PROTOCOL_GROUP: 'Protocol Group'
    });
    
    /**
     * Possible Node-JS service status modes.
     *
     * @constant {Integer.<module:xide/types~SERVICE_STATUS>}
     *     module:xide/types~SERVICE_STATUS
     */
    types.SERVICE_STATUS = {
        OFFLINE: "offline",
        ONLINE: "online",
        TIMEOUT: "timeout"
    };

    /**
     * @enum {string} CONNECTION_PROTOCOL
     * @global
     */
    types.PROTOCOL = {
        TCP: 'tcp',
        UDP: 'udp',
        SERIAL: 'serial',
        DRIVER: 'driver',
        SSH: 'ssh',
        MQTT: 'mqtt'
    };
    /**
     * Additional event keys
     * @enum {string} module:xcf/types/EVENTS
     * @extends module:xide/types/EVENTS
     */
    var Events = {
        ON_DEBUGGER_READY: 'onDebuggerReady',
        ON_DEVICE_SELECTED: 'onDeviceSelected',
        ON_DEVICE_GROUP_SELECTED: 'onDeviceGroupSelected',
        ON_PROTOCOL_SELECTED: 'onProtocolSelected',
        ON_PROTOCOL_GROUP_SELECTED: 'onProtocolGroupSelected',
        ON_PROTOCOL_CHANGED:'onProtocolChanged',
        ON_MQTT_MESSAGE:'onMQTTMessage',
        ON_DEVICE_MESSAGE: 'onDeviceMessage',
        ON_DEVICE_MESSAGE_EXT: 'onDeviceMessageExt',
        ON_COMMAND_FINISH:'onCommandFinish',
        ON_COMMAND_PROGRESS:'onCommandProgress',
        ON_COMMAND_PAUSED:'onCommandPaused',
        ON_COMMAND_STOPPED:'onCommandStopped',
        ON_COMMAND_ERROR:'onCommandError',
        ON_DEVICE_DISCONNECTED: 'onDeviceDisconnected',
        ON_DEVICE_CONNECTED:'onDeviceConnected',
        ON_DEVICE_COMMAND: 'onDeviceCommand',
        ON_DEVICE_STATE_CHANGED: 'onDeviceStateChanged',
        ON_DEVICE_DRIVER_INSTANCE_READY: 'onDeviceDriveInstanceReady',
        ON_DRIVER_SELECTED: 'onDriverSelected',
        ON_DRIVER_GROUP_SELECTED: 'onDriverGroupSelected',
        ON_DRIVER_VARIABLE_ADDED: 'onDriverVariableAdded',
        ON_DRIVER_VARIABLE_REMOVED: 'onDriverVariableRemoved',
        ON_DRIVER_VARIABLE_CHANGED: 'onDriverVariableChanged',
        ON_DRIVER_COMMAND_ADDED: 'onDriverCommandAdded',
        ON_DRIVER_COMMAND_REMOVED: 'onDriverCommandRemoved',
        ON_DRIVER_COMMAND_CHANGE: 'onDriverVariableChanged',
        ON_SCOPE_CREATED: 'onScopeCreated',
        ON_DRIVER_MODIFIED:'onDriverModified',
        SET_DEVICE_VARIABLES:'setDeviceVariables',
        ON_SERVER_LOG_MESSAGE: 'onServerLogMessage',
        ON_CLIENT_LOG_MESSAGE: 'onClientLogMessage',
        ON_DEVICE_SERVER_CONNECTED:'onDeviceServerConnected',
        ON_RUN_CLASS_EVENT: 'onRunClassEvent'
    };
    
    utils.mixin(types.EVENTS,Events);

    /**
     * Enumeration to define a source type for variable change.
     * @enum module:xide/types/MESSAGE_SOURCE
     * @memberOf module:xide/types
     */
    types.MESSAGE_SOURCE = {
        DEVICE: 'DEVICE',
        GUI: 'GUI',
        BLOX: 'BLOX',
        CODE: 'CODE'
    };

    /**
     *
     * the device state
     * typedef {Object} xide.types~STATE
     *-@memberOf module:xide/types
     * -property {Number|String} [x] - X coordinate of the rectangle. Can be a pixel position, or a string with a 'px' or '%' suffix.
     */


    /**
     * Enumeration to define a device's status
     * @enum {String} module:xide/types/DEVICE_STATE
     * @memberOf module:xide/types
     */
    types.DEVICE_STATE = {
        CONNECTING: 'DeviceIsConnecting',
        CONNECTED: 'DeviceIsConnected',
        SYNCHRONIZING: 'DeviceIsSynchronizing',
        READY: 'DeviceIsReady',
        DISCONNECTED: 'DeviceIsDisconnected',
        DISABLED: 'DeviceIsDisabled',
        LOST_DEVICE_SERVER:'LostDeviceServerConnection'
    };

    /**
     * Keys to define a driver meta property
     * @enum module:xide/types/DRIVER_PROPERTY
     * @memberOf module:xide/types
     */
    types.DRIVER_PROPERTY = {
        CF_DRIVER_NAME: 'CF_DRIVER_NAME',
        CF_DRIVER_ICON: 'CF_DRIVER_ICON',
        CF_DRIVER_CLASS: 'CF_DRIVER_CLASS',
        CF_DRIVER_ID: 'CF_DRIVER_ID',
        CF_DRIVER_COMMANDS: 'CF_DRIVER_COMMANDS',
        CF_DRIVER_VARIABLES: 'CF_DRIVER_VARIABLES',
        CF_DRIVER_RESPONSES: 'CF_DRIVER_RESPONSES'
    };

    /**
     * Keys to define protocol meta properties
     * @enum module:xide/types/PROTOCOL_PROPERTY
     * @memberOf module:xide/types
     */
    types.PROTOCOL_PROPERTY ={
        CF_PROTOCOL_TITLE: 'Title',
        CF_PROTOCOL_ICON: 'CF_PROTOCOL_ICON',
        CF_PROTOCOL_CLASS: 'CF_PROTOCOL_CLASS',
        CF_PROTOCOL_ID: 'CF_PROTOCOL_ID',
        CF_PROTOCOL_COMMANDS: 'CF_PROTOCOL_COMMANDS',
        CF_PROTOCOL_VARIABLES: 'CF_PROTOCOL_VARIABLES',
        CF_PROTOCOL_RESPONSES: 'CF_PROTOCOL_RESPONSES'
    };

    /**
     * Keys to define protocol meta properties
     * @enum module:xide/types/DEVICE_PROPERTY
     * @memberOf module:xide/types
     */
    types.DEVICE_PROPERTY = {
        CF_DEVICE_DRIVER: 'Driver',
        CF_DEVICE_HOST: 'Host',
        CF_DEVICE_PORT: 'Port',
        CF_DEVICE_PROTOCOL: 'Protocol',
        CF_DEVICE_TITLE: 'Title',
        CF_DEVICE_ID: 'Id',
        CF_DEVICE_ENABLED: 'Enabled',
        CF_DEVICE_OPTIONS: 'Options',
        CF_DEVICE_DRIVER_OPTIONS: 'DriverOptions',
        CF_DEVICE_LOGGING_FLAGS: 'Logging Flags'
    };


    /**
     * @enum {int} DEVICE_LOGGING_SOURCE
     * @global
     */
    types.LOG_OUTPUT = {        
        DEVICE_CONNECTED:'Device Connected',
        DEVICE_DISCONNECTED:'Device Disonnected',
        RESPONSE:'Response',
        SEND_COMMAND:'Send Command',
        DEVICE_ERROR:'Device Error'       
    };

    /**
     * @enum {int} DEFAULT_DEVICE_LOGGING_FLAGS
     * @global
     */
    types.DEFAULT_DEVICE_LOGGING_FLAGS = {};

    var LOGGING_FLAGS = types.LOGGING_FLAGS;
    
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_CONNECTED]  = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP |  LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEVICE_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_DISCONNECTED]  = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP |  LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEVICE_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.RESPONSE] = LOGGING_FLAGS.DEVICE_CONSOLE | LOGGING_FLAGS.GLOBAL_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.SEND_COMMAND] = LOGGING_FLAGS.DEVICE_CONSOLE | LOGGING_FLAGS.GLOBAL_CONSOLE;
    types.DEFAULT_DEVICE_LOGGING_FLAGS[types.LOG_OUTPUT.DEVICE_ERROR] = LOGGING_FLAGS.GLOBAL_CONSOLE | LOGGING_FLAGS.POPUP | LOGGING_FLAGS.STATUS_BAR | LOGGING_FLAGS.DEV_CONSOLE | LOGGING_FLAGS.DEVICE_CONSOLE;

    /**
     * Bitmask or flags for device about its driver
     * @enum {int} DRIVER_FLAGS
     * @global
     */
    types.DRIVER_FLAGS = {
        /**
         * Mark the driver for "server side"
         */
        RUNS_ON_SERVER: 2,
        /**
         * Enable protocol's debug message on console
         */
        DEBUG: 4,
        /**
         * Enable protocol's debug message on console
         */
        SERVER: 16
    };


    var ITEM_TYPES = {
        /**
         *
         * @extends module:xide/types~ITEM_TYPE
         */
        CF_DRIVER_VARIABLE: 'DriverVariable',
        CF_DRIVER_BASIC_COMMAND: 'DriverBasicCommand',
        CF_DRIVER_CONDITIONAL_COMMAND: 'DriverConditionalCommand',
        CF_DRIVER_RESPONSE_VARIABLE: 'DriverResponseVariable'
    };

    utils.mixin(types.ITEM_TYPE,ITEM_TYPES);

    types.BLOCK_GROUPS =
    {
        CF_DRIVER_VARIABLE: 'DriverVariable',
        CF_DRIVER_BASIC_COMMAND: 'DriverBasicCommand',
        CF_DRIVER_CONDITIONAL_COMMAND: 'DriverConditionalCommand',
        CF_DRIVER_RESPONSE_VARIABLE: 'DriverResponseVariable',
        CF_DRIVER_RESPONSE_BLOCKS: 'conditionalProcess',
        CF_DRIVER_RESPONSE_VARIABLES: 'processVariables',
        CF_DRIVER_BASIC_VARIABLES: 'basicVariables'
    };

    types.COMMAND_TYPES =
    {
        BASIC_COMMAND: 'basic',
        CONDITIONAL_COMMAND: 'conditional',
        INIT_COMMAND: 'init'
    };


    /**
     * Mixin new Core types
     */
    utils.mixin(types.ECIType, {
        DEVICE_NETWORK_SETTINGS: types.ECIType.END + 1,
        DRIVER_COMMAND_SETTINGS: 'CommandSettings'
    });

    types.VFS_ROOTS = {

        SYSTEM_DRIVERS: 'system_drivers',
        USER_DRIVERS: 'user_drivers'
    };

    /**
     * Device Server Socket Commands
     * @enum {string} SERVER_COMMAND
     * @global SERVER_COMMAND
     */
    types.SOCKET_SERVER_COMMANDS =
    {
        SIGNAL_MANAGER: 'Manager_command',
        RUN_FILE: 'Run_File',
        RUN_CLASS: 'Run_Class',
        RUN_APP_SERVER_CLASS: 'Run_App_Server_Class',
        SIGNAL_DEVICE: 'Device_command',
        SIGNAL_RESPONSE: 'WebSocket_response',
        MANAGER_TEST: 'Manager_Test',
        MANAGER_CLOSE_ALL: 'Close_All_Connections',
        MANAGER_STATUS: 'status',
        MANAGER_START_DRIVER: 'startDriver',
        START_DEVICE: 'startDevice',
        STOP_DEVICE: 'stopDevice',
        CREATE_CONNECTION: 'createConnection',
        MANAGER_STOP_DRIVER: 'stopDriver',
        DEVICE_SEND: 'Device_Send',
        CALL_METHOD: 'Call_Method',
        RUN_SHELL: 'Run_Shell',
        WATCH: 'Watch_Directory',
        MQTT_PUBLISH:'MQTT_PUBLISH',
        MQTT_SUBSCRIBE:'MQTT_SUBSCRIBE',
        GET_DEVICE_VARIABLES: 'getVariables',
        WRITE_LOG_MESSAGE:'Write_Log_Message',
        INIT_DEVICES:'INIT_DEVICES',
        PROTOCOL_METHOD:'PROTOCOL_METHOD'
    };
    return types;
});
;
define('xcf/types',[
    'dojo/_base/declare'
],function(declare){
    return declare("xcf.types", null,{});
});

;
define('xwire/main',[
    "xwire/Binding",
    "xwire/Source",
    "xwire/Target",
    "xwire/WidgetSource",
    "xwire/WidgetTarget",
    "xwire/EventSource",
    "xwire/DeviceTarget"
], function(){});;
define('xwire/DeviceTarget',[
    'dcl/dcl',
    'xide/types',
    'xwire/Target'
],function(dcl,types,Target){
    /**
     * Widget based binding target
     */
    return dcl(Target,{
        declaredClass:"xwire.DeviceTarget",
        /***
         * An optional variable to set before calling a command
         */
        variable:null,
        /**
         * The command to call (uses this.object(Block)) {String}
         */
        command:null,
        /**
         * Run the action
         */
        run:function(data){
            this.inherited(arguments);
            if(this.object){
                if(this.variable){
                    this.object.setVariable(this.variable,data.value,false,false,types.MESSAGE_SOURCE.GUI);
                }
                if(this.command){
                    this.object.callCommand(this.command);
                }
            }
        }
    });
});;
define('xwire/EventSource',[
    'dcl/dcl',
    'xwire/Source',
    'xide/mixins/EventedMixin'
],function(dcl,Source,EventedMixin){
    /**
     * Event based binding source
     */
    return dcl([Source,EventedMixin.dcl],{
        declaredClass:"xwire.EventSource",
        /**
         * Trigger specifies the event name
         * {String|Array}
         */
        trigger:null,
        /**
         * Path to the value within the triggered event.
         * {String}
         */
        path:null,
        /**
         * An array of filters, specified by path and value :
         * {
         *      path:string,
         *      value:string (path value must match this)
         * }
         *
         */
        filters:null,

        _started:false,
        /**
         * _matches evaluates a number of filters on an object
         * @param object {Object}
         * @param filters {Array}
         * @returns {boolean}
         * @private
         */
        _matches:function(object,filters){
            for(var i =0 ; i<filters.length;i++){
                var value = this.getValue(object,filters[i].path);
                if(value!==filters[i].value){
                    return false;
                }
            }
            return true;
        },
        /**
         *
         * @param evt
         */
        onTriggered:function(evt){
            /**
             * Run event filters if specified
             */
            if(this.filters && !this._matches(evt,this.filters)){
                return;
            }
            if(this.path){

                var value = this.getValue(evt,this.path);
                /**
                 * forward to owner
                 */
                if(this.binding){
                    this.binding.trigger({
                        value:value,
                        source:this
                    })
                }
            }
        },
        /***
         * Start will subscribe to event specified in trigger
         */
        start:function(){
            if(this._started){
                return;
            }
            this.subscribe(this.trigger,this.onTriggered);

            this._started = true;
        }
    });
});;
/** @module xwire/WidgetTarget */
define('xwire/WidgetTarget',[
    'dcl/dcl',
    'xide/types',
    'xwire/Target',
    'xide/utils'
],function(dcl,types,Target,utils){
    /**
     * Widget based binding target
     * @class xwire/WidgetTarget
     */
    return dcl(Target,{
        declaredClass:"xwire.WidgetTarget",
        targetFilter:null,
        /**
         * type {module:xwire/Binding}
         */
        binding:null,
        /**
         * type {module:xblox/RunScript}
         */
        delegate:null,
        /**
         * Run the action
         */
        run:function(data){
            var thiz = this;
            var isDelite = thiz.object !==null && thiz.object.render!=null;
            var acceptFn = this.binding.accept ? this.binding.accept.getFunction() : null;
            var transformFn = this.binding.transform ? this.binding.transform.getFunction() : null;
            if(thiz.object){
                var value = data.value;
                if(this.targetFilter!=null && this.targetFilter.length && this.delegate && this.delegate.resolveFilter){
                    value = this.delegate.resolveFilter(this.targetFilter,value,this.object);
                }
                thiz.object.ignore=true;
                if(acceptFn){
                    var accept = acceptFn.apply(this.delegate,[value,this.binding.accept,this.delegate,,this.object]);
                    if(!accept){
                        return;
                    }
                }
                if(transformFn){
                    var _value = transformFn.apply(this.delegate,[value,this.binding.transform,this.delegate,this.object]);
                    if(_value!==null && _value!==undefined){
                        value = _value;
                    }
                }
                if(!isDelite && thiz.object.set) {
                    thiz.object.set(thiz.path, value);
                }else if(thiz.object._set){
                    thiz.object._set(thiz.path, value);
                    var _funcPath = "set" + utils.capitalize(thiz.path);
                    if(thiz.object[_funcPath]) {
                        thiz.object[_funcPath](value,data);
                    }
                }else{
                    thiz.object[thiz.path] = value;
                }
                thiz.object.ignore=false;
            }
        }
    });
});;
define('xwire/WidgetSource',[
    'dcl/dcl',
    'dojo/_base/kernel'
],function(dcl,Source,dojo){
    /**
     * Event based binding source
     */
    return dcl(Source,{
        declaredClass:"xwire.WidgetSource",
        /**
         * Trigger specifies the event name
         * {String|Array}
         */
        trigger:null,
        /**
         * Dijit widget instance
         */
        object:null,
        /**
         * Widget changed its value,
         * @param value
         */
        onTriggered:function(value){
            var thiz=this;
            //skip
            if(this.object && this.object.ignore===true){
                setTimeout(function(){
                    thiz.object.ignore=false;
                },500);
                return;
            }
            /**
             * forward to owner
             */
            if(this.binding){
                this.binding.trigger({
                    value:value,
                    source:this
                });
            }
        },
        /***
         * Start will subscribe to event specified in trigger
         */
        start:function(){
            var thiz=this;
            this.handle=dojo.connect(this.object,this.trigger, function (value) {
                thiz.onTriggered(value);
            });
        },
        /**
         * Cleanup
         */
        destroy:function(){
            this.handle.remove();
        }
    });
});;
/** @module xwire/Target */
define('xwire/Target',[
    'dcl/dcl',
    'xwire/_Base'
],function(dcl,_Base){
    /**
     * Abstract binding target
     * @class xwire/Target
     */
    var Module = dcl(_Base,{
        declaredClass:"xwire.Target",
        /**
         * The binding we belong to
         * {xwire.Binding}
         */
        binding:null,
        /**
         * The object instance we're operating on
         */
        object:null,
        /**
         * The path within the object
         */
        path:null,
        /**
         * run is performed when a source is being triggered
         */
        run:function(){

        },
        /**
         * start the target, this is not really needed
         */
        start:function(){

        }
    });
    dcl.chainAfter(Module,'run');
    return Module
});;
/** @module xwire/Source */
define('xwire/Source',[
    'dcl/dcl',
    'xide/types',
    'xwire/_Base'
],function(dcl,types,_Base){
    /**
     * Abstract binding source
     * @class xwire/Source
     * @extends {module:xwire/_Base}
     */
    return dcl(_Base,{
        declaredClass:"xwire.Source"
    });
});;
/** @module xwire/Binding */
define('xwire/Binding',[
    'dcl/dcl',
    'xwire/_Base'
],function(dcl,_Base){
    /**
     * @class xwire/Binding
     */
    return dcl(_Base,{
        declaredClass:"xwire.Binding",
        /**
         * @type {module:xdeliteful/Source}
         */
        source:null,
        /**
         * @type {module:xwire/Target}
         */
        target:null,
        /**
         * @type {module:xdeliteful/Script}
         */
        accept:null,
        /**
         * @type {module:xdeliteful/Script}
         */
        transform:null,
        destroy:function(){
            this.source && this.source.destroy();
            this.target && this.target.destroy();
            delete this.transform;
            delete this.accept;
        },
        /**
         * trigger is being invoked by the source
         */
        trigger:function(data){
            if(this.target){
                this.target.run(data);
            }
        },
        /**
         *
         */
        start:function(){
            if(this.source){
                this.source.binding=this;
                this.source.start();
            }
            if(this.target){
                this.target.binding=this;
                this.target.start();
            }
        }
    });
});;
/** @module xfile/manager/FileManager */
define('xfile/manager/FileManager',[
    'dcl/dcl',
    'dojo/_base/kernel',
    'xide/manager/ServerActionBase',
    'xide/types',
    'xfile/types',
    'xide/utils',
    'xide/encoding/SHA1',
    'xide/manager/RPCService',
    'dojo/Deferred',
    'xdojo/has',
    'xfile/manager/FileManagerActions',
    'require',
    'xfile/factory/Store',
    "xide/lodash",
    'xdojo/has!electron?xfile/manager/Electron'
], function (dcl,dojo,ServerActionBase, types, fTypes, utils, SHA1, RPCService, Deferred,has,FileManagerActions,require,StoreFactory,_,Electron) {
    var bases = [ServerActionBase, FileManagerActions];
    if(has('electronx') && Electron){
        bases.push(Electron);
    }
    var debug = false;
    /**
     * @class module:xfile.manager.FileManager
     * @extends {module:xide/manager/ServerActionBase}
     * @extends {module:xide/manager/ManagerBase}
     * @augments {module:xide/mixins/EventedMixin}
     */
    return dcl(bases, {
        declaredClass:"xfile.manager.FileManager",
        /**
         * Returns a new name 
         * @param item
         * @param others
         * @returns {*}
         */
        getNewName:function(item,others){
            var name = item.name.replace('.meta.json','');
            var found = false;
            var i = 1;
            var newName = null;
            while (!found){
                newName = name + '-' + i + '.meta.json';
                var colliding = _.find(others,{
                    name:newName
                });

                if(!colliding){
                    found = true;
                }else{
                    i++;
                }
            }
            return newName;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _uploadXHR: null,
        store: null,
        config: null,
        filesToUpload: null,
        serviceUrl: "index.php",
        serviceClass: 'XCOM_Directory_Service',
        settingsStore: null,
        stores:[],
        getStore:function(mount,cache){
            var store =  _.find(this.stores,{
                mount:mount
            });
            if(store){
                return store;
            }
            return StoreFactory.createFileStore(mount,null,this.config,null,this.ctx);
        },
        addStore:function(store){
            this.stores.push(store);
            store._on('destroy',this.removeStore.bind(this));
        },
        removeStore:function(store){
            var index = this.stores.indexOf(store);
            if(index) {
                this.stores.remove(store);
            }
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Standard manager interface implementation
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        download: function (src) {
            var selection = [];
            selection.push(src.path);

            if(has('nserver')){
                window.open('../files/'+src.mount+'/'+src.path);
                return;
            }

            var thiz = this;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            var serviceClass = this.serviceClass || 'XCOM_Directory_Service';
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html",
                "attachment": "1",
                "send": "1"
            });
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            delete  aParams['attachment'];
            delete  aParams['send'];
            var pStr = dojo.toJson(JSON.stringify(aParams));
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            window.open(downloadUrl);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  File manager only related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getImageUrl: function (src, preventCache, extraParams) {
            if(has('nserver')){
                return ('../files/'+src.mount+'/'+src.path);
            }
            preventCache = location.href.indexOf('noImageCache') != -1 || preventCache === true || src.dirty === true;
            var downloadUrl = decodeURIComponent(this.serviceUrl);
            downloadUrl = downloadUrl.replace('view=rpc', 'view=smdCall');
            var path = utils.buildPath(src.mount, src.path, true);
            path = this.serviceObject.base64_encode(path);

            var serviceClass = this.ctx.getFileManager().serviceClass || 'XCOM_Directory_Service';
            if (downloadUrl.indexOf('?') != -1) {
                downloadUrl += '&';
            } else {
                downloadUrl += '?';
            }
            downloadUrl += 'service=' + serviceClass + '.get&path=' + path + '&callback=asdf';
            if (this.config.DOWNLOAD_URL) {
                downloadUrl = '' + this.config.DOWNLOAD_URL;
                downloadUrl += '&path=' + path + '&callback=asdf';
            }
            downloadUrl += '&raw=html';
            downloadUrl += '&attachment=0';
            downloadUrl += '&send=1';
            var aParams = utils.getUrlArgs(location.href);
            utils.mixin(aParams, {
                "service": serviceClass + ".get",
                "path": path,
                "callback": "asdf",
                "raw": "html"
            });
            utils.mixin(aParams, extraParams);
            delete  aParams['theme'];
            delete  aParams['debug'];
            delete  aParams['width'];
            var pStr = dojo.toJson(aParams);
            var signature = SHA1._hmac(pStr, this.config.RPC_PARAMS.rpcSignatureToken, 1);
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcUserField + '=' + this.config.RPC_PARAMS.rpcUserValue;
            downloadUrl += '&' + this.config.RPC_PARAMS.rpcSignatureField + '=' + signature;
            if (preventCache) {
                downloadUrl += '&time=' + new Date().getTime();
            }
            if (extraParams) {
                for (var p in extraParams) {
                    downloadUrl += '&' + p + '=' + extraParams[p];
                }
            }
            return downloadUrl;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Upload related
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onFileUploadFailed: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;
            if (item.dfd) {
                item.dfd.reject(item);
            }
            thiz.filesToUpload.remove(item);
            thiz.publish(eventKeys.ON_UPLOAD_FAILED, {item: item}, thiz);
        },
        onFileUploaded: function (item) {
            var thiz = this,
                eventKeys = types.EVENTS;

            setTimeout(function () {
                var struct1 = {
                    message: '' + item.file.name + ' uploaded to ' + item.dstDir,
                    messageArgs: {}
                };
                thiz.publish(eventKeys.STATUS, struct1, thiz);
                if (item.dfd) {
                    item.dfd.resolve(item);
                }
                thiz.filesToUpload.remove(item);
                thiz.publish(eventKeys.ON_UPLOAD_FINISH, {item: item});
            }, 500);
        },
        getUploadUrl: function () {
            if(has('nserver')){
                return this.serviceUrl.replace('/smd','/upload?');
            }
            var url = '' + decodeURIComponent(this.serviceUrl);

            url = url.replace('view=rpc', 'view=upload');
            url = url.replace('../../../../', './');
            url += '&service=';
            url += this.serviceClass;
            url += '.put&callback=nada';
            return url;
        },
        initXHRUpload: function (item, autoRename, dstDir, mount) {
            var xhr = new XMLHttpRequest();
            var uploadUrl = this.getUploadUrl();
            var uri = '' + uploadUrl;
            uri += '&mount=' + encodeURIComponent(mount);
            uri += '&dstDir=' + encodeURIComponent(dstDir);
            var thiz = this;
            var upload = xhr.upload;
            upload.addEventListener("progress", function (e) {
                if (!e.lengthComputable) {
                    thiz.onFileUploaded(item);
                } else {
                    var struct = {
                        item: item,
                        progress: e
                    };
                    item.isLoading = true;
                    item.dfd.progress(struct);
                }
            }.bind(this), false);

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.responseText && xhr.responseText != 'OK') {
                        var error = utils.getJson(xhr.responseText);
                        if (!error && xhr.responseText.indexOf('Fata Error')) {
                            error = {
                                result: [xhr.responseText],
                                code: 1
                            };
                        }
                        if (error && error.result && _.isArray(error.result) && error.result.length > 0) {
                            var _message = null;
                            for (var i = 0; i < error.result.length; i++) {
                                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.result[i], thiz);
                                _message = error.result[i];
                            }
                            if (_message) {
                                item.error = _message;
                            }
                            thiz.onFileUploadFailed(item);
                            thiz.submitNext();
                            return;
                        }
                        if (error && error.error) {
                            thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name + ' ' + error.error.message, thiz);
                            thiz.onFileUploadFailed(item);
                        }
                    }
                    thiz.onFileUploaded(item);
                    thiz.submitNext();
                }
            }.bind(this);
            upload.onerror = function () {
                thiz.publish(types.EVENTS.ERROR, 'Error uploading : ' + item.name, thiz);
            };
            xhr.open("POST", uri, true);
            return xhr;
        },
        hasLoadingItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (this.filesToUpload[i].status == 'loading') {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        /**
         *
         * @param files
         * @param mount
         * @param path
         * @param callee
         * @param view
         * @returns {Deferred[]}
         */
        upload: function (files, mount, path, callee, view) {
            var dfds = [];
            for (var i = 0; i < files.length; i++) {
                var uploadStruct = {
                    file: files[i],
                    dstDir: '' + path,
                    mount: '' + mount,
                    callee: callee,
                    view: callee,
                    dfd: new Deferred()
                };
                dfds.push(uploadStruct['dfd']);
                this.filesToUpload.push(uploadStruct);
            }
            this.submitNext();
            return dfds;
        },
        sendFileUsingFormData: function (xhr, file) {
            var formData = new FormData();
            formData.append("userfile_0", file.file);
            xhr.send(formData);
        },
        sendFileMultipart: function (item) {
            var auto_rename = false;
            item.status = 'loading';
            var xhr = this.initXHRUpload(item, (auto_rename ? "auto_rename=true" : ""), item['dstDir'], item['mount']);
            this.publish(types.EVENTS.ON_UPLOAD_BEGIN,{
                item: item,
                name: item.name
            }, this);
            if (window.FormData) {
                this.sendFileUsingFormData(xhr, item);
            }
        },
        submitNext: function () {
            var item = this.getNextUploadItem();
            if (item) {
                this.sendFileMultipart(item);
            }
        },
        getNextUploadItem: function () {
            for (var i = 0; i < this.filesToUpload.length; i++) {
                if (!this.filesToUpload[i].status) {
                    return this.filesToUpload[i];
                }
            }
            return false;
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Error handling
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        onError: function (err) {
            if (err) {
                if (err.code === 1) {
                    if (err.message && _.isArray(err.message)) {
                        this.publish(types.EVENTS.ERROR, err.message.join('<br/>'), this);
                        return;
                    }
                } else if (err.code === 0) {
                    this.publish(types.EVENTS.STATUS, 'Ok', this);
                }
            }
            this.publish(types.EVENTS.ERROR, {
                error: err
            }, this);
        },
        addError: function (def) {
            var thiz = this;
            var _cb = function () {
                thiz.onError();
            };
            def.addCallback(_cb);
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  pre RPC roundup
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        downloadItem: function (src, readyCB) {
            return this.callMethod(types.OPERATION.DOWNLOAD, [src], readyCB, true);
        },
        downloadTo: function (url, mount, dst, readyCB, dstItem) {
            if (dstItem) {
                var thiz = this;
                var _cb = function (result) {
                    var _failed = false;
                    if (result && result.error && result.error.code == 1) {
                        _failed = true;
                    }
                    thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_END, {
                        terminatorItem: dstItem,
                        failed: _failed
                    }, this);

                    readyCB(arguments);
                };
                thiz.publish(types.EVENTS.ON_DOWNLOAD_TO_BEGIN, {
                    dst: dstItem,
                    url: url,
                    items: [dstItem]
                }, this);
            } else {
                console.log('download from remote url have no dest item');
            }
            return this.callMethod(types.OPERATION.DOWNLOAD_TO, [url, mount, dst], _cb, true);
        },
        find: function (mount, conf, readyCB) {
            try {
                return this.callMethod(types.OPERATION.FIND, [mount, conf], readyCB, true);
            } catch (e) {
                logError(e,'find');
            }
        },
        getContent: function (mount, path, readyCB, emit) {
            if(this.getContentE){
                var res = this.getContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            if(has('php')) {
                var _path = this.serviceObject.base64_encode(utils.buildPath(mount, path, true));
                return this.callMethod(types.OPERATION.GET_CONTENT, [_path, false, false], readyCB, false);
            }else{
                return this._getText(require.toUrl(mount).replace('main.js','') + '/' + path,{
                    sync: false,
                    handleAs: 'text'
                }).then(function(res){
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        logError(e, 'error running RPC');
                    }
                });
            }
        },
        setContent: function (mount, path, content, readyCB) {
            this.publish(types.EVENTS.ON_CHANGED_CONTENT, {
                'mount': mount,
                'path': path,
                'content': content
            });
            this.publish(types.EVENTS.ON_STATUS_MESSAGE, {
                text: "Did save file : " + mount + '://' + path
            });
            if(this.setContentE){
                var res = this.setContentE.apply(this,arguments);
                if(res){
                    return res;
                }
            }
            return this.callMethod(types.OPERATION.SET_CONTENT, [mount, path, content], readyCB, true);
        },
        onMessages: function (res) {
            var events = utils.getJson(res.events);
            if (events && _.isArray(events)) {
                for (var i = 0; i < events.length; i++) {
                    var struct = {
                        path: events[i].relPath
                    };
                    utils.mixin(struct, events[i]);
                    this.publish(events[i].clientEvent, struct, this);
                }
            }
        },
        onErrors: function (res) {},
        init:function(){
            this.stores = [];
            this.filesToUpload = [];
        },
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  RPC helpers
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        callMethodEx: function (serverClassIn, method, args, readyCB, omitError) {
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = serverClassIn || this.serviceClass;
            var thiz = this;
            if (!this.serviceObject[serviceClass][method]) {
                if (omitError === true) {
                    this.onError({
                        code: 1,
                        message: ['Sorry, server doesnt know ' + method]
                    });
                }
                return null;
            }
            /***
             * Build signature
             */
            var params = {};
            params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
            /**
             * Mixin mandatory fields
             */
            params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
            this.serviceObject.extraArgs = params;
            this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
            this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
            this.serviceObject[serviceClass][method](args).then(function (res) {
                try {
                    if (readyCB) {
                        readyCB(res);
                    }
                } catch (e) {
                    console.error('bad news : callback for method ' + method + ' caused a crash in service class ' + serviceClass);
                }
                if (res && res.error && res.error.code == 3) {
                    setTimeout(function () {
                        thiz.onMessages(res.error);
                    }, 50);
                }

                if (res && res.error && res.error && res.error.code !== 0) {
                    thiz.onError(res.error);
                    return;
                }

                thiz.publish(types.EVENTS.STATUS, {
                    message: 'Ok!'
                }, this);

            }, function (err) {
                thiz.onError(err);
            });


        },
        callMethod: function (method, args, readyCB, omitError) {
            var thiz = this;
            /***
             * Check we the RPC method is in the SMD
             */
            var serviceClass = this.serviceClass;
            try {
                if (!this.serviceObject[serviceClass][method]) {
                    if (omitError === true) {
                        this.onError({
                            code: 1,
                            message: ['Sorry, server doesnt know ' + method]
                        });
                    }
                    return null;
                }
                /***
                 * Build signature
                 */
                var params = {};
                params = utils.mixin(params, this.config.RPC_PARAMS.rpcFixedParams);
                /**
                 * Mixin mandatory fields
                 */
                params[this.config.RPC_PARAMS.rpcUserField] = this.config.RPC_PARAMS.rpcUserValue;
                this.serviceObject.extraArgs = params;
                this.serviceObject.signatureField = this.config.RPC_PARAMS.rpcSignatureField;
                this.serviceObject.signatureToken = this.config.RPC_PARAMS.rpcSignatureToken;
                var dfd = this.serviceObject[this.serviceClass][method](args);
                dfd.then(function (res) {
                    try {
                        if (readyCB) {
                            readyCB(res);
                        }
                    } catch (e) {
                        console.error('crashed in ' + method);
                        logError(e, 'error running RPC');

                    }
                    //@TODO: batch, still needed?
                    if (res && res.error && res.error.code == 3) {
                        setTimeout(function () {
                            thiz.onMessages(res.error);
                        }, 50);
                    }

                    if (res && res.error && res.error && res.error.code == 1) {
                        thiz.onError(res.error);
                        return;
                    }
                    if (omitError !== false) {
                        var struct = {
                            message: 'Ok!'
                        };
                        thiz.publish(types.EVENTS.STATUS, struct, this);
                    }
                }, function (err) {
                    thiz.onError(err);
                });
                return dfd;
            } catch (e) {
                console.error('crash calling method' + e,arguments);
                thiz.onError(e);
                logError(e,'error ');
            }
        },
        __initService: function () {
            this.filesToUpload = [];
            if (!this.serviceObject) {
                if(this.serviceUrl) {
                    this.serviceObject = new RPCService(decodeURIComponent(this.serviceUrl));
                    this.serviceObject.config = this.config;
                }
            }
        }
    });
});;
define('xfile/manager/Electron',[
    'dcl/dcl',
    'xdojo/has',
    'xide/utils',
    'dojo/Deferred'
], function (dcl, has, utils, Deferred) {
    var electron = has('electronx');
    var Module = dcl(null, {
        declaredClass: "xfile.manager.Electron",
        require: function () {
            return window['eRequire'].apply(null, arguments);
        },
        srequire: function () {
            return this.require('electron').remote.require.apply(null, arguments);
        },
        remote: function () {
            var _require = window['eRequire'];
            return _require('electron').remote;
        },
        getContentE: function (_mount, _path, readyCB, emit) {
            var thiz = this,
                item = {
                    path: _path,
                    mount: _mount
                },
                ctx = thiz.ctx || sctx,
                resourceManager = ctx.getResourceManager(),
                vfsConfig = resourceManager.getVariable('VFS_CONFIG') || {},
                dfd = new Deferred();

            var os = this.require('os');
            var shell = this.require('electron').shell;
            var path = this.require("path");
            var fs = this.require("fs");
            var mount = item.mount.replace('/', '');
            if (!vfsConfig[mount]) {
                console.error('open in os failed: have no VFS config for ' + mount);
                return;
            }
            mount = vfsConfig[mount];
            if (!mount) {
                console.error('cant resolve file ' + mount + '/' + _path);
                return false;
            }
            var itemPath = item.path.replace('./', '/');
            itemPath = utils.replaceAll('/', path.sep, itemPath);
            var realPath = path.resolve(mount + path.sep + itemPath);
            if (fs.existsSync(realPath)) {
                var size = fs.statSync(realPath).size,
                    buf = new Buffer(size),
                    fd = fs.openSync(realPath, 'r');
                if (!size) {
                    return "";
                }

                fs.readSync(fd, buf, 0, size, 0);
                fs.closeSync(fd);
                var res = buf.toString();
                dfd.resolve(res);
                if (readyCB) {
                    readyCB(res);
                }

            } else {
                console.warn('path ' + realPath + ' doesnt exists, fall back to legacy getContent');
                return false;
            }
            return dfd;
        },
        setContentE: function (_mount, _path, content, readyCB) {
            var thiz = this;
            var item = {
                path: _path,
                mount: _mount
            };
            var ctx = thiz.ctx || sctx;
            var resourceManager = ctx.getResourceManager();
            var vfsConfig = resourceManager.getVariable('VFS_CONFIG') || {};
            var dfd = new Deferred();
            var os = this.require('os');
            var path = this.require("path");
            var fs = this.require("fs");
            var mount = item.mount.replace('/', '');
            if (!vfsConfig[mount]) {
                console.error('open in os failed: have no VFS config for ' + mount);
                return;
            }
            mount = vfsConfig[mount];
            if (!mount) {
                console.warn('cant resolve file mount' + mount + '/' + _path);
                return false;
            }
            var itemPath = item.path.replace('./', '/');
            itemPath = utils.replaceAll('/', path.sep, itemPath);
            var realPath = path.resolve(mount + path.sep + itemPath);
            if (fs.existsSync(realPath)) {
                try {
                    fs.writeFileSync(realPath, content);
                    if (readyCB) {
                        readyCB();
                    }
                    dfd.resolve();
                } catch (e) {
                    console.error('error saving file ' + realPath);
                    return false;
                }
            } else {
                console.error('path ' + realPath + ' doesnt exists, fallback to legacy setContent');
                return false;
            }
            return dfd;
        }
    });
    return Module;
});

;
define('xfile/factory/Store',[
    'xide/types',
    'xide/factory',
    'xide/utils',
    'xfile/data/Store'
], function (types, factory,utils,Store){
    /**
     *
     * @param mount
     * @param options
     * @param config
     * @param optionsMixin
     * @param ctx
     * @param args
     * @returns {*}
     */
    factory.createFileStore = function (mount,options,config,optionsMixin,ctx,args){
        var storeClass = Store;
        options = options || {
            fields:
            types.FIELDS.SHOW_ISDIR |
            types.FIELDS.SHOW_OWNER |
            types.FIELDS.SHOW_SIZE |
            //types.FIELDS.SHOW_FOLDER_SIZE |
            types.FIELDS.SHOW_MIME |
            types.FIELDS.SHOW_PERMISSIONS |
            types.FIELDS.SHOW_TIME |
            types.FIELDS.SHOW_MEDIA_INFO
        };

        utils.mixin(options,optionsMixin);
        var store = new storeClass(utils.mixin({
            data:[],
            ctx:ctx,
            config:config,
            url:config.FILE_SERVICE,
            serviceUrl:config.serviceUrl,
            serviceClass:config.FILES_STORE_SERVICE_CLASS,
            mount:mount,
            options:options
        },args));
        store._state = {
            initiated:false,
            filter:null,
            filterDef:null
        };
        store.reset();
        store.setData([]);
        store.init();
        ctx && ctx.getFileManager().addStore(store);
        return store;
    };
    return factory;

});;
/**
 * @module xfile/data/FileStore
 **/
define('xfile/data/Store',[
    "dojo/_base/declare",
    "dojo/_base/lang",
    'dojo/Deferred',
    "xide/mixins/ReloadMixin",
    "xide/manager/ServerActionBase",
    'dstore/Cache',
    'dstore/QueryResults',
    'xide/types',
    'xide/utils',
    'dojo/when',
    'xide/data/TreeMemory',
    'dstore/Trackable',
    'xide/data/ObservableStore',
    'xfile/model/File',
    'xide/lodash'
], function (declare, lang, Deferred, ReloadMixin, ServerActionBase, Cache, QueryResults, types, utils, when, TreeMemory, Trackable, ObservableStore, File, _) {
    var _debug = false;
    /**
     * Constants
     * @type {string}
     */
    var C_ITEM_EXPANDED = "_EX";      // Attribute indicating if a directory item is fully expanded.
    /**
     *
     * A store based on dstore/Memory and additional dstore mixins, used for all xfile grids.
     *
     * ###General
     *
     * - This store is only fetching file listings from the server! Any other file operation is done in
     * by file manager. However, this store is the central database for all files.
     *
     *
     * ###Common features and remarks
     *
     * - works with for multiple grid instances: lists/thumb or tree grids
     * - caches all directory listings, use _loadPath(path,force=true) to drop the cache
     * - all server methods return dojo/Deferred handles
     * - loads path segments recursivly, ie: getItem('./path/subPath/anotherSub');
     *
     * ### Server related
     * #### Requests

     * This part is done in the {link:xide/manager/ServerActionBase} ServerActionBase mixin, wrapped in here as
     * '_request'. This will take care about the possible transports : JSON-RPC-2.0 with a Dojo-SMD envelope or JSONP.
     * Both requests will be signed upon its payload, using this.config.RPC_PARAMETERS(server controlled), if required.
     * At the time of writing, this library has been developed for a PHP and Java-Struts which both support Dojo - SMD.
     * However, you may adjust to REST based environments yourself. Also, when using the
     * supplied XPHP - JSON-RPC-2.0-SMD implementation you can make use of 'batch-requests' to avoid further requests.
     *
     * #### Responses
     *
     * The response arrives here parsed already, no need to do anything but adding it to the store.
     *
     * @class module:xfile/data/FileStore
     * @augments module:xide/manager/ServerActionBase
     * @augments module:dgrid/Memory
     * @augments module:dgrid/Tree
     * @augments module:dgrid/Cache
     * @augments module:xide/mixins/ReloadMixin
     */
    function Implementation() {
        return {
            addDot: true,
            /**
             * 'recursive' will tell the server to run the directory listing recursive for server method 'ls'
             * @type {boolean}
             */
            recursive: false,
            rootSegment: ".",
            Model: File,
            /**
             * @member idProperty {string} sets the unique identifier for store items is set to the 'path' of a file.
             * @public
             */
            idProperty: "path",
            parentProperty: "path",
            parentField: 'parent',
            /**
             * @member mount {string} sets the 'mount' prefix for a VFS. This is needed to simplify the work
             * with paths and needs to be handled separated. By default any request expects full paths as:
             * - root/_my_path
             * - root://_my_path/even_deeper
             * - dropbox/_my_folder
             *
             * This property is is being used to complete a full file path automatically in the request so that only the
             * actual inner path needs to be specified in all methods.
             * By default xfile supports multiple stores in the same application.
             * Each store is created upon mount + store options hash.
             * @public
             */
            mount: 'path',
            /**
             * @member options{Object[]} specifies the store options. The store options are tied to the server. As the store
             * is only relavant for enumerating files through a server method, there are only a couple of options needed:
             *
             * <b>options.fields</b> {int} A enumeration bitmask which specifies the fields to be added for a file or
             * directory node. This is described in link:xfile/types/Types#Fields and again, this is being processed by
             * the server.
             *
             * options.includeList {string} a comma separated list of allowed file extensions, this has priority the
             * exclusion mask.
             *
             * options.excludeList {string} a comma separated list of excluded file extensions
             *
             * This options are set through xfile/manager/Context#defaultStoreOptions which might be overriden
             * through the server controlled xFileConfiguration.mixins global header script tag.
             *
             * @example {
                "fields": 1663,
                "includeList": "*",
                "excludeList": "*"
            }
             * @public
             */
            options: {
                fields: 1663,
                includeList: "*",
                excludeList: "*"    // XPHP actually sets this to ".svn,.git,.idea" which are compatible to PHP's 'glob'
            },
            /**
             * @member serviceUrl {string} the path to the service entry point. There are 2 modes this end-point must
             * provide:
             * - a Dojo compatible SMD
             * - post/get requests with parameters. Currently JSONP & JSON-RPC-1/2.0 is supported.
             *
             * You can set also static SMD (see xide/manager/ServerActionBase) to bypass the SMD output. However,
             * this is being set usually by a server side mixin (in HTML header tag) on the fly!
             * @default null
             * @public
             */
            serviceUrl: null,
            /**
             * @member serviceClass {string} is the server class to be called. By default, this store creates a
             * JSON-RPC-2.0 post request where the methods looks like "XApp_Directory_Service.ls". Other formats are
             * supported in XPHP as well and support also composer autoloaders. If this is a singleton, you can also call
             * this.serviceObject.SERVER_CLASS.SERVER_METHOD(args) through here!
             * @public
             *
             */
            serviceClass: null,
            /**
             * @member singleton {boolean} Sets the ServerActionBase as 'Singleton' at the time of the construction. If there
             * is any other ServerActionBase subclass with the same service url, this will avoid additional requests to
             * fetch a SMD, furthermore, you can call other methods on the server through this here
             * as well: this.serviceObject.SERVER_CLASS.SERVER_METHOD(args)
             * @default true
             * @public
             */
            singleton: true,
            /////////////////////////////////////////////////////////////////////////////
            //
            //  dstore/Tree implementation
            //
            /////////////////////////////////////////////////////////////////////////////
            queryAccessors: true,
            autoEmitEvents: false, // this is handled by the methods themselves
            /*
             * test
             * @param object
             * @returns {boolean}
             */
            mayHaveChildren: function (object) {
                // summary:
                //		Check if an object may have children
                // description:
                //		This method is useful for eliminating the possibility that an object may have children,
                //		allowing collection consumers to determine things like whether to render UI for child-expansion
                //		and whether a query is necessary to retrieve an object's children.
                // object:
                //		The potential parent
                // returns: boolean
                if (object.mayHaveChildren == false) {
                    return false;
                }
                return object.directory === true;
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Private part, might be trashed
            //
            /////////////////////////////////////////////////////////////////////////////
            _lastFilter: null,
            _lastFilterDef: null,
            _lastFilterItem: null,
            _initiated: {
                value: false
            },
            id: null,
            _state: {
                initiated: false,
                filter: null,
                filterDef: null
            },
            isInitiated: function () {
                return this._state.initiated;
            },
            setInitiated: function (initiated) {
                this._state.initiated = initiated;
            },
            _extraSortProperties: {
                name: {
                    ignoreCase: true
                }
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Sorting
            //
            /////////////////////////////////////////////////////////////////////////////

            constructor: function () {
                this.id = utils.createUUID();
            },
            onSorted: function (sorted, data) {
                if (sorted.length == 1 && sorted[0].property === 'name') {
                    var upperCaseFirst = true,
                        directoriesFirst = true,
                        descending = sorted[0].descending;

                    if (directoriesFirst) {
                        function _sort(item) {
                            return upperCaseFirst ? item.name : item.name.toLowerCase();
                        }
                        var grouped = _.groupBy(data, function (item) {
                            return item.directory === true;
                        }, this);

                        data = _.sortBy(grouped['true'], _sort);
                        data = data.concat(_.sortBy(grouped['false'], _sort));
                        if (descending) {
                            data.reverse();
                        }
                    }
                }
                var _back = _.find(data, {
                    name: '..'
                });
                if (_back) {
                    data.remove(_back);
                    data.unshift(_back);
                }

                data = this.onAfterSort(data);

                return data;
            },
            onAfterSort: function (data) {
                var micromatch = this.micromatch;
                if (typeof mm !== 'undefined' && micromatch && data && data[0]) {
                    var what = data[0].realPath ? 'realPath' : 'path';
                    what = 'name';
                    var _items = _.pluck(data, what);
                    var matching = mm(_items, micromatch);
                    data = data.filter(function (item) {
                        if (matching.indexOf(item[what]) === -1) {
                            return null;
                        }
                        return item;
                    });
                    if (this._onAfterSort) {
                        data = this._onAfterSort(data);
                    }
                }
                return data;
            },
            /**
             * Overrides dstore method to add support for case in-sensitive sorting. This requires
             * ignoreCase: true in a this.sort(..) call, ie:
             *
             *  return [{property: 'name', descending: false, ignoreCase: true}]
             *
             * this will involve this._extraSortProperties and is being called by this.getDefaultSort().
             *
             * @param sorted
             * @returns {Function}
             * @private
             */
            _createSortQuerier: function (sorted) {
                var thiz = this;
                return function (data) {
                    data = data.slice();
                    data.sort(typeof sorted == 'function' ? sorted : function (a, b) {
                        for (var i = 0; i < sorted.length; i++) {
                            var comparison;
                            if (typeof sorted[i] == 'function') {
                                comparison = sorted[i](a, b);
                            } else {
                                var property = sorted[i].property;
                                if (thiz._extraSortProperties[property]) {
                                    utils.mixin(sorted[i], thiz._extraSortProperties[property]);
                                }
                                var descending = sorted[i].descending;
                                var aValue = a.get ? a.get(property) : a[property];
                                var bValue = b.get ? b.get(property) : b[property];
                                var ignoreCase = !!sorted[i].ignoreCase;
                                aValue != null && (aValue = aValue.valueOf());
                                bValue != null && (bValue = bValue.valueOf());

                                if (ignoreCase) {
                                    aValue.toUpperCase && (aValue = aValue.toUpperCase());
                                    bValue.toUpperCase && (bValue = bValue.toUpperCase());
                                }
                                comparison = aValue === bValue ? 0 : (!!descending === (aValue === null || aValue > bValue) ? -1 : 1);
                            }
                            if (comparison !== 0) {
                                return comparison;
                            }
                        }
                        return 0;
                    });
                    return thiz.onSorted(sorted, data);
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  Public API section
            //
            /////////////////////////////////////////////////////////////////////////////
            _getItem: function (path, allowNonLoaded) {
                //try instant and return when loaded
                //this.getSync(path.replace('./',''))
                if (path === '/') {
                    path = '.';
                }
                var item = this.getSync(path) || this.getSync('./' + path);
                if (item && (this.isItemLoaded(item) || allowNonLoaded == true)) {
                    return item;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Returns a promise or a store item. This works recursively for any path and
             * results in one request per path segment or a single request when batch-requests
             * are enabled on the server.

             * @param path {string} a unique path, ie: ./ | . | ./myFolder | ./myFolder/and_deeper. If the item isn't
             * fully loaded yet, it just returns the item, if you enable 'load' and does the full load.
             * @param load {boolean} load the item if not already
             * @param options {object|null} request options
             *
             * @returns {Object|Deferred|null}
             */
            getItem: function (path, load, options) {
                path = path.replace('./', '');
                if (load == false) {
                    return this._getItem(path);
                } else if (load == true) {
                    //at this point we have to load recursively
                    var parts = path.split('/'),
                        thiz = this,
                        partsToLoad = [],
                        item = thiz.getSync(path);

                    if (item && this.isItemLoaded(item)) {
                        return item;
                    }

                    //new head promise for all underlying this.getItem calls
                    var deferred = new Deferred();
                    var _loadNext = function () {
                        //no additional lodash or array stuff please, keep it simple
                        var isFinish = !_.find(partsToLoad, { loaded: false });
                        if (isFinish) {
                            deferred.resolve(thiz._getItem(path));
                        } else {
                            for (var i = 0; i < partsToLoad.length; i++) {
                                if (!partsToLoad[i].loaded) {
                                    var _item = thiz.getSync(partsToLoad[i].path);
                                    if (_item) {
                                        if (_item.directory === true && thiz.isItemLoaded(_item)) {
                                            partsToLoad[i].loaded = true;
                                            continue;
                                        } else if (_item.directory == null) {
                                            deferred.resolve(_item);
                                            break;
                                        }
                                    }
                                    thiz._loadPath(partsToLoad[i].path, false, options).then(function (items) {
                                        partsToLoad[i].loaded = true;
                                        _loadNext();
                                    }, function (err) {
                                        var _i = Math.abs(Math.min(0, i - 1));
                                        var nextPart = partsToLoad[_i];
                                        var parts = partsToLoad;
                                        if (!nextPart) {
                                            _i = partsToLoad.length - 1;
                                            nextPart = partsToLoad[_i];
                                        }
                                        var _item = thiz.getItem(nextPart.path);
                                        when(thiz.getItem(partsToLoad[_i].path, false), function (_item) {
                                            deferred.resolve(_item, partsToLoad[_i].path);
                                        });
                                    });
                                    break;
                                }
                            }
                        }
                    };

                    //prepare process array
                    var itemStr = '.';
                    for (var i = 0; i < parts.length; i++) {
                        if (parts[i] == '.') {
                            continue;
                        }
                        if (parts.length > 0) {
                            itemStr += '/';
                        }
                        itemStr += parts[i];
                        partsToLoad.push({ path: itemStr, loaded: false });
                    }
                    //fire
                    _loadNext();
                    return deferred;
                }
                if (path === '.') {
                    return this.getRootItem();
                }
                return null;
            },
            /**
             * Return the root item, is actually private
             * @TODO: root item unclear
             * @returns {{path: string, name: string, mount: *, directory: boolean, virtual: boolean, _S: (xfile|data|FileStore), getPath: Function}}
             */
            getRootItem: function () {
                return {
                    _EX: true,
                    path: '.',
                    name: '.',
                    mount: this.mount,
                    directory: true,
                    virtual: true,
                    _S: this,
                    getPath: function () {
                        return this.path;
                    }
                };
            },
            /**
             * back compat, trash
             */
            getItemByPath: function () {
                //console.log('FILESTORE::getItemByPath',arguments);
            },
            /*
             * */
            getParents: function () {
                return null;
            },
            /**
             * Return parent object in sync mode, default to root item
             * @TODO fix root problem
             * @param mixed {string|object}
             */
            getParent: function (mixed) {
                if (!mixed) {
                    return null;
                }
                var item = mixed,
                    result = null;

                if (lang.isString(item)) {
                    item = this.getSync(mixed);
                }

                if (item && item.parent) {
                    result = this.getSync(item.parent);
                }
                return result || this.getRootItem();
            },
            /**
             * Return 'loaded' state
             * @param item
             * @returns {boolean}
             */
            isItemLoaded: function (item) {
                return item && (!item.directory || this._isLoaded(item));
            },
            /**
             * Wrap loadItem
             * @TODO yeah, what?
             * @param item
             * @param force
             * @returns {*}
             */
            loadItem: function (item, force) {
                return this._loadItem(item, force);
            },
            /**
             * Fix an incoming item for our needs, adds the _S(this) attribute and
             * a function to safely return a its path since there are items with fake paths as: './myPath_back_'
             * @param item
             * @private
             */
            _parse: function (item) {
                item._S = this;
                if (!_.isEmpty(item.children)) {
                    _.each(item.children, function (_item) {
                        _item.parent = item.path;
                        this._parse(_item);
                    }, this);

                    item._EX = true;
                    item.children = this.addItems(item.children);
                }
                item.getPath = function () {
                    return this.path;
                };
            },
            /////////////////////////////////////////////////////////////////////////////
            //
            //  True store impl.
            //
            /////////////////////////////////////////////////////////////////////////////
            /**
             * Here to load an item forcefully (reload/refresh)
             * @param path
             * @param force
             * @param options {object|null}
             * @returns {*}
             * @private
             */
            _loadPath: function (path, force, options) {
                var thiz = this;
                var result = this._request(path, options);
                //console.log('load path : ' + path);
                result.then(function (items) {
                    //console.log('got : items for ' + path, items);
                    var _item = thiz._getItem(path, true);
                    if (_item) {
                        if (force) {
                            if (!_.isEmpty(_item.children)) {
                                thiz.removeItems(_item.children);
                            }
                        }
                        _item._EX = true;
                        thiz.addItems(items, force);
                        _item.children = items;
                        return items;
                    } else {
                        if (options && options.onError) {
                            options.onError('Error Requesting path on server : ' + path);
                        } else {
                            throw new Error('cant get item at ' + path);
                        }
                    }
                }.bind(this),
                    function (err) {
                        console.error('error in load');
                    });

                return result;

            },
            /**
             * Creates an object, throws an error if the object already exists.
             * @param object {Object} The object to store.
             * @param options {Object} Additional metadata for storing the data.  Includes an 'id' property if a specific
             * id is to be used. dstore/Store.PutDirectives?
             * @returns {Number|Object}
             */
            addSync: function (object, options) {
                (options = options || {}).overwrite = false;
                // call put with overwrite being false
                return this.putSync(object, options);
            },
            /**
             * @TODO: what?
             * @param item
             * @param force
             * @returns {Deferred}
             * @private
             */
            _loadItem: function (item, force) {
                var deferred = new Deferred(),
                    thiz = this;
                if (!item) {
                    deferred.reject('need item');
                    return deferred;
                }
                if (force) {
                    //special case on root
                    if (item.path === '.') {
                        thiz.setInitiated(false);
                        thiz.fetchRange().then(function (items) {
                            deferred.resolve({
                                store: thiz,
                                items: items,
                                item: item
                            });
                        });
                    } else {
                        this._loadPath(item.path, true).then(function (items) {
                            deferred.resolve(item);
                        }, function (err) {
                            console.error('error occured whilst loading items');
                            deferred.reject(err);
                        });
                    }
                }
                return deferred;
            },
            _normalize: function (response) {
                if (response && response.items) {
                    return response.items[0];
                }
                return [];
            },
            _isLoaded: function (item) {
                return item && item[C_ITEM_EXPANDED] === true;
            },
            fetch: function () {

            },
            put: function () {

            },
            add: function (item) {
                var _item = this.getSync(item.path);
                if (!_item) {
                    _item = this.addSync(item);
                    _item._S = this;
                    _item.getPath = function () {
                        return this.path;
                    };
                }
                return _item;
            },
            removeItems: function (items) {
                _.each(items, function (item) {
                    if (this.getSync(item.path)) {
                        this.removeSync(item.path);
                    }
                }, this);
            },
            getSync: function (id) {
                var data = this.storage.fullData;
                return data[this.storage.index[id]] || data[this.storage.index[id.replace('./', '')]];
            },
            addItems: function (items) {
                var result = [];
                _.each(items, function (item) {
                    var storeItem = this.getSync(item.path);
                    if (storeItem) {
                        this.removeSync(item.path);
                    }
                    result.push(this.add(item));
                }, this);
                return result;
            },
            open: function (item) {
                var thiz = this;
                if (!this._isLoaded(item)) {
                    item.isLoading = true;
                    return thiz._request(item.path).then(function (items) {
                        item.isLoading = false;
                        item._EX = true;
                        thiz.addItems(items);
                        item.children = items;
                        return items;
                    });
                } else {
                    var deferred = new Deferred();
                    thiz.resetQueryLog();
                    deferred.resolve(item.children);
                    return deferred;
                }
            },
            getDefaultSort: function () {
                return [{ property: 'name', descending: false, ignoreCase: true }];
            },
            filter: function (data) {
                if (data.parent) {
                    this._state.path = data.parent;
                }
                var item = this.getSync(data.parent);
                if (item) {
                    if (!this.isItemLoaded(item)) {
                        item.isLoading = true;
                        this._state.filterDef = this._loadPath(item.path);
                        this._state.filterDef.then(function () {
                            item.isLoading = false;
                        })
                    } else {
                        /*
                        if(item.children) {
                            var total = new Deferred();
                            total.resolve(item.children);
                            this._state.filterDef = total;
                            this._state.filter = data;
                        }
                        */
                        this._state.filterDef = null;
                    }
                }
                delete this._state.filter;
                this._state.filter = data;
                return this.inherited(arguments);
            },
            _request: function (path, options) {
                var collection = this;
                //console.log('requesting ' + path);
                return this.runDeferred(null, 'ls', {
                    path: path,
                    mount: this.mount,
                    options: this.options,
                    recursive: this.recursive
                },
                    utils.mixin({ checkErrors: false, displayError: true }, options)).then(function (response) {
                        var results = collection._normalize(response);
                        collection._parse(results);
                        // support items in the results
                        results = results.children || results;
                        return results;
                    }, function (e) {
                        if (options && options.displayError === false) {
                            return;
                        }
                        logError(e, 'error in FileStore : ' + this.mount + ' :' + e);
                    });
            },
            fetchRangeSync: function () {
                var data = this.fetchSync();
                var total = new Deferred();
                total.resolve(data.length);
                return new QueryResults(data, {
                    totalLength: total
                });
            },
            reset: function () {
                this._state.filter = null;
                this._state.filterDef = null;
                this.resetQueryLog();
            },
            resetQueryLog: function () {
                this.queryLog = [];
            },
            fetchRange: function () {
                // dstore/Memory#fetchRange always uses fetchSync, which we aren't extending,
                // so we need to extend this as well.
                var results = this._fetchRange();
                return new QueryResults(results.then(function (data) {
                    return data;
                }), {
                        totalLength: results.then(function (data) {
                            return data.length;
                        })
                    });
            },
            initRoot: function () {
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (!this.isInitiated()) {
                    return thiz._request(_path).then(function (data) {
                        if (!thiz.isInitiated()) {
                            _.each(data, thiz._parse, thiz);
                            thiz.setData(data);
                            thiz.setInitiated(true);
                            thiz.emit('loaded');
                        }
                        return thiz.fetchRangeSync(arguments);
                    }.bind(this));
                }
                var dfd = new Deferred();
                dfd.resolve();
                return dfd;
            },
            _fetchRange: function () {
                //special case for trees
                if (this._state.filter) {
                    var def = this._state.filterDef;
                    if (def) {
                        def.then(function (items) {
                            this.reset();
                            if (def && def.resolve) {
                                def.resolve(items);
                            }
                        }.bind(this));
                        return def;
                    }
                }
                //first time load
                var _path = '.';
                var thiz = this;
                //business as usual, root is loaded
                if (this.isInitiated()) {
                    var _def = thiz.fetchRangeSync(arguments);
                    var resultsDeferred = new Deferred();
                    var totalDeferred = new Deferred();
                    resultsDeferred.resolve(_def);
                    totalDeferred.resolve(_def.length);
                    thiz.emit('loaded');
                    return new QueryResults(resultsDeferred, {
                        totalLength: _def.totalLength
                    });
                }
                return thiz._request(_path).then(function (data) {
                    if (!thiz.isInitiated()) {
                        _.each(data, thiz._parse, thiz);
                        thiz.setData(data);
                        thiz.setInitiated(true);
                        thiz.emit('loaded');
                    }
                    return thiz.fetchRangeSync(arguments);
                }.bind(this));
            },
            getDefaultCollection: function (path) {
                var _sort = this.getDefaultSort();
                if (!path) {
                    return this.sort(_sort);
                } else {
                    return this.filter({
                        parent: path
                    }).sort(_sort);
                }
            },
            getChildren: function (object) {
                // summary:
                //		Get a collection of the children of the provided parent object
                // object:
                //		The parent object
                // returns: dstore/Store.Collection
                return this.root.filter({ parent: this.getIdentity(object) });
            }
        };
    }
    var Module = declare("xfile/data/Store", [TreeMemory, Cache, Trackable, ObservableStore, ServerActionBase.declare, ReloadMixin], Implementation());
    Module.Implementation = Implementation;
    return Module;
});;
/** @module xfile/model/File **/
define('xfile/model/File',[
    "dcl/dcl",
    "xide/data/Model",
    "xide/utils",
    "xide/types"
], function (dcl, Model, utils, types) {
    /**
     * @class module:xfile/model/File
     */
    return dcl(Model, {
        declaredClass:'xfile.model.File',
        getFolder: function () {
            var path = this.getPath();
            if (this.directory) {
                return path;
            }
            return utils.pathinfo(path, types.PATH_PARTS.ALL).dirname;
        },
        getChildren: function () {
            return this.children;
        },
        getParent: function () {
            //current folder:
            var store = this.getStore() || this._S;
            return store.getParent(this);
        },
        getStore: function () {
            return this._store || this._S;
        }
    });
});
;
define('dstore/Cache',[
	'dojo/_base/array',
	'dojo/when',
	'dojo/_base/declare',
	'dojo/_base/lang',
	'./Store',
	'./Memory',
	'./QueryResults'
], function (arrayUtil, when, declare, lang, Store, Memory, QueryResults) {

	// module:
	//		dstore/Cache


	function cachingQuery(type) {
		// ensure querying creates a parallel caching store query
		return function () {
			var subCollection = this.inherited(arguments);
			var cachingCollection = this.cachingCollection || this.cachingStore;
			subCollection.cachingCollection = cachingCollection[type].apply(cachingCollection, arguments);
			subCollection.isValidFetchCache = this.canCacheQuery === true || this.canCacheQuery(type, arguments);
			return subCollection;
		};
	}

	function init (store) {
		if (!store.cachingStore) {
			store.cachingStore = new Memory();
		}

		store.cachingStore.Model = store.Model;
		store.cachingStore.idProperty = store.idProperty;
	}
	var CachePrototype = {
		cachingStore: null,
		constructor: function () {
			init(this);
		},
		canCacheQuery: function (method, args) {
			// summary:
			//		Indicates if a queried (filter, sort, etc.) collection should using caching
			return false;
		},
		isAvailableInCache: function () {
			// summary:
			//		Indicates if the collection's cachingCollection is a viable source
			//		for a fetch
			return (this.isValidFetchCache && (this.allLoaded || this.fetchRequest)) ||
					this._parent && this._parent.isAvailableInCache();
		},
		fetch: function () {
			return this._fetch(arguments);
		},
		fetchRange: function () {
			return this._fetch(arguments, true);
		},
		_fetch: function (args, isRange) {
			// if the data is available in the cache (via any parent), we use fetch from the caching store
			var cachingStore = this.cachingStore;
			var cachingCollection = this.cachingCollection || cachingStore;
			var store = this;
			var available = this.isAvailableInCache();
			if (available) {
				return new QueryResults(when(available, function () {
					// need to double check to make sure the flag hasn't been cleared
					// and we really have all data loaded
					if (store.isAvailableInCache()) {
						return isRange ?
							cachingCollection.fetchRange(args[0]) :
							cachingCollection.fetch();
					} else {
						return store.inherited(args);
					}
				}));
			}
			var results = this.fetchRequest = this.inherited(args);
			when(results, function (results) {
				var allLoaded = !isRange;
				store.fetchRequest = null;
				// store each object before calling the callback
				arrayUtil.forEach(results, function (object) {
					// store each object before calling the callback
					if (!store.isLoaded || store.isLoaded(object)) {
						cachingStore.put(object);
					} else {
						// if anything is not loaded, we can't consider them all loaded
						allLoaded = false;
					}
				});
				if (allLoaded) {
					store.allLoaded = true;
				}

				return results;
			});
			return results;
		},
		// TODO: for now, all forEach() calls delegate to fetch(), but that may be different
		// with IndexedDB, so we may need to intercept forEach as well (and hopefully not
		// double load elements.
		// isValidFetchCache: boolean
		//		This flag indicates if a previous fetch can be used as a cache for subsequent
		//		fetches (in this collection, or downstream).
		isValidFetchCache: false,
		get: function (id, directives) {
			var cachingStore = this.cachingStore;
			var masterGet = this.getInherited(arguments);
			var masterStore = this;
			// if everything is being loaded, we always wait for that to finish
			return when(this.fetchRequest, function () {
				return when(cachingStore.get(id), function (result) {
					if (result !== undefined) {
						return result;
					} else if (masterGet) {
						return when(masterGet.call(masterStore, id, directives), function (result) {
							if (result) {
								cachingStore.put(result, {id: id});
							}
							return result;
						});
					}
				});
			});
		},
		add: function (object, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				// now put result in cache (note we don't do add, because add may have
				// called put() and already added it)
				var cachedPutResult =
					cachingStore.put(result && typeof result === 'object' ? result : object, directives);
				// the result from the add should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement add
				return result || cachedPutResult;
			});
		},
		put: function (object, directives) {
			// first remove from the cache, so it is empty until we get a response from the master store
			var cachingStore = this.cachingStore;
			cachingStore.remove((directives && directives.id) || this.getIdentity(object));
			return when(this.inherited(arguments), function (result) {
				// now put result in cache
				var cachedPutResult =
					cachingStore.put(result && typeof result === 'object' ? result : object, directives);
				// the result from the put should be dictated by the master store and be unaffected by the cachingStore,
				// unless the master store doesn't implement put
				return result || cachedPutResult;
			});
		},
		remove: function (id, directives) {
			var cachingStore = this.cachingStore;
			return when(this.inherited(arguments), function (result) {
				return when(cachingStore.remove(id, directives), function () {
					return result;
				});
			});
		},
		evict: function (id) {
			// summary:
			//		Evicts an object from the cache
			// any eviction means that we don't have everything loaded anymore
			this.allLoaded = false;
			return this.cachingStore.remove(id);
		},
		invalidate: function () {
			// summary:
			//		Invalidates this collection's cache as being a valid source of
			//		future fetches
			this.allLoaded = false;
		},
		_createSubCollection: function () {
			var subCollection = this.inherited(arguments);
			subCollection._parent = this;
			return subCollection;
		},

		sort: cachingQuery('sort'),
		filter: cachingQuery('filter'),
		select: cachingQuery('select'),

		_getQuerierFactory: function (type) {
			var cachingStore = this.cachingStore;
			return this.inherited(arguments) || lang.hitch(cachingStore, cachingStore._getQuerierFactory(type));
		}
	};
	var Cache = declare(null, CachePrototype);
	Cache.create = function (target, properties) {
		// create a delegate of an existing store with caching
		// functionality mixed in
		target = declare.safeMixin(lang.delegate(target), CachePrototype);
		declare.safeMixin(target, properties);
		// we need to initialize it since the constructor won't have been called
		init(target);
		return target;
	};
	return Cache;
});
;
define('xfile/manager/FileManagerActions',[
    'dcl/dcl',
    'xide/types',
    'xide/utils'
], function (dcl, types, utils) {
    /**
     * @class xfile.manager.FileManager
     * @augments module:xfile.manager.FileManager
     */
    return dcl(null, {
        declaredClass: "xfile/manager/FileManagerActions",
        /**
         * Publish a file's operations progress event
         * @param event
         * @param terminator
         * @param items
         * @param failed
         * @param extra
         * @private
         */
        _publishProgress: function (event, terminator, items, failed, extra) {
            var _args = {
                terminatorItem: terminator,
                failed: failed,
                items: items || terminator
            };
            utils.mixin(_args, extra);
            this.publish(event, _args, this);
        },
        /**
         *
         * @param operation
         * @param args
         * @param terminator
         * @param items
         * @returns {*}
         */
        doOperation: function (operation, args, terminator, items, extra, dfdOptions) {
            var thiz = this,
                operationCapitalized = operation.substring(0, 1).toUpperCase() + operation.substring(1),
                beginEvent = 'on' + operationCapitalized + 'Begin', //will evaluate for operation 'delete' to 'onDeleteBegin'
                endEvent = 'on' + operationCapitalized + 'End';

            thiz._publishProgress(beginEvent, terminator, items, false, extra);

            var rpcPromise = this.runDeferred(null, operation, args, dfdOptions).then(function () {
                thiz._publishProgress(endEvent, terminator, items, false, extra);
            }, function (err) {
                thiz._publishProgress(endEvent, terminator, items, true, extra);
            });
            return rpcPromise;
        },
        deleteItems: function (selection, options, dfdOptions) {
            return this.doOperation(types.OPERATION.DELETE, [selection, options, true], selection, selection, null, dfdOptions);
        },
        copyItem: function (selection, dst, options, dfdOptions) {
            return this.doOperation(types.OPERATION.COPY, [selection, dst, options, false], selection, selection, {dst: dst}, dfdOptions);
        },
        mkdir: function (mount, path, dfdOptions) {
            return this.doOperation(types.OPERATION.NEW_DIRECTORY, [mount, path], path, null, null, dfdOptions);
        },
        mkfile: function (mount, path, content) {
            return this.doOperation(types.OPERATION.NEW_FILE, [mount, path], path);
        },
        rename: function (mount, src, dst) {
            return this.doOperation(types.OPERATION.RENAME, [mount, src, dst], src);
        },
        moveItem: function (src, dst, include, exclude, mode, dfdOptions) {
            return this.doOperation(types.OPERATION.MOVE, [src, dst, include, exclude, mode], src, null, null, dfdOptions);
        },
        compressItem: function (mount, src, type, readyCB) {
            return this.doOperation(types.OPERATION.COMPRESS, [mount, src, type], src);
        },
        extractItem: function (mount, src, type) {
            return this.doOperation(types.OPERATION.EXTRACT, [mount, src], src);
        }
    });
});;
define('xide/mainr',[
    "xide/types",
    "xide/types/Types",
    'xide/utils/StringUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/StoreUtils',
    'xide/utils/WidgetUtils',
    'xide/utils/CIUtils',
    'xide/utils/ObjectUtils',
    'xide/utils/CSSUtils',

    'xide/factory',
    'xide/factory/Objects',
    'xide/factory/Events',
    'xide/factory/Clients',
    "xide/client/ClientBase",

    "xide/client/WebSocket",
    "xide/data/Memory",
    "xide/data/Model",
    "xide/data/ObservableStore",
    "xide/data/Reference",
    "xide/data/Source",
    "xide/data/TreeMemory",
    "xide/data/_Base",
    "xide/encoding/MD5",
    "xide/encoding/SHA1",
    "xide/encoding/_base",

    "xide/model/Component",
    "xide/debug",

    "xide/mixins/EventedMixin",
    "xide/mixins/ReferenceMixin",
    "xide/mixins/ReloadMixin",
    "xide/min",

    "xide/manager/BeanManager",
    "xide/manager/ContextBase",
    "xide/manager/Context",
    "xide/manager/ManagerBase",
    "xide/manager/PluginManager",
    "xide/manager/RPCService",
    "xide/manager/Reloadable",
    "xide/manager/ResourceManager",
    "xide/manager/ServerActionBase",
    'xide/utils'
], function () {

});;
/** @module xide/manager/ResourceManager **/
define('xide/manager/ResourceManager',[
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    'xide/mixins/VariableMixin'
], function (dcl,ServerActionBase, utils, VariableMixin) {
    /**
     *
     * Resource manager which provides:
     *
     * - Resolving variables in strings
     * - Loading & unloading of resources: CSS,JS, Blox, API-Docs and plugins
     *
     * @class xide.manager.ResourceManager
     */
    return dcl([ServerActionBase,VariableMixin.dcl], {
        declaredClass:"xide.manager.ResourceManager",
        serviceClass: "XApp_Resource_Service",
        resourceData: null,
        resourceVariables: null,
        getResourceVariables:function(){
            return this.resourceVariables;
        },
        setVariable: function (variableName,value) {
            return this.resourceVariables[variableName]=value;
        },
        getVariable: function (variableName) {
            return this.resourceVariables[variableName];
        },
        init: function () {
            if (!this.resourceVariables) {
                this.resourceVariables = {};
            }
        },
        replaceVariables: function (string, variables) {
            
            return utils.multipleReplace('' + string, variables || this.resourceVariables);
        }
    });
});;
/** @mixin xide/mixin/VariableMixin **/
define('xide/mixins/VariableMixin',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/utils'
], function (dcl,declare,utils) {

    var Implementation = {
        /**
         *
         * @param what
         * @param variables
         * @param delimitters
         * @returns {*}
         */
        resolve:function(what,variables,delimitters){
            variables = variables || this.resourceVariables || this.ctx.getResourceManager().getResourceVariables() || null;
            delimitters = delimitters || this.variableDelimiters || null;
            return utils.replace(what,null,variables,delimitters);
        }
    }

    /**
     * Mixin to resolve resource variables in strings.
     * Currently stub
     */
    var Module = declare("xide/mixins/VariableMixin", null, Implementation);
    Module.dcl = dcl(null,Implementation);
    return Module;
});;
/** @module xide/manager/Reloadable **/
define('xide/manager/Reloadable',[
    'dcl/dcl',
    "dojo/_base/lang",
    "xide/utils",
    "xide/types"
], function (dcl,lang,utils,types) {
    /**
     * @class xide.manager.Reloadable
     * @augments module:xide/mixins/EventedMixin
     */
    return dcl(null, {
        declaredClass:"xide.manager.Reloadable",
        vfsMounts: null,
        xideServiceClient: null,
        fileUpdateTimes:{},
        onXIDELoaded: function (min, WebSocket) {
            return;
            var thiz = this;
            var _ctorArgs = {
                delegate: {
                    onServerResponse: function (e) {
                        thiz.onXIDEMessage(utils.fromJson(e.data));
                    }
                }
            };
            try {
                var client = new WebSocket(_ctorArgs);
                utils.mixin(client, _ctorArgs);
                client.init({
                    options: {
                        host: 'http://0.0.0.0',
                        port: 9993,
                        channel: '',
                        debug: {
                            "all": false,
                            "protocol_connection": true,
                            "protocol_messages": true,
                            "socket_server": true,
                            "socket_client": true,
                            "socket_messages": true,
                            "main": true
                        }
                    }
                });
                client.connect();

            } catch (e) {
                console.error('create client with store : failed : ' + e);
            }

        },
        loadXIDE: function () {
            var thiz = this;
            this.subscribe(types.EVENTS.ON_NODE_SERVICE_STORE_READY, this.onNodeServiceStoreReady);
            require(['xide/min', 'xide/client/WebSocket'], function (min, WebSocket) {
                if (thiz._didXIDE) {
                    return;
                }
                thiz._didXIDE = true;
                thiz.onXIDELoaded(min, WebSocket);
            });
        },
        onXIDEMessage: function (data) {
            var thiz = this;
            thiz.publish(data.event, data);
            if (data.event === types.EVENTS.ON_FILE_CHANGED) {
                var _path = data.data.path;
                var timeNow = new Date().getTime();
                if (thiz.fileUpdateTimes[_path]) {
                    var last = thiz.fileUpdateTimes[_path];
                    var diff = timeNow - last;

                    if (diff < 30) {
                        thiz.fileUpdateTimes[_path] = timeNow;
                        return;
                    }
                }
                thiz.fileUpdateTimes[_path] = timeNow;

                //path is absolute and might look like: /PMaster/projects/xbox-app/client/src/lib/xfile/Views.js
                //fix windows path
                var path = utils.replaceAll('\\', '/', data.data.path);
                path = utils.replaceAll('//', '/', data.data.path);
                /**
                 * Check its a css file
                 */
                if (path == null || path.indexOf == null) {
                    console.error('on file changed : have no path, aborting');
                    return;
                }
                if (path.match(/\.css$/)) {
                    var newEvt = {
                        path: path
                    };
                    thiz.onCSSChanged(newEvt);
                }

                //generic
                if (path.match(/\.js$/)) {
                    var modulePath = data.data.modulePath;
                    if (modulePath) {
                        modulePath = modulePath.replace('.js', '');
                        var _re = require;//hide from gcc
                        //try pre-amd module
                        var module = null;
                        try {
                            module = _re(modulePath);
                        } catch (e) {

                        }
                        var _start = 'node_modules';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + _start.length, path.length);
                            libPath = libPath.replace('.js', '');
                            if (path.indexOf('xcfnode') != -1) {
                                path = libPath;
                                modulePath = path.replace('/xcfnode', 'xcfnode');
                            }
                        }
                        modulePath = utils.replaceAll('.', '/', modulePath);
                        setTimeout(function () {
                            thiz._reloadModule(modulePath, true);
                        }, 400);
                    }
                }
            }
        },
        onNodeServiceStoreReady: function (evt) {

        },
        mergeFunctions: function (target, source) {
            for (var i in source) {
                if (_.isFunction(source[i]) /*&& lang.isFunction(target[i])*/) {
                    target[i] = source[i];//swap
                }

            }
        },
        /**
         * Special case when module has been reloaded : update all functions in our singleton
         * managers!
         * @param evt
         */
        onModuleReloaded: function (evt) {
            if(evt._didHandle){
                return;
            }
            evt._didHandle=true;
            this.inherited(arguments);
            if(this.managers) {
                var newModule = evt.newModule;
                for (var i = 0; i < this.managers.length; i++) {
                    var manager = this.managers[i];
                    if (newModule.prototype
                        && newModule.prototype.declaredClass
                        && newModule.prototype.declaredClass === manager.declaredClass) {
                        this.mergeFunctions(manager, newModule.prototype);
                        if (manager.onReloaded) {
                            manager.onReloaded(newModule);
                        }
                        break;
                    }
                }
            }
        },
        _reloadModule: function (module, reload) {


            require.undef(module);
            var thiz = this;
            if (reload) {
                setTimeout(function () {
                    require([module], function (moduleLoaded) {
                        if(!moduleLoaded){
                            console.warn('invalid module');
                            return;
                        }
                        if (_.isString(moduleLoaded)) {
                            console.error('module reloaded failed : ' + moduleLoaded + ' for module : ' + module);
                            return;
                        }
                        console.log('did - re-require module : ' + module);
                        moduleLoaded.modulePath = module;
                        var obj = lang.getObject(utils.replaceAll('/', '.', module));
                        if (obj) {
                            thiz.mergeFunctions(obj.prototype, moduleLoaded.prototype);
                        }
                        thiz.publish(types.EVENTS.ON_MODULE_RELOADED, {
                            module: module,
                            newModule: moduleLoaded
                        });
                        thiz.publish(types.EVENTS.ON_MODULE_UPDATED,{
                            moduleClass:moduleLoaded.prototype.declaredClass,
                            moduleProto:moduleLoaded.prototype
                        });
                    });
                }, 500);
            }
        },
        onCSSChanged: function (evt) {
            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;
            var path = evt.path;
            path = utils.replaceAll('//', '/', path);
            path = path.replace('/PMaster/', '');
            var reloadFn = window['xappOnStyleSheetChanged'];
            if (reloadFn) {
                reloadFn(path);
            }
        },
        onDidChangeFileContent: function (evt) {
            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;
            if (!this.vfsMounts) {
                return;
            }
            if (!evt.path) {
                return;
            }
            var path = evt.path;
            if (path.indexOf('.css') != -1) {
                this.onCSSChanged(evt);
                return;
            }

            if (path.indexOf('resources') != -1 ||
                path.indexOf('meta') != -1 ||
                path.indexOf('.js') == -1) {
                return;
            }

            var mount = evt.mount.replace('/', '');
            var module = null;
            if (!this.vfsMounts[mount]) {
                return;
            }
            module = '' + evt.path;
            module = module.replace('./', '');
            module = module.replace('/', '.');
            module = module.replace('.js', '');
            module = utils.replaceAll('.', '/', module);
            var thiz = this;
            setTimeout(function () {
                thiz._reloadModule(module, true);
            }, 500);
        }
    });
});



;
/**
 * @module xide/manager/PluginManager
*/
define('xide/manager/PluginManager',[
    'dcl/dcl',
    'dojo/has',
    'xide/manager/ManagerBase',
    'xide/utils',
    'xide/types',
    'xide/factory',
    "dojo/Deferred",
    "dojo/promise/all"
], function (dcl, has, ManagerBase, utils, types, factory, Deferred, all){
    var _debug = false;

    /**
     * Plugin manager which provides loading of additional modules at any time after the main layer(s)
     * have been loaded.
     * @class module:xide/manager/PluginManager
     * @extends module:xide/mixins/ReloadMixin
     */
    return dcl(ManagerBase,{
        declaredClass:"xide.manager.PluginManager",
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Variables
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * When load() receives a module name without a slash, use this prefix
         *
         * @TODO: this must be changed into a map to configure this per 'run-time configuration'
         * @member string _defaultPackageLocationPrefix
         */
        _defaultPackageLocationPrefix:'../../',
        /**
         * When load() receives a module name without a slash, use this prefix
         * @member string _defaultPackageLocationSuffix
         */
        _defaultPackageLocationSuffix:'/component',
        /**
         * Whe loading a component, use this flags by default
         * @member module:xide.types.COMPONENT_FLAGS
         */
        _defaultComponentFlags:{
            /**
             * call load() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:LOAD
             */
            LOAD:1,
            /**
             * call run() when loaded
             * @enum module:xide.types.COMPONENT_FLAGS:RUN
             */
            RUN:2  //call run() when loaded
        },
        /**
         * Whe loading a component, mixin these properties/members
         * @member {Object}
         */
        defaultComponentMixin:function(flags){
            return {
                owner:this,
                ctx:this.ctx,
                flags:flags
            };
        },
        /**
         * List of modules to add to a components base classes. That will be used to add logging and others
         * @member {String[]}
         */
        componentBaseClasses:null,
        /**
         * Our context object
         * @member module: xide/manager/Context
         */
        ctx:null,
        /**
         * JSON data of plugin data
         * @member {Array}
         */
        pluginResources:null,
        /**
         * Array of plugin instances
         * @member {object[]}
         */
        pluginInstances:null,
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Components
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Called when component::load() is finish
         * @param component
         * @param flags
         * @param deferred
         * @private
         */
        _componentReady:function(component,flags,deferred){
            if (flags.RUN) {

                try {
                    component.run(this.ctx);//fire only, don't bother when it crashes
                }catch(e){
                    _debug && console.error('component: ' + component.getLabel() + ' crashed in run ' + e);
                }
            }
            return deferred.resolve(component);
        },
        /**
         * Called when a component has been loaded
         * @param component
         * @param flags
         * @param componentArguments
         * @param deferred
         * @private
         */
        _componentLoaded:function(component,flags,componentArguments,deferred){
            try {

                //add constructor arguments
                utils.mixin(componentArguments,this.defaultComponentMixin(flags));
                var componentInstance = factory.createInstance(component, componentArguments, this.componentBaseClasses);

                var _afterLoaded = function(componentInstance,flags,deferred){
                    this._componentReady(componentInstance,flags,deferred);
                }.bind(this);


                if (flags.LOAD) {
                    //call load, its async
                    componentInstance.load().then(function(){
                        _afterLoaded(componentInstance,flags,deferred);
                    });
                }else{
                    _afterLoaded(componentInstance,flags,deferred);
                }
            }catch(e){
                _debug && console.error('error in component creation!' + e);
                deferred.reject(arguments);
                logError(e);
            }

        },
        /**
         * Load a component
         *
         * @memberOf module:xide/manager/PluginManager#
         *
         * @param path {string} A require-js module path
         * @param {int} flags being used whilst loading
         * @param {object} componentArguments
         * @param packageLocation {string=}
         * @param packagePath {string=}
         */
        loadComponent:function(path,flags,componentArguments,packageLocation,packagePath){

            //defaults, sanitizing
            componentArguments = componentArguments ==='true' ? {} : componentArguments;

            path = path.indexOf('/') == -1 ? ( this._defaultPackageLocationPrefix + path + this._defaultPackageLocationSuffix ) : path;

            flags = flags!=null ? flags : this._defaultComponentFlags;

            var deferred = new Deferred(),
                self = this;

            var _component = utils.getObject(path);
            if(_component){
                //not loaded yet?
                if(_.isFunction(_component.then)){
                    _component.then(function(module){
                        self._componentLoaded(module,flags,componentArguments,deferred);
                    },function(err){
                        //shouldn't happen
                        console.error('error in loading component at path ' + path,err);
                    });
                }else{
                    //already loaded
                    this._componentLoaded(_component,flags,componentArguments,deferred);
                }
            }else{
                console.error('cant get object at ' + path);
            }

            _debug &&  console.log('load component ' + path);

            return deferred;
        },
        /**
         * Each component has a resource file within its directory with this pattern : resources-config.json.
         * When component is being loaded, we do load also client resources for that component (css,js,...)
         * @param component {xide.model.Component}
         * @param path
         */
        loadComponentResources:function(component,path){},
        /**
         * @TODO
         *
         * @param component
         */
        reloadComponent:function(component){},
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Plugins: to be removed soon.
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
         * @deprecated
         * @param pluginResources
         */
        loadPlugins:function(pluginResources){
            if(!has('plugins')) {
                return;
            }
            var dfd = new Deferred(),
                pluginPromises = [],
                thiz = this;

            this.pluginResources = pluginResources;
            this.pluginInstances = [];
            if(this.pluginResources){
                for(var i=0 ; i < this.pluginResources.length; i++){
                    var plug = this.pluginResources[i];
                    if(plug.type && plug.type=="JS-PLUGIN" && plug.path){
                        pluginPromises.push(this.loadComponent(plug.path,null,plug).then(function(component){
                            component.pluginResources = plug;
                            thiz.pluginInstances.push(component);
                        }));
                    }else{
                        _debug &&  console.warn('something wrong with plugin data');
                    }
                }
            }
            all(pluginPromises).then(function(){
                dfd.resolve(pluginPromises);
                _debug && console.log('plugins ready',thiz.pluginInstances);
                thiz.publish(types.EVENTS.ALL_PLUGINS_READY,{
                    instances:thiz.pluginInstances,
                    resources:pluginResources
                });
            });
            return dfd;
        }
    });
});;
/** module:xide/manager/Context **/
define('xide/manager/Context',[
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/has',
    'xide/manager/ContextBase',
    'xide/types',
    'xide/utils',
    'require',
    "dojo/promise/all",
    'xdojo/has!host-browser?xide/manager/Context_UI'
], function (dcl, Deferred, has, ContextBase, types, utils, _require, all, Context_UI) {

    !has('host-browser') && has.add('xlog', function () {
        return true;
    }, true);

    var isServer = has('host-node'),
        isBrowser = has('host-browser'),
        bases = isBrowser ? [ContextBase, Context_UI] : [ContextBase],
        debugFileChanges = false,
        debugModuleReload = true;

    /**
     * @class module:xide/manager/Context
     * @extends module:xide/manager/ContextBase
     */
    var Module = dcl(bases, {
        declaredClass: "xide.manager.Context",
        application: null,
        contextManager: null,
        fileManager: null,
        resourceManager: null,
        notificationManager: null,
        serviceObject: null,
        pluginManager: null,
        windowManager: null,
        logManager: null,
        mountManager: null,
        config: null,
        managers: null,
        namespace: 'xide.manager.',
        defaultNamespace: 'xide.manager.',
        vfsMounts: null,
        xideServiceClient: null,
        fileUpdateTimes: {},
        /***********************************************************************/
        /*
         * Global event handlers
         */
        onXIDEMessage: function (data, publish) {
            if (!data || !data.event) {
                return;
            }
            var thiz = this;
            if (data.event === types.EVENTS.ON_FILE_CHANGED) {
                debugFileChanges && console.log("on file changed ", data);
                //inotify plus
                if (data.data && data.data.mask && data.data.mask.indexOf('delete') !== -1) {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }

                if (data.data && data.data.type == 'delete') {
                    thiz.publish(types.EVENTS.ON_FILE_DELETED, data);
                    return;
                }
                var _path = data.data.path;
                var timeNow = new Date().getTime();
                if (thiz.fileUpdateTimes[_path]) {
                    var last = thiz.fileUpdateTimes[_path];
                    var diff = timeNow - last;
                    if (diff < 1000) {
                        thiz.fileUpdateTimes[_path] = timeNow;
                        return;
                    }
                }


                publish !== false && thiz.publish(data.event, data);
                thiz.fileUpdateTimes[_path] = timeNow;
                //path is absolute and might look like: /PMaster/projects/xbox-app/client/src/lib/xfile/Views.js
                //fix windows path
                var path = utils.replaceAll('\\', '/', data.data.path);
                path = utils.replaceAll('//', '/', data.data.path);
                path = path.replace(/\\/g, "/");

                if (path.indexOf('/build/') !== -1) {
                    return;
                }

                if (path == null || path.indexOf == null) {
                    return;
                }
                if (path.match(/\.css$/)) {
                    thiz.onCSSChanged({
                        path: path
                    });
                }
                /**
                 * Try generic
                 */
                if (path.match(/\.js$/)) {
                    var modulePath = data.data.modulePath;
                    if (modulePath) {
                        modulePath = modulePath.replace('.js', '');
                        var _re = _require;//hide from gcc
                        //try pre-amd module
                        var module = null;
                        try {
                            module = _re(modulePath);
                        } catch (e) {
                        }


                        //special: driver
                        var _start = 'data/system/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'system_drivers/' + libPath;
                        }

                        _start = 'user/drivers';
                        if (path.indexOf(_start) != -1) {
                            var libPath = path.substr(path.indexOf(_start) + (_start.length + 1), path.length);
                            libPath = libPath.replace('.js', '');
                            modulePath = 'user_drivers/' + libPath;
                        }


                        var resourceManager = this.getResourceManager(),
                            vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;

                        if (vfsConfig && vfsConfig['user_drivers']) {

                            if (path.indexOf(vfsConfig['user_drivers']) !== -1) {
                                var _start = vfsConfig['user_drivers'];
                                _start = _start.replace(/\/+$/, "");
                                var libPath = path.substr(path.indexOf(_start) + (_start.length + 1), path.length);
                                libPath = libPath.replace('.js', '');
                                modulePath = 'user_drivers/' + libPath;
                            }
                        }
                        modulePath = utils.replaceAll('.', '/', modulePath);
                        if (modulePath.indexOf('/build/') === -1 && !isServer) {
                            setTimeout(function () {
                                debugModuleReload && console.log('reloading module ' + modulePath);
                                thiz._reloadModule(modulePath, true);
                            }, 400);
                        }
                    }
                }
            }
        },
        onNodeServiceStoreReady: function (evt) {
        },
        mergeFunctions: function (target, source, oldModule, newModule) {
            for (var i in source) {
                var o = source[i];
                if (_.isFunction(source[i])) {
                    if (source[i] && target) {
                        target[i] = source[i];//swap
                    }
                }
            }
        },
        /***********************************************************************/
        /*
         * File - Change - Handlers
         */
        /**
         * Special case when module has been reloaded : update all functions in our singleton
         * managers!
         * @param evt
         */
        reloadModules: function (modules, patch) {
            var head = new Deferred(),
                pluginPromises = [],
                newModules = [],
                thiz = this;
            _require({
                cacheBust: 'time=' + new Date().getTime()
            });
            _.each(modules, function (module) {
                var oldModule = null,
                    dfd = new Deferred();
                if (patch !== false) {
                    oldModule = _require(module);
                }
                _require.undef(module);
                _require([module], function (moduleLoaded) {
                    oldModule && thiz.mergeFunctions(oldModule.prototype, moduleLoaded.prototype);
                    newModules.push(moduleLoaded);
                    dfd.resolve();
                });
                pluginPromises.push(dfd);
            });

            all(pluginPromises).then(function () {
                head.resolve(newModules);
                _require({
                    cacheBust: null
                });
            });
            return head;
        },
        _reloadModule: function (_module, reload) {
            var _errorHandle = null;
            var dfd = new Deferred();
            if (!isServer && _module.indexOf('nodejs') !== -1) {
                return;
            }

            _module = _module.replace('0/8', '0.8');
            _module = _module.replace('/src/', '/');
            function handleError(error) {
                debugModuleReload && console.log(error.src, error.id);
                debugModuleReload && console.error('require error ' + _module, error);
                _errorHandle.remove();
                dfd.reject(error);
            }


            //has its own impl.
            var obj = this.getModule(_module);
            if (obj && obj.prototype && obj.prototype.reloadModule) {
                return obj.prototype.reloadModule();
            }

            _errorHandle = _require.on("error", handleError);

            var oldModule = this.getModule(_module);
            if (!oldModule) {
                oldModule = typeof _module !== 'undefined' ? oldModule : null;
                if (!oldModule && typeof window !== 'undefined') {
                    //try global namespace
                    oldModule = utils.getAt(window, utils.replaceAll('/', '.', _module), null);
                    if (oldModule) {
                        obj = oldModule;
                    } else {
                        try {
                            oldModule = _require(utils.replaceAll('.', '/', _module));
                        } catch (e) {
                            //logError(e,'error requiring '+_module);
                            //dfd.reject(e);
                            debugModuleReload && console.log('couldnt require old module', _module);
                        }
                    }
                }
            }
            if (oldModule) {
                obj = oldModule;
            }

            //remove from dom
            if (isBrowser) {
                var scripts = document.getElementsByTagName('script');
                _.each(scripts, function (script) {
                    if (script && script.src && script.src.indexOf(_module) !== -1) {
                        script.parentElement.removeChild(script);
                    }
                })
            }

            _require.undef(_module);

            var thiz = this;
            if (reload) {
                setTimeout(function () {
                    _require({
                        cacheBust: 'time=' + new Date().getTime(),
                        waitSeconds: 5
                    });
                    try {
                        _require([_module], function (moduleLoaded) {
                            _require({
                                cacheBust: null
                            });
                            if (_.isString(moduleLoaded)) {
                                console.error('module reloaded failed : ' + moduleLoaded + ' for module : ' + _module);
                                return;
                            }
                            moduleLoaded.modulePath = _module;
                            if (obj) {
                                thiz.mergeFunctions(obj.prototype, moduleLoaded.prototype, obj, moduleLoaded);
                                if (obj.prototype && obj.prototype._onReloaded) {
                                    obj.prototype._onReloaded(moduleLoaded);
                                }
                            }

                            if (oldModule && oldModule.onReloaded) {
                                oldModule.onReloaded(moduleLoaded, oldModule);
                            }

                            thiz.publish(types.EVENTS.ON_MODULE_RELOADED, {
                                module: _module,
                                newModule: moduleLoaded
                            });

                            if (moduleLoaded.prototype && moduleLoaded.prototype.declaredClass) {
                                thiz.publish(types.EVENTS.ON_MODULE_UPDATED, {
                                    moduleClass: moduleLoaded.prototype.declaredClass,
                                    moduleProto: moduleLoaded.prototype
                                });
                            }
                            thiz.setModule(_module, moduleLoaded);
                            dfd.resolve(moduleLoaded);
                        });
                    } catch (e) {
                        console.error('error reloading module', e);
                        logError(e, 'error reloading module');
                        dfd.reject(e);
                    }
                }, 100);
            } else {
                dfd.resolve();
            }
            return dfd;
        },
        onCSSChanged: function (evt) {
            if (isBrowser) {
                var path = evt.path;
                var _p = this.findVFSMount(path);
                var _p2 = this.toVFSShort(path, _p);
                path = utils.replaceAll('//', '/', path);
                path = path.replace('/PMaster/', '');
                var reloadFn = window['xappOnStyleSheetChanged'];
                if (reloadFn) {
                    reloadFn(path);
                }
            }
        },
        onDidChangeFileContent: function (evt) {
            if (evt['didProcess']) {
                return;
            }
            evt['didProcess'] = true;
            if (!this.vfsMounts) {
                return;
            }
            if (!evt.path) {
                return;
            }
            var path = evt.path;
            if (path.indexOf('.css') != -1) {
                if (isBrowser) {
                    this.onCSSChanged(evt);
                }
                return;
            }

            if (path.indexOf('resources') != -1 ||
                path.indexOf('meta') != -1 ||
                path.indexOf('.js') == -1) {
                return;
            }

            var mount = evt.mount.replace('/', ''),
                module = null;

            if (!this.vfsMounts[mount]) {
                return;
            }
            module = '' + evt.path;
            module = module.replace('./', '');
            module = module.replace('/', '.');
            module = module.replace('.js', '');
            module = utils.replaceAll('.', '/', module);
            var thiz = this;
            setTimeout(function () {
                try {
                    thiz._reloadModule(module, true);
                } catch (e) {
                    console.error('error reloading module', e);
                }
            }, 100);

        },
        /***********************************************************************/
        /*
         * get/set
         */
        getMount: function (mount) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig && vfsConfig[mount]) {
                return vfsConfig[mount];
            }
            return null;
        },
        toVFSShort: function (path, mount) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig && vfsConfig[mount]) {
                var mountPath = vfsConfig[mount];
                mountPath = utils.replaceAll('//', '/', mountPath);
                mountPath = mountPath.replace(/\/+$/, "");
                if (path.indexOf(mountPath) !== -1) {
                    var _start = mountPath;
                    _start = _start.replace(/\/+$/, "");
                    var libPath = path.substr(path.indexOf(_start) + (_start.length + 1), path.length);
                    return libPath;
                }
            }
            return null;
        },
        findVFSMount: function (path) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig) {
                for (var mount in vfsConfig) {
                    var mountPath = vfsConfig[mount];
                    mountPath = utils.replaceAll('//', '/', mountPath);
                    mountPath = mountPath.replace(/\/+$/, "");
                    if (path.indexOf(mountPath) !== -1) {
                        return mount;
                    }
                }

            }
            return null;
        },
        getBlockManager: function () {
            return this.blockManager;
        },
        getPluginManager: function () {
            return this.pluginManager;
        },
        getService: function () {
            return this.serviceObject;
        },
        getFileManager: function () {
            return this.fileManager;
        },
        getResourceManager: function () {
            return this.resourceManager;
        },
        getMountManager: function () {
            return this.mountManager;
        },
        getContextManager: function () {
            return this.contextManager;
        },
        getLogManager: function () {
            return this.logManager;
        },
        getApplication: function () {
            return this.application;
        },
        /***********************************************************************/
        /*
         * STD - API
         */
        constructor: function (config, args) {
            this.managers = [];
            this.config = config;
            this.args = args;
            this.language = 'en';
            this.subscribe(types.EVENTS.ON_CHANGED_CONTENT, this.onDidChangeFileContent);
        },
        prepare: function () {
            if (this.config) {
                this.initWithConfig(this.config);
            }
        },
        /**
         * The config is put into the index.php as JSON. The server has also some data
         * which gets mixed into the manager instances.
         * @param config
         */
        initWithConfig: function (config) {
            if (config && config.mixins) {
                this.doMixins(config.mixins);
            }
        },
        isEditor: function () {
            return this.args && this.args.file;
        }
    });
    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');
    return Module;
});;
/** module:xide/manager/Context_UI **/
define('xide/manager/Context_UI',[
    'dcl/dcl',
    'dojo/Deferred',
    'dojo/has',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'require',
    'xide/manager/PluginManager',
    'xide/manager/WindowManager',
    'xide/manager/NotificationManager',
    'xide/manager/SettingsManager',
    'xide/editor/Registry',
    'xaction/ActionProvider',
    'xide/lodash',
    'xide/manager/Router'
], function (dcl, Deferred, has, types, utils, EventedMixin, _require, PluginManager,WindowManager, NotificationManager, SettingsManager, Registry, ActionProvider, _,Router) {


    !has('host-browser') && has.add('xlog', function () {
        return true;
    }, true);

    var isServer = has('host-node'),
        isBrowser = has('host-browser');
    /**
     * @class module:xide/manager/Context_UI
     * @extends module:xide/manager/ContextBase
     * @extends module:xaction/ActionProvider
     * @extends module:xide/mixins/EventedMixin
     * @extends module:xide/editor/Registry
     *
     */
    var Module = dcl([EventedMixin.dcl, ActionProvider.dcl, Registry], {
        declaredClass: "xide.manager.Context_UI",
        widgetManager: null,
        settingsManager: null,
        trackingManager: null,
        mainView: null,
        registerRoute:function(config){
            if(!this.routes){
                this.routes = [];
            }
            this.routes.push(config);
        },
        ready:function(){
            this.getRouter();
        },
        routes:null,
        /**
         * @type {module:xide/manager/Router}
         */
        router:null,
        /**
         *
         * @returns {module:xide/manager/Router}
         */
        getRouter:function(){
            if(!this.router || !this.router.match){
                this.router = new Router({routes:this.routes});
            }
            return this.router;
        },
        /**
         *
         * @returns {null|module:xide/manager/WindowManager}
         */
        getWindowManager: function () {
            return this.windowManager;
        },
        /**
         *
         * @returns {null|module:xideve/manager/WindowManager}
         */
        getWidgetManager: function () {
            return this.widgetManager;
        },
        getNotificationManager: function () {
            return this.notificationManager;
        },
        getSettingsManager: function () {
            return this.settingsManager;
        },
        getTrackingManager: function () {
            return this.trackingManager;
        },
        getMainView: function () {
            return this.mainView;
        },
        /**
         * Run global actions here
         * @param action {string|module:xaction/ActionModel}
         * @returns {module:dojo/Deferred}
         */
        runAction: function (action) {
            action = this.getAction(action);
            var actionDfd = this.inherited(arguments),
                who = this;
            if (actionDfd == null && action.handler) {
                actionDfd = action.handler.apply(who, [action]);
            }
            return actionDfd;
        },
        /***********************************************************************/
        /*
         * Editors
         */
        /**
         * Create editor
         * @param ctrArgs {object} ctor args
         * @param item {module:xfile/model/File}
         * @param editorOverrides
         * @param where {HTMLElement|module:xide/widgets/_Widget}
         * @param owner {*|null}
         * @returns {module:dojo/Deferred}
         */
        createEditor: function (ctrArgs, item, editorOverrides, where, owner) {
            var dfd = new Deferred(),
                registerInWindowManager = owner && owner.registerEditors === true ? true : true;

            if (_.isArray(item)) {
                item = item[0];
            }

            var thiz = this,
                title = item && item.name ? item.name : (utils.pathinfo(item.path, 'PATHINFO_FILENAME') + '.' + utils.pathinfo(item.path, 'PATHINFO_EXTENSION')),
                ctx = this,
                mainView = ctx.mainView,
                docker = mainView.getDocker(),
                ctrArgsFinal = {
                    ctx: ctx,
                    config: this.config,
                    item: item,
                    title: title,
                    closeable: true,
                    closable: true
                };
            utils.mixin(ctrArgsFinal, ctrArgs);
            if (_.isString(ctrArgs.editorClass)) {
                //test this really exists
                if (!this.getModule(ctrArgs.editorClass)) {
                    return null;
                }
            }

            if (ctrArgs.runFunctionOnly === true) {
                ctrArgs.editorClass.apply(this, [item]);
                dfd.resolve(null);
                return dfd;
            }

            where = where || mainView.layoutCenter;

            var root = docker.addTab(null, {
                title: title,
                target: where ? where._parent : null,
                icon: 'fa-code'
            });

            ctrArgsFinal._parent = root;

            //- tell everybody
            thiz.publish(types.EVENTS.ON_CREATE_EDITOR_BEGIN, {
                args: ctrArgsFinal,
                item: item
            }, this);


            root.set('loading', true);
            var editor = utils.addWidget(ctrArgs.editorClass, ctrArgsFinal, thiz, root, true, null, null, null, editorOverrides);

            //- tell everybody
            thiz.publish(types.EVENTS.ON_CREATE_EDITOR_END, {
                args: ctrArgsFinal,
                item: item,
                editor: editor
            }, this);

            //- use openItem if possible
            if (editor.openItem) {
                var _dfd = editor.openItem(item);
                dfd.resolve(editor);
                if (registerInWindowManager) {
                    this.getWindowManager().registerView(editor, false);
                }
            }
            //-resize if possible
            root.resize && root.resize();

            if (dfd.then) {
                dfd.then(function () {
                    root.set('loading', false);
                })
            }
            return dfd;
        },
        /**
         *
         * @param name
         * @param extensions
         * @param iconClass
         * @param owner {module:xide/model/Component|*|null}
         * @param isDefault
         * @param onEdit
         * @param editorClass
         * @param editorArgs
         */
        registerEditorExtension: function (name, extensions, iconClass, owner, isDefault, onEdit, editorClass, editorArgs) {
            iconClass = iconClass || 'el-icon-brush';
            var thiz = this,
                _editorArgs = {
                    name: name,
                    extensions: extensions,
                    onEdit: onEdit,
                    iconClass: iconClass,
                    owner: this,
                    isDefault: isDefault != null ? isDefault : false,
                    editorClass: editorClass
                };

            if (editorArgs) {
                _editorArgs = utils.mixin(_editorArgs, editorArgs);
            }
            if (!onEdit) {
                _editorArgs.onEdit = function (item, _owner, overrides) {
                    //some components may have an additional bootstrap in top of 'run':
                    if (owner && owner.onCreateEditor) {
                        var dfd = new Deferred();
                        owner.onCreateEditor().then(function () {
                            var editor = thiz.createEditor(_editorArgs, item, overrides, null, _owner);
                            dfd.resolve(editor);
                        });
                        return dfd;
                    }

                    return thiz.createEditor(_editorArgs, item, overrides, null, _owner);
                }
            }

            if (_.isString(extensions) && extensions.indexOf(',') == -1) {
                types.registerCustomMimeIconExtension(extensions, iconClass);
            }
            Registry.onRegisterEditor(_editorArgs);
            this.publish(types.EVENTS.REGISTER_EDITOR, _editorArgs);
        },
        /***********************************************************************/
        /*
         * Global event handlers
         */
        /***********************************************************************/
        /*
         * STD - API
         */
        initManagers: function () {

            if (this.settingsManager) {
                this.settingsManager.init();
            }

            if (this.storeDelegate) {
                this.storeDelegate.appService = this.settingsManager;
            }

            if (this.settingsManager) {
                this.settingsManager.serviceObject = this.serviceObject;
                this.settingsManager.ctx = this;
                this.settingsManager.config = this.config;
                this.settingsManager.init();

            }
            if (this.storeDelegate) {
                this.storeDelegate.serviceObject = this.serviceObject;
            }


            if (has('plugins') && typeof xappPluginResources != 'undefined' && this.pluginManager) {
                this.pluginsLoading = this.pluginManager.loadPlugins(xappPluginResources);
            }

            if (this.notificationManager) {
                this.notificationManager.init();
                this.notificationManager.postMessage({
                    message: 'Loading application, please wait!',
                    duration: 1000,
                    showCloseButton: true
                });
            }
            this.application && this.application.init();
            this.windowManager && this.windowManager.init();
            var self = this;
            this.registerEditorExtension('Browser', 'php|html|mp4|doc|xls|pdf|zip|tar|iso|avi|gz|mp3|mkv|ogg|png|jpg|cfhtml', 'fa-play-circle-o', this, false, null, function (item) {
                window.open(self.getFileManager().getImageUrl(item));
            }, {
                ctx: this.ctx,
                registerView: false,
                runFunctionOnly: true,
                isDefault: false
            });

        },
        constructManagers: function () {
            this.pluginManager = this.createManager(PluginManager);
            this.windowManager = this.createManager(WindowManager);
            this.notificationManager = this.createManager(NotificationManager);
            this.settingsManager = this.createManager(SettingsManager);
        }
    });

    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');
    dcl.chainAfter(Module, 'ready');

    return Module;
});;
/** module:xide/manager/Router **/
define('xide/manager/Router',['xide/utils'], function (utils) {
    /**
     * @param {Object} object
     * @param {Function} callback
     * @param {Object} [ctx]
     * @returns {Object}
     */
    var map = function (object, callback, ctx) {
        var copy = {};
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                copy[key] = callback.call(ctx, object[key], key, object);
            }
        }
        return copy;
    };

    /**
     * merges objects
     * @returns {{}}
     */
    var merge = function () {
        var result = {};
        Array.prototype.forEach.call(arguments, function (o) {
            for (var key in o) {
                if (o.hasOwnProperty(key)) {
                    result[key] = o[key];
                }
            }
        });
        return result;
    };

    /**
     * @param {*} o
     * @returns {*}
     */
    var clone = function (o) {
        if (Array.isArray(o)) {
            return o.map(clone);
        }
        if (o instanceof RegExp || [
                'string',
                'number',
                'boolean',
                'object'
            ].indexOf(typeof o) > -1 || o == null) {
            return o;
        }
        return map(o, clone);
    };

    /**
     * @typedef {Object} module:xide/interface/RouteDefinition
     * @property {String} id
     * @property {String} path
     * @property {String} [host]
     * @property {String} [prefix]
     * @property {Object.<String|Number>} [defaults]
     * @property {Object.<String>} [requirements]
     * @property {Array.<String>} [methods]
     * @property {Array.<String>} [schemes]
     * @property {module:xide/interface/Route} delegate
     */

    /**
     * @typedef {Object} RoutesDefinition
     * @property {String} [prefix]
     * @property {Array.<RouteDefinition|RoutesDefinition>} routes
     */

    /**
     * @typedef {Object} RouteDefinitionParsed
     * @property {String} id
     * @property {RegExp} pattern
     * @property {String} path
     * @property {Array.<String>} parameters
     * @property {RegExp} hostPattern
     * @property {String} host
     * @property {Array.<String>} hostParameters
     * @property {Object.<RegExp>} requirements
     * @property {Object.<String>} defaults
     * @property {Array.<String>} methods
     * @property {Array.<String>} schemes
     * @property {{RouteDefinition}} definition
     */

    /**
     * @typedef {Object} Route
     * @property {String} id
     * @property {RouteDefinition} definition
     * @property {Object.<String>} [parameters]
     */

    /**
     * @class module:xide/manager/Router
     * @param {Object} options
     * @param {Array.<RouteDefinition|RoutesDefinition>} options.routes
     * @param {Array.<String>} [options.defaultMethods=['GET', 'POST', 'PUT', 'DELETE']]
     * @param {Array.<String>} [options.defaultSchemes=['http', 'https']]
     * @param {Object} [options.symbols]
     * @param {String} [options.symbols.defaultParameterRequirement='[^\\/.]*']
     * @param {String} [options.symbols.parametersDelimiters='\.|\/']
     * @param {String} [options.symbols.parameterStart='\{']
     * @param {String} [options.symbols.parameterMatcher='.*?']
     * @param {String} [options.symbols.parameterEnd='\}']
     */
    var RouterBase = function (options) {
        var symbols = options.symbols || {},
            paramsDelimiters = symbols.parametersDelimiters || '\\.|\\/',
            paramStart = symbols.parameterStart || '\\{',
            paramMatcher = symbols.parameterMatcher || '.*?',
            paramEnd = symbols.parameterEnd || '\\}';

        /**
         * @const {{regexp: RegExp, parameters: Array}}
         * @private
         */
        this._NO_HOST = {
            regexp: /.*/,
            parameters: []
        };

        /**
         * @type {string}
         * @private
         */
        this._defaultParameterRequirement = symbols.defaultParameterRequirement || '[^\\/.]*';

        /**
         * @type {RegExp}
         * @private
         */
        this._paramsReplaceRegExp = new RegExp('(' + paramsDelimiters + ')?' + paramStart +
            '(' + paramMatcher + ')' + paramEnd, 'g');

        /**
         * @type {Array.<String>}
         * @private
         */
        this._defaultMethods = options.defaultMethods || ['GET', 'POST', 'PUT', 'DELETE'];

        /**
         * @type {Array.<String>}
         * @private
         */
        this._defaultSchemes = options.defaultSchemes || ['http', 'https'];

        /**
         * @type {Array.<RouteDefinition>}
         * @private
         */
        this._routesDefinitions = this._unifyRoutes(options.routes);

        /**
         * @type {Array.<RouteDefinitionParsed>}
         * @private
         */
        this._routes = this._parseRoutes(this._routesDefinitions);

        /**
         * @type {Object.<RouteDefinitionParsed>}
         * @private
         */
        this._routeIdToParsedDefinitionMap = {};
    };

    /**
     * @param {Array.<RouteDefinition|RoutesDefinition>} routes
     * @param {RouteDefinition} [parentRoute]
     * @returns {Array.<RouteDefinition>}
     * @private
     */
    RouterBase.prototype._unifyRoutes = function (routes, parentRoute) {
        var unifiedRoutes = [];
        routes.forEach(function (route) {
            unifiedRoutes = unifiedRoutes.concat(this._unifyRoute(route, parentRoute));
        }, this);
        return unifiedRoutes;
    };

    /**
     * @param {RouteDefinition|RoutesDefinition} route
     * @param {RouteDefinition} [parentRoute]
     * @returns {RouteDefinition|Array.<RouteDefinition>}
     * @private
     */
    RouterBase.prototype._unifyRoute = function (route, parentRoute) {
        parentRoute = parentRoute || {};
        route.defaults = map(merge(parentRoute.defaults, route.defaults), function (prop) {
            return String(prop);
        });
        route.requirements = merge(parentRoute.requirements, route.requirements);
        if (parentRoute.prefix) {
            route.path = parentRoute.prefix + route.path;
            route.prefix = route.prefix ? parentRoute.prefix + route.prefix : parentRoute.prefix;
        }
        route.host = route.host || parentRoute.host;
        route.methods = route.methods || parentRoute.methods || this._defaultMethods;
        route.schemes = route.schemes || parentRoute.schemes || this._defaultSchemes;
        for (var key in parentRoute) {
            if (parentRoute.hasOwnProperty(key) && key !== 'routes' && !route[key]) {
                route[key] = parentRoute[key];
            }
        }
        return route.routes ? this._unifyRoutes(route.routes, route) : route;
    };

    /**
     * @param {Array.<RouteDefinition|RoutesDefinition>} routes
     * @returns {Array.<RouteDefinitionParsed>}
     * @private
     */
    RouterBase.prototype._parseRoutes = function (routes) {
        return routes.map(this._parseRoute, this);
    };

    /**
     * @param {RouteDefinition} route
     * @param {Number} i
     * @returns {RouteDefinitionParsed}
     * @private
     */
    RouterBase.prototype._parseRoute = function (route, i) {
        var defaults = route.defaults,
            requirements = route.requirements,
            path = route.path,
            host = route.host,
            parsedHost = host ? this._parsePath(host, requirements, defaults) : this._NO_HOST,
            parsedPath = this._parsePath(path, requirements, defaults);
        return {
            id: route.id,
            pattern: parsedPath.regexp,
            path: path,
            parameters: parsedPath.parameters,
            hostPattern: parsedHost.regexp,
            host: host,
            hostParameters: parsedHost.parameters,
            requirements: map(requirements, function (prop) {
                return new RegExp('^' + prop + '$');
            }),
            defaults: defaults,
            methods: route.methods,
            schemes: route.schemes,
            definition: this._routesDefinitions[i]
        };
    };

    /**
     * @param {String} path
     * @param {Object} [requirements]
     * @param {Object} [defaults]
     * @returns {{regexp: RegExp, parameters: Array.<String>}}
     * @private
     */
    RouterBase.prototype._parsePath = function (path, requirements, defaults) {
        var parameters = [],
            defaultParameterRequirement = this._defaultParameterRequirement,
            regexp = new RegExp('^' +
                path
                    .replace(/([\/\.\|])/g, '\\$1')
                    .replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
                        var optional = parameterName in defaults;
                        parameters.push(parameterName);
                        return (delimiter || '') + (optional && delimiter ? '?' : '') +
                            '(' + (requirements[parameterName] ? requirements[parameterName] : defaultParameterRequirement) + ')' +
                            (optional ? '?' : '');
                    }) +
                '$');
        return {
            regexp: regexp,
            parameters: parameters
        };
    };

    /**
     * @param {{path: String, method: String, host: String|undefined, scheme: String|undefined}} request
     * @returns {?Route}
     * @public
     */
    RouterBase.prototype.match = function (request) {
        var routes = this._routes,
            route,
            pathParts = request.path.split('?'),
            path = pathParts[0],
            query = pathParts[1] ? this._parseQuery(pathParts[1]) : null,
            execPathResult,
            execHostResult,
            isMethodValid,
            isSchemeValid;

        request.method = 'GET';

        for (var i = 0, l = routes.length; i < l; i++) {
            route = routes[i];
            execPathResult = route.pattern.exec(path);
            if (!execPathResult) {
                continue;
            }
            execHostResult = route.hostPattern.exec(request.host);
            if (!execHostResult) {
                continue;
            }
            isMethodValid = route.methods.indexOf(request.method) > -1;
            if (!isMethodValid) {
                continue;
            }
            isSchemeValid = !request.scheme || route.schemes.indexOf(request.scheme) > -1;
            if (isSchemeValid) {
                execPathResult.shift();
                execHostResult.shift();
                return {
                    id: route.id,
                    parameters: this._retrieveParameters(route, execPathResult, execHostResult, query),
                    definition: clone(this._routesDefinitions[i])
                };
            }
        }
        return null;
    };

    /**
     * @param {String} query
     * @returns {{}}
     * @protected
     */
    RouterBase.prototype._parseQuery = function (query) {
        var obj = {};

        if (typeof query !== 'string' || query.length === 0) {
            return obj;
        }

        var regexp = /\+/g;
        query = query.split('&');

        var len = query.length;

        for (var i = 0; i < len; ++i) {
            var x = query[i].replace(regexp, '%20'),
                idx = x.indexOf('='),
                kstr, vstr, k, v;

            if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
            } else {
                kstr = x;
                vstr = '';
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!obj.hasOwnProperty(k)) {
                obj[k] = v;
            } else if (Array.isArray(obj[k])) {
                obj[k].push(v);
            } else {
                obj[k] = [obj[k], v];
            }
        }

        return obj;
    };

    /**
     * @param {RouteDefinitionParsed} route
     * @param {Array.<String>} parsedParameters
     * @param {Array.<String>} parsedHostParameters
     * @param {Object.<String>} [query={}]
     * @returns {Object.<String>}
     * @private
     */
    RouterBase.prototype._retrieveParameters = function (route, parsedParameters, parsedHostParameters, query) {
        var parameters = query || {};
        for (var key in route.defaults) {
            if (route.defaults.hasOwnProperty(key)) {
                parameters[key] = route.defaults[key];
            }
        }
        this._extendParameters(parsedParameters, route.parameters, parameters);
        this._extendParameters(parsedHostParameters, route.hostParameters, parameters);
        return parameters;
    };

    /**
     * @param {Array.<String>} input parameters values
     * @param {Array.<String>} names parameters names
     * @param {Object.<String>} output parameters names: parameters values
     * @private
     */
    RouterBase.prototype._extendParameters = function (input, names, output) {
        for (var i = 0, l = names.length; i < l; i++) {
            if (input[i] === undefined) {
                break;
            }
            output[names[i]] = decodeURIComponent(input[i]);
        }
    };

    /**
     * @param {String} id
     * @param {Object.<String>} [params]
     * @returns {String}
     * @throws Error if required parameter is not given
     * @throws Error if parameter value is not suits requirements
     * @throws Error if route is not defined
     * @throws URIError
     * @public
     */
    RouterBase.prototype.generate = function (id, params) {
        var routes = this._routes,
            route;
        for (var i = 0, l = routes.length; i < l; i++) {
            route = routes[i];
            if (route.id === id) {
                return this._generate(route, merge({}, params));
            }
        }
        throw new Error('No such route: ' + id);
    };

    /**
     * @param {RouteDefinitionParsed} route
     * @param {Object.<String>} [params]
     * @returns {String}
     * @throws Error if required parameter is not given
     * @throws Error if parameter value is not suits requirements
     * @private
     */
    RouterBase.prototype._generate = function (route, params) {
        var path = route.path,
            generatedPath,
            host = route.host,
            generatedHost,
            defaults = route.defaults,
            requirements = route.requirements,
            _this = this;
        generatedPath = path.replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
            delimiter = delimiter || '';
            var optional = parameterName in defaults,
                exists = params && parameterName in params;
            if (exists) {
                return _this._getParameterValue(parameterName, params, requirements, delimiter);
            } else if (!optional) {
                _this._throwParameterNeededError(parameterName, route.id);
            }

            var hasFilledParams = false;
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    if (route.parameters.indexOf(key) > -1) {
                        hasFilledParams = true;
                        break;
                    }
                }
            }

            return hasFilledParams ? delimiter + defaults[parameterName] : '';
        });

        if (host) {
            generatedHost = host.replace(this._paramsReplaceRegExp, function (match, delimiter, parameterName) {
                var optional = parameterName in defaults,
                    exists = params && parameterName in params;
                delimiter = delimiter || '';
                if (exists) {
                    return _this._getParameterValue(parameterName, params, requirements, delimiter);
                } else if (optional) {
                    return delimiter + defaults[parameterName];
                } else {
                    _this._throwParameterNeededError(parameterName, route.id);
                }
            });
        }

        var query = this._generateQuery(params);

        if (query) {
            generatedPath += '?' + query;
        }

        return generatedHost ? route.schemes[0] + '://' + generatedHost + generatedPath : generatedPath;
    };

    /**
     * @param {Object.<String>} params
     * @returns {String}
     * @protected
     */
    RouterBase.prototype._generateQuery = function (params) {
        var query = '';
        for (var key in params) {
            if (params.hasOwnProperty(key)) {
                query += (query.length ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
            }
        }
        return query;
    };

    /**
     * @param {String} parameterName
     * @param {Object.<String>} params
     * @param {Object.<RegExp>} requirements
     * @param {String} delimiter
     * @returns {String}
     * @throws Error if parameter value is invalid
     * @private
     */
    RouterBase.prototype._getParameterValue = function (parameterName, params, requirements, delimiter) {
        var value = params[parameterName];
        delete params[parameterName];
        if (requirements[parameterName] && !requirements[parameterName].test(value)) {
            throw new Error('Parameter "' + parameterName + '" has bad value "' + value + '", not suitable for path generation');
        }
        return delimiter + encodeURIComponent(value);
    };

    /**
     * @param {String} parameterName
     * @param {String} routeId
     * @private
     */
    RouterBase.prototype._throwParameterNeededError = function (parameterName, routeId) {
        throw new Error('Parameter "' + parameterName + '" is needed for route "' + routeId + '" generation');
    };

    /**
     * @param {String} routeId
     * @returns {?RouteDefinitionParsed}
     * @public
     * @throws if route is not defined
     */
    RouterBase.prototype.getRouteInfo = function (routeId) {
        if (!this._routeIdToParsedDefinitionMap[routeId]) {
            for (var i = 0, l = this._routes.length; i < l; i++) {
                if (this._routes[i].id === routeId) {
                    this._routeIdToParsedDefinitionMap[routeId] = this._routes[i];
                    break;
                }
            }
        }

        if (!this._routeIdToParsedDefinitionMap[routeId]) {
            throw new Error('No such route: ' + routeId);
        }

        return clone(this._routeIdToParsedDefinitionMap[routeId]);
    };

    return RouterBase;
});;
define('xaction/ActionProvider',[
    "xdojo/declare",
    'dcl/dcl',
    "xide/types",
    "xide/utils",
    "xide/model/Path",
    'xaction/ActionStore',
    'xaction/Action',
    'xide/Keyboard',
    'xide/mixins/EventedMixin',
    'xaction/DefaultActions',
    'xide/lodash'
], function (declare, dcl, types, utils, Path, ActionStore, Action, Keyboard, EventedMixin, DefaultActions,_) {

    var Implementation = {
        /**
         * @type module:xaction/ActionStore
         */
        actionStore: null,
        actions: null,
        allowActionOverride: true,
        sortGroups: function (groups, groupMap) {
            groups = groups.sort(function (a, b) {
                if (groupMap[a] != null && groupMap[b] != null) {
                    var orderA = groupMap[a];
                    var orderB = groupMap[b];
                    return orderB - orderA;
                }
                return 100;
            });
            return groups;
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(_.map(items, 'command'), false);
        },
        /////////////////////////////////////////////////////
        //
        //  Store Based Extension -
        //
        /////////////////////////////////////////////////////
        /**
         * Update all actions referencing widgets
         */
        refreshActions: function () {
            var allActions = this.getActions();
            for (var i = 0; i < allActions.length; i++) {
                var action = allActions[i];
                if (action.refresh) {
                    action.refresh();
                }
            }
        },
        getAction: function (mixed) {
            if (_.isString(mixed)) {
                return this.getActionStore().getSync(mixed);
            }
            return mixed;
        },
        clearActions: function () {
            var store = this.getActionStore(),
                actions = store ? store.query() : [];

            _.each(actions, function (action) {
                action && store.removeSync(action.command);
            });
            store && store.setData([]);
        },
        destroy: function () {
            this.clearActions();
            return this.inherited(arguments);
        },
        /**
         *
         * @param title
         * @param command
         * @param group
         * @param icon
         * @param handler
         * @param accelKey
         * @param keyCombo
         * @param keyProfile
         * @param keyTarget
         * @param keyScope
         * @param mixin
         * @returns {xaction/Action}
         */
        __createAction: function (title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope, mixin) {
            icon = icon || types.ACTION_ICON[command];
            var args = {accelKey: accelKey};
            utils.mixin(args, mixin);
            var action = Action.createDefault(title, icon, command, group, handler, args);
            if (keyCombo) {
                var keyboardMappings;
                if (this.keyboardMappings) {
                    keyboardMappings = this.keyboardMappings;
                } else {
                    action.keyboardMappings = keyboardMappings = [];
                }
                var mapping = Keyboard.defaultMapping(keyCombo, handler, keyProfile || types.KEYBOARD_PROFILE.DEFAULT, keyTarget, keyScope, [action]);
                mapping = this.registerKeyboardMapping(mapping);
                keyboardMappings.push(mapping);
                action.keyboardMappings = keyboardMappings;
            }
            return action;
        },
        updateAction: function (action, what, value) {
            action = action || this.getAction(action);
            if (action) {
                action.set(what, value);
                setTimeout(function () {
                    action.getReferences().forEach(function (ref) {
                        ref.set(what, value);
                    });
                }, 100);
            }
        },
        _completeActions: function (actions) {
            var result = [];
            var keyTarget = this.getKeyTarget ? this.getKeyTarget() : null;
            for (var i = 0; i < actions.length; i++) {
                var config = actions[i],
                    action;

                if (!config) {
                    continue;
                }

                if (!(config instanceof Action)) {
                    action = this.__createAction(
                        config.title,
                        config.command,
                        config.group,
                        config.icon,
                        config.handler,
                        config.accelKey,
                        config.keyCombo,
                        config.keyProfile,
                        keyTarget || config.keyTarget,
                        config.keyScope,
                        config.mixin);

                    action.parameters = config;
                } else {
                    action = config;
                }
                this._addAction(result, action);
            }
            if (this.keyboardMappings) {
                console.error('have mappings');
            }
            _.each(this.keyboardMappings, function (mapping) {
                this.registerKeyboardMapping(mapping);
            }, this);
            return result;
        },
        createActionStore: function () {
            if (!this.actionStore) {
                var _actions = this._completeActions(this.actions || []);
                this.actionStore = new ActionStore({
                    id: utils.createUUID(),
                    data: _actions,
                    observedProperties: [
                        "value",
                        "icon",
                        "label"
                    ],
                    tabOrder: this.tabOrder,
                    groupOrder: this.groupOrder,
                    tabSettings: this.tabSettings,
                    menuOrder: this.menuOrder
                });
            }
            return this.actionStore;
        },
        /**
         * Get all actions via query from Action store
         * @param mixed
         * @param allowCache
         * @returns {*}
         */
        getActions: function (mixed, allowCache) {
            if (!mixed && allowCache !== false && this.__actions) {
                return this.__actions;
            }
            var query = mixed;
            //no query or function given
            if (!mixed) {
                query = {
                    command: /\S+/
                };
            }
            this.__actions = this.getActionStore().query(query);
            return this.__actions;

        },
        /**
         * Safe getter for action store
         * @returns {*}
         */
        getActionStore: function () {
            return this.createActionStore();
        },
        /**
         * Create action store upon construction
         */
        postMixInProperties: function () {
            this.inherited && this.inherited(arguments);
            this.createActionStore();
        },
        addActions: function (actions) {
            var store = this.getActionStore();
            if (!store['subscribedToUpdates_' + this.id]) {
                store['subscribedToUpdates_' + this.id] = true;
                this.addHandle('update', store.on('update', function (evt) {
                    var action = evt.target;
                    if (action._isCreating || !evt.property) {
                        return;
                    }
                    if (action && action.onChange) {
                        action.onChange(evt.property, evt.value, action);
                    }

                }));
            }
            var result = [];
            this._emit('onAddActions', {
                actions: actions,
                permissions: this.permissions,
                store: store
            });

            //remove existing
            this.allowActionOverride && _.each(actions, function (action) {
                if (action) {
                    var existing = store.getSync(action.command);
                    if (existing) {
                        store.removeSync(existing.command);
                    }
                }
            });
            actions = this._completeActions(actions);

            _.each(actions, function (action) {
                if (this.allowActionOverride && store.getSync(action.command)) {
                    store.removeSync(action.command);
                }
                var _action = store.putSync(action);
                result.push(_action);
                _action._isCreating = true;
                _action.onCreate && _action.onCreate(_action);
                this._emit('onAddAction', _action);
                _action._isCreating = false;
            }.bind(this));
            return result;

        },
        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param props
         * @param mixin
         * @returns {*}
         */
        createActionShort: function (label, command, icon, props, mixin) {
            return this.createAction(_.extend({
                label: label,
                command: command,
                icon: icon,
                mixin: props && props.mixin ? props.mixin : mixin
            }, props));
        },
        /**
         *
         * @param options
         * @returns {*}
         */
        createAction2: function (options) {
            var thiz = this,
                action = null,
                mixin = options.mixin || {},
                owner = options.owner || mixin.owner || thiz,
                permissions = options.permissions || this.permissions || [],
                command = options.command,
                keycombo = options.keycombo,
                label = options.label,
                icon = options.icon,
                tab = options.tab,
                group = options.group,
                filterGroup = options.filterGroup,
                onCreate = options.onCreate,
                handler = options.handler,
                container = options.container || thiz.domNode,
                shouldShow = options.shouldShow,
                shouldDisable = options.shouldDisable;

            utils.mixin(mixin, {
                owner: owner,
                onChange: options.onChange

            });

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {

                handler = handler || DefaultActions.defaultHandler;
                if (keycombo) {
                    if (_.isString(keycombo)) {
                        keycombo = [keycombo];
                    }
                    mixin.tooltip = keycombo.join('<br/>').toUpperCase();
                }

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);
                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        /**
         * Create Action
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         * @param permissions
         * @param container
         * @param owner
         * @returns {*}
         */
        createAction: function (label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, permissions, container, owner) {
            if (arguments.length == 1) {
                return this.createAction2(arguments[0]);
            }
            var thiz = this,
                action = null;

            mixin = mixin || {};
            utils.mixin(mixin, {owner: owner || thiz});

            if (mixin.addPermission || DefaultActions.hasAction(permissions, command)) {
                if (!handler) {
                    handler = function (action) {
                        this.runAction && this.runAction.apply(this, [action]);
                    };
                }
                keycombo && _.isString(keycombo) && (keycombo = [keycombo]);

                action = DefaultActions.createAction(label, command, icon, keycombo, tab, group, filterGroup, onCreate, handler, mixin, shouldShow, shouldDisable, container || thiz.domNode);

                if (owner && action && owner.addAction) {
                    owner.addAction(null, action);
                }
                return action;
            }
        },
        addAction: function (where, action) {
            var actions = where || [];
            var eventCallbackResult = this._emit('addAction', action);
            if (eventCallbackResult === false) {
                return false;
            } else if (_.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        /**
         *
         * @param where
         * @param action
         * @returns {boolean}
         */
        _addAction: function (where, action) {
            var actions = where || [],
                eventCallbackResult = this._emit('addAction', action);

            if (eventCallbackResult === false) {
                return false;
            } else if (utils.isObject(eventCallbackResult)) {
                utils.mixin(action, eventCallbackResult);
            }
            actions.push(action);
            return true;
        },
        hasAction: function (action) {
            return DefaultActions.hasAction(this.permissions, action);
        }
    };

    /**
     * Provides tools to deal with 'actions' (xaction/Action). This is the model part for actions which is being used
     * always together with the render part(xide/widgets/EventedMixin) in a subclass.
     *
     * @class module:xide/mixins/ActionProvider
     * @extends module:xide/mixins/EventedMixin
     */
    var Module = declare("xaction/ActionProvider", [EventedMixin, Keyboard], Implementation);
    Module.dcl = dcl([EventedMixin.dcl, Keyboard.dcl], Implementation);
    return Module;
});
;
/** @module xaction/DefaultActions **/
define('xaction/DefaultActions',[
    "dcl/dcl",
    'dcl/inherited',
    "xdojo/declare",
    'xide/types',
    'xide/utils',
    'xlang/i18'
], function (dcl,inherited,declare,types,utils,i18) {
    /**
     * @mixin module:xide/action/DefaultActions
     */
    var Module = declare("xaction/DefaultActions", null , {});
    /**
     *
     * @param title
     * @param command
     * @param group
     * @param icon
     * @param handler
     * @param accelKey
     * @param keyCombo
     * @param keyProfile
     * @param keyTarget
     * @param keyScope
     * @param mixin
     * @returns {{title: *, command: *, group: *, icon: *, handler: *, accelKey: *, keyCombo: *, keyProfile: *, keyTarget: *, keyScope: *}}
     */
    Module.createActionParameters=function(title, command, group, icon, handler, accelKey, keyCombo, keyProfile, keyTarget, keyScope,mixin){
        return {
            title:title,
            command: command,
            group: group,
            icon: icon,
            handler: handler,
            accelKey: accelKey,
            keyCombo: keyCombo,
            keyProfile: keyProfile,
            keyTarget: keyTarget,
            keyScope: keyScope,
            mixin:mixin
        };
    };
    /**
     *
     * @param label
     * @param command
     * @param icon
     * @param keycombo
     * @param tab
     * @param group
     * @param filterGroup
     * @param onCreate
     * @param handler
     * @param mixin
     * @param shouldShow
     * @param shouldDisable
     * @param container
     * @returns {*}
     */
    var createAction = function(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,container){
        if(keycombo) {
            if (_.isString(keycombo)) {
                keycombo = [keycombo];
            }
        }

        mixin = utils.mixin({
            filterGroup:filterGroup || "item|view",
            tab:tab||'File',
            onCreate: onCreate || function (action){},
            shouldShow:shouldShow||function(){return true;},
            shouldDisable:shouldDisable||function(){return false;}
        },mixin);

        var _action = Module.createActionParameters(
            label,
            command,
            group || 'File',//Group
            icon, handler || null, "", keycombo, null, container, null, mixin);

        utils.mixin(_action,mixin);

        return _action;
    };

    /**
     * Find action in permission
     * @param what
     * @returns {boolean}
     */
    function hasAction(permissions,what){
        return _.contains(permissions,what);
    }

    /**
     * After action default handler, trys:
     * - this::onAfterAction
     * - emit onAfterAction
     *
     * @param dfdResult
     * @param event
     * @param action
     * @private
     */
    function _afterAction(dfdResult,event,action) {
        var who = this;
        // call onAfterAction with this results
        var onAfterActionDfd = null;
        who.onAfterAction && (onAfterActionDfd = who.onAfterAction(action, dfdResult, event));

        who._emit && who._emit('onAfterAction', {
            action: action,
            result: dfdResult,
            source: who,
            afterAction: onAfterActionDfd
        });
    }
    /**
     * Default handler, does
     * - try this::runAction || action#handler
     * - call afterAction
     *
     * As last cal
     * @param action {module:xaction/ActionModel}
     * @param event
     */
    function defaultHandler(action,event){
        var actionDfd,
            who = this;

        who && who.onBeforeAction && who.onBeforeAction(action);
        if(who.runAction){
            actionDfd = who.runAction.apply(who,[action,null,event]);
        }else if(action.handler){
            actionDfd = action.handler.apply(who,[action,null,event]);
        }
        if(actionDfd && actionDfd.then){
            actionDfd.then(function(actionResult){
                _afterAction.apply(who,[actionResult,event,action]);
            });

        }else{
            _afterAction.apply(who,[actionDfd,event,action]);
        }
        return actionDfd;
    }

    /**
     *
     * @param permissions
     * @param grid
     * @param owner
     * @returns {Array}
     */
    function getDefaultActions(permissions,grid,owner){
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultEmptySelection(selection,reference,visibility){
            selection = selection || grid ? grid.getSelection() : [];

            if(!selection || !selection.length){
                return true;
            }
            return false;
        }
        /**
         *
         * @param selection
         * @param reference
         * @param visibility
         * @returns {boolean}
         */
        function shouldDisableDefaultFileOnly(selection,reference,visibility){

            if(shouldDisableDefaultEmptySelection.apply(this,arguments)){
                return true;
            }
            selection = selection || grid ? grid.getSelection() : [];

            if(selection && selection[0].isDir === true){
                return true;
            }
            return false;
        }

        var root = 'File/',
            thiz = this,
            renderActions = [],
            VISIBILITY = types.ACTION_VISIBILITY,
            result = [],
            ACTION = types.ACTION,
            ACTION_ICON = types.ACTION_ICON,
            creator = owner || grid;

        /**
         *
         * @param label
         * @param command
         * @param icon
         * @param keycombo
         * @param tab
         * @param group
         * @param filterGroup
         * @param onCreate
         * @param handler
         * @param mixin
         * @param shouldShow
         * @param shouldDisable
         */
        function addAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable){
            var action = null;
            mixin = mixin || {};
            utils.mixin(mixin,{owner:owner || grid});

            if(mixin.addPermission || hasAction(permissions,command)){

                handler = handler || defaultHandler;

                action = createAction(label,command,icon,keycombo,tab,group,filterGroup,onCreate,handler,mixin,shouldShow,shouldDisable,grid.domNode);

                if(action) {
                    if (owner && owner.addAction) {
                        owner.addAction(null, action);
                    }
                    result.push(action);
                }
            }
        }
        if(hasAction(permissions, ACTION.CLIPBOARD) && grid.getClipboardActions){
            result.push(creator.createAction({
                label: 'Clipboard',
                command: 'Edit/Clipboard',
                icon: 'fa-clipboard',
                tab: 'Edit',
                group: 'Clipboard',
                mixin:{
                    addPermission:true,
                    dynamic:true,
                    quick:true
                },
                onCreate:function(action){
                    action.setVisibility(VISIBILITY.RIBBON,{
                        expand:true,
                        tab:"File"
                    });
                }
            }));

            result = result.concat(grid.getClipboardActions(addAction));
        }

        result.push(creator.createAction({
            label: 'Show',
            command: 'View/Show',
            icon: 'fa-eye',
            tab: 'View',
            group: 'Show',
            mixin:{
                addPermission:true,
                dynamic:true
            },
            onCreate:function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }
        }));


        if(hasAction(permissions,ACTION.LAYOUT) && grid.getRendererActions){
            result = result.concat(grid.getRendererActions());
        }

        if(hasAction(permissions,ACTION.COLUMNS) && grid.getColumnHiderActions){
            result = result.concat(grid.getColumnHiderActions(permissions));
        }
        ///////////////////////////////////////
        //
        //  Open/Edit
        //
        //
        result.push(creator.createAction({
            label: 'Edit',
            command: 'File/Edit',
            icon: ACTION_ICON.EDIT,
            tab: 'Home',
            group: 'Open',
            keycombo: ['f4', 'enter','dblclick'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultFileOnly
        }));


        ///////////////////////////////////////
        //
        //  Organize
        //
        result.push(creator.createAction({
            label: 'Delete',
            command: 'File/Delete',
            icon: ACTION_ICON.DELETE,
            tab: 'Home',
            group: 'Organize',
            keycombo: ['f8','delete'],
            mixin:{
                quick:true
            },
            shouldDisable:shouldDisableDefaultEmptySelection
        }));

        addAction('Rename','File/Rename','fa-edit',['f2'],'Home','Organize','item',null,null,null,null,shouldDisableDefaultEmptySelection);

        result.push(creator.createAction({
            label: 'Reload',
            command: 'File/Reload',
            icon: ACTION_ICON.RELOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl l'],
            mixin:{
                quick:true
            }
        }));
        addAction('Create archive','File/Compress',ACTION_ICON.COMPRESS,['ctrl z'],'Home','Organize','item|view',null,null,null,null,shouldDisableDefaultEmptySelection);

        ///////////////////////////////////////
        //
        //  File
        //
        addAction('Extract','File/Extract',ACTION_ICON.EXTRACT,['ctrl e'],'Home','File','item|view',null,null,null,null,function(){
            return true;
            //return shouldDisableDefaultFileOnly.apply(this,arguments);
        });

        result.push(creator.createAction({
            label: 'Download',
            command: 'File/Download',
            icon: ACTION_ICON.DOWNLOAD,
            tab: 'Home',
            group: 'File',
            keycombo: ['ctrl down'],
            mixin:{
                quick:true
            }
        }));

        //////////////////////////////////////////
        //
        //  New
        //
        if(hasAction(permissions,ACTION.NEW_DIRECTORY)|| hasAction(permissions,ACTION.NEW_FILE)) {

            addAction('New','File/New','fa-magic',null,'Home','New','item|view',null,null,{},null,null);
/*
            result.push(creator.createAction({
                label: 'New',
                command: 'File/New',
                icon: 'fa-magic',
                tab: 'Home',
                group: 'File',
                keycombo: ['ctrl down'],
                mixin:{
                    quick:true
                }
            }));*/

        }
        addAction('New Folder',ACTION.NEW_DIRECTORY,'fa-folder',['f7'],'Home','New','item|view',null,null,{quick:true},null,null);
        addAction('New File',ACTION.NEW_FILE,'el-icon-file',['ctrl f4'],'Home','New','item|view',null,null,{quick:true},null,null);


        //////////////////////////////////////////
        //
        //  Preview
        //
        if(hasAction(permissions,ACTION.PREVIEW)) {
            result.push(creator.createAction({
                label: 'Preview',
                command: 'File/Preview',
                icon: 'fa-eye',
                tab: 'Home',
                group: 'Open',
                keycombo: ['f3'],
                mixin:{
                    quick:true
                },
                shouldDisable:shouldDisableDefaultFileOnly
            }));
        }

        ///////////////////////////////////////
        //
        //  Selection
        //
        if(hasAction(permissions,ACTION.SELECTION)) {
            result.push(createAction('Select', 'File/Select', 'fa-hand-o-up', null, 'Home', 'Select', 'item|view', function(action){
                action.setVisibility(VISIBILITY.RIBBON,{
                    expand:true
                });
            }, null, null, null, null,grid.domNode));

            var _mixin = {
                    owner:owner || grid
                },
                container = grid.domNode;

            result.push(createAction('Select all', 'File/Select/All', 'fa-th', ['ctrl a'], 'Home', 'Select', 'item|view', null, function(){
                grid.selectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Select none', 'File/Select/None', 'fa-square-o', 'ctrl d', 'Home', 'Select', 'item|view', null, function(){
                grid.deselectAll();
            }, _mixin, null, null,container));

            result.push(createAction('Invert selection', 'File/Select/Invert', 'fa-square', ['ctrl i'], 'Home', 'Select', 'item|view', null, function(){
                grid.invertSelection();
            }, _mixin, null, null,container));
        }
        return result;
    }

    Module.createAction = createAction;
    Module.hasAction = hasAction;
    Module.getDefaultActions = getDefaultActions;
    Module.defaultHandler = defaultHandler;

    return Module;
});;
define('xlang/i18',['xdojo/declare','xide/utils/ObjectUtils','dcl/dcl'], function (declare,utils,dcl) {

    var defaultLang= {
        language: 'English',
        direction: 'ltr',
        dateFormat: 'M d, Y h:i A', // Mar 13, 2012 05:27 PM
        fancyDateFormat: '$1 h:i A', // will produce smth like: Today 12:25 PM
        messages: {

            /********************************** errors **********************************/
            'error': 'Error',
            'errUnknown': 'Unknown error.',
            'errUnknownCmd': 'Unknown command.',
            'errJqui': 'Invalid jQuery UI configuration. Selectable, draggable and droppable components must be included.',
            'errNode': 'elFinder requires DOM Element to be created.',
            'errURL': 'Invalid elFinder configuration! URL option is not set.',
            'errAccess': 'Access denied.',
            'errConnect': 'Unable to connect to backend.',
            'errAbort': 'Connection aborted.',
            'errTimeout': 'Connection timeout.',
            'errNotFound': 'Backend not found.',
            'errResponse': 'Invalid backend response.',
            'errConf': 'Invalid backend configuration.',
            'errJSON': 'PHP JSON module not installed.',
            'errNoVolumes': 'Readable volumes not available.',
            'errCmdParams': 'Invalid parameters for command "$1".',
            'errDataNotJSON': 'Data is not JSON.',
            'errDataEmpty': 'Data is empty.',
            'errCmdReq': 'Backend request requires command name.',
            'errOpen': 'Unable to open "$1".',
            'errNotFolder': 'Object is not a folder.',
            'errNotFile': 'Object is not a file.',
            'errRead': 'Unable to read "$1".',
            'errWrite': 'Unable to write into "$1".',
            'errPerm': 'Permission denied.',
            'errLocked': '"$1" is locked and can not be renamed, moved or removed.',
            'errExists': 'File named "$1" already exists.',
            'errInvName': 'Invalid file name.',
            'errFolderNotFound': 'Folder not found.',
            'errFileNotFound': 'File not found.',
            'errTrgFolderNotFound': 'Target folder "$1" not found.',
            'errPopup': 'Browser prevented opening popup window. To open file enable it in browser options.',
            'errMkdir': 'Unable to create folder "$1".',
            'errMkfile': 'Unable to create file "$1".',
            'errRename': 'Unable to rename "$1".',
            'errCopyFrom': 'Copying files from volume "$1" not allowed.',
            'errCopyTo': 'Copying files to volume "$1" not allowed.',
            'errUpload': 'Upload error.',  // old name - errUploadCommon
            'errUploadFile': 'Unable to upload "$1".', // old name - errUpload
            'errUploadNoFiles': 'No files found for upload.',
            'errUploadTotalSize': 'Data exceeds the maximum allowed size.', // old name - errMaxSize
            'errUploadFileSize': 'File exceeds maximum allowed size.', //  old name - errFileMaxSize
            'errUploadMime': 'File type not allowed.',
            'errUploadTransfer': '"$1" transfer error.',
            'errNotReplace': 'Object "$1" already exists at this location and can not be replaced by object with another type.', // new
            'errReplace': 'Unable to replace "$1".',
            'errSave': 'Unable to save "$1".',
            'errCopy': 'Unable to copy "$1".',
            'errMove': 'Unable to move "$1".',
            'errCopyInItself': 'Unable to copy "$1" into itself.',
            'errRm': 'Unable to remove "$1".',
            'errRmSrc': 'Unable remove source file(s).',
            'errExtract': 'Unable to extract files from "$1".',
            'errArchive': 'Unable to create archive.',
            'errArcType': 'Unsupported archive type.',
            'errNoArchive': 'File is not archive or has unsupported archive type.',
            'errCmdNoSupport': 'Backend does not support this command.',
            'errReplByChild': 'The folder $1 cant be replaced by an item it contains.',
            'errArcSymlinks': 'For security reason denied to unpack archives contains symlinks or files with not allowed names.', // edited 24.06.2012
            'errArcMaxSize': 'Archive files exceeds maximum allowed size.',
            'errResize': 'Unable to resize "$1".',
            'errResizeDegree': 'Invalid rotate degree.',  // added 7.3.2013
            'errResizeRotate': 'Image dose not rotated.',  // added 7.3.2013
            'errResizeSize': 'Invalid image size.',  // added 7.3.2013
            'errResizeNoChange': 'Image size not changed.',  // added 7.3.2013
            'errUsupportType': 'Unsupported file type.',
            'errNotUTF8Content': 'File "$1" is not in UTF-8 and cannot be edited.',  // added 9.11.2011
            'errNetMount': 'Unable to mount "$1".', // added 17.04.2012
            'errNetMountNoDriver': 'Unsupported protocol.',     // added 17.04.2012
            'errNetMountFailed': 'Mount failed.',         // added 17.04.2012
            'errNetMountHostReq': 'Host required.', // added 18.04.2012
            'errSessionExpires': 'Your session has expired due to inactivity.',
            'errCreatingTempDir': 'Unable to create temporary directory: "$1"',
            'errFtpDownloadFile': 'Unable to download file from FTP: "$1"',
            'errFtpUploadFile': 'Unable to upload file to FTP: "$1"',
            'errFtpMkdir': 'Unable to create remote directory on FTP: "$1"',
            'errArchiveExec': 'Error while archiving files: "$1"',
            'errExtractExec': 'Error while extracting files: "$1"',

            /******************************* commands names ********************************/
            'cmdarchive': 'Create archive',
            'cmdback': 'Back',
            'cmdcopy': 'Copy',
            'cmdcut': 'Cut',
            'cmddownload': 'Download',
            'cmdduplicate': 'Duplicate',
            'cmdedit': 'Edit file',
            'cmdextract': 'Extract files from archive',
            'cmdforward': 'Forward',
            'cmdgetfile': 'Select files',
            'cmdhelp': 'About this software',
            'cmdhome': 'Home',
            'cmdinfo': 'Get info',
            'cmdmkdir': 'New folder',
            'cmdmkfile': 'New text file',
            'cmdopen': 'Open',
            'cmdpaste': 'Paste',
            'cmdquicklook': 'Preview',
            'cmdreload': 'Reload',
            'cmdrename': 'Rename',
            'cmdrm': 'Delete',
            'cmdsearch': 'Find files',
            'cmdup': 'Go to parent directory',
            'cmdupload': 'Upload files',
            'cmdview': 'View',
            'cmdresize': 'Resize & Rotate',
            'cmdsort': 'Sort',
            'cmdnetmount': 'Mount network volume', // added 18.04.2012

            /*********************************** buttons ***********************************/
            'btnClose': 'Close',
            'btnSave': 'Save',
            'btnRm': 'Remove',
            'btnApply': 'Apply',
            'btnCancel': 'Cancel',
            'btnNo': 'No',
            'btnYes': 'Yes',
            'btnMount': 'Mount',  // added 18.04.2012

            /******************************** notifications ********************************/
            'ntfopen': 'Open folder',
            'ntffile': 'Open file',
            'ntfreload': 'Reload folder content',
            'ntfmkdir': 'Creating directory',
            'ntfmkfile': 'Creating files',
            'ntfrm': 'Delete files',
            'ntfcopy': 'Copy files',
            'ntfmove': 'Move files',
            'ntfprepare': 'Prepare to copy files',
            'ntfrename': 'Rename files',
            'ntfupload': 'Uploading files',
            'ntfdownload': 'Downloading files',
            'ntfsave': 'Save files',
            'ntfarchive': 'Creating archive',
            'ntfextract': 'Extracting files from archive',
            'ntfsearch': 'Searching files',
            'ntfresize': 'Resizing images',
            'ntfsmth': 'Doing something',
            'ntfloadimg': 'Loading image',
            'ntfnetmount': 'Mounting network volume', // added 18.04.2012
            'ntfdim': 'Acquiring image dimension', // added 20.05.2013

            /************************************ dates **********************************/
            'dateUnknown': 'unknown',
            'Today': 'Today',
            'Yesterday': 'Yesterday',
            'msJan': 'Jan',
            'msFeb': 'Feb',
            'msMar': 'Mar',
            'msApr': 'Apr',
            'msMay': 'May',
            'msJun': 'Jun',
            'msJul': 'Jul',
            'msAug': 'Aug',
            'msSep': 'Sep',
            'msOct': 'Oct',
            'msNov': 'Nov',
            'msDec': 'Dec',
            'January': 'January',
            'February': 'February',
            'March': 'March',
            'April': 'April',
            'May': 'May',
            'June': 'June',
            'July': 'July',
            'August': 'August',
            'September': 'September',
            'October': 'October',
            'November': 'November',
            'December': 'December',
            'Sunday': 'Sunday',
            'Monday': 'Monday',
            'Tuesday': 'Tuesday',
            'Wednesday': 'Wednesday',
            'Thursday': 'Thursday',
            'Friday': 'Friday',
            'Saturday': 'Saturday',
            'Sun': 'Sun',
            'Mon': 'Mon',
            'Tue': 'Tue',
            'Wed': 'Wed',
            'Thu': 'Thu',
            'Fri': 'Fri',
            'Sat': 'Sat',

            /******************************** sort variants ********************************/
            'sortname': 'by name',
            'sortkind': 'by kind',
            'sortsize': 'by size',
            'sortdate': 'by date',
            'sortFoldersFirst': 'Folders first',

            /********************************** messages **********************************/
            'moveup':'Move Up',
            'movedown':'Move Down',
            'moveleft':'Move Left',
            'moveright':'Move Right',

            'edit':'Edit',
            'confirmReq': 'Confirmation required',
            'confirmRm': 'Are you sure you want to remove files?<br/>This cannot be undone!',
            'confirmRepl': 'Replace old file with new one?',
            'apllyAll': 'Apply to all',
            'name': 'Name',
            'size': 'Size',
            'perms': 'Permissions',
            'modify': 'Modified',
            'kind': 'Kind',
            'read': 'read',
            'write': 'write',
            'noaccess': 'no access',
            'and': 'and',
            'unknown': 'unknown',
            'selectall': 'Select all files',
            'selectfiles': 'Select file(s)',
            'selectffile': 'Select first file',
            'selectlfile': 'Select last file',
            'viewlist': 'List view',
            'viewicons': 'Icons view',
            'places': 'Places',
            'calc': 'Calculate',
            'path': 'Path',
            'aliasfor': 'Alias for',
            'locked': 'Locked',
            'dim': 'Dimensions',
            'files': 'Files',
            'folders': 'Folders',
            'items': 'Items',
            'yes': 'yes',
            'no': 'no',
            'link': 'Link',
            'searcresult': 'Search results',
            'selected': 'selected items',
            'about': 'About',
            'shortcuts': 'Shortcuts',
            'help': 'Help',
            'webfm': 'Web file manager',
            'ver': 'Version',
            'protocolver': 'protocol version',
            'homepage': 'Project home',
            'docs': 'Documentation',
            'github': 'Fork us on Github',
            'twitter': 'Follow us on twitter',
            'facebook': 'Join us on facebook',
            'team': 'Team',
            'chiefdev': 'chief developer',
            'developer': 'developer',
            'contributor': 'contributor',
            'maintainer': 'maintainer',
            'translator': 'translator',
            'icons': 'Icons',
            'dontforget': 'and don\'t forget to take your towel',
            'shortcutsof': 'Shortcuts disabled',
            'dropFiles': 'Drop files here',
            'or': 'or',
            'selectForUpload': 'Select files to upload',
            'moveFiles': 'Move files',
            'copyFiles': 'Copy files',
            'rmFromPlaces': 'Remove from places',
            'aspectRatio': 'Aspect ratio',
            'scale': 'Scale',
            'width': 'Width',
            'height': 'Height',
            'resize': 'Resize',
            'crop': 'Crop',
            'rotate': 'Rotate',
            'rotate-cw': 'Rotate 90 degrees CW',
            'rotate-ccw': 'Rotate 90 degrees CCW',
            'degree': '',
            'netMountDialogTitle': 'Mount network volume', // added 18.04.2012
            'protocol': 'Protocol', // added 18.04.2012
            'host': 'Host', // added 18.04.2012
            'port': 'Port', // added 18.04.2012
            'user': 'User', // added 18.04.2012
            'pass': 'Password', // added 18.04.2012
            'confirmUnmount'      : 'Are you unmount $1?',  // from v2.1 added 30.04.2012
            'dropFilesBrowser': 'Drop or Paste files from browser', // from v2.1 added 30.05.2012
            'dropPasteFiles'  : 'Drop or Paste files and URLs here', // from v2.1 added 07.04.2014
            'encoding'        : 'Encoding', // from v2.1 added 19.12.2014
            'locale'          : 'Locale',   // from v2.1 added 19.12.2014
            'searchTarget'    : 'Target: $1',                // from v2.1 added 22.5.2015
            'searchMime'      : 'Search by input MIME Type', // from v2.1 added 22.5.2015
            'owner'           : 'Owner', // from v2.1 added 20.6.2015
            'group'           : 'Group', // from v2.1 added 20.6.2015
            'other'           : 'Other', // from v2.1 added 20.6.2015
            'execute'         : 'Execute', // from v2.1 added 20.6.2015
            'perm'            : 'Permission', // from v2.1 added 20.6.2015
            'mode'            : 'Mode', // from v2.1 added 20.6.2015

            /********************************** mimetypes **********************************/
            'kindUnknown': 'Unknown',
            'kindFolder': 'Folder',
            'kindAlias': 'Alias',
            'kindAliasBroken': 'Broken alias',
            // applications
            'kindApp': 'Application',
            'kindPostscript': 'Postscript document',
            'kindMsOffice': 'Microsoft Office document',
            'kindMsWord': 'Microsoft Word document',
            'kindMsExcel': 'Microsoft Excel document',
            'kindMsPP': 'Microsoft Powerpoint presentation',
            'kindOO': 'Open Office document',
            'kindAppFlash': 'Flash application',
            'kindPDF': 'Portable Document Format (PDF)',
            'kindTorrent': 'Bittorrent file',
            'kind7z': '7z archive',
            'kindTAR': 'TAR archive',
            'kindGZIP': 'GZIP archive',
            'kindBZIP': 'BZIP archive',
            'kindXZ': 'XZ archive',
            'kindZIP': 'ZIP archive',
            'kindRAR': 'RAR archive',
            'kindJAR': 'Java JAR file',
            'kindTTF': 'True Type font',
            'kindOTF': 'Open Type font',
            'kindRPM': 'RPM package',
            // texts
            'kindText': 'Text document',
            'kindTextPlain': 'Plain text',
            'kindPHP': 'PHP source',
            'kindCSS': 'Cascading style sheet',
            'kindHTML': 'HTML document',
            'kindJS': 'Javascript source',
            'kindRTF': 'Rich Text Format',
            'kindC': 'C source',
            'kindCHeader': 'C header source',
            'kindCPP': 'C++ source',
            'kindCPPHeader': 'C++ header source',
            'kindShell': 'Unix shell script',
            'kindPython': 'Python source',
            'kindJava': 'Java source',
            'kindRuby': 'Ruby source',
            'kindPerl': 'Perl script',
            'kindSQL': 'SQL source',
            'kindXML': 'XML document',
            'kindAWK': 'AWK source',
            'kindCSV': 'Comma separated values',
            'kindDOCBOOK': 'Docbook XML document',
            // images
            'kindImage': 'Image',
            'kindBMP': 'BMP image',
            'kindJPEG': 'JPEG image',
            'kindGIF': 'GIF Image',
            'kindPNG': 'PNG Image',
            'kindTIFF': 'TIFF image',
            'kindTGA': 'TGA image',
            'kindPSD': 'Adobe Photoshop image',
            'kindXBITMAP': 'X bitmap image',
            'kindPXM': 'Pixelmator image',
            // media
            'kindAudio': 'Audio media',
            'kindAudioMPEG': 'MPEG audio',
            'kindAudioMPEG4': 'MPEG-4 audio',
            'kindAudioMIDI': 'MIDI audio',
            'kindAudioOGG': 'Ogg Vorbis audio',
            'kindAudioWAV': 'WAV audio',
            'AudioPlaylist': 'MP3 playlist',
            'kindVideo': 'Video media',
            'kindVideoDV': 'DV movie',
            'kindVideoMPEG': 'MPEG movie',
            'kindVideoMPEG4': 'MPEG-4 movie',
            'kindVideoAVI': 'AVI movie',
            'kindVideoMOV': 'Quick Time movie',
            'kindVideoWM': 'Windows Media movie',
            'kindVideoFlash': 'Flash movie',
            'kindVideoMKV': 'Matroska movie',
            'kindVideoOGG': 'Ogg movie'
        }
    };

    var mappings = {
        cmdpreview:'cmdquicklook',
        cmddelete:'cmdrm',
        'cmdnew_folder':'cmdmkdir',
        'cmdnew_file':'cmdmkfile',
        'create_archive':'cmdarchive',
        'select_all':'selectall',
        'go_up':'cmdback',
        'source':'places',
        'select':'selectfiles',
        'modified':'modify',
        'list':'viewlist',
        'thumb':'viewicons',
        'type':'kind',
        'move':'moveFiles'
        /*'view':'cmdview'*/
    };

    var messages = defaultLang.messages;

    var debug = false;

    function _lookupKey(prefix,_key,capitalize){

        var key = prefix + (capitalize ==true ? utils.capitalize(_key) : _key),
            mappingKey = mappings[key];

        return messages[mappingKey||key];

    }

    var dates = {
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            monthsShort: ['msJan', 'msFeb', 'msMar', 'msApr', 'msMay', 'msJun', 'msJul', 'msAug', 'msSep', 'msOct', 'msNov', 'msDec'],

            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    };

    function localize(str){



        str = str || '';

        if(str ==='Invert selection '){
            //debugger;
        }

        var segments = str.replace(/\s+/g, "_").split('/'),
            last = segments[segments.length-1],
            strLow = last.toLocaleLowerCase();



        // try in messages.cmd***
        var cmdValue = _lookupKey('cmd',strLow);

        // try in messages.err***
        var errValue = _lookupKey('err',strLow,true);

        // try in messages.but***
        var btnValue = _lookupKey('btn',strLow,true);

        // try in messages.but***
        var directValue = _lookupKey('',strLow);

        // try in messages.but***
        var directValueUp = _lookupKey('',strLow,true);

        // try in messages.but***
        var directValueRaw = _lookupKey('',str,false);

        var res = directValue || directValueUp || directValueRaw || cmdValue || btnValue || errValue;

        if(res){
            return res.replace('$1','');
        }


        if(str.indexOf(' ')!==-1 && str.indexOf('%%')==-1) {
            res = "";
            var parts = str.split(' ');
            _.each(parts, function (part) {
                res += " " + localize(part);
            });
            return res.trim();
        }

        str = str.replace('%%','');

        debug && console.log('localize ' + str + ' to ' + res + ' with = ' + strLow);

        return str;

    }

    function formatDate(ts){

        var utc = '';
        var date = new Date();

        this.getHours    = 'get'+utc+'Hours';
        this.getMinutes  = 'get'+utc+'Minutes';
        this.getSeconds  = 'get'+utc+'Seconds';
        this.getDate     = 'get'+utc+'Date';
        this.getDay      = 'get'+utc+'Day';
        this.getMonth    = 'get'+utc+'Month';
        this.getFullYear = 'get'+utc+'FullYear';
        this.today = (new Date(date.getFullYear(), date.getMonth(), date.getDate())).getTime()/1000;
        this.yesterday = this.today - 86400;

        var self = this,
            format, output, d, dw, m, y, h, g, i, s;


        var messages = Module.translations.messages;


        if (ts > 0) {

            date = new Date(ts*1000);

            h  = date[self.getHours]();
            g  = h > 12 ? h - 12 : h;
            i  = date[self.getMinutes]();
            s  = date[self.getSeconds]();
            d  = date[self.getDate]();
            dw = date[self.getDay]();
            m  = date[self.getMonth]() + 1;
            y  = date[self.getFullYear]();

            format = ts >= self.yesterday
                ? Module.translations.fancyDateFormat
                : Module.translations.dateFormat;

            output = format.replace(/[a-z]/gi, function(val) {
                switch (val) {
                    case 'd': return d > 9 ? d : '0'+d;
                    case 'j': return d;
                    case 'D': return Module.localize(dates.daysShort[dw]);
                    case 'l': return Module.localize(dates.days[dw]);
                    case 'm': return m > 9 ? m : '0'+m;
                    case 'n': return m;
                    case 'M': return Module.localize(dates.monthsShort[m-1]);
                    case 'F': return Module.localize(dates.months[m-1]);
                    case 'Y': return y;
                    case 'y': return (''+y).substr(2);
                    case 'H': return h > 9 ? h : '0'+h;
                    case 'G': return h;
                    case 'g': return g;
                    case 'h': return g > 9 ? g : '0'+g;
                    case 'a': return h > 12 ? 'pm' : 'am';
                    case 'A': return h > 12 ? 'PM' : 'AM';
                    case 'i': return i > 9 ? i : '0'+i;
                    case 's': return s > 9 ? s : '0'+s;
                }
                return val;
            });

            return ts >= self.yesterday
                ? output.replace('$1', Module.localize(ts >= self.today ? 'Today' : 'Yesterday'))
                : output;

        } /*else if (file && file.date) {
            return file.date.replace(/([a-z]+)\s/i, function(a1, a2) { return self.i18n(a2)+' '; });
        }
*/
        return Module.localize('dateUnknown');
    }

    var Implementation = {
        translations:defaultLang,
        localize:localize
    };




    function setLanguage(langModule){
        var translations = langModule.translations;
        defaultLang.language = translations.language;
        defaultLang.direction = translations.direction;
        defaultLang.dateFormat = translations.dateFormat;
        defaultLang.fancyDateFormat = translations.fancyDateFormat;
        utils.mixin(defaultLang.messages,translations.messages);
    }



    var Module = declare('xlang.i18',null,Implementation);

    Module.dcl = dcl(null,Implementation);
    Module.Implementation = Implementation;
    Module.setLanguage = setLanguage;
    Module.mappings = mappings;
    Module.localize = localize;
    Module.translations = defaultLang;
    Module.addMapping = function(_mappings){
        utils.mixin(mappings,_mappings);
    };
    Module.formatDate = formatDate;

    return Module;

});;
(function(factory){
	if(typeof define != "undefined"){
		define('dcl/inherited',["./mini", "./advise"], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory(require("./mini"), require("./advise"));
	}else{
		factory(dcl, advise);
	}
})(function(dcl, advise){
	var empty = {}, t;

	function inherited(ctor, name, args){
		var callee = arguments.length < 3 && ctor.callee, // callee is truthy if in non-strict mode.
			f = get.call(this, callee ? callee.ctr : ctor, callee ? callee.nom : name);
		if(f){ return f.apply(this, callee ? ctor || name : args); }
		// intentionally no return
	}

	function get(ctor, name){
		var meta = this.constructor._meta, bases, base, i, l;
		if(+meta.weaver[name]){
			return; // return undefined
		}
		if(meta){
			if(meta.chains.hasOwnProperty(name)){
				if((bases = meta.chains[name])){	// intentional assignment
					for(i = bases.length - 1; i >= 0; --i){
						base = bases[i];
						if(base.ctr === ctor){
							return i > 0 ? bases[i - 1] : 0;
						}
					}
				}
				return; // return undefined
			}
			for(bases = meta.bases, i = bases.length - 1; i >= 0; --i){
				if(bases[i] === ctor){
					break;
				}
			}
			if(i >= 0){
				for(++i, l = bases.length; i < l; ++i){
					if((meta = (base = bases[i])._meta)){	// intentional assignments
						if((meta = meta.ownProps).hasOwnProperty(name)){	// intentional assignment
							return meta[name];
						}
					}else{
						return base.prototype[name];
					}
				}
			}
		}
		return empty[name];
	}

	advise.after(dcl, "_postprocess", function(args, ctor){
		// decorate all methods with necessary nom/ctr variables
		var bases = ctor._meta.bases, i = bases.length - 1, base, meta, name, f;
		for(; i >= 0; --i){
			base = bases[i];
			if((meta = base._meta)){ // intentional assignment
				meta = meta.ownProps;
				dcl.allKeys(meta).some(function(name){
					f = meta[name];
					if(typeof f == "function"){
						if(f.nom === name){ return 1; }
						f.nom = name;
						f.ctr = base;
					}
				});
			}
		}
		ctor.prototype.inherited = inherited;
		ctor.prototype.getInherited = get;
	});

	dcl.getInherited = inherited.get = get;
	return dcl.inherited = inherited;   // intentional assignment
});
;
/** @module xide/Keyboard **/
define('xide/Keyboard',[
    'xdojo/declare',
    'dcl/dcl',
    'dojo/_base/lang',
    'xide/types',
    'xide/utils/ObjectUtils'    //possibly not loaded yet
], function (declare, dcl, lang, types, utils) {

    /**
     * First things first, mixin KEYBOARD_FLAGS into core types.
     */
    utils.mixin(types, {
        /**
         * KEYBOARD_EVENT describes all possible events a subscriber can listen to.
         *
         * @enum module:xide/types/KEYBOARD_EVENT
         * @memberOf module:xide/types
         */
        KEYBOARD_EVENT: {
            /**
             * Add a custom callback for a key-up event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            UP: 'on_keyup',
            /**
             * Add a custom callback for a key-dow event.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            DOWN: 'on_keydown',
            /**
             * Add a custom callback for a release event. This is similar to keyup, but will fire once
             * when ALL of the keys of a combo have been released. If you're unsure, you probably want to
             * ignore this and use UP.
             *
             * @default null, not required.
             * @type {function}
             * @constant
             */
            RELEASE: 'on_release'
        }
    });

    /**
     * Define a public struct for a 'keyboard - mapping
     */
    utils.mixin(types, {

        /**
         * KEYBOARD_MAPPING
         *
         * Keys accepted in human readable format as 'shift s', see the full map:
         *
         _modifier_event_mapping =
         "cmd"   : "metaKey"
         "ctrl"  : "ctrlKey"
         "shift" : "shiftKey"
         "alt"   : "altKey"

         _keycode_alternate_names =
         "escape"        : "esc"
         "control"       : "ctrl"
         "command"       : "cmd"
         "break"         : "pause"
         "windows"       : "cmd"
         "option"        : "alt"
         "caps_lock"     : "caps"
         "apostrophe"    : "\'"
         "semicolon"     : ";"
         "tilde"         : "~"
         "accent"        : "`"
         "scroll_lock"   : "scroll"
         "num_lock"      : "num"

         _keycode_shifted_keys =
         "/"     : "?"
         "."     : ">"
         ","     : "<"
         "\'"    : "\""
         ";"     : ":"
         "["     : "{"
     "]"     : "}"
         "\\"    : "|"
         "`"     : "~"
         "="     : "+"
         "-"     : "_"
         "1"     : "!"
         "2"     : "@"
         "3"     : "#"
         "4"     : "$"
         "5"     : "%"
         "6"     : "^"
         "7"     : "&"
         "8"     : "*"
         "9"     : "("
         "0"     : ")"

         _keycode_dictionary =
         0   : "\\"          # Firefox reports this keyCode when shift is held
         8   : "backspace"
         9   : "tab"
         12  : "num"
         13  : "enter"
         16  : "shift"
         17  : "ctrl"
         18  : "alt"
         19  : "pause"
         20  : "caps"
         27  : "esc"
         32  : "space"
         33  : "pageup"
         34  : "pagedown"
         35  : "end"
         36  : "home"
         37  : "left"
         38  : "up"
         39  : "right"
         40  : "down"
         44  : "print"
         45  : "insert"
         46  : "delete"
         48  : "0"
         49  : "1"
         50  : "2"
         51  : "3"
         52  : "4"
         53  : "5"
         54  : "6"
         55  : "7"
         56  : "8"
         57  : "9"
         65  : "a"
         66  : "b"
         67  : "c"
         68  : "d"
         69  : "e"
         70  : "f"
         71  : "g"
         72  : "h"
         73  : "i"
         74  : "j"
         75  : "k"
         76  : "l"
         77  : "m"
         78  : "n"
         79  : "o"
         80  : "p"
         81  : "q"
         82  : "r"
         83  : "s"
         84  : "t"
         85  : "u"
         86  : "v"
         87  : "w"
         88  : "x"
         89  : "y"
         90  : "z"
         91  : "cmd"
         92  : "cmd"
         93  : "cmd"
         96  : "num_0"
         97  : "num_1"
         98  : "num_2"
         99  : "num_3"
         100 : "num_4"
         101 : "num_5"
         102 : "num_6"
         103 : "num_7"
         104 : "num_8"
         105 : "num_9"
         106 : "num_multiply"
         107 : "num_add"
         108 : "num_enter"
         109 : "num_subtract"
         110 : "num_decimal"
         111 : "num_divide"
         112 : "f1"
         113 : "f2"
         114 : "f3"
         115 : "f4"
         116 : "f5"
         117 : "f6"
         118 : "f7"
         119 : "f8"
         120 : "f9"
         121 : "f10"
         122 : "f11"
         123 : "f12"
         124 : "print"
         144 : "num"
         145 : "scroll"
         186 : ";"
         187 : "="
         188 : ","
         189 : "-"
         190 : "."
         191 : "/"
         192 : "`"
         219 : "["
         220 : "\\"
         221 : "]"
         222 : "\'"
         223 : "`"
         224 : "cmd"
         225 : "alt"
         # Opera weirdness
         57392   : "ctrl"
         63289   : "num"
         # Firefox weirdness
         59 : ";"
         61 : "-"
         173 : "="

         *
         * @class module:xide/types/KEYBOARD_MAPPING
         * @memberOf module:xide/types
         */

        /**
         * KEYBOARD_MAPPING is defines keyboard mapping struct:
         *
         * @memberOf module:xide/types
         * @class module:xide/types/KEYBOARD_EVENT
         *
         */
        KEYBOARD_MAPPING: {
            /**
             * @param keys {string|string[]} the key sequence (see below for the right codes ).
             * This option can be either an array of strings, or a single space separated string of key names that describe
             * the keys that make up the combo.
             */
            keys: null,
            /**
             * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
             * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
             * in the params
             */
            handler: null,
            /**
             * @param scope {Object|null} the scope in which the handler(s) are excecuted.
             */
            scope: null,
            /**
             * @param target {HTMLElement|null} the element on the listerner is bound to. Null means global!
             */
            target: null,
            /**
             * @param type {string|null} the keypress combo type, can be:
             * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
             * counting_combo(keys, on_count_callback); // Registers a counting combo
             * sequence_combo(keys, callback); // Registers a sequence combo
             * register_combo(combo_dictionary); // Registers a combo from a dictionary
             */
            type: null,
            /**
             * @param mixin to override the 'keypress' libraries internal setup for a listener
             * @default {

                prevent_repeat: false,
                prevent_default: false,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: false
            */
            params: null,
            /**
             *
             * @param mouse {Object|null|true|false} filter to setup an addtional trigger constraint for keyboard
             * sequence. Example: mouse.before='mousedown' and keys ='ctrl' will fire the handler when the mouse is hold whilst
             * ctrl key is hold. default:null.
             *
             */
            mouse: {
                brefore: null,//true
                after: null//false
            },
            eventArgs: null
        }

    });

    /**
     * Global array of keypress listeners
     * @type {Object[]}
     * @private
     */
    var listeners = [];
    var byNode = {};

    /**
     * Util to extend a keyboard mapping with control functions per listener. Keyboard mappings can
     * have multiple key sequences and this will take care about stop(), listen() and destroy().
     * @param mapping
     * @param listeners
     */
    var addListenerControls = function (mapping, listeners) {
        mapping.stop = function () {
            return;
            //if(listeners && listeners.length) {
            //    _.invoke(listeners, 'stop_listening');
            //}
        };
        mapping.listen = function () {
            _.invoke(listeners, 'listen');
        };
        mapping.destroy = function () {
            mapping.stop();
            _.each(listeners, function (listener) {
                listener.destroy();
                listeners.remove(listener);
                delete byNode[listener.targetId];
            });
        };
        return mapping;
    };

    /**
     * Safe link to keypress prototype
     * @type {Listener|keypress.Listener}
     * @private
     */
    var keypressProto = window ? window['keypress'] ? window.keypress.Listener : null : null;
    if (!keypressProto) {
        console.error('you need keypress.min.js installed to use xide/Keyboard');
    }

    var Implementation = {
        /**
         * @member listener {Object[]} all keypress listener instances
         */
        _keyboardListeners: null,
        /**
         * The default setup for a listener, this is 'keypress' specific.
         *
         * @returns {{prevent_repeat: boolean, prevent_default: boolean, is_unordered: boolean, is_counting: boolean, is_exclusive: boolean, is_solitary: boolean, is_sequence: boolean}}
         */
        keyPressDefault: function () {
            return {
                prevent_repeat: false,
                prevent_default: true,
                is_unordered: false,
                is_counting: false,
                is_exclusive: false,
                is_solitary: false,
                is_sequence: true
            };
        },
        /**
         * Private listener creation method, accepts multiple key sequences for the same handler.
         *
         * @param keys {string|string[]} the key sequence (see below for the right codes ).
         * This option can be either an array of strings, or a single space separated string of key names that describe
         * the keys that make up the combo.
         *
         * @param params {Object|null} an additional parameter structure to override the default 'keypress' setup.
         * See this.keyPressDefault
         *
         * @param scope {Object|null} the scope in which the handler(s) are excecuted, defaults to 'this' as we are
         * a mixin.
         *
         *
         * @param type {string|null} the keypress combo type, can be:
         * simple_combo(keys, on_keydown_callback); // Registers a very basic combo;
         * counting_combo(keys, on_count_callback); // Registers a counting combo
         * sequence_combo(keys, callback); // Registers a sequence combo
         * register_combo(combo_dictionary); // Registers a combo from a dictionary
         *
         * @param handler {function|xide/types/KEYBOARD_EVENT} the callback for the key sequence. This can be one
         * function an structure per keyboard event. Usually its enough to leave this empty. You can also pass this
         * in the params

         * @param target {HTMLElement|null} the element on the listener is bound to. Null means global!
         *
         * @param eventArgs {array|null} Event arguments passed to the handler. Defaults to keyboard event.
         *
         * @public
         */
        addKeyboardListerner: function (keys, params, type, scope, handler, target, eventArgs) {
            // prepare keypress args
            var _defaults = lang.clone(this.keyPressDefault());
            //mixin override
            utils.mixin(_defaults, params);

            // defaults
            _defaults['this'] = _defaults['this'] || scope || this;

            // use simple_combo as default
            type = type || 'simple_combo';

            //normalize to array
            keys = !_.isArray(keys) ? [keys] : keys;

            var _listeners = [],
                ignore = ['ctrl s', 'ctrl l', 'ctrl r', 'ctrl w', 'ctrl f4', 'shift f4', 'alt tab', 'ctrl tab'];

            _.each(keys, function (key_seq) {
                var targetId = target && target.id ? target.id : 'global',
                    wasCached = target ? !!byNode[targetId] : false,
                    registered = false;

                var listener = byNode[targetId];
                if(listener && listener["_seq"+key_seq]){
                    registered = true;
                }

                if(!registered) {
                    if (!listener) {
                        listener = new keypressProto(target, _defaults);
                        listener.targetId = targetId;
                    }

                    listener["_seq" + key_seq] = true;
                    listener[type](key_seq, function (e) {
                        if (e._did) {
                            return;
                        }
                        e._did = true;
                        var className = e.target.className.toLowerCase();
                        //skip input fields
                        if (e.target.tagName!=='BUTTON' && className.indexOf('input') == -1 || className.indexOf('ace_text-input') != -1) {
                            if (handler && handler.apply) {
                                handler.apply(_defaults['this'], eventArgs || [e]);
                                if (ignore.indexOf(key_seq) !== -1) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        }
                    });
                    if (byNode[targetId]) {

                    } else {
                        byNode[targetId] = listener;
                    }

                    if (!wasCached) {
                        !this._keyboardListeners && (this._keyboardListeners = []);
                        //store in local
                        this._keyboardListeners.push(listener);
                        //store in global
                        _listeners.push(listener);
                    }
                }

            }, this);

            return _listeners;
        },
        /**
         * Public interface to register a keyboard mapping
         * @param mapping {xide/types/KEYBOARD_MAPPING}
         * @returns {xide/types/KEYBOARD_MAPPING}
         */
        registerKeyboardMapping: function (mapping) {
            var listeners = this.addKeyboardListerner(mapping.keys, mapping.params, null, mapping.scope, mapping.handler, mapping.target, mapping.eventArgs);
            mapping.listeners = listeners;
            return addListenerControls(mapping, listeners);
        },
        destroy:function(){
            this.inherited && this.inherited(arguments);
            var targetId = this.id;
            var listener = byNode[targetId];
            if(listener){
                listener.destroy();
                delete byNode[targetId];
            }
        }
    };

    /**
     * Generic keyboard handler, using the external 'keypress' Javascript library
     * which handles keyboard events a bit more elegant and robust, it does allow
     * registration of keyboard - sequences as 'shift s':
     * @example
     *
     * listener.simple_combo("shift s", function() {
     *  console.log("You pressed shift and s");
     * });
     *
     * @link http://dmauro.github.io/Keypress/
     * @link https://github.com/dmauro/Keypress/blob/master/keypress.coffee#L728-864
     */
    var _Keyboard = declare("xide/Keyboard", null, Implementation);
    /**
     * Static mapping factory
     * @param keys
     * @param params
     * @param type
     * @param scope
     * @param handler
     * @param target
     * @param eventArgs
     * @memberOf module:xide/Keyboard
     * @returns {xide/types/KEYBOARD_MAPPING}
     */
    _Keyboard.createMapping = function (keys, params, type, scope, handler, target, eventArgs) {
        var mapping = utils.clone(types.KEYBOARD_MAPPING);//@TODO: bad copy, uses a ctr followed by a lang.mixin
        function getHandler(__handler) {
            return _.isString(__handler) ? lang.hitch(scope, __handler) : __handler;
        }

        mapping.keys = keys;
        mapping.params = params || {};
        mapping.type = type;
        mapping.scope = scope;
        mapping.handler = getHandler(handler);
        mapping.target = target;
        mapping.eventArgs = eventArgs;
        mapping.setHandler = function (event, handler) {
            mapping.params[event] = getHandler(handler);
            return mapping;
        };
        return mapping;

    };

    _Keyboard.defaultMapping = function (keys, handler, params, node, who, args) {
        return _Keyboard.createMapping(keys, params, null, who, handler, node, args);
    };

    _Keyboard.dcl = dcl(null, Implementation);
    _Keyboard.byNode = byNode;
    _Keyboard.listeners = listeners;
    return _Keyboard;
});;
/** @module xaction/Action **/
define('xaction/Action',[
    'dcl/dcl',
    'xide/model/Base',
    'xide/types',
    'xide/utils/ObjectUtils',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'xide/cache/Circular'
], function (dcl, Base, types, ObjectUtils, utils, EventedMixin, Circular) {

    var Cache = null;//new Circular(100);
    /***
     * Extend the core types for action visibility(main menu,...) options/enums:
     * 1. 'Main menu',
     * 2. 'Context menu'
     * 3. 'Action toolbar'
     * 4. 'Property view'
     */
    utils.mixin(types, {
        /**
         * ActionVisibility
         * @enum module:xide/types/ACTION_VISIBILITY
         * @memberOf module:xide/types
         */
        ACTION_VISIBILITY: {
            /**
             * Enable visibility in main menu, which does
             * render actions in a menu bar whereby 'sub' levels
             * are rendered as sub level menus.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            MAIN_MENU: 'MAIN_MENU',

            /**
             * Enable visivibilty in context menu.
             *
             * Different to the main menu, all actions
             * are 'flatted'. The action's group field
             * will auto-create separators among these
             * groups.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            CONTEXT_MENU: 'CONTEXT_MENU',

            QUICK_LAUNCH: 'QUICK_LAUNCH',

            /**
             * Enable visivibilty in primary action toolbar.
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            ACTION_TOOLBAR: 'ACTION_TOOLBAR',

            /**
             * Enable visibility in an item's property view (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            PROPERTY_VIEW: 'PROPERTY_VIEW',

            /**
             * Enable visibility the ribbon toolbar (if such exists).
             *
             * Same as in the "Context Menu", actions will
             * rendered out flat, just the label is being removed.
             *
             * @default null, means not visible. Actually in xjs its 1/0/{}
             * @type {int|Object|xaction/Action}
             * @constant
             */
            RIBBON: 'RIBBON',

            /**
             * A mixin to be used whilst creating the widget
             * @type {object}
             */
            widgetArgs: null,

            /**
             * Util for the constructor yo create a visibilty. A visibility is a key/value store where the
             * key is ACTION_VISIBILITY
             * and its value is stored in this.ACTION_VISIBILITY_val ! Thus you'r accessing this store in a doc-friendly
             * and enum like function
             * @example
             *  this.getVisibility(types.ACTION_VISIBILITY.MAIN_MENU)'     *
             *
             * the returning value is of type {object}, or {integer(1|0)}
             * @type {function}
             * @returns {module:xide/types/ACTION_VISIBILITY}
             */
            factory: function () {

                var _in = arguments[1] || utils.clone(types.ACTION_VISIBILITY),
                    _args = arguments;

                //
                // A mode when we have the arguments like (1,1,1,2).
                //  This clones types.ACTION_VISIBILITY and blends in an integer mask

                if (_args[0].length > 0 && _.isNumber(_args[0][0])) {

                    var _FlagArgs = _args[0],
                        _val = null,
                        _index = 0;

                    //integer case, sets this[propIndex] to something
                    _.each(_in, function (index, prop) {
                        if (typeof _in[prop] !== 'function') {
                            if (_index < _FlagArgs.length) {
                                //set the value per key but preserve the actualy key by storing
                                //the value in a new key_val field
                                _in[prop + '_val'] = _FlagArgs[_index];
                            }
                        }
                        _index++;
                    });
                }

                // A modus when we have the arguments like (MAIN_MENU,something). set value in this.ENUM_val
                if (_.isString(_args[0][0])) {
                    if (_args[0][2] === true) {
                        utils.mixin(_in[_args[0][0] + '_val'], _args[0][2]);
                    } else {
                        _in[_args[0][0] + '_val'] = _args[0][1];
                        return _in;
                    }
                    return _args[1];
                }
                return _in;
            }
        }
    });
    types.ACTION_VISIBILITY_ALL = 'ACTION_VISIBILITY_ALL';
    /**
     * Basic model to represent an 'action'. Its just a structure
     * object with some factory methods and built-in store to have
     * versions of it self per 'ACTION_VISIBILITY' which may alter
     * rendering for such visibility.
     *
     * Please read {@link module:xide/types}
     *
     * @class module:xaction/Action
     * @augments xide/model/Base
     */
    var Module = dcl([Base.dcl, EventedMixin.dcl], {
        declaredClass: "xaction/Action",
        disabled: false,
        destroy: function () {
            if (Cache && Cache.size() < 100) {
                delete this._properties;
                delete this._visibility;
                delete this.keyboardMappings;
                delete this.group;
                delete this.tab;
                delete this.owner;
                delete this.item;
                delete this.icon;
                delete this.actionType;
                delete this.label;
                delete this.title;
                delete this.type;
                delete this.onCreate;
                delete this.onChange;
                delete this.addPermission;
                delete this._store;
                delete this.parameters;
                delete this.handler;
                Cache.push(this);
            }
        },
        /**
         * Turn on/off this action
         * @type {boolean}
         * @default true
         */
        enabled: true,
        /**
         * The object or bean we're up to. This is mostly the user's selection.
         * @type {Object|Object[]|Array}
         */
        object: null,
        /**
         * Show/hide this action in ui
         * @member show {boolean}
         */
        show: true,
        /**
         * A group for this action. This is being used in interface only.
         * @type {string|Object=}
         */
        group: '',
        /**
         * A comma separated list of bean types. This specifies on which bean types
         * this action can be applied
         * @type {string|Object=}
         */
        types: '',
        /**
         * A identifier of a command within a "bean action context". This should be human readable.
         * Remember, this is being used for populating menu items in toolbars.
         * @example "Edit/Copy", "Views/Log" and so forth
         * @type {string|integer}
         */
        command: null,
        /**
         * Icon class. You can use font-awesome, dijit icon classes or Elusive icons
         * @type {string}
         * @default fa-play
         */
        icon: 'fa-play',
        /**
         * An event key when the action is performed. This will be published automatically when this action
         * is performed.
         * @type {string|null}
         * @default null
         */
        event: null,
        /**
         * The function to be invoked
         * @type {function|null}
         */
        handler: null,
        /**
         * The tab (visual)
         * @type {string|null}
         * @default null
         */
        tab: null,

        /**
         * A store to override per visibility an action attributes like label, icon, renderer, handler
         * or whatever this action needs. This acts as store per VISIBILITY "Zone" as descried in the enumerations. Its
         * one simple object or single integer store.
         *
         * This storage must be fast as its used in mouse-over, don't use any dojo/dstore or whatever fancy stuff; the
         * operations in the consumer side are already heavy enough (loadash 'group' and 'sort' come up to 5000 calls for
         * just 10 actions)
         *
         * @see {module:xide/types/ACTION_VISIBILITY}
         * @type {xide/types/ACTION_VISIBILITY}
         * @augments {xide/types/ACTION_VISIBILITY}
         * @default null
         * @property
         * @member
         *
         * @example
         * {
         *      MAIN_MENU:"MAIN_MENU",
         *      MAIN_MENU_val:0
         *      //or MAIN_MENU_val:1
         *      ACTION_TOOLBAR:"ACTION_TOOLBAR",
         *      ACTION_TOOLBAR_val:{
         *          icon:"fa or el or dijit", //supports font-awesome, elusive or dojo/dijit
         *          label:"" // in some cases like an action bar you may override this per visibility to hide a label 
         *      }
         * }
         *
         */
        visibility_: null,
        /**
         * An action might contain a value. For instance the action might toggle
         * a checkbox...
         *
         * @type {object|*|null}
         */
        value: null,
        /**
         * Sets visibility options per visibility type.
         *
         * @param {mixed} arguments will blend a number of integers into a copy of
         * xide/types/ACTION_VISIBILITY. Be aware of the exact order!
         * @example
         *
         *
         //Example 1. : set the visibility per type
         setVisibility(1,1,0);// will result in:
         {
                 MAIN_MENU:1,
                 CONTEXT_MENU:1,
                 ACTION_TOOLBAR:0
         }

         //Example 2. : set the visibility per type. @TODO:specify merge filter bits
         setVisibility(types.ACTION_VISIBILITY.MAIN_MENU,{
                label:null  //don't show a label
            });

         */
        setVisibility: function () {
            if (arguments.length == 2 && _.isString(arguments[0]) && arguments[0] == types.ACTION_VISIBILITY_ALL) {
                var _obj = arguments[1],
                    _vis = types.ACTION_VISIBILITY,
                    thiz = this;

                //track vis key in all
                [_vis.MAIN_MENU, _vis.ACTION_TOOLBAR, _vis.CONTEXT_MENU, _vis.RIBBON].forEach(function (vis) {
                    thiz.setVisibility(vis, utils.cloneKeys(_obj, false));
                });
                return this;

            }
            var _args = _.isArray(arguments[0]) ? arguments[0] : arguments;
            this.visibility_ = types.ACTION_VISIBILITY.factory(_args, this.visibility_);
            return this;
        },
        /**
         * Visibility getter
         * @param key
         * @returns {module:xide/types/ACTION_VISIBILITY}
         */
        getVisibility: function (key) {
            if (!this.visibility_) {
                this.setVisibility(types.ACTION_VISIBILITY_ALL, {});
            }
            if (this.visibility_) {
                if (this.visibility_[key + '_val'] == null) {
                    this.visibility_[key + '_val'] = {
                        vis: key
                    };
                }
                return this.visibility_[key + '_val'];
            }
            return {};
        },
        /**
         *
         * @param _visibility
         * @param who
         * @param newItem
         * @returns {boolean}
         */
        shouldDestroyWidget: function (_visibility, who, newItem) {
            var visibility = this.getVisibility != null ? this.getVisibility(_visibility) : null;
            var destroy = true;
            if (visibility && visibility.permanent) {
                destroy = !(_.isFunction(visibility.permanent) ? visibility.permanent(this, who, newItem) : visibility.permanent);
            }
            return destroy;
        }

    });
    /**
     * Static factory
     * @param label {string}
     * @param icon
     * @param command
     * @param permanent
     * @param operation
     * @param btypes
     * @param group
     * @param visibility
     * @param register
     * @param handler
     * @param mixin
     * @static
     * @memberOf xaction/Action
     *
     * @example for queuing a clip board action:
     *
     *  var _copyAction  = Action.create('Copy', 'fa-copy', 'Edit/Copy', true, types.OPERATION_INT.CLIPBOARD_COPY, types.ITEM_TYPE.FILE, 'clipboard', null, true, _clipboardManager);
     *  _copy.accelKey = 'CTRL+C';
     *
     * @returns {module:xaction/Action}
     */
    Module.create = function (label, icon, command, permanent, operation, btypes, group, visibility, register, handler, mixin) {
        var _action = null;

        var _args = {
            permanent: permanent,
            command: command,
            icon: icon,
            label: label,
            owner: this,
            types: btypes,
            operation: operation,
            group: group,
            handler: handler,
            title: label
        };
        if (Cache && Cache.size()) {
            _action = Cache.deq(0);
            //console.log('re-use');
            utils.mixin(_action, _args);
        } else {
            //console.log('-create!');
            _action = new Module(_args);
        }
        /*
         var VISIBILITY = types.ACTION_VISIBILITY,
         VISIBILITIES = [
         VISIBILITY.ACTION_TOOLBAR,
         VISIBILITY.RIBBON,
         VISIBILITY.MAIN_MENU,
         VISIBILITY.CONTEXT_MENU
         ];
         */
        utils.mixin(_action, mixin);
        return _action;
    };
    /**
     * Simple wrapper for action.create
     * @param label {string}
     * @param icon
     * @param command
     * @param group
     * @param handler
     * @param mixin
     * @returns {module:xaction/Action}
     */
    Module.createDefault = function (label, icon, command, group, handler, mixin) {
        return Module.create(label, icon, command, false, null, null, group || 'nogroup', null, false, handler, mixin);
    };
    return Module;
});
;
define('xide/cache/Circular',[], function () {

    function CircularBuffer(capacity){
        if(!(this instanceof CircularBuffer))return new CircularBuffer(capacity);
        if(typeof capacity=="object"&&
            Array.isArray(capacity["_buffer"])&&
            typeof capacity._capacity=="number"&&
            typeof capacity._first=="number"&&
            typeof capacity._size=="number"){
            for(var prop in capacity){
                if(capacity.hasOwnProperty(prop))this[prop]=capacity[prop];
            }
        } else {
            if(typeof capacity!="number"||capacity%1!=0||capacity<1)
                throw new TypeError("Invalid capacity");
            this._buffer=new Array(capacity);
            this._capacity=capacity;
            this._first=0;
            this._size=0;
        }
    }
    CircularBuffer.prototype = {
        size: function () {
            return this._size;
        },
        capacity: function () {
            return this._capacity;
        },
        enq: function (value) {
            if (this._first > 0)this._first--; else this._first = this._capacity - 1;
            this._buffer[this._first] = value;
            if (this._size < this._capacity)this._size++;
        },
        push: function (value) {
            if (this._size == this._capacity) {
                this._buffer[this._first] = value;
                this._first = (this._first + 1) % this._capacity;
            } else {
                this._buffer[(this._first + this._size) % this._capacity] = value;
                this._size++;
            }
        },
        deq: function () {
            if (this._size == 0)throw new RangeError("dequeue on empty buffer");
            var value = this._buffer[(this._first + this._size - 1) % this._capacity];
            this._size--;
            return value;
        },
        pop: function () {
            return this.deq();
        },
        shift: function () {
            if (this._size == 0)throw new RangeError("shift on empty buffer");
            var value = this._buffer[this._first];
            if (this._first == this._capacity - 1)this._first = 0; else this._first++;
            this._size--;
            return value;
        },
        get: function (start, end) {
            if (this._size == 0 && start == 0 && (end == undefined || end == 0))return [];
            if (typeof start != "number" || start % 1 != 0 || start < 0)throw new TypeError("Invalid start");
            if (start >= this._size)throw new RangeError("Index past end of buffer: " + start);

            if (end == undefined)return this._buffer[(this._first + start) % this._capacity];

            if (typeof end != "number" || end % 1 != 0 || end < 0)throw new TypeError("Invalid end");
            if (end >= this._size)throw new RangeError("Index past end of buffer: " + end);

            if (this._first + start >= this._capacity) {
                //make sure first+start and first+end are in a normal range
                start -= this._capacity; //becomes a negative number
                end -= this._capacity;
            }
            if (this._first + end < this._capacity)
                return this._buffer.slice(this._first + start, this._first + end + 1);
            else
                return this._buffer.slice(this._first + start, this._capacity).concat(this._buffer.slice(0, this._first + end + 1 - this._capacity));
        },
        toarray: function () {
            if (this._size == 0)return [];
            return this.get(0, this._size - 1);
        }
    };

    return CircularBuffer;
});;
/** @module xaction/ActionStore **/
define('xaction/ActionStore',[
    "xdojo/declare",
    'xide/data/TreeMemory',
    'xide/utils',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xaction/ActionModel'
], function (declare, TreeMemory, utils, ObservableStore, Trackable, ActionModel) {
    /**
     * Default properties to be observed (in ObservableStore)
     * @type {string[]}
     */
    var DEFAULT_ACTION_PROPERTIES = [
        "value",
        "icon",
        "disabled",
        "enabled"
    ];

    /**
     * Default factory
     * @param composer
     * @param bases
     * @param Model
     * @param defaults
     * @param mixin
     * @returns {*}
     */
    function createClass(composer, bases, Model, defaults, mixin) {
        /**
         * @class module:xaction/ActionStore
         */
        return (composer || declare)(bases || [TreeMemory, Trackable, ObservableStore], utils.mixin({
            idProperty: 'command',
            declaredClass: "xaction/ActionStore",
            Model: Model || ActionModel,
            renderers: null,
            observedProperties: defaults || DEFAULT_ACTION_PROPERTIES,
            getAll: function () {
                return this.data;
            },
            addRenderer: function (renderer) {
                !this.renderers && (this.renderers = []);
                !_.contains(this.renderers, renderer) && this.renderers.push(renderer);
            }
        }, mixin));
    }

    var Module = createClass(null, null, null, null, null);
    Module.createDefault = function (args) {
        return new Module(args);
    };
    Module.createClass = createClass;
    Module.DEFAULT_ACTION_PROPERTIES = DEFAULT_ACTION_PROPERTIES;
    return Module;
});
;
/** module:xaction/ActionModel **/
define('xaction/ActionModel',[
    "dcl/dcl",
    'xaction/Action',
    'xide/data/Model',
    "xide/data/Source",
    'xide/model/Path',
    'xide/utils'
], function (dcl, Action, Model, Source, Path, utils) {
    var debug = false;
    var count = 0;
    /**
     * @class module:xaction/ActionModel
     * @extends module:xide/data/Source
     * @extends module:xaction/Action
     * @extends module:xide/mixins/EventedMixin
     */
    return dcl([Action, Model, Source.dcl], {
        filterGroup: "item|view",
        keyboardMappings: null,
        bindWidgetProperties: [
            //2-way bindings for these props:
            'value',
            'icon',
            'disabled'
        ],
        items: null,
        onRemove: function () {
            _.invoke(this.getReferences(), 'destroy');
            this.keyboardMappings && _.invoke(this.keyboardMappings, "destroy");
            this.destroy();
        },
        shouldShow: function () {
            return true;
        },
        shouldDisable: function () {
            return false;
        },
        updateReference: function (selection, reference, visibility) {
            reference.set('disabled', this.shouldDisable(selection, reference, visibility));
            if (this.icon !== null && reference.icon !== null && this.icon !== reference.icon) {
                reference.set('icon', this.icon);
            }
            if (this.value !== null && reference.value !== null && this.value !== reference.value) {
                reference.set('value', this.value);
            }
        },
        refreshReferences: function (property, value) {
            _.each(this.getReferences(), function (ref) {
                ref.set(property, value);
            }, this);
        },
        refresh: function (selection) {
            this._emit('refresh', {
                action: this,
                selection: selection
            });
            _.each(this.getReferences(), function (ref) {
                this.updateReference(selection, ref, ref.visibility);
            }, this);
        },
        setProperty: function (key, value, updateReferences) {
            return this.set(key, value);
        },
        complete: function () {
            this.items = this.getChildren();
        },
        getParent: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return this._store.getSync(segments.slice(0, segments.length - 1).join('/'));
            }
        },
        getParentCommand: function () {
            var segments = this.command.split('/');
            if (segments.length > 1) {
                return segments.slice(0, segments.length - 1).join('/');
            }
        },
        getSegments: function (command) {
            return command.split('/');
        },
        getRoot: function () {
            return this.command.split('/')[0];
        },
        getItemsAtBranch: function (items, path) {
            return new Path(path).getChildren(utils.pluck(items, 'command'), false);
        },
        getChildren: function () {
            var children = this.getItemsAtBranch(this._store.getAll(), this.command),
                self = this;

            //return an action from both stores
            function getAction(command) {
                return self._store.getSync(command);
            }

            //command strings to actions
            function toActions(paths) {
                var result = [];
                _.each(paths, function (path) {
                    result.push(getAction(path));
                });
                return result;
            }

            /*
            return lodash.map(this.getItemsAtBranch(this._store.getAll(), this.command),function(paths){
                return lodash.map(paths,function(path){
                    this._store.getSync(path);
                },this)
            },this)
            */
            return toActions(children);
        },
        /**
         * @TODO: remove back compat
         * @param evt {object}
         * @param evt.parent {widget}
         * @param evt.widget {widget}
         * @param evt.visibility {string}
         * @private
         */
        _onWidgetCreated: function (evt) {
            if (evt.widget.addSource) {
                this.addReference(evt.widget, {
                    properties: {
                        "value": true
                    }
                }, true);
            } else {
                debug && console.warn('widget is not a reference! ', evt);
            }
        }
    });
});;
/** @module xide/model/Path */
define('xide/model/Path',[
    "xide/utils",
    "dcl/dcl"
], function (utils, dcl) {
    var Path = dcl(null, {
        declaredClass: "xide.model.Path",
        /**
         * @class xide.model.Path
         * @constructor
         */
        constructor: function (path, hasLeading, hasTrailing) {
            path = path || '.';  // if empty string, use '.'
            if (typeof path == 'string') {
                this.path = path;
                this.getSegments();
            } else {
                this.segments = path;
                this.hasLeading = hasLeading !== null ? hasLeading : false;
                this.hasTrailing = hasTrailing !== null ? hasLeading : false;
            }
        },

        endsWith: function (tail) {
            var segments = utils.clone(this.segments);
            var tailSegments = (new Path(tail)).getSegments();
            while (tailSegments.length > 0 && segments.length > 0) {
                if (tailSegments.pop() != segments.pop()) {
                    return false;
                }
            }
            return true;
        },
        getExtension: function () {
            if (!this.extension) {
                this.extension = this.path.substr(this.path.lastIndexOf('.') + 1);
            }
            return this.extension;
        },
        segment: function (index) {
            var segs = this.getSegments();
            if (segs.length < index) {
                return null;
            }
            return segs[index];
        },
        /**
         * Return all items under this path
         * @param items {String[]}
         * @param recursive {boolean}
         * @returns {String[]}
         */
        getChildren: function (items, recursive) {
            var result = [];
            var root = this,
                path = this.toString();

            function addChild(child) {
                var _path = typeof child !== 'string' ? child.toString() : child;
                if (_path !== path && result.indexOf(_path) == -1) {
                    result.push(_path);
                }
            }

            _.each(items, function (item) {
                var child = new Path(item);
                //root match
                if (child.startsWith(root)) {
                    if (recursive) {
                        addChild(child.toString());
                    } else {

                        var diff = child.relativeTo(path);
                        if (diff) {
                            var diffSegments = diff.getSegments();
                            //direct child
                            if (diffSegments.length == 1) {
                                addChild(child);
                            } else if (diffSegments.length > 1) {

                                //make sure that its parent has been added:
                                var parent = child.getParentPath();
                                var parentDiff = parent.relativeTo(path);

                                //check diff again
                                if (parentDiff.getSegments().length == 1) {
                                    addChild(parent.toString());
                                }
                            }
                        }
                    }

                }
            });
            return result;
        },
        getSegments: function () {
            if (!this.segments) {
                var path = this.path;
                this.segments = path.split('/');
                if (path.charAt(0) == '/') {
                    this.hasLeading = true;
                }
                if (path.charAt(path.length - 1) == '/') {
                    this.hasTrailing = true;
                    // If the path ends in '/', split() will create an array whose last element
                    // is an empty string. Remove that here.
                    this.segments.pop();
                }
                this._canonicalize();
            }
            return this.segments;
        },
        isAbsolute: function () {
            return this.hasLeading;
        },
        getParentPath: function () {
            if (!this._parentPath) {
                var parentSegments = utils.clone(this.segments);
                parentSegments.pop();
                this._parentPath = new Path(parentSegments, this.hasLeading);
            }
            return utils.clone(this._parentPath);
        },
        _clone: function () {
            return new Path(utils.clone(this.segments), this.hasLeading, this.hasTrailing);
        },
        append: function (tail) {
            tail = tail || "";
            if (typeof tail == 'string') {
                tail = new Path(tail);
            }
            if (tail.isAbsolute()) {
                return tail;
            }
            var mySegments = this.segments;
            var tailSegments = tail.getSegments();
            var newSegments = mySegments.concat(tailSegments);
            var result = new Path(newSegments, this.hasLeading, tail.hasTrailing);
            if (tailSegments[0] == ".." || tailSegments[0] == ".") {
                result._canonicalize();
            }
            return result;
        },
        toString: function () {
            var result = [];
            if (this.hasLeading) {
                result.push('/');
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (i > 0) {
                    result.push('/');
                }
                result.push(this.segments[i]);
            }
            if (this.hasTrailing) {
                result.push('/');
            }
            return result.join("");
        },
        removeRelative: function () {
            var segs = this.getSegments();
            if (segs.length > 0 && segs[1] == ".") {
                return this.removeFirstSegments(1);
            }
            return this;
        },
        relativeTo: function (base, ignoreFilename) {
            if (typeof base == 'string') {
                base = new Path(base);
            }
            var mySegments = this.segments;
            if (this.isAbsolute()) {
                return this;
            }
            var baseSegments = base.getSegments();
            var commonLength = this.matchingFirstSegments(base);
            var baseSegmentLength = baseSegments.length;
            if (ignoreFilename) {
                baseSegmentLength = baseSegmentLength - 1;
            }
            var differenceLength = baseSegmentLength - commonLength;
            var newSegmentLength = differenceLength + mySegments.length - commonLength;
            if (newSegmentLength == 0) {
                return Path.EMPTY;
            }
            var newSegments = [];
            for (var i = 0; i < differenceLength; i++) {
                newSegments.push('..');
            }
            for (var i = commonLength; i < mySegments.length; i++) {
                newSegments.push(mySegments[i]);
            }
            return new Path(newSegments, false, this.hasTrailing);
        },
        startsWith: function (anotherPath) {
            var count = this.matchingFirstSegments(anotherPath);
            return anotherPath._length() == count;
        },
        _length: function () {
            return this.segments.length;
        },
        matchingFirstSegments: function (anotherPath) {
            var mySegments = this.segments;
            var pathSegments = anotherPath.getSegments();
            var max = Math.min(mySegments.length, pathSegments.length);
            var count = 0;
            for (var i = 0; i < max; i++) {
                if (mySegments[i] != pathSegments[i]) {
                    return count;
                }
                count++;
            }
            return count;
        },
        removeFirstSegments: function (count) {
            return new Path(this.segments.slice(count, this.segments.length), this.hasLeading, this.hasTrailing);
        },
        removeMatchingLastSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this.removeLastSegments(match);
        },
        removeMatchingFirstSegments: function (anotherPath) {
            var match = this.matchingFirstSegments(anotherPath);
            return this._clone().removeFirstSegments(match);
        },
        removeLastSegments: function (count) {
            if (!count) {
                count = 1;
            }
            return new Path(this.segments.slice(0, this.segments.length - count), this.hasLeading, this.hasTrailing);
        },
        lastSegment: function () {
            return this.segments[this.segments.length - 1];
        },
        firstSegment: function (length) {
            return this.segments[length || 0];
        },
        equals: function (anotherPath) {
            if (this.segments.length != anotherPath.segments.length) {
                return false;
            }
            for (var i = 0; i < this.segments.length; i++) {
                if (anotherPath.segments[i] != this.segments[i]) {
                    return false;
                }
            }
            return true;
        },
        _canonicalize: function () {
            var doIt;
            var segments = this.segments;
            for (var i = 0; i < segments.length; i++) {
                if (segments[i] == "." || segments[i] == "..") {
                    doIt = true;
                    break;
                }
            }
            if (doIt) {
                var stack = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i] == "..") {
                        if (stack.length == 0) {
                            // if the stack is empty we are going out of our scope
                            // so we need to accumulate segments.  But only if the original
                            // path is relative.  If it is absolute then we can't go any higher than
                            // root so simply toss the .. references.
                            if (!this.hasLeading) {
                                stack.push(segments[i]); //stack push
                            }
                        } else {
                            // if the top is '..' then we are accumulating segments so don't pop
                            if (".." == stack[stack.length - 1]) {
                                stack.push("..");
                            } else {
                                stack.pop();
                            }
                        }
                        //collapse current references
                    } else if (segments[i] != "." || this.segments.length == 1) {
                        stack.push(segments[i]); //stack push
                    }
                }
                //if the number of segments hasn't changed, then no modification needed
                if (stack.length == segments.length) {
                    return;
                }
                this.segments = stack;
            }
        }

    });
    Path.EMPTY = new Path("");
    return Path;
});;
define('xide/editor/Registry',[
    'dcl/dcl',
    'xdojo/declare',
    'xide/factory',
    'xide/types',
    'xide/data/Memory'
], function (dcl,declare, factory, types,Memory) {

    //exported mixin
    var editorMixin;

    //singleton store
    var store;

    var debug=false;

    editorMixin = dcl(null, {
        declaredClass:"xide.editor.Registry",
        delegate: null,
        editors: null,
        _started: false,
        startup: function () {
            this.subscribe(types.EVENTS.REGISTER_EDITOR, function (data) {
                editorMixin.onRegisterEditor(data);
            });
        }
    });

    editorMixin.editors = [];

    var editors = editorMixin.editors;

    editorMixin.getStore = function(){
        if(!store){
            store = new Memory({
                idProperty:'name'
            })
        }
        return store;
    };

    editorMixin.getExtension = function (fname) {
        if (fname != null) {
            return fname.substr((~-fname.lastIndexOf(".") >>> 0) + 2);
        }
        return "";
    };

    editorMixin._hasEditor = function (name,extensions) {
        return _.find(editorMixin.editors,{
            name:name,
            extensions:extensions
        });
    };

    editorMixin.unregisterEditor = function (name) {
        var _store = editorMixin.getStore();
        var editors = _store._find({
            name:name
        });
        function unregister(editor){
            _store.removeSync(editor.name);
            _.each(editors,function(_editor){
                if(_editor && _editor.name === editor.name){
                    editors.remove(_editor);
                }
            });
        }
        _.each(editors,unregister);
    };

    editorMixin.onRegisterEditor = function (eventData) {
        var _store = editorMixin.getStore();
        var allEditors = _store._find({
            name:eventData.name
        });
       if(allEditors.length>0){
           debug && console.warn('Editor already registered',eventData);
           _.each(allEditors,function(editor){
               _store.removeSync(editor.name);
               editorMixin.unregisterEditor(editor.name);
           });
        }
        _store.putSync(eventData);
        if (!editorMixin._hasEditor(eventData.name,eventData.extensions)) {
            editors.push(eventData);
        }
    };

    editorMixin.getDefaultEditor = function (item) {
        var editors = editorMixin.getEditors(item);
        if (!editors) {
            return null;
        }

        for (var i = 0; i < editors.length; i++) {
            var obj = editors[i];
            if (obj.isDefault === true) {
                return obj;
            }
        }
        return null;
    };

    editorMixin.getEditor = function(name){
        return _.find(editors,{
            name:name
        });
    };

    editorMixin.getEditors = function (item) {
        if(!item){
            return editors;
        }
        var extension = editorMixin.getExtension(item.path);
        if (extension != null && extension.length == 0) {
            return null;
        }
        extension=extension.toLowerCase();
        var result = [];
        if (!editorMixin.editors) {
            return null;
        }

        var store = editorMixin.getStore();
        var _defaultEditor = store._find({
            defaultEditor:true
        });

        for (var i = 0; i < editors.length; i++) {
            var editor = editors[i];
            if (editor) {
                //check multiple extensions
                if (editor.extensions.indexOf('|') != -1) {
                    var supportedPluginExtensions = editor.extensions.split('|');
                    for (var j = 0; j < supportedPluginExtensions.length; j++) {
                        var supportedPluginExtension = supportedPluginExtensions[j];
                        if (supportedPluginExtension === extension) {
                            result.push(editor);
                        }
                    }
                } else {
                    //otherwise single extension match
                    if (editor.extensions === extension) {
                        result.push(editor);
                    }
                }
            }
        }

        if(_defaultEditor.length==1){
            result.push(_defaultEditor[0]);
        }

        if (result.length > 0) {
            return result;
        }
        return null;
    };

    return editorMixin;
});;
/** module:xide/manager/SettingsManager **/
define('xide/manager/SettingsManager',[
    'dcl/dcl',
    "xide/manager/ServerActionBase",
    "xide/utils",
    "xide/manager/ManagerBase",
    "xide/data/Memory",
    "dojo/Deferred"
], function (dcl,ServerActionBase, utils, ManagerBase,Memory,Deferred) {
    var Module = dcl([ManagerBase, ServerActionBase], {
        declaredClass:"xide.manager.SettingsManager",
        serviceClass: 'XApp_Store',
        settingsStore: null,
        settingsDataAll: null,
        section: 'settings',
        store:null,
        has: function (section, path, query, data, readyCB) {},
        getSetting:function(id){
            var _val = this.getStore().query({
                id:id
            });
            return _val && _val[0] ? _val[0].value : null;
        },
        getStore: function () {
            return this.settingsStore;
        },
        _createStore: function (data) {
            return new Memory({
                data: data,
                idProperty: 'id'
            });
        },
        onSettingsReceived: function (data) {
            this.settingsDataAll = data;
            if (!data) {
                this._createStore([]);
                return;
            }
            var _a = data['' + this.section];
            this.settingsStore = this._createStore(_a);
        },
        replace: function (path, query, operation, newValue, readyCB) {
            var thiz = this;
            var defered = this.serviceObject[this.serviceClass].set(
                this.store,
                path || '.', query, operation, newValue
            );
            defered.addCallback(function (res) {
                if (readyCB) {
                    readyCB(res);
                }
            });
        },
        read: function (section, path, query, readyCB) {
            return this.runDeferred(null, 'get', [section, path, query]).then(function (data) {
                readyCB && readyCB(data);
            }.bind(this));
        },
        update: function (section, path, query, data, decode) {
            //return this.callMethodEx(this.serviceClass, 'update', [section || this.section, path, query, data, decode], readyCB, false);
            return this.runDeferred(null, 'update', [section || this.section, path, query, data, decode]);
        },
        write: function (section, path, query, data, decode, readyCB) {
            try {
                var itemLocal = utils.queryStoreEx(this.settingsStore, {id: data.id}, true, true);
                if (itemLocal) {
                    return this.update(section, path, {id: data.id}, data.data, decode, readyCB);
                } else {
                    return this.callMethodEx(this.serviceClass, 'set', [section || this.section, path, query, data, decode], readyCB, false);
                }
            } catch (e) {
                logError(e, 'update');
            }
        },
        write2: function (section, path, query, data, decode, readyCB) {
            try {
                //var itemLocal = utils.queryStoreEx(this.settingsStore, {id: data.id}, true, true);
                var itemLocal = utils.queryStoreEx(this.settingsStore, query, true, true);
                if (itemLocal) {
                    utils.mixin(itemLocal,data);
                    return this.update(section, path, query, data, decode, readyCB);
                } else {
                    return this.callMethodEx(this.serviceClass, 'set', [section || this.section, path, query, data, decode], readyCB, false);
                }
            } catch (e) {
                logError(e, 'update');
            }
        },
        initStore: function () {
            var dfd = new Deferred();
            var self = this;
            this.serviceObject.__init.then(function() {
                self.read(self.section, '.', null, self.onSettingsReceived.bind(self));
                dfd.resolve();
            });
            return dfd;
        },
        init:function(){
            var dfd = new Deferred();
            var self = this;
            dfd.resolve();
            return dfd;
        }
    });
    return Module;
});;
define('xide/manager/NotificationManager',[
    'dcl/dcl',
    'xide/types',
    'xide/utils',
    'xide/manager/ManagerBase',
    'xide/encoding/MD5'
],function(dcl,types,utils,ManagerBase,MD5){

    return dcl([ManagerBase],{
        declaredClass:"xide.manager.NotificationManager",
        onError:function(err){
            var mess = '';
            if(err && err&& err.error && err.error.message){
                mess = err.error.message;
            }else if(err && _.isString(err)){
                mess = err;
            }else if(err && _.isString(err.message)){
                mess = err.message;
            }
            var args = {
                message: mess,
                type:'error',
                duration: 500,
                showCloseButton: true
            };

            if(mess.indexOf('Stack trace')!==-1){
                args.message = mess.substr(0,mess.indexOf('Stack trace'));
                args.duration = 4000;
            }

            if(err.messageArgs){
                utils.mixin(args,err.messageArgs);
            }
            this.postMessage(args);
        },
        _lastMessageTime:null,
        _lastMessageHash:null,
        onStatus:function(err){
            var mess = '';

            if(err.did!=null){
                return;
            }
            err.did=true;

            if(err && err&& err.message){
                mess = err.message;
            }else if(err && _.isString(err)){
                mess = err;
            }


            if(mess=='Ok!'){
                return ;
            }
            var args = {
                message: mess,
                type:'success',
                duration: 500,
                showCloseButton: true
            };

            utils.mixin(args,err.messageArgs);

            //var timeNow = new Date().getTime();
            /*
            if (thiz.fileUpdateTimes[_path]) {
                var last = thiz.fileUpdateTimes[_path];
                var diff = timeNow - last;
                if (diff < 1000) {
                    thiz.fileUpdateTimes[_path] = timeNow;
                    return;
                }
            }



            thiz.fileUpdateTimes[_path] = timeNow;
            */

            //console.log('print ' + hash,args);

            this.postMessage(args);
        },
        postMessage:function(msg){
            var hash = MD5(JSON.stringify(msg),1);
            var self = this;

            if(this._lastMessageHash===hash){
                setTimeout(function () {
                    self._lastMessageHash=null;
                },2000);
                return;
            }
            this._lastMessageHash = hash;
            if(this._lastMessageTime){
                clearTimeout(this._lastMessageTime);
            }


            if(!this._lastMessageTime) {
                this._lastMessageTime = setTimeout(function () {
                    self._lastMessageHash = null;
                    delete self._lastMessageTime;
                    self._lastMessageTime = null;
                }, 1000);
            }
            return Messenger().post(msg);
        },
        init:function(){
            if($.globalMessenger && typeof Messenger!=='undefined') {
                this.subscribe(types.EVENTS.STATUS,this.onStatus);
                this.subscribe(types.EVENTS.ERROR,this.onError);
                var theme = 'flat';
                $.globalMessenger({
                    theme: theme,
                    extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right'
                });
                Messenger.options = {
                    theme: theme,
                    extraClasses: 'messenger-fixed messenger-on-bottom messenger-on-right'
                };
            }else{
                this.postMessage=function(){}
            }
        }
    });
});;
/** @module xide/manager/WindowManager **/
define('xide/manager/WindowManager',[
    'dcl/dcl',
    'xide/utils',
    'xide/types',
    'xide/manager/ManagerBase',
    'xide/editor/Registry',
    'xide/registry',
    'xdojo/has',
    'xide/lodash',
    'dojo/has!xace?xace/views/Editor'
], function (dcl, utils, types, ManagerBase, Registry, registry, has,_,Editor) {

    function register(what, where, _active) {
        where.addActionEmitter(what);
        if (_active !== false) {
            where.setActionEmitter(what);
        }
    }

    function clear(what, where, _active) {
        where.setActionEmitter(what);
    }

    function findFrame(docker) {
        var panels = docker.getPanels();
        if (docker._lastSelected) {
            for (var i = 0; i < panels.length; i++) {
                var panel = panels[i];
                if (panel == docker._lastSelected) {
                    var frame = panel.getFrame();
                    if (frame) {
                        return frame;
                    }
                }
            }
        }
    }

    /**
     * @class module:xide/manager/WindowManager
     * @extends module:xide/manager/ManagerBase
     */
    var Module = dcl(ManagerBase, {
        declaredClass: 'xide.manager.WindowManager',
        actionReceivers: null,
        /**
         *
         * @returns {Array}
         */
        getActions: function () {
            var result = [];
            var thiz = this;
            result.push(this.ctx.createAction('Next', 'View/Next', 'fa-cube', ['alt num_add'], 'Home', 'View', "global",
                //onCreate
                function (action) {
                },
                //handler
                function () {
                    var docker = thiz.ctx.mainView.getDocker();
                    var frame = findFrame(docker);
                    if (!frame) {
                        return;
                    }
                    var pos = frame._curTab;
                    var panel = frame.panel(pos);
                    var next = frame.panel(pos + 1);
                    if (panel || next) {
                        (next || panel ).select();
                        (next || panel ).resize();
                        docker.resize();
                    }
                },
                {
                    addPermission: true,
                    show: true
                }, null, null,
                //permissions:
                [], window, this
            ));
            result.push(this.ctx.createAction('Prev', 'View/Prev', 'fa-cube', ['alt num_subtract'], 'Home', 'View', "global",
                //onCreate
                function (action) {
                },
                //handler
                function () {
                    var docker = thiz.ctx.mainView.getDocker();
                    var frame = findFrame(docker);
                    if (!frame) {
                        return;
                    }
                    var pos = frame._curTab;

                    var panel = frame.panel(pos);
                    var next = frame.panel(pos - 1);
                    if (panel || next) {

                        (next || panel ).select();
                        (next || panel ).resize();
                        docker.resize();
                    }
                },
                {
                    addPermission: true,
                    show: true
                }, null, null,
                //permissions:
                [], window, this
            ));


            return result;
        },
        init: function () {
            this.ctx.addActions(this.getActions());
            this.actionReceivers = [];
        },
        addActionReceiver: function (receiver) {
            if (this.actionReceivers.indexOf(receiver) == -1) {
                this.actionReceivers.push(receiver);
                receiver._on('destroy', function () {
                    this.actionReceivers.remove(receiver);
                }, this);
            }
        },
        registerView: function (view, active) {
            var toolbar = this.getToolbar(),
                menu = this.getMainMenu();

            this.publish(types.EVENTS.ON_OPEN_VIEW, {
                view: view,
                menu: menu,
                toolbar: toolbar,
                src: this
            });
            toolbar && register(view, toolbar, active);
            menu && register(view, menu, active);
            var receivers = this.actionReceivers;
            _.each(receivers, function (widget) {
                widget && register(view, widget, active);
            });
            return true;
        },
        clearView: function (view, active) {
            var toolbar = this.getToolbar(),
                menu = this.getMainMenu(),
                breadcrumb = this.getBreadcrumb();
            toolbar && clear(view, toolbar, active);
            menu && clear(view, menu, active);
            return true;
        },
        getBreadcrumb: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView && mainView.getBreadcrumb ? mainView.getBreadcrumb() : null;
        },
        getToolbar: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView.getToolbar();
        },
        getMainMenu: function () {
            var ctx = this.ctx,
                mainView = ctx.mainView;
            return mainView.mainMenu;
        },
        /**
         *
         * @param title
         * @param icon
         * @param where
         * @returns {module:xdocker/Panel2}
         */
        createTab: function (title, icon, where) {
            var docker = this.getContext().getMainView().getDocker();
            return docker.addTab(null, {
                title: title,
                target: where ? where._parent : docker.getDefaultPanel(),
                icon: icon || 'fa-code'
            });
        },
        /**
         *
         * @returns {module:xdocker/Panel2}
         */
        getDefaultPanel: function () {
            return this.getContext().getMainView().getDocker().getDefaultPanel();
        },
        /**
         * @param title
         * @param icon
         * @returns {module:xdocker/Panel2}
         */
        createDefaultTab: function (title, icon) {
            return this.getContext().getMainView().getDocker().addTab(null, {
                title: title,
                icon: icon
            });
        },
        /**
         *
         * @param item {module:xfile/model/File}
         * @param where {module:xide/widgets/_Widget|null}
         * @param mixin {object} constructor argument mixin for the new view created
         * @param select {boolean} select the view (will update actions in global action receivers)
         * @returns {module:xide/editor/Base}
         */
        openItem: function (item, where, mixin, select) {
            if (!item || !item.getPath) {
                console.error('invalid item!');
                return null;
            }

            if (item && !item.getPath().match(/^(.*\.(?!(zip|tar|gz|bzip2)$))?[^.]*$/i)) {
                return;
            }
            var thiz = this,
                ctx = this.ctx;

            var root = where || registry.byId(this.appendTo);
            var docker = ctx.getMainView().getDocker();
            //create tab
            var title = utils.toString(item.name);
            if (_.isFunction(where)) {
                root = where({
                    title: title,
                    icon: 'fa-code',
                    location: null,
                    tabOrientation: null
                });
            } else {
                root = docker.addTab(null, {
                    title: title,
                    target: where ? where._parent : null,
                    icon: 'fa-code'
                });
            }

            if (has('debug')) {
                if (!root) {
                    console.error('have no attachment parent!');
                    return;
                }
            }

            var args = {
                dataItem: item,
                item: item,
                filePath: item.path,
                config: this.config,
                delegate: this,
                parentContainer: root,
                store: this.store,
                style: 'padding:0px;height:inherit;height:width;',
                iconClass: 'fa-code',
                autoSelect: true,
                ctx: ctx,
                /***
                 * Provide a text editor store delegate
                 */
                storeDelegate: {
                    getContent: function (onSuccess) {
                        thiz.ctx.getFileManager().getContent(item.mount, item.path, onSuccess);
                    },
                    saveContent: function (value, onSuccess, onError) {
                        thiz.ctx.getFileManager().setContent(item.mount, item.path, value, onSuccess);
                    }

                },
                title: title,
                closable: true,
                fileName: item.path
            };

            utils.mixin(args, mixin);
            var editor = utils.addWidget(Editor, args, this, root, true, null, null, select);
            root.resize();
            editor.resize();

            if (select !== false && root.selectChild) {
                root.selectChild(editor);
            }

            docker.resize();
            if (mixin && mixin.register) {
                this.registerView(editor, select);
            }
            return editor;
        }
    });
    return Module;
});;
define('xide/min',[
    'xide/utils',
    'xide/utils/StringUtils',
    'xide/utils/HTMLUtils',
    'xide/utils/WidgetUtils',
    'xide/types',
    'xide/types/Types',
    'xide/factory',
    'xide/factory/Objects',
    'xide/factory/Events',
    'xide/lodash'
], function () {
    if(!Array.prototype.remove) {
        Array.prototype.remove = function () {
            var what, a = arguments, L = a.length, ax;
            while (L && this.length) {
                what = a[--L];
                if (this.indexOf == null) {
                    break;
                }
                while ((ax = this.indexOf(what)) != -1) {
                    this.splice(ax, 1);
                }
            }
            return this;
        };
    }
});
;
define('xide/debug',[
    'xdojo/declare',
    'dojo/has',
    'xdojo/has!debug?xide/serverDebug'
],function(declare,has,serverDebug){
	var Module = declare("xide.debug", null,{});

    if(has('debug')) {

        function displayServerDebugData(data){
            serverDebug && serverDebug.logError(data);
        }

        window.xappServerDebug = displayServerDebugData;

        var callback = function (stackframes) {
            var stringifiedStack = stackframes.map(function (sf) {
                return sf.toString();
            }).join('\n');
            console.log(stringifiedStack);
        };

        var errback = function (err) {
            console.log(err.message);
        };


        window.onerror = function (msg, file, line, col, error) {
            StackTrace.fromError(error).then(callback)['catch'](errback);
        };
        if (!window.logError) {
            window.logError = function (e, message) {
                console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
                if (typeof 'StackTracke' === 'undefined') {
                    var stack = e.stack;
                    stack = stack.split('\n').map(function (line) {
                        return line.trim();
                    });
                    stack.splice(stack[0] == 'Error' ? 2 : 1);
                    console.log(stack.join('\n'));
                } else {
                    StackTrace.fromError(e).then(callback)['catch'](errback);

                }
            }
        } else {
            console.log('logError already created');
        }
    }else{
        window.onerror = function (msg, file, line, col, error) {
            console.error(msg, error);
        };
        window.logError = function (e, message) {
            console.error((message || '') + ' :: ' + e.message + ' stack:\n', e);
        }
    }
    return Module;
});;
define('xide/serverDebug',[
    'xdojo/declare',
    'xdojo/has'
],function(declare,has){

    var Module = declare("xide.serverDebug", null,{

    });

    /**
     * @var object
     */
    var local_storage = null;
    var color1 = '#888';
    var color2 = '#0563ad';

    var ALLOWED_TYPES = {
        'group': 1,
        'groupEnd': 1,
        'groupCollapsed': 1,
        'warn': 1,
        'error': 1,
        'info': 1,
        'table': 1,
        'log': 1
    };

    /**
     * @var array
     */
    var queue = [];

    /**
     * @var bool
     */
    var use_queue = true;

    /**
     * should we show line numbers?
     *
     * @return bool
     */
    function _showLineNumbers()
    {
        return true;
    }

    /**
     * logs nicely formatted data in new format
     *
     * @param Object
     * @return void
     */
    function _logData(data, callback)
    {

        //console.log('server log : ',data);

        var column_map = {};
        var column_name;

        for (var key in data.columns) {
            column_name = data.columns[key];
            column_map[column_name] = key;
        }

        var rows = data.rows,
            i = 0,
            length = rows.length;

        for (i = 0; i < length; i++) {
            var row = rows[i],
                backtrace = row[column_map.backtrace],
                label = row[column_map.label],
                log = row[column_map.log],
                type = row[column_map.type] || 'log';

            if (_showLineNumbers() && backtrace !== null) {
                console.log('%c' + backtrace, 'color: ' + color1 + '; font-weight: bold;');
            }

            // new version without label
            var new_version = false;
            if (data.columns.indexOf('label') === -1) {
                new_version = true;
            }

            // if this is the old version do some converting
            if (!new_version) {
                var show_label = label && typeof label === "string";

                log = [log];

                if (show_label) {
                    log.unshift(label);
                }
            }

            var logs = [];
            var current_log;
            var last_log;
            var new_string;

            // loop through logs to add in any class name labels that should be here
            for (var j = 0; j < log.length; j++) {
                current_log = log[j];
                last_log = logs[logs.length - 1];

                if (current_log && typeof current_log === 'object' && current_log['___class_name']) {
                    new_string = '%c' + current_log['___class_name'];

                    if (typeof last_log === 'string') {

                        // if the last log was a string we need to append to it
                        // in order for the coloring to work correctly
                        logs[logs.length - 1] = last_log + ' ' + new_string;
                    }
                    else {

                        // otherwise just push the new string to the end of the list
                        logs.push(new_string);
                    }

                    logs.push('color: ' + color2 + '; font-weight: bold;');
                    delete log[j]['___class_name'];
                }

                logs.push(current_log);
            }

            if (!(type in ALLOWED_TYPES)) {
                type = 'log';
            }

            console[type].apply(console, logs);
        }

        if (typeof callback === 'function') {
            callback();
        }
    }
    function _decode(header) {
        return JSON.parse(atob(header));
    }

    Module.logError = function(data){
        _logData(_decode(data));
    }

    return Module;
});;
/** @module xide/model/Component **/
define('xide/model/Component',[
    "dcl/dcl",
    "dojo/Deferred",
    "dojo/has",
    "require",
    "xide/model/Base",
    "xide/types",
    "xide/mixins/EventedMixin"
], function (dcl, Deferred, has, require, Base, types, EventedMixin) {
    /**
     * COMPONENT_FLAGS is a number of flags being used for the component's instance creation. Use an object instead of
     * an integer, never know how big this becomes and messing with 64bit integers doesn't worth the effort.
     *
     * @enum module:xide/types/COMPONENT_FLAGS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.COMPONENT_FLAGS = {
        /**
         * Due the object instantiation, instruct the component loader to call ::load()
         * @constant
         */
        LOAD: 1,
        /**
         * Due the object instantiation, instruct the component loader to call ::run()
         * @constant
         */
        RUN: 1
    };

    /**
     * @class xide/model/Component
     * @extends module:xide/mixins/EventedMixin
     * @extends module:xide/model/Base
     */
    return dcl([Base.dcl, EventedMixin.dcl], {
        declaredClass:"xide/model/Component",
        /**
         * Flag indicating that all dependencies are fully loaded
         * @type {boolean}
         * @default false
         */
        _loaded: false,
        /**
         * Pointer to a context, filled by the component loader
         * @member module:xide/manager/Context
         */
        ctx: null,
        /**
         * Pointer to an optional owner
         * @member {Object|null}
         */
        owner: {
            reloadComponent: function () {
            }
        },
        /**
         * Usually a component is about a new beantype.
         * @TODO handle many
         */
        beanType: null,
        /**
         * Array of typical JS packages
         * @member {Array|null} packages
         */
        packages: null,

        /**
         * Array of resources. A components has typically a bunch of resources like CSS.
         * @member {Array} resources
         */
        resources: [],
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        getDependencies: function () {
            return [];
        },
        hasEditors: function () {
            return [];
        },
        /**
         * Return a human readable string
         * @returns {string}
         */
        getLabel: function () {
            return "Have no label";
        },
        /**
         * If this component has additional dependencies, load them here!
         * @returns {dojo.Deferred}
         */
        load: function (hasName) {
            var _defered = new Deferred(),
                thiz = this,
                _re = require;

            hasName = hasName || this.getLabel();

            _re(this.getDependencies(), function () {
                thiz._loaded = true;
                if (hasName) {
                    has.add(hasName, function () {
                        return true;
                    });
                }
                _defered.resolve();
            });
            return _defered.promise;
        },
        run: function () {
            return false;
        },
        onModuleReloaded: function () {
            this.owner.reloadComponent(this);
        },
        isLoaded: function () {
            return this._loaded;
        }
    });
});

;
define('xide/factory/Events',[
    'xide/factory',
    'dojo/_base/connect',
    'dojo/_base/lang',
    "dojo/on",
    'dojo/has',
    'xide/lodash'
], function (factory, connect, lang, on,has) {
    var _debug = false,         //print publish messages in console
        _tryEvents = false,     //put publish in try/catch block
        _foo=null,              //noop
        _nativeEvents = {
            "click": _foo,
            "dblclick":_foo,
            "mousedown":_foo,
            "mouseup":_foo,
            "mouseover":_foo,
            "mousemove":_foo,
            "mouseout":_foo,
            "keypress":_foo,
            "keydown":_foo,
            "keyup":_foo,
            "focus":_foo,
            "blur":_foo,
            "change":_foo
        },
        _debugGroup=false;


    /**
     * Returns true if it is a DOM element, might be not needed anymore
     * @param o
     * @returns {*}
     * @private
     */
    function _isElement(o){
        return (
            typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
        );
    }
    /**
     * Event debouncer/throttler
     * @param eventHandler
     * @param waitForMirror
     * @returns {Function}
     */
    function applyEventOnce(eventHandler, waitForMirror) {
        var timer;
        var mirror = this;
        return function() {
            var _arguments = arguments;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {
                if (waitForMirror && mirror.isPending())
                    return setTimeout(function() { applyEventOnce(eventHandler, true) }, 0);
                eventHandler.apply(eventHandler, _arguments);
            }, 0);
        };
    }

    /**
     * asyncForEach does runs a chain of promises, needed this specialized for event callbacks
     * @param array
     * @param fn
     * @param test
     * @param callback
     */
    function asyncForEach(array, fn, test, callback) {
        if (!callback) {
            callback = test;
            test = null;
        }

        array = array.slice(); // copy before use

        var nested = false, callNext = true;
        loop();

        function loop() {
            while (callNext && !nested) {
                callNext = false;
                while (array.length > 0 && test && !test(array[0]))
                    array.shift();

                var item = array.shift();
                // TODO: implement proper err argument?
                if (!item)
                    return callback && callback();

                nested = true;
                fn(item, loop);
                nested = false;
            }
            callNext = true;
        }
    }

    /***
     * @param keys
     * @param data
     * @param callee
     * @extends module:xide/factory
     * @memberOf xide/factory
     */
    factory.publish = function (keys, data, callee,filter) {
        var msgStruct   = data ? _.isString(data) ? {message: data} : data : {},
            eventKeys   = keys,
            _publish    = connect.publish,
            result      = [];//lookup cache

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }
        for (var i = 0,l=eventKeys.length; i < l; i++) {

            var eventKey = eventKeys[i];

            if(filter && !filter(eventKey)){
                continue;
            }

            if (_debug) {
                //console.group("Events");
                _debugGroup = true;
                console.log('publish ' + eventKey + ' from : ' + (callee ? callee.id : ''), msgStruct);
            }

            if(_tryEvents) {
                try {
                    result = _publish(eventKey, msgStruct);
                } catch (e) {
                    logError(e,'error whilst publishing event ' + eventKey);
                }
            }else{
                result = _publish(eventKey, msgStruct);
            }
        }

        return result;
    };

    /***
     *
     * Subscribes to multiple events
     * @param keys {String[]}
     * @param _cb {function|null} When null, it expects the owner having a function matching the event key!
     * @param owner {Object}
     * @extends module:xide/factory
     * @memberOf xide/factory
     * @returns {Object[]|null} Returns an array of regular Dojo-subscribe/on handles
     */
    factory.subscribe = function (keys, cb, owner,filter) {
        if(has('debug')){
            if(!keys){
                _debug && console.error('subscribe failed, event key is empty!');
                return null;
            }
        }

        //some vars
        var eventKeys  = keys,
            _subscribe = connect.subscribe,     //cache
            events = [];                        //resulting subscribe handles
            //_isDom = _isElement(owner),       //dom element?

        //normalize to array
        if (!_.isArray(keys)) {
            eventKeys = [keys];
        }

        for (var i = 0,l=eventKeys.length; i < l; i++) {

            if(!eventKeys[i] || filter && !filter(eventKey)){
                continue;
            }

            var _item =
                    //the raw item
                    eventKeys[i],
                    //is string?
                    _isString = _.isString(_item),
                    //if string: use it, otherwise assume struct
                    eventKey =  _isString ? _item : _item.key,
                    //pick handler from arguments or struct
                    _handler = _isString ? cb : _item.handler,
                    //is native event?
                    _isNative = eventKey in _nativeEvents,
                    //the final handle
                    _handle;


            //owner specified, hitch the callback into owner's scope
            if (owner != null) {
                //try cb first, then owner.onEVENT_KEY, that enables similar effect as in Dojo2/Evented
                var _cb = _handler !=null ? _handler : owner[eventKey];
                if(_isNative){
                    _handle = on(owner, eventKey, lang.hitch(owner, _cb));
                }else{
                    _handle = _subscribe(eventKey, lang.hitch(owner, _cb));
                }
                _handle.handler = lang.hitch(owner, _cb);
            } else {
                _handle =  connect.subscribe(eventKey, _handler);
                _handle.handler = _handler;
            }
            //track the actual event type
            _handle.type = eventKey;
            events.push(_handle);
        }
        return events;
    };
    return factory;
});;
define('xide/factory/Objects',[
    'dcl/dcl',
    'xide/utils',
    'xide/factory',
    'xdojo/declare'
], function (dcl,utils, factory, declare) {
    /***
     * Convinience object factory via dojo/declare
     * @param classNameOrPrototype
     * @param ctrArgs
     * @param baseClasses
     * @returns {*}
     */
    factory.createInstance = function (classNameOrPrototype, ctrArgs, baseClasses) {
        var ctrArgsFinal = {};
        utils.mixin(ctrArgsFinal, ctrArgs);
        //prepare object prototype, try dojo and then abort
        var objectProtoType = classNameOrPrototype;
        if (_.isString(classNameOrPrototype)) {
            var proto = dojo.getObject(objectProtoType) || dcl.getObject(objectProtoType);
            if (proto) {
                objectProtoType = proto;
            } else {
                console.error('no such class : ' + classNameOrPrototype);
                return null;
            }
        }

        baseClasses && ( objectProtoType = declare(baseClasses, objectProtoType.prototype));

        if(!ctrArgsFinal.id){
            var className = objectProtoType.declaredClass || 'no_class_';
            ctrArgsFinal.id = className.replace(/\//g, "_") + utils.createUUID();
        }

        var instance = new objectProtoType(ctrArgsFinal);

        //@TODO: trash
        instance && ( instance.ctrArgs = ctrArgsFinal);

        return instance;
    };
    return factory;
});;
define('xblox/model/html/SetState',[
    "dcl/dcl",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    "dojo/dom-attr",
    "dojo/dom-style",
    "dojo/_base/Color",
    "xide/registry"
], function(dcl,Block,utils,types,EventedMixin,Referenced,domAttr,domStyle,Color,registry){
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    var Impl = {
        declaredClass:"xblox.model.html.SetState",
        name:'Set State',
        reference:'',
        references:null,
        description:'Switches to a state',
        value:'',
        mode:1,
        sharable:false,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Run this block
         * @param scope
         * @param settings
         */
        solve:function(scope,settings) {
            var value = this.value;
            settings = settings || {};
            settings.flags = types.CIFLAG.DONT_PARSE;
            var objects = this.resolveReference(this.deserialize(this.reference),settings);
            if(this.override && this.override.variables){
                value = utils.replace(value,null,this.override.variables,{
                    begin:'{',
                    end:'}'
                });
            }
            if(objects && objects.length){
                _.each(objects,function(object){
                    var widget = object
                    var _widget = registry.byId(widget.id) || widget;
                    if(widget!=_widget){

                    }
                    if(_widget && _widget.setState){
                        _widget.setState(value);
                    }
                });
            }
            this.onSuccess(this,settings);
            this.onDidRun();//clear overrides
        },
        /**
         * Get human readable string for the UI
         * @returns {string}
         */
        toText:function(){
            var _ref = this.deserialize(this.reference);
            var result = this.getBlockIcon() + ' ' + this.name + ' :: on ' + _ref.reference + ' to' || ' ' + ' to ';
            if(this.value){
                result+= ' ' + this.value;
            }
            return result;
        },
        /**
         * Standard call when editing this block
         * @returns {*}
         */
        getFields:function(){
            var fields = this.getDefaultFields(false);
            var referenceArgs = {
                group:'General',
                dst:'reference',
                value:this.reference
            };
            fields.push(utils.createCI('State',types.ECIType.STRING,this.value,{
                group:'General',
                dst:'value',
                value:this.value,
                intermediateChanges:false
            }));
            fields.push(utils.createCI('Target',types.ECIType.WIDGET_REFERENCE,this.reference,referenceArgs));
            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-paint-brush"></span>';
        },
        getPropValue:function(stylesObject,prop){
            for (var _prop in stylesObject) {
                if(_prop === prop){
                    return stylesObject[_prop];
                }
            }
            return null;
        },
        updateObject:function(obj,style,mode){
            if(!obj){
                return false;
            }
            mode = mode || 1;
            if(obj.domNode!=null){
                obj = obj.domNode;
            }
            var currentStyle = domAttr.get(obj,'style');
            if(currentStyle===";"){
                currentStyle="";
            }
            if(currentStyle===""){
                if(obj['lastStyle']!=null){
                    currentStyle = obj['lastStyle'];
                }else {
                    currentStyle = style;
                }
            }

            if(currentStyle===";"){
                currentStyle=style;
            }
            switch (mode){
                //set
                case 1:{
                    var currentStyleMap = this._toObject(currentStyle);
                    var props = style.split(';');
                    for (var i = 0; i < props.length; i++) {
                        var _style = props[i].split(':');
                        if(_style.length==2){
                            currentStyleMap[_style[0]]=_style[1];
                        }
                    }
                    var styles=[];
                    for (var p in currentStyleMap){
                        styles.push(p + ':' +currentStyleMap[p]);
                    }
                    $(obj).attr('style',styles.join(';'));
                    break;
                }
                //add
                case 2:{
                    var _newStyle = currentStyle + ';' + style,
                        _newStyleT = _.uniq(_newStyle.split(';')).join(';');
                    domAttr.set(obj,'style',_newStyleT);
                    break;
                }
                //remove
                case 3:{
                    domAttr.set(obj,'style',utils.replaceAll(style,'',currentStyle));
                    break;
                }
                //increase
                case 4:
                //decrease
                case 5:{
                    var	numbersOnlyRegExp = new RegExp(/(\D*)(-?)(\d+)(\D*)/);
                    /**
                     * compute current style values of the object
                     * @type {{}}
                     */
                    var stylesRequested = this._toObject(style);
                    var stylesComputed = {};
                    var jInstance = $(obj);
                    ///determine from node it self
                    if(stylesRequested) {
                        for (var prop in stylesRequested) {
                            stylesComputed[prop] = this._getStyle(prop,obj,jInstance);
                        }
                    }

                    var _newStyleObject = {};
                    /**
                     * compute the new style
                     * @type {number}
                     */
                    for (var prop in stylesRequested){
                        var _prop = '' + prop.trim();
                        var multiplicator = 1;
                        if(stylesComputed[_prop]!=null){

                            var _valueRequested = stylesRequested[prop];
                            var _valueComputed = stylesComputed[prop];

                            var _isHex = _valueRequested.indexOf('#')!=-1;
                            var _isRGB = _valueRequested.indexOf('rgb')!=-1;
                            var _isRGBA = _valueRequested.indexOf('rgba')!=-1;

                            if( _isHex || _isRGB || _isRGBA){

                                var dColorMultiplicator = dojo.colorFromString(_valueRequested);
                                var dColorNow = dojo.colorFromString(_valueRequested);
                                var dColorComputed = dojo.colorFromString(_valueComputed);
                                var dColorNew = new Color();

                                _.each(["r", "g", "b", "a"], function(x){
                                    dColorNew[x] = Math.min(dColorComputed[x] + dColorMultiplicator[x], x=="a" ? 1 : 255);
                                });

                                var _valueOut = '';
                                if(_isHex){
                                    _valueOut = dColorNew.toHex();
                                }else if(_isRGB){
                                    _valueOut = dColorNew.toCss(false);
                                }else if(_isRGBA){
                                    _valueOut = dColorNew.toCss(true);
                                }
                                _newStyleObject[prop]=_valueOut;
                                domStyle.set(obj,prop, _valueOut);


                            }else{
                                //extract actual number :
                                var numberOnly = numbersOnlyRegExp.exec(stylesComputed[_prop]);
                                if(numberOnly && numberOnly.length>=3){
                                    var _int = parseInt(numberOnly[3]);
                                    if(_int && _int>0){
                                        multiplicator  = _int;
                                    }
                                }
                            }
                        }
                    }
                    //now get an object array of the styles we'd like to alter
                    var styles = this._toObject(currentStyle);
                    if(!styles){
                        return false;
                    }
                    break;
                }
            }
        },
        activate:function(){
            this._destroy();//you never know
        },
        deactivate:function(){
            this._destroy();
        }
    };

    //package via declare
    var _class = dcl([Block,EventedMixin.dcl,Referenced.dcl],Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return _class;

});;
define('dojo/_base/Color',["./kernel", "./lang", "./array", "./config"], function(dojo, lang, ArrayUtil, config){

	var Color = dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		//		Work with a Color instance:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var c = new Color();
		//	|		c.setColor([0,0,0]); // black
		//	|		var hex = c.toHex(); // #000000
		//	|	});
		//
		// example:
		//		Work with a node's color:
		//	| 
		//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
		//	|		var color = domStyle("someNode", "backgroundColor");
		//	|		var n = new Color(color);
		//	|		// adjust the color some
		//	|		n.r *= .5;
		//	|		console.log(n.toString()); // rgb(128, 255, 255);
		//	|	});
		if(color){ this.setColor(color); }
	};

	// FIXME:
	// there's got to be a more space-efficient way to encode or discover
	// these!! Use hex?
	Color.named = {
		// summary:
		//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
		"black":  [0,0,0],
		"silver": [192,192,192],
		"gray":	  [128,128,128],
		"white":  [255,255,255],
		"maroon": [128,0,0],
		"red":	  [255,0,0],
		"purple": [128,0,128],
		"fuchsia":[255,0,255],
		"green":  [0,128,0],
		"lime":	  [0,255,0],
		"olive":  [128,128,0],
		"yellow": [255,255,0],
		"navy":	  [0,0,128],
		"blue":	  [0,0,255],
		"teal":	  [0,128,128],
		"aqua":	  [0,255,255],
		"transparent": config.transparentColor || [0,0,0,0]
	};

	lang.extend(Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and sets this color instance to that value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color(); // no color
			//	|		c.setColor("#ededed"); // greyish
			//	|	});
			if(lang.isString(color)){
				Color.fromString(color, this);
			}else if(lang.isArray(color)){
				Color.fromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof Color)){ this.sanitize(); }
			}
			return this;	// Color
		},
		sanitize: function(){
			// summary:
			//		Ensures the object has correct attributes
			// description:
			//		the default implementation does nothing, include dojo.colors to
			//		augment it with real checks
			return this;	// Color
		},
		toRgb: function(){
			// summary:
			//		Returns 3 component array of rgb values
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#000000");
			//	|		console.log(c.toRgb()); // [0,0,0]
			//	|	});
			var t = this;
			return [t.r, t.g, t.b]; // Array
		},
		toRgba: function(){
			// summary:
			//		Returns a 4 component array of rgba values from the color
			//		represented by this object.
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary:
			//		Returns a CSS color string in hexadecimal representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		console.log(new Color([0,0,0]).toHex()); // #000000
			//	|	});
			var arr = ArrayUtil.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary:
			//		Returns a css color string in rgb(a) representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#FFF").toCss();
			//	|		console.log(c); // rgb('255','255','255')
			//	|	});
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary:
			//		Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	Color.blendColors = dojo.blendColors = function(
		/*Color*/ start,
		/*Color*/ end,
		/*Number*/ weight,
		/*Color?*/ obj
	){
		// summary:
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated Color object for the result
		var t = obj || new Color();
		ArrayUtil.forEach(["r", "g", "b", "a"], function(x){
			t[x] = start[x] + (end[x] - start[x]) * weight;
			if(x != "a"){ t[x] = Math.round(t[x]); }
		});
		return t.sanitize();	// Color
	};

	Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Returns a `Color` instance from a string of the form
		//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
		//		object to update with the parsed value and return instead of
		//		creating a new object.
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
	};

	Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Converts a hex string with a '#' prefix to a color object.
		//		Supports 12-bit #rgb shorthand. Optionally accepts a
		//		`Color` object to update with the parsed value.
		//
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		//
		// example:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
		//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
		//	|	});
		var t = obj || new Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // Color
		}
		ArrayUtil.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// Color
	};

	Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
		// summary:
		//		Builds a `Color` from a 3 or 4 element array, mapping each
		//		element in sequence to the rgb(a) values of the color.
		// example:
		//		|	require(["dojo/_base/color"], function(Color){
		//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
		//		|	});
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var t = obj || new Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// Color
	};

	Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
		// summary:
		//		Parses `str` for a color value. Accepts hex, rgb, and rgba
		//		style color values.
		// description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var a = Color.named[str];
		return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
	};

	return Color;
});
;
define('xblox/StyleState',[
    'dcl/dcl',
    'delite/register',
    'delite/CustomElement',
    'xide/factory/Events',
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/_State'
], function (dcl,register, CustomElement, Events, utils, Types,_State) {
    var Impl = {
        declaredClass: 'xblox/StyleState',
        _targetReference: null,        
        name:"Default",
        _widget:null,
        /**
         * Convert Style String to an object array, eg: { color:value,.... }
         * @param styleString
         * @returns {{}}
         * @private
         */
        _toObject:function(styleString){
            if(!styleString){
                return {};
            }
            var _result = {};
            var _values = styleString.split(';');
            for (var i = 0; i < _values.length; i++) {
                var obj = _values[i];
                if(!obj || obj.length==0 || !obj.split){
                    continue;
                }
                var keyVal = obj.split(':');
                if(!keyVal || !keyVal.length){
                    continue;
                }
                var key = obj.substring(0,obj.indexOf(':'));
                var value = obj.substring(obj.indexOf(':')+1,obj.length);

                _result[key]=value;
            }
            return _result;
        },
        _toStyleString:function(values){

            var _values = [];
            for(var prop in values){
                _values.push( prop + ':' + values[prop]);
            }
            return _values.join(';') + ';';
        },
        onChanged:function () {
            this.applyTo(this._widget);
        },
        applyTo:function(widget){
            $(widget).removeClass($(widget).data('_lastCSSState'));
            $(widget).removeClass($(widget).data('_lastCSSClass'));
            if(widget && widget._attached){
                this._widget = widget;
                var _cssWidget = this._toObject($(widget).attr('style'));
                var _cssThis = this._toObject($(this).attr('style'));
                var styleOut = utils.mixin(_cssWidget,_cssThis);
                $(widget).attr('style',this._toStyleString(styleOut));
            }
        }
    };
    var _class = dcl(_State, Impl);
    return register("d-xstate-style", [HTMLElement, CustomElement, _class]);
});;
define('xblox/_State',[
    "dojo/_base/lang",
    "dojo/on",
    "dcl/dcl",//make sure
    "delite/register",
    "delite/CustomElement",
    //explicit because a bootstrap might not be loaded at some point
    "xide/factory/Events",
    //explicit because a bootstrap might not be loaded at some point
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/model/Referenced',
    'xide/mixins/EventedMixin',
    'xide/mixins/ReloadMixin',
    'xwire/Binding',
    'xwire/EventSource',
    'xwire/WidgetTarget'
], function (lang, on, dcl,register, CustomElement, Events, utils, Types, Referenced, EventedMixin, ReloadMixin, Binding, EventSource, WidgetTarget) {
    var debugWidgets = false;
    var debugApp = false;
    var debugAttach = false;
    var debugCreated = false;
    var debugBinding = false;
    var debugRun = false;
    /**
     * Proxy widget to run a selected blox script on the parent widget/node.
     *
     * @class xblox/RunScript
     */
    var Impl = {
        declaredClass: 'xblox/_State',
        script:"",
        bidirectional: false,
        _targetBlock: null,
        _targetReference: null,
        _complete: false,
        enabled: true,
        stop: false,
        _events: [],
        context: null,
        name:"Default",
        isState:true,
        _isState:function(){
            return true;
        },
        /**
         * soft destroy
         */
        reset:function(){
            
        },
        getChildren: function () {
            return [];
        },
        /**
         * @inheritDoc
         */
        destroy: function () {
            this.onDestroy && this.onDestroy();
            this.reset();
        },
        /**
         * The final execution when 'target event' has been triggered. This
         * will run the select block.
         * @param event
         * @param val
         */
        run: function (event, val) {
            if (!this.enabled) {
                return;
            }            
        },
        /**
         * Callback when the minimum parameters are given: targetReference & targetBlock
         */
        onReady: function () {            
        },
        getEnclosingWidget: function (node) {
            if(node) {
                do {
                    if (node.nodeType === 1 && node.render) {
                        return node;
                    }
                } while ((node = node.parentNode));
            }
            return null;
        },
        initWithReference: function (ref) {
            //target node or widget
            if(ref.nodeType!==1){
                return;
            }
            this._targetReference = ref;
        },
        /**
         * Function to setup the target reference
         * on the surrounding widget!
         *
         */
        _setupTargetReference: function () {
            var i = 0,
                element = this,
                widget = null;

            while (i < 2 && !widget) {

                if (element) {
                    element = element.parentNode;
                    widget = this.getEnclosingWidget(element, "widgetId");
                    if (!widget) {
                        widget = this.getEnclosingWidget(element, "widgetid");
                    }
                }
                i++;
            }
            if (widget) {
                debugWidgets && console.info('have widget reference' + '  : ', [widget,this]);
                this.initWithReference(widget);
                if(widget._attached && widget.stateReady){
                    widget.stateReady(this);
                }

            } else {
                if (this.domNode && this.domNode.parentNode) {
                    this.initWithReference(this.domNode.parentNode);
                    debugWidgets && console.error('cant find widget reference, using parent node', this._targetReference);
                } else {
                    if(this.parentNode){
                        this.initWithReference(this.parentNode);
                    }
                    debugWidgets && console.error('cant find widget reference', this);
                }
            }
        },
        onAppReady: function (evt) {
            debugApp && console.log('-ready');
            //resolve target reference
            //if (!this._targetReference) {
                this._setupTargetReference();
            //}

            //track context {xapp/manager/Context}
            if (evt && evt.context) {
                this.context = evt.context;
            }
        },
        detachedCallback:function(){
            debugAttach && console.info('detachedCallback', this);
            if(this._appContext){
                this.destroy();
            }

        },
        applyTo:function(widget){
            
        },
        /**
         * Delite created callback
         */
        createdCallback: function () {
            //console.error('createdCallback', this);
            debugCreated && console.info('createdCallback', this);
            if (!this._targetReference) {
                this._setupTargetReference();
                if(this._targetReference && this._targetReference.stateReady){
                    this._targetReference.stateReady(this);
                }
            }
        },
        attachedCallback: function () {
            debugAttach && console.info('attachedCallback', this);
            if (this._started) {
                return;
            }
            this.onAppReady();//emulates
            this.subscribe(Types.EVENTS.ON_APP_READY);
            this._started = true;
        }

    };
    //package and declare via dcl
    var _class = dcl([EventedMixin.dcl,Referenced.dcl], Impl);
    return _class; 
});;
define('xblox/CSSState',[
    "dcl/dcl",
    "delite/register",
    "delite/CustomElement",
    'xblox/_State',
    'xide/utils',
    'xdojo/has'
], function (dcl,register, CustomElement,_State,utils,has) {
    var extraRules = [],
        extraSheet,
        removeMethod,
        rulesProperty,
        invalidCssChars = /([^A-Za-z0-9_\u00A0-\uFFFF-])/g;

    has.add('dom-contains', function (global, doc, element) {
        return !!element.contains; // not supported by FF < 9
    });
    function removeRule(index) {
        // Function called by the remove method on objects returned by addCssRule.
        var realIndex = extraRules[index],
            i, l;
        if (realIndex === undefined) {
            return; // already removed
        }

        // remove rule indicated in internal array at index
        extraSheet[removeMethod](realIndex);

        // Clear internal array item representing rule that was just deleted.
        // NOTE: we do NOT splice, since the point of this array is specifically
        // to negotiate the splicing that occurs in the stylesheet itself!
        extraRules[index] = undefined;

        // Then update array items as necessary to downshift remaining rule indices.
        // Can start at index + 1, since array is sparse but strictly increasing.
        for (i = index + 1, l = extraRules.length; i < l; i++) {
            if (extraRules[i] > realIndex) {
                extraRules[i]--;
            }
        }
    }
    var Impl = {
        _lastState:null,
        declaredClass: 'xblox/CSSState',
        cssClass:"",
        addCssRule: function (selector, css) {
            // summary:
            //		Dynamically adds a style rule to the document.  Returns an object
            //		with a remove method which can be called to later remove the rule.

            if (!extraSheet) {
                // First time, create an extra stylesheet for adding rules
                extraSheet = document.createElement('style');
                document.getElementsByTagName('head')[0].appendChild(extraSheet);
                // Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
                extraSheet = extraSheet.sheet || extraSheet.styleSheet;
                // Store name of method used to remove rules (`removeRule` for IE < 9)
                removeMethod = extraSheet.deleteRule ? 'deleteRule' : 'removeRule';
                // Store name of property used to access rules (`rules` for IE < 9)
                rulesProperty = extraSheet.cssRules ? 'cssRules' : 'rules';
            }

            var index = extraRules.length;
            extraRules[index] = (extraSheet.cssRules || extraSheet.rules).length;
            extraSheet.addRule ?
                extraSheet.addRule(selector, css) :
                extraSheet.insertRule(selector + '{' + css + '}', extraRules[index]);
            return {
                get: function (prop) {
                    return extraSheet[rulesProperty][extraRules[index]].style[prop];
                },
                set: function (prop, value) {
                    if (typeof extraRules[index] !== 'undefined') {
                        extraSheet[rulesProperty][extraRules[index]].style[prop] = value;
                    }
                },
                remove: function () {
                    removeRule(index);
                },
                sheet:extraSheet
            };
        },
        escapeCssIdentifier: function (id, replace) {
            return typeof id === 'string' ? id.replace(invalidCssChars, replace || '\\$1') : id;
        },
        detachedCallback:function(){
            this._styles && _.each(this._styles,function(style){
                style.remove();
            });
            delete this._styles;
        },
        applyTo:function(widget,name){
            if(this._lastState){
                this._lastState.remove();
            }
            delete this._lastStateName;
            this._lastStateName = name;
            if(!this._attached){
                return;
            }
            var cssClass = this.cssClass;
            var isCSSClass = cssClass.length > 0;
            var id = widget.id || utils.createUUID();
            var _uniqueId = widget.tagName.replace(/\./g,"_") + '_' + id;
            var css = '' + this.innerHTML;
            css = css.replace('.style','');
            css = css.replace(/<(?:.|\n)*?>/gm, '');
            css = css.replace('{','');
            css = css.replace('}','');
            css = css.replace(/(\r\n|\n|\r|\t)/gm,"");

            _uniqueId+='_state_' + name;

            $(widget).removeClass($(widget).data('_lastCSSState'));
            $(widget).removeClass($(widget).data('_lastCSSClass'));
            $(widget).removeClass(cssClass);

            if(!cssClass) {
                $(widget).addClass(_uniqueId);
                $(widget).data('_lastCSSState', _uniqueId);
                var selectorPrefix = '.' + this.escapeCssIdentifier(_uniqueId);
                if (!this._styles) {
                    this._styles = [];
                }
                var style = this.addCssRule(selectorPrefix, css);
                this._styles.push(style);
            }else{
                $(widget).addClass(cssClass);
                $(widget).data('_lastCSSClass', cssClass);
            }
        }

    };

    var _class = dcl([_State], Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return register("d-xstate-css", [HTMLElement, CustomElement, _class]);
});;
define('xblox/mainr',[
    "xblox/component",
    "xblox/embedded",
    "xblox/model/Block",
    "xblox/model/logic/CaseBlock",
    "xblox/model/functions/CallBlock",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/code/RunBlock",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    "xblox/model/logging/Log",
    "xblox/model/html/SetStyle",
    "xblox/model/html/SetCSS",
    "xblox/model/html/SetState",
    "xblox/manager/BlockManager",
    "xblox/factory/Blocks",
    "xblox/model/Referenced",
    "xblox/types/Types",
    "xblox/RunScript",
    "xblox/CSSState",
    "xblox/StyleState"
], function(){});
;
define('xblox/model/html/SetCSS',[
    "dojo/_base/declare",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Targeted'
], function(declare,Block,utils,types,EventedMixin,Targeted){
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    return declare("xblox.model.html.SetCSS",[Block,EventedMixin,Targeted],{
        //method: (String)
        //  block name
        name:'Set CSS',
        file:'',
        reference:'',
        references:null,
        description:'Sets HTML Node CSS',
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        solve:function(scope,settings) {
            this.onSuccess(this,settings);
        },
        toText:function(){
            var result = this.getBlockIcon() + ' ' + this.name + ' :: ';
            if(this.event){
                result+= this.event;
            }
            return result;
        },

        //  standard call for editing
        getFields:function(){
            try {
                var fields = this.inherited(arguments) || this.getDefaultFields();
                fields.push(utils.createCI('File', types.ECIType.FILE, this.file, {
                    group: 'General',
                    dst: 'file',
                    value: this.file,
                    intermediateChanges: false,
                    acceptFolders: false,
                    acceptFiles: true,
                    encodeFilePath: false,
                    buildFullPath: true,
                    filePickerOptions: {
                        dialogTitle: 'Select CSS File',
                        filePickerMixin: {
                            beanContextName: 'CSSFilePicker',
                            persistent: false,
                            globalPanelMixin: {
                                allowLayoutCookies: false
                            }
                        },
                        configMixin: {
                            beanContextName: 'CSSFilePicker',
                            LAYOUT_PRESET: types.LAYOUT_PRESET.SINGLE,
                            PANEL_OPTIONS:{
                                ALLOW_MAIN_MENU:false
                            }
                        },
                        defaultStoreOptions: {
                            "fields": 1663,
                            "includeList": "css",
                            "excludeList": "*"
                        },
                        startPath: this.file
                    }
                }));
                fields.push(utils.createCI('Target', types.ECIType.WIDGET_REFERENCE, this.reference, {
                    group: 'General',
                    dst: 'reference',
                    value: this.reference
                }));

            }catch(e){

            }
            return fields;
        },
        getBlockIcon:function(){
            return '<span class="fa-paint-brush"></span>';
        },
        onReferenceChanged:function(newValue){
            this._destroy();//unregister previous event(s)
            this.reference = newValue;
        },
        onChangeField:function(field,newValue,cis){
            if(field=='reference'){
                this.onReferenceChanged(newValue,cis);
            }
            this.inherited(arguments);
        },
        activate:function(){
            this._destroy();
        },
        deactivate:function(){
            this._destroy();
        },
        _destroy:function(){
        }
    });
});;
define('xblox/model/Targeted',[
    "dojo/_base/declare",
    "./Referenced"
], function(declare,Referenced){

    /**
     * Targeted provides functions to get an object through various ways
     */
    return declare('xblox.model.Targeted',[Referenced],{

    });
});;
/** @module xblox/model/html/SetStyle **/
define('xblox/model/html/SetStyle',[
    "dcl/dcl",
    "xblox/model/Block",
    'xide/utils',
    'xide/types',
    'xide/mixins/EventedMixin',
    'xblox/model/Referenced',
    "dojo/dom-attr",
    "dojo/dom-style",
    "dojo/_base/Color",
    "xide/registry"
], function (dcl, Block, utils, types, EventedMixin, Referenced, domAttr, domStyle, Color, registry) {

    var debug = false;
    /**
     * @augments module:xide/mixins/EventedMixin
     * @lends module:xblox/model/Block_UI
     * @extends module:xblox/model/Block
     * @extends module:xblox/model/ModelBase
     */
    /**
     *
     * @class module:xblox/model/html/SetStyle
     * @extends module:xblox/model/Block
     */
    var Impl = {
        declaredClass: "xblox.model.html.SetStyle",
        name: 'Set Style',
        reference: '',
        references: null,
        description: 'Sets HTML Node Style Attribute',
        value: '',
        mode: 1,
        sharable: true,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  UI
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param params (object in that format : reference(string) | mode (string))
         */
        /**
         * Run this block
         * @param scope
         * @param settings
         */
        solve: function (scope, settings) {
            debug && console.log('-set style solve');
            var value = this.value;
            settings = settings || {};
            var override = settings.override || this.override || {};

            if (override.variables) {
                value = utils.replace(value, null, override.variables, {
                    begin: '{',
                    end: '}'
                });
            }

            if (override.args && override.args[0] !== null) {
                value = utils.replace(value, null, {value: override.args[0]}, {
                    begin: '{',
                    end: '}'
                });
            }
            this.updateObjects(null, value, this.mode, settings);
            this.onSuccess(this, settings);
            this.onDidRun();
        },
        /**
         * Get human readable string for the UI
         * @returns {string}
         */
        toText: function () {
            var _ref = this.deserialize(this.reference);
            var result = this.getBlockIcon() + ' ' + this.name + ' :: on ' + _ref.reference + ' to' || ' ' + ' to ';
            if (this.value) {
                result += ' ' + this.value;
            }
            return result;
        },
        /**
         * Standard call when editing this block
         * @returns {*}
         */
        getFields: function () {
            var fields = this.inherited(arguments) || this.getDefaultFields();
            fields.push(utils.createCI('Value', types.ECIType.DOM_PROPERTIES, this.value, {
                group: 'General',
                dst: 'value',
                value: this.value,
                intermediateChanges: false
            }));
            fields.push(utils.createCI('Mode', types.ECIType.ENUMERATION, this.mode, {
                group: 'General',
                options: [
                    utils.createOption('Set', 1),
                    utils.createOption('Add', 2),
                    utils.createOption('Remove', 3),
                    utils.createOption('Increase', 4),
                    utils.createOption('Decrease', 5)
                ],
                dst: 'mode'
            }));
            var referenceArgs = {
                group: 'General',
                dst: 'reference',
                value: this.reference
            };

            if (this.scope) {
                if (this.scope.global) {
                    referenceArgs.window = this.scope.global;
                    referenceArgs.allowHTMLNodes = true;
                    referenceArgs.allowWidgets = false;

                }
                if (this.scope.document) {
                    referenceArgs.document = this.scope.document;
                }
            }
            fields.push(utils.createCI('Target', types.ECIType.WIDGET_REFERENCE, this.reference, referenceArgs));

            return fields;
        },
        getBlockIcon: function () {
            return '<span class="fa-paint-brush"></span>';
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Lifecycle
        //
        /////////////////////////////////////////////////////////////////////////////////////
        updateEventSelector: function (objects, cis) {
            var options = [];
            if (!objects || !objects.length) {
                options = this.scope.getEventsAsOptions(this.event);
            } else {
                options = [{label: "onclick", value: "onclick"},
                    {label: "ondblclick", value: "ondblclick"},
                    {label: "onmousedown", value: "onmousedown"},
                    {label: "onmouseup", value: "onmouseup"},
                    {label: "onmouseover", value: "onmouseover"},
                    {label: "onmousemove", value: "onmousemove"},
                    {label: "onmouseout", value: "onmouseout"},
                    {label: "onkeypress", value: "onkeypress"},
                    {label: "onkeydown", value: "onkeydown"},
                    {label: "onkeyup", value: "onkeyup"},
                    {label: "onfocus", value: "onfocus"},
                    {label: "onblur", value: "onblur"},
                    {label: "onchange", value: "onchange"}];

                //select the event we are listening to
                for (var i = 0; i < options.length; i++) {
                    var obj = options[i];
                    if (obj.value === this.event) {
                        obj.selected = true;
                        break;
                    }
                }
            }

            for (var i = 0; i < cis.length; i++) {
                var ci = cis[i];
                if (ci['widget'] && ci['widget'].title === 'Event') {
                    var widget = ci['_widget'];
                    widget.nativeWidget.set('options', options);
                    widget.nativeWidget.reset();
                    widget.nativeWidget.set('value', this.event);
                    this.publish(types.EVENTS.RESIZE, {});
                    break;
                }
            }
        },
        onReferenceChanged: function (newValue, cis, settings) {
            this.reference = newValue;
            this.references = this.resolveReference(this.deserialize(newValue), settings);
            this.updateObjects(this.references, this.value, null, settings);
        },
        getPropValue: function (stylesObject, prop) {
            for (var _prop in stylesObject) {
                if (_prop === prop) {
                    return stylesObject[_prop];
                }
            }
            return null;
        },
        _getStyle: function (name, obj, jObj) {
            switch (name) {
                case "height": {
                    return jObj.outerHeight();
                }
                case "width": {
                    return jObj.outerWidth();
                }
                case "color": {
                    return jObj.css("color");
                }
                case "border-color": {
                    return jObj.css("border-color") || "rgba(0,0,0,0)";
                }
            }

            return null;
        },
        updateObject: function (obj, style, mode, settings) {
            if (!obj) {
                return false;
            }
            mode = mode || 1;

            var _obj = obj.id ? registry.byId(obj.id) : null;
            if (_obj) {
                obj = _obj;
            }

            if (obj.domNode != null) {
                obj = obj.domNode;
            }
            var currentStyle = domAttr.get(obj, 'style');
            if (currentStyle === ";") {
                currentStyle = "";
            }
            if (currentStyle === "") {
                if (obj['lastStyle'] != null) {
                    currentStyle = obj['lastStyle'];
                } else {
                    currentStyle = style;
                }
            }

            if (currentStyle === ";") {
                currentStyle = style;
            }
            switch (mode) {
                //set
                case 1: {

                    var currentStyleMap = this._toObject(currentStyle);
                    var props = style.split(';');
                    var css = {};
                    for (var i = 0; i < props.length; i++) {
                        var _style = props[i].split(':');
                        if (_style.length == 2) {
                            currentStyleMap[_style[0]] = _style[1];
                        }
                    }
                    var styles = [];
                    for (var p in currentStyleMap) {
                        styles.push(p + ':' + currentStyleMap[p]);
                    }
                    $(obj).attr('style', styles.join(';'));
                    break;
                }
                //add
                case 2: {

                    var _newStyle = currentStyle + ';' + style,
                        _newStyleT = _.uniq(_newStyle.split(';')).join(';');

                    domAttr.set(obj, 'style', _newStyleT);
                    break;
                }
                //remove
                case 3: {
                    domAttr.set(obj, 'style', utils.replaceAll(style, '', currentStyle));
                    break;
                }
                //increase
                case 4:
                //decrease
                case 5: {
                    var numbersOnlyRegExp = new RegExp(/(\D*)(-?)(\d+)(\D*)/);
                    /**
                     * compute current style values of the object
                     * @type {{}}
                     */
                    var stylesRequested = this._toObject(style);
                    var stylesComputed = {};
                    var jInstance = $(obj);
                    ///determine from node it self
                    if (stylesRequested) {
                        for (var prop in stylesRequested) {
                            var currentStyle = this._getStyle(prop, obj, jInstance);
                            stylesComputed[prop] = currentStyle;
                        }
                    }

                    var _newStyleObject = {};
                    /**
                     * compute the new style
                     * @type {number}
                     */
                    for (var prop in stylesRequested) {
                        var _prop = '' + prop.trim();
                        var multiplicator = 1;
                        if (stylesComputed[_prop] != null) {

                            var _valueRequested = stylesRequested[prop];
                            var _valueComputed = stylesComputed[prop];

                            var _isHex = _valueRequested.indexOf('#') != -1;
                            var _isRGB = _valueRequested.indexOf('rgb') != -1;
                            var _isRGBA = _valueRequested.indexOf('rgba') != -1;

                            if (_isHex || _isRGB || _isRGBA) {

                                var dColorMultiplicator = dojo.colorFromString(_valueRequested);
                                var dColorNow = dojo.colorFromString(_valueRequested);
                                var dColorComputed = dojo.colorFromString(_valueComputed);
                                var dColorNew = new Color();

                                _.each(["r", "g", "b", "a"], function (x) {
                                    dColorNew[x] = Math.min(dColorComputed[x] + dColorMultiplicator[x], x == "a" ? 1 : 255);
                                });

                                console.log('color computed ' + dColorComputed.toRgba() + ' color requested: ' + dColorNow.toRgba() + ' | multiplicator color = ' + dColorMultiplicator.toRgba() + ' is then = ' + dColorNew.toRgba());

                                var _valueOut = '';
                                if (_isHex) {
                                    _valueOut = dColorNew.toHex();
                                } else if (_isRGB) {
                                    _valueOut = dColorNew.toCss(false);
                                } else if (_isRGBA) {
                                    _valueOut = dColorNew.toCss(true);
                                }
                                _newStyleObject[prop] = _valueOut;
                                domStyle.set(obj, prop, _valueOut);

                            } else {
                                //extract actual number :
                                var numberOnly = numbersOnlyRegExp.exec(stylesComputed[_prop]);
                                if (numberOnly && numberOnly.length >= 3) {
                                    var _int = parseInt(numberOnly[3]);
                                    if (_int && _int > 0) {
                                        multiplicator = _int;
                                    }
                                }
                            }
                        }
                    }
                    var delta = mode == 4 ? 1 : -1;
                    //now get an object array of the styles we'd like to alter
                    var styles = this._toObject(currentStyle);
                    var inStyles = this._toObject(style);
                    if (!styles) {
                        return false;
                    }
                    var _skipped = [];
                    for (var prop in styles) {
                        var _prop = '' + prop.trim();
                    }

                    var newStyleString = this._toStyleString(_newStyleObject);
                    break;
                }
            }
        },
        onDomStyleChanged: function (objects, newStyle, mode, settings) {
            objects = objects || this.resolveReference(this.deserialize(this.reference), settings);
            if (!objects) {
                debug && console.warn('have no objects');
                return;
            }
            debug && console.log('change dom style to ' + newStyle + ' on ' + objects.length + ' objects');
            for (var i = 0; i < objects.length; i++) {
                var obj = objects[i];
                if (obj && obj.id && obj.id.indexOf('davinci') != -1) {
                    continue;
                }
                this.updateObject(obj, newStyle, mode, settings);
            }
        },
        /**
         *
         * @param objects
         * @param domStyleString
         * @param mode
         * @param settings
         */
        updateObjects: function (objects, domStyleString, mode, settings) {
            objects = objects || this.resolveReference(this.deserialize(this.reference), settings);
            this.onDomStyleChanged(objects, domStyleString, mode, settings);
        },
        onChangeField: function (field, newValue, cis) {
            this._destroy();
            if (field == 'mode' && newValue !== this.mode) {
                this.mode = newValue;
            }
            if (field == 'value' && newValue !== this.value) {
                this.onDomStyleChanged(null, newValue, this.mode);
                this.value = newValue;
            }
            if (field == 'reference') {
                this.onReferenceChanged(newValue, cis);
            }
            this.inherited(arguments);
        },
        activate: function () {
            this._destroy();//you never know
        },
        deactivate: function () {
            this._destroy();
        },
        _destroy: function () {

        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        _changeValue: function (value, delta) {
            if (!value) {
                return "";
            }
            var split = value.split(" ");
            var result = "";
            for (var i = 0; i < split.length; i++) {
                if (i > 0)
                    result += " ";
                var bits = split[i].match(/([-\d\.]+)([a-zA-Z%]*)/);
                if (!bits) {
                    result += split[i];
                } else {
                    if (bits.length == 1) {
                        result += bits[0];
                    } else {
                        for (var z = 1; z < bits.length; z++) {
                            if (!isNaN(bits[z]) && bits[z] != "") {
                                result += parseFloat(bits[z]) + delta;
                            } else {
                                result += bits[z];
                            }
                        }
                    }
                }
            }
            return result;
        },
        /**
         * Convert Style String to an object array, eg: { color:value,.... }
         * @param styleString
         * @returns {{}}
         * @private
         */
        _toObject: function (styleString) {
            if (!styleString) {
                return {};
            }
            var _result = {};
            var _values = styleString.split(';');
            for (var i = 0; i < _values.length; i++) {
                var obj = _values[i];
                if (!obj || obj.length == 0 || !obj.split) {
                    continue;
                }
                var keyVal = obj.split(':');
                if (!keyVal || !keyVal.length) {
                    continue;
                }
                var key = obj.substring(0, obj.indexOf(':'));
                var value = obj.substring(obj.indexOf(':') + 1, obj.length);

                _result[key] = value;
            }
            return _result;
        },
        _toStyleString: function (values) {
            var _values = [];
            for (var prop in values) {
                _values.push(prop + ':' + values[prop]);
            }
            return _values.join(';') + ';';
        }

    };

    //package via declare
    var _class = dcl([Block, Referenced.dcl], Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return _class;

});;
define('xblox/embedded',[
    'dojo/_base/declare',
    'xide/types',
    'xblox/types/Types',
    'xide/factory',
    'xide/utils',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    "xblox/model/logic/CaseBlock",
    "xblox/model/Block",
    "xblox/model/functions/CallBlock",
    "xblox/model/code/CallMethod",
    "xblox/model/code/RunScript",
    "xblox/model/code/RunBlock",
    "xblox/model/loops/ForBlock",
    "xblox/model/loops/WhileBlock",
    "xblox/model/variables/VariableAssignmentBlock",
    "xblox/model/logic/IfBlock",
    "xblox/model/logic/ElseIfBlock",
    "xblox/model/logic/SwitchBlock",
    "xblox/model/variables/VariableSwitch",
    "xblox/model/events/OnEvent",
    "xblox/model/events/OnKey",
    "xblox/model/logging/Log",
    "xblox/model/html/SetStyle",
    "xblox/model/html/SetCSS",
    "xblox/model/html/SetStyle",
    "xblox/manager/BlockManager",
    "xblox/factory/Blocks",
    "xdojo/has!xblox-ui?xblox/model/Block_UI"
], function () {
    if(!Array.prototype.remove){
        Array.prototype.remove= function(){
            var what, a= arguments, L= a.length, ax;
            while(L && this.length){
                what= a[--L];
                if(this.indexOf==null){
                    break;
                }
                while((ax= this.indexOf(what))!= -1){
                    this.splice(ax, 1);
                }
            }
            return this;
        };
    }
    if(!Array.prototype.swap){
        Array.prototype.swap = function (x,y) {
            var b = this[x];
            this[x] = this[y];
            this[y] = b;
            return this;
        };
    }

    if ( typeof String.prototype.startsWith != 'function' ) {
        String.prototype.startsWith = function( str ) {
            return this.substring( 0, str.length ) === str;
        };
    }

    if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
            return this.substring( this.length - str.length, this.length ) === str;
        };
    }

    if(!Function.prototype.bind) {
        // Cheap polyfill to approximate bind(), make Safari happy
        Function.prototype.bind = Function.prototype.bind || function (that) {
            return dojo.hitch(that, this);
        };
    }
});;
define('xblox/component',[
    "dcl/dcl",
    "xdojo/has",
    "xide/model/Component"
], function (dcl,has,Component) {

    /**
     * @class xblox.component
     * @inheritDoc
     */
    return dcl(Component, {
        /**
         * @inheritDoc
         */
        beanType:'BLOCK',
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Implement base interface
        //
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        _load:function(){
        },
        hasEditors:function(){
            return ['xblox'];
        },
        getDependencies:function(){
            if(has('xblox-ui')) {
                return [
                    'xide/xide',
                    'xblox/types/Types',
                    'xblox/manager/BlockManager',
                    'xblox/manager/BlockManagerUI',
                    'xblox/embedded_ui',
                    'xblox/views/BlockGridPalette',
                    'xide/widgets/ExpressionJavaScript',
                    'xide/widgets/Expression',
                    'xide/widgets/RichTextWidget',
                    'xide/widgets/ExpressionEditor',
                    'xide/widgets/WidgetReference'
                    //'xide/widgets/DomStyleProperties',
                    //'xblox/views/BlocksFileEditor'
                    //'xide/widgets/BlockPickerWidget',
                    //'xide/widgets/BlockSettingsWidget'
                ];
            }else{
                return [
                    'xide/xide',
                    'xblox/types/Types',
                    'xblox/manager/BlockManager',
                    'xblox/embedded'
                ];
            }
        },
        /**
         * @inheritDoc
         */
        getLabel: function () {
            return 'xblox';
        },
        /**
         * @inheritDoc
         */
        getBeanType:function(){
            return this.beanType;
        }
    });
});

;
define('xapp/manager/Application',[
    "dcl/dcl",
    'dojo/Deferred',
    'xide/types',
    'xide/utils',
    //'dojo/dom-construct',
    "xide/manager/ManagerBase"
], function (dcl, Deferred, types, utils, ManagerBase) {
    var debugBootstrap = true;
    var debugBlocks = false;
    //Application
    var Module = dcl([ManagerBase], {
        declaredClass: "xapp/manager/Application",
        delegate: null,
        settings: null,
        constructor: function (args) {
            utils.mixin(this, args);
            this.id = utils.createUUID();
        },
        runBlox: function (path, id, context, settings) {
            var parts = utils.parse_url(path);
            debugBlocks && console.log('run blox: ' + id + ' with ', settings);
            var bm = this.ctx.getBlockManager();
            bm.load(parts.scheme, parts.host).then(function (scope) {
                var block = scope.getBlockById(id);
                if (block) {
                    block.context = context;
                    if (settings) {
                        block.override = settings;
                    }
                    return block.solve(block.scope);
                } else {
                    debugBlocks && console.error('have no block !');
                }
            }, function (e) {
                debugBlocks && console.error('error loading block files ' + e, e);
            });
        },
        onReloaded: function () {
            console.log('on reloaded', arguments);
        },

        run: function (settings) {
            this.settings = settings;
        },
        loadScript: function (url) {
            /*
            debugger;
            domConstruct.create('script', {
                src:url
            }, query('head')[0]);*/
        },
        publishVariables: function () {

            var deviceManager = this.ctx.getDeviceManager();
            if (deviceManager) {
                var deviceInstances = deviceManager.deviceInstances;
                for (var i in deviceInstances) {
                    var instance = deviceInstances[i];
                    var instanceOptions = instance.options;
                    if (!instanceOptions) {
                        continue;
                    }

                    if (instance.blockScope) {
                        var basicVariables = instance.blockScope.getVariables({
                            group: types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES
                        });
                        var out = [];
                        for (var i = 0; i < basicVariables.length; i++) {
                            var variable = basicVariables[i];

                            this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                                item: variable,
                                scope: instance.blockScope,
                                owner: this,
                                save: false,                         //dont save it
                                source: types.MESSAGE_SOURCE.DEVICE,  //for prioritizing
                                publishMQTT: false
                            });
                        }
                    }
                }
            }
        },
        onReady: function () {
            debugBootstrap && console.log('   Checkpoint 5.3 managers ready');
            this.publish(types.EVENTS.ON_APP_READY, {
                context: this.ctx,
                application: this,
                delegate: this.delegate
            });
        },
        onXBloxReady: function () {
            var _re = require,
                thiz = this;
            debugBootstrap && console.log('   Checkpoint 5.2 xblox component ready');
            _re(['xblox/embedded', 'xblox/manager/BlockManager'], function (embedded, BlockManager) {
                debugBootstrap && console.log('   Checkpoint 5.2 setup xblox');
                //IDE's block manager
                if (thiz.delegate && thiz.delegate.ctx) {

                    var ctx = thiz.delegate.ctx;

                    if (ctx.nodeServiceManager) {
                        thiz.ctx.nodeServiceManager = ctx.nodeServiceManager;
                    }

                    if (ctx.getBlockManager()) {
                        thiz.ctx.blockManager = ctx.getBlockManager();
                    }

                    if (ctx.getDriverManager()) {
                        thiz.ctx.driverManager = ctx.getDriverManager();
                        thiz.ctx.deviceManager = ctx.getDeviceManager();
                    }


                    thiz.onReady();


                } else {
                    var blockManagerInstance = new BlockManager();
                    blockManagerInstance.ctx = thiz.ctx;
                    thiz.ctx.blockManager = blockManagerInstance;
                }
                thiz.onReady();
            });
        },
        /**
         *
         * @param settings {Object}
         * @param settings.delegate {xideve/manager/WidgetManager}
         * @returns {Deferred}
         */
        start: function (settings) {
            this.initReload && this.initReload();
            debugBootstrap && console.log('xapp/Application::start ', settings);
            var def = new Deferred();
            var thiz = this;
            this.delegate = settings.delegate;
            debugBootstrap && console.log('Checkpoint 5 xapp/manager/Application->start, load xblox');
            try {
                this.ctx.pluginManager.loadComponent('xblox').then(function () {
                    debugBootstrap && console.log('   Checkpoint 5.1 xblox component loaded');
                    def.resolve(thiz.ctx);
                    thiz.onXBloxReady();
                }, function (e) {
                    debugBootstrap && console.error('error loading xblox - component ' + e, e);
                });
            } catch (e) {
                console.error('error loading xblox ' + e, e);
                def.reject(e);
            }
            window['xapp'] = this;
            return def;
        }
    });


    Module.getApp = function () {
        return window['xapp'];
    }

    return Module;

});
;
/** @module xapp/manager/Context */
define('xapp/manager/Context',[
    "dcl/dcl",
    'xide/manager/ContextBase',
    'xide/manager/PluginManager',
    'xapp/manager/Application',
    'xide/manager/ResourceManager',
    'xide/mixins/EventedMixin',
    'xide/types',
    'xide/utils',
    './_WidgetPickerMixin',
    'xide/manager/Reloadable',
    'xcf/types/Types',
    'xdojo/has',
    'dojo/Deferred'
], function (dcl, ContextBase, PluginManager, Application, ResourceManager, EventedMixin, types, utils, _WidgetPickerMixin, Reloadable, Types, has, Deferred) {
    var isIDE = has('xcf-ui');
    var debugWire = false;
    var debugBoot = true;
    var debugRun = true;
    var Instance = null;
    var NotifierClass = dcl([EventedMixin.dcl], {});
    var Notifier = new NotifierClass({});
    /**
     * Lightweight context for end-user apps
     * @class module:xapp/manager/Context
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xide/manager/ContextBase
     */
    var Module = dcl([ContextBase, Reloadable, _WidgetPickerMixin], {
        declaredClass: "xapp/manager/Context",
        settings: null,
        application: null,
        blockManager: null,
        getUserDirectory: function () {
            var resourceManager = this.getResourceManager(),
                userDir = resourceManager ? resourceManager.getVariable('USER_DIRECTORY') || {} : null;
            return userDir;
        },
        getResourceManager: function () {
            return this.resourceManager;
        },
        getMount: function (mount) {
            var resourceManager = this.getResourceManager();
            var vfsConfig = resourceManager ? resourceManager.getVariable('VFS_CONFIG') || {} : null;
            if (vfsConfig && vfsConfig[mount]) {
                return vfsConfig[mount];
            }
            return null;
        },
        getBlock: function (url) {
            return this.getDeviceManager().getBlock(url);
        },
        getVariable: function (deviceId, driverId, variableId) {
            var deviceManager = ctx.getDeviceManager();
            var device = deviceManager.getDeviceById(deviceId),
                result = null;
            if (!device) {
                return null;
            }
            var driverScope = device.driver;
            //not initiated driver!
            if (driverScope && driverScope.blockScope) {
                driverScope = driverScope.blockScope;
            }

            if (!driverScope) {
                if (device) {
                    var driverId = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                    driverScope = ctx.getBlockManager().getScope(driverId);
                    result = driverScope.getVariableById(driverId + '/' + variableId);
                }
            }
            return result;
        },
        wireNode: function (widget, event, block, params) {
            var thiz = this,
                rejectFunction = null,
                onBeforeRun = null;

            if (!widget['__setup']) {
                widget['__setup'] = {};
            }

            if (widget['__setup'][block.id]) {
                return;
            }
            widget['__setup'][block.id] = true;
            if (params) {
                if (event === types.EVENTS.ON_DRIVER_VARIABLE_CHANGED) {

                    var varParams = params.params;
                    var deviceId = varParams[0],
                        driverId = varParams[1],
                        variableId = varParams[2];

                    var variable = this.getBlock(variableId);
                    rejectFunction = function (evt) {
                        var variable = evt.item;
                        var _variableIn = thiz.getBlock(variableId);
                        if (_variableIn && variable && _variableIn.id === variable.id) {
                            return false;
                        }
                        if (variable.id === variableId) {
                            return false;
                        }
                        return true;
                    };
                    onBeforeRun = function (block, evt) {
                        var variable = evt.item;
                        block.override = {
                            variables: {
                                value: variable.value
                            }
                        };
                    }
                }
            }

            if (!widget) {
                console.error('have no widget for event ' + event);
                return;
            }
            if (!block) {
                console.error('have no block for event ' + event);
                return;
            }

            if (!event) {
                console.error('have no event');
                return;
            }

            if (!_.isString(event)) {
                console.error('event not string ', event);
                return;
            }

            debugWire && console.log('wire node : ' + event);


            /**
             *
             * @param event
             * @param value: original event data
             * @param block
             * @param widget
             */
            var run = function (event, value, block, widget) {

                if (event === 'load' && widget.__didRunLoad) {
                    return;
                }
                if (event === 'load') {
                    widget.__didRunLoad = true;
                }

                if (thiz.delegate && thiz.delegate.isDesignMode && thiz.delegate.isDesignMode()) {
                    return;
                }

                //filter, custom reject function
                if (rejectFunction) {

                    var abort = rejectFunction(value);
                    if (abort) {
                        return;
                    }
                }
                debugRun && console.log('run ! ' + event + ' for block ' + block.name + ':' + block.id);
                if (block._destroyed) {
                    console.error('run failed block invalid, block has been removed');
                    return;
                }

                if (!block.enabled) {
                    return;
                }
                var context = widget,
                    result;
                if (block && context) {
                    block.context = context;
                    block._targetReference = context;
                    if (onBeforeRun) {
                        onBeforeRun(block, value);
                    }
                    result = block.solve(block.scope, {
                        highlight: true,
                        args: [value]
                    });
                    debugWire && console.log('run ' + block.name + ' for even ' + event + ' for ' + this.id, result);
                }
            };

            //patch the target
            if (!widget.subscribe) {
                utils.mixin(widget, EventedMixin.prototype);
            }

            var _target = widget.domNode || widget,
                _event = event,
                _isWidget = widget.declaredClass || widget.startup,
                _hasWidgetCallback = widget.on != null && widget['on' + utils.capitalize(_event)] != null,
                _handle = null,
                _isDelite = _target.render != null && _target.on != null;


            if (_isWidget &&
                //dijit
                (widget.baseClass && widget.baseClass.indexOf('dijitContentPane') != -1)
                //delite
                || widget.render != null || widget.on != null) {
                _isWidget = false;//use on
            }

            if (_target) {
                //plain node
                if (!_isDelite && (!_hasWidgetCallback || !_isWidget)) {
                    if (utils.isSystemEvent(event)) {
                        _handle = widget.subscribe(event, function (evt) {
                            run(event, evt, block, widget);
                        }.bind(this), widget);
                    } else {
                        _handle = widget.__on(_target, event, function (evt) {
                            run(event, evt, block, widget);
                        });
                    }
                } else {
                    _target = widget;
                    var useOn = true;
                    if (useOn) {
                        if (!_isDelite) {
                            var _e = 'on' + utils.capitalize(_event);
                            widget[_e] = function (val, nada) {
                                if (_target.ignore !== true) {
                                    run(event, val);
                                }
                            }
                        } else {
                            if (utils.isSystemEvent(event)) {
                                _handle = _target.subscribe(event, function (evt) {
                                    run(event, evt, block, widget);
                                }.bind(this), widget);
                            }
                            else {
                                if (utils.isNativeEvent(event)) {
                                    event = event.replace('on', '');
                                }
                                _handle = _target.on(event, function (evt) {
                                    var value = evt.target.value;
                                    if ("checked" in evt.target) {
                                        value = evt.target.checked;
                                    }
                                    run(event, value, block, widget);
                                }.bind(this));
                            }
                        }
                    } else {
                        widget['on' + utils.capitalize(_event)] = function (val) {
                            if (_target.ignore !== true) {
                                run(event, val);
                            }
                        }
                    }
                }

                if (_handle) {
                    if (widget.addHandle) {
                        widget.addHandle(event, _handle);
                    }
                    if (!block._widgetHandles) {
                        block._widgetHandles = [];
                    }
                    block._widgetHandles.push(_handle);

                } else {
                    console.error('wire widget: have no handle', widget);
                }
            }
        },
        wireWidget: function (scope, widget, node, event, group, params) {
            var blocks = scope.getBlocks({
                group: group
            });
            debugWire && console.log('wire widget : ' + event + ' for group ' + group, blocks);
            if (!blocks || !blocks.length) {
                debugWire && console.log('have no blocks for group : ' + group);
            }
            for (var j = 0; j < blocks.length; j++) {

                var block = blocks[j];
                debugWire && console.log('activate block : ' + block.name + ' for ' + event, block);
                this.wireNode(widget, event, block, params);
            }
        },
        wireScope: function (scope) {
            debugWire && console.log('wire scope ' + scope.id);
            var allGroups = scope.allGroups(),
                thiz = this,
                delegate = thiz.delegate || {},
                widgets = [];

            var getParams = function (group) {
                var event = null,
                    widgetId = null,
                    parts = group.split('__'),
                    params = [];

                //no element, set to body
                if (parts.length == 1) {
                    event = parts[0];
                    widgetId = 'body';
                    if (isIDE) {
                        var _body = editorContext.rootWidget;
                        _body.domNode.runExpression = editorContext.global.runExpression;
                    }
                }

                if (parts.length == 2) {
                    var blockUrl;
                    //can be: event & block url: onDriverVariableChanged__variable://deviceScope=user_devices&device=bc09b5c4-cfe6-b621-c412-407dbb7bcef8&driver=9db866a4-bb3e-137b-ae23-793b729c44f8&driverScope=user_drivers&block=2219d68b-862f-92ab-de5d-b7a847930a7a
                    //can be: widget id & event: btnCurrentFileName__load
                    if (parts[1].indexOf('://') !== -1) {
                        event = parts[0];
                        widgetId = 'body';
                        blockUrl = parts[1];
                    } else {
                        event = parts[1];
                        widgetId = parts[0];

                    }
                    if (blockUrl) {
                        var url_parts = utils.parse_url(blockUrl);
                        var url_args = utils.urlArgs(url_parts.host);
                        params = [
                            url_args.device.value,
                            url_args.driver.value,
                            blockUrl
                        ]
                    }
                }

                //scripted__onDriverVariableChanged__variable://deviceScope=user_devices&device=bc09b5c4-cfe6-b621-c412-407dbb7bcef8&driver=9db866a4-bb3e-137b-ae23-793b729c44f8&driverScope=user_drivers&block=2219d68b-862f-92ab-de5d-b7a847930a7a
                if (parts.length == 3) {
                    event = parts[1];
                    widgetId = parts[0];
                    var _blockUrl = parts[2];
                    var _url_parts = utils.parse_url(_blockUrl);
                    var _url_args = utils.urlArgs(_url_parts.host);
                    params = [
                        _url_args.device.value,
                        _url_args.driver.value,
                        _blockUrl
                    ]
                }
                if (parts.length == 5) {
                    event = parts[1];
                    widgetId = parts[0];
                    params = [
                        parts[2],
                        parts[3],
                        parts[4]
                    ]

                }

                if (event && widgetId) {
                    var widget = document.getElementById(widgetId);
                    if (!widget && widgetId === 'body') {
                        widget = document.body;
                    }
                    return {
                        event: event,
                        widgetId: widgetId,
                        widget: widget,
                        params: params
                    }
                }

                return null;
            };

            var wireBlock = function (block) {
                block._on(types.EVENTS.ON_ITEM_REMOVED, function (evt) {
                    try {
                        //console.log('on block removed', evt.item);
                        if (block._widgetHandles) {
                            var _handles = block._widgetHandles;
                            for (var i = 0; i < _handles.length; i++) {
                                if (_handles[i].remove) {
                                    _handles[i].remove();
                                }
                            }
                            delete block._widgetHandles;

                        }
                    } catch (e) {
                        console.error('troubble!' + e, e);
                    }
                }, this);
            };
            for (var i = 0; i < allGroups.length; i++) {
                var group = allGroups[i];
                var params = getParams(group);
                if (params && params.widget) {
                    this.wireWidget(scope, params.widget, params.widget.domNode || params.widget, params.event, group, params);
                } else {
                    console.error('cant resolve group ' + group);
                }
                var blocks = scope.getBlocks({
                    group: group
                });
                if (!blocks || !blocks.length) {
                    debugWire && console.warn('have no blocks for group : ' + group);
                }
                if (isIDE) {
                    for (var j = 0; j < blocks.length; j++) {
                        var block = blocks[j];
                        wireBlock(block);
                    }
                }
                params.widget && widgets.indexOf(params.widget) == -1 && widgets.push(params.widget);
            }

            for (var i = 0; i < widgets.length; i++) {
                var widget = widgets[i];
                if (widget.__didEmitLoad) {
                    return;
                }
                debugBoot && console.log('emit load', widget);
                widget.__didEmitLoad = true;
                if (widget.nodeName === 'BODY') {
                    $(widget.nodeName).trigger('load');
                } else {
                    if (widget.emit) {
                        try {
                            widget.emit('load', widget);
                        } catch (e) {
                            console.error('firing load', e);
                        }
                    }
                }
            }

            isIDE && scope._on(types.EVENTS.ON_ITEM_ADDED, function (evt) {
                var params = getParams(evt.item.group);
                if (params && params.widget) {
                    debugWire && console.log('on item added', arguments);
                    var item = evt.item;
                    var editorContext = delegate.getEditorContext ? delegate.getEditorContext() : null;
                    var widget = params.widget.domNode || params.widget;
                    thiz.wireNode(widget, params.event, evt.item, editorContext, params);
                    wireBlock(evt.item);
                }
            });

        },
        onBlockFilesLoaded: function (scopes) {
            if (this.isVE()) {
                return;
            }
            debugBoot && console.log('xapp:onSceneBlocksLoaded, wire scope!', scopes);
            for (var i = 0; i < scopes.length; i++) {
                var scope = scopes[i];
                try {

                    this.wireScope(scope);
                } catch (e) {
                    logError(e, 'onBlockFilesLoaded')
                }
            }
        },
        loadXBloxFiles: function (files) {
            var thiz = this;
            function loadXBLOXFiles() {
                thiz.getBlockManager().loadFiles(files).then(function (scopes) {
                    debugBoot && console.log('   Checkpoint 8.1. xapp/manager/context->xblox files loaded');
                    thiz.onBlockFilesLoaded(scopes);
                })
            }

            files = [];
            if (files.length == 0) {
                var item = this.settings.item;
                if (item) {
                    var mount = utils.replaceAll('/', '', item.mount);
                    var extension = utils.getFileExtension(item.path);
                    var path = item.path.replace('.' + extension, '.xblox');
                    var sceneBloxItem = {
                        mount: mount,
                        path: path
                    };
                    files.push(sceneBloxItem);

                    var content = {
                        "blocks": [],
                        "variables": []
                    };
                    var fileManager = this.getFileManager();
                    if (fileManager.serviceObject) {
                        this.getFileManager().mkfile(mount, path, JSON.stringify(content, null, 2)).then(function () {
                            loadXBLOXFiles();
                        });
                    } else {
                        loadXBLOXFiles();
                    }
                }
            }
        },
        _appModule: null,
        loadAppModule: function (item) {
            if (this._appModule) {
                //return _appModule;
            }
            var dfd = new Deferred();
            if (!item) {
                dfd.resolve();
                return dfd;
            }
            var itemUrl = item.path.replace('./', '').replace('.dhtml', '');
            var mid = item.mount.replace('/', '') + '/' + itemUrl;
            var _require = require;
            mid = mid.split(' ').join('%20');

            var url = _require.toUrl(item.mount.replace('/', '') + '/' + itemUrl);
            debugBoot && console.log('load default app.js ' + mid);
            try {
                _require.undef && _require.undef(mid);
            } catch (e) {
                console.warn('error unloading app module ' + mid, e);
            }
            try {
                //probe
                _require([mid], function (appModule) {
                    dfd.resolve(appModule);
                    _require.config({
                        urlArgs: null
                    });
                });
            } catch (e) {
                console.error('error loading module ', e);
                dfd.resolve();
            }
            this._appModule = dfd;

            return dfd;
        },
        /**
         * Called when all managers and minimum dependencies are loaded.
         *
         * At this point we're load our xblox files and fire them!
         *
         *
         */
        onReady: function (settings) {
            debugBoot && console.log('Checkpoint 8. xapp/manager->onReady');
            if (settings) {
                this.settings = settings;
            } else {
                settings = this.settings;
            }

            var xbloxFiles = this.settings.xbloxScripts || [];
            if (xbloxFiles.length === 0 && settings.item) {
                xbloxFiles.push({
                    path: settings.item.path.replace('.dhtml', '.xblox').replace('.html', '.xblox'),
                    mount: settings.item.mount
                });
            }

            this.loadXBloxFiles(xbloxFiles);
            var thiz = this;
            debugBoot && console.info('-app ready', this);
            if (!this.isVE()) {
                this.loadAppModule(settings.item).then(function () {
                    thiz.application.onReady();
                    console.log('app module loaded from ');
                    setTimeout(function () {
                        thiz.publish('onContextReady', thiz);
                        thiz.publish('DevicesConnected');
                    }, 1500);
                });
            } else {
                this.application.onReady();
                this.application.publishVariables();
            }
            /*
            this.loadAppModule(settings.item).then(function(){
                console.log('app module loaded from ');
                setTimeout(function(){
                    thiz.publish('onContextReady',thiz);
                    thiz.publish('DevicesConnected');
                },1500);
            });
            */
            //this.application.onReady();
        },
        isVE: function () {
            return this.delegate;
        },
        init: function (settings) {
            this.settings = settings;
            if (settings && settings.mixins) {
                this.doMixins(settings.mixins);
            }
            debugBoot && console.log('Checkpoint 7. xapp/manager->init(settings)', settings);
            var thiz = this;
            this.subscribe(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, function (evt) {
                if (thiz._timer) {
                    clearTimeout(thiz._timer);
                    delete thiz._timer;
                }
                var instance = evt.instance;
                if (!instance) {
                    return;
                }
                if (thiz['__instance_variables_' + instance.id]) {
                    //return;
                }
                thiz['__instance_variables_' + instance.id] = true;
                thiz.timer = setTimeout(function () {
                    thiz.publish(types.EVENTS.ON_APP_READY, {
                        context: thiz
                    });
                    thiz.application.publishVariables();
                }, 10);

            });
            
            if (has('debug')) {
                this.loadXIDE();
            }


            function ready() {
                require([
                    'xfile/manager/FileManager',
                    'xide/manager/ResourceManager',
                    'xnode/manager/NodeServiceManager',
                    'xcf/manager/DriverManager',
                    'xcf/manager/DeviceManager',
                    'xcf/manager/BlockManager',
                    'xcf/model/ModelBase',
                    'xcf/model/Command',
                    'xcf/model/Variable',
                    'xcf/factory/Blocks'
                ], function (FileManager, ResourceManager, NodeServiceManager, DriverManager, DeviceManager, BlockManager) {

                    debugBoot && console.log('Checkpoint 7.0 xapp/Context::init');
                    thiz.doMixins(thiz.mixins);
                    thiz.blockManager = thiz.createManager(BlockManager);
                    thiz.blockManager.init();
                    thiz.fileManager = thiz.createManager(FileManager, settings.xFileConfig, {
                        serviceUrl: settings.rpcUrl,
                        singleton: true
                    });
                    thiz.fileManager.init();
                    thiz.resourceManager = thiz.createManager(ResourceManager, settings.xFileConfig, {
                        serviceUrl: settings.rpcUrl,
                        singleton: true
                    });
                    thiz.driverManager = thiz.createManager(DriverManager, null, {
                        serviceUrl: settings.rpcUrl,
                        singleton: true
                    }
                    );
                    thiz.driverManager.init();

                    try {
                        thiz.driverManager.ls('system_drivers').then(function () {
                            thiz.driverManager.ls('user_drivers').then(function () {
                                debugBoot && console.log('Checkpoint 7.1 drivers loaded');

                                thiz.deviceManager = thiz.createManager(DeviceManager, null, {
                                    serviceUrl: settings.rpcUrl,
                                    singleton: true
                                }
                                );
                                thiz.deviceManager.init();
                                thiz.deviceManager.ls('system_devices').then(function () {
                                    thiz.deviceManager.ls('user_devices').then(function () {
                                        debugBoot && console.log('Checkpoint 7.1.1 devices loaded');
                                        thiz.onReady();
                                    });

                                });


                                thiz.resourceManager.init();
                                var nodeServices = settings.NODE_SERVICES;
                                if (nodeServices) {
                                    var url = location.href;
                                    var parts = utils.parse_url(url);
                                    nodeServices[0].host = parts.host;
                                    if (nodeServices[0].info) {
                                        nodeServices[0].info.host = 'http://' + parts.host;
                                    }
                                }

                                thiz.nodeServiceManager = thiz.createManager(NodeServiceManager, null, {
                                    serviceUrl: settings.rpcUrl,
                                    singleton: true,
                                    services: settings.NODE_SERVICES
                                });
                                thiz.nodeServiceManager.init();
                            });
                        });
                        Notifier.publish('onContextReady', thiz);
                    } catch (e) {
                        logError(e);
                    }
                });
            }

            if (!this.isVE()) {
                this.loadAppModule(settings.item).then(function () {
                    ready();
                })
            } else {
                ready();
            }

        },
        mergeFunctions: function (target, source) {
            for (var i in source) {
                var o = source[i];
                if (_.isFunction(source[i])) {
                    debugBoot && console.log('override ' + i);
                    target[i] = o;
                }
            }
        },
        onModuleUpdated: function (evt) {
            var _obj = dojo.getObject(evt.moduleClass);
            if (_obj && _obj.prototype) {
                this.mergeFunctions(_obj.prototype, evt.moduleProto);
            }
        },
        getApplication: function () {
            return this.application;
        },
        getBlockManager: function () {
            return this.blockManager;
        },
        getFileManager: function () {
            return this.fileManager;
        },
        getDriverManager: function () {
            return this.driverManager;
        },
        /**
         *
         * @returns {module:xcf.manager.DeviceManager}
         */
        getDeviceManager: function () {
            return this.deviceManager;
        },
        getNodeServiceManager: function () {
            return this.nodeServiceManager;
        },
        initManagers: function () {
            this.pluginManager.init();
            this.application.init();
        },
        constructManagers: function (settings) {

            this.pluginManager = this.createManager(PluginManager);
            this.application = this.createManager(Application);
            Instance = this;
            var self = this;
            if (settings) {
                this.settings = settings;
                if (settings.delegate) {
                    this.delegate = settings.delegate;
                }
            }
            if (this.isVE() && settings.item) {
                this.loadAppModule(settings.item);
            }

        },
        initVe: function () {
            this.notifier = Notifier;
        }
    });

    Module.getInstance = function () {
        return Instance;
    }
    Module.notifier = Notifier;
    return Module;

});
;
define('xapp/manager/_WidgetPickerMixin',[
    "dcl/dcl",
    'dojo/_base/declare',
    "dojo/dom-class",
    "dojo/dom-construct",
    'xide/utils',
    'xide/registry'
],function(dcl,declare,domClass,domConstruct,utils,registry){

        var outlineVisible = false;
        var boxModelVisible = false;
        var outlineElements = {};
        var isIE =false;
        var isIEStantandMode=false;
        var offlineFragment = null;
        var boxModel, boxModelStyle,
            boxMargin, boxMarginStyle,
            boxBorder, boxBorderStyle,
            boxPadding, boxPaddingStyle,
            boxContent, boxContentStyle;

        var outline = {
            "fbOutlineT": "fbHorizontalLine",
            "fbOutlineL": "fbVerticalLine",
            "fbOutlineB": "fbHorizontalLine",
            "fbOutlineR": "fbVerticalLine"
        };

        var outlineStyle = {
            fbHorizontalLine: "background: #00d706;height: 2px;",
            fbVerticalLine: "background: #00d706;width: 2px;"
        };

        var resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";
        var offscreenStyle = resetStyle + "top:-1234px; left:-1234px;";

        var inspectStyle = resetStyle + "z-index: 2147483500;";
        var inspectModelOpacity = isIE ? "filter:alpha(opacity=80);" : "opacity:0.8;";
        var inspectModelStyle = inspectStyle + inspectModelOpacity;
        var inspectMarginStyle = inspectStyle + "background: #EDFF64; height:100%; width:100%;";
        var inspectBorderStyle = inspectStyle + "background: #666;";
        var inspectPaddingStyle = inspectStyle + "background: SlateBlue;";
        var inspectContentStyle = inspectStyle + "background: SkyBlue;";

        var createBoxModelInspector = function createBoxModelInspector(){
            boxModel = domConstruct.create("div");
            boxModel.id = "fbBoxModel";
            boxModel.firebugIgnore = true;
            boxModelStyle = boxModel.style;
            boxModelStyle.cssText = inspectModelStyle;

            boxMargin = domConstruct.create("div");
            boxMargin.id = "fbBoxMargin";
            boxMarginStyle = boxMargin.style;
            boxMarginStyle.cssText = inspectMarginStyle;
            boxModel.appendChild(boxMargin);

            boxBorder = domConstruct.create("div");
            boxBorder.id = "fbBoxBorder";
            boxBorderStyle = boxBorder.style;
            boxBorderStyle.cssText = inspectBorderStyle;
            boxModel.appendChild(boxBorder);

            boxPadding = domConstruct.create("div");
            boxPadding.id = "fbBoxPadding";
            boxPaddingStyle = boxPadding.style;
            boxPaddingStyle.cssText = inspectPaddingStyle;
            boxModel.appendChild(boxPadding);

            boxContent = domConstruct.create("div");
            boxContent.id = "fbBoxContent";
            boxContentStyle = boxContent.style;
            boxContentStyle.cssText = inspectContentStyle;
            boxModel.appendChild(boxContent);

            offlineFragment.appendChild(boxModel);
        };
        var createOutlineInspector = function createOutlineInspector()
        {
            for (var name in outline)
            {
                var el = outlineElements[name] = domConstruct.create("div");
                el.id = name;
                el.firebugIgnore = true;
                el.style.cssText = inspectStyle + outlineStyle[outline[name]];
                offlineFragment.appendChild(el);
            }
        };
        var destroyBoxModelInspector = function destroyBoxModelInspector()
        {
            boxModel.parentNode.removeChild(boxModel);
        };

        var destroyOutlineInspector = function destroyOutlineInspector()
        {
            for (var name in outline)
            {
                var el = outlineElements[name];
                el.parentNode.removeChild(el);
            }
        };


        return dcl(null,{
            declaredClass:"xide.widgets._WidgetPickerMixin",
            _inspectFrame:null,
            _isInspecting:false,
            _lastInspecting:0,
            inspectorMask:{
            },
            shouldShowOutline:function(el){
            },
            getWindowSize: function()
            {
                var width=0, height=0, el;

                if (typeof this.window.innerWidth == "number")
                {
                    width = this.window.innerWidth;
                    height = this.window.innerHeight;
                }
                else if ((el=this.document.documentElement) && (el.clientHeight || el.clientWidth))
                {
                    width = el.clientWidth;
                    height = el.clientHeight;
                }
                else if ((el=this.document.body) && (el.clientHeight || el.clientWidth))
                {
                    width = el.clientWidth;
                    height = el.clientHeight;
                }

                return {width: width, height: height};
            },
            addEvent:function(object, name, handler, useCapture)
            {
                if (object.addEventListener)
                    object.addEventListener(name, handler, useCapture);
                else
                    object.attachEvent("on"+name, handler);
            },
            removeEvent : function(object, name, handler, useCapture)
            {
                try
                {
                    if (object.removeEventListener)
                        object.removeEventListener(name, handler, useCapture);
                    else
                        object.detachEvent("on"+name, handler);
                }
                catch(e)
                {

                }
            },
            getWindowScrollSize: function()
            {
                var width=0, height=0, el,isIEQuiksMode =false;

                // first try the document.documentElement scroll size
                if (!isIEQuiksMode && (el=this.document.documentElement) &&
                    (el.scrollHeight || el.scrollWidth))
                {
                    width = el.scrollWidth;
                    height = el.scrollHeight;
                }

                // then we need to check if document.body has a bigger scroll size value
                // because sometimes depending on the browser and the page, the document.body
                // scroll size returns a smaller (and wrong) measure
                if ((el=this.document.body) && (el.scrollHeight || el.scrollWidth) &&
                    (el.scrollWidth > width || el.scrollHeight > height))
                {
                    width = el.scrollWidth;
                    height = el.scrollHeight;
                }

                return {width: width, height: height};
            },
            getElementFromPoint: function(x, y)
            {
                var shouldFixElementFromPoint=false;
                if (shouldFixElementFromPoint)
                {
                    var scroll = this.getWindowScrollPosition();
                    return this.document.elementFromPoint(x + scroll.left, y + scroll.top);
                }
                else
                    return this.document.elementFromPoint(x, y);
            },
            getWindowScrollPosition: function()
            {
                var top=0, left=0, el;

                if(typeof this.window.pageYOffset == "number")
                {
                    top = this.window.pageYOffset;
                    left = this.window.pageXOffset;
                }
                else if((el=this.document.body) && (el.scrollTop || el.scrollLeft))
                {
                    top = el.scrollTop;
                    left = el.scrollLeft;
                }
                else if((el=this.document.documentElement) && (el.scrollTop || el.scrollLeft))
                {
                    top = el.scrollTop;
                    left = el.scrollLeft;
                }

                return {top:top, left:left};
            },
            getElementPosition: function(el)
            {
                var left = 0;
                var top = 0;

                do
                {
                    left += el.offsetLeft;
                    top += el.offsetTop;
                }
                while (el = el.offsetParent);

                return {left:left, top:top};
            },
            getElementBox: function(el)
            {
                var result = {};

                if (el.getBoundingClientRect)
                {
                    var rect = el.getBoundingClientRect();

                    // fix IE problem with offset when not in fullscreen mode
                    var offset = 0;//BrowserDetection.IE ?  this.document.body.clientTop || this.document.documentElement.clientTop: 0;

                    var scroll = this.getWindowScrollPosition();

                    result.top = Math.round(rect.top - offset + scroll.top);
                    result.left = Math.round(rect.left - offset + scroll.left);
                    result.height = Math.round(rect.bottom - rect.top);
                    result.width = Math.round(rect.right - rect.left);
                }
                else
                {
                    var position = this.getElementPosition(el);

                    result.top = position.top;
                    result.left = position.left;
                    result.height = el.offsetHeight;
                    result.width = el.offsetWidth;
                }

                return result;
            },
            hideBoxModel: function()
            {
                if (!boxModelVisible) return;

                offlineFragment.appendChild(boxModel);
                boxModelVisible = false;
            },
            hideOutline: function(){
                if (!outlineVisible) return;

                for (var name in outline)
                    offlineFragment.appendChild(outlineElements[name]);

                outlineVisible = false;
            },
            showOutline: function(){

                if (outlineVisible) return;

                if (boxModelVisible) this.hideBoxModel();

                for (var name in outline) {
                    this.document.getElementsByTagName("body")[0].appendChild(outlineElements[name]);
                }

                outlineVisible = true;
            },
            getCSSAutoMarginBox: function(el)
            {
                if (isIE && " meta title input script link a ".indexOf(" "+el.nodeName.toLowerCase()+" ") != -1)
                    return {top:0, left:0, bottom:0, right:0};
                /**/

                if (isIE && " h1 h2 h3 h4 h5 h6 h7 ul p ".indexOf(" "+el.nodeName.toLowerCase()+" ") == -1)
                    return {top:0, left:0, bottom:0, right:0};
                /**/

                var offsetTop = 0;
                if (false && isIEStantandMode)
                {
                    var scrollSize = this.getWindowScrollSize();
                    offsetTop = scrollSize.height;
                }

                var box = this.document.createElement("div");
                //box.style.cssText = "margin:0; padding:1px; border: 0; position:static; overflow:hidden; visibility: hidden;";
                box.style.cssText = "margin:0; padding:1px; border: 0; visibility: hidden;";

                var clone = el.cloneNode(false);
                var text = this.document.createTextNode("&nbsp;");
                clone.appendChild(text);

                box.appendChild(clone);

                this.document.body.appendChild(box);

                var marginTop = clone.offsetTop - box.offsetTop - 1;
                var marginBottom = box.offsetHeight - clone.offsetHeight - 2 - marginTop;

                var marginLeft = clone.offsetLeft - box.offsetLeft - 1;
                var marginRight = box.offsetWidth - clone.offsetWidth - 2 - marginLeft;

                this.document.body.removeChild(box);

                return {top:marginTop+offsetTop, left:marginLeft, bottom:marginBottom-offsetTop, right:marginRight};
            },
            getMeasurementInPixels: function(el, name)
            {
                if (!el) return null;

                var m = this.getMeasurement(el, name);
                var value = m.value;
                var unit = m.unit;

                if (unit == "px")
                    return value;

                else if (unit == "pt")
                    return this.pointsToPixels(name, value);

                else if (unit == "em")
                    return this.emToPixels(el, value);

                else if (unit == "%")
                    return this.percentToPixels(el, value);

                else if (unit == "ex")
                    return this.exToPixels(el, value);

                // TODO: add other units. Maybe create a better general way
                // to calculate measurements in different units.
            },
            getMeasurementBox: function(el, name)
            {
                var result = [];
                var sufixes = name == "border" ?
                    ["TopWidth", "LeftWidth", "BottomWidth", "RightWidth"] :
                    ["Top", "Left", "Bottom", "Right"];

                if (isIE)
                {
                    var propName, cssValue;
                    var autoMargin = null;

                    for(var i=0, sufix; sufix=sufixes[i]; i++)
                    {
                        propName = name + sufix;

                        cssValue = el.currentStyle[propName] || el.style[propName];

                        if (cssValue == "auto")
                        {
                            if (!autoMargin)
                                autoMargin = this.getCSSAutoMarginBox(el);

                            result[i] = autoMargin[sufix.toLowerCase()];
                        }
                        else
                            result[i] = this.getMeasurementInPixels(el, propName);

                    }

                }
                else
                {
                    for(var i=0, sufix; sufix=sufixes[i]; i++)
                        result[i] = this.getMeasurementInPixels(el, name + sufix);
                }

                return {top:result[0], left:result[1], bottom:result[2], right:result[3]};
            },
            drawBoxModel: function(el)
            {
                console.log('-draw');
                // avoid error when the element is not attached a document
                if (!el || !el.parentNode)
                    return;

                var box = this.getElementBox(el);

                var windowSize = this.getWindowSize();
                var scrollPosition = this.getWindowScrollPosition();

                // element may be occluded by the chrome, when in frame mode
                var offsetHeight = 0;//Firebug.chrome.type == "frame" ? Firebug.context.persistedState.height : 0;

                // if element box is not inside the viewport, don't draw the box model
                if (box.top > scrollPosition.top + windowSize.height - offsetHeight ||
                    box.left > scrollPosition.left + windowSize.width ||
                    scrollPosition.top > box.top + box.height ||
                    scrollPosition.left > box.left + box.width )
                    return;

                var top = box.top;
                var left = box.left;
                var height = box.height;
                var width = box.width;

                var margin = Firebug.browser.getMeasurementBox(el, "margin");
                var padding = Firebug.browser.getMeasurementBox(el, "padding");
                var border = Firebug.browser.getMeasurementBox(el, "border");

                boxModelStyle.top = top - margin.top + "px";
                boxModelStyle.left = left - margin.left + "px";
                boxModelStyle.height = height + margin.top + margin.bottom + "px";
                boxModelStyle.width = width + margin.left + margin.right + "px";

                boxBorderStyle.top = margin.top + "px";
                boxBorderStyle.left = margin.left + "px";
                boxBorderStyle.height = height + "px";
                boxBorderStyle.width = width + "px";

                boxPaddingStyle.top = margin.top + border.top + "px";
                boxPaddingStyle.left = margin.left + border.left + "px";
                boxPaddingStyle.height = height - border.top - border.bottom + "px";
                boxPaddingStyle.width = width - border.left - border.right + "px";

                boxContentStyle.top = margin.top + border.top + padding.top + "px";
                boxContentStyle.left = margin.left + border.left + padding.left + "px";
                boxContentStyle.height = height - border.top - padding.top - padding.bottom - border.bottom + "px";
                boxContentStyle.width = width - border.left - padding.left - padding.right - border.right + "px";

                if (!boxModelVisible) this.showBoxModel();
            },
            drawOutline: function(el)
            {
                console.log('-draw outline');
                var border = 2;
                var scrollbarSize = 17;

                var windowSize = this.getWindowSize();
                var scrollSize = this.getWindowScrollSize();
                var scrollPosition = this.getWindowScrollPosition();

                var box = this.getElementBox(el);

                var top = box.top;
                var left = box.left;
                var height = box.height;
                var width = box.width;
                var isIE = false;


                //console.dir(outlineElements);
                var freeHorizontalSpace = scrollPosition.left + windowSize.width - left - width -
                    (!isIE && scrollSize.height > windowSize.height ? // is *vertical* scrollbar visible
                        scrollbarSize : 0);

                var freeVerticalSpace = scrollPosition.top + windowSize.height - top - height -
                    (!isIE && scrollSize.width > windowSize.width ? // is *horizontal* scrollbar visible
                        scrollbarSize : 0);

                var numVerticalBorders = freeVerticalSpace > 0 ? 2 : 1;

                var o = outlineElements;
                var style;

                style = o.fbOutlineT.style;
                style.top = top-border + "px";
                style.left = left + "px";
                style.height = border + "px";  // TODO: on initialize()
                style.width = width + "px";

                style = o.fbOutlineL.style;
                style.top = top-border + "px";
                style.left = left-border + "px";
                style.height = height+ numVerticalBorders*border + "px";
                style.width = border + "px";  // TODO: on initialize()

                style = o.fbOutlineB.style;
                if (freeVerticalSpace > 0)
                {
                    style.top = top+height + "px";
                    style.left = left + "px";
                    style.width = width + "px";
                    //style.height = border + "px"; // TODO: on initialize() or worst case?
                }
                else
                {
                    style.top = -2*border + "px";
                    style.left = -2*border + "px";
                    style.width = border + "px";
                    //style.height = border + "px";
                }

                style = o.fbOutlineR.style;
                if (freeHorizontalSpace > 0)
                {
                    style.top = top-border + "px";
                    style.left = left+width + "px";
                    style.height = height + numVerticalBorders*border + "px";
                    style.width = (freeHorizontalSpace < border ? freeHorizontalSpace : border) + "px";
                }
                else
                {
                    style.top = -2*border + "px";
                    style.left = -2*border + "px";
                    style.height = border + "px";
                    style.width = border + "px";
                }

                if (!outlineVisible) this.showOutline();
            },
            onInspecting: function(e) {

                if (new Date().getTime() - this._lastInspecting > 30) {

                    this._inspectFrame.style.display = "none";
                    var targ = this.getElementFromPoint(e.clientX, e.clientY);

                    this._inspectFrame.style.display = "block";

                    // Avoid inspecting the outline, and the FirebugUI
                    var id = targ.id;
                    if (id && /^fbOutline\w$/.test(id)) return;
                    if (id == "FirebugUI") return;

                    // Avoid looking at text nodes in Opera
                    while (targ.nodeType != 1) targ = targ.parentNode;

                    if (targ.nodeName.toLowerCase() == "body") return;


                    //decided by sub class
                    if(this.isPickable){

                        if(this.isPickable(targ)){
                            this.drawOutline(targ);
                        }else{
                            //console.log('skip !');
                            return;
                        }
                    }else {
                        this.drawOutline(targ);
                    }

/*
                    if (ElementCache(targ)) {
                        var target = "" + ElementCache.key(targ);
                        var lazySelect = function () {
                            inspectorTS = new Date().getTime();

                            if (Firebug.HTML)
                                Firebug.HTML.selectTreeNode("" + ElementCache.key(targ));
                        };

                        if (inspectorTimer) {
                            clearTimeout(inspectorTimer);
                            inspectorTimer = null;
                        }

                        if (new Date().getTime() - inspectorTS > 200)
                            setTimeout(lazySelect, 0);
                        else
                            inspectorTimer = setTimeout(lazySelect, 300);
                    }
*/
                    this._lastInspecting = new Date().getTime();
                }
            },
            destroyInspectorFrame:function (){
                if (this._inspectFrame)
                {
                    this.document.getElementsByTagName("body")[0].removeChild(this._inspectFrame);
                    this._inspectFrame = null;
                }
            },
            stopInspecting: function()
            {
                this._isInspecting= false;

                if (outlineVisible) this.hideOutline();

                this.removeEvent(this._inspectFrame, "mousemove", this.onInspecting);
                this.removeEvent(this._inspectFrame, "mousedown", this.onInspectingClick);
                this.destroyInspectorFrame();
                //Firebug.chrome.inspectButton.restore();
            },
            onInspectingClick: function(e)
            {
                this._inspectFrame.style.display = "none";
                var targ = this.getElementFromPoint(e.clientX, e.clientY);
                this._inspectFrame.style.display = "block";

                // Avoid inspecting the outline, and the FirebugUI
                var id = targ.id;
                if (id && /^fbOutline\w$/.test(id)) return;
                if (id == "FirebugUI") return;

                // Avoid looking at text nodes in Opera
                while (targ.nodeType != 1) targ = targ.parentNode;
                //console.log(targ);
                if(this.onNodePicked){
                    this.onNodePicked(targ);
                }
                this.stopInspecting();
                this._destroy();
            },
            _destroy: function()
            {
                destroyBoxModelInspector();
                destroyOutlineInspector();

                offlineFragment = null;
            },
            _createInspectorFrame:function()
            {
                var resetStyle = "margin:0; padding:0; border:0; position:absolute; overflow:hidden; display:block;";

                //var inspectFrameStyle = resetStyle + "z-index: 2147483550; top:0; left:0; background:url(" +"pixel_transparent.gif);";
                var inspectFrameStyle = resetStyle + "z-index: 2147483550; top:0; left:0;";

                this._inspectFrame= domConstruct.create('div',{

                });

                this._inspectFrame.style.cssText = inspectFrameStyle;
                this.document.getElementsByTagName("body")[0].appendChild(this._inspectFrame);

                var size = this.getWindowScrollSize();
                var thiz = this;

                this._inspectFrame.style.width = size.width + "px";
                this._inspectFrame.style.height = size.height + "px";

                this.addEvent(this._inspectFrame, "mousemove", function(e){
                    thiz.onInspecting(e);
                });
                this.addEvent(this._inspectFrame, "mousedown", function(e){
                    thiz.onInspectingClick(e);
                });

            },
            initInspector : function(){
                offlineFragment = document.createDocumentFragment();
                createBoxModelInspector();
                createOutlineInspector();
            },
            isPickable: function (node) {

                if (this.allowWidgets) {
                    var widget = registry.getEnclosingWidget(node);
                    if (widget) {
                        if (this.skipWidgetClasses.indexOf(widget.declaredClass) > -1) {
                            return false;
                        }
                        if (node.id && node.id == widget.id) {
                            return true;
                        } else {
                        }
                    } else {
                        return false;
                    }

                } else if (this.allowHTMLNodes) {
                    return true;
                }

                return false;

            },
            startInspecting: function()
            {
                this._isInspecting = true;
                var data = this.userData;

                this.window=window;
                this.document=/*data.document || */document;
                this.initInspector();
                this._createInspectorFrame();
            },
            _pick:function(){
                try {
                    this.startInspecting();
                }catch(e){
                    console.error('inspector crash!');
                }
            }

        });
    });;
define('dojo/dom-class',["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

            if(!node){
                //console.error('dom class::add failed');
                return;
            }
			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
            if(!node){
                console.error('dom class remove failed');
                return;
            }
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling dojo.removeClass and dojo.addClass
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
});
;
/** module:xide/manager/ContextBase **/
define('xide/manager/ContextBase',[
    'dcl/dcl',
    'xide/factory',
    'xide/types',
    'xide/utils',
    'xide/mixins/EventedMixin',
    'dojo/_base/kernel',
    'dojo/_base/lang'
], function (dcl, factory, types, utils, EventedMixin, dojo, lang) {
    var _debug = false;
    /**
     * @class module:xide/manager/ContextBase
     * @extends module:xide/mixins/EventedMixin
     */
    var Module = dcl(EventedMixin.dcl, {
        declaredClass: "xide.manager.ContextBase",
        language: "en",
        managers: [],
        mixins: null,
        _getModuleDojo: function (mid) {
            return lang.getObject(utils.replaceAll('/', '.', mid)) || lang.getObject(mid);
        },
        _getModuleDcl: function (mid) {
            return (dcl.getObject ? dcl.getObject(mid) || dcl.getObject(utils.replaceAll('/', '.', mid)) : null);
        },
        /**
         *
         * @param module {string}
         * @returns {*|Object|null}
         */
        getModule: function (module) {
            return this._getModuleDojo(module) || this._getModuleDcl(module);
        },
        /**
         * @param mid {string}
         * @param object {module}
         * @returns {*|Object|null}
         */
        setModule: function (mid, module) {
            var moduleDojo = this._getModuleDojo(mid);
            if (moduleDojo) {
                return lang.setObject(utils.replaceAll('/', '.', mid), module);
            }
            var moduleDCL = this._getModuleDcl(mid);
            if (moduleDCL) {
                return dcl.setObject(utils.replaceAll('/', '.', mid), module);
            }
        },
        /***
         * createManager creates and instances and tracks it in a local array.
         * @param clz : class name or prototype
         * @param config {object|null}: explicit config, otherwise its using local config
         * @param ctrArgs {object|null}: extra constructor arguments
         * @returns {module:xide/manager/ManagerBase} : instance of the manager
         */
        createManager: function (clz, config, ctrArgs) {
            try {
                if (!this.managers) {
                    this.managers = [];
                }
                //1. prepare constructor arguments
                var ctrArgsFinal = {
                    ctx: this,
                    config: config || this.config
                };
                utils.mixin(ctrArgsFinal, ctrArgs);
                if (_.isString(clz) && this.namespace) {
                    var _clz = null;
                    if (clz.indexOf('.') == -1) {
                        _clz = this.namespace + clz;
                    } else {
                        _clz = '' + clz;
                    }
                    //test this really exists, if not fallback to default namespace
                    if (!dojo.getObject(_clz) || !dcl.getObject(_clz)) {
                        _debug && console.log('creating manager instance : ' + _clz + ' doesnt exists!' + ' Using default! ');
                        clz = this.defaultNamespace + clz;
                    } else {
                        clz = _clz;
                    }
                    _debug && console.log('creating manager instance : ' + clz);
                } else if (_.isObject(clz)) {
                    _debug && console.log('creating manager instance : ' + (clz.declaredClass || clz.prototype.declaredClass));
                }

                //2. create instance
                var mgr = factory.createInstance(clz, ctrArgsFinal);
                if (!mgr) {
                    _debug && console.error('creating manager instance failed : ' + clz);
                    return;
                }

                //3. track instance
                this.managers.push(mgr);

                //4. tell everybody
                factory.publish(types.EVENTS.ON_CREATED_MANAGER, {
                    instance: mgr,
                    className: clz,
                    ctx: this,
                    config: config || this.config
                });

                return mgr;
            } catch (e) {
                console.error('error creating manager ' + e, arguments);
            }
        },
        constructManagers: function () {
        },
        initManagers: function () {
        },
        /***
         * Monkey patch prototypes
         * @param mixins
         */
        doMixins: function (mixins) {
            this.mixins = mixins || this.mixins;
            for (var i = 0; i < mixins.length; i++) {
                var mixin = mixins[i];
                var obj = this.getModule(mixin.declaredClass);
                if (mixin.declaredClass === this.declaredClass) {
                    obj = this;
                }
                if (obj) {
                    utils.mixin(obj.prototype, mixin.mixin);
                } else {
                    _debug && console.error('couldnt apply mixin to : ' + mixin.declaredClass);
                }
            }
        }
    });
    dcl.chainAfter(Module, 'constructManagers');
    dcl.chainAfter(Module, 'initManagers');
    return Module;
});;
define('xfile/types',[
    'xide/utils',
    'xide/types',
    'xide/types/Types',
    'xaction/types'
],function(utils,types){
        /**
         * Public mime registry setter
         * @param type
         * @param map
         */
        types.registerCustomMimeIconExtension = function (type, map) {
            types['customMimeIcons'][type] = map;
        };

        var ACTION = types.ACTION;

        var DEFAULT_PERMISSIONS = [
            ACTION.EDIT,
            ACTION.COPY,
            ACTION.CLOSE,
            ACTION.MOVE,
            ACTION.RENAME,
            ACTION.DOWNLOAD,
            ACTION.RELOAD,
            ACTION.DELETE,
            ACTION.NEW_FILE,
            ACTION.NEW_DIRECTORY,
            ACTION.CLIPBOARD,
            ACTION.LAYOUT,
            ACTION.COLUMNS,
            ACTION.SELECTION,
            ACTION.PREVIEW,
            ACTION.OPEN_IN,
            ACTION.GO_UP,
            ACTION.SEARCH,
            ACTION.OPEN_IN_TAB,
            ACTION.TOOLBAR,
            ACTION.STATUSBAR,
            ACTION.UPLOAD,
            ACTION.SIZE_STATS,
            ACTION.CONSOLE,
            ACTION.HEADER,
            'File/Compress',
            'File/New',
            ACTION.CONTEXT_MENU,
            ACTION.SOURCE,
            'File/OpenInOS'
        ];

        types.DEFAULT_FILE_GRID_PERMISSIONS = DEFAULT_PERMISSIONS;

        types.FIELDS = {
            SHOW_ISDIR:1602,
            SHOW_OWNER:1604,
            SHOW_MIME:1608,
            SHOW_SIZE:1616,
            SHOW_PERMISSIONS:1632,
            SHOW_TIME:1633,
            SHOW_FOLDER_SIZE:1634,
            SHOW_FOLDER_HIDDEN:1635,
            SHOW_TYPE:1636,
            SHOW_MEDIA_INFO:1637
        };

        types.FILE_PANEL_LAYOUT =
        {
            TREE:1,
            LIST:2,
            THUMB:3,
            PREVIEW:4,
            COVER:5,
            SPLIT_VERTICAL:6,
            SPLIT_HORIZONTAL:7,
            IMAGE_GRID:8
        };

        types.LAYOUT_PRESET =
        {
            DUAL:1,
            SINGLE:2,
            BROWSER:3,
            PREVIEW:4,
            GALLERY:5,
            EDITOR:6
        };

        types.PANEL_OPTIONS = {
            ALLOW_NEW_TABS:true,
            ALLOW_MULTI_TAB:false,
            ALLOW_INFO_VIEW:true,
            ALLOW_LOG_VIEW:true,
            ALLOW_CONTEXT_MENU:true,
            ALLOW_LAYOUT_SELECTOR:true,
            ALLOW_SOURCE_SELECTOR:true,
            ALLOW_COLUMN_RESIZE:true,
            ALLOW_COLUMN_REORDER:true,
            ALLOW_COLUMN_HIDE:true,
            ALLOW_ACTION_TOOLBAR:true,
            ALLOW_MAIN_MENU:true
        };

        /**
         * @TODO: remove
         * @type {{LAYOUT: number, AUTO_OPEN: boolean}}
         */
        types.FILE_PANEL_OPTIONS_LEFT={
            LAYOUT:2,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_MAIN={
            LAYOUT:3,
            AUTO_OPEN:true
        };

        types.FILE_PANEL_OPTIONS_RIGHT={
            LAYOUT:3,
            AUTO_OPEN:true
        };
        types.FILE_GRID_COLUMNS =
        {
            NAME:'name',
            SIZE:'size',
            MODIFIED:'modified'
        };
        types.ACTION_TOOLBAR_MODE =
        {
            SELF:'self'
        };

        utils.mixin(types.ITEM_TYPE,{
            FILE:'BTFILE'
        });

        /***
         *
         * Extend the core events with xfile specific events
         */
        /**
         * ActionVisibility
         * @enum module:xide/types/EVENTS
         * @memberOf module:xide/types
         */
        utils.mixin(types.EVENTS,{
            STORE_CHANGED:'onStoreChange',
            BEFORE_STORE_CHANGE:'onBeforeStoreChange',
            STORE_REFRESHED:'onStoreRefreshed',
            ON_FILE_STORE_READY:'onFileStoreReady',
            ON_DID_OPEN_ITEM:'onDidOpenItem',
            ON_SHOW_PANEL:'onShowPanel',
            ITEM_SELECTED:'onItemSelected',
            ERROR:'fileOperationError',
            STATUS:'fileOperationStatus',
            IMAGE_LOADED:'imageLoaded',
            IMAGE_ERROR:'imageError',
            RESIZE:'resize',
            ON_UPLOAD_BEGIN:'onUploadBegin',
            ON_UPLOAD_PROGRESS:'onUploadProgress',
            ON_UPLOAD_FINISH:'onUploadFinish',
            ON_UPLOAD_FAILED: 'onUploadFailed',
            ON_CLIPBOARD_COPY:'onClipboardCopy',
            ON_CLIPBOARD_PASTE:'onClipboardPaste',
            ON_CLIPBOARD_CUT:'onClipboardCut',
            ON_CONTEXT_MENU_OPEN:'onContextMenuOpen',
            ON_PLUGIN_LOADED:'onPluginLoaded',
            ON_PLUGIN_READY:'onPluginReady',
            ON_MAIN_VIEW_READY:'onMainViewReady',
            ON_FILE_CONTENT_CHANGED:'onFileContentChanged',
            ON_PANEL_CLOSED:'onPanelClosed',
            ON_PANEL_CREATED:'onPanelCreated',
            ON_COPY_BEGIN:'onCopyBegin',
            ON_COPY_END:'onCopyEnd',
            ON_DOWNLOAD_TO_BEGIN:'onDownloadToBegin',
            ON_DOWNLOAD_TO_END:'onDownloadToEnd',
            ON_DELETE_BEGIN:'onDeleteBegin',
            ON_DELETE_END:'onDeleteEnd',
            ON_MOVE_BEGIN:'onMoveBegin',
            ON_MOVE_END:'onMoveEnd',
            ON_COMPRESS_BEGIN:'onCompressBegin',
            ON_COMPRESS_END:'onCompressEnd',
            ON_SOURCE_MENU_OPEN:'onSourceMenuOpen',
            ON_MOUNT_DATA_READY:'onMountDataReady',
            ON_XFILE_READY:'onXFileReady',
            ON_CHANGE_PERSPECTIVE:'onChangePerspective',
            ON_FILE_PROPERTIES_RENDERED:'onFilePropertiesRendered'
        });

        /**
         * SELECTION_MODE specfies the possible selection modes for xfile grid views
         * @enum module:xide/types/SELECTION_MODE
         * @memberOf module:xide/types
         */
        types.SELECTION_MODE =
        {
            /** Single
             * @const
             * @type {string}
             */
            SINGLE:'single',
            /** Multiple
             * @const
             * @type {string}
             */
            MULTI:'multiple',
            /** Extended
             * @const
             * @type {string}
             */
            EXTENDED:'extended'
        };

        /**
         * @TODO: remove
         * OPERATION is the string representation of xfile commands
         * @enum module:xide/types/OPERATION
         * @memberOf module:xide/types
         */
        types.OPERATION=
        {

            COPY:'copy',
            MOVE:'move',
            RENAME:'rename',
            DELETE:'delete',
            OPEN:'open',
            EDIT:'edit',
            DOWNLOAD:'download',
            DOWNLOAD_TO:'downloadTo',
            INFO:'info',
            COMPRESS:'compress',
            RELOAD:'reload',
            PREVIEW:'preview',
            INSERT_IMAGE:'insertImage',
            COPY_PASTE:'copypaste',
            DND:'dnd',
            OPTIONS:'options',
            NEW_FILE:'mkfile',
            NEW_DIRECTORY:'mkdir',
            GET_CONTENT:'get',
            SET_CONTENT:'set',
            FIND:'find',
            CUSTOM:'custom',
            PERMA_LINK:'permaLink',
            ADD_MOUNT:'ADD_MOUNT',
            REMOVE_MOUNT:'REMOVE_MOUNT',
            EDIT_MOUNT:'EDIT_MOUNT',
            PERSPECTIVE:'PERSPECTIVE',
            EXTRACT:'extract'
        };

        /**
         * @TODO: remove
         * OPERATION_INT is the integer version of {xide/types/OPERATION}
         * @enum module:xide/types/OPERATION_INT
         * @memberOf module:xide/types
         */
        types.OPERATION_INT={
            NONE:0,
            EDIT:1,
            COPY:2,
            MOVE:3,
            INFO:4,
            DOWNLOAD:5,
            COMPRESS:6,
            DELETE:7,
            RENAME:8,
            DND:9,
            COPY_PASTE:10,
            OPEN:11,
            RELOAD:12,
            PREVIEW:13,
            INSERT_IMAGE:15,
            NEW_FILE:16,
            NEW_DIRECTORY:17,
            UPLOAD:18,
            READ:19,
            WRITE:20,
            PLUGINS:21,
            CUSTOM:22,
            FIND:23,
            PERMA_LINK:24,
            ADD_MOUNT:25,
            REMOVE_MOUNT:26,
            EDIT_MOUNT:27,
            PERSPECTIVE:28,      //change perspective
            CLIPBOARD_COPY:29,
            CLIPBOARD_CUT:30,
            CLIPBOARD_PASTE:31,
            EXTRACT:32
        };

    return types;
});;
/** @module xide/utils/CSSUtils
 *  @description All string related functions
 */
define('xide/utils/CSSUtils',[
    'xide/utils',
    'xide/types'

], function (utils, types) {


    "use strict";

    /**
     *
     * @param styleString
     * @param property
     * @returns {*}
     */
    utils.findStyle=function(styleString,property){
        var parser = new CSSParser();
        var content = ".foo{";
        content+=styleString;
        content+="}";
        var sheet=parser.parse(content, false, true);
        var declarations = sheet.cssRules[0].declarations;
        var declaration = _.find(declarations,{
            property:property
        });

        if(declaration){
            return declaration.valueText;
        }
        return "";
    }

    /**
     *
     * @param styleString
     * @returns {*}
     */
    utils.getBackgroundUrl=function(styleString){
        var background = utils.findStyle(styleString,"background-image");
        if(background) {
            try {
                return background.match(/\((.*?)\)/)[1].replace(/('|")/g, '');
            }catch(e){}
        }
        return null;
    }

    return utils;
});
;
define('xide/utils/ObjectUtils',[
    'xide/utils',
    'require',
    "dojo/Deferred",
    'xide/lodash'
], function (utils, require, Deferred, lodash) {
    var _debug = false;
    "use strict";

    utils.delegate = (function () {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {
        }

        return function (obj, props) {
            TMP.prototype = obj;
            var tmp = new TMP();
            TMP.prototype = null;
            if (props) {
                lang._mixin(tmp, props);
            }
            return tmp; // Object
        };
    })();

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Loader utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.debounce = function (who, methodName, _function, delay, options, now, args) {
        var _place = who[methodName + '_debounced'];
        if (!_place) {
            _place = who[methodName + '_debounced'] = lodash.debounce(_function, delay, options);
        }
        if (now === true) {
            if (!who[methodName + '_debouncedFirst']) {
                who[methodName + '_debouncedFirst'] = true;
                _function.apply(who, args);
            }
        }
        return _place();
    };


    utils.pluck = function (items, prop) {
        return lodash.map(items, prop);
    };

    /**
     * Trigger downloadable file
     * @param filename
     * @param text
     */
    utils.download = function (filename, text) {
        var element = document.createElement('a');
        text = lodash.isString(text) ? text : JSON.stringify(text, null, 2);
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    /**
     * Ask require registry at this path
     * @param mixed
     * @returns {*}
     */
    utils.hasObject = function (mixed) {
        var result = null;
        var _re = require;
        try {
            result = _re(mixed);
        } catch (e) {
            console.error('error in utils.hasObject ', e);
        }
        return result;
    };
    /**
     * Safe require.toUrl
     * @param mid {string}
     */
    utils.toUrl = function (mid) {
        var _require = require;
        //make sure cache bust is off otherwise it appends ?time
        _require({
            cacheBust: null,
            waitSeconds: 5
        });
        return _require.toUrl(mid);
    }
    /**
     * Returns a module by module path
     * @param mixed {String|Object}
     * @param _default {Object} default object
     * @returns {Object|Promise}
     */
    utils.getObject = function (mixed, _default) {
        var result = null;
        if (utils.isString(mixed)) {
            var _re = require;
            try {
                result = _re(mixed);
            } catch (e) {
                _debug && console.warn('utils.getObject::require failed for ' + mixed);
            }
            //not a loaded module yet
            try {
                if (!result) {
                    var deferred = new Deferred();
                    //try loader
                    result = _re([
                        mixed
                    ], function (module) {
                        deferred.resolve(module);
                    });
                    return deferred.promise;
                }
            } catch (e) {
                _debug && console.error('error in requiring ' + mixed, e);
            }
            return result;

        } else if (utils.isObject(mixed)) {
            return mixed;//reflect
        }
        return result !== null ? result : _default;
    };


    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  True object utils
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    utils.toArray = function (obj) {
        var result = [];
        for (var c in obj) {
            result.push({
                name: c,
                value: obj[c]
            });
        }
        return result;
    };
    /**
     * Array to object conversion
     * @param arr
     * @returns {Object}
     */
    utils.toObject = function (arr, lodash) {
        if (!arr) {
            return {};
        }
        if (lodash !== false) {
            return lodash.object(lodash.map(arr, lodash.values));
        } else {
            //CI related back compat hack
            if (utils.isObject(arr) && arr[0]) {
                return arr[0];
            }

            var rv = {};
            for (var i = 0; i < arr.length; ++i) {
                rv[i] = arr[i];
            }
            return rv;
        }
    };

    /**
     * Gets an object property by string, eg: utils.byString(someObj, 'part3[0].name');
     * @deprecated, see objectAtPath below
     * @param o {Object}    : the object
     * @param s {String}    : the path within the object
     * @param defaultValue {Object|String|Number} : an optional default value
     * @returns {*}
     */
    utils.byString = function (o, s, defaultValue) {
        s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        s = s.replace(/^\./, '');           // strip a leading dot
        var a = s.split('.');
        while (a.length) {
            var n = a.shift();
            if (n in o) {
                o = o[n];
            } else {
                return;
            }
        }
        return o;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Internals
     */

        //cache
    var toStr = Object.prototype.toString,
        _hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * @private
     * @param type
     * @returns {*}
     */
    function toString(type) {
        return toStr.call(type);
    }

    /**
     * @private
     * @param key
     * @returns {*}
     */
    function getKey(key) {
        var intKey = parseInt(key, 10);
        if (intKey.toString() === key) {
            return intKey;
        }
        return key;
    }

    /**
     * internal set value at path in object
     * @private
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    function set(obj, path, value, doNotReplace) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return set(obj, path.split('.').map(getKey), value, doNotReplace);
        }
        var currentPath = path[0];

        if (path.length === 1) {
            var oldVal = obj[currentPath];
            if (oldVal === void 0 || !doNotReplace) {
                obj[currentPath] = value;
            }
            return oldVal;
        }

        if (obj[currentPath] === void 0) {
            //check if we assume an array
            if (lodash.isNumber(path[1])) {
                obj[currentPath] = [];
            } else {
                obj[currentPath] = {};
            }
        }
        return set(obj[currentPath], path.slice(1), value, doNotReplace);
    }

    /**
     * deletes an property by a path
     * @param obj
     * @param path
     * @returns {*}
     */
    function del(obj, path) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isString(path)) {
            return del(obj, path.split('.'));
        }

        var currentPath = getKey(path[0]);
        var oldVal = obj[currentPath];

        if (path.length === 1) {
            if (oldVal !== void 0) {
                if (lodash.isArray(obj)) {
                    obj.splice(currentPath, 1);
                } else {
                    delete obj[currentPath];
                }
            }
        } else {
            if (obj[currentPath] !== void 0) {
                return del(obj[currentPath], path.slice(1));
            }
        }
        return obj;
    }

    /**
     * Private helper class
     * @private
     * @type {{}}
     */
    var objectPath = {};

    objectPath.has = function (obj, path) {
        if (lodash.isEmpty(obj)) {
            return false;
        }
        if (lodash.isNumber(path)) {
            path = [path];
        } else if (lodash.isString(path)) {
            path = path.split('.');
        }

        if (lodash.isEmpty(path) || path.length === 0) {
            return false;
        }

        for (var i = 0; i < path.length; i++) {
            var j = path[i];
            if ((lodash.isObject(obj) || lodash.isArray(obj)) && _hasOwnProperty.call(obj, j)) {
                obj = obj[j];
            } else {
                return false;
            }
        }

        return true;
    };

    /**
     * Define private public 'ensure exists'
     * @param obj
     * @param path
     * @param value
     * @returns {*}
     */
    objectPath.ensureExists = function (obj, path, value) {
        return set(obj, path, value, true);
    };

    /**
     * Define private public 'set'
     * @param obj
     * @param path
     * @param value
     * @param doNotReplace
     * @returns {*}
     */
    objectPath.set = function (obj, path, value, doNotReplace) {
        return set(obj, path, value, doNotReplace);
    };

    /**
     Define private public 'insert'
     * @param obj
     * @param path
     * @param value
     * @param at
     */
    objectPath.insert = function (obj, path, value, at) {
        var arr = objectPath.get(obj, path);
        at = ~~at;
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.splice(at, 0, value);
    };

    /**
     * Define private public 'empty'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.empty = function (obj, path) {
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            return void 0;
        }

        var value, i;
        if (!(value = objectPath.get(obj, path))) {
            return obj;
        }

        if (lodash.isString(value)) {
            return objectPath.set(obj, path, '');
        } else if (lodash.isBoolean(value)) {
            return objectPath.set(obj, path, false);
        } else if (lodash.isNumber(value)) {
            return objectPath.set(obj, path, 0);
        } else if (lodash.isArray(value)) {
            value.length = 0;
        } else if (lodash.isObject(value)) {
            for (i in value) {
                if (_hasOwnProperty.call(value, i)) {
                    delete value[i];
                }
            }
        } else {
            return objectPath.set(obj, path, null);
        }
    };

    /**
     * Define private public 'push'
     * @param obj
     * @param path
     */
    objectPath.push = function (obj, path /*, values */) {
        var arr = objectPath.get(obj, path);
        if (!lodash.isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
        }
        arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
    };

    /**
     * Define private public 'coalesce'
     * @param obj
     * @param paths
     * @param defaultValue
     * @returns {*}
     */
    objectPath.coalesce = function (obj, paths, defaultValue) {
        var value;
        for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
                return value;
            }
        }
        return defaultValue;
    };

    /**
     * Define private public 'get'
     * @param obj
     * @param path
     * @param defaultValue
     * @returns {*}
     */
    objectPath.get = function (obj, path, defaultValue) {
        if (lodash.isNumber(path)) {
            path = [path];
        }
        if (lodash.isEmpty(path)) {
            return obj;
        }
        if (lodash.isEmpty(obj)) {
            //lodash doesnt seem to work with html nodes
            if (obj && obj.innerHTML === null) {
                return defaultValue;
            }
        }
        if (lodash.isString(path)) {
            return objectPath.get(obj, path.split('.'), defaultValue);
        }
        var currentPath = getKey(path[0]);
        if (path.length === 1) {
            if (obj && obj[currentPath] === void 0) {
                return defaultValue;
            }
            if (obj) {
                return obj[currentPath];
            }
        }
        if (!obj) {
            return defaultValue;
        }
        return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
    };

    /**
     * Define private public 'del'
     * @param obj
     * @param path
     * @returns {*}
     */
    objectPath.del = function (obj, path) {
        return del(obj, path);
    };
    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Object path public xide/utils mixin
    //
    //////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *  Returns a value by a give object path
     *
     *  //works also with arrays
     *    objectPath.get(obj, "a.c.1");  //returns "f"
     *    objectPath.get(obj, ["a","c","1"]);  //returns "f"
     *
     * @param obj {object}
     * @param path {string}
     * @param _default {object|null}
     * @returns {*}
     */
    utils.getAt = function (obj, path, _default) {
        return objectPath.get(obj, path, _default);
    };

    /**
     * Sets a value in an object/array at a given path.
     * @example
     *
     * utils.setAt(obj, "a.h", "m"); // or utils.setAt(obj, ["a","h"], "m");
     *
     * //set will create intermediate object/arrays
     * objectPath.set(obj, "a.j.0.f", "m");
     *
     * @param obj{Object|Array}
     * @param path {string}
     * @param value {mixed}
     * @returns {Object|Array}
     */
    utils.setAt = function (obj, path, value) {
        return objectPath.set(obj, path, value);
    };

    /**
     * Returns there is anything at given path within an object/array.
     * @param obj
     * @param path
     */
    utils.hasAt = function (obj, path) {
        return objectPath.has(obj, path);
    };

    /**
     * Ensures at given path, otherwise _default will be placed
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.ensureAt = function (obj, path, _default) {
        return objectPath.ensureExists(obj, path, _default);
    };
    /**
     * Deletes at given path
     * @param obj
     * @param path
     * @returns {*}
     */
    utils.deleteAt = function (obj, path) {
        return objectPath.del(obj, path);
    };

    /**
     *
     * @param to
     * @param from
     * @returns {*}
     */
    utils.merge = function (to, from) {
        for (var n in from) {
            if (typeof to[n] != 'object') {
                to[n] = from[n];
            } else if (typeof from[n] == 'object') {
                to[n] = utils.merge(to[n], from[n]);
            }
        }

        return to;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Dojo's most wanted
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Clones objects (including DOM nodes) and all children.
     * Warning: do not clone cyclic structures.
     * @param src {*} The object to clone.
     * @returns {*}
     */
    utils.clone = function (src) {
        if (!src || typeof src != "object" || utils.isFunction(src)) {
            // null, undefined, any non-object, or function
            return src; // anything
        }
        if (src.nodeType && "cloneNode" in src) {
            // DOM Node
            return src.cloneNode(true); // Node
        }
        if (src instanceof Date) {
            // Date
            return new Date(src.getTime()); // Date
        }
        if (src instanceof RegExp) {
            // RegExp
            return new RegExp(src); // RegExp
        }
        var r, i, l;
        if (utils.isArray(src)) {
            // array
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
                if (i in src) {
                    r.push(utils.clone(src[i]));
                }
            }
            // we don't clone functions for performance reasons
            // }else if(d.isFunction(src)){
            // // function
            // r = function(){ return src.apply(this, arguments); };
        } else {
            // generic objects
            r = src.constructor ? new src.constructor() : {};
        }
        return utils._mixin(r, src, utils.clone);
    };

    /**
     * Copies/adds all properties of source to dest; returns dest.
     * @description All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
     * found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
     * delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
     * Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
     * @param dest {object} The object to which to copy/add all properties contained in source.
     * @param source {object} The object from which to draw all properties to copy into dest.
     * @param copyFunc {function} The process used to copy/add a property in source; defaults to the Javascript assignment operator.
     * @returns {object} dest, as modified
     * @private
     */
    utils._mixin = function (dest, source, copyFunc) {
        var name, s, i, empty = {};
        for (name in source) {
            // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
            // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
            // don't overwrite it with the toString() method that source inherited from Object.prototype
            s = source[name];
            if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                dest[name] = copyFunc ? copyFunc(s) : s;
            }
        }

        return dest; // Object
    };
    /**
     * Copies/adds all properties of one or more sources to dest; returns dest.
     * @param dest {object} The object to which to copy/add all properties contained in source. If dest is falsy, then
     * a new object is manufactured before copying/adding properties begins.
     *
     * @param sources One of more objects from which to draw all properties to copy into dest. sources are processed
     * left-to-right and if more than one of these objects contain the same property name, the right-most
     * value "wins".
     *
     * @returns {object} dest, as modified
     *
     * @example
     * make a shallow copy of an object
     * var copy = utils.mixin({}, source);
     *
     * @example
     *
     * many class constructors often take an object which specifies
     *        values to be configured on the object. In this case, it is
     *        often simplest to call `lang.mixin` on the `this` object:
     *        declare("acme.Base", null, {
    *			constructor: function(properties){
    *				//property configuration:
    *				lang.mixin(this, properties);
    *				console.log(this.quip);
    *			},
    *			quip: "I wasn't born yesterday, you know - I've seen movies.",
    *			* ...
    *		});
     *
     *        //create an instance of the class and configure it
     *        var b = new acme.Base({quip: "That's what it does!" });
     *
     */
    utils.mixin = function (dest, sources) {
        if (sources) {
            if (!dest) {
                dest = {};
            }
            var l = arguments.length;
            for (var i = 1; i < l; i++) {
                utils._mixin(dest, arguments[i]);
            }
            return dest; // Object
        }
        return dest;
    };

    /**
     * Clone object keys
     * @param defaults
     * @returns {{}}
     */
    utils.cloneKeys = function (defaults, skipEmpty) {
        var result = {};
        for (var _class in defaults) {
            if (skipEmpty === true && !(_class in defaults)) {
                continue;
            }
            result[_class] = defaults[_class];
        }
        return result;
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  STD
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isArray = function (what) {
        return lodash.isArray(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isObject = function (what) {
        return lodash.isObject(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isString = function (what) {
        return lodash.isString(what);
    };
    /**
     *
     * @param what
     * @returns {*}
     */
    utils.isNumber = function (what) {
        return lodash.isNumber(what);
    };
    /**
     * Return true if it is a Function
     * @param it
     * @returns {*}
     */
    utils.isFunction = function (it) {
        return lodash.isFunction(it);
    };
    return utils;
});;
define('xide/utils/CIUtils',[
    'xide/utils',
    'xide/types',
    'xide/factory',
    'dojo/has',
    'xide/lodash'
],function(utils,types,factory,has,_){
    "use strict";
    /**
     *
     * @param cis
     * @returns {Array}
     */
    utils.toOptions  = function(cis){
        cis = utils.flattenCIS(cis);
        var result = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            result.push({
                name:utils.toString(ci['name']),
                value:utils.getCIValue(ci),
                type: utils.toInt(ci['type']),
                enumType:utils.toString(ci['enumType']),
                visible:utils.toBoolean(ci['visible']),
                active:utils.toBoolean(ci['active']),
                changed:utils.toBoolean(ci['changed']),
                group:utils.toString(ci['group']),
                user:utils.toObject(ci['user']),
                dst:utils.toString(ci['dst']),
                id:utils.toString(ci['id']),
                params:utils.toString(ci['params'])
            })
        }
        return result;
    };

    if(has('xideve') || has('xblox-ui')) {
        utils.getEventsAsOptions = function (selected) {
            var result = [
                {label: "Select Event", value: ""}
            ];
            for (var e in types.EVENTS) {
                var label = types.EVENTS[e];

                var item = {
                    label: label,
                    value: types.EVENTS[e]
                };
                result.push(item);
            }
            result = result.concat(
                [{label: "onclick", value: "onclick"},
                    {label: "ondblclick", value: "dblclick"},
                    {label: "onmousedown", value: "mousedown"},
                    {label: "onmouseup", value: "mouseup"},
                    {label: "onmouseover", value: "mouseover"},
                    {label: "onmousemove", value: "mousemove"},
                    {label: "onmouseout", value: "mouseout"},
                    {label: "onkeypress", value: "keypress"},
                    {label: "onkeydown", value: "keydown"},
                    {label: "onkeyup", value: "keyup"},
                    {label: "onfocus", value: "focus"},
                    {label: "onblur", value: "blur"},
                    {label: "On Load", value: "Load"}
                ]);
            //select the event we are listening to
            for (var i = 0; i < result.length; i++) {
                var obj = result[i];
                if (obj.value === selected) {
                    obj.selected = true;
                    break;
                }
            }
            return result;
        };
    }

    utils.flattenCIS  = function(cis){
        var addedCIS = [];
        var removedCIs = [];
        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            var ciType = utils.toInt(ci.type);
            if(ciType > types.ECIType.END){//type is higher than core types, try to resolve it
                var resolved = types.resolveType(ciType);
                if(resolved){
                    utils.mixin(addedCIS,resolved);
                    removedCIs.push(ci);
                }
            }
        }
        if(addedCIS.length>0){
            cis = cis.concat(addedCIS);
        }
        if(removedCIs){
            for(var i in removedCIs){
                cis.remove(removedCIs[i]);
            }
        }
        return cis;
    };

    utils.arrayContains=function(array,element){
        for (var i = 0; i < array.length; i++){
            var _e = array[i];
            if(_e===element){
                return true;
            }
        }
        return false;
    };

    utils.setStoreCIValueByField = function (d, field, value) {
        if (d[field] == null) {
            d[field] = [];
        }
        d[field][0] = utils.getStringValue(value);
        return d;
    };
    /**
     *
     * @param label
     * @param value
     * @param extra
     * @returns {Object}
     */
    utils.createOption=function(label,value,extra){
        return utils.mixin({
            label:label,
            value:value !=null ? value : label
        },extra);
    };
    /**
     *
     * @param name
     * @param type
     * @param value
     * @param args
     * @param settings
     * @returns {{dataRef: null, dataSource: null, name: *, group: number, id: *, title: *, type: *, uid: number, value: *, visible: boolean, enumType: number, class: string}}
     */
    utils.createCI = function (name, type, value,args,settings) {
        var res = {
            dataRef:null,
            dataSource:null,
            name:name,
            group:-1,
            id:name,
            title:name,
            type:type,
            uid:-1,
            value: value!=null ? value : -1,
            visible:true,
            enumType:-1,
            "class":"cmx.types.ConfigurableInformation"
        };
        utils.mixin(res,args);
        if(settings){
            if(settings.publish){
                factory.publish(settings.publish,{
                    CI:res,
                    owner:settings.owner
                },settings.owner);
            }
        }
        return res;
    };

    utils.createCIAsArray = function (name, type, chain,value) {
        return {
            chainType:[chain ? chain : 0],
            dataRef:[null],
            dataSource:[null],
            params:[],
            name:[name],
            group:[-1],
            id:[name],
            title:[name],
            type:[type],
            uid:[-1],
            value: [value ? value : -1],
            visible:[true],
            enumType:[-1],
            parentId:[-1],
            "class":["cmx.types.ConfigurableInformation"]
        };
    };

    utils.hasValue = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset";
    };

    utils.hasValueAndDataRef = function (data){
        return data.value &&  data.value[0] !=null && data.value[0].length > 0 && data.value[0] !="0" && data.value[0] !="undefined" && data.value[0] !="Unset" &&
            data.dataRef &&  data.dataRef[0] !=null && data.dataRef[0].length > 0 && data.dataRef[0] !="0" && data.dataRef[0] !="undefined";
    };

    utils.getInputCIByName = function (data,name){
        if(!data ||!name){
            return null;
        }
        var chain = 0;
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains, be nice
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getInputCIById = function (data,name){
        if(!data){
            return null;
        }
        var chain = 0;
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains, be nice
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.id);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    /***
     *
     * @param data
     * @param chain
     * @param name
     * @returns {*}
     */
    utils.getCIByChainAndName = function (data, chain, name) {
        if(!data){
            return null;
        }
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if(!dstChain){//has no chains
            dstChain=data;
        }
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.name);
                if (_n!=null && _n.toLowerCase() === name.toLowerCase()){
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIByUid= function (dstChain, uid) {
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                var _n = utils.getStringValue(ci.uid);
                if (_n!=null && _n === uid)
                {
                    return ci;
                }
            }
        }
        return null;
    };
    utils.getCIById= function (data, chain, id) {
        var dstChain = chain == 0 ? data.inputs : chain == 1 ? data.outputs : null;
        if (dstChain != null) {
            for (var i = 0; i < dstChain.length; i++) {
                var ci = dstChain[i];
                if (ci.id[0] == id[0]  )
                    return ci;
            }
        }
        return null;
    };
    utils.getCIInputValueByName = function (data, name) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci.value;
        }
        return null;
    };
    utils.getCIValue = function (data){
        return utils.getCIValueByField(data,"value");
    };
    utils.getStringValue = function (d){
        return utils.toString(d);
    };
    utils.toString = function (d){
        if (d != null) {
            if(!_.isArray(d))
            {
                return ''+ d;
            }
            if(d && d.length==1 && d[0]==null)
            {
                return null;
            }
            return '' + (d[0] !=null ? d[0] : d);
        }
        return null;
    };
    /**
     *
     * @param data
     * @param value
     */
    utils.setIntegerValue = function (data,value){
        if (data != null) {

            if(dojo.isArray(data))
            {
                data[0]=value;
            }else{
                data=value;
            }
        }
    };
    /**
     *
     * @param data
     * @param field
     * @returns {*}
     */
    utils.getCIValueByField = function (data, field) {
        if (data[field] != null) {
            if(_.isArray(data[field])){
                return data[field][0] ? data[field][0] : data[field];
            }else{
                return data[field];
            }
        }
        return null;
    };
    /**
     *
     * @param data
     * @param field
     * @param value
     * @returns {*}
     */
    utils.setCIValueByField = function (data, field, value) {
        if(!data){
            return data;
        }
        if (data[field] == null) {
            data[field] = [];
        }
        data[field]=value
        return data;
    };

    utils.setCIValue = function (data, field, value) {
        var ci = utils.getInputCIByName(data,field);
        if(ci){
            utils.setCIValueByField(ci,'value',value);
        }
        return ci;
    };
    /**
     *
     * @param data
     * @param name
     * @param field
     * @returns {*}
     */
    utils.getCIInputValueByNameAndField = function (data, name, field) {
        var ci = utils.getCIByChainAndName(data, 0, name);
        if (ci) {
            return ci["" + field];
        }
        return null;
    };
    /**
     *
     * @param data
     * @param name
     * @param field
     * @returns {null}
     */
    utils.getCIInputValueByNameAndFieldStr = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.getStringValue(rawValue);
        }
        return null;
    };
    /**
     *
     * @param data
     * @param name
     * @param field
     * @returns {null}
     */
    utils.getCIInputValueByNameAndFieldBool = function (data, name, field) {
        var rawValue = utils.getCIInputValueByNameAndField(data,name,field);
        if(rawValue){
            return utils.toBoolean(rawValue);
        }
        return null;
    };
    /**
     *
     * @param cis
     * @param name
     * @returns {*}
     */
    utils.getCIWidgetByName=function(cis,name){

        for (var i = 0; i < cis.length; i++) {
            var ci = cis[i];
            if(ci['_widget'] && ci.name===name){
                return ci['_widget'];
            }
        }
        return null;
    };
    return utils;
});;
define('xide/utils/WidgetUtils',[
    'xide/utils',
    'xide/types',
    'xide/registry'
], function (utils,types,registry) {
    "use strict";
    utils.getParentWidget=function(start,declaredClass,max){
        //sanitize start
        start = start.containerNode || start.domNode || start;
        var i = 0,
            element = start,
            widget = null,
            _max = max || 10,
            _lastWidget = null;

        while (i < _max && !widget) {
            if (element) {
                element = element.parentNode;
                var _widgetById = registry.byId(element.id);
                var _widget = _widgetById || registry.getEnclosingWidget(element);
                _widget && (_lastWidget = _widget);
                if(_widget && declaredClass &&  _widget.declaredClass && _widget.declaredClass.indexOf(declaredClass)!=-1){
                    widget = _widget;
                }
            }
            i++;
        }
        return widget;
    };
    /**
     *
     * @param type
     * @returns {string}
     */
    utils.getWidgetType = function (type) {
        var res = "";
        var root = 'xide.widgets.';
        if (type == types.ECIType.ENUMERATION) {
            res = root  + "Select";
        }
        if (type == types.ECIType.STRING) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.ICON) {
            res = root  + "TextBox";
        }

        if (type == types.ECIType.REFERENCE) {
            res = root  + "Button";
        }

        if (type == types.ECIType.EXPRESSION) {
            res = root  + "Expression";
        }

        if (type == types.ECIType.EXPRESSION_EDITOR) {
            res = root  + "ExpressionEditor";
        }

        if (type == types.ECIType.ARGUMENT) {
            res = root  + "ArgumentsWidget";
        }

        if (type == types.ECIType.WIDGET_REFERENCE) {
            res = root  + "WidgetReference";
        }

        if (type == types.ECIType.BLOCK_REFERENCE) {
            res =root  +  "BlockPickerWidget";
        }

        if (type == types.ECIType.BLOCK_SETTINGS) {
            res = root  + "BlockSettingsWidget";
        }

        if (type == types.ECIType.DOM_PROPERTIES) {
            res = root  + "DomStyleProperties";
        }

        if (type == types.ECIType.FILE_EDITOR) {
            res = root  + "FileEditor";
        }

        return res;
    };
    return utils;
});;
define('xide/utils/StoreUtils',[
    'xide/utils',
    'xide/data/Memory',
    'dojo/_base/kernel',
    'xide/lodash'
], function (utils, Memory,dojo,lodash) {
    "use strict";
    /**
     *
     * @param store {module:xide/data/_Base|null}
     * @param mixed {object|string|null}
     * @param recursive {boolean|null}
     * @param idAttribute {string|null}
     * @param parentAttr {string|null}
     * @param destroy {boolean|null}
     */
    utils.removeFromStore = function (store, mixed, recursive, idAttribute, parentAttr,silent,destroy) {
        if(mixed==null || !store){
            return;
        }
        mixed = lodash.isString(mixed) ? store.getSync(mixed) || mixed : mixed;
        idAttribute = idAttribute || store.idProperty;
        parentAttr = parentAttr || store.parentProperty;
        //remove the item itself
        mixed && store.removeSync(mixed[idAttribute],silent);
        //remove children recursively
        var query = {};
        query[parentAttr] = mixed[idAttribute] ? mixed[idAttribute] : mixed;
        destroy ===true && lodash.isObject(mixed) && utils.destroy(mixed,true);
        if(recursive===true) {
            var items = store.query(query);
            if (items && items.length) {
                for (var i = 0; i < items.length; i++) {
                    utils.removeFromStore(store, items[i], recursive, idAttribute, parentAttr,silent,destroy);
                }
            }
        }
    };
    /**
     * CI related tools.
     * @param val {string|array|null}
     * @returns {string|null}
     */
    utils.toString = function (val) {
        if (val != null) {
            if (!dojo.isArray(val)) {
                return '' + val;
            }
            if (val && val.length == 1 && val[0] == null) {
                return null;
            }
            return '' + (val[0] != null ? val[0] : val);
        }
        return null;
    };
    utils.toBoolean = function (data) {
        var resInt = false;
        if (data != null) {
            var _dataStr = data[0] ? data[0] : data;
            if (_dataStr != null) {
                resInt = !!(( _dataStr === true || _dataStr === 'true' || _dataStr === '1'));
            }
        }
        return resInt;
    };
    utils.toObject = function (data) {
        if (data != null) {
            return data[0] ? data[0] : data;
        }
        return null;
    };
    utils.toInt = function (data) {
        if(_.isNumber(data)){
            return data;
        }
        var resInt = -1;
        if (data!=null) {
            var _dataStr = data.length > 1 ? data : data[0] ? data[0] : data;
            if (_dataStr != null) {
                resInt = parseInt(_dataStr, 10);
            }
        }
        return resInt;
    };
    /***
     *
     * @param store
     * @param id
     * @return {null}
     */
    utils.getStoreItemById = function (store, id) {
        return utils.queryStoreEx(store, {id: id},null,null);
    };
    /***
     *
     * @param store
     * @param id
     * @param type
     * @return {null}
     */
    utils.getAppDataElementByIdAndType = function (store, id, type) {
        return utils.queryStore(store, {uid: id, type: type},null,null);
    };
    /***
     *
     * @param store
     * @param type
     * @return {null}
     */
    utils.getElementsByType = function (store, type) {
        return utils.queryStoreEx(store, {type: type});
    };
    /***
     * @param store {module:xide/data/_Base} Store to query
     * @param query {object} Literal to match
     * @param nullEmpty {boolean|null} Return null if nothing has been found
     * @param single {boolean|null} Return first entry
     * @returns {*}
     */
    utils.queryStoreEx = function (store, query, nullEmpty, single) {
        if (!store) {
            console.error('utils.queryStoreEx: store = null');
            return null;
        }
        if (store instanceof Memory) {
            var result = utils.queryMemoryStoreEx(store, query);
            if (single && result && result[0]) {
                return result[0];
            }
            return result;
        }
        var res = null;
        if (store.query) {
            res = store.query(query);
        }
        if (nullEmpty === true) {
            if (res && res.length === 0) {
                return null;
            }
        }
        if (single === true) {
            if (res && res.length == 1) {
                return res[0];
            }
        }
        return res;
    };
    /**
     *
     * @param store
     * @param query
     * @param nullEmpty {boolean|null}
     * @returns {*}
     */
    utils.queryStore = function (store, query, nullEmpty) {
        var res = utils.queryStoreEx(store, query,null,null);
        if (res && res.length == 1) {
            return res[0];
        }
        if (nullEmpty === true) {
            if (res && res.length === 0) {
                return null;
            }
        }
        return res;
    };

    /**
     *
     * @param store
     * @param query
     * @returns {Array}
     */
    utils.queryMemoryStoreEx = function (store, query) {
        var result = [];
        store.query(query).forEach(function (entry) {
            result.push(entry);
        });
        return result;
    };

    utils.queryMemoryStoreSingle = function (store, query) {
        var result = utils.queryMemoryStoreEx(store, query);
        if (result.length == 1) {
            return result[0];
        }
        return result;
    };

    return utils;
});;
/** @module xide/utils/HTMLUtils **/
define('xide/utils/HTMLUtils',[
    'xide/utils',
    'xide/types',
    'dcl/dcl',
    'xdojo/declare',
    "dojo/dom-construct",
    'dojo/has',
    'dojo/dom-class',
    "dojo/_base/window",
    'xide/lodash',
    'xide/$'
], function (utils, types, dcl,declare, domConstruct, has, domClass, win, _,$) {
    /**
     * @TODO: remove
     * #Maqetta back compat tool
     * @returns {*}
     */
    utils.getDoc = function () {
        return win.doc;
    };
    /**
     * @TODO: remove
     * Save empty a node or a widget
     * @param mixed {HTMLElement|xide/_base/_Widget || dijit/_WidgetBase}
     * @returns void
     */
    utils.empty = function (mixed) {
        //seems widget
        if (mixed.getChildren && mixed.removeChild) {
            var children = mixed.getChildren();
            _.each(children, function (widget) {
                mixed.removeChild(widget);
            });
        }
        //now remove anything non-widget
        var _el = mixed.containerNode || mixed.domNode || _.isElement(mixed) ? mixed : null;
        if (_el) {
            domConstruct.empty(_el);
        }
    };
    /**
     *
     * @TODO: remove, not needed since 3.0
     * @param startNode
     * @param mustHaveClass
     * @returns {*}
     */
    utils.findEmptyNode = function (startNode, mustHaveClass) {
        if (!startNode || startNode.children == null || startNode.children.length == null) {
            return null;
        }
        var children = startNode.children;
        if (mustHaveClass !== null) {
            children = utils.find(mustHaveClass, startNode, false);
        }
        for (var i in children) {
            var child = children[i];
            if (child.innerHTML === '') {
                return child;
            }
        }
        return null;
    };
    /**
     *
     * @param tag {string}
     * @param options {object}
     * @param where {HTMLElement}
     * @memberOf module:xide/utils
     * @returns {HTMLElement}
     */
    utils.create = function (tag, options, where) {
        var doc = win.doc;
        if (where) {
            doc = where.ownerDocument;
        }

        if (typeof tag == "string") {
            tag = doc.createElement(tag);
        }
        options && $(tag).attr(options);
        where && $(where).append(tag);
        return tag;
    };

    /**
     * Returns true when a node is child of another node
     * @param parent {HTMLElement}
     * @param child {HTMLElement}
     * @memberOf module:xide/utils
     * @returns {boolean}
     */
    utils.isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (node !== null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    utils.find=function(clss,parent){
        return $(clss,parent)[0];
    }
    /**
     * Finds and returns a widgets instance in a stack-container by name
     * @param name
     * @param container
     * @memberOf module:xide/utils
     * @returns {module:xide/layout/_Container}
     */
    utils.hasChild = function (name, container) {
        if (!!name || !container && container.getChildren) {
            return _.find(container.getChildren(), {
                title: name
            });
        }
    };
    /**
     *
     * @param proto {Module} a module
     * @param args {Object} the constructor arguments
     * @param node {HTMLElement|null}
     * @param extraBaseClasses {Module[]} additional base classes
     * @param classExtension
     * @memberOf module:xide/utils
     * @returns {Object}
     */
    utils.createInstanceSync = function (proto, args, node, extraBaseClasses, classExtension) {
        //extra bases and/or class extension, create a dynamic class and fill extra-bases
        if (extraBaseClasses || classExtension) {
            extraBaseClasses = extraBaseClasses || [];

            if (classExtension) {
                extraBaseClasses.push(declare(proto, classExtension));
            }
        }
        if (extraBaseClasses) {
            extraBaseClasses = _.isArray(extraBaseClasses) ? extraBaseClasses : [extraBaseClasses];
            extraBaseClasses.push(proto);
            extraBaseClasses.reverse();
            proto = proto.extend ? declare(extraBaseClasses, {}) : dcl(extraBaseClasses,{});
        }
        return new proto(args || {}, node || win.doc.createElement('div'));

    };
    /***
     * addWidget
     * @param widgetProto {module:xide/_base/_Widget|module:xide/widgets/_Widget}
     * @param ctrArgsIn {object|null}
     * @param delegate {*|null}
     * @param parent {HTMLElement|module:xide/_base/_Widget|module:xide/widgets/_Widget}
     * @param startup {boolean}
     * @param cssClass {string} CSS class to be added
     * @param baseClasses {null|object[]}
     * @param select {boolean} call select (ie: a tab in a container)
     * @param classExtension {object} one more mixin
     * @memberOf module:xide/utils
     * @returns {module:xide/_base/_Widget|module:xide/widgets/_Widget|null}
     */
    utils.addWidget = function (widgetProto, ctrArgsIn, delegate, parent, startup, cssClass, baseClasses, select, classExtension) {
        var ctrArgs = {
            delegate: delegate
        };
        ctrArgsIn = ctrArgsIn || {};
        utils.mixin(ctrArgs, ctrArgsIn);

        //deal with class name
        if (_.isString(widgetProto)) {
            var _widgetProto = utils.getObject(widgetProto);
            if (_widgetProto) {
                widgetProto = _widgetProto;
            }
        }

        parent = _.isString(parent) ? domConstruct.create(parent) : parent == null ? win.doc.createElement('div') : parent;
        var isDirect = ctrArgsIn.attachDirect ? ctrArgsIn.attachDirect : (widgetProto && widgetProto.prototype ? widgetProto.prototype.attachDirect : false);
        ctrArgs._parent = parent;

        var _target = utils.getNode(parent);

        //@TODO: remove
        if (parent && parent.finishLoading) {
            parent.finishLoading();
        }
        //@TODO: remove
        if (ctrArgs.attachChild && parent.addChild) {
            delete ctrArgs.attachChild;
            return parent.addChild(widgetProto, ctrArgs, startup);
        }


        //@TODO: replace
        if (parent.addWidget && ctrArgs.ignoreAddChild !== true) {
            return parent.addWidget(widgetProto, ctrArgsIn, delegate, parent, startup, cssClass, baseClasses, select, classExtension);
        }

        var widget = utils.createInstanceSync(widgetProto, ctrArgs, isDirect ? _target : null, baseClasses, classExtension);// new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        if (!widget) {
            console.error('widget creation failed! ', arguments);
            return null;
        }

        if (parent) {
            if (!isDirect) {
                utils.addChild(parent, widget, startup, select);
            } else {
                startup && widget.startup();
            }
        } else {
            return widget;
        }

        if (cssClass) {
            domClass.add(widget.domNode, cssClass);
        }

        if (parent.resize || parent.startup) {
            widget._parent = parent;
        }

        //@TODO: remove
        widget.utils = utils;
        widget.types = types;
        return widget;
    };

    /***
     * addChild is a Dojo abstraction. It tries to call addChild on the parent when the client is fitted for this case.
     * @param parent {HTMLElement|module:xide/widgets/_Widget}
     * @param child {HTMLElement|module:xide/widgets/_Widget}
     * @param startup {boolean} call startup() on the child
     * @param select {boolean} select the widget if parent has such method
     * @memberOf module:xide/utils
     */
    utils.addChild = function (parent, child, startup, select) {
        if (!parent || !child) {
            console.error('error! parent or child is invalid!');
            return;
        }
        try {
            var parentIsWidget = typeof parent.addChild === 'function';
            var _parentNode = parentIsWidget ? parent : utils.getNode(parent);
            var _childNode = parentIsWidget ? child : child.domNode || child;
            if (_parentNode && _childNode) {
                if (!parent.addChild) {
                    if (_childNode.nodeType) {
                        _parentNode.appendChild(_childNode);
                        if (startup === true && child.startup) {
                            child.startup();
                        }
                    } else {
                        logError('child is not html');
                    }
                } else {
                    var insertIndex = -1;
                    if (parent.getChildren) {
                        insertIndex = parent.getChildren().length;
                    }
                    try {
                        //@TODO: this has wrong signature in beta3
                        parent.addChild(_childNode, insertIndex, select !== null ? select : startup);
                    } catch (e) {
                        logError(e, 'add child failed for some reason!' + e);
                    }
                }
            } else if (has('debug')) {
                console.error("utils.addChild : invalid parameters :: parent or child domNode is null");
            }
        } catch (e) {
            logError(e, 'addWidget : crashed : ');
        }
    };
    /***
     *
     * 'templatify' creates a sort of dynamic widget which behaves just like a normal templated widget. Its
     * there for simple widget creation which goes beyond the string substitute alternative. This can
     * avoid also to carry around too many widget modules in your app.
     *
     * @param baseClass {xide/widgets/TemplatedWidgetBase|dijit/_TemplatedMixin} a base class to use, this must be
     * anything which is a dijit/_TemplatedMixin.
     *
     * @param templateString {string} template string as usual, can have all tags like  data-dojo-attach-point and so
     * forth
     *
     * @param parentNode {HTMLNode} the node where the 'dynamic widget' is being added to.

     * @param templateArguments {Object} some parameters mixed into the widget. In the example below you might use
     * {iconClass:'fa-play'} to insert the icon class 'fa-play' into the widget's template
     *
     * @param baseClasses {Object[]=} optional, a number of additional base classes you want make the 'dynamic widget'
     * to be inherited from.
     *
     * @param startup {boolean} call startup on the widget
     *
     * @returns {Widget} returns the templated widget
     *
     *
     * @example var _tpl =  "<div>" +
     "<div class='' data-dojo-type='dijit.form.DropDownButton' data-dojo-props=\"iconClass:'${!iconClass}'\" +
     "data-dojo-attach-point='wButton'>" +
     "<span></span>" +
     "<div data-dojo-attach-point='menu' data-dojo-type='dijit.Menu' style='display: none;'></div>" +
     "</div></div>";

     var widget  = this.templatify(xide/widgets/TemplatedWidgetBase,_tpl, parent , {
            iconClass:'fa-play'
        },[xide/mixins/ReloadMixin]);

     * @memberOf module:xide/utils
     * @extends xide/utils

     */
    utils.templatify = function (baseClass, templateString, parentNode, templateArguments, baseClasses, startup) {
        var widgetClassIn = baseClass || 'xide/widgets/TemplatedWidgetBase',
            widgetProto = null;
        if (baseClasses) {
            widgetProto = declare([baseClass].concat(baseClasses));
        } else {
            widgetProto = utils.getObject(widgetClassIn);
        }
        if (!widgetProto) {
            return null;
        }
        var ctrArgs = {
            templateString: templateString
        };
        utils.mixin(ctrArgs, templateArguments);
        var widget = new widgetProto(ctrArgs, dojo.doc.createElement('div'));
        utils.addChild(parentNode, widget, startup);
        return widget;
    };
    /**
     * XIDE specific
     * @param prop
     * @param owner
     * @memberOf module:xide/utils
     * @private
     */
    utils._clearProperty = function (prop, owner) {
        var _key = null;
        if (owner) {
            _key = utils.getObjectKeyByValue(owner, prop);
        }
        if (_key) {
            owner[_key] = null;
        }
    };
    /**
     * XIDE specific destroy
     * @param view
     * @param callDestroy
     * @param owner
     * @memberOf module:xide/utils
     * @private
     */
    utils._destroyWidget = function (view, callDestroy, owner) {
        try {
            _.isString(view) && (view = $(view)[0]);
            if (view) {
                if (view.parentContainer &&
                    view.parentContainer.removeChild &&
                    view.domNode) {
                    if (view.destroy && callDestroy !== false) {
                        try {
                            view.destroy();
                        } catch (e) {
                            console.error('error destroying view');
                        }
                    }
                    view.parentContainer.removeChild(view);
                    if (owner) {
                        utils._clearProperty(view, owner);
                    }
                    return;
                }
                view.destroyRecursive && view.destroyRecursive();
                view.destroy && view._destroyed !== true && view.destroy();
                view._destroyed = true;
                if (view.domNode || view["domNode"]) {
                    if (view.domNode) {
                        domConstruct.destroy(view.domNode);
                    }
                } else {
                    var doc = view.ownerDocument;
                    // cannot use _destroyContainer.ownerDocument since this can throw an exception on IE
                    if (doc) {
                        domConstruct.destroy(view);
                    }
                }
                utils._clearProperty(view, owner);
            }

        } catch (e) {
            logError(e, 'error in destroying widget ' + e);
        }
    };
    /**
     * Destroys a widget or HTMLElement safely. When an owner
     * is specified, 'widget' will be nulled in owner
     * @param widget {Widget|HTMLElement|object}
     * @param callDestroy instruct to call 'destroy'
     * @memberOf module:xide/utils
     * @param owner {Object=}
     */
    utils.destroy = function (widget, callDestroy, owner) {
        if (widget) {
            if (_.isArray(widget)) {
                for (var i = 0; i < widget.length; i++) {
                    var obj1 = widget[i];
                    var _key = null;
                    if (owner) {
                        _key = utils.getObjectKeyByValue(owner, obj1);
                    }
                    utils._destroyWidget(obj1, callDestroy);
                    if (_key) {
                        owner[_key] = null;
                    }
                }
            } else {
                utils._destroyWidget(widget, callDestroy, owner);
            }
        }
    };

    /**
     * Get a widet's default append target, dojo specfic
     * @param target
     * @memberOf module:xide/utils
     * @returns {*}
     */
    utils.getNode = function (target) {
        if (target) {
            return target.containerNode || target.domNode || target;
        }
        return target;
    };

    /**
     * Return the total height for widgets
     * @param widgets {module:xide/widgets/_Widget|module:xide/widgets/_Widget[]}
     * @memberOf module:xide/utils
     * @returns {number}
     */
    utils.getHeight = function (widgets) {
        if (!_.isArray(widgets)) {
            widgets = [widgets];
        }
        var total = 0;
        _.each(widgets, function (w) {
            total += $(utils.getNode(w)).outerHeight();
        });
        return total;

    };
    /**
     *
     * @param source
     * @param target
     * @param height
     * @param width
     * @param force
     * @param offset
     * @memberOf module:xide/utils
     */
    utils.resizeTo = function (source, target, height, width, force, offset) {
        target = utils.getNode(target);
        source = utils.getNode(source);
        if (height === true) {
            var targetHeight = $(target).height();
            if (offset && offset.h !== null) {
                targetHeight += offset.h;
            }
            $(source).css('height', targetHeight + 'px' + (force === true ? '!important' : ''));
        }
        if (width === true) {
            var targetWidth = $(target).width();
            $(source).css('width', targetWidth + 'px' + (force === true ? '!important' : ''));
        }
    };

    return utils;
});
;
/** @module xide/$ **/
define('xide/$',[],function(){
    /**
     * temp. wanna be shim for jQuery
     */
    if(typeof $ !=="undefined"){
        return $;
    }
});
;
/** @module xide/utils/HexUtils
 *  @description All hex related functions
 */
define('xide/utils/HexUtils',[
    'xide/utils',
    'xide/types',
    'dojo/json',
    'xide/lodash'
], function (utils, types, json, _) {
    "use strict";
    /**
     * Converts a single hex number to a character. note that no checking is performed to ensure that this is just a hex
     * number, eg. no spaces etc.
     * @param hex {string} the hex codepoint to be converted.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function hex2char(hex) {
        var result = '';
        var n = parseInt(hex, 16);
        if (n <= 0xFFFF) {
            result += String.fromCharCode(n);
        }
        else if (n <= 0x10FFFF) {
            n -= 0x10000;
            result += String.fromCharCode(0xD800 | (n >> 10)) + String.fromCharCode(0xDC00 | (n & 0x3FF));
        }
        else {
            result += 'hex2Char error: Code point out of range: ' + dec2hex(n);
        }
        return result;
    }

    /**
     * Converts a single string representing a decimal number to a character. Note that no checking is performed to
     * ensure that this is just a hex number, eg. no spaces etc.
     * @param n {string} dec: string, the dec codepoint to be converted
     * @returns {string}
     */
    function dec2char(n) {
        var result = '';
        if (n <= 0xFFFF) {
            result += String.fromCharCode(n);
        }
        else if (n <= 0x10FFFF) {
            n -= 0x10000;
            result += String.fromCharCode(0xD800 | (n >> 10)) + String.fromCharCode(0xDC00 | (n & 0x3FF));
        }
        else {
            result += 'dec2char error: Code point out of range: ' + dec2hex(n);
        }
        return result;
    }

    function dec2hex(textString) {
        return (textString + 0).toString(16).toUpperCase();
    }

    var hexequiv = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];

    function dec2hex2(textString) {
        return hexequiv[(textString >> 4) & 0xF] + hexequiv[textString & 0xF];
    }

    function dec2hex4(textString) {
        return hexequiv[(textString >> 12) & 0xF] + hexequiv[(textString >> 8) & 0xF]
            + hexequiv[(textString >> 4) & 0xF] + hexequiv[textString & 0xF];
    }

    /**
     *
     * @param textString {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertChar2CP(textString) {
        var haut = 0;
        var n = 0;
        var CPstring = '';
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    CPstring += dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + ' ';
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                CPstring += dec2hex(b) + ' ';
            }
        }
        return CPstring.substring(0, CPstring.length - 1);
    }

    /**
     * Converts a string containing &#x...; escapes to a string of characters.
     * @param str {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function removeWhitespacesFromHexSequence(str) {
        // convert up to 6 digit escapes to characters
        str = str.replace(/0x([A-Fa-f0-9]{1,4})(\s)?/g,
            function (matchstr, parens) {
                var result = hex2char(parens);
                return hex2char(parens);
            }
        );
        return str;
    }

    utils.dec2hex4 = dec2hex4;
    utils.dec2hex = dec2hex;
    utils.dec2char = dec2char;
    utils.dec2hex2 = dec2hex2;
    // ========================== Converting to characters ==============================================
    /**
     * Converts all escapes in the text str to characters, and can interpret numbers as escapes too.
     * @param str {string} the text to be converted.
     * @param numbers {string} enum [none, hex, dec, utf8, utf16], what to treat numbers as.
     * @returns {string|*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertAllEscapes(str, numbers) {
        var sle = false;
        str = convertUnicode2Char(str);
        str = removeWhitespacesFromHexSequence(str);

        str = convertZeroX2Char(str);
        str = convertHexNCR2Char(str);
        str = convertDecNCR2Char(str);
        if (sle) {
            str = convertjEsc2Char(str, true);
        }
        else {
            str = convertjEsc2Char(str, false);
            str = convertCSS2Char(str, false);
        }
        str = convertpEnc2Char(str);
        str = convertEntities2Char(str);
        str = convertNumbers2Char(str, numbers);

        return str;
    }
    /**
     * Converts a string containing U+... escapes to a string of characters.
     * @param str {string} the input
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertUnicode2Char(str) {
        // first convert the 6 digit escapes to characters
        str = str.replace(/[Uu]\+10([A-Fa-f0-9]{4})/g,
            function (matchstr, parens) {
                return hex2char('10' + parens);
            }
        );
        // next convert up to 5 digit escapes to characters
        str = str.replace(/[Uu]\+([A-Fa-f0-9]{1,5})/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }

    /**
     * Converts a string containing &#x...; escapes to a string of characters
     * @param str
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertHexNCR2Char(str) {
        // convert up to 6 digit escapes to characters
        str = str.replace(/&#x([A-Fa-f0-9]{1,6});/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }

    /**
     * Converts a string containing &#...; escapes to a string of characters
     * @param str
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertDecNCR2Char(str) {

        // convert up to 6 digit escapes to characters
        str = str.replace(/&#([0-9]{1,7});/g,
            function (matchstr, parens) {
                return dec2char(parens);
            }
        );
        return str;
    }

    /**
     * Converts a string containing 0x... escapes to a string of characters, up to 6 digit escapes to characters.
     * @param str
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertZeroX2Char(str) {
        //
        str = str.replace(/0x([A-Fa-f0-9]{1,6})/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        return str;
    }

    /**
     * Converts a string containing CSS escapes to a string of characters, up to 6 digit escapes to characters & throw
     * away any following whitespace.
     * @param str {string} str: string, the input
     * @param convertbackslash {boolean} true if you want \x etc to become x or \a to be treated as 0xA
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCSS2Char(str, convertbackslash) {
        if (convertbackslash) {
            str = str.replace(/\\([A-Fa-f0-9]{1,6})(\s)?/g,
                function (matchstr, parens) {
                    return hex2char(parens);
                }
            );
            str = str.replace(/\\/g, '');
        }
        else {
            str = str.replace(/\\([A-Fa-f0-9]{2,6})(\s)?/g,
                function (matchstr, parens) {
                    return hex2char(parens);
                }
            );
        }
        return str;
    }

    /**
     * Converts a string containing JavaScript or Java escapes to a string of characters
     * @param str {string} str: string, the input
     * @param shortEscapes {boolean} if true the function will convert \b etc to characters
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertjEsc2Char(str, shortEscapes) {
        // convert ES6 escapes to characters
        str = str.replace(/\\u\{([A-Fa-f0-9]{1,})\}/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \U and 6 digit escapes to characters
        str = str.replace(/\\U([A-Fa-f0-9]{8})/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \u and 6 digit escapes to characters
        str = str.replace(/\\u([A-Fa-f0-9]{4})/g,
            function (matchstr, parens) {
                return hex2char(parens);
            }
        );
        // convert \b etc to characters, if flag set
        if (shortEscapes) {
            str = str.replace(/\\b/g, '\b');
            str = str.replace(/\\t/g, '\t');
            str = str.replace(/\\n/g, '\n');
            str = str.replace(/\\v/g, '\v');
            str = str.replace(/\\f/g, '\f');
            str = str.replace(/\\r/g, '\r');
            str = str.replace(/\\\'/g, '\'');
            str = str.replace(/\\\"/g, '\"');
            str = str.replace(/\\\\/g, '\\');
        }
        return str;
    }

    /**
     * Converts a string containing precent encoded escapes to a string of characters
     * @param str {string} the input
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertpEnc2Char(str) {
        // find runs of hex numbers separated by % and send them for conversion
        str = str.replace(/((%[A-Fa-f0-9]{2})+)/g,
            function (matchstr, parens) {
                //return convertpEsc2Char(parens.replace(/%/g,' '));
                return convertpEsc2Char(parens);
            }
        );
        return str;
    }

    /**
     * converts a string containing HTML/XML character entities to a string of characters
     * @param str {string} the input
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertEntities2Char(str) {
        var entities = {};
        str = str.replace(/&([A-Za-z0-9]+);/g,
            function (matchstr, parens) {
                if (parens in entities) {
                    return entities[parens];
                }
                else {
                    return matchstr;
                }
            }
        );
        return str;
    }

    /**
     * Converts a string containing HTML/XML character entities to a string of characters
     * @param str {string} the input
     * @param type {string} none, hex, dec, utf8, utf16. what to treat numbers as
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertNumbers2Char(str, type) {
        if (type == 'hex') {
            str = str.replace(/(\b[A-Fa-f0-9]{2,6}\b)/g,
                function (matchstr, parens) {
                    return hex2char(parens);
                }
            );
        }
        else if (type == 'dec') {
            str = str.replace(/(\b[0-9]+\b)/g,
                function (matchstr, parens) {
                    return dec2char(parens);
                }
            );
        }
        else if (type == 'utf8') {
            str = str.replace(/(( [A-Fa-f0-9]{2})+)/g,
                function (matchstr, parens) {
                    return convertUTF82Char(parens);
                }
            );
        }
        else if (type == 'utf16') {
            str = str.replace(/(( [A-Fa-f0-9]{1,6})+)/g,
                function (matchstr, parens) {
                    return convertUTF162Char(parens);
                }
            );
        }
        return str;
    }

    /**
     * Converts to characters a sequence of space-separated hex numbers representing bytes in utf8.
     * @param str {string} the input
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertUTF82Char(str) {
        var outputString = "";
        var counter = 0;
        var n = 0;

        // remove leading and trailing spaces
        str = str.replace(/^\s+/, '');
        str = str.replace(/\s+$/, '');
        if (str.length == 0) {
            return "";
        }
        str = str.replace(/\s+/g, ' ');

        var listArray = str.split(' ');
        for (var i = 0; i < listArray.length; i++) {
            var b = parseInt(listArray[i], 16);  // alert('b:'+dec2hex(b));
            switch (counter) {
                case 0:
                    if (0 <= b && b <= 0x7F) {  // 0xxxxxxx
                        outputString += dec2char(b);
                    }
                    else if (0xC0 <= b && b <= 0xDF) {  // 110xxxxx
                        counter = 1;
                        n = b & 0x1F;
                    }
                    else if (0xE0 <= b && b <= 0xEF) {  // 1110xxxx
                        counter = 2;
                        n = b & 0xF;
                    }
                    else if (0xF0 <= b && b <= 0xF7) {  // 11110xxx
                        counter = 3;
                        n = b & 0x7;
                    }
                    else {
                        outputString += 'convertUTF82Char: error1 ' + dec2hex(b) + '! ';
                    }
                    break;
                case 1:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertUTF82Char: error2 ' + dec2hex(b) + '! ';
                    }
                    counter--;
                    outputString += dec2char((n << 6) | (b - 0x80));
                    n = 0;
                    break;
                case 2:
                case 3:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertUTF82Char: error3 ' + dec2hex(b) + '! ';
                    }
                    n = (n << 6) | (b - 0x80);
                    counter--;
                    break;
            }
        }
        return outputString.replace(/ $/, '');
    }

    /**
     * Converts a string of UTF-16 code units to characters
     * @param str {string} the input, the equence of UTF16 code units, separated by spaces.
     * @returns {string|null}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertUTF162Char(str) {
        var highsurrogate = 0;
        var outputString = '';

        // remove leading and multiple spaces
        str = str.replace(/^\s+/, '');
        str = str.replace(/\s+$/, '');
        if (str.length == 0) {
            return null;
        }
        str = str.replace(/\s+/g, ' ');

        var listArray = str.split(' ');
        for (var i = 0; i < listArray.length; i++) {
            var b = parseInt(listArray[i], 16);
            if (b < 0 || b > 0xFFFF) {
                outputString += '!Error in convertUTF162Char: unexpected value, b=' + dec2hex(b) + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    outputString += dec2char(0x10000 + ((highsurrogate - 0xD800) << 10) + (b - 0xDC00));
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertUTF162Char: low surrogate expected, b=' + dec2hex(b) + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) { // start of supplementary character
                highsurrogate = b;
            }
            else {
                outputString += dec2char(b);
            }
        }
        return outputString;
    }

    /**
     * Converts to characters a sequence of %-separated hex numbers representing bytes in utf8.
     * @param str {string} the input
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertpEsc2Char(str) {
        var outputString = "";
        var counter = 0;
        var n = 0;

        var listArray = str.split('%');
        for (var i = 1; i < listArray.length; i++) {
            var b = parseInt(listArray[i], 16);
            switch (counter) {
                case 0:
                    if (0 <= b && b <= 0x7F) { // 0xxxxxxx
                        outputString += dec2char(b);
                    }
                    else if (0xC0 <= b && b <= 0xDF) {  // 110xxxxx
                        counter = 1;
                        n = b & 0x1F;
                    }
                    else if (0xE0 <= b && b <= 0xEF) {  // 1110xxxx
                        counter = 2;
                        n = b & 0xF;
                    }
                    else if (0xF0 <= b && b <= 0xF7) {  // 11110xxx
                        counter = 3;
                        n = b & 0x7;
                    }
                    else {
                        outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                    }
                    break;
                case 1:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                    }
                    counter--;
                    outputString += dec2char((n << 6) | (b - 0x80));
                    n = 0;
                    break;
                case 2:
                case 3:
                    if (b < 0x80 || b > 0xBF) {
                        outputString += 'convertpEsc2Char: error ' + dec2hex(b) + '! ';
                    }
                    n = (n << 6) | (b - 0x80);
                    counter--;
                    break;
            }
        }
        return outputString;
    }

    /**
     * Converts XML or HTML text to characters by removing all character entities and ncrs.
     * @param str {string} the input
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertXML2Char(str) {
        // remove various escaped forms
        str = convertHexNCR2Char(str);
        str = convertDecNCR2Char(str);
        str = convertEntities2Char(str);
        return str;
    }

    utils.convertUTF82Char = convertUTF82Char;
    utils.convertUTF162Char = convertUTF162Char;
    utils.convertUnicode2Char = convertUnicode2Char;

    // ============================== Convert to escapes ===============================================

    /**
     * replaces xml/html syntax-sensitive characters in a string with entities
     * also replaces invisible and ambiguous characters with escapes (list to be extended).
     * @param str
     * @param parameters {boolean] if true, invisible characters are converted to NCRs
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2XML(str, parameters) {
        // bidimarkup: boolean, if true, bidi rle/lre/pdf/rli/lri/fsi/pdi characters are converted to markup
        str = str.replace(/&/g, '&amp;');
        str = str.replace(/"/g, '&quot;');
        str = str.replace(/</g, '&lt;');
        str = str.replace(/>/g, '&gt;');

        // replace invisible and ambiguous characters
        if (parameters.match(/convertinvisibles/)) {
            str = str.replace(/\u2066/g, '&#x2066;');  // lri
            str = str.replace(/\u2067/g, '&#x2067;');  // rli
            str = str.replace(/\u2068/g, '&#x2068;');  // fsi
            str = str.replace(/\u2069/g, '&#x2069;');  // pdi

            str = str.replace(/\u202A/g, '&#x202A;'); // lre
            str = str.replace(/\u202B/g, '&#x202B;'); // rle
            str = str.replace(/\u202D/g, '&#x202D;'); // lro
            str = str.replace(/\u202E/g, '&#x202E;'); // rlo
            str = str.replace(/\u202C/g, '&#x202C;'); // pdf
            str = str.replace(/\u200E/g, '&#x200E;'); // lrm
            str = str.replace(/\u200F/g, '&#x200F;'); // rlm

            str = str.replace(/\u2000/g, '&#x2000;'); // en quad
            str = str.replace(/\u2001/g, '&#x2001;'); // em quad
            str = str.replace(/\u2002/g, '&#x2002;'); // en space
            str = str.replace(/\u2003/g, '&#x2003;'); // em space
            str = str.replace(/\u2004/g, '&#x2004;'); // 3 per em space
            str = str.replace(/\u2005/g, '&#x2005;'); // 4 per em space
            str = str.replace(/\u2006/g, '&#x2006;'); // 6 per em space
            str = str.replace(/\u2007/g, '&#x2007;'); // figure space
            str = str.replace(/\u2008/g, '&#x2008;'); // punctuation space
            str = str.replace(/\u2009/g, '&#x2009;'); // thin space
            str = str.replace(/\u200A/g, '&#x200A;'); // hair space
            str = str.replace(/\u200B/g, '&#x200B;'); // zwsp
            str = str.replace(/\u205F/g, '&#x205F;'); // mmsp
            //str = str.replace(/\uA0/g, '&#xA0;') // nbsp
            str = str.replace(/\u3000/g, '&#x3000;'); // ideographic sp
            str = str.replace(/\u202F/g, '&#x202F;'); // nnbsp

            str = str.replace(/\u180B/g, '&#x180B;'); // mfvs1
            str = str.replace(/\u180C/g, '&#x180C;'); // mfvs2
            str = str.replace(/\u180D/g, '&#x180D;'); // mfvs3

            str = str.replace(/\u200C/g, '&#x200C;'); // zwnj
            str = str.replace(/\u200D/g, '&#x200D;'); // zwj
            str = str.replace(/\u2028/g, '&#x2028;'); // line sep
            str = str.replace(/\u206A/g, '&#x206A;'); // iss
            str = str.replace(/\u206B/g, '&#x206B;'); // ass
            str = str.replace(/\u206C/g, '&#x206C;'); // iafs
            str = str.replace(/\u206D/g, '&#x206D;'); // aafs
            str = str.replace(/\u206E/g, '&#x206E;'); // nads
            str = str.replace(/\u206F/g, '&#x206F;'); // nods
        }

        // convert lre/rle/pdf/rli/lri/fsi/pdi to markup
        if (parameters.match(/bidimarkup/)) {
            str = str.replace(/\u2066/g, '&lt;span dir=&quot;ltr&quot;&gt;'); // lri
            str = str.replace(/\u2067/g, '&lt;span dir=&quot;rtl&quot;&gt;'); // rli
            str = str.replace(/\u2068/g, '&lt;span dir=&quot;auto&quot;&gt;'); // fsi
            str = str.replace(/\u2069/g, '&lt;/span&gt;'); // pdi

            str = str.replace(/\u202A/g, '&lt;span dir=&quot;ltr&quot;&gt;'); //
            str = str.replace(/\u202B/g, '&lt;span dir=&quot;rtl&quot;&gt;');
            str = str.replace(/\u202C/g, '&lt;/span&gt;');
            str = str.replace(/&#x202A;/g, '&lt;span dir=&quot;ltr&quot;&gt;');
            str = str.replace(/&#x202B;/g, '&lt;span dir=&quot;rtl&quot;&gt;');
            //str = str.replace(/\u202D/g, '&lt;bdo dir=&quot;ltr&quot;&gt;')
            //str = str.replace(/\u202E/g, '&lt;bdo dir=&quot;rtl&quot;&gt;')
            str = str.replace(/&#x202C;/g, '&lt;/span&gt;');
        }

        return str;
    }

    /**
     * Converts a string of characters to code points or code point based escapes.
     * @param str {string} the input
     * @param parameters {string} enum [ascii, latin1], a set of characters to not convert.
     * @param pad {boolean} if true, hex numbers lower than 1000 are padded with zeros.
     * @param before {string} any characters to include before a code point (eg. &#x for NCRs).
     * @param after {string} any characters to include after (eg. ; for NCRs).
     * @param base {string] enum [hex, dec], hex or decimal output.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2SelectiveCPs(str, parameters, pad, before, after, base) {
        var haut = 0;
        var n = 0;
        var cp;
        var CPstring = '';
        for (var i = 0; i < str.length; i++) {
            var b = str.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertCharStr2SelectiveCPs: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    if (base == 'hex') {
                        CPstring += before + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + after;
                    }
                    else {
                        cp = 0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00);
                        CPstring += before + cp + after;
                    }
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertCharStr2SelectiveCPs: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (parameters.match(/ascii/) && b <= 127) { //  && b != 0x3E && b != 0x3C &&  b != 0x26) {
                    CPstring += str.charAt(i);
                }
                else if (b <= 255 && parameters.match(/latin1/)) { // && b != 0x3E && b != 0x3C &&  b != 0x26) {
                    CPstring += str.charAt(i);
                }
                else {
                    if (base == 'hex') {
                        cp = dec2hex(b);
                        if (pad) {
                            while (cp.length < 4) {
                                cp = '0' + cp;
                            }
                        }
                    }
                    else {
                        cp = b;
                    }
                    CPstring += before + cp + after;
                }
            }
        }
        return CPstring;
    }

    /**
     *
     * @param textString
     * @returns {string}
     */
    function convertCharStr2HexNCR(textString) {
        var outputString = "";
        textString = textString.replace(/^\s+/, '');
        if (textString.length == 0) {
            return "";
        }
        textString = textString.replace(/\s+/g, ' ');
        var listArray = textString.split(' ');
        for (var i = 0; i < listArray.length; i++) {
            var n = parseInt(listArray[i], 16);
            outputString += '&#x' + dec2hex(n) + ';';
        }
        return ( outputString );
    }

    /**
     *
     * @param str {string] sequence of Unicode characters
     * @returns {string}
     */
    function convertCharStr2pEsc(str) {
        var outputString = "";
        var CPstring = convertChar2CP(str);
        if (str.length == 0) {
            return "";
        }
        // process each codepoint
        var listArray = CPstring.split(' ');
        for (var i = 0; i < listArray.length; i++) {
            var n = parseInt(listArray[i], 16);
            //if (i > 0) { outputString += ' ';}
            if (n == 0x20) {
                outputString += '%20';
            }
            else if (n >= 0x41 && n <= 0x5A) {
                outputString += String.fromCharCode(n);
            } // alpha
            else if (n >= 0x61 && n <= 0x7A) {
                outputString += String.fromCharCode(n);
            } // alpha
            else if (n >= 0x30 && n <= 0x39) {
                outputString += String.fromCharCode(n);
            } // digits
            else if (n == 0x2D || n == 0x2E || n == 0x5F || n == 0x7E) {
                outputString += String.fromCharCode(n);
            } // - . _ ~
            else if (n <= 0x7F) {
                outputString += '%' + dec2hex2(n);
            }
            else if (n <= 0x7FF) {
                outputString += '%' + dec2hex2(0xC0 | ((n >> 6) & 0x1F)) + '%' + dec2hex2(0x80 | (n & 0x3F));
            }
            else if (n <= 0xFFFF) {
                outputString += '%' + dec2hex2(0xE0 | ((n >> 12) & 0x0F)) + '%' + dec2hex2(0x80 | ((n >> 6) & 0x3F)) + '%' + dec2hex2(0x80 | (n & 0x3F));
            }
            else if (n <= 0x10FFFF) {
                outputString += '%' + dec2hex2(0xF0 | ((n >> 18) & 0x07)) + '%' + dec2hex2(0x80 | ((n >> 12) & 0x3F)) + '%' + dec2hex2(0x80 | ((n >> 6) & 0x3F)) + '%' + dec2hex2(0x80 | (n & 0x3F));
            }
            else {
                outputString += '!Error ' + dec2hex(n) + '!';
            }
        }
        return ( outputString );
    }

    /**
     * Converts a string of characters to UTF-8 byte codes, separated by spaces.
     * @param str {string} sequence of Unicode characters.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2UTF8(str) {
        var highsurrogate = 0;
        var suppCP; // decimal code point value for a supp char
        var n = 0;
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF8: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    outputString += ' ' + dec2hex2(0xF0 | ((suppCP >> 18) & 0x07)) + ' ' + dec2hex2(0x80 | ((suppCP >> 12) & 0x3F)) + ' ' + dec2hex2(0x80 | ((suppCP >> 6) & 0x3F)) + ' ' + dec2hex2(0x80 | (suppCP & 0x3F));
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF8: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // high surrogate
                highsurrogate = cc;
            }
            else {
                if (cc <= 0x7F) {
                    outputString += ' ' + dec2hex2(cc);
                }
                else if (cc <= 0x7FF) {
                    outputString += ' ' + dec2hex2(0xC0 | ((cc >> 6) & 0x1F)) + ' ' + dec2hex2(0x80 | (cc & 0x3F));
                }
                else if (cc <= 0xFFFF) {
                    outputString += ' ' + dec2hex2(0xE0 | ((cc >> 12) & 0x0F)) + ' ' + dec2hex2(0x80 | ((cc >> 6) & 0x3F)) + ' ' + dec2hex2(0x80 | (cc & 0x3F));
                }
            }
        }
        return outputString.substring(1);
    }

    /**
     * Converts a string of characters to UTF-16 code units, separated by spaces.
     * @param str {string} sequence of Unicode characters.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2UTF16(str) {
        var highsurrogate = 0;
        var suppCP;
        var n = 0;
        var outputString = '';
        var result = "";
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF16: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) {
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    suppCP -= 0x10000;
                    outputString += dec2hex4(0xD800 | (suppCP >> 10)) + ' ' + dec2hex4(0xDC00 | (suppCP & 0x3FF)) + ' ';
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF16: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else {
                result = dec2hex(cc);
                while (result.length < 4){
                    result = '0' + result;
                }
                outputString += result + ' ';
            }
        }
        return outputString.substring(0, outputString.length - 1);
    }

    /**
     * Converts a string of characters to JavaScript escapes.
     * @param str {string} sequence of Unicode characters.
     * @param parameters {string} a semicolon separated string showing ids for checkboxes that are turned on.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2jEsc(str, parameters) {
        var highsurrogate = 0;
        var suppCP;
        var pad;
        var n = 0;
        var pars = parameters.split(';');
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2UTF16: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) { // this is a supp char, and cc contains the low surrogate
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    if (parameters.match(/cstyleSC/)) {
                        pad = suppCP.toString(16);
                        while (pad.length < 8) {
                            pad = '0' + pad;
                        }
                        outputString += '\\U' + pad;
                    }
                    else if (parameters.match(/es6styleSC/)) {
                        pad = suppCP.toString(16);
                        outputString += '\\u{' + pad + '}';
                    }
                    else {
                        suppCP -= 0x10000;
                        outputString += '\\u' + dec2hex4(0xD800 | (suppCP >> 10)) + '\\u' + dec2hex4(0xDC00 | (suppCP & 0x3FF));
                    }
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2UTF16: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else { // this is a BMP character
                //outputString += dec2hex(cc) + ' ';
                switch (cc) {
                    case 0:
                        outputString += '\\0';
                        break;
                    case 8:
                        outputString += '\\b';
                        break;
                    case 9:
                        if (parameters.match(/noCR/)) {
                            outputString += '\\t';
                        } else {
                            outputString += '\t';
                        }
                        break;
                    case 10:
                        if (parameters.match(/noCR/)) {
                            outputString += '\\n';
                        } else {
                            outputString += '\n';
                        }
                        break;
                    case 13:
                        if (parameters.match(/noCR/)) {
                            outputString += '\\r';
                        } else {
                            outputString += '\r';
                        }
                        break;
                    case 11:
                        outputString += '\\v';
                        break;
                    case 12:
                        outputString += '\\f';
                        break;
                    case 34:
                        if (parameters.match(/noCR/)) {
                            outputString += '\\\"';
                        } else {
                            outputString += '"';
                        }
                        break;
                    case 39:
                        if (parameters.match(/noCR/)) {
                            outputString += "\\\'";
                        } else {
                            outputString += '\'';
                        }
                        break;
                    case 92:
                        outputString += '\\\\';
                        break;
                    default:
                        if (cc > 0x1f && cc < 0x7F) {
                            outputString += String.fromCharCode(cc);
                        }
                        else {
                            pad = cc.toString(16).toUpperCase();
                            while (pad.length < 4) {
                                pad = '0' + pad;
                            }
                            outputString += '\\u' + pad;
                        }
                }
            }
        }
        return outputString;
    }

    /**
     * Converts a string of characters to CSS escapes.
     * @param str {string} sequence of Unicode characters.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2CSS(str) {
        //
        //
        var highsurrogate = 0;
        var suppCP;
        var pad;
        var outputString = '';
        for (var i = 0; i < str.length; i++) {
            var cc = str.charCodeAt(i);
            if (cc < 0 || cc > 0xFFFF) {
                outputString += '!Error in convertCharStr2CSS: unexpected charCodeAt result, cc=' + cc + '!';
            }
            if (highsurrogate != 0) { // this is a supp char, and cc contains the low surrogate
                if (0xDC00 <= cc && cc <= 0xDFFF) {
                    suppCP = 0x10000 + ((highsurrogate - 0xD800) << 10) + (cc - 0xDC00);
                    pad = suppCP.toString(16).toUpperCase();
                    if (suppCP < 0x10000) {
                        while (pad.length < 4) {
                            pad = '0' + pad;
                        }
                    }
                    else {
                        while (pad.length < 6) {
                            pad = '0' + pad;
                        }
                    }
                    outputString += '\\' + pad + ' ';
                    highsurrogate = 0;
                    continue;
                }
                else {
                    outputString += 'Error in convertCharStr2CSS: low surrogate expected, cc=' + cc + '!';
                    highsurrogate = 0;
                }
            }
            if (0xD800 <= cc && cc <= 0xDBFF) { // start of supplementary character
                highsurrogate = cc;
            }
            else { // this is a BMP character
                if (cc == 0x5C) {
                    outputString += '\\\\';
                }
                else if (cc > 0x1f && cc < 0x7F) {
                    outputString += String.fromCharCode(cc);
                }
                else if (cc == 0x9 || cc == 0xA || cc == 0xD) {
                    outputString += String.fromCharCode(cc);
                }
                else /* if (cc > 0x7E) */ {
                    pad = cc.toString(16).toUpperCase();
                    while (pad.length < 4) {
                        pad = '0' + pad;
                    }
                    outputString += '\\' + pad + ' ';
                }
            }
        }
        return outputString;
    }

    /**
     * Converts a string of characters to code points, separated by space.
     * @param textString {string} the input
     * @param parameters {string} enum [ascii, latin1], a set of characters to not convert.
     * @param pad {boolean} if true, hex numbers lower than 1000 are padded with zeros.
     * @param type {string} enum[hex, dec, unicode, zerox], whether output should be in hex or dec or unicode U+ form.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2CP(textString, parameters, pad, type) {
        var haut = 0;
        var n = 0;
        var CPstring = '';
        var afterEscape = false;
        var cp = "";
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    if (afterEscape) {
                        CPstring += ' ';
                    }
                    if (type == 'hex') {
                        CPstring += dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else if (type == 'unicode') {
                        CPstring += 'U+' + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else if (type == 'zerox') {
                        CPstring += '0x' + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00));
                    }
                    else {
                        CPstring += 0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00);
                    }
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (b <= 127 && parameters.match(/ascii/)) {
                    CPstring += textString.charAt(i);
                    afterEscape = false;
                }
                else if (b <= 255 && parameters.match(/latin1/)) {
                    CPstring += textString.charAt(i);
                    afterEscape = false;
                }
                else {
                    if (afterEscape) {
                        CPstring += ' ';
                    }
                    if (type == 'hex') {
                        cp = dec2hex(b);
                        if (pad) {
                            while (cp.length < 4) {
                                cp = '0' + cp;
                            }
                        }
                    }
                    else if (type == 'unicode') {
                        cp = dec2hex(b);
                        if (pad) {
                            while (cp.length < 4) {
                                cp = '0' + cp;
                            }
                        }
                        CPstring += 'U+';
                    }
                    else if (type == 'zerox') {
                        cp = dec2hex(b);
                        if (pad) {
                            while (cp.length < 4) {
                                cp = '0' + cp;
                            }
                        }
                        CPstring += '0x';
                    }
                    else {
                        cp = b;
                    }
                    CPstring += cp;
                    afterEscape = true;
                }
            }
        }
        return CPstring;
    }

    /**
     * Converts a string of characters to U+... notation, separated by space.
     * @param textString {string} the input
     * @param preserve {string} enum [ascii, latin1], a set of characters to not convert.
     * @param pad {boolean} if true, hex numbers lower than 1000 are padded with zeros.
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    function convertCharStr2Unicode(textString, preserve, pad) {
        // pad:
        var haut = 0;
        var n = 0;
        var CPstring = '';
        var cp = "";
        pad = false;
        for (var i = 0; i < textString.length; i++) {
            var b = textString.charCodeAt(i);
            if (b < 0 || b > 0xFFFF) {
                CPstring += 'Error in convertChar2CP: byte out of range ' + dec2hex(b) + '!';
            }
            if (haut != 0) {
                if (0xDC00 <= b && b <= 0xDFFF) {
                    CPstring += 'U+' + dec2hex(0x10000 + ((haut - 0xD800) << 10) + (b - 0xDC00)) + ' ';
                    haut = 0;
                    continue;
                }
                else {
                    CPstring += 'Error in convertChar2CP: surrogate out of range ' + dec2hex(haut) + '!';
                    haut = 0;
                }
            }
            if (0xD800 <= b && b <= 0xDBFF) {
                haut = b;
            }
            else {
                if (b <= 127 && preserve == 'ascii') {
                    CPstring += textString.charAt(i) + ' ';
                }
                else if (b <= 255 && preserve == 'latin1') {
                    CPstring += textString.charAt(i) + ' ';
                }
                else {
                    cp = dec2hex(b);
                    if (pad) {
                        while (cp.length < 4) {
                            cp = '0' + cp;
                        }
                    }
                    CPstring += 'U+' + cp + ' ';
                }
            }
        }
        return CPstring.substring(0, CPstring.length - 1);
    }


    utils.convertCharStr2pEsc = convertCharStr2pEsc;

    utils.convertAllEscapes = convertAllEscapes;

    var digit_array = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
    /**
     *
     * @param n
     * @returns {string}
     */
    utils.to_hex = function (n) {
        var hex_result = '';
        var the_start = true;
        for (var i = 32; i > 0;) {
            i -= 4;
            var one_digit = (n >> i) & 0xf;
            if (!the_start || one_digit != 0) {
                the_start = false;
                hex_result += digit_array[one_digit];
            }
        }
        return '0x' + (hex_result == '' ? '0' : hex_result);
    };


    /**
     * Unescape hex sequences like 'x0d' to chars
     * @param str {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceHex = function (str) {
        if (_.isString(str)) {
            return str.replace(/x([0-9A-Fa-f]{2})/gmi, function () {
                return String.fromCharCode(parseInt(arguments[1], 16));
            });
        }
        return str;
    };

    var zero = function (n, max) {
        n = n.toString(16).toUpperCase();
        while (n.length < max) {
            n = '0' + n;
        }
        return n;
    };

    function d2h(d) {
        return d.toString(16);
    }

    function h2d(h) {
        return parseInt(h, 16);
    }

    /**
     * Convert a string into hex values
     * @memberOf module:xide/utils/StringUtils
     * @param string {string}
     * @returns {string}
     */
    utils.stringToHex = function (string) {
        var str = '',
            i = 0,
            tmp_len = string.length,
            c;

        for (; i < tmp_len; i += 1) {
            c = string.charCodeAt(i);
            str += zero(d2h(c), 2) + ' ';
        }
        return str;
    };

    /**
     * Returns buffer compatible string
     * @param string
     * @example

     utils.stringToHex("a b") returns "61 20 62"

     * @memberOf module:xide/utils/StringUtils
     * @returns {string}
     */
    utils.stringToBufferStr = function (string) {
        var i = 0,
            tmp_len = string.length,
            c;

        var arr = [];
        for (; i < tmp_len; i += 1) {
            c = string.charCodeAt(i);
            arr.push(c);
        }
        return arr.join(',');
    };

    /**
     * Return an integer array (as Buffer) for a string
     * @param string
     * @returns {Array}
     */
    utils.stringToBuffer = function (string) {
        var i = 0,
            tmp_len = string.length,
            c;
        var arr = [];
        for (; i < tmp_len; i += 1) {
            c = string.charCodeAt(i);
            arr.push(c);
        }
        return arr;
    };

    /**
     *
     * @param bufferString {String} The serialized buffer formatted as 00,02 (decimal values)
     * @memberOf module:xide/utils/StringUtils
     * @returns {String} The hex version of the buffer string
     */
    utils.bufferToHexString = function (bufferString) {
        var bytesArray = bufferString.indexOf(',') !== -1 ? bufferString.split(',') : [bufferString];
        var tmp = [];
        for (var i = 0; i < bytesArray.length; i++) {
            var dec = bytesArray[i];
            tmp.push(utils.dec2hex2(dec));
        }
        return tmp.join(" ");
    };

    /**
     *
     * @param bufferString {String} The serialized buffer formatted as 00,02 (decimal values)
     * @memberOf module:xide/utils/StringUtils
     * @returns {integer} The integer array
     */
    utils.bufferFromDecString = function (bufferString) {
        var bytesArray = bufferString.indexOf(',') !== -1 ? bufferString.split(',') : [bufferString];
        for (var i = 0; i < bytesArray.length; i++) {
            bytesArray[i] = parseInt(bytesArray[i],10);
        }
        return bytesArray;
    };


    /**
     * Return a buffer like formatted string "0a 12"
     * @param string
     * @memberOf module:xide/utils/StringUtils
     * @returns {string}
     */
    utils.stringFromDecString = function (string) {
        var buffer = utils.bufferFromDecString(string);
        var result = "";
        for (var i = 0; i < buffer.length; i++) {
            result += String.fromCharCode(buffer[i]);
        }
        return result;
    };

    /**
     *
     * @param string
     * @returns {string}
     */
    utils.stringToHex2 = function (string) {
        var str = '',
            i = 0,
            tmp_len = string.length,
            c;

        for (; i < tmp_len; i += 1) {
            c = string.charCodeAt(i);
            str += zero(d2h(c), 2) + ' ';
        }
        return str;
    };

    /**
     *
     * @param string {string}
     * @returns {string}
     */
    function hexToString(string) {
        var arr = string.split(' '),
            str = '',
            i = 0,
            arr_len = arr.length,
            c;

        for (; i < arr_len; i += 1) {
            c = String.fromCharCode(h2d(arr[i]));
            str += c;
        }
        return str;
    }

    utils.hexToString = hexToString;

    /**
     *
     * @param buffer
     * @returns {string}
     */
    utils.prettyHex = function (buffer) {
        var rows = Math.ceil(buffer.length / 16);
        var last = buffer.length % 16 || 16;
        var offsetLength = buffer.length.toString(16).length;
        if (offsetLength < 6) {
            offsetLength = 6;
        }
        var str = 'Offset';
        while (str.length < offsetLength) {
            str += ' ';
        }

        str = '\u001b[36m' + str + '  ';

        var i;
        for (i = 0; i < 16; i++) {
            str += ' ' + zero(i, 2);
        }

        str += '\u001b[0m\n';
        if (buffer.length) {
            str += '\n';
        }

        var b = 0;
        var lastBytes;
        var lastSpaces;
        var v;

        for (i = 0; i < rows; i++) {
            str += '\u001b[36m' + zero(b, offsetLength) + '\u001b[0m  ';
            lastBytes = i === rows - 1 ? last : 16;
            lastSpaces = 16 - lastBytes;

            var j;
            for (j = 0; j < lastBytes; j++) {
                str += ' ' + zero(buffer[b], 2);
                b++;
            }

            for (j = 0; j < lastSpaces; j++) {
                str += '   ';
            }

            b -= lastBytes;
            str += '   ';

            for (j = 0; j < lastBytes; j++) {
                v = buffer[b];
                str += (v > 31 && v < 127) || v > 159 ? String.fromCharCode(v) : '.';
                b++;
            }
            str += '\n';
        }
        return str;
    };

    /**
     *
     * @param str
     * @param prefix
     * @returns {string}
     */
    utils.hexEncode = function (str, prefix) {
        var hex, i;
        var result = "";
        for (i = 0; i < str.length; i++) {
            hex = str.charCodeAt(i).toString(16);
            result += ((prefix !== null ? prefix : "000") + hex).slice(-4);
        }
        return result;
    };

    /**
     *
     * @param str
     * @param prefix
     * @param suffix
     * @param sign
     * @returns {string}
     */
    utils.markHex = function (str, prefix, suffix, sign) {
        prefix = prefix || "";
        suffix = suffix || "";
        var myString = "" + str;
        var pattern = /[^\x20-\x7E]/gim;
        var match = pattern.exec(myString);
        var matches = myString.match(pattern);
        var newString = "" + myString;
        myString.replace(pattern, function (a, b) {
            var _raw = utils.hexEncode(a, '$');
            if (_raw.length == 2) {
                _raw = _raw.replace("$", "$0");
            }
            _raw = _raw.toUpperCase();
            myString = myString.replace(a, prefix + _raw + suffix);
        });
        return myString;
    };

    return utils;
});;
/** @module xide/utils/StringUtils
 *  @description All string related functions
 */
define('xide/utils/StringUtils',[
    'xide/utils',
    'xide/types',
    'dojo/json',
    'xide/lodash'
], function (utils, types, json, _) {
    "use strict";

    /**
     *
     * @param replacer
     * @param cycleReplacer
     * @returns {Function}
     */
    function serializer(replacer, cycleReplacer) {
        var stack = [], keys = [];

        if (cycleReplacer == null) cycleReplacer = function (key, value) {
            if (stack[0] === value) return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
        };

        return function (key, value) {
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this);
                ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
                ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
                if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
            }
            else stack.push(value);

            return replacer == null ? value : replacer.call(this, key, value)
        }
    }

    /**
     *
     * @param obj
     * @returns {*}
     */
    utils.stringify = function (obj) {
        return JSON.stringify(obj, serializer(), 2);
    };

    function stringify(obj, replacer, spaces, cycleReplacer) {
        return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }

    /**
     * Takes a number and returns a rounded fixed digit string.
     * Returns an empty string if first parameter is NaN, (-)Infinity or not of type number.
     * If parameter trailing is set to true trailing zeros will be kept.
     *
     * @param {number} num the number
     * @param {number} [digits=3] digit count
     * @param {boolean} [trailing=false] keep trailing zeros
     * @memberOf module:xide/utils/StringUtils
     *
     * @example
     *
     test(fsuxx(-6.8999999999999995), '-6.9');
     test(fsuxx(0.020000000000000004), '0.02');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 1), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     test(fsuxx('muh'), '');
     test(fsuxx(false), '');
     test(fsuxx(null), '');
     test(fsuxx(), '');
     test(fsuxx(NaN), '');
     test(fsuxx(Infinity), '');
     test(fsuxx({bla: 'blub'}), '');
     test(fsuxx([1,2,3]), '');
     test(fsuxx(6.8999999999999995), '6.9');
     test(fsuxx(0.199000000000000004), '0.199');
     test(fsuxx(0.199000000000000004, 2), '0.2');
     test(fsuxx(0.199000000000000004, 2, true), '0.20');
     *
     *
     * @returns {string}
     *
     */
    utils.round = function (num, digits, trailing) {

        if (typeof num !== 'number' || isNaN(num) || num === Infinity || num === -Infinity) return '';

        digits = ((typeof digits === 'undefined') ? 3 : (parseInt(digits, 10) || 0));

        var f = Math.pow(10, digits);
        var res = (Math.round(num * f) / f).toFixed(digits);

        // remove trailing zeros and cast back to string
        if (!trailing) res = '' + (+res);

        return res;
    };




    /**
     *
     * @param bytes
     * @param si
     * @returns {string}
     */
    utils.humanFileSize = function (bytes, si) {
        var thresh = si ? 1000 : 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = si
            ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1) + ' ' + units[u];
    };

    if (typeof String.prototype.startsWith != 'function') {
        // see below for better implementation!
        String.prototype.startsWith = function (str) {
            return this.indexOf(str) === 0;
        };
    }

    if ( typeof String.prototype.endsWith != 'function' ) {
        String.prototype.endsWith = function( str ) {
            return this.substring( this.length - str.length, this.length ) === str;
        }
    }

    /**
     *
     * @param str
     * @returns {boolean}
     */
    utils.isNativeEvent = function (str) {
        var _foo = null,//just for having an optimized object map for a native event lookup below
            _nativeEvents = {
                "onclick": _foo,
                "ondblclick": _foo,
                "onmousedown": _foo,
                "onmouseup": _foo,
                "onmouseover": _foo,
                "onmousemove": _foo,
                "onmouseout": _foo,
                "onkeypress": _foo,
                "onkeydown": _foo,
                "onkeyup": _foo,
                "onfocus": _foo,
                "onblur": _foo,
                "onchange": _foo
            };

        if (str in _nativeEvents) {
            return true;
        }
        _nativeEvents = {
            "click": _foo,
            "dblclick": _foo,
            "mousedown": _foo,
            "mouseup": _foo,
            "mouseover": _foo,
            "mousemove": _foo,
            "mouseout": _foo,
            "keypress": _foo,
            "keydown": _foo,
            "keyup": _foo,
            "focus": _foo,
            "blur": _foo,
            "change": _foo
        };

        return str in _nativeEvents;

    };
    /**
     *
     * @param str
     * @returns {boolean}
     *
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isSystemEvent = function (str) {
        for (var t in types.EVENTS) {
            if (types.EVENTS[t] === str) {
                return true;
            }
        }
        return false;
    };

    /**
     *
     * @param arr
     * @param val
     * @returns {number}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.contains = function (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === val) {
                return i;
            }
        }
        return -1;
    };
    /**
     *
     * @param obj
     * @param val
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getObjectKeyByValue = function (obj, val) {
        if (obj && val) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (obj[prop] === val)
                        return prop;
                }
            }
        }
        return null;
    };

    /**
     *
     * @param url
     * @param parameter
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.removeURLParameter = function (url, parameter) {
        //prefer to use l.search if you have a location/link object
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {

            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);

            //reverse iteration as may be destructive
            for (var i = pars.length; i-- > 0;) {
                //idiom for string.startsWith
                if (pars[i].lastIndexOf(prefix, 0) !== -1) {
                    pars.splice(i, 1);
                }
            }

            url = urlparts[0] + '?' + pars.join('&');
            return url;
        } else {
            return url;
        }
    };

    /**
     *
     * @param url
     * @param paramName
     * @param paramValue
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceUrlParam = function (url, paramName, paramValue) {
        if (url.indexOf(paramName) == -1) {
            url += (url.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue;
            return url;
        }
        var pattern = new RegExp('(' + paramName + '=).*?(&|$)');
        var newUrl = url.replace(pattern, '$1' + paramValue + '$2');
        if (newUrl == url) {
            newUrl = newUrl + (newUrl.indexOf('?') > 0 ? '&' : '?') + paramName + '=' + paramValue
        }
        return newUrl
    };

    /**
     *
     * @param mount
     * @param path
     * @param encode
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.buildPath = function (mount, path, encode) {

        //fix mount
        var _mount = '' + mount;
        _mount = utils.replaceAll('/', '', mount);
        var _path = '' + path;
        _path = _path.replace('./', '/').replace(/^\/|\/$/g, '');

        var _res = _mount + '://' + _path;
        if (encode === true) {
            return encodeURIComponent(_res);
        }
        return _res;
    };

    /**
     *
     * @param string
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     *
     */
    utils.isImage = function (string) {
        return string.toLowerCase().match(/\.(jpeg|jpg|gif|png)$/) != null;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag3 = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param field
     * @param enumValue
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.hasFlag = function (field, enumValue) {
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        return ((1 << enumValue) & field) ? true : false;
    };

    /**
     *
     * @param enumValue
     * @param field
     * @returns {int|*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.disableFlag = function (enumValue, field) {
        enumValue &= ~(1 << field);
        return enumValue;
    };
    /**
     * XApp specific url string cleaner
     * @param string
     * @returns {*}
     */
    utils.cleanUrl = function (string) {
        if (string) {
            string = string.replace('//', '/');
            string = string.replace('./', '/');
            string = string.replace('http:/', 'http://');
            string = string.replace('./', '/');
            string = string.replace('////', '/');
            string = string.replace('///', '/');
            return string;
        }
        return string;
    };
    /**
     * Return data from JSON
     * @param inData
     * @param validOnly
     * @param imit
     * @memberOf module:xide/utils/StringUtils
     * @returns {*}
     */
    utils.getJson = function (inData, validOnly, ommit) {
        try {
            return _.isString(inData) ? json.parse(inData, false) : validOnly === true ? null : inData;
        } catch (e) {
            ommit !== false && console.error('error parsing json data ' + inData + ' error = ' + e);
        }
        return null;
    };

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.fromJson = function (js) {
        if (!_.isString(js)) {
            return js;
        }
        var res = null;
        var didFail = false;
        try {
            res = eval("(" + js + ")", {});
        } catch (e) {
            didFail = true;
        }
        if (didFail) {
            js = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                res = eval("(" + js + ")", {});
            } catch (e) {
                throw new Error(js);
            }
        }
        return res;
    };

    /**
     * String Replace which works with multiple found items. Native aborts on the first needle.
     * @param find
     * @param replace
     * @param str
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.replaceAll = function (find, replace, str) {
        return str ? str.split(find).join(replace) : '';
    };

    /**
     * CI compatible string check for null and length>0
     * @param input
     * @returns {boolean}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.isValidString = function (input) {
        return input != null && input.length != null && input.length > 0 && input != "undefined"; //Boolean
    };

    /**
     * Dojo style template replacer
     * @param template
     * @param obj
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.substituteString = function (template, obj) {
        return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key) {
            return obj[key];
        });
    };

    /**
     *
     * @param expression
     * @param delimiters
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.findOcurrences = function (expression, delimiters) {
        var d = {
            begin: utils.escapeRegExp(delimiters.begin),
            end: utils.escapeRegExp(delimiters.end)
        };
        return expression.match(new RegExp(d.begin + "([^" + d.end + "]*)" + d.end, 'g'));
    };

    /**
     * Escape regular expressions in a string
     * @param string
     * @returns {*}
     * @private
     * @memberOf module:xide/utils/StringUtils
     */
    utils.escapeRegExp = function (string) {
        var special = ["[", "]", "(", ")", "{", "}", "*", "+", ".", "|", "||"];
        for (var n = 0; n < special.length; n++) {
            string = string.replace(special[n], "\\" + special[n]);
        }

        return string;
    };
    /**
     *
     * @param str {string} haystack
     * @param hash {Object}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.multipleReplace = function (str, hash) {
        //to array
        var a = [];
        for (var key in hash) {
            a[a.length] = key;
        }
        return str.replace(new RegExp(a.join('\\b|\\b'), 'g'), function (m) {
            return hash[m] || hash["\\" + m];
        });
    };

    /**
     * Flexible replacer, supports multiple replace and safe replace
     *
     * @param str {string} the haystack

     * @param needle {string|null} optional, only needed for simple cases, otherwise its using the 'what' map
     *
     * @param what {string|Object}. When string, its replacing 'needle' with 'what'. If its a hash-map:
     * variable:value, its replacing occurrences of all variables in 'haystack'. In such case, you can specify
     * delimiters to make sure that 'unresolved' variables will be stripped of in the result.
     *
     * @param delimiters {Object} Delimiters to identify variables. This is used to eliminate unresolved variables from
     * the result.
     *
     * @param delimiters.begin {string}
     * @param delimiters.end {string}
     *
     * @returns {string}
     *
     *
     * @example:
     *
     * 1. simple case: replace all '/' with ''
     *
     * return utils.replace('/foo/','/','') //returns 'foo'
     *
     * 2. simple case with multiple variables:
     *
     * return utils.replace('darling, i miss you so much',null,{'miss':'kiss','much':'little'})
     * # darling, i kiss you so little
     *
     * @memberOf module:xide/utils
     * @extends xide/utils
     */
    utils.replace = function (str, needle, what, delimiters) {
        if (!str) {
            return '';
        }
        if (what && _.isObject(what) || _.isArray(what)) {
            if (delimiters) {
                var ocurr = utils.findOcurrences(str, delimiters),
                    replaceAll = utils.replaceAll;
                if (ocurr) {

                    for (var i = 0, j = ocurr.length; i < j; i++) {
                        var el = ocurr[i];

                        //strip off delimiters
                        var _variableName = replaceAll(delimiters.begin, '', el);
                        _variableName = replaceAll(delimiters.end, '', _variableName);
                        str = replaceAll(el, what[_variableName], str);
                    }
                } else {
                    return str;
                }
            } else {
                //fast case
                return utils.multipleReplace(str, what)
            }
            return str;
        }
        //fast case
        return utils.replaceAll(needle, what, str);
    };

    /**
     * Capitalize
     * @param word
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.capitalize = function (word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1);
    };

    /**
     * vsprintf impl. of PHP
     * @param format
     * @param args
     * @example
     // example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1]);
     // returns 1: '1988-08-01'
     * @memberOf module:xide/utils/StringUtils
     */
    utils.vsprintf = function (format, args) {
        return utils.sprintf.apply(this, [format].concat(args));
    };
    /**
     * PHP.js version of sprintf
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @link http://kevin.vanzonneveld.net
     */
    utils.sprintf = function () {
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        var a = arguments,
            i = 0,
            format = a[i++];

        // pad()
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        };

        // justify()
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };

        // formatBaseX()
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {
                    '2': '0b',
                    '8': '0',
                    '16': '0x'
                }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };

        // formatString()
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };

        // doFormat()
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;

            if (substring === '%%') {
                return '%';
            }

            // parse flags
            var leftJustify = false,
                positivePrefix = '',
                zeroPad = false,
                prefixBaseX = false,
                customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                    case ' ':
                        positivePrefix = ' ';
                        break;
                    case '+':
                        positivePrefix = '+';
                        break;
                    case '-':
                        leftJustify = true;
                        break;
                    case "'":
                        customPadChar = flags.charAt(j + 1);
                        break;
                    case '0':
                        zeroPad = true;
                        break;
                    case '#':
                        prefixBaseX = true;
                        break;
                }
            }

            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth === '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }

            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
            } else if (precision === '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }

            // grab value using valueIndex if required?
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
                case 's':
                    return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
                case 'c':
                    return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
                case 'b':
                    return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'o':
                    return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'x':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'X':
                    return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
                case 'u':
                    return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
                case 'i':
                case 'd':
                    number = +value || 0;
                    number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
                    prefix = number < 0 ? '-' : positivePrefix;
                    value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad);
                case 'e':
                case 'E':
                case 'f': // Should handle locales (as per setlocale)
                case 'F':
                case 'g':
                case 'G':
                    number = +value;
                    prefix = number < 0 ? '-' : positivePrefix;
                    method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                    textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                    value = prefix + Math.abs(number)[method](precision);
                    return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
                default:
                    return substring;
            }
        };

        return format.replace(regex, doFormat);
    };
    /***
     *
     * @param str
     * @returns {string | null}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.cleanString = function (str) {
        if (!str) {
            return null;
        }
        str = str.replace(/[\r]/g, '')
            .replace(/[\b]/g, '')
            .replace(/[\f]/g, '')
            .replace(/[\n]/g, '')
            .replace(/\\/g, '');
        return str;
    };
    /***
     *
     * @param str {string}
     * @returns {string | null}
     */
    utils.normalizePath = function (str) {
        if (!str) {
            return null;
        }
        str = utils.cleanString(str);//control characters
        str = str.replace('./', '');//file store specifics
        str = str.replace('/.', '');//file store specifics
        str = str.replace(/([^:]\/)\/+/g, "$1");//double slashes
        return str;
    };

    /**
     *
     * @enum
     * @global
     * @memberOf module:xide/types
     */
    types.PATH_PARTS = {
        'DIRNAME': 1,
        'BASENAME': 2,
        'EXTENSION': 4,
        'FILENAME': 8,
        'PATHINFO_ALL': 0
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix {string}
     * @example
     //   example 1: basename('/www/site/home.htm', '.htm');
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1');
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/');
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext');
     //   returns 4: 'path_ext'
     * @returns {*}
     * @memberOf module:xide/utils/StringUtils
     * @link http://phpjs.org/functions/basename/
     */
    utils.basename = function (path, suffix) {
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1);
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) == suffix) {
            b = b.substr(0, b.length - suffix.length);
        }
        return b;
    };

    /**
     *
     * @param path
     * @param options
     * @example
     //   example 1: pathinfo('/www/htdocs/index.html', 1);
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME');
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION');
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME');
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4);
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL');
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html');
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     * @returns {object}
     * @link http://phpjs.org/functions/pathinfo/
     * @memberOf module:xide/utils/StringUtils
     */
    utils.pathinfo = function (path, options) {
        //  discuss at:
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //        note: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //        note: The way the bitwise arguments are handled allows for greater flexibility
        //        note: & compatability. We might even standardize this code and use a similar approach for
        //        note: other bitwise PHP functions
        //        note: php.js tries very hard to stay away from a core.js file with global dependencies, because we like
        //        note: that you can just take a couple of functions and be on your way.
        //        note: But by way we implemented this function, if you want you can still declare the PATHINFO_*
        //        note: yourself, and then you can use: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //        note: which makes it fully compliant with PHP syntax.
        //  depends on: basename
        var opt = '',
            real_opt = '',
            optName = '',
            optTemp = 0,
            tmp_arr = {},
            cnt = 0,
            i = 0;
        var have_basename = false,
            have_extension = false,
            have_filename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false;
        }
        if (!options) {
            options = 'PATHINFO_ALL';
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName];
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]];
                }
            }
            options = optTemp;
        }

        // Internal Functions
        var __getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : '';
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path.replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmp_arr.dirname = dirName === path ? '.' : dirName;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            tmp_arr.basename = have_basename;
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false !== have_extension) {
                tmp_arr.extension = have_extension;
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (false === have_basename) {
                have_basename = utils.basename(path);
            }
            if (false === have_extension) {
                have_extension = __getExt(have_basename);
            }
            if (false === have_filename) {
                have_filename = have_basename.slice(0, have_basename.length - (have_extension ? have_extension.length + 1 :
                        have_extension === false ? 0 : 1));
            }

            tmp_arr.filename = have_filename;
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmp_arr) {
            if (tmp_arr.hasOwnProperty(opt)) {
                cnt++;
                real_opt = opt;
            }
        }
        if (cnt === 1) {
            return tmp_arr[real_opt];
        }

        // Return full-blown array
        return tmp_arr;
    };

    /**
     * PHP.js version of parse_url
     * @param str {string}
     * @param component {string} enum
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.parse_url = function (str, component) {
        //       discuss at: http://phpjs.org/functions/parse_url/
        //      improved by: Brett Zamir (http://brett-zamir.me)
        //             note: original by http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: blog post at http://blog.stevenlevithan.com/archives/parseuri
        //             note: demo at http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
        //             note: Does not replace invalid characters with '_' as in PHP, nor does it return false with
        //             note: a seriously malformed URL.
        //             note: Besides function name, is essentially the same as parseUri as well as our allowing
        //             note: an extra slash after the scheme/protocol (to allow file:/// as in PHP)
        //        example 1: parse_url('http://username:password@hostname/path?arg=value#anchor');
        //        returns 1: {scheme: 'http', host: 'hostname', user: 'username', pass: 'password', path: '/path', query: 'arg=value', fragment: 'anchor'}
        var query, key = ['source', 'scheme', 'authority', 'userInfo', 'user', 'pass', 'host', 'port',
                'relative', 'path', 'directory', 'file', 'query', 'fragment'
            ],
            ini = (this.php_js && this.php_js.ini) || {},
            mode = (ini['phpjs.parse_url.mode'] &&
                ini['phpjs.parse_url.mode'].local_value) || 'php',
            parser = {
                php: /^(?:([^:\/?#]+):)?(?:\/\/()(?:(?:()(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?()(?:(()(?:(?:[^?#\/]*\/)*)()(?:[^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/\/?)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // Added one optional slash to post-scheme to catch file:/// (should restrict this)
            };

        var m = parser[mode].exec(str),
            uri = {},
            i = 14;
        while (i--) {
            if (m[i]) {
                uri[key[i]] = m[i];
            }
        }

        if (component) {
            return uri[component.replace('PHP_URL_', '')
                .toLowerCase()];
        }
        if (mode !== 'php') {
            var name = (ini['phpjs.parse_url.queryKey'] &&
                ini['phpjs.parse_url.queryKey'].local_value) || 'queryKey';
            parser = /(?:^|&)([^&=]*)=?([^&]*)/g;
            uri[name] = {};
            query = uri[key[12]] || '';
            query.replace(parser, function ($0, $1, $2) {
                if ($1) {
                    uri[name][$1] = $2;
                }
            });
        }
        delete uri.source;
        return uri;
    };

    /***
     *
     * @deprecated
     */
    utils.getMimeTable = function () {
        return {};
    };

    /***
     * @deprecated
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getMimeTable2 = function () {
        return {
            "mid": "fa-file-audio-o",
            "txt": "fa-file-text-o",
            "sql": "fa-cube",
            "js": "fa-cube",
            "gif": "fa-file-picture-o",
            "jpg": "fa-file-picture-o",
            "html": "fa-cube",
            "htm": "fa-cube",
            "rar": "fa-file-zip-o",
            "gz": "fa-file-zip-o",
            "tgz": "fa-file-zip-o",
            "z": "fa-file-zip-o",
            "ra": "fa-file-movie-o",
            "ram": "fa-file-movie-o",
            "rm": "fa-file-movie-o",
            "pl": "source_pl.png",
            "zip": "fa-file-zip-o",
            "wav": "fa-file-audio-o",
            "php": "fa-cube",
            "php3": "fa-cube",
            "phtml": "fa-cube",
            "exe": "fa-file-o",
            "bmp": "fa-file-picture-o",
            "png": "fa-file-picture-o",
            "css": "fa-cube",
            "mp3": "fa-file-audio-o",
            "m4a": "fa-file-audio-o",
            "aac": "fa-file-audio-o",
            "xls": "fa-file-excel-o",
            "xlsx": "fa-file-excel-o",
            "ods": "fa-file-excel-o",
            "sxc": "fa-file-excel-o",
            "csv": "fa-file-excel-o",
            "tsv": "fa-file-excel-o",
            "doc": "fa-file-word-o",
            "docx": "fa-file-word-o",
            "odt": "fa-file-word-o",
            "swx": "fa-file-word-o",
            "rtf": "fa-file-word-o",
            "md": "fa-file-word-o",
            "ppt": "fa-file-powerpoint-o",
            "pps": "fa-file-powerpoint-o",
            "odp": "fa-file-powerpoint-o",
            "sxi": "fa-file-powerpoint-o",
            "pdf": "fa-file-pdf-o",
            "mov": "fa-file-movie-o",
            "avi": "fa-file-movie-o",
            "mpg": "fa-file-movie-o",
            "mpeg": "fa-file-movie-o",
            "mp4": "fa-file-movie-o",
            "m4v": "fa-file-movie-o",
            "ogv": "fa-file-movie-o",
            "webm": "fa-file-movie-o",
            "wmv": "fa-file-movie-o",
            "swf": "fa-file-movie-o",
            "flv": "fa-file-movie-o",
            "tiff": "fa-file-picture-o",
            "tif": "fa-file-picture-o",
            "svg": "fa-file-picture-o",
            "psd": "fa-file-picture-o",
            "ers": "horo.png"
        };
    };
    /***
     *
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     */
    utils.getIconTable = function () {
        return {};
    };


    /**
     *
     * @param string
     * @param overwrite
     * @returns {object}
     * @memberOf module:xide/utils/StringUtils
     * @deprecated
     */
    utils.urlDecode = function (string, overwrite) {
        if (!string || !string.length) {
            return {}
        }
        var obj = {};
        var pairs = string.split("&");
        var pair, name, value;
        for (var i = 0, len = pairs.length; i < len; i++) {
            pair = pairs[i].split("=");
            name = decodeURIComponent(pair[0]);
            value = decodeURIComponent(pair[1]);
            if (value != null && value === 'true') {
                value = true;
            } else if (value === 'false') {
                value = false;
            }
            if (overwrite !== true) {
                if (typeof obj[name] == "undefined") {
                    obj[name] = value
                } else {
                    if (typeof obj[name] == "string") {
                        obj[name] = [obj[name]];
                        obj[name].push(value)
                    } else {
                        obj[name].push(value)
                    }
                }
            } else {
                obj[name] = value
            }
        }
        return obj;
    };
    /**
     *
     * @param string {string}
     * @returns {object}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getUrlArgs = function (string) {
        var args = {};
        if (string && (string.indexOf('?') != -1 || string.indexOf('&') != -1)) {

            var query = string.substr(string.indexOf("?") + 1) || location.search.substring(1);
            var pairs = query.split("&");
            for (var i = 0; i < pairs.length; i++) {
                var pos = pairs[i].indexOf("=");
                var name = pairs[i].substring(0, pos);
                var value = pairs[i].substring(pos + 1);
                value = decodeURIComponent(value);
                args[name] = value;
            }
        }
        return args;
    };

    /**
     *
     * @param url {string}
     * @returns {object}
     * @deprecated
     */
    utils.urlArgs = function (url) {
        var query = utils.getUrlArgs(url);
        var map = {};
        for (var param in query) {
            var value = query[param],
                options = utils.findOcurrences(value, {
                    begin: "|",
                    end: "|"
                }),
                parameterOptions = null;

            if (options && options.length) {
                //clean value:
                value = value.replace(options[0], '');
                //parse options
                var optionString = options[0].substr(1, options[0].length - 2),
                    optionSplit = optionString.split(','),
                    optionsData = {};

                for (var i = 0; i < optionSplit.length; i++) {

                    var keyValue = optionSplit[i],
                        pair = keyValue.split(':');

                    optionsData[pair[0]] = pair[1];
                }
                parameterOptions = optionsData;
            }

            if (value && value.length) {
                map[param] = {
                    value: value,
                    options: parameterOptions
                }
            }
        }
        return map;
    };

    /**
     *
     * @param fileName {string}
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIcon = function (fileName) {
        if (!fileName) {
            return 'txt2.png';
        }
        var extension = utils.getFileExtension(fileName);
        if (extension) {
            var mime = utils.getMimeTable();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'txt2.png';
    };
    /**
     *
     * @param fileName
     * @returns {string}
     * @deprecated
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getIconClass = function (fileName) {
        if (!fileName) {
            return 'fa-file-o';
        }
        var extension = utils.getFileExtension(fileName);
        if (types.customMimeIcons[extension]) {
            return types.customMimeIcons[extension];
        }
        if (extension) {
            var mime = utils.getMimeTable2();
            if (mime[extension] != null) {
                return mime[extension];
            }
        }
        return 'fa-file-o';
    };
    /**
     * File extension
     * @deprecated
     * @param fileName {string}
     * @returns {string}
     */
    utils.getFileExtension = function (fileName) {
        if (!fileName || fileName == "") return "";
        var split = utils.getBaseName(fileName).split('.');
        if (split.length > 1) return split[split.length - 1].toLowerCase();
        return '';
    };
    /**
     * Create a basic UUID via with Math.Random
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.createUUID = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4()); //String
    };
    /**
     * Basename
     * @param fileName {string}
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     */
    utils.getBaseName = function (fileName) {
        if (fileName == null) return null;
        var separator = "/";
        if (fileName.indexOf("\\") !==-1)
            separator = "\\";
        return fileName.substr(fileName.lastIndexOf(separator) + 1, fileName.length);
    };
    /**
     * PHP.js version of basename
     * @param path {string}
     * @param suffix
     * @returns {string}
     * @memberOf module:xide/utils/StringUtils
     * @example

     //   example 1: basename('/www/site/home.htm', '.htm')
     //   returns 1: 'home'
     //   example 2: basename('ecra.php?p=1')
     //   returns 2: 'ecra.php?p=1'
     //   example 3: basename('/some/path/')
     //   returns 3: 'path'
     //   example 4: basename('/some/path_ext.ext/','.ext')
     //   returns 4: 'path_ext'

     * @memberOf module:xide/utils/StringUtils
     */
    utils.basename = function basename(path, suffix) {
        //  discuss at: http://locutus.io/php/basename/
        // original by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Ash Searle (http://hexmen.com/blog/)
        // improved by: Lincoln Ramsay
        // improved by: djmix
        // improved by: Dmitry Gorelenkov
        var b = path;
        var lastChar = b.charAt(b.length - 1);

        if (lastChar === '/' || lastChar === '\\') {
            b = b.slice(0, -1)
        }

        b = b.replace(/^.*[\/\\]/g, '');

        if (typeof suffix === 'string' && b.substr(b.length - suffix.length) === suffix) {
            b = b.substr(0, b.length - suffix.length)
        }

        return b
    };
    /**
     *
     * @param path {string}
     * @param options
     * @memberOf module:xide/utils/StringUtils
     * @returns {object}
     *
     * @example
     *
     //   example 1: pathinfo('/www/htdocs/index.html', 1)
     //   returns 1: '/www/htdocs'
     //   example 2: pathinfo('/www/htdocs/index.html', 'PATHINFO_BASENAME')
     //   returns 2: 'index.html'
     //   example 3: pathinfo('/www/htdocs/index.html', 'PATHINFO_EXTENSION')
     //   returns 3: 'html'
     //   example 4: pathinfo('/www/htdocs/index.html', 'PATHINFO_FILENAME')
     //   returns 4: 'index'
     //   example 5: pathinfo('/www/htdocs/index.html', 2 | 4)
     //   returns 5: {basename: 'index.html', extension: 'html'}
     //   example 6: pathinfo('/www/htdocs/index.html', 'PATHINFO_ALL')
     //   returns 6: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     //   example 7: pathinfo('/www/htdocs/index.html')
     //   returns 7: {dirname: '/www/htdocs', basename: 'index.html', extension: 'html', filename: 'index'}
     */
    utils.pathinfo = function (path, options) {
        //  discuss at: http://locutus.io/php/pathinfo/
        // original by: Nate
        //  revised by: Kevin van Zonneveld (http://kvz.io)
        // improved by: Brett Zamir (http://brett-zamir.me)
        // improved by: Dmitry Gorelenkov
        //    input by: Timo
        //      note 1: Inspired by actual PHP source: php5-5.2.6/ext/standard/string.c line #1559
        //      note 1: The way the bitwise arguments are handled allows for greater flexibility
        //      note 1: & compatability. We might even standardize this
        //      note 1: code and use a similar approach for
        //      note 1: other bitwise PHP functions
        //      note 1: Locutus tries very hard to stay away from a core.js
        //      note 1: file with global dependencies, because we like
        //      note 1: that you can just take a couple of functions and be on your way.
        //      note 1: But by way we implemented this function,
        //      note 1: if you want you can still declare the PATHINFO_*
        //      note 1: yourself, and then you can use:
        //      note 1: pathinfo('/www/index.html', PATHINFO_BASENAME | PATHINFO_EXTENSION);
        //      note 1: which makes it fully compliant with PHP syntax.


        var basename = utils.basename;
        var opt = '';
        var realOpt = '';
        var optName = '';
        var optTemp = 0;
        var tmpArr = {};
        var cnt = 0;
        var i = 0;
        var haveBasename = false;
        var haveExtension = false;
        var haveFilename = false;

        // Input defaulting & sanitation
        if (!path) {
            return false
        }
        if (!options) {
            options = 'PATHINFO_ALL'
        }

        // Initialize binary arguments. Both the string & integer (constant) input is
        // allowed
        var OPTS = {
            'PATHINFO_DIRNAME': 1,
            'PATHINFO_BASENAME': 2,
            'PATHINFO_EXTENSION': 4,
            'PATHINFO_FILENAME': 8,
            'PATHINFO_ALL': 0
        };
        // PATHINFO_ALL sums up all previously defined PATHINFOs (could just pre-calculate)
        for (optName in OPTS) {
            if (OPTS.hasOwnProperty(optName)) {
                OPTS.PATHINFO_ALL = OPTS.PATHINFO_ALL | OPTS[optName]
            }
        }
        if (typeof options !== 'number') {
            // Allow for a single string or an array of string flags
            options = [].concat(options);
            for (i = 0; i < options.length; i++) {
                // Resolve string input to bitwise e.g. 'PATHINFO_EXTENSION' becomes 4
                if (OPTS[options[i]]) {
                    optTemp = optTemp | OPTS[options[i]]
                }
            }
            options = optTemp
        }

        // Internal Functions
        var _getExt = function (path) {
            var str = path + '';
            var dotP = str.lastIndexOf('.') + 1;
            return !dotP ? false : dotP !== str.length ? str.substr(dotP) : ''
        };

        // Gather path infos
        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_DIRNAME) {
            var dirName = path
                .replace(/\\/g, '/')
                .replace(/\/[^\/]*\/?$/, ''); // dirname
            tmpArr.dirname = dirName === path ? '.' : dirName
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_BASENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            tmpArr.basename = haveBasename
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_EXTENSION) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveExtension !== false) {
                tmpArr.extension = haveExtension
            }
        }

        //noinspection JSBitwiseOperatorUsage,JSBitwiseOperatorUsage
        if (options & OPTS.PATHINFO_FILENAME) {
            if (haveBasename === false) {
                haveBasename = basename(path)
            }
            if (haveExtension === false) {
                haveExtension = _getExt(haveBasename)
            }
            if (haveFilename === false) {
                haveFilename = haveBasename.slice(0, haveBasename.length - (haveExtension
                            ? haveExtension.length + 1
                            : haveExtension === false
                            ? 0
                            : 1
                    )
                )
            }

            tmpArr.filename = haveFilename
        }

        // If array contains only 1 element: return string
        cnt = 0;
        for (opt in tmpArr) {
            if (tmpArr.hasOwnProperty(opt)) {
                cnt++;
                realOpt = opt
            }
        }
        if (cnt === 1) {
            return tmpArr[realOpt]
        }

        // Return full-blown array
        return tmpArr
    };

    /**
     *
     * @param input {string}
     * @param allowed {string}
     * @example
     //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>');
     //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
     //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>');
     //   returns 2: '<p>Kevin van Zonneveld</p>'
     //   example 3: strip_tags("<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>", "<a>");
     //   returns 3: "<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>"
     //   example 4: strip_tags('1 < 5 5 > 1');
     //   returns 4: '1 < 5 5 > 1'
     //   example 5: strip_tags('1 <br/> 1');
     //   returns 5: '1  1'
     //   example 6: strip_tags('1 <br/> 1', '<br>');
     //   returns 6: '1 <br/> 1'
     //   example 7: strip_tags('1 <br/> 1', '<br><br/>');
     //   returns 7: '1 <br/> 1'
     * @returns {string}
     */
    utils.strip_tags = function (input, allowed) {
        //  discuss at: http://phpjs.org/functions/strip_tags/
        allowed = (((allowed || '') + '')
            .toLowerCase()
            .match(/<[a-z][a-z0-9]*>/g) || [])
            .join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,
            commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
        return input.replace(commentsAndPhpTags, '')
            .replace(tags, function ($0, $1) {
                return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
            });
    };
    return utils;
});
;
define('xaction/types',[
    'xide/types',
    'dojo/_base/lang'
],function(types,lang){

    lang.mixin(types.EVENTS,{
        ON_ACTION_CHANGE_CONTEXT: 'onChangeActionContext',
        ON_ACTION_CONTEXT_CHANGED: 'onActionContextChanged',
        REGISTER_ACTION: 'registerAction',
        SET_ITEM_ACTIONS: 'onSetItemsActions',
        ON_CLIPBOARD_COPY: 'onClipboardCopy',
        ON_CLIPBOARD_PASTE: 'onClipboardPaste',
        ON_CLIPBOARD_CUT: 'onClipboardCut',
        ON_RENDER_ACTIONS: 'onRenderActions',
        ON_DID_ACTION:'onDidAction',
        ON_AFTER_ACTION:'onAfterAction'
    });

    /**
     * Enumeration to define an Action command
     * @enum {string} module:xide/types/Action
     * @memberOf module:xide/types
     */
    types.ACTION =
    {
        LAYOUT: 'View/Layout',
        COLUMNS: 'View/Columns',
        SELECTION: 'File/Select',
        CLIPBOARD: 'Edit/Clipboard',
        UNDO: 'Edit/Undo',
        REDO: 'Edit/Redo',
        CLIPBOARD_COPY: 'Edit/Clipboard/Copy',
        CLIPBOARD_PASTE: 'Edit/Clipboard/Paste',
        CLIPBOARD_CUT: 'Edit/Clipboard/Cut',
        COPY: 'File/Copy',
        MOVE: 'File/Move',
        RENAME: 'File/Rename',
        DELETE: 'File/Delete',
        OPEN: 'File/Open',
        EDIT: 'File/Edit',
        SAVE: 'File/Save',
        SEARCH: 'File/Search',
        TOOLBAR: 'View/Show/Toolbar',
        STATUSBAR: 'View/Show/Statusbar',
        BREADCRUMB: 'View/Show/Breadcrumb',
        HEADER: 'View/Show/Header',
        DOWNLOAD: 'File/Download',
        DOWNLOAD_TO: 'File/downloadTo',
        INFO: 'File/Info',
        COMPRESS: 'File/Compress',
        RELOAD: 'File/Reload',
        UPLOAD: 'File/Upload',
        PREVIEW: 'File/Preview',
        OPEN_IN: 'File/Open In',
        INSERT_IMAGE: 'insertImage',
        COPY_PASTE: 'copypaste',
        DND: 'dnd',
        OPTIONS: 'options',
        NEW_FILE: 'File/New/New File',
        NEW_DIRECTORY: 'File/New/New Folder',
        GET_CONTENT: 'get',
        SET_CONTENT: 'set',
        FIND: 'File/Find',
        CUSTOM: 'custom',
        PERMA_LINK: 'permaLink',
        ADD_MOUNT: 'ADD_MOUNT',
        REMOVE_MOUNT: 'REMOVE_MOUNT',
        EDIT_MOUNT: 'EDIT_MOUNT',
        PERSPECTIVE: 'PERSPECTIVE',
        RUN: 'File/Run',
        GO_UP: 'Navigation/Go Up',
        STOP: 'File/Stop',
        CLOSE: 'View/Close',
        FULLSCREEN: 'View/Fullscreen',
        OPEN_IN_TAB: 'File/OpenInNewTab',
        SOURCE: 'Navigation/Source',
        RIBBON: 'View/Show/Ribbon',
        MAIN_MENU: 'View/Show/MainMenu',
        NAVIGATION: 'View/Show/Navigation',
        BASH_CONSOLE: 'File/Console/Bash',
        JS_CONSOLE: 'File/Console/JS',
        PHP_CONSOLE: 'File/Console/PHP',
        CONSOLE: 'File/Console/PHP',
        SIZE_STATS: 'View/Show/SizeStats',
        WELCOME: 'Window/Welcome',
        CONTEXT_MENU:'File/ContextMenu'
    };

    types.ACTION_TYPE = {
        MULTI_TOGGLE: 'multiToggle',
        SINGLE_TOGGLE: 'singleToggle'
    };

    types.ACTION_ICON =
    {
        CLIPBOARD_COPY: 'fa-copy',
        CLIPBOARD_PASTE: 'fa-paste',
        UPLOAD: 'fa-upload',
        RENAME: 'el-icon-edit',
        DELETE: 'text-danger fa-remove',
        RELOAD: 'fa-refresh',
        EDIT: 'fa-pencil',
        SAVE: 'fa-floppy-o',
        SEARCH: 'fa-search',
        NEW_DIRECTORY: 'fa-magic',
        NEW_FILE: 'fa-magic',
        RUN: 'text-success el-icon-play',
        COMPRESS: 'fa-file-archive-o',
        EXTRACT: 'fa-folder-open',
        DOWNLOAD: 'fa-download',
        GO_UP: 'fa-level-up',
        TOOLBAR: 'fa-bars',
        STATUSBAR: 'fa-terminal',
        PREVIEW: 'fa-eye',
        MAXIMIZE: 'fa-arrows-alt',
        UNDO: 'fa-undo',
        REDO: 'fa-repeat'

    };

    return types;
});;
define('xide/utils',[
    "dcl/dcl"
], function (dcl) {
    return dcl(null, {
        declaredClass:"xide.utils"
    });
});;
/** @module xide/types
 *  @description All the package's constants and enums in C style structures.
 */
define('xide/types/Types',[
    'dojo/_base/lang',
    'xide/types',
    'dojo/_base/json',
    'dojo/_base/kernel',
    'xide/utils'
], function (lang, types, json, dojo,utils) {
    /**
     * @TODO:
     * - apply xide/registry for types
     * - move mime handling to xfile
     * - remove ui types
     * - remove all other things which are part of ui or server only
     */
    /**
     * Custom CI Types, see ECITYPE enumeration. Each enum is mapped to a widget.
     */
    if (types['customTypes'] == null) {
        types['customTypes'] = {};
    }
    /**
     * ECTYPE_ENUM is mapped to and label-value option array
     */
    if (types['customEnumerations'] == null) {
        types['customEnumerations'] = {};
    }
    /**
     * The actual mapping of custom types to widget proto classes
     */
    if (types['widgetMappings'] == null) {
        types['widgetMappings'] = {};
    }
    /**
     * Mixes in new mime icons per ECITYPE & file extensions. Rendered by FontAwesome
     */
    if (types['customMimeIcons'] == null) {
        types['customMimeIcons'] = {};
    }
    /**
     * CI Render callbacks
     */
    if (types['CICallbacks'] == null) {
        types['CICallbacks'] = {};
    }
    /**
     * Public ECI_TYPE registry getter
     * @param type
     * @returns {*}
     */
    types.resolveType = function (type) {
        if (types['customTypes'][type]) {
            return types['customTypes'][type];
        }
        return null;
    };
    /**
     * Public ECI_TYPE registry setter
     * @param type
     * @param map
     */
    types.registerType = function (type, map) {
        types['customTypes'][type] = map;
    };
    /**
     * Public widget-type registry setter
     * @param type
     * @param map
     */
    types.registerWidgetMapping = function (type, map) {
        types['widgetMappings'][type] = map;
    };
    /**
     * Public custom enum registry setter
     * @param type
     * @param map
     */
    types.registerEnumeration = function (type, map) {
        types['customEnumerations'][type] = map;
    };
    /**
     * Public custom enumeration registry getter
     * @param type
     */
    types.resolveEnumeration = function (type) {
        if (types['customEnumerations'][type]) {
            return types['customEnumerations'][type];
        }
        return null;
    };
    /**
     * Public type-widget mapping registry setter
     * @param type
     */
    types.resolveWidgetMapping = function (type) {
        if (types['widgetMappings'][type]) {
            return types['widgetMappings'][type];
        }
        return null;
    };

    types.registerCICallbacks = function (type,callbacks) {
        if (!types['CICallbacks'][type]) {
            types['CICallbacks'][type] = {}
        }
        utils.mixin(types['CICallbacks'][type],callbacks);
        return null;
    };
    types.getCICallbacks = function (type) {
        if (types['CICallbacks'][type]){
            return types['CICallbacks'][type];
        }
        return null;
    };

    types.GRID_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    
    types.VIEW_FEATURE = {
        KEYBOARD_NAVIGATION: 'KEYBOARD_NAVIGATION',
        KEYBOARD_SELECT: 'KEYBOARD_SELECT',
        SELECTION: 'SELECTION',
        ACTIONS: 'ACTIONS',
        CONTEXT_MENU: 'CONTEXT_MENU'
    };
    
    types.KEYBOARD_PROFILE = {
        DEFAULT: {
            prevent_default: true,
            prevent_repeat: false
        },
        PASS_THROUGH: {
            prevent_default: false,
            prevent_repeat: false
        },
        SEQUENCE: {
            prevent_default: true,
            is_sequence: true,
            prevent_repeat: true
        }
    };
    /////////////////////////////////////////////////////////////////////////////
    //
    // CORE TYPES
    //
    /////////////////////////////////////////////////////////////////////////////
    /**
     * A 'Configurable Information's ("CI") processing state during post or pre-processing.
     *
     * @enum {int} module:xide/types/CI_STATE
     * @memberOf module:xide/types
     */
    types.CI_STATE = {
        /**
         * Nothing done, could also mean there is nothing to do all
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * In pending state. At that time the compiler has accepted additional work and ci flag processing is queued
         * but not scheduled yet.
         * @constant
         * @type int
         */
        PENDING: 0x00000001,
        /**
         * The processing state.
         * @constant
         * @type int
         */
        PROCESSING: 0x00000002,
        /**
         * The CI has been processed but it failed.
         * @constant
         * @type int
         */
        FAILED: 0x00000004,
        /**
         * The CI was successfully processed.
         * @constant
         * @type int
         */
        SUCCESSED: 0x00000008,
        /**
         * The CI has been processed.
         * @constant
         * @type int
         */
        PROCESSED: 0x00000010,
        /**
         * The CI left the post/pre processor entirly but has not been accepted by the originating source.
         * This state can happen when the source became invalid and so its sort of orphan.
         * @constant
         * @type int
         */
        DEQUEUED: 0x00000020,
        /**
         * The CI fully resolved and no references except by the source are around.
         * @constant
         * @type int
         */
        SOLVED: 0x00000040,
        /**
         * Flag to mark the core's end of this bitmask, from here its user land
         * @constant
         * @type int
         */
        END: 0x00000080
    };
    /**
     * A 'Configurable Information's ("CI") type flags for post and pre-processing a value.
     * @enum {string} CIFLAGS
     * @global
     * @memberOf module:xide/types
     */
    types.CIFLAG = {
        /**
         * Instruct for no additional extra processing
         * @constant
         * @type int
         */
        NONE: 0x00000000,
        /**
         * Will instruct the pre/post processor to base-64 decode or encode
         * @constant
         * @type int
         */
        BASE_64: 0x00000001,
        /**
         * Post/Pre process the value with a user function
         * @constant
         * @type int
         */
        USE_FUNCTION: 0x00000002,
        /**
         * Replace variables with local scope's variables during the post/pre process
         * @constant
         * @type int
         */
        REPLACE_VARIABLES: 0x00000004,
        /**
         * Replace variables with local scope's variables during the post/pre process but evaluate the whole string
         * as Javascript
         * @constant
         * @type int
         */
        REPLACE_VARIABLES_EVALUATED: 0x00000008,
        /**
         * Will instruct the pre/post processor to escpape evaluated or replaced variables or expressions
         * @constant
         * @type int
         */
        ESCAPE: 0x00000010,
        /**
         * Will instruct the pre/post processor to replace block calls with oridinary vanilla script
         * @constant
         * @type int
         */
        REPLACE_BLOCK_CALLS: 0x00000020,
        /**
         * Will instruct the pre/post processor to remove variable delimitters/placeholders from the final string
         * @constant
         * @type int
         */
        REMOVE_DELIMTTERS: 0x00000040,
        /**
         * Will instruct the pre/post processor to remove   "[" ,"]" , "(" , ")" , "{", "}" , "*" , "+" , "."
         * @constant
         * @type int
         */
        ESCAPE_SPECIAL_CHARS: 0x00000080,
        /**
         * Will instruct the pre/post processor to use regular expressions over string substitution
         * @constant
         * @type int
         */
        USE_REGEX: 0x00000100,
        /**
         * Will instruct the pre/post processor to use Filtrex (custom bison parser, needs xexpression) over string substitution
         * @constant
         * @type int
         */
        USE_FILTREX: 0x00000200,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        CASCADE: 0x00000400,
        /**
         * Cascade entry. There are cases where #USE_FUNCTION is not enough or we'd like to avoid further type checking.
         * @constant
         * @type int
         */
        EXPRESSION: 0x00000800,
        /**
         * Dont parse anything
         * @constant
         * @type int
         */
        DONT_PARSE: 0x000001000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        TO_HEX: 0x000002000,
        /**
         * Convert to hex
         * @constant
         * @type int
         */
        REPLACE_HEX: 0x000004000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        WAIT: 0x000008000,
        /**
         * Wait for finish
         * @constant
         * @type int
         */
        DONT_ESCAPE: 0x000010000,
        /**
         * Flag to mark the maximum core bit mask, after here its user land
         * @constant
         * @type int
         */
        END: 0x000020000
    };
    /**
     * A CI's default post-pre processing order.
     *
     * @enum {string} module:xide/types/CI_ORDER
     * @memberOf module:xide/types
     */
    types.CI_CORDER = {};

    /**
     * A 'Configurable Information's ("CI") type information. Every CI has this information. You can
     * re-composite new types with ECIType.STRUCTURE. However all 'beans' (rich objects) in the system all displayed through a set of CIs,
     * also called the CIS (Configurable Information Set). There are many types already :
     *
     * Each ECIType has mapped widgets, BOOL : checkbox, STRING: Text-Areay and so forth.
     *
     * @enum {string} module:xide/types/ECIType
     * @memberOf module:xide/types
     */
    types.ECIType = {
        /**
         * @const
         * @type { int}
         */
        BOOL: 0,
        /**
         * @const
         * @type { int}
         */
        BOX: 1,
        /**
         * @const
         * @type { int}
         */
        COLOUR: 2,
        /**
         * @const
         * @type { int}
         */
        ENUMERATION: 3,
        /**
         * @const
         * @type { int}
         */
        FILE: 4,
        /**
         * @const
         * @type { int}
         */
        FLAGS: 5,
        /**
         * @const
         * @type { int}
         */
        FLOAT: 6,
        /**
         * @const
         * @type { int}
         */
        INTEGER: 7,
        /**
         * @const
         * @type { int}
         */
        MATRIX: 8,
        /**
         * @const
         * @type { int}
         */
        OBJECT: 9,
        /**
         * @const
         * @type { int}
         */
        REFERENCE: 10,
        /**
         * @const
         * @type { int}
         */
        QUATERNION: 11,
        /**
         * @const
         * @type { int}
         */
        RECTANGLE: 12,
        /**
         * @const
         * @type { int}
         */
        STRING: 13,
        /**
         * @const
         * @type { int}
         */
        VECTOR: 14,
        /**
         * @const
         * @type { int}
         */
        VECTOR2D: 15,
        /**
         * @const
         * @type { int}
         */
        VECTOR4D: 16,
        /**
         * @const
         * @type { int}
         */
        ICON: 17,
        /**
         * @const
         * @type { int}
         */
        IMAGE: 18,
        /**
         * @const
         * @type { int}
         */
        BANNER: 19,
        /**
         * @const
         * @type { int}
         */
        LOGO: 20,
        /**
         * @const
         * @type { int}
         */
        STRUCTURE: 21,
        /**
         * @const
         * @type { int}
         */
        BANNER2: 22,
        /**
         * @const
         * @type { int}
         */
        ICON_SET: 23,
        /**
         * @const
         * @type { int}
         */
        SCRIPT: 24,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION: 25,
        /**
         * @const
         * @type { int}
         */
        RICHTEXT: 26,
        /**
         * @const
         * @type { int}
         */
        ARGUMENT: 27,
        /**
         * @const
         * @type { int}
         */
        JSON_DATA: 28,
        /**
         * @const
         * @type { int}
         */
        EXPRESSION_EDITOR: 29,
        /**
         * @const
         * @type { int}
         */
        WIDGET_REFERENCE: 30,
        /**
         * @const
         * @type { int}
         */
        DOM_PROPERTIES: 31,

        /**
         * @const
         * @type { int}
         */
        BLOCK_REFERENCE: 32,

        /**
         * @const
         * @type { int}
         */
        BLOCK_SETTINGS: 33,
        /**
         * @const
         * @type { int}
         */
        FILE_EDITOR: 34,
        /**
         * @const
         * @type { int}
         */
        END: 35,
        /**
         * @const
         * @type { int}
         */
        UNKNOWN: -1
    };
    /**
     * Dummy type for jsdoc
     * @typedef {Object} module:xide/types/ConfigurableInformation
     * @property {String} id
     * @property {String} name
     * @property {module:xide/types/ECIType} type
     */
    /**
     * Stub for registered bean types. This value is needed to let the UI switch between configurations per such type.
     * At the very root is the bean action context which may include more contexts.
     * @enum {string} module:xide/types/ITEM_TYPE
     * @memberOf module:xide/types
     */
    types.ITEM_TYPE = {
        /**
         * Bean type 'file' is handled by the xfile package
         * @constant
         */
        FILE: 'BTFILE',         //file object
        /**
         * Bean type 'widget' is handled by the xide/ve and davinci package
         * @constant
         */
        WIDGET: 'WIDGET',       //ui designer
        /**
         * Bean type 'block' is handled by the xblox package
         * @constant
         */
        BLOCK: 'BLOCK',         //xblox
        /**
         * Bean type 'text' is used for text editors
         * @constant
         */
        TEXT: 'TEXT',           //xace
        /**
         * Bean type 'xexpression' is used for user expressions
         * @constant
         */
        EXPRESSION: 'EXPRESSION'       //xexpression
    };

    /**
     * Expression Parser is a map of currently existing parsers
     * and might be extended by additional modules. Thus, it acts as registry
     * and is here as stub.
     *
     * @enum module:xide/types/EXPRESSION_PARSER
     * @memberOf module:xide/types
     */
    if (!types.EXPRESSION_PARSER) {
        types.EXPRESSION_PARSER = {};
    }
    /**
     * Component names stub, might be extended by sub-classing applications
     * @constant xide.types.COMPONENT_NAMES
     */
    types.COMPONENT_NAMES = {
        XIDEVE: 'xideve',
        XNODE: 'xnode',
        XBLOX: 'xblox',
        XFILE: 'xfile',
        XACE: 'xace',
        XEXPRESSION: 'xexpression',
        XCONSOLE: 'xconsole',
        XTRACK: 'xtrack'
    };

    /**
     * WIDGET_REFERENCE_MODE enumerates possible modes to resolve a string expression
     * into instances. There are a few CI based widgets subclassed from xide/widgets/Referenced.
     * The reference structure consist out of this mode and that expression.
     *
     * @constant {Array.<module:xide/types~WidgetReferenceMode>}
     *     module:xide/types~WIDGET_REFERENCE_MODE
     */
    types.WIDGET_REFERENCE_MODE = {
        BY_ID: 'byid',
        BY_CLASS: 'byclass',
        BY_CSS: 'bycss',
        BY_EXPRESSION: 'expression'
    };
    /**
     * Possible split modes for rich editors with preview or live coding views.
     *
     * @constant {Array.<module:xide/types~ViewSplitMode>}
     *     module:xide/types~VIEW_SPLIT_MODE
     */
    types.VIEW_SPLIT_MODE = {
        DESIGN: 1,
        SOURCE: 2,
        SPLIT_VERTICAL: 6,
        SPLIT_HORIZONTAL: 7
    };
    /**
     * All client resources are through variables on the server side. Here the minimum variables for an xjs application.
     *
     * @constant {Array.<module:xide/types~RESOURCE_VARIABLES>}
     *     module:xide/types~RESOURCE_VARIABLES
     */
    types.RESOURCE_VARIABLES = {
        ACE: 'ACE',
        APP_URL: 'APP_URL',
        SITE_URL: 'SITE_URL'
    };
    /**
     * Events of xide.*
     * @enum {string} module:xide/types/EVENTS
     * @memberOf module:xide/types
     * @extends xide/types
     */
    types.EVENTS = {
        /**
         * generic
         */
        ERROR: 'onError',//xhr
        STATUS: 'onStatus',//xhr
        ON_CREATED_MANAGER: 'onCreatedManager',//context

        /**
         * item events, to be renoved
         */
        ON_ITEM_SELECTED: 'onItemSelected',
        ON_ITEM_REMOVED: 'onItemRemoved',
        ON_ITEM_CLOSED: 'onItemClosed',
        ON_ITEM_ADDED: 'onItemAdded',
        ON_ITEM_MODIFIED: 'onItemModified',
        ON_NODE_SERVICE_STORE_READY: 'onNodeServiceStoreReady',
        /**
         * old, to be removd
         */
        ON_FILE_STORE_READY: 'onFileStoreReady',
        ON_CONTEXT_MENU_OPEN: 'onContextMenuOpen',
        /**
         * CI events
         */
        ON_CI_UPDATE: 'onCIUpdate',

        /**
         * widgets
         */
        ON_WIDGET_READY: 'onWidgetReady',
        ON_CREATED_WIDGET: 'onWidgetCreated',
        RESIZE: 'onResize',
        /**
         * Event to notify classes about a reloaded module
         * @constant
         * @type string
         */
        ON_MODULE_RELOADED: 'onModuleReloaded',
        ON_MODULE_UPDATED: 'onModuleUpdated',


        ON_DID_OPEN_ITEM: 'onDidOpenItem',//remove
        ON_DID_RENDER_COLLECTION: 'onDidRenderCollection',//move

        ON_PLUGIN_LOADED: 'onPluginLoaded',
        ON_PLUGIN_READY: 'onPluginReady',
        ALL_PLUGINS_READY: 'onAllPluginsReady',

        /**
         * editors
         */
        ON_CREATE_EDITOR_BEGIN: 'onCreateEditorBegin',//move to xedit
        ON_CREATE_EDITOR_END: 'onCreateEditorEnd',//move to xedit
        REGISTER_EDITOR: 'registerEditor',//move to xedit
        ON_EXPRESSION_EDITOR_ADD_FUNCTIONS: 'onExpressionEditorAddFunctions',//move to xedit
        ON_ACE_READY: 'onACEReady',//remove

        /**
         * Files
         */
        ON_UNSAVED_CONTENT: 'onUnSavedContent',
        ON_FILE_CHANGED: 'fileChanged',
        ON_FILE_DELETED: 'fileDeleted',
        IMAGE_LOADED: 'imageLoaded',
        IMAGE_ERROR: 'imageError',
        UPLOAD_BEGIN: 'uploadBegin',
        UPLOAD_PROGRESS: 'uploadProgress',
        UPLOAD_FINISH: 'uploadFinish',
        UPLOAD_FAILED: 'uploadFailed',
        ON_FILE_CONTENT_CHANGED: 'onFileContentChanged',
        ON_COPY_BEGIN: 'onCopyBegin',
        ON_COPY_END: 'onCopyEnd',
        ON_DELETE_BEGIN: 'onDeleteBegin',
        ON_DELETE_END: 'onDeleteEnd',
        ON_MOVE_BEGIN: 'onMoveBegin',
        ON_MOVE_END: 'onMoveEnd',
        ON_CHANGED_CONTENT: 'onChangedContent',
        ON_COMPRESS_BEGIN: 'onCompressBegin',
        ON_COMPRESS_END: 'onCompressEnd',



        ON_COMPONENT_READY: 'onComponentReady',
        ON_ALL_COMPONENTS_LOADED: 'onAllComponentsLoaded',
        ON_APP_READY: 'onAppReady',
        /**
         * Store
         */
        ON_CREATE_STORE: 'onCreateStore',
        ON_STORE_CREATED: 'onStoreCreated',
        ON_STORE_CHANGED: 'onStoreChanged',
        ON_STATUS_MESSAGE: 'onStatusMessage',
        /**
         * layout
         */
        SAVE_LAYOUT: 'layoutSave',
        RESTORE_LAYOUT: 'layoutRestore',
        /**
         * views, panels and 'main view'
         */
        ON_SHOW_PANEL: 'onShowPanel',
        ON_PANEL_CLOSED: 'onPanelClosed',
        ON_PANEL_CREATED: 'onPanelCreated',

        ON_MAIN_VIEW_READY: 'onMainViewReady',
        ON_MAIN_MENU_READY: 'onMainMenuReady',
        ON_MAIN_MENU_OPEN: 'onMainMenuOpen',
        ON_VIEW_REMOVED: 'onViewRemoved',
        ON_VIEW_SHOW: 'onViewShow',
        ON_VIEW_HIDE: 'onViewHide',
        ON_VIEW_ADDED: 'onViewAdded',
        ON_OPEN_VIEW: 'onOpenView',
        ON_VIEW_MAXIMIZE_START: 'onViewMaximizeStart',
        ON_VIEW_MAXIMIZE_END: 'onViewMaximizeEnd',
        ON_CONTAINER_ADDED: 'onContainerAdded',
        ON_CONTAINER_REMOVED: 'onContainerRemoved',
        ON_REMOVE_CONTAINER: 'onRemoveContainer',
        ON_CONTAINER_REPLACED: 'onContainerReplaced',
        ON_CONTAINER_SPLIT: 'onContainerSplit',
        ON_RENDER_WELCOME_GRID_GROUP:'onRenderWelcomeGridGroup',

        ON_DND_SOURCE_OVER:'/dnd/source/over',
        ON_DND_START:'/dnd/start',
        ON_DND_DROP_BEFORE:'/dnd/drop/before',
        ON_DND_DROP:'/dnd/drop',
        ON_DND_CANCEL:'/dnd/cancel'
    };
    /**
     * To be moved
     * @type {{SIZE_NORMAL: string, SIZE_SMALL: string, SIZE_WIDE: string, SIZE_LARGE: string}}
     */
    types.DIALOG_SIZE = {
        SIZE_NORMAL: 'size-normal',
        SIZE_SMALL: 'size-small',
        SIZE_WIDE: 'size-wide',    // size-wide is equal to modal-lg
        SIZE_LARGE: 'size-large'
    };

    /**
     * To be moved
     * @type {{DEFAULT: string, INFO: string, PRIMARY: string, SUCCESS: string, WARNING: string, DANGER: string}}
     */
    types.DIALOG_TYPE = {
        DEFAULT: 'type-default',
        INFO: 'type-info',
        PRIMARY: 'type-primary',
        SUCCESS: 'type-success',
        WARNING: 'type-warning',
        DANGER: 'type-danger'
    };
    /**
     * @TODO: remove, defined in xideve
     */
    lang.mixin(types, {
        LAYOUT_RIGHT_CENTER_BOTTOM: 'LAYOUT_RIGHT_CENTER_BOTTOM',
        LAYOUT_CENTER_BOTTOM: 'LAYOUT_CENTER_BOTTOM',
        LAYOUT_CENTER_RIGHT: 'LAYOUT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT: 'LAYOUT_LEFT_CENTER_RIGHT',
        LAYOUT_LEFT_CENTER_RIGHT_BOTTOM: 'LAYOUT_LEFT_CENTER_RIGHT_BOTTOM'
    });

    /**
     * Hard Dojo override to catch malformed JSON.
     * @param js
     * @returns {*}
     */
    dojo.fromJson = function (js, debug) {
        var res = null;
        var didFail = false;
        debug = true;
        try {
            res = eval("(" + js + ")");
        } catch (e) {
            didFail = true;
        }

        if (didFail) {
            var js2 = js.substring(js.indexOf('{'), js.lastIndexOf('}') + 1);
            try {
                js2 && (res = eval("(" + js2 + ")"));
            } catch (e) {
                debug !== false && console.error('error in json parsing! ' + js);
                if (js.indexOf('error') !== -1) {
                    return {
                        "jsonrpc": "2.0",
                        "result": {
                            "error": {
                                "code": 1,
                                "message": js,
                                "data": null
                            }
                        }, "id": 0
                    };
                }
                throw new Error(js);
            }
        }
        return res;
    };
    return types;
});;
define('xide/types',[
    "dcl/dcl"
],function(dcl){
    var mod = new dcl(null,{
        declaredClass:"xide/types"
    });
    mod.test = 22;
    return mod;
});

;
define('dstore/Filter',['dojo/_base/declare'], function (declare) {
	// a Filter builder
	function filterCreator(type) {
		// constructs a new filter based on type, used to create each comparison method
		return function newFilter() {
			var Filter = this.constructor;
			var filter = new Filter();
			filter.type = type;
			// ensure args is array so we can concat, slice, unshift
			filter.args = Array.prototype.slice.call(arguments);
			if (this.type) {
				// we are chaining, so combine with an and operator
				return filterCreator('and').call(Filter.prototype, this, filter);
			}
			return filter;
		};
	}
	function logicalOperatorCreator(type) {
		// constructs a new logical operator 'filter', used to create each logical operation method
		return function newLogicalOperator() {
			var Filter = this.constructor;
			var argsArray = [];
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				argsArray.push(arg instanceof Filter ? arg : new Filter(arg));
			}
			var filter = new Filter();
			filter.type = type;
			filter.args = argsArray;
			if (this.type === type) {
				// chaining, same type
				// combine arguments
				filter.args = this.args.concat(argsArray);
			} else if (this.type) {
				// chaining, different type
				// add this filter to start of arguments
				argsArray.unshift(this);
			} else if (argsArray.length === 1) {
				// not chaining and only one argument
				// returned filter is the same as the single argument
				filter.type = argsArray[0].type;
				filter.args = argsArray[0].args.slice();
			}
			return filter;
		};
	}
	var Filter = declare(null, {
		constructor: function (filterArg) {
			var argType = typeof filterArg;
			switch (argType) {
				case 'object':
					var filter = this;
					// construct a filter based on the query object
					for (var key in filterArg){
						var value = filterArg[key];
						if (value instanceof this.constructor) {
							// fully construct the filter from the single arg
							filter = filter[value.type](key, value.args[0]);
						} else if (value && value.test) {
							// support regex
							filter = filter.match(key, value);
						} else {
							filter = filter.eq(key, value);
						}
					}
					this.type = filter.type;
					this.args = filter.args;
					break;
				case 'function': case 'string':
					// allow string and function args as well
					this.type = argType;
					this.args = [filterArg];
			}
		},
		// define our operators
		and: logicalOperatorCreator('and'),
		or: logicalOperatorCreator('or'),
		eq: filterCreator('eq'),
		ne: filterCreator('ne'),
		lt: filterCreator('lt'),
		lte: filterCreator('lte'),
		gt: filterCreator('gt'),
		gte: filterCreator('gte'),
		contains: filterCreator('contains'),
		'in': filterCreator('in'),
		match: filterCreator('match')
	});
	Filter.filterCreator = filterCreator;
	Filter.logicalOperatorCreator = logicalOperatorCreator;
	return Filter;
});;
define('dstore/mainr',[
    "dstore/Memory",
    "dstore/Promised",
    "dstore/QueryMethod",
    "dstore/QueryResults",
    "dstore/SimpleQuery",
    "dstore/Store",
    "dstore/Tree",
    "dstore/Filter",
    "dstore/Trackable"
    //"dstore/legacy/DstoreAdapter"
], function () {

});;
(function(factory){
	if(typeof define != "undefined"){
		define('dcl/mini',[], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		dcl = factory();
	}
})(function(){

	"use strict";

	var counter = 0, cname = "constructor", pname = "prototype", empty = {}, mix;

	var registry = {};

	function dcl(superClass, props){
		var bases = [0], proto, base, ctor, meta, connectionMap,
			output, vector, superClasses, i, j = 0, n;

		if(superClass){
			if(superClass instanceof Array){
				// mixins: C3 MRO
				connectionMap = {};
				superClasses = superClass.slice(0).reverse();
				for(i = superClasses.length - 1; i >= 0; --i){
					base = superClasses[i];
					// pre-process a base
					// 1) add a unique id
					base._uniqueId = base._uniqueId || counter++;
					// 2) build a connection map and the base list
					if((proto = base._meta)){   // intentional assignment
						for(vector = proto.bases, j = vector.length - 1; j > 0; --j){
							n = vector[j]._uniqueId;
							connectionMap[n] = (connectionMap[n] || 0) + 1;
						}
						superClasses[i] = vector.slice(0);
					}else{
						superClasses[i] = [base];
					}
				}
				// build output
				output = {};
				c: while(superClasses.length){
					for(i = 0; i < superClasses.length; ++i){
						vector = superClasses[i];
						base = vector[0];
						n = base._uniqueId;
						if(!connectionMap[n]){
							if(!output[n]){
								bases.push(base);
								output[n] = 1;
							}
							vector.shift();
							if(vector.length){
								--connectionMap[vector[0]._uniqueId];
							}else{
								superClasses.splice(i, 1);
							}
							continue c;
						}
					}
					// error
					dcl._error("cycle", props, superClasses);
				}
				// calculate a base class
				superClass = superClass[0];
				j = bases.length - ((meta = superClass._meta) && superClass === bases[bases.length - (j = meta.bases.length)] ? j : 1) - 1; // intentional assignments
			}else{
				// 1) add a unique id
				superClass._uniqueId = superClass._uniqueId || counter++;
				// 2) single inheritance
				bases = bases.concat((meta = superClass._meta) ? meta.bases : superClass);   // intentional assignment
			}
		}
		// create a base class
		proto = superClass ? dcl.delegate(superClass[pname]) : {};
		// the next line assumes that constructor is actually named "constructor", should be changed if desired
		vector = superClass && (meta = superClass._meta) ? dcl.delegate(meta.weaver) : {constructor: 2};   // intentional assignment

		// create prototype: mix in mixins and props
		for(; j > 0; --j){
			base = bases[j];
			meta = base._meta;
			dcl.mix(proto, meta && meta.ownProps || base[pname]);
			if(meta){
				for(n in (superClasses = meta.weaver)){    // intentional assignment
					vector[n] = (+vector[n] || 0) | superClasses[n];
				}
			}
		}
		for(n in props){
			if(isSuper(meta = props[n])){  // intentional assignment
				vector[n] = +vector[n] || 0;
			}else{
				proto[n] = meta;
			}
		}

		// create stubs with fake constructor
		//
		meta = {bases: bases, ownProps: props, weaver: vector, chains: {}};
		// meta information is coded like that:
		// bases: an array of super classes (bases) and mixins
		// ownProps: a bag of immediate prototype properties for the constructor
		// weaver: a bag of chain instructions (before is 1, after is 2)
		// chains: a bag of chains (ordered arrays)

		bases[0] = {_meta: meta, prototype: proto};
		buildStubs(meta, proto);
		ctor = proto[cname];

		// put in place all decorations and return a constructor
		ctor._meta  = meta;
		ctor[pname] = proto;
		//proto.constructor = ctor; // uncomment if constructor is not named "constructor"
		bases[0] = ctor;

		// each constructor may have two properties on it:
		// _meta: a meta information object as above
		// _uniqueId: a unique number, which is used to id the constructor

		var result = dcl._postprocess(ctor);    // fully prepared constructor

		if(props.declaredClass && !registry[props.declaredClass]){
			registry[props.declaredClass] = result;
		}

		return result;

	}

	// decorators

	function Super(f){ this.around = f; }
	function isSuper(f){ return f && f.spr instanceof Super; }

	// utilities

	function allKeys(o){
		var keys = [];
		for(var name in o){
			keys.push(name);
		}
		return keys;
	}

	(mix = function(a, b){
		for(var n in b){
			a[n] = b[n];
		}
	})(dcl, {
		// piblic API
		mix: mix,
		delegate: function(o){
			return Object.create(o);
		},
		allKeys: allKeys,
		Super: Super,
		superCall: function superCall(f){ return dcl._makeSuper(f); },

		// protected API starts with _ (don't use it!)

		// make a Super marker
		_makeSuper: function makeSuper(advice, S){ var f = function(){}; f.spr = new (S || Super)(advice); return f; },

		// post-processor for a constructor, can be used to add more functionality
		// or augment its behavior
		_postprocess: function(ctor){ return ctor; },   // identity, used to hang on advices

		// error function, augmented by debug.js
		_error: function(msg){ throw Error("dcl: " + msg); },

		// supercall instantiation, augmented by debug.js
		_instantiate: function(advice, previous, node){ var t = advice.spr.around(previous); t.ctr = advice.ctr; return t; },

		// the "buildStubs()" helpers, can be overwritten
		_extractChain: function(bases, name, advice){
			var i = bases.length - 1, chain = [], base, f, around = advice == "around";
			for(; base = bases[i]; --i){
				// next line contains 5 intentional assignments
				if((f = base._meta) ? (f = f.ownProps).hasOwnProperty(name) && (isSuper(f = f[name]) ? (around ? f.spr.around : (f = f.spr[advice])) : around) : around && (f = name == cname ? base : base[pname][name]) && f !== empty[name]){
					if(typeof f == "function"){
						f.ctr = base;
						chain.push(f);
					}else{
						dcl._error("wrong super", base, name);
					}
				}
			}
			return chain;
		},
		_stubChain: function(chain){ // this is "after" chain
			var l = chain.length, f;
			return !l ? 0 : l == 1 ?
				(f = chain[0], function(){
					f.apply(this, arguments);
				}) :
				function(){
					for(var i = 0; i < l; ++i){
						chain[i].apply(this, arguments);
					}
				};
		},
		_stubSuper: function(chain, name){
			var i = 0, f, p = empty[name];
			for(; f = chain[i]; ++i){
				p = isSuper(f) ? (chain[i] = dcl._instantiate(f, p, name)) : f;
			}
			return name != cname ? p : function(){ p.apply(this, arguments); };
		},
		_stubChainSuper: function(chain, stub, name){
			var i = 0, f, diff, pi = 0;
			for(; f = chain[i]; ++i){
				if(isSuper(f)){
					diff = i - pi;
					chain[i] = dcl._instantiate(f, !diff ? 0 : diff == 1 ? chain[pi] : stub(chain.slice(pi, i)), name);
					pi = i;
				}
			}
			diff = i - pi;
			return !diff ? 0 : diff == 1 && name != cname ? chain[pi] : stub(pi ? chain.slice(pi) : chain);
		},
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around");
			return (id ? dcl._stubChainSuper(f, dcl._stubChain, name) : dcl._stubSuper(f, name)) || function(){};
		}
	});

	function buildStubs(meta, proto){
		var weaver = meta.weaver, bases = meta.bases, chains = meta.chains;
		for(var name in weaver){
			proto[name] = dcl._stub(weaver[name], bases, name, chains);
		}
	}
	dcl.getObject=function(classString){
		return registry[classString];
	};
    dcl.setObject=function(classString,object){
        return registry[classString] = object;
    };
	return dcl;
});
;
(function(factory){
	if(typeof define != "undefined"){
		define('dcl/advise',[], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory();
	}else{
		advise = factory();
	}
})(function(){
	"use strict";

	function Node(instance, name){
		this.next_before = this.prev_before = this.next_after = this.prev_after =
			this.next_around = this.prev_around = this;
		this.instance = instance;
		this.name = name;
	}
	var p = Node.prototype = {
		add: function(before, after, around, original){
			var node = new Node(this.instance, this.name);
			node.parent = this;
			node.before = before;
			this._add("before", node);
			node.after = after;
			this._add("after", node);
			node.around = around;
			this._add("around", node, original);
			node.original = original;
			if(original){ node.around = advise._instantiate(original, node.prev_around.around, this); }
			return node;
		},
		_add: function(topic, node, flag){
			if(node[topic] || flag){
				var n = "next_" + topic, p = "prev_" + topic;
				(node[p] = this[p])[n] = (node[n] = this)[p] = node;
			}
		},
		remove: function(node){
			this._remove("before", node);
			this._remove("after",  node);
			this._remove("around", node);
		},
		_remove: function(topic, node){
			var n = "next_" + topic, p = "prev_" + topic;
			node[n][p] = node[p];
			node[p][n] = node[n];
		},
		destroy: function(){
			var around = this.prev_around.around, t = this.next_around, parent = this.parent;
			this.remove(this);
			if(t !== this){
				for(; t !== parent; around = t.around, t = t.next_around){
					if(t.original){
						t.around = advise._instantiate(t.original, around, this);
					}
				}
			}
			this.instance = 0;
		}
	};
	p.unadvise = p.destroy;   // alias

	function makeAOPStub(node){
		var f = function(){
			var p, r, t = this, a = arguments, thrown;
			// running the before chain
			for(p = node.prev_before; p !== node; p = p.prev_before){
				p.before.apply(t, a);
			}
			// running the around chain
			try{
				if(node.prev_around !== node){ r = node.prev_around.around.apply(t, a); }
			}catch(e){
				r = e;
				thrown = true;
			}
			// running the after chain
			for(p = node.next_after; p !== node; p = p.next_after){
				p.after.call(t, a, r);
			}
			if(thrown){
				throw r;
			}
			return r;
		};
		f.adviceNode = node;
		return f;
	}

	function advise(instance, name, advice){
		var f = instance[name], node;
		if(f && f.adviceNode && f.adviceNode instanceof Node){
			node = f.adviceNode;
		}else{
			node = new Node(instance, name);
			if(f && f.advices){
				f = f.advices;
				node.add(f.before, f.after, f.around);
			}else{
				node.add(0, 0, f);
			}
			instance[name] = makeAOPStub(node);
		}
		if(typeof advice == "function"){ advice = advice(name, instance); }
		return node.add(advice.before, advice.after, 0, advice.around);
	}

	advise.before = function(instance, name, f){ return advise(instance, name, {before: f}); };
	advise.after  = function(instance, name, f){ return advise(instance, name, {after:  f}); };
	advise.around = function(instance, name, f){ return advise(instance, name, {around: f}); };
	advise.Node = Node;

	advise._instantiate = function(advice, previous, node){ return advice(previous); };

	return advise;
});
;
(function(factory){
	if(typeof define != "undefined"){
		define('dcl/dcl',["./mini"], factory);
	}else if(typeof module != "undefined"){
		module.exports = factory(require("./mini"));
	}else{
		dcl = factory(dcl);
	}
})(function(dcl){
	"use strict";

	function nop(){}

	var Advice = dcl(dcl.Super, {
		//declaredClass: "dcl.Advice",
		constructor: function(){
			this.before = this.around.before;
			this.after  = this.around.after;
			this.around = this.around.around;
		}
	});
	function advise(advice){ return dcl._makeSuper(advice, Advice); }

	function makeAOPStub(before, after, around){
		var beforeChain = before || nop,
			afterChain  = after  || nop,
			aroundChain = around || nop,
			stub = function(){
				var r, thrown;
				// running the before chain
				beforeChain.apply(this, arguments);
				// running the around chain
				try{
					r = aroundChain.apply(this, arguments);
				}catch(e){
					r = e;
					thrown = true;
				}
				// running the after chain
				afterChain.call(this, arguments, r);
				if(thrown){
					throw r;
				}
				return r;
			};
		stub.advices = {before: before, after: after, around: around};
		return stub;
	}

	function chain(id){
		return function(ctor, name){
			var meta = ctor._meta, rule;
			if(meta){
				rule = +meta.weaver[name] || 0;
				if(rule && rule != id){
					dcl._error("set chaining", name, ctor, id, rule);
				}
				meta.weaver[name] = id;
			}
		};
	}

	dcl.mix(dcl, {
		// public API
		Advice: Advice,
		advise: advise,
		// expose helper methods
		before: function(f){ return dcl.advise({before: f}); },
		after:  function(f){ return dcl.advise({after:  f}); },
		around: dcl.superCall,
		// chains
		chainBefore: chain(1),
		chainAfter:  chain(2),
		isInstanceOf: function(o, ctor){
			if(o instanceof ctor){
				return true;
			}
			var t = o.constructor._meta, i;
			if(t){
				for(t = t.bases, i = t.length - 1; i >= 0; --i){
					if(t[i] === ctor){
						return true;
					}
				}
			}
			return false;
		},
		// protected API starts with _ (don't use it!)
		_stub: /*generic stub*/ function(id, bases, name, chains){
			var f = chains[name] = dcl._extractChain(bases, name, "around"),
				b = dcl._extractChain(bases, name, "before").reverse(),
				a = dcl._extractChain(bases, name, "after");
			f = id ? dcl._stubChainSuper(f, id == 1 ? function(f){ return dcl._stubChain(f.reverse()); } : dcl._stubChain, name) : dcl._stubSuper(f, name);
			return !b.length && !a.length ? f || function(){} : makeAOPStub(dcl._stubChain(b), dcl._stubChain(a), f);
		}
	});

	return dcl;
});
;
define('xdojo/has',[
    "requirejs-dplugins/has"
], function (has) {
    return has;
});;
define('xdojo/declare',[
    'dojo/_base/declare'
], function (declare) {
    return declare;
});;
define('dojo/node',[
	"dojo/_base/kernel",
	"dojo/has",
	"require",
	"dojo/noob" //empty module
], function (kernel, has, require, noob) {

	var nodeRequire = kernel.global.require && kernel.global.require.nodeRequire;
	var _window = typeof window !== 'undefined' ? window : null;
	var isElectron = _window && _window.process && _window.process.type === "renderer";
	var module = nodeRequire ? nodeRequire("module") : null;
	if (!nodeRequire) {
		//@TODO: notice that window.nodeRequire must be set manually in your Electron renderer code. I could not extract the
		//Electron's require from anywhere.
		if (isElectron && _window && _window.nodeRequire) {
			nodeRequire = _window.nodeRequire;
			module = nodeRequire("module");
		} else {
		    if(has('debug')) {
                console.warn("Cannot get Electron/Node.js require, will noob to empty module dojo/noob");
            }
		}
	}
	return {
		// summary:
		//		This AMD plugin module allows native Node.js modules to be loaded by AMD modules using the Dojo
		//		loader. This plugin will not work with AMD loaders that do not expose the Node.js require function
		//		at `require.nodeRequire`.
		//
		// example:
		//	|	require(["dojo/node!fs"], function(fs){
		//	|		var fileData = fs.readFileSync("foo.txt", "utf-8");
		//	|	});

		load: function (/*string*/ id, /*Function*/ contextRequire, /*Function*/ load) {
			/*global define:true */
			// The `nodeRequire` function comes from the Node.js module of the AMD loader, so module ID resolution is
			// relative to the loader's path, not the calling AMD module's path. This means that loading Node.js
			// modules that exist in a higher level or sibling path to the loader will cause those modules to fail to
			// resolve.
			//
			// Node.js does not expose a public API for performing module filename resolution relative to an arbitrary
			// directory root, so we are forced to dig into the internal functions of the Node.js `module` module to
			// use Node.js's own path resolution code instead of having to duplicate its rules ourselves.
			//
			// Sooner or later, probably around the time that Node.js internal code is reworked to use ES6, these
			// methods will no longer be exposed and we will have to find another workaround if they have not exposed
			// an API for doing this by then.
			if (module && module._findPath && module._nodeModulePaths) {
				var localModulePath = module._findPath(id, module._nodeModulePaths(contextRequire.toUrl(".")));
				if (localModulePath !== false) {
					id = localModulePath;
				}
			}

			if (id && typeof  global !== "undefined" && global.moduleCache && global.moduleCache[id]) {
				return global.moduleCache[id];
			}

			//noob out modules when not node-js and not electron
			if (!module) {
				return load(noob);
			}

			var oldDefine = define,
				result;

			// Some modules attempt to detect an AMD loader by looking for global AMD `define`. This causes issues
			// when other CommonJS modules attempt to load them via the standard Node.js `require`, so hide it
			// during the load
			define = undefined;

			try {
				result = nodeRequire(id);
			}
			finally {
				define = oldDefine;
			}

			load(result);
		},
		normalize: function (/**string*/ id, /*Function*/ normalize) {
			// summary:
			//		Produces a normalized CommonJS module ID to be used by Node.js `require`. Relative IDs
			//		are resolved relative to the requesting module's location in the filesystem and will
			//		return an ID with path separators appropriate for the local filesystem

			if (id.charAt(0) === ".") {
				// absolute module IDs need to be generated based on the AMD loader's knowledge of the parent module,
				// since Node.js will try to use the directory containing `dojo.js` as the relative root if a
				// relative module ID is provided
				id = require.toUrl(normalize("./" + id));
			}

			if (!module) {
				id = normalize('dojo/noob');
			}

			return id;
		}
	};
});
;
define('dojo/noob',[], function () {

});;
define('dojo/has',["require", "module"], function(require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(!has("dojo-has-api")){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			global = this,
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		has.add("host-browser", isBrowser);
		has.add("dom", isBrowser);
		has.add("dojo-dom-ready-api", 1);
		has.add("dojo-sniff", 1);
	}

	if(has("host-browser")){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);
		has.add("touch", "ontouchstart" in document || window.navigator.msMaxTouchPoints > 0);
		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
});
;
/** module:dojo/Deferred **/
define('dojo/Deferred',[
	"./has",
	"./_base/lang",
	"./errors/CancelError",
	"./promise/Promise",
	"./has!config-deferredInstrumentation?./promise/instrumentation"
], function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				typeof logError !=='undefined' ? logError(error): console.error('error! ',error);
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};
    /**
     * @class module:dojo/Deferred
     * @param canceler {function}
     * @constructor
     */
	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if(has("config-deferredInstrumentation") && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if(has("config-deferredInstrumentation") && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
});
;
define('dojo/_base/declare',["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor = new Function, counter = 0, cname = "constructor";

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args == "string"){
			name = args;
			args = a;
			a = f;
		}
		f = 0;

		caller = args.callee;
		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args){
		if(typeof name == "string"){
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2){
		var f = this.getInherited(args, a1);
		if(f){ return f.apply(this, a2 || a1 || args); }
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

	function createSubclass(mixins, props){
		return declare([this].concat(mixins), props || {});
	}

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				ctor = new Function;
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},
		
		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
});
;
define('dojo/_base/lang',["./kernel", "../has", "../sniff"], function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			var p, i = 0, dojoGlobal = dojo.global;
			if(!context){
				if(!parts.length){
					return dojoGlobal;
				}else{
					p = parts[i++];
					try{
						context = dojo.scopeMap[p] && dojo.scopeMap[p][1];
					}catch(e){}
					context = context || (p in dojoGlobal ? dojoGlobal[p] : (create ? dojoGlobal[p] = {} : undefined));
				}
			}
			while(context && (p = parts[i++])){
				context = (p in context ? context[p] : (create ? context[p] = {} : undefined));
			}
			return context; // mixed
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
                if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: function(it){
			// summary:
			//		Return true if it is an Array.
			//		Does not work on Arrays created in other windows.
			// it: anything
			//		Item to test.
			return it && (it instanceof Array || typeof it == "array"); // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return it && it !== undefined && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the a given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r.push(lang.clone(src[i]));
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	has("extend-dojo") && lang.mixin(dojo, lang);

	return lang;
});

;
define('dojo/_base/kernel',["../has", "./config", "require", "module"], function(has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:this,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			this[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = !has("dojo-loader") || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 9, patch: 2, flag: "-pre",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	has.add("extend-dojo", 1);


	(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if(has("host-rhino")){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	has.add("dojo-guarantee-console",
		// ensure that console.log, console.warn, etc. are defined
		1
	);
	if(has("dojo-guarantee-console")){
		typeof console != "undefined" || (console = {});
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.apply({}, arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if(has("dojo-modulePaths")){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if(has("dojo-moduleUrl")){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lenghty relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
});
;
/** @module delite/register */
define('delite/register',[
	"module",
	"dcl/advise",
	"dcl/dcl",
	"decor/schedule",
	"requirejs-domready/domReady",	// loading as a function, not as a plugin
	"./features"
], function (module, advise, dcl, schedule, domReady, has) {
	"use strict";

	var doc = has("builder") ? require.nodeRequire("jsdom").jsdom("") : document;

	// Set to true after the page finishes loading and the parser runs.  Any widgets declared after initialParseComplete
	// instantiated in a separate code path.
	var initialParseComplete;

	// Workaround problem using dcl() on native DOMNodes on FF and IE,
	// see https://github.com/uhop/dcl/issues/9.
	// Fixes case where tabIndex is declared in a mixin that's passed to register().
	dcl.mix = function (a, b) {
		for (var n in b) {
			try {
				a[n] = b[n];
			} catch (e) {
				Object.defineProperty(a, n, {
					configurable: true,
					writable: true,
					enumerable: true,
					value: b[n]
				});
			}
		}
	};

	/**
	 * List of selectors that the parser needs to search for as possible upgrade targets.  Mainly contains
	 * the widget custom tags like d-accordion, but also selectors like button[is='d-button'] to find <button is="...">
	 * @type {string[]}
	 */
	var selectors = [];

	/**
	 * Internal registry of widget class metadata.
	 * Key is custom widget tag name, used as Element tag name like <d-accordion> or "is" attribute like
	 * <button is="d-accordion">).
	 * Value is metadata about the widget, including its prototype, ex: {prototype: object, extends: "button", ... }
	 * @type {Object}
	 */
	var registry = {};

	/**
	 * Create an Element.  Similar to document.createElement(), but if tag is the name of a widget defined by
	 * register(), then it upgrades the Element to be a widget.
	 * @function module:delite/register.createElement
	 * @param {string} tag
	 * @returns {Element} The DOMNode
	 */
	function createElement(tag) {
		if (/-/.test(tag) && !(tag in registry) && !has("builder")) {
			// Try to help people that have templates with custom elements but they forgot to do requires="..."
			console.warn("register.createElement(): undefined tag '" + tag +
				"', did you forget requires='...' in your template?");
		}

		var base = registry[tag] ? registry[tag].extends : null;
		if (has("document-register-element")) {
			return base ? doc.createElement(base, tag) : doc.createElement(tag);
		} else {
			var element = doc.createElement(base || tag);
			if (base) {
				element.setAttribute("is", tag);
			}
			upgrade(element);
			return element;
		}
	}

	/**
	 * Generate metadata about all the properties in proto, both direct and inherited.
	 * On IE<=10, these properties will be applied to a DOMNode via Object.defineProperties().
	 * Skips properties in the base element (HTMLElement, HTMLButtonElement, etc.)
	 * @param {Object} proto - The prototype.
	 * @returns {Object} Hash from property name to return value from `Object.getOwnPropertyDescriptor()`.
	 */
	function getPropDescriptors(proto) {
		var props = {};

		do {
			var keys = Object.getOwnPropertyNames(proto);	// better than Object.keys() because finds hidden props too
			for (var i = 0, k; (k = keys[i]); i++) {
				if (!props[k]) {
					props[k] = Object.getOwnPropertyDescriptor(proto, k);
				}
			}
			proto = Object.getPrototypeOf(proto);
		} while (!/HTML[a-zA-Z]*Element/.test(proto.constructor.toString()));

		return props;
	}

	/**
	 * Converts plain Element of custom type into "custom element", by adding the widget's custom methods, etc.
	 * Does nothing if the Element has already been converted or if it doesn't correspond to a registered custom tag.
	 * After the upgrade, calls `createdCallback()`.
	 *
	 * Usually the application will not need to call this method directly, because it's called automatically
	 * on page load and as elements are added to the document.
	 *
	 * @function module:delite/register.upgrade
	 * @param {Element} element - The DOM node.
	 * @param {boolean} [attach] - If `element`'s tag has been registered, but `attachedCallback()` hasn't yet been
	 * called [since the last call to `detachedCallback()`], then call `attachedCallback()`.  Call even if the element
	 * has already been upgraded.
	 */
	function upgrade(element, attach) {
		if (!has("document-register-element")) {
			var widget = registry[element.getAttribute("is") || element.nodeName.toLowerCase()];
			if (widget) {
				if (!element._upgraded) {
					if (has("dom-proto-set")) {
						// Redefine Element's prototype to point to widget's methods etc.
						/*jshint camelcase: false*/
						/*jshint proto: true*/
						element.__proto__ = widget.prototype;
						/*jshint camelcase: true*/
						/*jshint proto: false*/
					} else {
						// Mixin all the widget's methods etc. into Element
						Object.defineProperties(element, widget.props);
					}
					element._upgraded = true;
					if (element.createdCallback) {
						element.createdCallback();
					}
				}
				if (attach && !element._attached) {
					element.attachedCallback();
				}
			}
		}
	}

	/**
	 * Call detachedCallback() on specified Element if it's a custom element that was upgraded by us.
	 * @param {Element} node
	 */
	function detach(node) {
		if (node._upgraded) {
			node.detachedCallback();
		}
	}

	/**
	 * Mapping of tag names to HTMLElement interfaces.
	 * Doesn't include newer elements not available on all browsers.
	 * @type {Object}
	 */
	var tagMap = typeof HTMLElement !== "undefined" && {	// "typeof HTMLElement" check so module loads in NodeJS
		a: HTMLAnchorElement,
		// applet: HTMLAppletElement,
		// area: HTMLAreaElement,
		// audio: HTMLAudioElement,
		base: HTMLBaseElement,
		br: HTMLBRElement,
		button: HTMLButtonElement,
		canvas: HTMLCanvasElement,
		// data: HTMLDataElement,
		// datalist: HTMLDataListElement,
		div: HTMLDivElement,
		dl: HTMLDListElement,
		directory: HTMLDirectoryElement,
		// embed: HTMLEmbedElement,
		fieldset: HTMLFieldSetElement,
		font: HTMLFontElement,
		form: HTMLFormElement,
		head: HTMLHeadElement,
		h1: HTMLHeadingElement,
		html: HTMLHtmlElement,
		hr: HTMLHRElement,
		iframe: HTMLIFrameElement,
		img: HTMLImageElement,
		input: HTMLInputElement,
		// keygen: HTMLKeygenElement,
		label: HTMLLabelElement,
		legend: HTMLLegendElement,
		li: HTMLLIElement,
		link: HTMLLinkElement,
		map: HTMLMapElement,
		// media: HTMLMediaElement,
		menu: HTMLMenuElement,
		meta: HTMLMetaElement,
		// meter: HTMLMeterElement,
		ins: HTMLModElement,
		object: HTMLObjectElement,
		ol: HTMLOListElement,
		optgroup: HTMLOptGroupElement,
		option: HTMLOptionElement,
		// output: HTMLOutputElement,
		p: HTMLParagraphElement,
		param: HTMLParamElement,
		pre: HTMLPreElement,
		// progress: HTMLProgressElement,
		quote: HTMLQuoteElement,
		script: HTMLScriptElement,
		select: HTMLSelectElement,
		// source: HTMLSourceElement,
		// span: HTMLSpanElement,
		style: HTMLStyleElement,
		table: HTMLTableElement,
		caption: HTMLTableCaptionElement,
		// td: HTMLTableDataCellElement,
		// th: HTMLTableHeaderCellElement,
		col: HTMLTableColElement,
		tr: HTMLTableRowElement,
		tbody: HTMLTableSectionElement,
		textarea: HTMLTextAreaElement,
		// time: HTMLTimeElement,
		title: HTMLTitleElement,
		// track: HTMLTrackElement,
		ul: HTMLUListElement,
		// blink: HTMLUnknownElement,
		video: HTMLVideoElement
	};
	var tags = tagMap && Object.keys(tagMap);

	/**
	 * Registers the tag with the current document, and save tag information in registry.
	 * Handles situations where the base constructor inherits from
	 * HTMLElement but is not HTMLElement.
	 * @param  {string}   tag         The custom tag name for the element, or the "is" attribute value.
	 * @param  {string}	  _extends    The name of the tag this element extends, ex: "button" for <button is="...">
	 * @param  {string}   baseElement The native HTML*Element "class" that this custom element is extending.
	 * @param  {Function} baseCtor    The constructor function.
	 * @return {Function}             The "new" constructor function that can create instances of the custom element.
	 */
	function getTagConstructor(tag, _extends, baseElement, baseCtor) {
		var proto = baseCtor.prototype,
			config = registry[tag] = {
				constructor: baseCtor,
				prototype: proto
			};

		if (_extends) {
			config.extends = _extends;
		}

		if (has("document-register-element")) {
			doc.registerElement(tag, config);
		} else {
			if (!has("dom-proto-set")) {
				// Get descriptors for all the properties in the prototype.  This is needed on IE<=10 in upgrade().
				config.props = getPropDescriptors(proto);
			}
		}

		// Note: if we wanted to support registering new types after the parser was called, then here we should
		// scan the document for the new type (selectors[length-1]) and upgrade any nodes found.

		// Create a constructor method to return a DOMNode representing this widget.
		var tagConstructor = function (params) {
			// Create new widget node or upgrade existing node to widget
			var node = createElement(tag);

			// Set parameters on node
			for (var name in params || {}) {
				if (name === "style") {
					node.style.cssText = params.style;
				} else if ((name === "class" || name === "className") && node.setClassComponent) {
					node.setClassComponent("user", params[name]);
				} else {
					node[name] = params[name];
				}
			}
			if (node.deliver) {
				node.deliver();
			}

			return node;
		};

		// Add some flags for debugging and return the new constructor
		tagConstructor.tag = tag;
		tagConstructor._ctor = baseCtor;

		// Register the selector to find this custom element
		var selector = _extends ? _extends + "[is='" + tag + "']" : tag;
		selectors.push(selector);

		// If the document has already been parsed then do a supplementary sweep for this new custom element.
		if (initialParseComplete && !has("document-register-element")) {
			unobserve();	// pause listening for added/deleted nodes
			parse(doc, selector);
			observe();	// resume listening for added/deleted nodes
		}

		return tagConstructor;
	}

	/**
	 * Restore the "true" constructor when trying to recombine custom elements
	 * @param  {Function} extension A constructor function that might have a shadow property that contains the
	 *                              original constructor
	 * @return {Function}           The original construction function or the existing function/object
	 */
	function restore(extension) {
		return (extension && extension._ctor) || extension;
	}

	/**
	 * Declare a widget and register it as a custom element.
	 *
	 * props{} can provide custom setters/getters for widget properties, which are called automatically when
	 * the widget properties are set.
	 * For a property XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	 *
	 * @param  {string}               tag             The custom element's tag name.
	 * @param  {Object[]}             superclasses    Any number of superclasses to be built into the custom element
	 *                                                constructor. But first one must be [descendant] of HTMLElement.
	 * @param  {Object}               props           Properties of this widget class.
	 * @return {Function}                             A constructor function that will create an instance of the custom
	 *                                                element.
	 * @function module:delite/register
	 */
	function register(tag, superclasses, props) {
		// Create the widget class by extending specified superclasses and adding specified properties.

		// Make sure all the bases have their proper constructors for being composited.
		// I.E. remove the wrapper added by getTagConstructor().
		var bases = (superclasses instanceof Array ? superclasses : superclasses ? [superclasses] : []).map(restore);


		// Check to see if the custom tag is already registered
		if (tag in registry) {
			throw new TypeError("A widget is already registered with tag '" + tag + "'.");
		}

		// Get root (aka native) class: HTMLElement, HTMLInputElement, etc.
		var baseElement = bases[0];
		if (baseElement.prototype && baseElement.prototype._baseElement) {
			// The first superclass is a widget created by another call to register, so get that widget's root class
			baseElement = baseElement.prototype._baseElement;
		}

		// Get name of tag that this widget extends, for example <button is="..."> --> "button"
		var _extends;
		if (baseElement !== HTMLElement) {
			_extends = tags.filter(function (tag) {
				return tagMap[tag] === baseElement;
			})[0];
			if (!_extends) {
				throw new TypeError(tag + ": must have HTMLElement in prototype chain");
			}
		}

		// Get a composited constructor
		var ctor = dcl(bases, props || {}),
			proto = ctor.prototype;
		proto._ctor = ctor;
		proto._baseElement = baseElement;
		proto._tag = tag;
		proto._extends = _extends;

		// Monkey-patch attachedCallback() and detachedCallback() to avoid double executions.
		// Generally this isn't an issue, but it could happen if the app manually called the functions
		// and then they were called automatically too.
		advise.around(proto, "attachedCallback", function (sup) {
			return function () {
				if (this._attached) { return; }
				if (sup) { sup.apply(this, arguments); }
				this._attached = true;
			};
		});
		advise.around(proto, "detachedCallback", function (sup) {
			return function () {
				if (!this._attached) { return; }
				if (sup) { sup.apply(this, arguments); }
				this._attached = false;
			};
		});

		// Run introspection to add ES5 getters/setters.
		// Doesn't happen automatically because Stateful's constructor isn't called.
		// Also, on IE this needs to happen before the getTagConstructor() call,
		// since getTagConstructor() scans all the properties on the widget prototype.
		if (proto.introspect) {
			ctor._propsToObserve = proto.getProps();
			proto.introspect(ctor._propsToObserve);
			ctor.introspected = true;
		}

		// Save widget metadata to the registry and return constructor that creates an upgraded DOMNode for the widget
		/* jshint boss:true */
		return getTagConstructor(tag, _extends, baseElement, ctor);
	}

	/**
	 * Parse the given DOM tree for any Elements that need to be upgraded to widgets.
	 * Searches all descendants of the specified node, but does not upgrade the node itself.
	 *
	 * Usually the application will not need to call this method directly, because it's called automatically
	 * on page load and as elements are added to the document.
	 *
	 * @function module:delite/register.parse
	 * @param {Element} [root] DOM node to parse from.
	 * @param {String} [selector] The selector to use to detect custom elements.  Defaults to selector
	 * for all registered custom elements.
	 */
	function parse(root, selector) {
		if (has("document-register-element")) { return; }
		selector = selector || selectors.join(", ");
		if (selector) {
			var node, idx = 0, nodes = (root || doc).querySelectorAll(selector);
			while ((node = nodes[idx++])) {
				upgrade(node, true);
			}
		}
	}

	// ------------------------
	// Code to listen for nodes being added/deleted from the document, to automatically call parse()/detachedCallback()
	var observer;

	/**
	 * Start listening for added/deleted nodes.
	 */
	function observe() {
		if (!has("document-register-element")) {
			if (!observer) {
				if (has("MutationObserver")) {
					observer = new MutationObserver(processMutations);
				} else {
					// Fallback for Android < 4.2 and IE < 11.  Partial shim of MutationObserver, except sometimes
					// addedNodes lists all nodes not just the root of each added tree.
					observer = {
						takeRecords: function () {
							var ret = this._mutations;
							this._mutations = [];
							if (this._timer) {
								this._timer.remove();
								this._timer = null;
							}
							return ret;
						},
						observe: function () {
							this._mutations = [];
							this._listener = function (event) {
								if (event.target.nodeType === 1) {
									var mutation = {};
									mutation[event.type === "DOMNodeInserted" ? "addedNodes" : "removedNodes"] =
										[event.target];
									this._mutations.push(mutation);
								}
								if (!this._timer) {
									this._timer = schedule(function () {
										this._timer = null;
										processMutations(this.takeRecords());
									}.bind(this));
								}
							}.bind(this);
							doc.body.addEventListener("DOMNodeInserted", this._listener);
							doc.body.addEventListener("DOMNodeRemoved", this._listener);
						},
						disconnect: function () {
							doc.body.removeEventListener("DOMNodeInserted", this._listener);
							doc.body.removeEventListener("DOMNodeRemoved", this._listener);
						}
					};
				}
			}
			observer.observe(doc.body, {childList: true, subtree: true});
		}
	}

	/**
	 * Stop (aka pause) listening for added/deleted nodes.
	 */
	function unobserve() {
		if (observer) {
			// TODO: This method is supposed to pause listening for DOM updates,
			// but I suspect disconnect() also throws away records
			// for any mutations that have already occurred.   Those records need to be saved or processed.
			observer.disconnect();
		}
	}

	/**
	 * Process the added/deleted nodes.  Called for incremental updates after initial parse.
	 * @param mutations
	 */
	function processMutations(mutations) {
		if (!has("document-register-element") && selectors.length) {
			unobserve();	// pause listening for added/deleted nodes
			var parseDescendants = has("MutationObserver") || has("DOMNodeInserted") === "root";
			mutations.forEach(function (mutation) {
				var added, idx1 = 0;
				while ((added = mutation.addedNodes && mutation.addedNodes[idx1++])) {
					// contains() checks avoid calling attachedCallback() on nodes not attached to document because:
					//		1. node was added then removed before processMutations() was called
					//		2. node was added and then its ancestor was removed before processMutations() was called
					if (added.nodeType === 1 && added.ownerDocument.body.contains(added)) {
						// upgrade the node itself (if it's a custom widget and it hasn't been upgraded yet),
						// and then call attachedCallback() on it
						upgrade(added, true);

						// upgrade any descendants that are custom widgets (if they aren't already upgraded),
						// and then call attachedCallback() on them
						if (parseDescendants) {
							parse(added);
						}
					}
				}

				var removedRoot, idx2 = 0;
				while ((removedRoot = mutation.removedNodes && mutation.removedNodes[idx2++])) {
					if (removedRoot.nodeType === 1) {
						detach(removedRoot);
						var removed, idx3 = 0, removedDescendants = removedRoot.querySelectorAll(selectors.join(", "));
						while ((removed = removedDescendants[idx3++])) {
							detach(removed);
						}
					}
				}
			});
			observe();	// resume listening for added/deleted nodes
		}
	}

	/**
	 * Upgrade any custom tags in the document that have not yet been upgraded.
	 * Nodes are automatically updated asynchronously, but applications can synchronously update them by calling
	 * this method.  Should not be called before domReady event.
	 */
	function deliver() {
		if (!has("document-register-element")) {
			if (!initialParseComplete) {
				parse();
				initialParseComplete = true;
				observe();
			} else {
				processMutations(observer.takeRecords());
			}
		}
	}

	// Setup initial parse of document and also listeners for future document modifications.
	if (!has("document-register-element") && doc) {
		domReady(function () {
			if (!has("dom-template")) {
				// Move <template> child nodes to .content property, so that we don't parse custom elements in
				// <template> nodes.  Could be done on dynamically created nodes too, but currently there's no need.
				var template, idx = 0, nodes = doc.querySelectorAll("template");
				while ((template = nodes[idx++])) {
					if (!template.content) {
						var child, content = template.content = doc.createDocumentFragment();
						while ((child = template.firstChild)) {
							content.appendChild(child);
						}
					}
				}
			}

			// Upgrade all custom element nodes, and setup listeners for future changes.
			deliver();
		});
	}

	// Setup return value as register() method, with other methods hung off it.
	register.upgrade = upgrade;
	register.createElement = createElement;
	register.parse = parse;
	register.deliver = deliver;

	// Add helpers from dcl for declaring classes.

	/**
	 * Convenience shortcut to [dcl()](http://www.dcljs.org/docs/mini_js/dcl/).
	 * @function module:delite/register.dcl
	 */
	register.dcl = dcl;

	/**
	 * Convenience shortcut to [dcl.after()](http://www.dcljs.org/docs/dcl_js/after/).
	 * @function module:delite/register.after
	 */
	register.after = dcl.after;

	/**
	 * Convenience shortcut to [dcl.before()](http://www.dcljs.org/docs/dcl_js/before/).
	 * @function module:delite/register.before
	 */
	register.before = dcl.before;

	/**
	 * Convenience shortcut to [dcl.around()](http://www.dcljs.org/docs/dcl_js/around/).
	 * @function module:delite/register.around
	 */
	register.around = dcl.around;

	/**
	 * Convenience shortcut to [dcl.superCall()](http://www.dcljs.org/docs/mini_js/supercall/).
	 * @function module:delite/register.superCall
	 */
	register.superCall = dcl.superCall;

	return register;
});
;
/** @module delite/Container */
define('delite/Container',[
	"dcl/dcl",
	"./Widget"
], function (dcl, Widget) {

	/**
	 * Dispatched after an Element has been added as child of this widget.
	 * @example
	 * element.addEventListener("delite-add-child", function (evt) {
	 *      console.log("container: " + evt.target.id + " has new child " + evt.child.id);
	 * });
	 * @event module:delite/Container#delite-add-child
	 */

	/**
	 * Dispatched after an child Element has been removed from this widget.
	 * @example
	 * element.addEventListener("delite-remove-child", function (evt) {
	 *      console.log("container: " + evt.target.id + " removed child " + evt.child.id);
	 * });
	 * @event module:delite/Container#delite-remove-child
	 */

	/**
	 * Base class for widgets that contain content.
	 * Useful both for widgets that contain free-form markup (ex: ContentPane),
	 * and widgets that contain an ordered list of children (ex: Toolbar).
	 *
	 * Note that Container is not meant to be used for widgets that just internally create child
	 * widgets (ex: a StarRating widget creates stars), but rather for when the widget has children from
	 * the application's perspective (i.e. from the perspective of the widget *user* rather
	 * than the widget *author*).
	 *
	 * @mixin module:delite/Container
	 * @augments module:delite/Widget
	 */
	return dcl(Widget, /** @lends module:delite/Container# */{
		/**
		 * Designates where children of the source DOM node will be placed,
		 * and also the target for nodes inserted via `.appendChild()`, `.insertBefore()`, etc.
		 * "Children" in this case refers to both DOM nodes and widgets.
		 *
		 * @member {Element}
		 * @default Widget root node itself.
		 * @protected
		 */
		containerNode: undefined,

		render: dcl.advise({
			before: function () {
				// Save original markup to put into this.containerNode.
				var srcDom = this._srcDom = this.ownerDocument.createDocumentFragment();
				var oldContainer = this.containerNode || this;
				while (oldContainer.firstChild) {
					srcDom.appendChild(oldContainer.firstChild);
				}
			},

			after: function () {
				if (!this.containerNode) {
					// All widgets with descendants must set containerNode.
					this.containerNode = this;
				}

				// Put original markup into this.containerNode.  Note that appendChild() on a DocumentFragment will
				// loop through all the Elements in the document fragment, adding each one.
				this.containerNode.appendChild(this._srcDom);
			}
		}),

		appendChild: dcl.superCall(function (sup) {
			return function (child) {
				if (this.rendered) {
					var res = sup.call(this.containerNode, child);
					this.onAddChild(child);
					return res;
				} else {
					return sup.call(this, child);
				}
			};
		}),

		insertBefore: dcl.superCall(function (sup) {
			return function (newChild, refChild) {
				if (this.rendered) {
					var res = sup.call(this.containerNode, newChild, refChild);
					this.onAddChild(newChild);
					return res;
				} else {
					return sup.call(this, newChild, refChild);
				}
			};
		}),

		/**
		 * Callback whenever a child element is added to this widget via `appendChild()`, `insertBefore()`,
		 * or a method like `addChild()` that internally calls `appendChild()` and/or `insertBefore()`.
		 * @param {Element} node
		 */
		onAddChild: function (node) {
			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if (this.attached && node.attachedCallback) {
				node.attachedCallback();
			}

			this.emit("delite-add-child", {
				bubbles: false,
				cancelable: false,
				child: node
			});
		},

		/**
		 * Inserts the specified Element at the specified index.
		 * For example, `.addChild(node, 3)` sets this widget's fourth child to node.
		 * @param {Element} node - Element to add as a child.
		 * @param {number} [insertIndex] - Position the child as at the specified position relative to other children.
		 */
		addChild: function (node, insertIndex) {
			// Note: insertBefore(node, null) equivalent to appendChild().  Null arg is needed (only) on IE.
			var cn = this.containerNode, nextSibling = cn.children[insertIndex];
			cn.insertBefore(node, nextSibling || null);
		},

		/**
		 * Detaches the specified node instance from this widget but does
		 * not destroy it.  You can also pass in an integer indicating
		 * the index within the container to remove (ie, removeChild(5) removes the sixth node).
		 * @param {Element|number} node
		 */
		removeChild: function (node) {
			if (typeof node === "number") {
				node = this.getChildren()[node];
			}

			if (node && node.parentNode) {
				HTMLElement.prototype.removeChild.call(node.parentNode, node); // detach but don't destroy
			}

			this.emit("delite-remove-child", {
				bubbles: false,
				cancelable: false,
				child: node
			});
		},

		/**
		 * Returns all direct children of this widget, i.e. all widgets or DOM nodes underneath
		 * `this.containerNode`.  Note that it does not return all
		 * descendants, but rather just direct children.
		 *
		 * The result intentionally excludes element outside off `this.containerNode`.  So, it is different than
		 * accessing the `children` or `childNode` properties.
		 *
		 * @returns {Element[]}
		 */
		getChildren: function () {
			// use Array.prototype.slice to transform the live HTMLCollection into an Array
			return Array.prototype.slice.call(this.containerNode.children);
		},

		/**
		 * Returns true if widget has child nodes, i.e. if `this.containerNode` contains widgets.
		 * @returns {boolean}
		 */
		hasChildren: function () {
			return this.getChildren().length > 0;
		},

		/**
		 * Returns the index of the child in this container or -1 if not found.
		 * @param {Element} child
		 * @returns {number}
		 */
		getIndexOfChild: function (child) {
			return this.getChildren().indexOf(child);
		}
	});
});
;
define('xblox/RunScript',[
    "dojo/_base/lang",
    "dojo/on",
    "dcl/dcl",//make sure
    "delite/register",
    "delite/CustomElement",
    //explicit because a bootstrap might not be loaded at some point
    "xide/factory/Events",
    //explicit because a bootstrap might not be loaded at some point
    'xide/utils/StringUtils',
    'xide/types/Types',
    'xblox/model/Referenced',
    'xide/mixins/EventedMixin',
    'xide/mixins/ReloadMixin',
    /** 2way binding dependencies **/
    'xwire/Binding',
    'xwire/EventSource',
    'xwire/WidgetTarget'

], function (lang, on, dcl, register, CustomElement, Events, utils, Types, Referenced, EventedMixin, ReloadMixin, Binding, EventSource, WidgetTarget, registry) {

    var debugWidgets = false;
    var debugApp = false;
    var debugAttach = false;
    var debugCreated = false;
    var debugBinding = false;
    var debugRun = false;
    /**
     * Proxy widget to run a selected blox script on the parent widget/node.
     *
     * @class xblox/RunScript
     */
    var Impl = {
        declaredClass: 'xblox/RunScript',
        targetevent: '',
        sourceevent: "",
        sourceeventvaluepath: "",
        sourceeventnamepath: "",
        targetproperty: "",
        targetvariable: "",
        targetfilter: "",
        script: "",
        bidirectional: false,
        blockGroup: '',
        block: '',
        _targetBlock: null,
        _targetReference: null,
        _appContext: null,
        _complete: false,
        enabled: true,
        stop: false,
        _events: [],
        context: null,
        accept: '',
        transform: '',
        mode: 0,
        _2wayHandle: null,//the handle
        binding: null,//the binding
        /**
         * soft destroy
         */
        reset: function () {
            this._destroyHandles();
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }
            if (this.binding) {
                this.binding.destroy();
            }
            delete this.binding;
            this._appContext = null;
            this._targetReference = null;
        },
        /**
         *
         * @param newSettings
         */
        onSettingsChanged: function () {
            this.reset();
            if (!this.enabled) {
                return;
            }
            this.onAppReady(null);
        },
        getChildren: function () {
            return [];
        },
        /**
         * @inheritDoc
         */
        destroy: function () {
            this.onDestroy && this.onDestroy();
            this.reset();
            delete this.binding;
            delete this.context;
        },
        /**
         * The final execution when 'target event' has been triggered. This
         * will run the select block.
         * @param event
         * @param val
         */
        run: function (event, val) {
            if (!this.enabled) {
                return;
            }
            var settings = {};
            //filter, in design mode, we ain't do anything
            if (this.context && this.context.delegate) {
                if (this.context.delegate.isDesignMode && this.context.delegate.isDesignMode()) {
                    return;
                }
                if (this.context.delegate.getBlockSettings) {
                    settings = this.context.delegate.getBlockSettings();
                }
            }
            //setup variables
            var block = this._targetBlock,
                context = this._targetReference,
                result;

            if (block && context) {
                block.context = context;
                block._targetReference = context;
                if (this.targetvariable && this.targetvariable.length && val != null) {
                    block.override = {
                        variables: {}
                    };
                    block.override.variables[this.targetvariable] = val;
                }
                result = block.solve(block.scope, settings);
                debugRun && console.log('run ' + block.name + ' for even ' + event, result + ' for ' + this.id, this._targetReference);
            }
        },
        /**
         * Callback when the minimum parameters are given: targetReference & targetBlock
         */
        onReady: function () {
            if (!this._targetReference) {
                this._setupTargetReference();
            }

            //resolve 2way binding
            if (this._targetReference && this['bidirectional'] === true && this.sourceevent && this.sourceevent.length && !this.binding) {
                this._setup2WayBinding();
            }

            if (this._complete) {
                return;
            }
            if (!this._targetReference) {
                console.error('have no target reference');
            }
            if (!this._targetBlock) {
                console.error('have no target block');
            }

            if (this._targetReference && this._targetBlock) {
                //we trigger on events
                if (this.targetevent) {
                    this._complete = true;
                    //patch the target
                    utils.mixin(this._targetReference, EventedMixin.prototype);
                    var _target = this._targetReference.domNode || this._targetReference,
                        _event = this.targetevent,
                        _isWidget = this._targetReference.declaredClass || this._targetReference.startup,
                        _hasWidgetCallback = this._targetReference.on != null && this._targetReference['on' + utils.capitalize(_event)] != null,
                        _handle = null,
                        _isDelite = _target.render != null && _target.on != null,
                        thiz = this;

                    if (_isWidget && (this._targetReference.baseClass && this._targetReference.baseClass.indexOf('dijitContentPane') != -1) || this._targetReference.render != null || this._targetReference.on != null) {
                        _isWidget = false;//use on
                    }

                    if (_target) {
                        debugBinding && console.log('wire success ' + this.id + ' for ' + this.targetevent);
                        if (!_isDelite && (!_hasWidgetCallback || !_isWidget)) {
                            _handle = on(_target, this.targetevent, function (evt) {
                                this.run(this.targetevent);
                            }.bind(this));
                        } else {
                            _target = this._targetReference;
                            var useOn = true;
                            if (useOn) {
                                if (!_isDelite) {
                                    var _e = 'on' + utils.capitalize(_event);
                                    this._targetReference[_e] = function (val, nada) {
                                        if (_target.ignore !== true) {
                                            thiz.run(thiz.targetevent, val);
                                        }
                                    };
                                } else {
                                    _handle = _target.on(this.targetevent, function (evt) {
                                        if (this.stop) {
                                            evt.preventDefault();
                                            evt.stopImmediatePropagation();
                                        }
                                        this.run(this.targetevent, evt.currentTarget.value);
                                    }.bind(this));
                                }
                            } else {
                                this._targetReference['on' + utils.capitalize(_event)] = function (val) {
                                    if (_target.ignore !== true) {
                                        thiz.run(thiz.targetevent, val);
                                    }
                                };
                            }
                        }
                        _handle && this._events.push(_handle);
                    } else {
                        console.error('have no target to wire');
                    }
                }
            } else {
                console.error('invalid params, abort', this);
            }
            if (this.binding) {
                this.binding.start();
            }
        },
        resolveBlock: function (block) {
            var ctx = this._appContext;
            var deviceManager = ctx.getDeviceManager();
            if (block.indexOf('://') !== -1) {
                if (!deviceManager) {
                    return;
                }
                var _block = deviceManager.getBlock(this.block);
                if (_block) {
                    return _block;
                }
            }
        },
        /**
         *
         * @param ctx
         * @private
         */
        _setBlock: function (ctx) {
            ctx = ctx || window['appContext'];
            if (!ctx || !ctx.getBlockManager) {
                debugApp && console.warn('have no context or block manager');
                return;
            }
            this._appContext = ctx;
            var blockManager = ctx.getBlockManager(),
                deviceManager = ctx.getDeviceManager(),
                thiz = this;

            if (!blockManager) {
                return;
            }
            var _block = this.block ? this.block : this.getAttribute('block');
            if (_block && _block.length > 0) {
                var parts = utils.parse_url(_block);
                if (_block.indexOf('://') !== -1) {
                    if (!deviceManager) {
                        debugApp && console.warn('xScript::_setBlock : have no device manager');
                        return;
                    }
                    var _block2 = deviceManager.getBlock(_block);
                    if (_block2) {
                        thiz._targetBlock = _block2;
                        thiz.onReady();
                    } else {
                        debugBinding && console.warn('cant get block : ' + _block);
                    }
                } else {
                    blockManager.load(parts.scheme, parts.host).then(function (scope) {
                        var block = scope.getBlockById(thiz.blockid);
                        if (block) {
                            thiz._targetBlock = block;
                            thiz.onReady();
                        }
                    });
                }
            } else if (this.scopeid) {
                var scope = blockManager.hasScope(thiz.scopeid);
                if (scope) {
                    var block = scope.getBlockById(thiz.blockid);
                    if (block) {
                        thiz._targetBlock = block;
                        thiz.onReady();
                    } else {
                        block = scope.getVariableById(thiz.blockid);
                        if (block) {
                            thiz._targetBlock = block;
                            thiz.onReady();
                        }
                    }
                } else {
                    console.error('have no scope!');
                }
            }
        },
        initWithReference: function (ref) {
            if (ref.nodeType !== 1) {
                return;
            }
            this._targetReference = ref;
            this._setBlock(null);
        },
        resolveFilter: function (expression, value, widget) {
            if (this._targetBlock) {
                var expressionModel = this._targetBlock.scope.expressionModel;
                value = expressionModel.parseVariable(this._targetBlock.scope, {
                    value: expression
                }, '', false, false, widget, [value]);
            }
            return value;
        },
        /**
         * setup outbound wire, assumes all parameters are checked
         * @private
         */
        _setup1WayBinding: function () {
            debugBinding && console.log('setup 1 way binding');
            //destroy old handle
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }

            if (!this._targetBlock) {
                console.error('invalid params for one way binding');
                return;
            }
            var sourceVariableTitle = this._targetBlock.name;
            //wire to system event
            var bindingSource = new EventSource({
                //listen to variable changes
                trigger: this.sourceevent,
                //the path to value, ie: 'item.value'
                path: this.sourceeventvaluepath,
                //add an event filter
                filters: [{
                    // variable title must match,ie: 'item.title'
                    path: this.sourceeventnamepath,
                    // the name of the variable, ie: 'Volume'
                    value: sourceVariableTitle
                }]
            });


            //now map the event source to a widget
            var bindingTarget = new WidgetTarget({
                //the path to value
                path: this.targetproperty,
                object: this._targetReference,
                targetFilter: this.targetfilter,
                delegate: this
            });
            var accept = this._findbyTagAndName('D-SCRIPT', 'accept');
            var transform = this._findbyTagAndName('D-SCRIPT', 'transform');
            //construct the binding
            var binding = new Binding({
                source: bindingSource,
                target: bindingTarget,
                accept: this._findbyTagAndName('D-SCRIPT', 'accept'),
                transform: this._findbyTagAndName('D-SCRIPT', 'transform')
            });
            this.binding = binding;
            binding.start();
        },
        _findbyTagAndName: function (tag, name) {
            var scripts = $(this).find(tag);
            for (var i = 0; i < scripts.length; i++) {
                var script = scripts[i];
                if ($(script).attr('name') === name) {
                    return script;
                }
            }
            return null;
        },
        /**
         * setup inbound wire, assumes all parameters are checked
         * @private
         */
        _setup2WayBinding: function () {
            if (this.binding) {
                return;
            }
            debugBinding && console.log('setup 2 way binding');
            //destroy old handle
            if (this._2wayHandle) {
                this._2wayHandle.remove();
            }
            //wire to system event
            var bindingSource = new EventSource({
                //listen to variable changes
                trigger: this.sourceevent,
                //the path to value, ie: 'item.value'
                path: this.sourceeventvaluepath,
                //add an event filter
                filters: [{
                    // variable title must match,ie: 'item.title'
                    path: this.sourceeventnamepath,
                    // the name of the variable, ie: 'Volume'
                    value: this.targetvariable
                }]
            });

            //now map the event source to a widget
            var bindingTarget = new WidgetTarget({
                //the path to value
                path: 'value',
                object: this._targetReference
            });
            this.binding = new Binding({
                source: bindingSource,
                target: bindingTarget
            });
            this.binding.start();
        },
        /**
         * Returns the widget whose DOM tree contains the specified DOMNode, or null if
         * the node is not contained within the DOM tree of any widget
         * @param {Element} node
         */
        getEnclosingWidget: function (node) {
            if (node) {
                do {
                    if (node.nodeType === 1 && node.render) {
                        return node;
                    }
                } while ((node = node.parentNode));
            }
            return null;
        },
        /**
         * Function to setup the target reference
         * on the surrounding widget!
         *
         */
        _setupTargetReference: function () {
            var i = 0,
                element = this,
                widget = null;

            while (i < 2 && !widget) {
                if (element) {
                    element = element.parentNode;
                    widget = this.getEnclosingWidget(element, "widgetId");
                    if (!widget) {
                        widget = this.getEnclosingWidget(element, "widgetid");
                    }
                }
                i++;
            }
            if (widget) {
                debugWidgets && console.info('have widget reference' + '  : ', widget);
                this.initWithReference(widget);
            } else {
                if (this.domNode && this.domNode.parentNode) {
                    this.initWithReference(this.domNode.parentNode);
                    debugWidgets && console.error('cant find widget reference, using parent node', this._targetReference);
                } else {
                    if (this.parentNode) {
                        this.initWithReference(this.parentNode);
                    }
                    debugWidgets && console.error('cant find widget reference', this);
                }

            }
        },
        /**
         * Required in case of dojoConfig.parseOnLoad
         * @param evt
         */
        onAppReady: function (evt) {
            debugApp && console.log('-ready');
            //resolve target reference
            if (!this._targetReference) {
                this._setupTargetReference();
            }
            //resolve target block
            if (!this._targetBlock) {
                this._setBlock(evt ? evt.context : null);
            }

            this.mode = this['bidirectional'] === true ? 0 : 1;
            //normal mode, allows 2-way binding
            if (this.mode === 0) {
                //resolve 2way binding
                if (this._targetBlock && this._targetReference && this['bidirectional'] === true && this.sourceevent && this.sourceevent.length) {
                    this._setup2WayBinding();
                }

                //if both are valid, run the the init procedure
                if (this._targetReference && this._targetBlock) {
                    this.onReady();
                }

            } else if (this.mode === 1 && this._targetBlock) {
                if (this._targetReference && this.sourceevent && this.sourceevent.length && this.targetproperty && this.targetproperty.length) {
                    this._setup1WayBinding();
                    if (this.binding) {
                        this.binding.start();
                    }
                }
            }
            //track context {xapp/manager/Context}
            if (evt && evt.context) {
                this.context = evt.context;
            }
        },
        detachedCallback: function () {
            debugAttach && console.info('detachedCallback', this);
            if (this._appContext) {
                this.destroy();
            }
        },
        /**
         * Delite created callback
         */
        createdCallback: function () {
            debugCreated && console.info('createdCallback', this);
        },
        /**
         * Delite attached callback
         */
        attachedCallback: function () {
            debugAttach && console.info('attachedCallback', this);
            if (this._started) {
                return;
            }
            this.initReload();
            this.subscribe(Types.EVENTS.ON_APP_READY);
            this._started = true;

        },
        detachCallback: function () {
        },
        render: function () {

        },
        postRender: function () {

        },
        startup: function () {
            debugAttach && console.log('startup');
            this.inherited(arguments);
            this.onAppReady();
            this.initReload();
            this.subscribe(Types.EVENTS.ON_APP_READY);

        }
    };

    //package and declare via dcl
    var _class = dcl([EventedMixin.dcl, ReloadMixin.dcl, Referenced.dcl], Impl);
    //static access to Impl.
    _class.Impl = Impl;
    return register("d-xscript", [HTMLElement, CustomElement, _class]);
});;
define('delite/handlebars!deliteful/Button/Button.html',["delite/handlebars"], function(handlebars){
	return handlebars.compile("<template attach-point=\"focusNode\" aria-label=\"{{label}}\">\n\t<span attach-point=\"iconNode\" class=\"d-icon {{this.iconClass || 'd-hidden'}}\" aria-hidden=\"true\"></span><span attach-point=\"labelNode\" d-shown=\"{{showLabel}}\">{{label}}</span>\n</template>");
});;
/** @module deliteful/Button */
define('deliteful/Button',[
	"dcl/dcl",
	"requirejs-dplugins/has",
	"delite/register",
	"delite/Widget",
	"requirejs-dplugins/has!bidi?./Button/bidi/Button",
	"delite/handlebars!./Button/Button.html",
	"delite/theme!./Button/themes/{{theme}}/Button.css"
], function (dcl, has, register, Widget, BidiButton, template) {

	/**
	 * A form-aware button widget.
	 * A Button can display a label, an icon, or both.  Icon is specified via the iconClass property that
	 * takes the name of the class to apply to the button node to display the icon.
	 * @example
	 * <style>
	 *   .iconForButton {
	 *     background-image: url('images/cut.png');
	 *     width: 16px;
	 *     height: 16px;
	 *   }
	 * </style>
	 * <button is="d-button" iconClass="iconForButton">Click Me</button>
	 * @class module:deliteful/Button
	 * @augments module:delite/Widget
	 */
	var Button = dcl(Widget, /** @lends module:deliteful/Button# */ {

		/**
		 * The text to display in the button.
		 * @member {string}
		 * @default ""
		 */
		label: "",

		/**
		 * The name of the CSS class to apply to DOMNode in button to make it display an icon.
		 * @member {string}
		 * @default ""
		 */
		iconClass: "",

		/**
		 * The name of the CSS class of this widget.
		 * @member {string}
		 * @default "d-button"
		 */
		baseClass: "d-button",

		/**
		 * If `true`, the button's label will be shown.
		 * @member {boolean}
		 * @default true
		 */
		showLabel: true,

		template: template,

		createdCallback: function () {
			// Get label from innerHTML, and then clear it since we are to put the label in a <span>
			if (!this.label) {
				this.label = this.textContent.trim();
				this.innerHTML = "";
			}
		},

		refreshRendering: function (props) {
			if (("label" in props || "showLabel" in props) &&
				(!this.title || this.title === ("label" in props ? props.label : this.label))) {
				this.title = this.showLabel ? "" : this.label;
			}
		}
	});

	var ButtonElt = register("d-button", has("bidi") ? [HTMLButtonElement, Button, BidiButton] :
		[HTMLButtonElement, Button]);
	ButtonElt.Impl = Button;
	return ButtonElt;
});
;
define('deliteful/Button/bidi/Button',["dcl/dcl", "dpointer/events"], function (dcl) {

	// module:
	//		deliteful/Button/bidi/Button

	return dcl(null, {
		// summary:
		//		Support for control over text direction for Button widget,
		//		using Unicode Control Characters to control text direction.
		// description:
		//		Implementation for text direction support for label and tooltip.
		//		This class should not be used directly.
		//		Button widget loads this module when user sets "has: {'bidi': true }" in data-dojo-config.

		refreshRendering: function (oldVals) {
			if ("textDir" in oldVals || "label" in oldVals) {
				this.labelNode.textContent = this.applyTextDirection(this.label);
			}
			if (this.title && "textDir" in oldVals) {
				this.title = this.applyTextDirection(this.title);
			}
		},
		
		postRender: function () {
			this.on("pointerover", this._pointerOverHandler.bind(this));
		},
		
		_pointerOverHandler: function () {
			if (this.title) {
				this.title = this.applyTextDirection(this.title);
			}
		}
	});
});
