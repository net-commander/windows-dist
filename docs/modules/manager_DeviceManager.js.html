<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Documentation Source: manager/DeviceManager.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.simplex.css">
	<link type="text/css" rel="stylesheet" href="styles/override.css">
	<link type="text/css" rel="stylesheet" href="styles/theme.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Documentation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-xcf_driver_DriverBase.html">xcf/driver/DriverBase</a></li><li><a href="module-xcf_manager_BeanManager.html">xcf/manager/BeanManager</a></li><li><a href="module-xcf_manager_DeviceManager.html">xcf/manager/DeviceManager</a></li><li><a href="module-xcf_manager_DeviceManager_DeviceServer.html">xcf/manager/DeviceManager_DeviceServer</a></li><li><a href="module-xide_manager_DeviceManager.html">xide/manager/DeviceManager</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-xcf.driver.DriverBase.html">xcf.driver.DriverBase</a></li><li><a href="module-xcf.manager.DeviceManager_DeviceServer.html">xcf.manager.DeviceManager_DeviceServer</a></li><li><a href="module-xcf_manager_Context.html">xcf/manager/Context</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#addDeviceInstance">addDeviceInstance</a></li><li><a href="global.html#appScope">appScope</a></li><li><a href="global.html#beanIconClass">beanIconClass</a></li><li><a href="global.html#completeDriver">completeDriver</a></li><li><a href="global.html#createDriverInstance">createDriverInstance</a></li><li><a href="global.html#createLeftView">createLeftView</a></li><li><a href="global.html#createRightView">createRightView</a></li><li><a href="global.html#defaultScope">defaultScope</a></li><li><a href="global.html#driverScopes">driverScopes</a></li><li><a href="global.html#editDriver">editDriver</a></li><li><a href="global.html#groupType">groupType</a></li><li><a href="global.html#insertIfMatch">insertIfMatch</a></li><li><a href="global.html#itemMetaPath">itemMetaPath</a></li><li><a href="global.html#itemMetaStorePath">itemMetaStorePath</a></li><li><a href="global.html#itemMetaTitleField">itemMetaTitleField</a></li><li><a href="global.html#itemType">itemType</a></li><li><a href="global.html#match">match</a></li><li><a href="global.html#newGroup">newGroup</a></li><li><a href="global.html#newItem">newItem</a></li><li><a href="global.html#nodeValuePath">nodeValuePath</a></li><li><a href="global.html#nodeValueTransform">nodeValueTransform</a></li><li><a href="global.html#onCreateVariableCI">onCreateVariableCI</a></li><li><a href="global.html#onDeviceMessage">onDeviceMessage</a></li><li><a href="global.html#onDeviceReady">onDeviceReady</a></li><li><a href="global.html#onMainViewReady">onMainViewReady</a></li><li><a href="global.html#onNewDriverScopeCreated">onNewDriverScopeCreated</a></li><li><a href="global.html#onReloaded">onReloaded</a></li><li><a href="global.html#onStoreReady">onStoreReady</a></li><li><a href="global.html#onWidgetReady">onWidgetReady</a></li><li><a href="global.html#registerEditorExtensions">registerEditorExtensions</a></li><li><a href="global.html#replaceWith">replaceWith</a></li><li><a href="global.html#setScriptFunctions">setScriptFunctions</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#systemScope">systemScope</a></li><li><a href="global.html#toPreferenceId">toPreferenceId</a></li><li><a href="global.html#updateItemMetaData">updateItemMetaData</a></li><li><a href="global.html#userScope">userScope</a></li><li><a href="global.html#variables">variables</a></li>
				</ul>
			</li>
			
		</ul>
		<div class="col-sm-3 col-md-3">
            <form class="navbar-form" role="search">
                <div class="input-group">
                    <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                    <div class="input-group-btn">
                        <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                    </div>
                </div>
            </form>
        </div>
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: manager/DeviceManager.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/** @module xcf/manager/DeviceManager */
define([
    'dcl/dcl',
    "xdojo/declare",
    "dojo/_base/lang",
    'xide/encoding/MD5',
    'xide/types',
    'xide/utils',
    'xide/factory',
    'xcf/manager/BeanManager',
    'xide/mixins/ReloadMixin',
    'xide/mixins/EventedMixin',
    './DeviceManager_Server',
    './DeviceManager_DeviceServer',
    'xide/data/TreeMemory',
    'dojo/has',
    'xide/data/ObservableStore',
    'dstore/Trackable',
    'xcf/model/Device',
    'dojo/Deferred',
    "xide/manager/ServerActionBase",
    "xide/data/Reference",
    'xide/utils/StringUtils',
    'xdojo/has!xcf-ui?./DeviceManager_UI',
    'xdojo/has!xexpression?xexpression/Expression',
    'xdojo/has!host-node?nxapp/utils/_console',
    "xdojo/has!host-node?nxapp/utils"
], function (dcl,declare, lang, MD5,
             types, utils, factory, BeanManager, ReloadMixin, EventedMixin,
             DeviceManager_Server, DeviceManager_DeviceServer,TreeMemory,has,
             ObservableStore,Trackable,Device,Deferred,ServerActionBase,Reference,StringUtils,
             DeviceManager_UI,Expression,_console,xUtils) {



    var console = typeof window !== 'undefined' ? window.console : console;
    if(_console &amp;&amp; _console.error &amp;&amp; _console.warn){
        console = _console;
    }

    var bases = [
        ServerActionBase,
        BeanManager,
        DeviceManager_Server,
        DeviceManager_DeviceServer,
        ReloadMixin.dcl
    ],
    _debugMQTT = false,
    _debug = false,
    _debugConnect = true,
    isServer = !has('host-browser'),
    isIDE = has('xcf-ui'),
    DEVICE_PROPERTY = types.DEVICE_PROPERTY,
    EVENTS = types.EVENTS;
    has('xcf-ui') &amp;&amp; bases.push(DeviceManager_UI);
/*
    console.error('has ide : ' + isIDE);
    console.error('is server : ' + isServer);
    console.error('has drivers : ' + has('drivers'));
    console.error('has devices : ' + has('devices'));

    */
    /**
     * Common base class, for server and client.
     * @class module:xcf/manager/DeviceManager
     * @augments module:xide/mixins/EventedMixin
     * @extends module:xcf/manager/BeanManager
     */
    return dcl(bases,{
        declaredClass:"xcf.manager.DeviceManager",
        /***
         * The Bean-Manager needs a unique name of the bean:
         * @private
         */
        beanNamespace: 'device',
        /***
         * The Bean-Manager has some generic function like creating Dialogs for adding new items, please
         * provide a title for the interface.
         * @private
         */
        beanName: 'Device',
        /**
         * the icon class for bean edit views
         * @private
         */
        beanIconClass:'fa-sliders',
        /**
         * Bean group type
         * @private
         */
        groupType:types.ITEM_TYPE.DEVICE_GROUP,
        /**
         * Bean item type
         * @private
         */
        itemType:types.ITEM_TYPE.DEVICE,
        /**
         * The name of the CI in the meta database for the title or name.
         * @private
         */
        itemMetaTitleField:DEVICE_PROPERTY.CF_DEVICE_TITLE,
        /**
         * Name of the system scope
         * @private
         */
        systemScope:'system_devices',
        /**
         * Name of the user scope
         * @private
         */
        userScope:'user_devices',
        /**
         * Name of the app scope
         * @private
         */
        appScope:'app_devices',
        /**
         * Name of the default scope for new created items
         * @private
         */
        defaultScope:'system_devices',
        /***
         * The RPC server class:
         * @private
         */
        serviceClass: 'XCF_Device_Service',
        /***
         * A copy of all devices raw data from the server
         * @private
         */
        rawData: null,
        /***
         * @type {module:xcf/data/Store}
         * @private
         */
        store: null,
        /***
         * {xcf.views.DevicesTreeView}
         * @private
         */
        treeView: null,
        /***
         * {xide.client.WebSocket}
         */
        deviceServerClient: null,
        /***
         *  An array of started device instances.
         *  @private
         */
        deviceInstances: null,
        /***
         *  A map of scope names for module hot reloading
         *  @private
         */
        driverScopes: null,
        /***
         * autoConnectDevices does as it says, on app start, it connects to all known devices of the
         * project
         * @param autoConnectDevices
         * @private
         */
        autoConnectDevices: true,
        /**
         * Consoles is an array of {xide.views.ConsoleViews}. There is one console per device possible
         * @private
         */
        consoles: null,
        /**
         * lastUpTime is being used to recognize a computer suspend hibernate
         * @private
         */
        lastUpTime: null,
        /**
         * @private
         */
        reconnectDevice: 5000,
        /**
         * @private
         */
        reconnectDeviceServer: 5000,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Device-Related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         * Make sure we've a connection to our device-server
         * @private
         */
        checkDeviceServerConnection: function () {
            if (!this.deviceServerClient) {
                var store = this.ctx.getNodeServiceManager().getStore();
                if (!store) {
                    console.error('checkDeviceServerConnection : have no service store');
                    return false;
                }
                this.createDeviceServerClient(store);
            }
            return true;
        },
        /**
         *
         * @param target
         * @param source
         * @private
         */
        addDriverFunctions: function (target, source) {
            for (var i in source) {

                if (i === 'constructor' ||
                    i === 'inherited' ||
                    i == 'getInherited' ||
                    i == 'isInstanceOf' ||
                    i == '__inherited' ||
                    i == 'onModuleReloaded' ||
                    i == 'start' ||
                    i == 'publish' ||
                    i == 'subscribe' ||
                    i == 'getInherited' ||
                    i == 'getInherited'
                ) {
                    continue;
                }
                if (_.isFunction(source[i]) &amp;&amp; !target[i]) {
                    target[i] = source[i];//swap
                }
            }
        },
        /**
         *
         * @param driver
         * @param instance
         * @private
         */
        addLoggingFunctions: function (driver, instance) {
            var thiz = this;
            instance.log = function (level, type, message, data) {
                data = data || {};
                var oriData = lang.clone(data);
                data.type = data.type || type || 'Driver';
                if (instance.options) {
                    data.device = instance.options;
                }
                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                    data: data,
                    level: level || 'info',
                    message: message,
                    details:oriData
                });
            }
        },
        /**
         * An instance of a driver class has been created.
         * We mixin new functions: callCommand, set/get-Variable, log
         * @param driver
         * @param instance
         * @param device
         * @private
         */
        completeDriverInstance: function (driver, instance,device) {

            var thiz = this;

            _debug &amp;&amp; console.info('complete driver instance');

            var scope = instance.blockScope,
                store = scope.blockStore,
                parentId = device.path;

            var commandsRoot = parentId + '_commands';
            var variablesRoot = parentId + '_variables';

            store.on('delete',function(evt){

                var _isVariable = evt.target.declaredClass.indexOf('Variable') !==-1,
                    _parent = _isVariable  ? variablesRoot : commandsRoot,
                    referenceParent = device._store.getSync(_parent);

                if(referenceParent){
                    referenceParent.refresh();
                }

                var referenceId = _parent + '_reference_'+evt.target.id,
                    reference  = device._store.getSync(referenceId);

                if(reference){
                    reference.refresh();
                }
            });

            function createReference(block,driver,title,icon){
                var _isVariable = block.declaredClass.indexOf('Variable') !==-1;
                var _parent = _isVariable  ? variablesRoot : commandsRoot;
                if(block.declaredClass.indexOf( _isVariable? 'Variable' : 'Command')==-1){
                    return;
                }

                var reference  = new Reference({
                    enabled:true,
                    path: _parent + '_reference_'+block.id,
                    name: title,
                    id: block.id,
                    parentId: _parent,
                    _mayHaveChildren: false,
                    virtual: true,
                    tooltip: true,
                    icon:icon,
                    ref: {
                        driver: driver,
                        item: block,
                        device:device
                    },
                    type: types.ITEM_TYPE.BLOCK
                });

                reference = device._store.putSync(reference);

                block.addReference(reference,{
                    properties: {
                        "name":true,
                        "enabled":true,
                        "value":true
                    },
                    onDelete:true
                },true);

                reference.refresh();
            }

            store.on('added',function(block){
                createReference(block,driver,block.name,block.icon || 'fa-exclamation');
            });

            /**
             * Add 'callCommand'
             * @param title
             */
            instance.callCommand = function (title) {
                var _block = this.blockScope.getBlockByName(title);
                if (_block) {
                    _block.solve(this.blockScope);
                }
            };

            /**
             * Add 'setVariable'
             * @param title
             * @param value
             */
            instance.setVariable = function (title, value, save) {
                var _variable = this.blockScope.getVariable(title);
                if (_variable) {
                    _variable.value = value;
                    _variable.set('value',value);
                } else {
                    _debug &amp;&amp;  console.log('no such variable : ' + title);
                    return;
                }
                thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, {
                    item: _variable,
                    scope: this.blockScope,
                    driver: driver,
                    owner: thiz,
                    save: save === true
                });
            };

            /**
             * Add getVariable
             * @param title
             */
            instance.getVariable = function (title) {
                var _variable = this.blockScope.getVariable(title);
                if (_variable) {
                    return _variable.value;
                }
                return '';
            };

            instance.log = function (level, type, message, data) {

                data = data || {};
                var oriData = lang.clone(data);
                data.type = data.type || type || 'Driver';
                if (instance.options) {
                    data.device = instance.options;
                }
                thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, {
                    data: data,
                    level: level || 'info',
                    message: message,
                    details:oriData
                });
            };


            for (var i in driver) {

                if (i === 'constructor' ||
                    i === 'inherited' ||
                    i == 'getInherited' ||
                    i == 'isInstanceOf' ||
                    i == '__inherited' ||
                    i == 'onModuleReloaded' ||
                    i == 'start' ||
                    i == 'publish' ||
                    i == 'subscribe' ||
                    i == 'getInherited' ||
                    i == 'getInherited'
                ) {
                    continue;
                }
                if (lang.isFunction(driver[i]) &amp;&amp; !instance[i] /*&amp;&amp; lang.isFunction(target[i])*/) {
                    instance[i] = driver[i];//swap
                }
            }
        },
        /**
         * Callback when we are connected to a device.
         * We use this to fire all looping blocks
         * @param driverInstance {module:xcf/driver/DriverBase} the instance of the driver
         * @param deviceStoreItem {module:xcf/model/Device} the device model item
         * @param driver {module:xcf/model/Driver} the driver model item
         */
        onDeviceStarted: function (driverInstance, deviceStoreItem, driver) {

            _debug &amp;&amp; console.log('onDeviceStarted');

            if (!driverInstance || !deviceStoreItem || !driver) {
                _debug &amp;&amp; console.log('onDeviceStarted failed, invalid params');
                return;
            }

            var info = this.toDeviceControlInfo(deviceStoreItem),
                serverSide = info.serverSide;


            /**
             * Post work :
             * 1. Start all commands with the 'startup' flag!
             * 2. Todo : update last variables from Atomize server
             * 3. Establish long polling
             */

            //1. fire startup blocks
            var blockScope = driverInstance.blockScope;// ctx.getBlockManager().getScope(driver.id);

            if( (isServer &amp;&amp; serverSide) || (!serverSide &amp;&amp; !isServer)) {

                var autoBlocks = [];

                var initBlocks = blockScope.getBlocks({
                    group: types.COMMAND_TYPES.INIT_COMMAND
                });

                _.invoke(initBlocks,'solve',blockScope);

                autoBlocks = autoBlocks.concat(blockScope.getBlocks({
                    group: types.COMMAND_TYPES.BASIC_COMMAND,
                    startup: true
                }));

                autoBlocks = autoBlocks.concat(blockScope.getBlocks({
                    group: types.COMMAND_TYPES.CONDITIONAL_COMMAND,
                    startup: true
                }));

                for (var i = 0; i &lt; autoBlocks.length; i++) {
                    _debug &amp;&amp; console.log('fire command ' + autoBlocks[i].name);
                    autoBlocks[i].solve(blockScope);
                }

                //2. fire long polling commands

                var pollingBlocks = autoBlocks.concat(blockScope.getBlocks({
                    group: types.COMMAND_TYPES.BASIC_COMMAND,
                    auto: /^[1-9][0-9]*$/
                }));

                pollingBlocks = pollingBlocks.concat(blockScope.getBlocks({
                    group: types.COMMAND_TYPES.CONDITIONAL_COMMAND,
                    auto: /^[1-9][0-9]*$/
                }));

                for (var i = 0; i &lt; pollingBlocks.length; i++) {
                    var _block = pollingBlocks[i];
                    if (_block.auto == true &amp;&amp; _block.interval > 1) {
                        blockScope.loopBlock(_block);
                    }
                }

                this.publish(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, {
                    device: deviceStoreItem,
                    instance: driverInstance,
                    driver: driver,
                    blockScope: blockScope
                });

            }
            driverInstance.__didStartBlocks = true;
            this.ctx.getDriverManager().addDeviceInstance(deviceStoreItem,driver);

        },
        /**
         * Creates a driver instance per device
         * @param deviceInfo {module:xide/types~DeviceInfo} The device info
         * @param driverBase {module:xcf/driver/DriverBase} The driver base class
         * @param device {module:xcf/model/Device} The device model item
         */
        createDriverInstance: function (deviceInfo, driverBase, device) {

            var hash = MD5(JSON.stringify(deviceInfo), 1),
                driverPrefix = this.driverScopes[deviceInfo.scope],
                requirePath = driverPrefix + deviceInfo.driver;//xcfnode/data/driver/system/Marantz/MyMarantz.js

            requirePath = requirePath.replace('.js', '');

            var thiz = this,
                ctx = thiz.ctx,
                meta = device['user'],
                driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                driverManager = ctx.getDriverManager(),
                driver = driverManager.getItemById(driverId),
                dfd = new Deferred(),
                enabled = device.getMetaValue(DEVICE_PROPERTY.CF_DEVICE_ENABLED),
                serverSide = deviceInfo.serverSide;

            if(device.isEnabled()===false){
                _debug &amp;&amp; console.warn('device not enabled, abort ' + deviceInfo.toString());
                setTimeout(function(){
                    dfd.reject();
                });
                return dfd;
            }

            if(isServer &amp;&amp; !device.isServerSide()){
                dfd.reject();
                return dfd;
            }


            _debugConnect &amp;&amp; console.info('------create driver instance with DriverBase at '+requirePath + ' with driver prefix : ' + driverPrefix,this.driverScopes);

            try {
                require([requirePath], function (driverProtoInstance) {

                    var baseClass = driverBase,
                        baseClasses = [baseClass],
                        driverProto = declare([baseClass, EventedMixin, ReloadMixin], driverProtoInstance.prototype),
                        driverInstance = new driverProto();

                    driverInstance.declaredClass = requirePath;
                    driverInstance.options = deviceInfo;
                    driverInstance.baseClass = baseClass.prototype.declaredClass;
                    driverInstance.modulePath = utils.replaceAll('//', '/', requirePath);
                    driverInstance.delegate = thiz;
                    driverInstance.driver = driver;
                    driverInstance.serverSide = deviceInfo.serverSide;


                    try {
                        driverInstance.start();
                        driverInstance.initReload();
                    } catch (e) {
                        console.error('crash in driver instance startup! ' + device.toString());
                    }


                    //console.log('add instances');
                    thiz.deviceInstances[hash] = driverInstance;
                    // Build an id basing on : driver id + driver path
                    // "235eb680-cb87-11e3-9c1a-....ab5_Marantz/Marantz.20.meta.json"
                    var scopeId = driverId + '_' + hash + '_' + device.path;


                    if (!driver.blox || !driver.blox.blocks) {
                        _debugConnect &amp;&amp; console.error('Attention : INVALID driver', [device, driver]);
                        driver.blox = {
                            blocks: []
                        }
                    }

                    if (isServer &amp;&amp; driver.blockPath) {
                        var newBlocks = StringUtils.getJson(xUtils.readFile(driver.blockPath));
                        newBlocks = driver.blox = StringUtils.getJson(xUtils.readFile(driver.blockPath));
                    }

                    var scope = ctx.getBlockManager().createScope({

                        id: scopeId,
                        device: device,
                        driver: driver,
                        instance: driverInstance,
                        serviceObject: thiz.serviceObject,
                        ctx: ctx,
                        serverSide: serverSide,
                        getContext: function () {
                            return this.instance;
                        }

                    }, dojo.clone(driver.blox.blocks));

                    //important:
                    driverInstance.blockScope = scope;

                    device.blockScope = scope;
                    device.driverInstance = driverInstance;

                    thiz.getDriverInstance(deviceInfo, true);//triggers to resolve settings

                    //add variable &amp;&amp; command functions:
                    isIDE &amp;&amp; thiz.completeDriverInstance(driver, driverInstance, device);
                    dfd.resolve(driverInstance);

                    return driverInstance;

                });
            }catch(e){
                console.error('DeviceManager::createDriverInstance:: requiring base driver at ' + requirePath + ' failed',e);
            }
            return dfd;
        },
        getDevice:function(mixed){
            var result = mixed;
            if(_.isString(mixed)){
                var byId = this.getItemById(mixed);
                if(byId){
                    result = byId;
                }else{
                    var byPath = this.store.getSync(mixed);
                    if(byPath){
                        result = byPath;
                    }
                }
            }
            return result;
        },
        /**
         * Stops a device with a device model item
         * @param item {module:xcf/model/Device|string}
         */
        stopDevice: function (item) {
            item = this.getDevice(item) || item;
            if(!item){
                console.error('cant find device');
                return;
            }
            this.checkDeviceServerConnection();

            item._userStopped = true;

            var cInfo = this.toDeviceControlInfo(item);
            if(!cInfo){
                console.error('cant find device::no device info',item.toString &amp;&amp; item.toString());
                return;
            }

            if(isServer &amp;&amp; !cInfo.serverSide){
                return;
            }

            cInfo['clientSide'] = true;

            var hash = MD5(JSON.stringify(cInfo), 1);
            if (this.deviceInstances[hash]) {
                this._removeInstance(this.deviceInstances[hash], hash,item);
                delete this.deviceInstances[hash];
                _debugConnect &amp;&amp; console.log('-- stop device ' + hash,this.deviceInstances);

            }else{
                _debugConnect &amp;&amp; console.log('cant find instance ' + hash);
            }

            !isServer &amp;&amp; this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_STOP_DRIVER, cInfo);

        },
        /**
         * Get all enabled devices
         * @param enabledOnly
         * @param addDriver
         * @returns {module:xcf/model/Device[]}
         */
        getDevices: function (enabledOnly,addDriver) {
            var store = this.getStore();
            if(!store){
                return [];
            }
            var items = utils.queryStore(store, {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }

            var result = [];
            for (var i = 0; i &lt; items.length; i++) {

                var device = items[i],
                    enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);

                if ((enabledOnly === true &amp;&amp; enabled == true || enabled == null) || enabledOnly === false) {
                    result.push(device);

                    if(addDriver==true) {
                        var driverId = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                        if (!driverId) {
                            console.error('device has no driver id!');
                            continue;
                        }
                        var driver = this.ctx.getDriverManager().getItemById(driverId);
                        if (driver){
                            device['driver'] = driver;
                        }
                    }
                }
            }
            return result;
        },
        /**
         * Connect to all known devices
         * @private
         */
        connectToAllDevices: function () {
            var store = this.getStore(),
                thiz = this;

            if(!store){
                console.error('have no device store');
                return;
            }

            var items = utils.queryStore(store, {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }


            var _start = function (device) {
                thiz.startDevice(device);
            };

            for (var i = 0; i &lt; items.length; i++) {
                var device = items[i];
                var enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED);
                if (enabled == true || enabled == null) {
                    _start(device);
                }
            }
        },
        /**
         *
         * @private
         */
        _getLogText: function (str) {
            return moment().format("HH:mm:SSS") + ' ::   ' + str + '';
        },
        _parse: function (scope, expression) {


            var str = '' + expression;

            if (str.indexOf('{{') > 0 || str.indexOf('}}') > 0) {
                console.time('parse expression');
                var _parser = new Expression();
                str = _parser.parse(types.EXPRESSION_PARSER.FILTREX,
                    str, this,
                    {
                        variables: scope.getVariablesAsObject(),
                        delimiters: {
                            begin: '{{',
                            end: '}}'
                        }
                    }
                );
                console.timeEnd('parse expression');
            }else{
                var _text = scope.parseExpression(expression);
                if(_text){
                    str = _text;
                }
            }

            //var pattern = "([-+]?[0-9]*\.?[0-9]+[\/\+\-\*])+([-+]?[0-9]*\.?[0-9]+)";
            //pattern = "(?[0-9])";
            //var out = str.match(new RegExp(/[d()+-*],"g"));
            //var out = str.match(/[\d\(\)\+\-\*\/\.]+/g);
            //var numbers = str.match(/[0-9()+\-*/.]/g).join('');
            //console.log('out : '  + numbers );
            /*
             var _text = scope.parseExpression(expression);
             if(_text){
             str = _text;
             }
             */
            return str;
        },
        /**
         *
         * @param driver
         * @param device
         * @private
         */
        runCommand: function (driver, device) {},
        /**
         * @private
         */
        _lastActions: null,
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Data related
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param rawData
         * @private
         */
        onStoreReloaded: function (rawData) {
            this.completeDeviceStore();
        },
        getInstance:function(mixed){
            var deviceInfo = mixed ? mixed._store ? this.toDeviceControlInfo(mixed) : mixed : null;
            if(!deviceInfo){
                return;
            }
            return this.getDriverInstance(deviceInfo,false);
        },
        /***
         * returns driver instance!
         * @param deviceInfo {module:xide/types~DeviceInfo}
         * @param fillSettings will convert and put CI settings into the driver's instance (member variable)
         * @returns {module:xcf/driver/DriverBase}
         * @private
         */
        getDriverInstance: function (deviceInfo, fillSettings) {


            if (!deviceInfo) {
                console.error('getDriverInstance::have no device info')
                return null;
            }
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];
                var instanceOptions = instance.options;
                if(!instanceOptions){
                    continue;
                }

                if (instanceOptions.port === deviceInfo.port &amp;&amp;
                    instanceOptions.host === deviceInfo.host &amp;&amp;
                    instanceOptions.protocol === deviceInfo.protocol) {

                    if (fillSettings !== false) {
                        //get settings, if not cached already
                        if (instance &amp;&amp; !instance.sendSettings) {
                            //pick driver
                            var driver = this.ctx.getDriverManager().getItemById(deviceInfo.driverId);//driverStore item
                            if (driver) {
                                var meta = driver['user'];
                                var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                                if (commandsCI &amp;&amp; commandsCI['params']) {
                                    instance.sendSettings = utils.getJson(commandsCI['params']);
                                }

                                var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                                if (responseCI &amp;&amp; responseCI['params']) {
                                    instance.responseSettings = utils.getJson(responseCI['params']);
                                }
                            }else{
                                _debug &amp;&amp; console.warn('getDriverInstance:: cant find driver');
                            }
                        }
                    }
                    return instance;
                }
            }
            return null;
        },
        _reconnectServerTimer:null,
        /**
         * @private
         */
        onDeviceServerConnectionLost:function(){

            if (this.deviceServerClient) {
                this.deviceServerClient.destroy();
                this.deviceServerClient = null;
            }

            if(this._reconnectServerTimer){
                return;
            }

            var thiz = this;
            if(isIDE) {
                thiz.ctx.getNotificationManager().postMessage({
                    message: 'Lost connection to device server, try reconnecting in 5 seconds',
                    type: 'error',
                    showCloseButton: true,
                    duration: 3000
                });
            }

            this._reconnectServerTimer = setTimeout(function(){
                thiz.checkDeviceServerConnection();
                thiz._reconnectServerTimer=null;
            },this.reconnectDeviceServer);
        },
        /**
         *
         * @param msg
         * @private
         */
        onMQTTMessage:function(msg){

            var message=utils.getJson(msg.message);

            var isUs =false;

            if(message){
                var sourceHost = message.sourceHost;
                var sourcePort = message.sourcePort;

                var mqttHost = msg.host;
                var mqttPort = msg.port;

                if(sourceHost &amp;&amp; sourcePort){
                    if(sourceHost===mqttHost &amp;&amp; sourcePort==mqttPort){
                        isUs=true;
                    }
                }
            }

            if(!isUs) {

                _debugMQTT &amp;&amp; console.error('on mqtt message ', [message, msg]);
                //
                var parts=msg.topic.split('/');

                //"192.168.1.20/23/Variable/Volume"

                if(parts.length==4 &amp;&amp; parts[2]=='Variable'){
                    var _device = this.getDeviceByHost(parts[0],parts[1]);
                    if(_device){
                        _debugMQTT &amp;&amp; console.error(' on mqtt variable topic ' + msg.topic);
                        var _deviceInfo = this.toDeviceControlInfo(_device);
                        if(_deviceInfo){
                            var driverInstance = this.getDriverInstance(_deviceInfo);
                            if(driverInstance){
                                var scope = driverInstance.blockScope;
                                var _variable = scope.getVariable(parts[3]);
                                if(_variable){
                                    _debugMQTT &amp;&amp; console.error('     received MQTT variable ' +_variable.name + ' = ' +message.value);
                                    _variable.set('value',message.value);
                                    _variable.refresh();
                                }
                                //var variable = getVariable
                            }else{
                                _debugMQTT &amp;&amp; console.error('cant find driver instance '+msg.topic);
                            }
                        }else{
                            _debugMQTT &amp;&amp; console.error('cant find device info');
                        }
                    }else{
                        console.error('cant find device for : ' + msg.topic);
                    }
                }
            }else{
                _debugMQTT &amp;&amp; console.error('same source');
            }
        },
        /**
         * Find a block by url in all instances
         * @param url
         * @returns {*}
         */
        getBlock:function(url){

            for (var id in this.deviceInstances) {
                var instance = this.deviceInstances[id];
                var scope = instance.blockScope;
                var block = scope.resolveBlock(url);
                if(block){
                    return block;
                }
            }
            return this.ctx.getDriverManager().getBlock(url);
        },
        /***
         * Callback when the NodeJS service manager initialized its service store. That may
         * happen multiple times as user can reload the store.
         *
         * @param evt
         * @private
         */
        onNodeServiceStoreReady: function (evt) {

            if (this.deviceServerClient) {
                this.deviceServerClient.destroy();
            }
            var store = evt.store,thiz = this;
            var client = this.createDeviceServerClient(store);
            var connect = has('drivers') &amp;&amp; has('devices');
            /*
            if(client &amp;&amp; client.dfd){
                thiz.connectToAllDevices();
                client.dfd.then(function(){
                    thiz.connectToAllDevices();
                });
            }else {
                */
                if (this.autoConnectDevices &amp;&amp; connect) {
                    setTimeout(function () {
                        thiz.connectToAllDevices();
                    }, 5000);
                }
            /*}*/
        },
        /**
         *
         * @param instance
         * @param modulePath
         * @private
         */
        onDriverUpdated: function (instance, modulePath) {
            return;
            /*
            var scope = this.ctx.getBlockManager().getScope(instance.id);
            if (scope) {
                xlog('Did update driver code : ' + modulePath);
                scope.clearCache();
            }
            */
        },
        /**
         * Some file has changed, update driver instance
         * @param evt
         * @private
         */
        onModuleReloaded: function (evt) {

            if (this.deviceInstances.length == 0) {//nothing to do
                return;
            }
            var modulePath = utils.replaceAll('//', '/', evt.module);
            var newModule = evt.newModule;
            var found = false;
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];

                if (instance.modulePath === modulePath ||
                    instance.baseClass === modulePath) {
                    this.mergeFunctions(instance, newModule.prototype);
                    found = true;
                    _debug &amp;&amp; console.log('Did update driver code : ' + modulePath,newModule.prototype);
                    if (instance.blockScope) {
                        instance.blockScope.expressionModel.expressionCache = {};
                    }
                    this.onDriverUpdated(instance, modulePath);
                }
            }
        },
        /**
         *
         * @param instance
         * @param hash
         * @param device
         * @private
         */
        _removeInstance: function (instance, hash,device) {

            if (instance.destroy) {
                instance.destroy();
            }
            instance.blockScope &amp;&amp; instance.blockScope._destroy();
            delete this.deviceInstances[hash];
            this.ctx.getBlockManager().removeScope(instance.options.id);
            this.ctx.getDriverManager().removeDriverInstance(instance,device);
            device.reset();
        },
        /**
         *
         * @param deviceInfo
         * @private
         */
        removeDriverInstance: function (deviceInfo) {

            var instance = this.getDriverInstance(deviceInfo);
            if(instance){
                this.ctx.getBlockManager().removeScope(instance.options.id);
                if(instance.blockScope){
                    instance.blockScope.destroy();
                }
                instance.destroy();
            }else{
                _debugConnect &amp;&amp; console.error('remove instance : cant find!');
            }
            for (var i in this.deviceInstances) {
                if(instance == this.deviceInstances[i]){
                    delete this.deviceInstances[i];
                }
            }
        },
        /**
         *
         * @param item {module:xcf/model/Device} the device
         * @param name {string} the name of the CI
         * @returns {string|int|object|null}
         */
        getMetaValue: function (item, name) {
            var meta = item['user'];
            if (meta) {
                return utils.getCIInputValueByName(meta, name);
            }
            return null;
        },
        /**
         * Return device by host and port
         * @param host {string}
         * @param port {string}
         * @returns {module:xcf/model/Device|null}
         */
        getDeviceByHost: function (host,port) {

            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });

            for (var i = 0; i &lt; items.length; i++) {
                var device = items[i];
                var _host = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_HOST);
                var _port = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_PORT);
                if(_host ==host &amp;&amp; _port == port){
                    return device;
                }
            }
            return null;
        },
        /**
         * Returns a device by id
         * @param id {string}
         * @returns {module:xcf/model/Device|null}
         */
        getDeviceById: function (id) {

            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }
            for (var i = 0; i &lt; items.length; i++) {
                var device = items[i];
                var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                if(_id == id){
                    return device;
                }
            }
            return null;
        },
        /**
         * Returns all devices by driver id
         * @param id {string} the driver id
         * @returns {module:xcf/model/Device[]}
         */
        getDevicesByDriverId: function (id) {

            var items = utils.queryStore(this.getStore(), {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }
            for (var i = 0; i &lt; items.length; i++) {
                var device = items[i];
                var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID);
                if(_id == id){
                    return device;
                }
            }
            return null;
        },
        getDeviceStoreItem: function (deviceInfo) {

            var store = this.getStore();
            if(!store){
                return;
            }

            var items = utils.queryStore(store, {
                isDir: false
            });
            if (items._S) {
                items = [items];
            }
            for (var i = 0; i &lt; items.length; i++) {

                var device = items[i],
                    meta = device['user'],
                    host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                    port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                    protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);

                if (port === deviceInfo.port &amp;&amp;
                    host === deviceInfo.host &amp;&amp;
                    protocol === deviceInfo.protocol) {
                    return device;
                }
            }
        },
        /**
         *
         * @param ci
         * @param storeRef
         * @private
         */
        onDriverSettingsChanged: function (ci, storeRef) {
            for (var i in this.deviceInstances) {

                var instance = this.deviceInstances[i];
                //get settings, if not cached already
                if (instance &amp;&amp; instance.driver == storeRef) {
                    //pick driver
                    var driver = storeRef;// this.ctx.getDriverManager().getItemById(instance.options.id);//driverStore item
                    var meta = driver['user'];
                    var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS);
                    if (commandsCI &amp;&amp; commandsCI['params'] &amp;&amp; commandsCI == ci) {
                        instance.sendSettings = utils.getJson(commandsCI['params']);
                    }
                    var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES);
                    if (responseCI &amp;&amp; responseCI['params']) {
                        instance.responseSettings = utils.getJson(responseCI['params']);
                    }
                    break;
                }
            }
        },
        /**
         * @private
         */
        onDeviceStateChanged: function (item,silent) {

            if(item._userStopped !==true &amp;&amp;  silent!==true &amp;&amp; item.info &amp;&amp; item.state &amp;&amp; item.state ==types.DEVICE_STATE.DISCONNECTED){

                this.ctx.getNotificationManager().postMessage({
                    message:'Lost connection to ' + item.info.host + ', ...reconnecting',
                    type:'error',
                    showCloseButton: false,
                    duration:1500
                });
            }
            if(silent!==true &amp;&amp; item.info &amp;&amp; item.state &amp;&amp; item.state ==types.DEVICE_STATE.CONNECTED){

                this.ctx.getNotificationManager().postMessage({
                    message:'Connected to ' + item.info.host + '',
                    type:'success',
                    showCloseButton: false,
                    duration:2000
                });
            }
        },
        /**
         *
         * @param item
         * @returns {*}
         * @private
         */
        connectDevice:function(item){

            this.checkDeviceServerConnection();
            var cInfo = this.toDeviceControlInfo(item);
            cInfo['clientSide'] = true;
            if (!cInfo) {
                console.error('couldnt start device, invalid control info');
                return;
            }

            var hash = MD5(JSON.stringify(cInfo), 1);
            if (this.deviceInstances[hash]) {
                console.log('device already connected', cInfo);
                item.setState(types.DEVICE_STATE.CONNECTED);
                return this.deviceInstances[hash];
            }
            item.setState(types.DEVICE_STATE.CONNECTING);
            this.publish(types.EVENTS.ON_STATUS_MESSAGE,{
                text:'Trying to connect to ' + cInfo.toString(),
                type:'info'
            });

            this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo);
        },
        /**
         * client application ready, mixin instances and block scopes
         * @param evt
         * @private
         */
        onAppReady: function (evt) {
            var appContext = evt.context;
            appContext.deviceManager = this;
            appContext.driverManager = this;
            if (appContext.blockManager) {
                utils.mixin(appContext.blockManager.scopes, this.ctx.getBlockManager().scopes);
            }
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods (NodeJs)
        //
        /////////////////////////////////////////////////////////////////////////////////////

        /**
         * @private
         */
        onHaveNoDeviceServer:function(){

            var thiz = this;
            var msg = this.ctx.getNotificationManager().postMessage({
                message:'Have no device server connection',
                type:'error',
                showCloseButton: true,
                duration:1500,
                actions: {
                    reconnect: {
                        label: 'Reconnect',
                        action: function() {
                            thiz.checkDeviceServerConnection();
                            return msg.update({
                                message: 'Reconnecting...',
                                type: 'success',
                                actions: false,
                                duration:1500
                            });
                        }
                    }
                }
            });
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Server methods (PHP)
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param options
         * @param readyCB
         * @param errorCB
         * @returns {*}
         * @private
         */
        createItem: function (options, readyCB, errorCB) {
            return this.callMethodEx(null, 'createItem', [dojo.toJson(options)], readyCB, true);
        },
        /***
         * setDriverScriptContent is storing a driver's actual code in a given scope on the server
         * @param scope {string}
         * @param path  {string}
         * @param content  {string}
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @returns {*}
         * @private
         */
        setDriverScriptContent: function (scope, path, content, readyCB, errorCB) {
            return this.callMethodEx(null, 'setDriverContent', [scope, path, content], readyCB, true);
        },
        /***
         * getDriverScriptContent is receiving a driver's actual code in a given scope
         * @param scope {string}
         * @param path  {string}
         * @param readyCB   {function}
         * @param errorCB   {function}
         * @returns {*}
         */
        getDriverScriptContent: function (scope, path, readyCB, errorCB) {
            return this.callMethodEx(null, 'getDriverContent', [scope, path], readyCB, true);
        },
        /**
         *
         * @param data
         * @returns {exports|module.exports|module:xcf/data/Store}
         * @private
         */
        initStore: function (data) {

            var storeClass = declare('deviceStore',[TreeMemory,Trackable,ObservableStore],{});
            var store = new storeClass({
                data: data.items,
                idProperty: 'path',
                Model:Device,
                id:utils.createUUID(),
                observedProperties:[
                    "name",
                    "state",
                    "iconClass",
                    "enabled"
                ]
            });

            this.store = store;

            this.onStoreReady();
            return this.store;
        },
        /////////////////////////////////////////////////////////////////////////////////////
        //
        //  Utils
        //
        /////////////////////////////////////////////////////////////////////////////////////
        /**
         *
         * @param item
         * @private
         */
        fixDeviceCI:function(item){

            var meta = item['user'];
            var driverOptions= utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS);
            if(!driverOptions) {
                meta.inputs.push({
                    "chainType": 0,
                    "class": "cmx.types.ConfigurableInformation",
                    "dataRef": "",
                    "dataSource": "",
                    "description": null,
                    "enabled": true,
                    "enumType": "-1",
                    "flags": -1,
                    "group": 'Common',
                    "id": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                    "name": DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS,
                    "order": 1,
                    "params": null,
                    "platform": null,
                    "title": "Driver Options",
                    "type": 5,
                    "uid": "-1",
                    "value":0,
                    "data":[
                        {
                            value: 2,
                            label: 'Runs Server Side'
                        },
                        {
                            value: 4,
                            label: 'Show Debug Messages'
                        },
                        {
                            value: 8,
                            label: 'Allow Multiple Device Connections'
                        }

                    ],
                    "visible": true,
                    "device": item
                });
            }else{
                driverOptions.data = [
                    {
                        value: 2,
                        label: 'Runs Server Side'
                    },
                    {
                        value: 4,
                        label: 'Show Debug Messages'
                    },
                    {
                        value: 8,
                        label: 'Allow Multiple Device Connections'
                    }

                ];

                driverOptions.group = 'Common'
            }

            var protocolCI = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL);
            if(protocolCI){
                protocolCI.type = 3;
                protocolCI.options = [
                    {
                        label:"TCP",
                        value:"tcp"
                    },
                    {
                        label:"UDP",
                        value:"tcp"
                    },
                    {
                        label:"Driver",
                        value:"driver"
                    },
                    {
                        label:"SSH",
                        value:"ssh"
                    },
                    {
                        label:"Serial",
                        value:"serial"
                    },
                    {
                        label:"MQTT",
                        value:"mqtt"
                    }
                ]
            }
        },

        /**
         * Return handy info for a device
         * @param {module:xcf/model/Device} item
         * @returns {module:xide/types~DeviceInfo}
         */
        toDeviceControlInfo: function (item) {

            if(!item._store &amp;&amp; item.id){
                var _item = this.getItemById(item.id);
                if(_item){
                    item = _item;
                }
            }

            if(!item.path){
                _debug &amp;&amp; console.error('not a device');
                var _item = this.getDeviceStoreItem(item);
                if(!_item){
                    return null;
                }
            }

            _debug &amp;&amp; !item &amp;&amp; console.error('toDeviceControlInfo: invalid device item');
            _debug &amp;&amp; !item.user &amp;&amp; console.error('toDeviceControlInfo: invalid device item, has no meta');

            var meta = item['user'];
            var host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST),
                port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT),
                title = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_TITLE),
                protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL),
                driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER),
                options = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_OPTIONS),
                driverOptions = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS),
                serverSide = item.isServerSide(),
                result = null;

            this.fixDeviceCI(item);

            var driver = this.ctx.getDriverManager().getItemById(driverId);
            if (driver) {

                var driverMeta = driver['user'],
                    script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS),
                    responseCI = utils.getCIByChainAndName(driverMeta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES),
                    responseSettings = {},
                    scope = driver['scope'];

                if (responseCI &amp;&amp; responseCI['params']) {
                    responseSettings = utils.getJson(responseCI['params']);
                }

                result = {
                    host: host,
                    port: port,
                    protocol: protocol,
                    driver: script ? script.replace('./', '') : '',
                    driverId:driverId,
                    scope: scope,
                    id: item.id,
                    title:title,
                    options:options,
                    driverOptions:driverOptions,
                    serverSide:serverSide,
                    responseSettings:responseSettings,
                    toString:function(){
                        return this.host + ':'+this.port+'@'+this.protocol;
                    }
                };
            }else{
                _debug &amp;&amp; console.error('cant find driver ' + driverId + ' for '+ item.toString());
            }
            item.info = result;
            return result;
        },
        /**
         * Return the device's status icon
         * @param item {module:xcf/model/Device} The device
         * @returns {string} an icon class string
         */
        getDeviceStatusIcon: function (item) {

            switch (item.state) {

                case types.DEVICE_STATE.DISCONNECTED:
                {
                    return 'fa-unlink iconStatusOff'
                }
                case types.DEVICE_STATE.READY:
                case types.DEVICE_STATE.CONNECTED:
                {
                    return 'fa-link iconStatusOn'
                }
                case types.DEVICE_STATE.SYNCHRONIZING:
                case types.DEVICE_STATE.CONNECTING:
                {
                    return 'fa-spinner fa-spin'
                }
            }

            return 'fa-unlink iconStatusOff';
        },
        /**
         * Return device model item by device id
         * @param itemId
         * @returns {module:xcf/model/Device} The device
         */
        getItemById: function (itemId) {

            if(!this.store || !this.store.data){
                _debug &amp;&amp; console.error('Device Manager::getItemById : have no valid store');
                return null;
            }
            var data = this.store.data,
                device = _.find(data,{
                    id: itemId
                });

            if(!device){
                _debug &amp;&amp; console.error('Device Manager::getItemById : cant find device with id: ' + itemId);
                return null;
            }
            return this.store.getSync(device.path);
        },
        /**
         *
         * @param evt
         * @private
         */
        onStoreCreated: function (evt) {

            var thiz = this,
                ctx = thiz.ctx,
                toolbar = isIDE ? ctx.mainView.getToolbar() : null,
                type = evt.type,
                data = evt.data,
                store = evt.store,
                items = store ? utils.queryStore(store, {
                    isDir: false
                }) : [],
                owner = evt.owner,
                driverManager = this.ctx.getDriverManager();


            if(type!==types.ITEM_TYPE.DEVICE){
                return;
            }

            for (var i = 0; i &lt; items.length; i++) {

                var item = store.getSync(items[i].path);
                if (item._completed != null) {
                    continue;
                }
                item._completed = true;

                var driverId = this.getMetaValue(item, DEVICE_PROPERTY.CF_DEVICE_DRIVER);
                if (!driverId) {
                    console.error('device has no driver id!');
                    continue;
                }
                var driver = driverManager.getItemById(driverId),
                    CIS = item.user;

                //complete CIS
                _.each(CIS.inputs,function(ci){
                    ci.device=item;
                    ci.actionTarget=toolbar;
                    ci.ctx = ctx;

                });

                if (!_.isEmpty(driver)) {
                    if(isIDE) {
                        this.completeDevice(store,item,driver);
                        item.iconClass = item.getStateIcon();
                    }
                }
            }

            //this.onNodeServiceStoreReady(evt);
        },
        onClientMessage:function(evt){
            this.checkDeviceServerConnection();
            if(this.deviceServerClient){
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.WRITE_LOG_MESSAGE, evt);
            }
        },
        onClientLogMessage:function(evt){
            if(!isServer){
                this.onClientMessage(evt);
            }
        },
        /**
         *
         * @param evt
         * @private
         */
        onVariableChanged:function(evt){

            var variable = evt.item,
                scope = evt.scope,
                name = variable.name;

            if(name==='value'){
                return;
            }

            var value = variable.value,
                driver= scope.driver,
                device = scope.device;

            if(!name || value==null){
                console.error('------------invalid params');
            }

            if(device) {

                var deviceInfo = device.info,
                    mqttTopic = deviceInfo.host + '/' + deviceInfo.port+'/Variable/' + name;

                _debugMQTT &amp;&amp; console.log('send mqtt message ' + mqttTopic);
                this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MQTT_PUBLISH, {
                    topic:mqttTopic,
                    data:{
                        value:value,
                        device:deviceInfo
                    }
                });
            }
            _debug &amp;&amp; console.error('on variable changed ' + device.toString());
        },
        /***
         * Common manager function, called by the context of the application
         * @private
         */
        init: function () {
            var thiz = this;
            if(this.initUI){
                this.initUI();
            }
            this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, this.onVariableChanged);
            this.subscribe([
                EVENTS.ON_NODE_SERVICE_STORE_READY,
                EVENTS.ON_MODULE_RELOADED,
                EVENTS.ON_DEVICE_DISCONNECTED,
                EVENTS.ON_DEVICE_CONNECTED,
                EVENTS.ON_CLIENT_LOG_MESSAGE,
                EVENTS.ON_STORE_CREATED
            ]);

            this.deviceInstances = this.consoles = {};

            this.driverScopes = {
                "system_drivers": "system_drivers/"
            };
            this.lastUpTime = (new Date()).getTime();
            setInterval(function () {
                var current = (new Date()).getTime();
                if (current - thiz.lastUpTime > 30000) {
                    thiz.lastUpTime = (new Date()).getTime();
                }
                thiz.lastUpTime = current;
            }, 1000);


        },
        onDeviceServerConnected:function(){},
        //nulled in server mode
        addDeviceInstance:function(device,driver){}
    });
});
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>

<div class="modal fade" id="searchResults">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Search results</h4>
      </div>
      <div class="modal-body"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div>

<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a>
	
		on 2016-06-02T17:42:36+02:00
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>
<script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>

<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			var id = $( heading ).attr( "id" );
			return id && id.replace(/\~/g, '-inner-').replace(/\./g, '-static-') || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->


<script type="text/javascript">
	$(document).ready(function() {
		SearcherDisplay.init();
	});
</script>

</body>
</html>
