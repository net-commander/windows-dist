<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"manager_DriverManager.js.html":{"id":"manager_DriverManager.js.html","title":"Source: manager/DriverManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DriverManager.js define([ 'dcl/dcl', &quot;dojo/_base/declare&quot;, &quot;dojo/_base/lang&quot;, &quot;dojo/_base/json&quot;, 'xide/types', 'xcf/types/Types', 'xide/utils', 'xcf/manager/BeanManager', &quot;xcf/model/Variable&quot;, 'xcf/manager/DriverManager_Server', 'xide/data/TreeMemory', 'xide/data/ObservableStore', 'dstore/Trackable', 'xdojo/has', 'xcf/model/Driver', &quot;xide/manager/ServerActionBase&quot;, &quot;xide/data/Reference&quot;, 'xdojo/has!xcf-ui?./DriverManager_UI' ], function (dcl,declare, lang,json,types,fTypes,utils, BeanManager,Variable, DriverManager_Server, TreeMemory,ObservableStore,Trackable, has,Driver, ServerActionBase,Reference,DriverManager_UI) { var bases = [ ServerActionBase, BeanManager, DriverManager_Server ], debug = false, isServer = !has('host-browser'); has('xcf-ui') &amp;&amp; bases.push(DriverManager_UI); /* var url = &quot;command://deviceScope=system_devices&amp;device=e5a06e24-6aa4-c8c5-3ffc-9d84d8528a91&amp;driver=235eb680-cb87-11e3-9c1a-0800200c9a66&amp;driverScope=system_drivers&amp;block=53a10527-709b-4c7d-7a90-37f58f17c8db&quot;; var parts = utils.parse_url(url);//strip scheme parts = utils.urlArgs(parts.host);//go on with query string //console.error(parts); var driverId = parts.driver.value; var driverManager = sctx.getDriverManager(); var _driver = driverManager.getItemById(driverId); var block = null; if(_driver &amp;&amp; _driver.blockScope){ block = _driver.blockScope.getBlockById(parts.block.value); } console.error(block); */ return dcl(bases, { getBlock:function(url){ var parts = utils.parse_url(url); parts = utils.urlArgs(parts.host);//go on with query string var _driver = this.getItemById(parts.driver.value), block = null; if(_driver &amp;&amp; _driver.blockScope){ block = _driver.blockScope.getBlockById(parts.block.value); } return block; }, declaredClass:&quot;xcf.manager.DriverManager&quot;, /** * * @param device * @param driver */ addDeviceInstance:function(device,driver){ driver.directory = true; var store = driver._store, parentId = driver.path, deviceManager = this.ctx.getDeviceManager(), instances = store.getSync(parentId + '_instances'); instances = instances || store.putSync({ path: parentId + '_instances', name: 'Instances', isDir: true, type: 'leaf', parentId: parentId, virtual: true, isCommand:false, icon:'fa-folder', children:[] }); var deviceName = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE), deviceId = device.path, instance = store.putSync(new Reference({ name:deviceName, isCommand:false, path: instances.path + '_instance_'+deviceId, isDir: false, type: 'driver_instance', parentId:instances.path, device:device, driver:driver, _mayHaveChildren:false, icon:device.iconClass, state:device.state })); instances.children.push(instance); device.addReference(instance,{ properties: { &quot;name&quot;:true, &quot;enabled&quot;:true, &quot;state&quot;:true, &quot;iconClass&quot;:true }, onDelete:false },true); !driver.instances &amp;&amp; (driver.instances =[]); driver.instances.push(instance); }, /*** * The Bean-Manager needs a unique name of the bean: */ beanNamespace: 'driver', /*** * The Bean-Manager has some generic function like creating Dialogs for adding new items, please * provide a title for the interface. */ beanName: 'Driver', /** * the icon class for bean edit views */ beanIconClass:'fa-exchange', /** * Bean group type */ groupType: types.ITEM_TYPE.DRIVER_GROUP, /** * Bean item type */ itemType: types.ITEM_TYPE.DRIVER, /** * The name of the CI in the meta database for the title or name. */ itemMetaTitleField:types.DRIVER_PROPERTY.CF_DRIVER_NAME, /** * the default scope for new items */ defaultScope: 'system_drivers', /*** * The RPC server class: */ serviceClass: 'XCF_Driver_Service', /*** * A copy of all divers raw da4ta from the server */ rawData: null, /*** * {module:xide/data/TreeMemory} */ store: null, /*** * {xcf.views.DriverTreeView} */ treeView: null, /** * array of driver store scopes : TODO : tbr */ driverScopes: null, _isLoading: false, removeDriverInstance:function(instance,device){ var driver = instance.driver, driverStore = driver._store, parentId = driver.path, deviceId = device.path, instanceId = parentId + '_instances' + '_instance_'+deviceId, instanceReferenceItem = driverStore.getSync(instanceId); instanceReferenceItem &amp;&amp; driverStore.removeSync(instanceId); driver.instances.remove(instanceReferenceItem); device.removeReference(instanceReferenceItem); if(instanceReferenceItem) { instanceReferenceItem.refresh(); driverStore.getSync(parentId + '_instances').refresh(); }else{ debug &amp;&amp; console.error('bad!! cant find reference for instance',arguments);; } }, onReloaded: function () { return; }, _onReloaded: function () { return; /* var currentItem = this.getItem(); if (!currentItem) { currentItem = { path: &quot;&quot; } } var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; var scope = 'system_drivers'; var templateUrlMeta = require.toUrl('xcfnode/data/driver/system/Default.meta.json'); var meta = utils.getJson(this._getText(templateUrlMeta)); var templateUrlDriverCode = require.toUrl('xcfnode/data/driver/system/Default.js'); var driverCode = this._getText(templateUrlDriverCode); //console.log('template url : ' + templateUrlDriverCode + &quot; : &quot; + driverCode ); //console.log('template url : ' + templateUrlDriverCode + &quot; : &quot; + driverCode ); console.log('get json : ', meta); var nameCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME); var idCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID); idCi.value = utils.createUUID(); nameCi.value = 'My New Driver2'; var thiz = this; var actionDialog = new CIActionDialog({ title: 'New Driver', resizable: true, delegate: { onOk: function (dlg, data) { if (nameCi.value !== 'Default') { try { var metaOut = JSON.stringify(meta, null, 2); if (parent.length == 0) { parent = &quot;/&quot;; } thiz.createItem(scope, parent, nameCi.value, metaOut, driverCode).then(function (data) { var newItem = thiz.createNewItem(title, scope, parent); newItem.user = meta; thiz.store.putSync(newItem); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: thiz.store, action: types.NEW_FILE, item: newItem }); //console.log('did create driver ', data); }); } catch (e) { console.error('error in CIDialog', e); } } } }, cis: [ nameCi, utils.createCI('Scope', 3, 'system_devices', { group: 'Common', options: [ { label: 'System', value: 'system_devices' }, { label: 'User', value: 'user_devices' }, { label: 'App', value: 'app_devices' } ] }) ] }); actionDialog.show(); actionDialog.resize();*/ }, ///////////////////////////////////////////////////////////////////////////////////// // // Device messaging // ///////////////////////////////////////////////////////////////////////////////////// /** * Secondary entry for incoming device messages. This is a regular callback * for the system event xcf.types.EVENTS.ON_DEVICE_MESSAGE emitted by the * DeviceManager. It comes with the device info, a driver instance and the * unfiltered device message. * * This function is primarily in charge to : * 1. split the message by a delimiter (driver settings) * 2. pass the device messages to the actual driver * 3. pass the device message to blox * 4. * * @param evt */ onDeviceMessage: function (evt) { if (!evt || !evt.device || !evt.driverInstance) { return; } var _deviceInfo = evt['device'], _driverInstance = evt['driverInstance'], _driverOptions = _driverInstance['options']; if (!_driverOptions)return; if (!_driverInstance.responseSettings) { console.error('driver has no response settings!'); return; } var serverSide = _driverOptions.serverSide; //split string into messages, using the driver's delimiter var messages = [evt.deviceMessage]; if (lang.isString(evt.deviceMessage)) { messages = _driverInstance.split(evt.deviceMessage); } /*** * At this point, we should reject incoming traffic */ if (_driverInstance.hasMessages()) { console.error('abort incoming, have still messages to send'); return; } //forward to blox if (messages.length &gt; 0) { var scope = _driverInstance.blockScope; var responseBlocks = scope.getBlocks({ group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_BLOCKS }); var responseVariables = scope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES }); if (!responseBlocks || responseBlocks.length == 0) { //console.log('have no response blocks, abort'); } var responseVariable = scope.getVariable('value'); if (responseVariable) { } else { responseVariable = new Variable({ id: utils.createUUID(), name: 'value', value: '', scope: scope, type: 13, group: 'processVariables', gui: false, cmd: false }); scope.blockStore.putSync(responseVariable); } for (var i = 0; i &lt; messages.length; i++) { if (messages[i].length == 0) { continue; } responseVariable.value = messages[i]; this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, { item: responseVariable, scope: scope, owner: this, save: false, //dont save it source: types.MESSAGE_SOURCE.DEVICE //for prioritizing }); var runVariables = false; var runBlocks = false; //now run each top-variabl block in 'conditional process' for (var j = 0; j &lt; responseVariables.length; j++) { var _var = responseVariables[j]; if (responseVariables[j].title == 'value') { continue; } var _varResult = null; var _cValue = responseVariable.value; if (!(typeof _cValue == &quot;number&quot;)) { _cValue = '' + _cValue; _cValue = &quot;'&quot; + _cValue + &quot;'&quot;; } var prefix = &quot;var value = &quot; + _cValue + &quot;;&quot;; var _varResult = _cValue; /* try { //_varResult = scope.expressionModel.parseVariable(scope, _var, prefix, false, false); } catch (e) { console.error('parsing response variable ' + _var.title + ' failed'); this.publish(types.EVENTS.ON_BLOCK_EXPRESSION_FAILED, { item: _var, scope: scope, owner: this, deviceInfo: _deviceInfo }); } */ if (_var.target &amp;&amp; _var.target != 'None' &amp;&amp; _varResult != null &amp;&amp; _varResult != 'null' &amp;&amp; _varResult != &quot;'null'&quot;) { var targetVariable = scope.getVariable(_var.target); if (targetVariable) { targetVariable.value = _varResult; this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, { item: targetVariable, scope: scope, owner: this, save: false, source: types.MESSAGE_SOURCE.BLOX //for prioritizing }); } } } if( (isServer &amp;&amp; serverSide) || (!serverSide &amp;&amp; !isServer)) { for (var j = 0; j &lt; messages.length; j++) { var message = messages[j]; if(_.isObject(message)) { if (message.src) { var block = scope.getBlockById(message.src); if(block &amp;&amp; block.onData){ block.onData(message); } } } } //now run each top-level block in 'conditional process' for (var j = 0; j &lt; responseBlocks.length; j++) { var block = responseBlocks[j]; if (block.enabled == false) { continue; } block.override = { args: _var ? [_var.value] : null }; try { scope.solveBlock(responseBlocks[j], { highlight: isServer ? false : true }); } catch (e) { logError(e,'----solving response block crashed ') debug &amp;&amp; console.trace(); } } } } } }, ///////////////////////////////////////////////////////////////////////////////////// // // CI related // ///////////////////////////////////////////////////////////////////////////////////// getDriverById: function (id) { var options = []; var result = null; function search(store) { var items = utils.queryStore(store, { isDir: false }); if (!lang.isArray(items)) { items = [items]; } for (var i = 0; i &lt; items.length; i++) { var driver = items[i]; var meta = driver['user']; var _id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID); if (!_id) { continue; } if (_id.value == id) { return store.getSync(driver.path); return driver; } } return null; } for(var scope in this.stores){ var store = this.stores[scope]; result = search(store); if(result){ return result; } } return null; }, getItemById: function (itemId) { if(!this.store || !this.store.data){ debug &amp;&amp; console.error('Driver Manager::getItemById : have no valid store'); } var data = this.store.data, driver = _.find(data,{ id: itemId }); if(!driver){ debug &amp;&amp; console.error('Driver Manager::getItemById : cant find driver with id: ' + itemId,data); } return driver; }, ///////////////////////////////////////////////////////////////////////////////////// // // Data related // ///////////////////////////////////////////////////////////////////////////////////// /** * Callback when a blox scope has been created. This is being used * to deserialize the driver's CI meta settings into a blox scope : variables, commands * @param scope */ onNewDriverScopeCreated: function (scope) {}, onScopeCreated: function (evt) {}, onDeviceDisconnected: function (evt) {}, onDriverCreated: function (store) { has('xcf-ui') &amp;&amp; types.registerEnumeration('Driver', this.getDriversAsEnumeration(store)); }, onDriverRemoved: function (store,item) { has('xcf-ui') &amp;&amp; types.registerEnumeration('Driver', this.getDriversAsEnumeration(store)); }, onStoreReady: function (store) { has('xcf-ui') &amp;&amp; types.registerEnumeration('Driver', this.getDriversAsEnumeration(store)); }, onStoreCreated: function (evt) { var type = evt.type, data = evt.data, store = evt.store, items = store.query({ isDir: false }), owner = evt.owner; if(type!==types.ITEM_TYPE.DRIVER){ return; } for (var i = 0; i &lt; items.length; i++) { var item = items[i]; if (item._completed != null || item.name === 'Default') { continue; } item._completed = true; if(has('xcf-ui')) { this.completeDriver(store, item, item); } } }, /*** * Inits the store with the driver data * @param data * @returns {xide.data.TreeMemory} */ createStore:function(data,scope,track){ var storeClass = declare('driverStore',[TreeMemory,Trackable,ObservableStore],{}); var store = new storeClass({ data: data.items, Model:Driver, idProperty: 'path', //parentField:'path', scope:scope, observedProperties:[ &quot;name&quot;, &quot;enabled&quot; ] }); if(scope &amp;&amp; !this.stores[scope] &amp;&amp; track!==false){ this.stores[scope] = store; } if(!this.store &amp;&amp; scope ==='system_drivers'){ this.store = store; } return store; }, /*** * Inits the store with the driver data * @param data * @returns {xide.data.TreeMemory} */ initStore:function(data,scope){ var store = this.createStore(data,scope); return store; }, getStore:function(scope){ if(!scope || scope==='system_drivers') { return this.store; } var store = this.stores[scope]; if(store){ return store; } if(scope){ return this.ls(scope); } }, /*** * ls is enumerating all drivers in a given scope * @param scope{string} * @returns {Deferred} */ ls: function (scope) { return this.runDeferred(null, 'ls', [scope]).then(function (data) { try { var store = this.initStore(data,scope); if(scope==='system_drivers'){ this.store = store; } this.stores[scope] = store; this.onStoreReady(store); this.publish(types.EVENTS.ON_STORE_CREATED, { data: data, owner: this, store: store, type: this.itemType }); }catch(e){ logError(e,'error ls drivers'); } }.bind(this)); }, /*** * Common manager function, called by the context of the application */ init: function () { var thiz = this, EVENTS = types.EVENTS; this.stores = {}; this.subscribe([ EVENTS.ON_SCOPE_CREATED, EVENTS.ON_STORE_CREATED ]); //replay block exceptions to log messages this.subscribe(EVENTS.ON_BLOCK_EXPRESSION_FAILED, function (evt) { thiz.publish(EVENTS.ON_SERVER_LOG_MESSAGE, { data: { type: 'Expression', device: evt.deviceInfo }, level: 'error', message: 'Expression Failed: ' + evt.item.title + ' : ' + evt.item.value }); }); this.driverScopes = { &quot;system_drivers&quot;: &quot;system_drivers/&quot; }; } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_ProtocolManager.js.html":{"id":"manager_ProtocolManager.js.html","title":"Source: manager/ProtocolManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/ProtocolManager.js define([ 'dcl/dcl', &quot;dojo/_base/declare&quot;, &quot;xide/manager/ServerActionBase&quot;, 'xide/types', 'xide/utils', 'xide/factory', 'xaction/Action', 'xcf/manager/BeanManager' /*, 'xide/views/ActionDialog', 'xide/widgets/FileEditor', 'xide/views/CIActionDialog', 'xide/views/CIGroupedSettingsView', 'xide/registry', 'require'*/ ], function (dcl,declare, ServerActionBase, types, utils, factory,Action,BeanManager, ActionDialog,FileEditor,CIActionDialog, CIGroupedSettingsView,registry,require) { return dcl([ServerActionBase, BeanManager], { declaredClass:&quot;xcf.manager.ProtocolManager&quot;, /*** * The Bean-Manager needs a unique name of the bean: */ beanNamespace: 'protocol', /*** * The Bean-Manager has some generic function like creating Dialogs for adding new items, please * provide a title for the interface. */ beanName: 'Protocol', /** * the icon class for bean edit views */ beanIconClass:'fa-code', /** * Bean group type */ groupType:types.ITEM_TYPE.PROTOCOL_GROUP, /** * Bean item type */ itemType:types.ITEM_TYPE.PROTOCOL, /** * the path to the meta data within the store item */ itemMetaPath:'user.meta', /** * the path to the meta data within the store item when saving */ itemMetaStorePath:'/meta/inputs', /** * The name of the CI in the meta database for the title or name. */ itemMetaTitleField:types.PROTOCOL_PROPERTY.CF_PROTOCOL_TITLE, /** * Name of the system scope */ systemScope:'system_protocols', /** * Name of the user scope */ userScope:'user_protocols', /** * Name of the app scope */ appScope:'app_protocols', /** * Name of the default scope for new created items */ defaultScope:'system_protocols', /*** * The RPC server class: */ serviceClass: 'XCF_Protocol_Service', /*** * A copy of all devices raw data from the server */ rawData: null, /*** * {dojo.data.ItemFileWriteStore} */ store: null, /*** * {xcf.views.ProtocolTreeView} */ treeView: null, /*** * A map of scope names for module hot reloading */ protocolScopes: null, ///////////////////////////////////////////////////////////////////////////////////// // // Bean protocol impl. // ///////////////////////////////////////////////////////////////////////////////////// getItemActions: function () { var actions = []; var thiz = this; var selectedItem = this.getItem(); var isGroup = selectedItem ? utils.toBoolean(selectedItem.isDir) === true : false; //New Group actions.push({ title: 'New Group', icon: 'el-icon-folder', place: 'last', emit: false, style: '', handler: function (command, item, owner) { thiz.newGroup() } }); //reload actions.push({ title: 'Reload', icon: 'fa-refresh', disabled: false, command: 'Reload', place: 'last', emit: false, style: '', handler: function () { thiz.reload() } }); //item actions, if if (this.getItem() != null) { //delete actions.push({ title: 'Delete', icon: 'el-icon-remove-circle', disabled: false, command: 'Delete', place: 'last', emit: false, style: '', handler: function () { thiz.onDeleteItem(selectedItem) } }); //new item if (isGroup) { actions.push({ title: 'New Protocol', icon: 'el-icon-file-new', disabled: false, command: 'NewItem', place: 'last', emit: false, style: '', handler: function () { thiz.newItem(selectedItem) } }); } else { actions.push({ title: 'Connect', icon: 'el-icon-play-circle', disabled: false, command: 'Start', place: 'last', emit: false, style: '', handler: function () { thiz.startDevice(selectedItem) } }); } } return actions; }, ///////////////////////////////////////////////////////////////////////////////////// // // UX related functions, @TODO : move it to somewhere else // ///////////////////////////////////////////////////////////////////////////////////// onItemRemoved: function (item) { if(item == this.currentItem) { this.currentItem = null; } if (item) { var view = this.getView(item); if (view) { utils.destroyWidget(view); } } //this.reload(); }, _onDeleteItem: function (item) { var isDir = utils.toBoolean(item.isDir) === true; var name = utils.toString(item['name']); //pick the right service function var removeFn = isDir ? 'removeGroup' : 'removeItem'; var thiz = this; var actionDialog = new ActionDialog({ title: 'Remove Protocol' + (isDir ? ' Group' : '') + ' ' + '\\'' + name + '\\'', style: 'max-width:400px', titleBarClass: 'text-danger', delegate: { isRemoving: false, onOk: function (dlg) { thiz[removeFn]( utils.toString(item.scope), utils.toString(item.path), function () { thiz.onItemRemoved(item) }); } }, inserts: [{ query: '.dijitDialogPaneContent', insert: '&lt;div&gt;&lt;span class=&quot;fileManagerDialogText&quot;&gt;Do you really want to remove this item' + '?&lt;/span&gt;&lt;/div&gt;', place: 'first' }] }); actionDialog.show(); }, /** * Bean UX function to create a new item by opening a dialog, followed by a server call */ newItem: function () { var thiz = this; var currentItem = this.getItem(); var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; if (!currentItem) { currentItem = { path: &quot;&quot; } } var cis = [ utils.createCI('In Group', 13, utils.toString(currentItem.path), { widget: { disabled: true }, group: 'Common' }), utils.createCI('Title', 13, '', { group: 'Common' }) ]; var actionDialog = new CIActionDialog({ title: 'New Device', /*style: 'max-width:400px;width:400px;height:300px;',*/ resizable: true, delegate: { onOk: function (dlg, data) { var idCi = utils.createCI('Id', 13, utils.createUUID(), { visible: false, group:&quot;Common&quot; }); data.push(idCi); var options = utils.toOptions(data); var nameCi = utils.getInputCIByName(cis, &quot;Title&quot;); var scopeCi = utils.getInputCIByName(cis, &quot;Scope&quot;); var groupCi = utils.getInputCIByName(cis, &quot;In Group&quot;); } }, cis: cis }); actionDialog.show(); actionDialog.resize(); }, ///////////////////////////////////////////////////////////////////////////////////// // // Data related // ///////////////////////////////////////////////////////////////////////////////////// reload: function () { }, /*** * Callback when the NodeJS service manager initialized its service store. That may * happen multiple times as user can reload the store. * * @param evt */ onFileChanged:function(evt){ if (evt._pp2) { return; } evt._pp2 = true; var data = evt.data; var thiz = this; if (!this.fileUpdateTimes) { this.fileUpdateTimes = {} }; if (data.event === types.EVENTS.ON_FILE_CHANGED) { if (data.data &amp;&amp; data.mask &amp;&amp; data.mask.indexOf('delete') !== -1) { //thiz.publish(types.EVENTS.ON_FILE_DELETED, data); console.error('deleted'); return; } var _path = data.path; var timeNow = new Date().getTime(); } var path = utils.replaceAll('\\\\', '/', data.path); path = utils.replaceAll('//', '/', data.path); path = path.replace(/\\\\/g, &quot;/&quot;); if(path.indexOf('protocols')==-1){ return; } if (path.match(/\\.json$/)) { var _start = 'data/system/protocols'; if (path.indexOf(_start) != -1) { console.log('protocol changed' + path); } this.ls('system_protocols'); } /* if(evt._pp){ return; } evt._pp = true; //console.log('file changed',evt); */ this['onFileChanged2'] &amp;&amp; this['onFileChanged2'](evt); }, /*** * Common manager function, called by the context of the application */ init: function () { this.subscribe(types.EVENTS.ON_FILE_CHANGED,this.onFileChanged); }, _resetItem:function(item){ if(item.commandsItem) { utils.removeFromStore(this.getStore(), item.commandsItem, true, 'path', 'parentId'); } if(item.variablesItem) { utils.removeFromStore(this.getStore(), item.variablesItem, true, 'path', 'parentId'); } }, _completeProtocolItem:function(item){ if(!item || !item.user){ return; } var contentCI = utils.getInputCIByName(item.user.meta, 'content'), thiz = this, store = this.getStore(); if(!contentCI){ //upgrade to file item item.mount = '' + item.scope; item.getPath=function(){ return item.path; }; item.virtual = false; item.isDir = true; item.children = []; contentCI = utils.createCI('Content', types.ECIType.FILE_EDITOR, 'no value', { group: 'Content', editor:'JSON Editor', editorArgs:{ subscribers:[ { event: 'onSave', handler: function (evt) { var value = utils.getJson(evt.value); if(value &amp;&amp; value.meta){ item.user = value; item._completed=false; thiz._resetItem(item); thiz._completeProtocolItem(item); thiz.publish(types.EVENTS.ON_PROTOCOL_CHANGED,{ item:item }); } }, owner:thiz } ], leftEditorArgs:{ subscribers:[ { event: 'addAction', handler: function (action) { console.log('add action',arguments); }, owner:thiz } ], hiddenFields:{ }, readOnlyNodes:{ &quot;commands&quot;:true, &quot;variables&quot;:true, &quot;meta&quot;:true }, insertTemplates:[ { label: 'New Command', path: 'commands', value: '{title:&quot;No Title&quot;,send:&quot;&quot;}', newNodeTemplate: '[]', collapse:true, select:true }, { label: 'New Variable', path: 'variables', value: '{title:&quot;No Title&quot;,value:&quot;&quot;}', newNodeTemplate: '[]', collapse:true, select:true } ], renderTemplates : [ { // // This segment is used to replace something in the node's dom structure // /** * @type {string} the path within the dom structure */ nodeValuePath: 'field.innerHTML', /** * @type {RegExp|string|function|RegExp[]|string[]|function[]} */ match: [/^variables[\\s]?\\.(\\d+)$/,/^commands[\\s]?\\.(\\d+)$/], /** * @type {string} the new value for the field specified in nodeValuePath */ replaceWith: '{nodeValue} - {title}', /** * @type {object} additional variables */ variables: null, /** * @type {function} a function to transform the node's dom value into something else */ nodeValueTransform:function(value){ return utils.capitalize(value); }, // // This segment is about dom manipulation, todo! // /** * @type (object) */ insertIfMatch:{} } ] }, rightEditorArgs:{ subscribers:[ { event: 'addAction', handler: function (action) { console.log('add action',arguments); }, owner:thiz } ] } }, editorItem:item, editorOverrides:{}, isOwnTab:true }); item.user.meta.inputs.push(contentCI); //append variables and commands if(!item._completed){ item._completed=true; var commands = { path: utils.createUUID(), name: 'Commands', isDir: true, type: 'leaf', parentId: item.path, virtual: true, children:[] }; item.commandsItem = commands; item.children.push(commands); //complete commands store.putSync(commands); var commandItems = item.user.commands; for (var i = 0; i &lt; commandItems.length; i++) { var command = commandItems[i]; commands.children.push(store.putSync({ path: utils.createUUID(), name: command.name, id: utils.createUUID(), parentId: commands.path, _mayHaveChildren: false, virtual: true, user:{}, isDir:false, value:command.value, ref: { protocol: item, item: command }, type: 'protocolCommand' })); } var variables = { path: utils.createUUID(), name: 'Variables', isDir: true, type: 'leaf', parentId: item.path, virtual: true, items:[], children:[] }; //complete commands store.putSync(variables); item.children.push(variables); item.variablesItem = variables; var variablesItems = item.user.variables; for (var i = 0; i &lt; variablesItems.length; i++) { var variable = variablesItems[i]; variables.children.push(store.putSync({ isDir:false, path: utils.createUUID(), name: variable.name, id: utils.createUUID(), parentId: variables.path, _mayHaveChildren: false, value:variable.value, virtual: true, user:{}, ref: { protocol: item, item: variable }, type: 'protocolVariable' })); } } } }, /** * Protocol store is ready, extend each item with a file-editor CI (protocol content) * @param store */ onStoreReady:function(store){ var items = store ? utils.queryStore(store, { isDir: false }) : [], thiz = this; _.each(items,function(what,value,item){ thiz._completeProtocolItem(what); }); console.log('store ready : ',items); }, onMainViewReady: function () { var thiz = this; /** * Register permanent actions */ var newProtocol = Action.createDefault('New Protocol', 'fa-exchange', 'File/New/Protocol', '__anewAction', null, { permanent: true, handler: function () { thiz.newItem(); } }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, null). setVisibility(types.ACTION_VISIBILITY.MAIN_MENU, {}). setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, null); thiz.publish(types.EVENTS.REGISTER_ACTION, { owner: thiz, action: newProtocol }); //@TODO wrong place: FileEditor.prototype.ctx = this.ctx; }, ///////////////////////////////////////////////////////////////////////////////////// // // Server methods (NodeJs) // ///////////////////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////////////////// // // Utils // ///////////////////////////////////////////////////////////////////////////////////// /*** * openItemSettings creates a new settings view for a protocol * @param item * @returns {xide.views.CIGroupedSettingsView|null} */ openItemSettings: function (item) { //1. sanity check var userData = item.user; if (!userData || !userData.meta) { return null; } //2. check its not open already var viewId = this.getViewId(item); var view = registry.byId(viewId); try { if (view) { if (view.parentContainer) { view.parentContainer.selectChild(view); } return null; } } catch (e) { utils.destroyWidget(view); } //3. get a view target var parent = this.getViewTarget(); var title = this.getMetaValue(item, this.itemMetaTitleField); item.beanContextName = this.ctx.mainView.beanContextName; return utils.addWidget(CIGroupedSettingsView, { title: title || utils.toString(item.name), cis: userData.meta.inputs, beanContextName:this.ctx.mainView.beanContextName, storeItem: item, iconClass: this.beanIconClass, id: viewId, delegate: this, storeDelegate: this, closable: true, showAllTab: false, blockManager: this.ctx.getBlockManager() }, this, parent, true); } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DriverManager_UI.js.html":{"id":"manager_DriverManager_UI.js.html","title":"Source: manager/DriverManager_UI.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DriverManager_UI.js define([ 'dcl/dcl', &quot;xdojo/declare&quot;, 'xide/types', 'xide/utils', 'xace/views/Editor', 'xide/views/_CIDialog', &quot;xide/data/Reference&quot;, &quot;xcf/views/DriverView2&quot;, 'dojo/Deferred', 'xide/registry' ], function (dcl,declare,types, utils, Editor, _CIDialog, Reference,DriverView2,Deferred,registry) { var debug = false; return dcl(null, { declaredClass:&quot;xcf.manager.DriverManager_UI&quot;, openItemSettings: function (item,device,mixin,createNew) { var docker = this.ctx.mainView.getDocker(); //1. sanity check var userData = item.user; if (!userData || !userData.inputs) { return null; } //2. check its not open already var viewId = this.getViewId(item); var view = registry.byId(viewId); try { if (view &amp;&amp; createNew!==true) { view._parent.select(); return null; } } catch (e) { utils.destroy(view); } var title = this.getMetaValue(item, this.itemMetaTitleField); var devinfo = null, ctx = this.ctx, deviceManager = ctx.getDeviceManager(); mixin = mixin || {}; if(device){ devinfo = ctx.getDeviceManager().toDeviceControlInfo(device); } var parent = docker.addTab(null, { title: (title || item.name) + '' + (device ? ':' + device.name + ':' + devinfo.host + ':' : ''), icon: this.beanIconClass }); //@Todo:driver, store device temporarly in Commands CI var commandsCI = utils.getCIByChainAndName(userData, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS); if(commandsCI){ commandsCI.device = device; } if(item.blockScope &amp;&amp; !item.blockScope.serviceObject){ item.blockScope.serviceObject = this.serviceObject; } //@Todo:driver, store device temporarly in Commands CI if(commandsCI){ commandsCI.device = device; } var driverView = utils.addWidget(DriverView2,utils.mixin({ userData:commandsCI, driver:item, device:device, ctx:ctx, registerView:true, id:viewId },mixin),null,parent,true); parent.add(driverView,null,false); return driverView; }, ///////////////////////////////////////////////////////////////////////////////////// // // Server methods // ///////////////////////////////////////////////////////////////////////////////////// /** * updateItemMetaData updates a CI in the drivers meta data store * @param scope {string} * @param driverMetaPath {string} * @param dataPath {string} : /inputs * @param query * @param value * @param readyCB * @param errorCB * @returns {*} */ updateItemMetaData: function (scope, driverMetaPath, dataPath, query, value, readyCB, errorCB) { return this.callMethodEx(null, 'updateItemMetaData', [scope, driverMetaPath, dataPath, query, value], readyCB, false); }, /*** * setDriverScriptContent is storing a driver's actual code in a given scope on the server * @param scope {string} * @param path {string} * @param readyCB {function} * @param errorCB {function} * @returns {*} */ setDriverScriptContent: function (scope, path, content, readyCB, errorCB) { return this.callMethodEx(null, 'setDriverContent', [scope, path, content], readyCB, true); }, /*** * getDriverScriptContent is receiveing a driver's actual code in a given scope * @param scope {string} * @param path {string} * @param readyCB {function} * @param errorCB {function} * @returns {*} */ getDriverScriptContent: function (scope, path, readyCB, errorCB) { return this.callMethodEx(null, 'getDriverContent', [scope, path], readyCB, true); }, onDriverModified:function(evt){ debug &amp;&amp; console.log('on driver modified',this.getStore()); var store = this.getStore(); var item = evt.driver; if(item.commandsItem) { utils.removeFromStore(store, item.commandsItem, true, 'path', 'parentId'); } if(item.variablesItem) { utils.removeFromStore(store, item.variablesItem, true, 'path', 'parentId'); } item._completed=false; this.completeDriver(store,item,item); }, onAllComponentsLoaded:function(components){ debug &amp;&amp; console.log('components loaded!',components); }, init:function(){ var thiz = this, EVENTS = types.EVENTS; this.subscribe([ EVENTS.ON_CI_UPDATE, EVENTS.ON_WIDGET_READY, EVENTS.ON_MAIN_VIEW_READY, EVENTS.ON_SCOPE_CREATED, EVENTS.ON_DRIVER_MODIFIED, EVENTS.ON_ALL_COMPONENTS_LOADED, EVENTS.ON_STORE_CREATED]); this.subscribe(EVENTS.ON_DEBUGGER_READY, function (evt) { setTimeout(function () { thiz.onDebuggerReady(evt) }, 1500); }, this); this.subscribe([EVENTS.ON_DRIVER_GROUP_SELECTED, EVENTS.ON_DRIVER_SELECTED], this.onItemSelected); this.subscribe(EVENTS.ON_ACE_READY, this.onACEReady); }, onACEReady: function (evt) { var add = true; if (evt.owner &amp;&amp; evt.owner.userData &amp;&amp; evt.owner.userData.widget &amp;&amp; evt.owner.userData.widget.item) { var variable = evt.owner.userData.widget.item; var scope = variable.scope; var variables = scope.getVariables({ group: 'basicVariables' }); var _responseVariables = scope.getVariables({ group: 'processVariables' }); if (_responseVariables &amp;&amp; _responseVariables.length) { variables = variables.concat(_responseVariables); } var completors = []; function createCompleter(text, value, help) { return { word: text, value: value, meta: help || '' }; } if (variables &amp;&amp; variables.length &gt; 0) { for (var i = 0; i &lt; variables.length; i++) { var obj = variables[i]; completors.push(createCompleter(obj.name, obj.value, 'Driver Variable')); } } if (completors.length) { evt.aceEditor.addAutoCompleter(completors); } } }, debugDriver: function (ci, storeItem) { //http://192.168.1.37:9090/debug?port=5858 var dbgManager = this.ctx.getDebugManager(); var driver = storeItem; //1.pick up meta data var meta = driver['user']; //2. pick meta data path var path = driver['path']; //3. pick scope var scope = driver['scope']; //4. pick name var name = driver['name']; //5. pick 'inputs' from meta var cis = meta['inputs']; //6. pick script ci var scriptCI = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS); //7. pick script ci's value var scriptCIValue = utils.toString(scriptCI['value']); //8. alternate way to pick a CI value var scriptCIValue2 = utils.getCIInputValueByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS); this.ctx.getDebugManager().debugDriver(scriptCIValue, { owner: this, storeItem: storeItem }); }, onVariableAction: function (scope, driver, removed) { if (driver &amp;&amp; scope) { var meta = driver['user']; //put variables from CI storage into scope var ci = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_VARIABLES); var variables = scope.variablesToJson(); var variablesString = JSON.stringify(variables, null, 2); this.updateCI(ci, JSON.stringify(variables, null, 2), '', driver); } }, reload: function () { var thiz = this; this.currentItem = null; this.ls('system_drivers', function () { if (thiz.treeView) { thiz.treeView.reload(thiz.store); } }); }, getDriversAsEnumeration: function (store) { try { var options = []; store = store || this.getStore() || this.store; if (!store) { console.error('getDriversAsEnumeration:: have no store!'); return options; } var items = store.query({ isDir: false }); if (!_.isArray(items)) { items = [items]; } for (var i = 0; i &lt; items.length; i++) { var driver = items[i]; var meta = driver['user']; var id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID); var title = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME); if(!meta){ continue; } options.push({ value: utils.toString(id['value']), label: utils.toString(title['value']), driver:driver }) } return options; }catch(e){ debug &amp;&amp; console.error('getDriversAsEnumeration failed',e); logError(e,'getDriversAsEnumeration failed'); return options; } }, onDriverSettingsChanged: function (ci, storeRef) { debug &amp;&amp; console.log('onDriverSettingsChanged',ci); this.ctx.getDeviceManager().onDriverSettingsChanged(ci, storeRef); }, saveDriver:function(storeRef){ debug &amp;&amp; console.log('save driver ',storeRef); var scope = this.ctx.getBlockManager().getScope(storeRef['id']); var meta = storeRef['user']; //save variables var variableCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_VARIABLES); //save blocks var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS); var blocksEvent = { ci:commandsCI, newValue:'', oldValue:&quot;0&quot;, storeItem:storeRef, owner:this } this.onCIUpdate(blocksEvent); //save responsie-params var resonseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES); var rEvent = { ci:resonseCI, newValue:'', oldValue:&quot;0&quot;, storeItem:storeRef, owner:this } this.onCIUpdate(rEvent); this.onDriverSettingsChanged(resonseCI,storeRef); }, updateCI: function (ci, newValue, oldValue, storeRef) { if (ci &amp;&amp; newValue!==null &amp;&amp; storeRef) { if (utils.toString(ci.name) == types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS || utils.toString(ci.name) == types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES) { this.onDriverSettingsChanged(ci, storeRef); } this.updateItemMetaData( utils.toString(storeRef.scope), //the scope of the driver utils.toString(storeRef.path), //the relative path of the driver '/inputs', //the path of the CIS in the meta db { id: utils.toString(ci.id) }, { value: newValue, params: utils.toString(ci['params']) } ); } }, ///////////////////////////////////////////////////////////////////////////////////// // // CI Updates // ///////////////////////////////////////////////////////////////////////////////////// onCIUpdate: function (evt) { var ci = evt.ci; var storeItem = ci ? ci.driver : null; if(storeItem){ var driver = this.getDriverById(storeItem.id); if(driver){ this.updateCI(evt.ci, evt.newValue, evt.oldValue, driver); } } }, /** * * @param store * @param device * @param driver */ completeDriver: function (store, device, driver) { if (!driver.id) { console.error('have no id!'); } debug &amp;&amp; console.log('complete driver ' + driver.name); var isDevice = device!=driver; var parentId = isDevice ? device.path : driver.path, ctx = this.ctx, blockManager = ctx.getBlockManager(), scope = null; if(!blockManager){ console.error('no block manager'); return; } var commandsRoot = parentId + '_commands'; var variablesRoot = parentId + '_variables'; function wireStore(store){} if(!isDevice &amp;&amp; !driver.blockScope){ scope = driver.blockScope = this.ctx.getBlockManager().createScope({ id:driver.id, device:null, driver:driver, instance:null, ctx:this.ctx, getContext:function(){ return this.instance; } },dojo.clone(driver.blox.blocks)); } var driverScope = scope; var commands = { path: parentId + '_commands', name: 'Commands', isDir: true, type: 'leaf', parentId: parentId, virtual: true, isCommand:true, icon:'fa-folder', children:[] }, variables = { path: parentId + '_variables', name: 'Variables', isDir: true, type: 'leaf', parentId: parentId, virtual: true, icon:'fa-folder', children:[] }, thiz = this, CIS = driver.user, toolbar = this.ctx.mainView.getToolbar(); //complete commands store.putSync(commands); driver.commandsItem=commands; driver.children = []; driver.children.push(commands); driver.children.push(variables); //complete CIS _.each(CIS.inputs,function(ci){ ci.driver=driver; ci.actionTarget=toolbar; ci.ctx = ctx; ci.registerView=function(grid){ ctx.getWindowManager().registerView(grid,false); } }); var commandBlocks = driverScope.getBlocks({ group: types.COMMAND_TYPES.BASIC_COMMAND, parentId:null }).concat(driverScope.getBlocks({ group: types.COMMAND_TYPES.CONDITIONAL_COMMAND, parentId:null })); function createReference(block,driver,title,icon){ var _isVariable = block.declaredClass.indexOf('Variable') !==-1; var _parent = _isVariable ? variables.path : commands.path; if(block.declaredClass.indexOf( _isVariable? 'Variable' : 'Command')==-1){ return; } var reference = new Reference({ enabled:true, path: _parent + '_reference_'+block.id, name: title, id: block.id, parentId: _parent, _mayHaveChildren: false, virtual: true, tooltip: true, icon:icon, ref: { driver: driver, item: block, device:device }, type: types.ITEM_TYPE.BLOCK }); reference = store.putSync(reference); _isVariable ? variables.children.push(reference) : commands.children.push(reference); block.addReference(reference,{ properties: { &quot;name&quot;:true, &quot;enabled&quot;:true, &quot;value&quot;:true }, onDelete:true },true); reference.refresh(); } if(!driverScope._didSubribeToStoreChanges){ driverScope._didSubribeToStoreChanges=true; if(driverScope.blockStore) { driverScope.blockStore.on('added', function (item) { if (!item.parentId) { createReference(item, driver, item.name); } }); } } _.each(commandBlocks,function(block){ createReference(block,driver,block.name,block.icon || 'fa-exclamation'); }); //complete variables driver.variablesItem=variables; store.putSync(variables); var basicVariables = driverScope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES }).concat(driverScope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES })); _.each(basicVariables,function(variable){ createReference(variable,driver,variable.name,variable.icon || 'fa-exclamation'); }); }, /** * Callback when a CI based widget has been rendered * This will may be complete xide standard widgets. * @param evt */ onWidgetReady: function (evt) { var thiz = this; /*** * Widget completion */ if (evt['owner'] == this // must come from us &amp;&amp; evt['ci'] != null // we need an CI &amp;&amp; evt['ci'].name === types.DRIVER_PROPERTY.CF_DRIVER_CLASS // we need an CI &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null // we need a store reference &amp;&amp; utils.toInt(evt['ci'].type) === types.ECIType.FILE) //must be a file widget { this.onDriverClassFileWidgetCreated(evt.widget, evt.ci, evt.storeItem); } //add a scope to driver command settings widget if (evt['owner'] == this // must come from us &amp;&amp; evt['ci'] != null // we need an CI &amp;&amp; evt['ci'].name === types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS // we need an CI &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null) // we need a store reference { //give this man a cookie! if (!evt['widget']['blockScope']) { evt['widget']['blockScope'] = thiz.ctx.getBlockManager().getScope(utils.toString(evt['storeItem']['id']), evt); } } //add a scope to driver response settings widget if (evt['owner'] == this // must come from us &amp;&amp; evt['ci'] != null // we need an CI &amp;&amp; evt['ci'].name === types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES // we need an CI &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null) // we need a store reference { var blockManager = thiz.ctx.getBlockManager(); var scopeId = evt['storeItem']['id']; var scope = blockManager.getScope(scopeId); //give this man a cookie! if (!evt['widget']['blockScope']) { evt['widget']['blockScope'] = thiz.ctx.getBlockManager().getScope(utils.toString(evt['storeItem']['id']), evt); } } //add a scope to driver variable settings widget if (evt['owner'] == this // must come from us &amp;&amp; evt['ci'] != null // we need an CI &amp;&amp; utils.toString(evt['ci'].name) === types.DRIVER_PROPERTY.CF_DRIVER_VARIABLES &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null) // we need a store reference { //give this man a cookie! if (!evt['widget']['blockScope']) { evt['widget']['blockScope'] = thiz.ctx.getBlockManager().getScope(utils.toString(evt['storeItem']['id']), evt); } } if ( evt['ci'] != null // we need an CI &amp;&amp; utils.toString(evt['ci'].name) === types.DEVICE_PROPERTY.CF_DEVICE_DRIVER &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null // we need a store reference &amp;&amp; utils.toInt(evt['ci'].type) === types.ECIType.ENUMERATION) //must be a file widget { //this.onDriverClassFileWidgetCreated(evt.widget,evt.ci,evt.storeItem); } }, /*** * Callback when a file widget has been created. We extend this widget for one more buttons: * * @param widget * @param ci * @param storeItem */ onDriverClassFileWidgetCreated: function (widget, ci, storeItem) { var thiz = this; /*** * Change file picker options */ var ctx = this.ctx; var xFileConfig = types.config; return ; /* var vfsConfigs = this.ctx.vfsConfigs; var vfsDriverConfig = factory.cloneConfig(xFileConfig); var xFileContext = null; var rootStore = xFileContext.getStore('system_drivers', { &quot;fields&quot;: 1663, &quot;includedFileExtensions&quot;: &quot;js&quot;, &quot;excludedFileExtensions&quot;: &quot;*&quot; }); var filePanelOptions = { cookiePrefix: 'driver', sources: [ { name: 'System', path: 'system_drivers', iconClass: 'fileSelectDiscIcon' }, { name: 'User', path: 'user_drivers', iconClass: 'fileSelectDiscIcon' }, { name: 'App', path: 'app_drivers', iconClass: 'fileSelectDiscIcon' } ], delegate: xFileContext.getPanelManager() }; var xFileSelectDialogOptions = { store: rootStore, config: vfsDriverConfig, title: 'Select Driver', filePanelOptions: filePanelOptions }; widget.options = xFileSelectDialogOptions; widget.debugButton = factory.createButton( widget.getFreeExtensionSlot(),//the widget knows where to add new items &quot;el-icon-puzzle&quot;, //eluisve icon class &quot;elusiveButton&quot;, //elusive button class adjustments &quot;&quot;, //no label &quot;&quot;, //no extra dom style markup function () { //button click callback thiz.debugDriver(ci, storeItem); }, this); widget.editButton = factory.createButton( widget.getFreeExtensionSlot(),//the widget knows where to add new items &quot;el-icon-file-edit&quot;, //eluisve icon class &quot;elusiveButton&quot;, //elusive button class adjustments &quot;&quot;, //no label &quot;&quot;, //no extra dom style markup function () { //button click callback thiz.editDriver(ci, storeItem); }, this); */ }, /** * * @param ci * @param storeItem */ editDriver: function (ci, storeItem) { var thiz = this; var driver = storeItem; var ctx = thiz.ctx; var meta = driver['user']; var name = driver['name']; var driverPath = utils.getCIInputValueByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS); var scope = utils.toString(driver['scope']), docker = ctx.mainView.getDocker(); var where = ctx.mainView.layoutCenter; var title = name + '.' + utils.getFileExtension(driverPath); var parent = docker.addTab(null,{ title:title, target:where ? where._parent : null, icon:'fa-code' }); try { var view = utils.addWidget(Editor, { style:'height:inherit', ctx: this.ctx, item:{ }, /*** * Provide a text editor store delegate */ storeDelegate: { getContent: function (onSuccess) { //1.pick up meta data thiz.getDriverScriptContent(scope, driverPath, onSuccess); }, saveContent: function (value, onSuccess, onError) { //1.pick up meta data thiz.setDriverScriptContent(scope, driverPath, value, onSuccess); } }, options:{ filePath:'.js', fileName:name + '.' + utils.getFileExtension(driverPath) }, title: name + '.' + utils.getFileExtension(driverPath), fileName: driverPath }, this, parent, true); ctx.getWindowManager().registerView(view); view.resize(); return view; } catch (e) { logError(e); } }, /*** * openDriverSettings creates a new settings view for a driver * @param item * @returns {xide.views.CIGroupedSettingsView} */ ///////////////////////////////////////////////////////////////////////////////////// // // UX related functions, @TODO : move it to somewhere else // ///////////////////////////////////////////////////////////////////////////////////// deleteItem: function (item) { //delete subs var store = this.getStore(item.scope) || this.store; var parent = item.getParent(); store.removeSync(item.path); this.onDriverRemoved(store,item); if(parent){ store.refreshItem(parent); } }, onDeleteItem: function (item) { debug &amp;&amp; console.log('onDeleteItemx',item); var isDir = utils.toBoolean(item.isDir) === true; var dfd = new Deferred(); //pick the right service function var removeFn = isDir ? 'removeGroup' : 'removeItem'; var thiz = this; var actionDialog = new _CIDialog({ title: 'Remove Driver' + (isDir ? ' Group' : '') + ' ' + &quot;\\&quot;&quot; + item.name + &quot;\\&quot; &quot;, style: 'max-width:400px', titleBarClass: 'text-danger', onOk: function (dlg) { var store = thiz.getStore(item.scope); thiz[removeFn]( utils.toString(item.scope), utils.toString(item.path), utils.toString(item.name), function () { thiz.deleteItem(item); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: store, action: types.DELETE, item: item }); store.emit(null); dfd.resolve(); }); } }); actionDialog.show(); return dfd; }, /** * Creates new driver group dialog */ newGroup: function (item,scope) { var thiz = this; var currentItem = item; var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; var store = this.getStore(scope); var dfd = new Deferred(); var actionDialog = new _CIDialog({ title: 'New Driver Group', titleBarClass: 'text-info', size: types.DIALOG_SIZE.SIZE_SMALL, onOk: function (dlg, data) { var title = this.getField('Title'); var scope = this.getField('Scope'); var _final = parent + '/' + title; thiz.createGroup(scope, _final, function (response) { var newItem = thiz.createNewGroupItem(title, scope, parent); store = thiz.getStore(scope); var _newItem = store.putSync(newItem); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: store, action: types.NEW_DIRECTORY, item: newItem }); store.refreshItem(parent); store.refreshItem(_newItem); dfd.resolve(_newItem); }); }, delegate: {}, ctx: this.ctx, cis: [ utils.createCI('Title', 13, ''), utils.createCI('Scope', 3, scope|| this.defaultScope, { &quot;options&quot;: [ { label: 'System', value: 'system_drivers' }, { label: 'User', value: 'user_drivers' }, { label: 'App', value: 'app_drivers' } ] }) ] }); actionDialog.show(); return dfd; }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean protocol impl. // ///////////////////////////////////////////////////////////////////////////////////// onItemSelected: function (item) { this.currentItem = item; }, /** * Bean UX function to create a new item by opening a dialog, followed by a server call */ newItem: function (currentItem) { var dfd = new Deferred(); if (!currentItem) { currentItem = { path: &quot;&quot; } } var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; var scope = currentItem.scope || 'system_drivers'; var templateUrlMeta = require.toUrl('system_drivers/Default.meta.json'); var meta = utils.getJson(this._getText(templateUrlMeta)); var templateUrlDriverCode = require.toUrl('system_drivers/Default.js'); var driverCode = this._getText(templateUrlDriverCode); var nameCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME); var idCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID); var scriptPathCi = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS); var store = this.getStore(scope); var thiz = this; idCi.value = utils.createUUID(); nameCi.value = 'My New Driver'; var actionDialog = new _CIDialog({ title: 'New Driver', resizable: true, titleBarClass: 'text-info', onCancel:function(){ dfd.resolve(); }, onOk: function (dlg, data) { if (nameCi.value !== 'Default') { try { scriptPathCi.value = './' + parent + '/' + nameCi.value + '.js'; var metaOut = JSON.stringify(meta,null,2); if (parent.length == 0) { parent = &quot;/&quot;; } try { thiz.createItem(scope, parent, nameCi.value, metaOut, driverCode).then(function (data) { var newItem = thiz.createNewItem(nameCi.value, scope, parent); newItem.path += '.meta.json'; newItem.user = meta; newItem.id = idCi.value; newItem.blox = { blocks: [], variables: [] } newItem = store.putSync(newItem); thiz.onDriverCreated(store); thiz.completeDriver(store, newItem, newItem); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: store, action: types.NEW_FILE, item: newItem }); dfd.resolve(newItem); }); }catch(e){ logError(e); } } catch (e) { logError(e,'error in CIDialog'); } } }, cis: [ nameCi, utils.createCI('Scope', 3, scope, { group: 'General', value:'system_drivers', options: [ { label: 'System', value: 'system_drivers' }, { label: 'User', value: 'user_drivers' }, { label: 'App', value: 'app_devices' } ] }) ] }); actionDialog.show(); return dfd; } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DriverManager_Server.js.html":{"id":"manager_DriverManager_Server.js.html","title":"Source: manager/DriverManager_Server.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DriverManager_Server.js define([ 'dcl/dcl', &quot;dojo/_base/lang&quot;, 'dojo/_base/declare', 'xide/types', 'xide/utils' ], function(dcl,lang,declare,types,utils){ function isItemPath(startNeedle,path){ var _start = startNeedle; if (path.indexOf(_start) != -1) { var libPath = path.substr(path.indexOf(_start) + (_start.length + 1 ), path.length); return libPath; } return null; } return dcl(null,{ declaredClass:'xcf.manager.DriverManager_Server', onDriverBlocksChanged:function(dataPath,shortPath){ var options = []; var store = this.getStore() || this.store; if (!store) { console.error('getDriversAsEnumeration:: have no store!'); return options; } var items = store.query({ isDir: false }); for (var i = 0; i &lt; items.length; i++) { var driver = items[i]; var meta = driver['user']; var id = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_ID); var title = utils.getInputCIByName(meta, types.DRIVER_PROPERTY.CF_DRIVER_NAME); if(!meta || !driver.blockPath){ continue; } if(driver.blockPath.indexOf(shortPath)!==-1){ } } }, onFileChanged:function(evt){ if(evt.type!=='changed'){ return; } if(evt._didb){ return; } evt._didb=true; var path = utils.replaceAll('\\\\', '/', evt.path); path = utils.replaceAll('//', '/', path); path = path.replace(/\\\\/g,&quot;/&quot;); ////data/system/drivers/SSH/Hercules.xblox' var isDriver = isItemPath('system/driver',path); if(isDriver &amp;&amp; isDriver.indexOf('.xblox')!==-1){ console.log('driver blocks changed ' + isDriver + ' @ '+ path, evt); this.onDriverBlocksChanged(path,isDriver); } }, /** * * @param storeItem * @param readyCB */ createDriverInstance:function(storeItem,readyCB){ var thiz=this; var baseDriverPrefix = this.driverScopes['system_drivers']; var baseDriverRequire = baseDriverPrefix + 'DriverBase'; //console.error(baseDriverRequire); require([baseDriverRequire],function(baseDriver){ baseDriver.prototype.declaredClass=baseDriverRequire; var meta = storeItem['user']; var driverPrefix = thiz.driverScopes[storeItem['scope']]; var driver = utils.getCIInputValueByName(meta,types.DRIVER_PROPERTY.CF_DRIVER_CLASS); if(!driver){ console.error('cant find driver class in meta'); return; } var requirePath = driverPrefix + driver; requirePath=requirePath.replace('.js',''); requirePath=requirePath.replace('./',''); console.log('create driver instance ' + requirePath); require([requirePath],function(driverProtoInstance){ var baseClass = baseDriver; var baseClasses = [baseClass]; var driverProto = declare([baseClass],driverProtoInstance.prototype); var driverInstance = new driverProto(); driverInstance.baseClass = baseClass.prototype.declaredClass; driverInstance.modulePath = utils.replaceAll('//','/',requirePath); driverInstance.delegate=thiz; storeItem.instance = driverInstance; if(readyCB){ readyCB(driverInstance); } try{ driverInstance.start(); }catch(e){ } return driverInstance; }); }); }, onDeviceDisconnected:function(evt){ /*console.log('device disconnected');*/ }, onDeviceMessage:function(evt){ if(evt &amp;&amp; evt['device'] &amp;&amp; evt['driverInstance']){ var _deviceInfo=evt['device']; var _driverInstance=evt['driverInstance']; var _driverOptions =_driverInstance['options']; if(!_driverOptions)return; //split message; var messages=[evt.deviceMessage]; if( lang.isString(evt.deviceMessage) &amp;&amp; evt.deviceMessage.indexOf(_driverInstance.lineBreak)!=-1){ messages=[]; messages=evt.deviceMessage.split(_driverInstance.lineBreak); } //forward to blox if(messages.length&gt;0){ var scope=this.ctx.getBlockManager().getScope(_driverOptions.id); var blockStore=scope.blockStore; var responseBlocks = scope.getBlocks({ group:types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_BLOCKS }); var responseVariables = scope.getVariables({ group:types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES }); if(!responseBlocks || responseBlocks.length==0){ console.log('have no response blocks, abort'); } var responseVariable = scope.getVariable('value'); if(responseVariable){ }else{ responseVariable = new Variable({ id:utils.createUUID(), title : 'value', value : '', scope : scope, type : 13, group : 'processVariables', gui:false, cmd:false }); } for(var i=0; i &lt; messages.length ; i++){ if(messages[i].length==0){ continue; } //update system variable 'value' responseVariable.value=messages[i]; console.log('update process value '+responseVariable.value + ' for ' + _deviceInfo.host); this.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED,{ item:responseVariable, scope:scope, owner:this }); //now run each top-variabl block in 'conditional process' for(var j=0; j &lt; responseVariables.length ; j++){ //console.profile('profiling response variable'); if(responseVariables[j].title=='value'){ continue; } scope.expressionModel.parseVariable(scope,responseVariables[j]); //console.profileEnd(); } //now run each top-level block in 'conditional process' for(var j=0; j &lt; responseBlocks.length ; j++){ scope.solveBlock(responseBlocks[j],{highlight:true}); } } console.log('forward messages to scope'); } } }, init:function(){ this.subscribe(types.EVENTS.ON_DEVICE_MESSAGE,this.onDeviceMessage); this.subscribe(types.EVENTS.ON_DEVICE_DISCONNECTED,this.onDeviceDisconnected); } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_Application_UI.js.html":{"id":"manager_Application_UI.js.html","title":"Source: manager/Application_UI.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/Application_UI.js define([ 'dcl/dcl', 'require', 'dojo/_base/declare', 'dojo/_base/lang', 'xide/utils', 'xcf/views/DriverTreeView', 'xcf/views/DeviceTreeView', 'xcf/views/ProtocolTreeView', 'xide/types', 'xide/factory', 'xace/views/Editor', 'xide/Wizards', 'xide/views/CIView', 'dojo/has', 'xide/editor/Default', 'xide/layout/_Accordion', 'xide/widgets/WidgetBase', 'xide/views/ACEEditor', &quot;xcf/views/_MainView&quot;, 'xaction/Action', &quot;xide/mixins/PersistenceMixin&quot;, &quot;xide/views/JsonEditor&quot;, 'xide/widgets/JSONDualEditorWidget', 'xdojo/has!xcf-ui?xide/editor/Registry' ], function (dcl,require,declare, lang,utils, DriverTreeView, DeviceTreeView, ProtocolTreeView, types, factory, Editor, Wizards, CIView,has,Default,_Accordion, WidgetBase,ACEEditor,_MainView,Action,PersistenceMixin,JSONEditor,JSONDualEditorWidget,Registry,FileConsole) { var Persistence = dcl([PersistenceMixin.dcl], { declaredClass:'xcf.manager.ApplicationPersistence', defaultPrefenceTheme: 'idle_fingers', defaultPrefenceFontSize: 14, saveValueInPreferences: true, cookiePrefix:'_xcf_application', getDefaultPreferences: function () { return utils.mixin( { theme: this.defaultPrefenceTheme, fontSize: this.defaultPrefenceFontSize }, this.saveValueInPreferences ? { } : null); }, onAfterAction: function (action) { //var _theme = this.getEditor().getTheme(); this.savePreferences({ /* theme: _theme.replace('ace/theme/', ''), fontSize: this.getEditor().getFontSize() */ }); return this.inherited(arguments); }, /** * Override id for pref store: * know factors: * * - IDE theme * - per bean description and context * - by container class string * - app / plugins | product / package or whatever this got into * - **/ toPreferenceId: function (prefix) { prefix = ''; return (prefix || this.cookiePrefix || '') + '_xcf_application'; }, getDefaultOptions: function () { //take our defaults, then mix with prefs from store, var _super = this.inherited(arguments), _prefs = this.loadPreferences(null); (_prefs &amp;&amp; utils.mixin(_super, _prefs) || //else store defaults this.savePreferences(this.getDefaultPreferences())); return _super; } }); return dcl(Persistence.dcl,{ declaredClass:&quot;xcf.manager.Application_UI&quot;, mainView: null, leftLayoutContainer: null, rightLayoutContainer: null, showGUI: true, showFiles: true, lastPane: null, _lastWizard: null, _maximized:false, openFile:function(args){ var self = this; var _editor=args.editor; var editor = Registry.getEditor(_editor) || Registry.getDefaultEditor({ path:args.file }) || Registry.getEditor('Default Editor'); var _require = window['eRequire']; var app = _require('electron').remote.app; var BrowserWindow = _require('electron').remote.BrowserWindow; var wind = BrowserWindow.getFocusedWindow() || BrowserWindow.mainWindow; wind &amp;&amp; wind.setTitle(args.file); if(editor){ var editorInstance = editor.onEdit({ path:args.file, mount:'__direct__', getPath:function(){ return this.path; } }) if(editorInstance._on) { this.ctx.getWindowManager().registerView(editorInstance, true); }else if(editorInstance.then){ editorInstance.then(function(instance){ self.ctx.getWindowManager().registerView(instance, true); }); } }else{ console.error('--have no editor ',args.editor); } }, /*** * Register custom types */ registerCustomTypes: function () { var _t = types; /*** * Network settings */ types.registerType(types.ECIType.DEVICE_NETWORK_SETTINGS, [ utils.createCI('Host', 13, '192.168.1.20', { group: 'Network' }), utils.createCI('Protocol', 3, 'tcp', { group: 'Network', options:[ { label:&quot;TCP&quot;, value:&quot;tcp&quot; }, { label:&quot;UDP&quot;, value:&quot;tcp&quot; }, { label:&quot;Driver&quot;, value:&quot;driver&quot; }, { label:&quot;SSH&quot;, value:&quot;ssh&quot; }, { label:&quot;Serial&quot;, value:&quot;serial&quot; }, { label:&quot;MQTT&quot;, value:&quot;mqtt&quot; } ] }), utils.createCI('Port', 13, '23', { group: 'Network' }), utils.createCI('Options', 28, '{}', { group: 'Network' }) ]); /* Widget Mappings */ //commands //types.registerWidgetMapping('CommandSettings', 'xcf.widgets.CommandSettings'); types.registerWidgetMapping('CommandSettings', 'xcf.widgets.CommandSettings'); //variables //types.registerWidgetMapping('VariableSettings', 'xcf.widgets.VariableSettings'); //responses //types.registerWidgetMapping('ResponseSettings', 'xcf.widgets.ResponseSettings'); }, /** * * @param clear * @param open * @returns {*} */ onMainViewReady: function (view) { var thiz = this; /** * Register Help Action */ var helpAction = Action.createDefault('Driver Guide', 'fa-cube', 'Help/Driver', '_a', null, { permanent: true, handler: function () { window.open('../../../docs/daux') } }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, null). setVisibility(types.ACTION_VISIBILITY.MAIN_MENU, {}). setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, null); thiz.publish(types.EVENTS.REGISTER_ACTION, { owner: thiz, action: helpAction }); var helpAction = Action.createDefault('Widget Guide', 'fa-cube', 'Help/Widgets', '_a', null, { permanent: true, handler: function () { window.open('../../../docs/daux/Interface_Designer/Guide') } }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, null). setVisibility(types.ACTION_VISIBILITY.MAIN_MENU, {}). setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, null); thiz.publish(types.EVENTS.REGISTER_ACTION, { owner: thiz, action: helpAction }); var helpAction = Action.createDefault('jQuery', 'fa-cube', 'Help/jQuery', '_a', null, { permanent: true, handler: function () { window.open('../../../docs/jQuery/index.html') } }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, null). setVisibility(types.ACTION_VISIBILITY.MAIN_MENU, {}). setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, null); thiz.publish(types.EVENTS.REGISTER_ACTION, { owner: thiz, action: helpAction }); if (this.logPanel || has('log') == false) { return; } thiz.registerEditorExtensions(); return; }, /** * Main entry point, does: * - create the main view * - registers custom types and enumerations * - loads data and adds data views * - initializes XFile */ start: function (showGUI, rootSelector,args) { var thiz = this; this.args = args; this.showGUI = showGUI; var ACTION = types.ACTION; var container = $(rootSelector || '#root')[0]; var permissons = [ ACTION.BREADCRUMB, //ACTION.RIBBON, ACTION.MAIN_MENU, ACTION.NAVIGATION, ACTION.STATUSBAR, ACTION.TOOLBAR, ACTION.WELCOME ]; var isEditor = false; console.info('---start main view with args',args); if(has('electron') &amp;&amp; args){ if(args.file){ permissons = [ ACTION.MAIN_MENU ] isEditor = true; } } var MainViewClass = dcl(_MainView, { getNewAlternateTarget: function () { return this.layoutCenter; }, getToolbar: function () { return this.toolbar; }, getNewDefaultTab: function (args) { utils.mixin(args, { target: this.layoutCenter, location: types.DOCKER.DOCK.STACKED }); var tab = this.getDocker().addTab(null, args); return tab; }, _onResize: function () { this.getDocker().resize(); }, resize: function () { this.getDocker().resize(); }, _resizeToWindow: function () { var target = $('#root')[0]; var staticTop = $('#staticTopContainer'); var staticTopH = 0; if (staticTop &amp;&amp; staticTop) { staticTopH = staticTop.height(); } utils.resizeTo(target, window, true, true, null, { h: -staticTopH }); if (this.layoutMain) { utils.resizeTo(this.layoutMain, target, true, true); this.layoutMain.resize(); var _total = $('#root').height(); _total -= this.extraBottomHeight; _toolbar -= staticTopH; var _toolbar = $(this.layoutTop.domNode).height(); $(this.layoutCenter.domNode).css('height', _total - _toolbar); } this.getDocker().resize(); }, __createLayout: function (docker, permissions) { this.inherited(arguments); this.layoutCenter = docker.addPanel('DefaultTab', types.DOCKER.DOCK.RIGHT, this.layoutLeft, { w: '80%', title: 'Welcome', mixin: { isDefault: true } }); this.layoutCenter.closeable(false); this.toolbar = utils.addWidget(Ribbon, { store: new ActionStore({}), flat: false }, this, this.layoutTop, true); var self = this, toolbar = this.toolbar; toolbar._on('RibbonClosed', function (evt) { setTimeout(function () { self.layoutTop.resize(); }, 1) }); toolbar._on('RibbonExpand', function (evt) { self._onResize(); self.resize(); setTimeout(function () { self.layoutTop.resize(); }, 1) }); toolbar._on('setActionEmitter', function (evt) { self._onResize(); self._resizeToWindow(); if (toolbar.isOpen) { setTimeout(function () { self.layoutTop.resize(); }, 1) setTimeout(function () { factory.publish(types.EVENTS.RESIZE, { force: true }); }, 10); } }); this.toolbar._on(types.EVENTS.RESIZE, function (evt) { self._onResize(); }); function _resize() { self._resizeToWindow(); setTimeout(function () { self.publish(types.EVENTS.RESIZE, {}, this); }, 500); } $(window).resize(function () { return self.debounce('resize', _resize.bind(thiz), 1000, null); }); }, getLayoutLeft: function () { return this.layoutLeft; }, getLayoutCenter: function () { return this.layoutCenter; }, onOpenView:function(evt){ this.onOpenView2 &amp;&amp; this.onOpenView2(evt); }, startup: function () { var self = this; function _resize() { self._resizeToWindow(); setTimeout(function () { self.publish(types.EVENTS.RESIZE, {}, this); }, 500); } $(window).resize(function () { return self.debounce('resize', _resize.bind(self), 1000, null); }); setTimeout(function(){ _resize(); },5000); this.subscribe(types.EVENTS.ON_OPEN_VIEW); } }); var view = utils.addWidget(_MainView, { ctx: this.ctx, permissions: permissons, config: this.config, windowManager: this.ctx.getWindowManager(), container: container }, null, container, true); this.mainView = view; this.ctx.mainView = this.mainView; var leftContainer = view.layoutLeft; var docker = view.getDocker(); if(!isEditor) { var accContainer = utils.addWidget(_Accordion, { tabHeight: '500px' }, null, leftContainer, true); this.mainView.leftLayoutContainer = accContainer; this.leftLayoutContainer = accContainer; }else{ this.mainView.layoutCenter =this.mainView.layoutLeft; } var self = this; this.doComponents().then(function () { console.info('xcf:dockerTest:: all components loaded '); self.registerCustomTypes(); self.onComponentsReady(); setTimeout(function () { if(isEditor) { self.openFile(args); }else{ self.initData(); } view._resize(); }, 1000); }); }, /** * Register new editors for xfile */ registerEditorExtensions: function () { var ctx = this.ctx, thiz = this; Default.Implementation.ctx = ctx; Default.ctx = ctx; //ctx.registerEditorExtension('CF Project Editor', 'cfproject', 'fa-sliders', this); /* ctx.registerEditorExtension('Preview', 'jpg|png', 'el-icon-eye-open', this, true, null, FilePreview, { updateOnSelection: false });*/ /* xfileContext.registerEditorExtension('Visual Editor', 'cfhtml', 'fa-laptop', this, true, null, VisualEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, rightLayoutContainer: null, ctx: this.ctx, mainView: this.mainView }); */ //sample default text editor open function, not needed var editInACE = function (item, owner) { var where = null; if (owner) { //where = owner ? owner.newTarget : null; if (_.isFunction(owner.newTarget)) { where = owner.newTarget({ title: item.name, icon: 'fa-code' }); } } return Default.Implementation.open(item, where, null, null, owner); }; /* ctx.registerEditorExtension('Text Editor', 'cfhtml', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }); */ ctx.registerEditorExtension('Default Editor', '*', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx, defaultEditor: true }); /* ctx.registerEditorExtension('Text Editor', 'xblox', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }); ctx.registerEditorExtension('Text Editor', 'dhtml', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }); ctx.registerEditorExtension('Text Editor', 'html', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }); ctx.registerEditorExtension('Text Editor', 'md', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }); */ ctx.registerEditorExtension('JSON Editor', 'json', 'fa-code', this, true, null, JSONEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx, registerView: true }); types.registerCustomMimeIconExtension('cfhtml', 'fa-laptop'); this.registerSplitEditors(); }, init:function(){ this.ctx.addActions(this.getActions()); this.ctx.addActions(this.getThemeActions()); WidgetBase.prototype.ctx = this.ctx; var thiz = this; this.subscribe(types.EVENTS.ON_EXPRESSION_EDITOR_ADD_FUNCTIONS, this.onExpressionEditorAddFunctions); //this.subscribe(types.EVENTS.ON_STATUS_MESSAGE); if(has('consoleError') &amp;&amp; location.href.indexOf('consoleError')!==-1){ var console = (window.console = window.console || {}); var _consoleErrorOld = console.error; function consoleError(string,args){ thiz.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:string, type:'error' }); //_consoleErrorOld.apply(thiz,[string,args]); } console.error = consoleError; } }, getLayoutRightMain: function (clear, open) { var mainView = this.mainView; return mainView.getLayoutRightMain(clear, open); }, getRightTopTarget: function (clear, open) { var mainView = this.mainView; return mainView.getRightTopTarget(clear, open); }, onExpressionEditorAddFunctions: function (evt) { var widget = evt.widget; var root = evt.root; if(!widget || !root){ return; } var device = widget.device; if(!device){ return; } var driverInstance = device.driverInstance; var _Variables = widget.createBranch('Variables', root.items); root.items.push(widget.createLeaf('getVariable', 'this.getVariable(\\'variableName\\')', 'Variables', 'gets a variable', true, _Variables)); root.items.push(widget.createLeaf('setVariable', 'this.setVariable(\\'variableName\\')', 'Variables', 'sets a variable by name', true, _Variables)); if(driverInstance){ var _Driver = widget.createBranch('Driver', root.items); //root.items.push(widget.createLeaf('sendSettings', 'this.sendSettings', 'Driver', 'drivers sendSettings', true, _Driver)); for(var prop in driverInstance){ } } }, initWidgets: function () { //factory.showStandBy(false); }, initElectron:function(){ /* document.addEventListener('drop', function(e) { e.preventDefault(); e.stopPropagation(); }); */ document.addEventListener('dragover', function(e) { e.preventDefault(); e.stopPropagation(); }); /* webview.addEventListener('dragover', function(e) { e.preventDefault(); }); */ /* document.addEventListener('dragover',function(event){ event.preventDefault(); return false; },false); */ var self = this; document.addEventListener('drop',function(event){ event.preventDefault(); var pathsToOpen = Array.prototype.map.call(event.dataTransfer.files, function(file) { return file.path; }); if (pathsToOpen.length &gt; 0) { self.openFile({ file:pathsToOpen[0] }); } return false; },false); }, onComponentsReady:function(){ var thiz = this, ctx = thiz.ctx, windowManager = ctx.getWindowManager(), mainView = ctx.mainView, left = mainView.layoutLeft, container = thiz.leftLayoutContainer; Editor.ctx = thiz.ctx; Editor.prototype.ctx = thiz.ctx; $('#loadingWrapper').remove(); if(has('electron')){ this.initElectron(); }; }, addDeviceView:function(){ var view, ctx = this.ctx, deviceMgr = ctx.getDeviceManager(), windowManager = ctx.getWindowManager(), thiz = this, container = thiz.leftLayoutContainer; view = deviceMgr.treeView = utils.addWidget(DeviceTreeView, { title: 'Devices', collection: deviceMgr.getStore(), delegate: deviceMgr, blockManager: thiz.ctx.getBlockManager(), ctx:thiz.ctx, icon:'fa-sliders', showHeader:false, scope:'system_devices', open:true }, null, container, false); deviceMgr.onDeviceTreeViewCreated(deviceMgr.treeView); windowManager.registerView(view,false); setTimeout(function(){ view.startup(); view.select([0],null,true,{ focus:true, append:false, delay:1000 }).then(function(){ }); },500); }, initData: function () { var thiz = this, ctx = thiz.ctx, driverMgr = ctx.getDriverManager(), deviceMgr = ctx.getDeviceManager(), logMgr = ctx.getLogManager(), windowManager = ctx.getWindowManager(), mainView = ctx.mainView, toolbar = mainView.getToolbar(), docker = mainView.getDocker(), left = mainView.layoutLeft, container = thiz.leftLayoutContainer; Editor.ctx = thiz.ctx; Editor.prototype.ctx = thiz.ctx; $('#loadingWrapper').remove(); this.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:&quot;Load data, please wait&quot;, timeout:8000 }); //docker.registerPanelType('Navigator',Docker.defaultPaneType('','',false,true,true)); /** * Driver tree view, added as pane into the left accordion */ if (has('drivers')) { driverMgr.ls('system_drivers').then(function () { thiz.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:&quot;Load Drivers, please wait...&quot; }) /** * Device tree view, added as pane into the left accordion */ if (has('devices')) { deviceMgr.ls('system_devices').then(function () { thiz.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:&quot;Start Device View, please wait...&quot;, type:'success' }) if (thiz.showGUI) { thiz.addDeviceView(); } }); } if (thiz.showGUI) { try { var view = driverMgr.treeView = utils.addWidget(DriverTreeView, { title: 'Drivers', store: driverMgr.getStore(), delegate: driverMgr, blockManager: thiz.ctx.getBlockManager(), scope:'system_drivers', ctx:thiz.ctx, icon:'fa-exchange' }, driverMgr, thiz.leftLayoutContainer, false); windowManager.registerView(view,false); /* setTimeout(function(){ view.startup(); view.select([0],null,true,{ focus:true, append:false, delay:1000 }).then(function(){ }); },500);*/ thiz.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:&quot;Driver View Ready&quot; }) } catch (e) { console.error('Driver Tree-View creation failed : ' + e); } } /** * Load past logs */ if (has('log')) { logMgr.ls(function () {}); } }); }else if(has('drivers')) { deviceMgr.ls('system_devices'); } /** * Protocol tree view, added as pane into the left accordion */ if (has('protocols')) { this.ctx.getProtocolManager().ls('system_protocols').then(function () { var protocolMgr = thiz.ctx.getProtocolManager(); /* if (thiz.showGUI) { try { protocolMgr.treeView = utils.addWidget(ProtocolTreeView, { title: 'Protocols', store: protocolMgr.getStore(), delegate: protocolMgr, beanContextName: thiz.ctx.mainView.beanContextName }, protocolMgr, thiz.leftLayoutContainer, true); } catch (e) { console.error('Protocol Tree-View creation failed : ' + e); } } */ }); } this.ctx.mainView.resize(); this.ctx.mainView.layoutLeft.__update(); }, registerSplitEditors: function () { return; var thiz = this, ctx = this.ctx; var editInACE = function (args) { /*xfileContext.getScriptManager().onFileClicked(args);*/ thiz.openJsonEditor(args); }; ctx.registerEditorExtension('JSON Editor', 'json', 'fa-code', this, false, null, null, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: ctx }, { /** * this goes into _designCP * @param where * @param who * @param item * @returns {widgetProto|*|*} */ createLeftView: function (where, who, item) { var pane = factory.createPane('', '', where, {}, null); //var editor = pane.editor = new JSONEditorX({},pane.containerNode); var editor = pane.editor = utils.addWidget(JSONEditorX, {}, this, pane.containerNode, true); pane.getItemActions = function () { return editor.getItemActions(); }; pane.setValue = function (value) { var _json = dojo.fromJson(value); editor.setData(_json); }; pane.getValue = function () { return JSON.stringify(editor.getData(), null, 2); }; return pane; }, /** * this goes into _srcCP * @param where * @param who * @param item * @returns {widgetProto|*|*} */ createRightView: function (where, who, item) { var editor = Default.Implementation.open(item, where, { region: 'bottom', splitter: true, style: &quot;height:40%;padding:0px;overflow:hidden;&quot;, emits: { 'onViewShow': false, 'onItemSelected': false }, autoSelect: false }, false); var thiz = this; editor._on('setFirstContent', function (evt) { thiz.setLeftValue(evt.value); }); return editor; } }); /* xfileContext.registerEditorExtension('Text Editor', 'xblox', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: this.getXFileContext() }); xfileContext.registerEditorExtension('Text Editor', 'dhtml', 'fa-code', this, false, editInACE, ACEEditor, { updateOnSelection: false, leftLayoutContainer: this.leftLayoutContainer, ctx: this.getXFileContext() }); */ }, createProtocolWizard: function () { return; /** * tasks * * 1. wizard-page- one: read-only Protocol-tree-viewer (as picker) * * 1.1 * * */ try { var thiz = this; if (this._lastWizard) { this._lastWizard.dialog.hide().then(function () { thiz._lastWizard.dialog.destroy(); }); } } catch (e) { } /** * setup * * 1. create the dialog, * 2. create wizard * 3. add panes * * */ var wizardStruct = Wizards.createWizard('Select Protocol', false,{}); this._lastWizard = wizardStruct; var wizard = wizardStruct.wizard; var dialog = wizardStruct.dialog; /* var CIS = [ utils.createCI('Title', 13, ''), utils.createCI('Scope', 3, 'system_drivers', { &quot;options&quot;: [ { label: 'System', value: 'system_drivers' }, { label: 'User', value: 'user_drivers' }, { label: 'App', value: 'app_drivers' } ] }) ]; var ciView = utils.addWidget(CIView, { viewStyle: 'padding:0px;', options: { groupOrder: { 'General': 0, 'Advanced': 1, 'Description': 2 } }, cis: CIS }, this, wizard, true, null, [WizardPaneBase]); ciView.initWithCIS(CIS); */ var protocolMgr = thiz.ctx.getProtocolManager(); var selectView = null; var selectItemsView = null; var selectedItems = [], selectedItem = null; var store = protocolMgr.getStore(); var done = function(){ wizard.destroy(); dialog.destroy(); } dialog.show().then(function () { /** * First protocol view, select item */ selectView = utils.addWidget(ProtocolTreeView, { title: 'Protocols', store: protocolMgr.getStore(), delegate: protocolMgr, beanContextName:'3',// thiz.ctx.mainView.beanContextName _doneFunction:function(){ return false; }, passFunction:function(){ return true; }, canGoBack:true, gridParams:{ showHeader:true } }, protocolMgr, wizard, true,null,[WizardPaneBase]). _on(types.EVENTS.ON_ITEM_SELECTED, function(evt){ selectedItem = evt.item; wizard.adjustWizardButton('next',selectView.isGroup(evt.item)); }); setTimeout(function(){ selectView.grid.set('collection',store.filter(selectView.getRootFilter())); selectView.grid.refresh(); },200); /** * Select commands/variables view */ /** * First protocol view, select item */ selectItemsView = utils.addWidget(ProtocolTreeView, { title: 'Protocols', store: protocolMgr.getStore(), delegate: protocolMgr, beanContextName:'3',// thiz.ctx.mainView.beanContextName doneFunction:function(){ done(); return true; }, passFunction:function(){ //not used return true; }, canGoBack:true, getRootFilter:function(){ if(selectedItem) { return { parentId: selectedItem.path } }else{ return { parentId: '' } } }, canSelect:function(item){ if(item.virtual===true &amp;&amp; item.isDir===false){ return true; } return false; } }, protocolMgr, wizard, true,null,[WizardPaneBase],null,{ getColumns:function(){ var _res = this.inherited(arguments); _res.push({ label: &quot;Value&quot;, field: &quot;value&quot;, sortable: false, _formatter: function (name, item) { if (!thiz.isGroup(item) &amp;&amp; item['user']) { var meta = item['user'].meta; var _in = meta ? utils.getCIInputValueByName(meta, types.PROTOCOL_PROPERTY.CF_PROTOCOL_TITLE) : null; if (meta) { return '&lt;span class=&quot;grid-icon ' + 'fa-exchange' + '&quot;&gt;&lt;/span&gt;' + _in; } else { return item.name; } return _in; } else { return item.name; } } }); return _res; } }). _on(types.EVENTS.ON_ITEM_SELECTED, function(evt){ selectedItems = selectItemsView.getSelection(); wizard.adjustWizardButton('done',selectedItems.length==0); }); setTimeout(function(){ if(selectItemsView.grid) { selectItemsView.grid.set('collection', store.filter(selectItemsView.getRootFilter())); selectItemsView.grid.refresh(); } },200); wizard.onNext = function(){ dialog.set('title','Select Commands &amp; Variables'); selectItemsView.grid.set('collection',store.filter(selectItemsView.getRootFilter())); selectItemsView.grid.refresh(); } }); }, createWizard: function () { return; try { var thiz = this; if (this._lastWizard) { this._lastWizard.dialog.hide().then(function () { thiz._lastWizard.dialog.destroy(); }); } } catch (e) { console.error(''); } /** * setup * * 1. create the dialog, * 2. create wizard * 3. add panes * * */ var wizardStruct = Wizards.createWizard('Select', false); this._lastWizard = wizardStruct; var wizard = wizardStruct.wizard; var dialog = wizardStruct.dialog; var CIS = [ utils.createCI('Title', 13, ''), utils.createCI('Scope', 3, 'system_drivers', { &quot;options&quot;: [ { label: 'System', value: 'system_drivers' }, { label: 'User', value: 'user_drivers' }, { label: 'App', value: 'app_drivers' } ] }) ]; var ciView = utils.addWidget(CIView, { viewStyle: 'padding:0px;', options: { groupOrder: { 'General': 0, 'Advanced': 1, 'Description': 2 } }, cis: CIS }, this, wizard, true, null, [WizardPaneBase]); ciView.initWithCIS(CIS); dialog.show(); }, createAceTerminal: function () { return; var where = this.ctx.mainView.bottomTabContainer; if (this.lastPane) { //utils.destroyWidget(this.lastPane); where.removeChild(this.lastPane); } var pane = factory.createPane('nada', 'nada', where); this.lastPane = pane; //console.log(term); /* var _k = ace.require(&quot;ace/lib/keys&quot;); console.log('_keys ',_k);*/ var _boot = require(['./ace/term'], function (term) { console.log('terminal', term); var aceterm; aceterm = term.createEditor(null, &quot;ace/theme/idle_fingers&quot;); aceterm.container.style.position = &quot;absolute&quot;; aceterm.container.style.left = &quot;0px&quot;; aceterm.container.style.right = &quot;0px&quot;; aceterm.container.style.top = &quot;0px&quot;; aceterm.container.style.bottom = &quot;0px&quot;; pane.containerNode.appendChild(aceterm.container); var session = aceterm.session; var terminal = new term.aceTerm(0, 0, function () { console.log('asdfasdf'); }); session.term = terminal; session.setValue('asdfasdf'); }); /* var aceTerm = ace.require(&quot;./ace/term&quot;); console.log('aceTerm',aceTerm); */ /* var require = ace.require; var dom = require(&quot;ace/lib/dom&quot;); var Range = require(&quot;ace/range&quot;).Range; var AceEditor = require(&quot;ace/editor&quot;).Editor; var EditSession = require(&quot;ace/edit_session&quot;).EditSession; var VirtualRenderer = require(&quot;ace/virtual_renderer&quot;).VirtualRenderer;*/ /* var Range = require(&quot;ace/range&quot;).Range; var AceEditor = require(&quot;ace/editor&quot;).Editor; var EditSession = require(&quot;ace/edit_session&quot;).EditSession; var VirtualRenderer = require(&quot;ace/virtual_renderer&quot;).VirtualRenderer; */ /* var parent = view.bottomTabContainer, view; try{ view=utils.addWidget(LogView,{ delegate:this, store:logManager.store, title:'Log', closable:false, style:'padding:0px', className:'ui-widget-content logGridView', showSource:true, silent:true },this,parent,true); }catch(e){ console.error(e); } */ } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"driver_DriverBase.js.html":{"id":"driver_DriverBase.js.html","title":"Source: driver/DriverBase.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: driver/DriverBase.js /** @module xcf/driver/DriverBase **/ define([&quot;dcl/dcl&quot;], function (dcl) { var _debug = false; /** * Driver Base Class * * Please read {@link module:xide/types} * * Online docs: http://rawgit.com/mc007/xcfnode/tree/master/out * * @class module:xcf.driver.DriverBase */ return dcl(null, { declaredClass:'system_drivers/DriverBase', /** * The information about the device in this structure: * @example * { * driver:&quot;Marantz/MyMarantz.js&quot;, * host:&quot;102.123.23.23&quot; * port:23, * protocol:&quot;tcp&quot; * scope:&quot;system_drivers&quot; * } * * @type {object} */ options: null, /** * The information about the driver it self * @example * { * name:&quot;My Marantz&quot;, * path:&quot;Marantz/My Marantz.meta.json&quot; * } * * @private * @type {object} */ storeItem: null, /** * The xBlox scope object for this driver. It contains all commands, variables and settings. You can blocks * through here * @private * @access private */ blockScope: null, /** * Our delegate is in charge to send messages * @private * @access private */ delegate: null, /** * @type {string} * @default \\r */ lineBreak: '\\r', // (optional, but recommended) name your class: // constructor is a method named ... 'constructor' constructor: function (name) {}, /** * sendSettings contains the constants for receiving and sending data to a device * its being set at initialization time and has this structure: * @example { constants:{ end:'\\r', start:'', }, send:{ interval:500, mode:true|false, //true=onReply | false=Interval onReply:'\\n', timeout:500 } } * @type {object} */ sendSettings: null, /** * responseSettings contains the constants for receiving data from a device * its being set at initialization time and has this structure: * @example { start:false, startString:'' cTypeByte:false, //construction type 'Per Byte' cTypePacket:false, //construction type 'Per Packet' cTypeDelimiter:true, //construction type 'Per Delimiter' cTypeCount:false, //construction type 'Per Count' delimiter:'', //the delimiter count:10 //packet count } * @type {object} */ responseSettings: null, /** * currently outgoing message queue * @private * @type {message[]} */ outgoing: null, /** * currently incoming message queue * @private * @type {message[]} */ incoming: null, // reference to a Javascript timer object, used for sending outgoing messages. private! /** * @private */ queueTimer: null, /** * private!in case processOutgoing is busy * @private */ busy: false, /** * Method to add a logging message. * * @param level {string} This can be error, warning, info, trace or custom * @param type {string} An additional string, by default this is set to &quot;Device&quot; * @param message {string} The message it self * @param data {object} An optional object/data you want to include * * @example * // for instance you want to log any incoming message in a custom way, you need to overwrite 'sendMessage' in // your base class like this: onMessage: function (data) { this.log('info', 'my marantz', 'Marantz Driver Message: ' + data.message, { some: 'extra', message: data }); this.inherited(arguments); //important, call BaseDriver::onMessage! } * */ log: function (level, type, message, data) { return this.inherited(arguments); }, /** * Callback when we got changed by an external editor or the IDE. * @private */ onReloaded: function (evt) {}, /*** * Unescape string from line breaks * @param str * @returns {*} */ unescape: function (str) { try { if (str) { return JSON.parse('&quot;' + str + '&quot;'); } }catch(e){ } return str; }, /** * Surround command with 'start' and 'end' constant, specified in the command settings * of the driver. * @param msg * @returns {*|string|String} */ prepareMessage: function (msg) { // add 'start' if (this.sendSettings.constants.start) { msg = this.sendSettings.constants.start + msg; } // add 'end' if (this.sendSettings.constants.end) { var _t = this.sendSettings.constants.end.split('\\\\n').join('\\n'); if (_t) { _t = _t.split('\\\\r').join('\\r'); } msg += _t; } var _m = msg.split('\\\\n').join('\\n'); if (_m) { _m = _m.split('\\\\r').join('\\r'); } return _m; }, /*** * Process outgoing sends last message from this.outgoing * @param force */ processOutgoing: function (force) { if(force==true){ this.busy=false; } //locked? if (this.busy) { return; } this.busy = true; var thiz = this; if (!this.outgoing) { this.outgoing = []; } //send via interval if (!this.sendSettings.send.mode &amp;&amp; this.sendSettings.send.interval &gt; 0) { //prepare timer if not already this.queueTimer = this.queueTimer || setInterval(function () { thiz.busy = false;//reset lock thiz.processOutgoing(); }, this.sendSettings.send.interval); } var messageToSend = this.outgoing[0];//pick the first //now finally send it out if (messageToSend) { messageToSend.msg = this.prepareMessage(messageToSend.msg); //send via interval mode if(!this.sendSettings.send.mode){ try { if (thiz.delegate &amp;&amp; thiz.delegate.sendDeviceCommand) { thiz.delegate.sendDeviceCommand(thiz, messageToSend.msg,messageToSend.src,messageToSend.id); } else { console.error('have no delegate'); } } catch (e) { console.error('error sending message : '+ e.message); } //remove from out going thiz.outgoing.remove(messageToSend); }else{ //send via onReply mode //special case, first command &amp;&amp; nothing received yet: if(this.incoming==null || force==true){ try { if (thiz.delegate &amp;&amp; thiz.delegate.sendDeviceCommand) { thiz.delegate.sendDeviceCommand(thiz, messageToSend.msg,messageToSend.src,messageToSend.id); } else { console.error('have no delegate'); } } catch (e) { console.error('error sending message : ' + e.message); } //remove from out going thiz.outgoing.remove(messageToSend); thiz.busy = false;//reset lock } } } }, /** * Send message send a string to the device. Basing on the send settings this message will be queued or send * on reply. * @param msg {string} the string to send * @param now {string} force sending now! * @param src {string} the id of the source block * @param id {string} the id of the send job */ sendMessage: function (msg, now,src,id) { if (!this.sendSettings) { console.error('have no send settings'); return; } //check we have a queue array if (!this.outgoing) { this.outgoing = []; } /** * if this.sendSettings.send.mode == false, its sending via 'interval', if true its on 'reply' */ if (now !== false) { var _interval = parseInt(this.sendSettings.send.interval) || 0; //we send per interval if (!this.sendSettings.send.mode &amp;&amp; _interval &gt; 0) { //add it to the queue this.outgoing.push({ msg: msg, src:src, id:id }); //trigger outgoing this.processOutgoing(); }else if (!_interval) {//we se if (this.delegate &amp;&amp; this.delegate.sendDeviceCommand) { return this.delegate.sendDeviceCommand(this, msg,src,id); } else { console.error('have no delegate'); } } //we send on reply else if (this.sendSettings.send.mode) { //add it to the queue this.outgoing.push({ msg: msg, src:src, id:id }); //trigger outgoing this.processOutgoing(); return; } return; } //we send directly if (this.delegate &amp;&amp; this.delegate.sendDeviceCommand) { return this.delegate.sendDeviceCommand(this, msg,src,id); } else { console.error('have no delegate'); } return false; }, /** * Deal with Javascript special characters, indexOf(&quot;\\n&quot;) fails otherwise * @returns {string} */ getLineBreakSend: function () { if (!this.sendSettings) { return ''; } var lineBreak = '' + this.sendSettings.constants.end; var lb = JSON.parse('&quot;' + lineBreak + '&quot;'); return lb || '\\r'; }, /** * Deal with Javascript special characters, indexOf(&quot;\\n&quot;) fails otherwise * @returns {string} */ getLineBreak: function () { if (!this.responseSettings || !this.responseSettings.cTypeDelimiter) { return ''; } var lineBreak = '' + this.responseSettings.delimiter; var lb = JSON.parse('&quot;' + lineBreak + '&quot;'); return lb || '\\r'; }, /** * Splits a message string from the device server into an array of messages. Its using 'responseSettings' * @param str * @returns {string[]} */ split: function (str) { if (!this.responseSettings || !this.getLineBreak()) { return [str]; } if (this.responseSettings.cTypeDelimiter) { var lineBreak = this.getLineBreak(); var has = str.indexOf(lineBreak); if (has != -1) { var _split = str.split(lineBreak); return _split; } return [str]; } return [str]; }, ///////////////////////////////////////////////////////////////////////////////////// // // Utils // ///////////////////////////////////////////////////////////////////////////////////// /** * Return true if we have message * @private * @returns {boolean} */ hasMessages: function () { return this.outgoing &amp;&amp; this.outgoing.length &gt; 0; }, /** * Standard callback when we have a message from the device we're bound to (specified in profile). * 1. put the message in the incoming queue, tag it as 'unread' * 2. in case we have messages to send and we are in 'onReply' mode, trigger outgoing queue * * @param data {Object} : Message Struct build by the device manager * @param data.device {Object} : Device info * @param data.device.host {String} : The host * @param data.device.port {String} : The host's port * @param data.device.protocol {String} : The host's protocol * @param data.message {String} : RAW message, untreated * * @example // for instance you might update the &quot;Volume&quot; Variable within onMessage: onMessage:function(data){ var value = data.message; var volume = 0; if (value.indexOf('MV') != -1 &amp;&amp; value.indexOf('MVMAX') == -1) { var _volume = value.substring(2, value.length); _volume = parseInt(_volume.substring(0, 2)); if (!isNaN(_volume)) { this.setVariable('Volume', _volume); volume = _volume; } } // do something else with volume: this.log('info',null,'Did update volume to ' + volume); //important, call BaseDriver::onMessage! this.inherited(arguments); } */ onMessage: function (data) { //track message this.incoming = data; //we're in 'onReply' mode if (this.sendSettings &amp;&amp; this.sendSettings.send.mode) { var _onReplyString = '' + this.unescape(this.sendSettings.send.onReply); var _messageString = '' + this.unescape(data.message); if (!this.sendSettings.send.onReply || _onReplyString ===_messageString) { this.processOutgoing(true); } } }, /*** * Standard callback when we have a feedback message from any device. The message data contains * all needed info like which device, the response, etc... * @param msg */ onBroadcastMessage: function (msg) {}, /** * Main entry when this instance is started * @returns {boolean} */ start: function () { this.outgoing = []; return true; }, /** * Set a variable's value * @param title {string} the name of the variable * @param value {string} the new value */ setVariable:function(title,value){}, /** * Return a variable's value * @param title {string} the name of the variable * @returns {string} the value of the variable */ getVariable:function(title){ return &quot;&quot;; } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DeviceManager_DeviceServer.js.html":{"id":"manager_DeviceManager_DeviceServer.js.html","title":"Source: manager/DeviceManager_DeviceServer.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DeviceManager_DeviceServer.js /** @module xcf/manager/DeviceManager_DeviceServer */ define([ 'dcl/dcl', &quot;xdojo/declare&quot;, &quot;dojo/_base/lang&quot;, 'xide/encoding/MD5', 'xide/types', 'xide/utils', 'xide/factory', 'xdojo/has', 'dojo/Deferred', 'xdojo/has!host-node?nxapp/utils/_console' ], function (dcl,declare, lang, MD5, types, utils, factory, has, Deferred,_console) { var isServer = has('host-node'); var console = typeof window !== 'undefined' ? window.console : console; if(_console &amp;&amp; _console.error &amp;&amp; _console.warn){ console = _console; } //debug mqtt activity var _debugMQTT = false; //debug device - server messages var debug = false; // debug device server connectivity var debugDevice = false; var debugStrangers = false; /*** * * 1. startDevice * -&gt;createDriverInstance * -&gt; sendManagerCommand(MANAGER_START_DRIVER, cInfo); * -&gt;onDeviceConnected * serverVariables? -&gt; * getDeviceServerVariables -&gt;onSetDeviceServerVariables * * */ /** * * @class module:xcf.manager.DeviceManager_DeviceServer * @augments module:xcf/manager/DeviceManager * @augments module:xide/mixins/EventedMixin */ return dcl(null,{ declaredClass:&quot;xcf.manager.DeviceManager_Server&quot;, /** * Callback when server returns the variables of a device * * @param data */ onSetDeviceServerVariables:function(data){ debugDevice &amp;&amp; console.error('did set device server variables',data); var instance = this.getDriverInstance(data.device, true); var device = this.getDeviceStoreItem(data.device); if(!device){ debugDevice &amp;&amp; console.log('did set device server variables failed, have no device',data); return; } if(instance){ var variables = data.variables, scope = instance.blockScope; device.serverVariables = data.variables; _.each(variables,function(variable){ var _var = scope.getVariable(variable.name); if(_var){ _var.value = variable.value; } }); } this.onDeviceConnected(data); device.setState(types.DEVICE_STATE.READY); device._startDfd &amp;&amp; device._startDfd.resolve(device.driverInstance); delete device._startDfd; device._startDfd = null; }, onDeviceDisconnected: function (data) { if (data &amp;&amp; data.device) { var error = data.error; var code = error &amp;&amp; error.code ? error.code : error || ''; var deviceStoreItem = this.getDeviceStoreItem(data.device); if(!deviceStoreItem){ debugDevice &amp;&amp; console.error('deviceStoreItem is null'); return; } this.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:'Device has been disconnected ' +'&lt;span class=&quot;text-warning&quot;&gt;'+ data.device.host+':'+data.device.port + '&lt;/span&gt;' + ' : ' + '&lt;span class=&quot;text-danger&quot;&gt;' + code + '&lt;/span&gt;', type:'info' }); var info = this.toDeviceControlInfo(deviceStoreItem); if(info &amp;&amp; isServer &amp;&amp; !info.serverSide){ return; } //kill old instance var instance = this.getDriverInstance(data.device, true); if (instance) { this.removeDriverInstance(data.device); }else{ console.error('cant find instance'); } deviceStoreItem.reset(); if (deviceStoreItem.state === types.DEVICE_STATE.DISABLED) { deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED); return; } deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED); function shouldRecconect(item){ if(item._userStopped || item.state === types.DEVICE_STATE.DISABLED){ return false; } enabled = thiz.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_ENABLED); if(!enabled){ return false; } return true; } if (deviceStoreItem) { var thiz = this; if(deviceStoreItem.reconnect){ return; } deviceStoreItem.reconnect = setTimeout(function(){ deviceStoreItem.reconnect=null; if(deviceStoreItem.shouldReconnect()) { deviceStoreItem.setState(types.DEVICE_STATE.CONNECTING); console.info('trying to reconnect to '+info.toString()); //thiz.connectDevice(deviceStoreItem); thiz.startDevice(deviceStoreItem); } },thiz.reconnectDevice); } } }, getDeviceServerVariables:function(device,driverInstance){ //debugDevice &amp;&amp; console.error('requesting device variables'); var scope = driverInstance.blockScope; if(!scope){ console.error(' have no block scope'); return; } var basicVariables = scope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES }); var out = []; for (var i = 0; i &lt; basicVariables.length; i++) { out.push({ name:basicVariables[i].name, value:basicVariables[i].value, initial:basicVariables[i].value }) } device.setState(types.DEVICE_STATE.SYNCHRONIZING); this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.GET_DEVICE_VARIABLES, { device:this.toDeviceControlInfo(device), variables:out }); }, onDeviceConnected:function(data){ debugDevice &amp;&amp; console.log('on device connected!',data); var deviceStoreItem = this.getDeviceStoreItem(data.device); var instance = this.getDriverInstance(data.device, true); if(!instance){ debugStrangers &amp;&amp; console.error('--cant find device instance',this.deviceInstances); deviceStoreItem &amp;&amp; deviceStoreItem.setState(types.DEVICE_STATE.DISCONNECTED); return; } if(!deviceStoreItem){ debugDevice &amp;&amp; console.error('onDeviceConnected:: deviceStoreItem is null'); return; } var cInfo = this.toDeviceControlInfo(deviceStoreItem); if(!cInfo){ debugDevice &amp;&amp; console.error('onDeviceConnected:: device info is null'); return; } if(isServer &amp;&amp; !cInfo.serverSide){ debugDevice &amp;&amp; console.error('onDeviceConnected:: device info is not server side, abort'); } if(instance &amp;&amp; deviceStoreItem.serverVariables==null){ this.getDeviceServerVariables(deviceStoreItem,instance); return; }else{ //debugDevice &amp;&amp; console.error('device has already device variables',deviceStoreItem.serverVariables); } deviceStoreItem.setState(types.DEVICE_STATE.CONNECTED); cInfo['clientSide'] = true; if (!cInfo) { console.error('couldnt start device, invalid control info'); return; } var hash = MD5(JSON.stringify(cInfo), 1); if (this.deviceInstances[hash]) { if(!instance.__didStartBlocks){ this.onDeviceStarted(instance,deviceStoreItem,instance.driver); }else{ console.error('instance.__didStartBlocks bad ' +hash,instance.__didStartBlocks); } deviceStoreItem.setState(types.DEVICE_STATE.READY); this.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:'Device is Ready &lt;span class=&quot;text-success&quot;&gt;'+ cInfo.host+':'+cInfo.port + '&lt;/span&gt;', type:'success' }); return this.deviceInstances[hash]; } var thiz = this; var baseDriverPrefix = this.driverScopes['system_drivers']; var baseDriverRequire = baseDriverPrefix + 'DriverBase'; debugDevice &amp;&amp; console.log('device conntected, load base driver with prefix : ' +baseDriverPrefix + ' and final require ' + baseDriverRequire); try { require([baseDriverRequire], function (baseDriver) { baseDriver.prototype.declaredClass = baseDriverRequire; thiz.createDriverInstance(cInfo, baseDriver, deviceStoreItem); }); }catch(e){ console.error('requiring base driver at ' + baseDriverRequire + ' failed',e); } }, /** * Starts a device with a device store item * @param item */ startDevice: function (item,force) { //console.error('-start device'); this.checkDeviceServerConnection(); item.check(); var dfd = new Deferred(); if(item._startDfd &amp;&amp; !item._startDfd.isResolved()){ debugDevice &amp;&amp; console.error('already starting ' + item.toString()); return item._startDfd; }else{ !item.driverInstance &amp;&amp; item.reset();//fresh } force==true &amp;&amp; item.setMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED,true,false); var enabled = item.getMetaValue(types.DEVICE_PROPERTY.CF_DEVICE_ENABLED); if(!enabled &amp;&amp; force!==true){ debugDevice &amp;&amp; console.error('---abort start device : device is not enabled!' + item.toString()); this.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:'Can`t start device because its not enabled! ' + item.toString(), type:'error' }); setTimeout(function(){ dfd.reject(); },10); return dfd; } var cInfo = this.toDeviceControlInfo(item); cInfo['clientSide'] = true; if (!cInfo) { console.error('couldnt start device, invalid control info '+ item.toString()); dfd.reject(); return dfd; } var hash = MD5(JSON.stringify(cInfo), 1); if (this.deviceInstances[hash]) { debugDevice &amp;&amp; console.error('device already started' + item.toString()); dfd.resolve(this.deviceInstances[hash]); return dfd; } item.setState(types.DEVICE_STATE.CONNECTING); item.info = cInfo; item._userStopped=null; item._startDfd = dfd; var thiz = this, baseDriverPrefix = this.driverScopes['system_drivers'], baseDriverRequire = baseDriverPrefix + 'DriverBase'; function buildMQTTParams(cInfo,driverInstance,deviceItem,driverItem){ return { driverScopeId:driverInstance.blockScope.id, driverId:driverInstance.driver.id, deviceId:item.path }; } try { require([baseDriverRequire], function (baseDriver) { baseDriver.prototype.declaredClass = baseDriverRequire; thiz.createDriverInstance(cInfo, baseDriver, item).then(function (driverInstance) { var _str = item.toString(); debugDevice &amp;&amp; console.info('created driver instance for '+ item.toString(),item.toString()); cInfo.mqtt = buildMQTTParams(cInfo, driverInstance, item); //debugDevice &amp;&amp; console.error(' start driver on server',cInfo); thiz.publish(types.EVENTS.ON_STATUS_MESSAGE, { text: 'Trying to connect to ' + cInfo.toString(), type: 'info' }); thiz.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo); delete cInfo.mqtt; }); }); }catch(e){ logError(e,'DeviceManager::startDevice: requiring base driver at ' + baseDriverRequire + ' failed! Base Driver - Prefix : ' + baseDriverPrefix); } return dfd; }, onCommandFinish:function(deviceData,message){ var driverInstance = this.getDriverInstance(deviceData, true); if (!driverInstance) { return; } var deviceInfo = deviceData; var device = this.getDeviceStoreItem(deviceInfo); if(message.src &amp;&amp; message.id){ var scope = driverInstance.blockScope; var block = scope.getBlockById(message.src); if(block &amp;&amp; block.onCommandFinish){ block.onCommandFinish(message); } } }, onCommandError:function(deviceData,message){ var driverInstance = this.getDriverInstance(deviceData, true); if (!driverInstance) { return; } var deviceInfo = deviceData, device = this.getDeviceStoreItem(deviceInfo); if(message.src &amp;&amp; message.id){ var scope = driverInstance.blockScope; var block = scope.getBlockById(message.src); if(block &amp;&amp; block.onCommandError){ block.onCommandError(message); } } }, /** * * Primary callback when the device server has received a message from a device. * * @param evt */ onDeviceServerMessage: function (evt) { var dataIn = evt['data']; var deviceMessageData = null; if (lang.isString(dataIn) &amp;&amp; dataIn.indexOf('{') !=-1){ try { /*if (! /^[\\[|\\{](\\s|.*|\\w)*[\\]|\\}]$/.test(dataIn)) {*/ deviceMessageData = dojo.fromJson(dataIn); /*}else{*/ //console.warn('received non json data...'+dataIn); /*}*/ } catch (e) { console.error('error parsing device message', evt); return; } } if (!deviceMessageData || !deviceMessageData.data || !deviceMessageData.data.device) { debug &amp;&amp; console.error('bad device message : ' + deviceMessageData); return; } var deviceInfo = deviceMessageData.data.device; if(!deviceInfo){ debug &amp;&amp; console.error('onDeviceServerMessage: cant get device info'); return; } if(isServer &amp;&amp; !deviceInfo.serverSide){ //console.error('onDeviceMessage : not a message for us'); return; } //pick driver instance var driverInstance = this.getDriverInstance(deviceMessageData.data.device, true); if (!driverInstance) { debugDevice &amp;&amp; console.error(' onDeviceMessage : failed! Have no device instance for ' + deviceMessageData.data.device.host, deviceMessageData); return; } var device = this.getDeviceStoreItem(deviceInfo), state = device.get('state'); //driver replay as broadcast message driverInstance.onBroadcastMessage({ device: deviceMessageData.data.device, message: deviceMessageData.data.deviceMessage }); //driver replay as individual message driverInstance.onMessage({ device: deviceMessageData.data.device, message: deviceMessageData.data.deviceMessage }); if(state !==types.DEVICE_STATE.READY){ device.set('state',types.DEVICE_STATE.READY); } var debugDevice = device.isDebug(); //system replay: if (deviceMessageData.event) { //before publishing on the public system bus, we do bundle the driver instance //together with the origin event from the device server: deviceMessageData.data['driverInstance'] = driverInstance; //now tell everybody! // // 'deviceMessageData.event' is a system event and defined in xcf.types.EVENTS.ON_DEVICE_MESSAGE // // 'deviceMessageData.data' is the actual payload, build by the device server. it comes with this structure : // // { // device:{ // host:'192.168.1.20', // port:'23', // protocol:'tcp' // }, // deviceMessage:'MV58\\r@VOL:-220\\r', // // } // // Current Subscribers : DriverManager &amp; this // this.publish(deviceMessageData.event, deviceMessageData.data); } if(has('xcf-ui')) { //console replay var hash = MD5(JSON.stringify(driverInstance.options), 1), viewId = hash + '-Console', messages = [], consoleViews = this.consoles[viewId]; debug &amp;&amp; console.log('on_device message '+hash,driverInstance.options); device.setState(types.DEVICE_STATE.READY); function clear(message){ delete message['resposeSettings']; delete message['driver']; delete message['lastResponse']; delete message['scope']; delete message['driverId']; delete message['device']; delete message['src']; delete message['id']; delete message['sourceHost']; delete message['sourcePort']; } if(debugDevice) { var text = deviceMessageData.data.deviceMessage; if (_.isObject(text)) { clear(text) try { text = JSON.stringify(text); } catch (e) { logError(e, 'error serialize message'); } } this.publish(types.EVENTS.ON_STATUS_MESSAGE, { text: &quot;Device Message from &quot; + driverInstance.options.host + &quot; : &quot; + '&lt;span class=&quot;text-info&quot;&gt;' + text + '&lt;/span&gt;' }) } consoleViews &amp;&amp; _.each(consoleViews,function(consoleView){ if (consoleView) { var message = deviceMessageData.data.deviceMessage; messages = []; if (_.isString(message)) { messages = driverInstance.split(message); }else if(_.isObject(message)){ clear(message); messages = [message]; } for (var i = 0; i &lt; messages.length; i++) { var _message = messages[i]; if (_.isString(_message) &amp;&amp; _message.length==0) { continue; } consoleView.log(_message); } } }); } }, /** * Device Server managment interface * @param cmd * @param data */ sendManagerCommand: function (cmd, data) { this.checkDeviceServerConnection(); var dataOut = { manager_command: cmd }; lang.mixin(dataOut, data); if(this.deviceServerClient) { var res = this.deviceServerClient.emit(null, dataOut, cmd); debug &amp;&amp; console.log('send manager command ' + cmd,[dataOut,res]); return res; }else{ console.error('Send Manager Command ' + cmd +' failed, have no device Server client'); this.onHaveNoDeviceServer(); } }, /*** * * @param driverInstance * @param data */ sendDeviceCommand: function (driverInstance, data,src,id) { this.checkDeviceServerConnection(); var options = driverInstance.options, sendOptions = { id:id, src:src }, dataOut = { command: data, device_command: 'Device_Send', host: options.host, port: options.port, protocol: options.protocol, options:sendOptions }; debug &amp;&amp; console.log(&quot;Device.Manager.Send.Message : &quot; + dataOut.command.substr(0,30), dataOut);//sending device message var device = this.getDevice(options.id); if(device.isDebug()) { this.publish(types.EVENTS.ON_STATUS_MESSAGE, { text: &quot;Did send message : &quot; + '&lt;span class=&quot;text-warnin&quot;&gt;' + dataOut.command.substr(0, 30) + '&lt;/span&gt;' + &quot; to &quot; + '&lt;span class=&quot;text-info&quot;&gt;' + dataOut.host + &quot;:&quot; + dataOut.port + &quot;@&quot; + dataOut.protocol + '&lt;/span&gt;' }) } //console replay var hash = MD5(JSON.stringify(driverInstance.options), 1); var viewId = hash + '-Console'; if(this.deviceServerClient) { this.deviceServerClient.emit(null, dataOut, 'Device_Send'); }else{ this.onHaveNoDeviceServer(); console.error('this.deviceServerClient is null'); console.error('Send Device Command ' + data +'failed, have no device Server client'); } }, /*** * * @param driverInstance * @param data */ callMethod: function (driverInstance,method,args,src,id) { this.checkDeviceServerConnection(); var options = driverInstance.options, sendOptions = { id:id, src:src }, dataOut = { method:method, args: args, device_command: 'Call_Method', host: options.host, port: options.port, protocol: options.protocol, options:sendOptions }; if(this.deviceServerClient) { this.deviceServerClient.emit(null, dataOut, 'Call_Method'); }else{ this.onHaveNoDeviceServer(); } }, createDeviceServerClient:function(store){ var thiz = this; var dfd = new Deferred(); this.deviceServerClient = null; this.deviceServerClient = factory.createClientWithStore(store, 'Device Control Server', { delegate: { onConnected:function(){ thiz.onDeviceServerConnected(); dfd.resolve(); }, onLostConnection: function(){ thiz.onDeviceServerConnectionLost(); }, onServerResponse: function (data) { //if(!has('debug')){ //}; var dataIn = data['data']; var msg = null; if (_.isString(dataIn)) { try { msg = dojo.fromJson(dataIn,false); } catch (e) { msg = dataIn; } debug &amp;&amp; !msg &amp;&amp; console.error('invalid incoming message',data); msg = msg || {}; debug &amp;&amp; console.log('server :'+msg.event); if (msg &amp;&amp; msg.data &amp;&amp; msg.data.deviceMessage &amp;&amp; msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_FINISH) { thiz.onCommandFinish(msg.data.device,msg.data.deviceMessage); return; } if (msg.data &amp;&amp; msg.data.deviceMessage &amp;&amp; msg.data.deviceMessage.event === types.EVENTS.ON_COMMAND_ERROR) { thiz.onCommandError(msg.data.device,msg.data.deviceMessage); return; } if (msg.event === types.EVENTS.ON_DEVICE_DISCONNECTED) { thiz.publish(types.EVENTS.ON_DEVICE_DISCONNECTED, msg.data); return; } if (msg.event === types.EVENTS.SET_DEVICE_VARIABLES) { return thiz.onSetDeviceServerVariables(msg.data); } if (msg.event === types.EVENTS.ON_DEVICE_CONNECTED) { thiz.publish(types.EVENTS.ON_DEVICE_CONNECTED, msg.data); return; } if (msg.event === types.EVENTS.ON_SERVER_LOG_MESSAGE) { thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, msg.data); return; } if (msg.event === types.EVENTS.ON_MQTT_MESSAGE) { thiz.publish(types.EVENTS.ON_MQTT_MESSAGE, msg.data); thiz.onMQTTMessage(msg.data); return; } if (msg.event === types.EVENTS.ON_FILE_CHANGED) { return thiz.ctx.onXIDEMessage(dojo.fromJson(data.data)); } } thiz.onDeviceServerMessage(data); if(data &amp;&amp; data.data){ //thiz.ctx.onXIDEMessage(dojo.fromJson(data.data)); } } } }); if (!this.deviceServerClient) { debug &amp;&amp; console.log('couldnt connect to device server'); return; } else { debug &amp;&amp; console.log('did connect to device server'); } this.deviceServerClient.dfd = dfd; return this.deviceServerClient; } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_BeanManager.js.html":{"id":"manager_BeanManager.js.html","title":"Source: manager/BeanManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/BeanManager.js /** @module xcf/manager/BeanManager **/ define([ 'dcl/dcl', &quot;xdojo/declare&quot;, &quot;dojo/_base/lang&quot;, 'xide/types', 'xide/utils', 'xide/manager/BeanManager', 'xdojo/has!xcf-ui?xide/views/ActionDialog', 'xdojo/has!xcf-ui?xide/views/CIActionDialog', 'xdojo/has!xcf-ui?xide/views/CIGroupedSettingsView' ], function (dcl,declare,lang,types, utils, BeanManager,registry,ActionDialog, CIActionDialog, CIGroupedSettingsView){ /** * @class module:xcf/manager/BeanManager * @extends module:xide/manager/BeanManager */ return dcl(BeanManager, { declaredClass:&quot;xcf.manager.BeanManager&quot;, /** * Url generator for device/driver/[command|block|variable] * * @param device * @param driver * @param block * @param prefix * @returns {*} */ toUrl:function(device, driver, block, prefix) { prefix = prefix || ''; var pattern = prefix + &quot;deviceScope={deviceScope}&amp;device={deviceId}&amp;driver={driverId}&amp;driverScope={driverScope}&amp;block={block}&quot;; var url = lang.replace( pattern, { deviceId: device.id, deviceScope: device.scope, driverId: driver.id, driverScope: driver.scope, block: block.id }); return url; }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean Editing // ///////////////////////////////////////////////////////////////////////////////////// /*** * openItemSettings creates a new settings view for a protocol * @param item * @returns {xide.views.CIGroupedSettingsView|null} */ openItemSettings: function (item,device) { //1. sanity check var userData = item.user; if (!userData || !userData.inputs) { return null; } //2. check its not open already var viewId = this.getViewId(item); var view = registry.byId(viewId); try { if (view) { if (view.parentContainer) { view.parentContainer.selectChild(view); } return null; } } catch (e) { utils.destroy(view); } var docker = this.ctx.mainView.getDocker(), title = this.getMetaValue(item, this.itemMetaTitleField), devinfo = device ? this.ctx.getDeviceManager().toDeviceControlInfo(device) : null; var parent = docker.addTab(null, { title: (title || item.name) + '' + (device ? ':' + device.name + ':' + devinfo.host + ':' : ''), icon: this.beanIconClass }); //@Todo:driver, store device temporarly in Commands CI var commandsCI = utils.getCIByChainAndName(userData, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS); if(commandsCI){ commandsCI.device = device; } if(item.blockScope &amp;&amp; !item.blockScope.serviceObject){ item.blockScope.serviceObject = this.serviceObject; } return utils.addWidget(CIGroupedSettingsView,{ cis: userData.inputs, storeItem: item, iconClass: this.beanIconClass, id: viewId, delegate: this, storeDelegate: this, blockManager: this.ctx.getBlockManager(), options:{ groupOrder: { 'General': 1, 'Settings': 2, 'Visual':3 } } }, this, parent, true); }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean Management // ///////////////////////////////////////////////////////////////////////////////////// /** * Creates new group item dialog */ newGroup: function () { var thiz = this, currentItem = this.getItem(), parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; var actionDialog = new CIActionDialog({ title: 'New ' + this.groupType, delegate: { onOk: function (dlg, data) { var title = utils.getCIInputValueByName(data, 'Title'); var scope = utils.getCIInputValueByName(data, 'Scope'); var _final = parent + '/' + title; thiz.createGroup(scope, _final, function (response) { var newItem = thiz.createNewGroupItem(title, scope, parent); thiz.store.putSync(newItem); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: thiz.store, action: types.NEW_DIRECTORY, item: newItem }); }); } }, cis: [ utils.createCI('Title', 13, ''), utils.createCI('Scope', 3, this.defaultScope, { &quot;options&quot;: [ { label: 'System', value: this.defaultScope }, { label: 'User', value: this.userScope }, { label: 'App', value: this.appScope } ] }) ] }); actionDialog.startup(); actionDialog.show(); }, onDeleteItem: function (item) { var isDir = utils.toBoolean(item.isDir) === true; //pick the right service function var removeFn = isDir ? 'removeGroup' : 'removeItem'; var thiz = this; var actionDialog = new ActionDialog({ title: 'Remove ' + this.beanName + (isDir ? ' Group' : '') + ' ' + &quot;\\&quot;&quot; + item.name + &quot;\\&quot; &quot;, style: 'max-width:400px', titleBarClass: 'text-danger', delegate: { isRemoving: false, onOk: function (dlg) { thiz[removeFn]( utils.toString(item.scope), utils.toString(item.path), utils.toString(item.name), function () { thiz.onItemDeleted(item); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: thiz.store, action: types.DELETE, item: item }); }); } } }); actionDialog.show(); }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean protocol // ///////////////////////////////////////////////////////////////////////////////////// hasItemActions: function () { return true; }, onItemDeleted: function (item) { //delete subs this.store.removeSync(item.path); if(item == this.currentItem) { this.currentItem = null; } if (item) { var view = this.getView(item); if (view) { utils.destroyWidget(view); } } }, onItemSelected: function (item) { this.currentItem = item; }, ///////////////////////////////////////////////////////////////////////////////////// // // UI-Callbacks // ///////////////////////////////////////////////////////////////////////////////////// onCIUpdate: function (evt) { if (evt['owner'] === this) { this.updateCI(evt.ci, evt.newValue, evt.oldValue, evt.storeItem); } }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean utils // ///////////////////////////////////////////////////////////////////////////////////// createNewGroupItem: function (title, scope, parent) { return this.createItemStruct(title, scope, parent, title, true, this.groupType); }, createNewItem: function (title, scope, parent) { return this.createItemStruct(title, scope, parent, parent + &quot;/&quot; + title, false, this.itemType); }, ///////////////////////////////////////////////////////////////////////////////////// // // main // ///////////////////////////////////////////////////////////////////////////////////// init: function () { this.subscribe(types.EVENTS.ON_CI_UPDATE); }, ///////////////////////////////////////////////////////////////////////////////////// // // Server methods (PHP) // ///////////////////////////////////////////////////////////////////////////////////// createItem: function (scope, path, title, meta,code) { return this.runDeferred(null, 'createItem', [scope, path, title, meta, code]); }, /*** * ls is enumerating all drivers in a given scope * @param scope{string} * @returns {Deferred} */ ls: function (scope) { return this.runDeferred(null, 'ls', [scope]).then(function (data) { try { this.rawData = data; this.initStore(data); this.publish(types.EVENTS.ON_STORE_CREATED, { data: data, owner: this, store: this.store, type: this.itemType }); }catch(e){ logError(e,'error ls'); } }.bind(this)); }, /** * * @param title * @param scope * @param parent * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}} */ _getText: function (url) { var result; var def = dojo.xhrGet({ url: url, sync: true, handleAs: 'text', load: function (text) { result = text; } }); return '' + result + ''; } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_Context.js.html":{"id":"manager_Context.js.html","title":"Source: manager/Context.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/Context.js /** module:xcf/manager/Context **/ define([ 'dcl/dcl', 'dojo/_base/declare', 'dojo/_base/array', 'dojo/_base/lang', 'xide/manager/Context', 'xide/factory', 'xide/types', 'xcf/manager/DriverManager', 'xcf/manager/DeviceManager', 'xcf/manager/ProtocolManager', 'xcf/manager/Application', 'xcf/manager/LogManager', 'xide/manager/ResourceManager', 'xide/manager/PluginManager', 'xdojo/has', 'xdojo/has!xideve?xcf/manager/WidgetManager' ],function(dcl,declare,array,lang,Context,factory,types,DriverManager,DeviceManager,ProtocolManager,Application, LogManager,ResourceManager,PluginManager,has,WidgetManager){ /** * @class module:xcf/manager/Context * @extends module:xide/manager/Context */ return dcl([Context],{ declaredClass:&quot;xcf.manager.Context&quot;, /*** * Standard application context, creates &amp; holds all manager instances */ ///////////////////////////////////////////////////////////// // // Variables // ///////////////////////////////////////////////////////////// namespace:'xcf.manager.', driverManager:null, deviceManager:null, protocolManager:null, debugManager:null, nodeServiceManager:null, blockManager:null, ///////////////////////////////////////////////////////////// // // Getters for managers // ///////////////////////////////////////////////////////////// getBlockManager:function(){ return this.blockManager; }, getProtocolManager:function(){ return this.protocolManager; }, getDriverManager:function(){ return this.driverManager; }, getDeviceManager:function(){ return this.deviceManager; }, getNodeServiceManager:function(){ return this.nodeServiceManager; }, getDebugManager:function(){ return this.debugManager; }, constructManagers:function(appClass){ var isEditor = this.isEditor(), isBrowser = has('host-browser'); if(isBrowser) { if(!isEditor) { this.driverManager = this.createManager(DriverManager, null); this.deviceManager = this.createManager(DeviceManager, null); this.protocolManager = this.createManager(ProtocolManager, null); this.logManager = this.createManager(LogManager); } this.pluginManager = this.createManager(PluginManager); this.resourceManager = this.createManager(ResourceManager); this.application = this.createManager(appClass || Application); } }, initManagers:function() { var isEditor = this.isEditor(); if(!isEditor) { if (has('drivers')) { this.driverManager.init(); } if (has('devices')) { this.deviceManager.init(); } if (has('protocols')) { this.protocolManager.init(); } if (has('log')) { this.logManager.init(); } } this.resourceManager &amp;&amp; this.resourceManager.init(); } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DeviceManager.js.html":{"id":"manager_DeviceManager.js.html","title":"Source: manager/DeviceManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DeviceManager.js /** @module xcf/manager/DeviceManager */ define([ 'dcl/dcl', &quot;xdojo/declare&quot;, &quot;dojo/_base/lang&quot;, 'xide/encoding/MD5', 'xide/types', 'xide/utils', 'xide/factory', 'xcf/manager/BeanManager', 'xide/mixins/ReloadMixin', 'xide/mixins/EventedMixin', './DeviceManager_Server', './DeviceManager_DeviceServer', 'xide/data/TreeMemory', 'dojo/has', 'xide/data/ObservableStore', 'dstore/Trackable', 'xcf/model/Device', 'dojo/Deferred', &quot;xide/manager/ServerActionBase&quot;, &quot;xide/data/Reference&quot;, 'xide/utils/StringUtils', 'xdojo/has!xcf-ui?./DeviceManager_UI', 'xdojo/has!xexpression?xexpression/Expression', 'xdojo/has!host-node?nxapp/utils/_console', &quot;xdojo/has!host-node?nxapp/utils&quot; ], function (dcl,declare, lang, MD5, types, utils, factory, BeanManager, ReloadMixin, EventedMixin, DeviceManager_Server, DeviceManager_DeviceServer,TreeMemory,has, ObservableStore,Trackable,Device,Deferred,ServerActionBase,Reference,StringUtils, DeviceManager_UI,Expression,_console,xUtils) { var console = typeof window !== 'undefined' ? window.console : console; if(_console &amp;&amp; _console.error &amp;&amp; _console.warn){ console = _console; } var bases = [ ServerActionBase, BeanManager, DeviceManager_Server, DeviceManager_DeviceServer, ReloadMixin.dcl ], _debugMQTT = false, _debug = false, _debugConnect = true, isServer = !has('host-browser'), isIDE = has('xcf-ui'), DEVICE_PROPERTY = types.DEVICE_PROPERTY, EVENTS = types.EVENTS; has('xcf-ui') &amp;&amp; bases.push(DeviceManager_UI); /* console.error('has ide : ' + isIDE); console.error('is server : ' + isServer); console.error('has drivers : ' + has('drivers')); console.error('has devices : ' + has('devices')); */ /** * Common base class, for server and client. * @class module:xcf/manager/DeviceManager * @augments module:xide/mixins/EventedMixin * @extends module:xcf/manager/BeanManager */ return dcl(bases,{ declaredClass:&quot;xcf.manager.DeviceManager&quot;, /*** * The Bean-Manager needs a unique name of the bean: * @private */ beanNamespace: 'device', /*** * The Bean-Manager has some generic function like creating Dialogs for adding new items, please * provide a title for the interface. * @private */ beanName: 'Device', /** * the icon class for bean edit views * @private */ beanIconClass:'fa-sliders', /** * Bean group type * @private */ groupType:types.ITEM_TYPE.DEVICE_GROUP, /** * Bean item type * @private */ itemType:types.ITEM_TYPE.DEVICE, /** * The name of the CI in the meta database for the title or name. * @private */ itemMetaTitleField:DEVICE_PROPERTY.CF_DEVICE_TITLE, /** * Name of the system scope * @private */ systemScope:'system_devices', /** * Name of the user scope * @private */ userScope:'user_devices', /** * Name of the app scope * @private */ appScope:'app_devices', /** * Name of the default scope for new created items * @private */ defaultScope:'system_devices', /*** * The RPC server class: * @private */ serviceClass: 'XCF_Device_Service', /*** * A copy of all devices raw data from the server * @private */ rawData: null, /*** * @type {module:xcf/data/Store} * @private */ store: null, /*** * {xcf.views.DevicesTreeView} * @private */ treeView: null, /*** * {xide.client.WebSocket} */ deviceServerClient: null, /*** * An array of started device instances. * @private */ deviceInstances: null, /*** * A map of scope names for module hot reloading * @private */ driverScopes: null, /*** * autoConnectDevices does as it says, on app start, it connects to all known devices of the * project * @param autoConnectDevices * @private */ autoConnectDevices: true, /** * Consoles is an array of {xide.views.ConsoleViews}. There is one console per device possible * @private */ consoles: null, /** * lastUpTime is being used to recognize a computer suspend hibernate * @private */ lastUpTime: null, /** * @private */ reconnectDevice: 5000, /** * @private */ reconnectDeviceServer: 5000, ///////////////////////////////////////////////////////////////////////////////////// // // Device-Related // ///////////////////////////////////////////////////////////////////////////////////// /** * Make sure we've a connection to our device-server * @private */ checkDeviceServerConnection: function () { if (!this.deviceServerClient) { var store = this.ctx.getNodeServiceManager().getStore(); if (!store) { console.error('checkDeviceServerConnection : have no service store'); return false; } this.createDeviceServerClient(store); } return true; }, /** * * @param target * @param source * @private */ addDriverFunctions: function (target, source) { for (var i in source) { if (i === 'constructor' || i === 'inherited' || i == 'getInherited' || i == 'isInstanceOf' || i == '__inherited' || i == 'onModuleReloaded' || i == 'start' || i == 'publish' || i == 'subscribe' || i == 'getInherited' || i == 'getInherited' ) { continue; } if (_.isFunction(source[i]) &amp;&amp; !target[i]) { target[i] = source[i];//swap } } }, /** * * @param driver * @param instance * @private */ addLoggingFunctions: function (driver, instance) { var thiz = this; instance.log = function (level, type, message, data) { data = data || {}; var oriData = lang.clone(data); data.type = data.type || type || 'Driver'; if (instance.options) { data.device = instance.options; } thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, { data: data, level: level || 'info', message: message, details:oriData }); } }, /** * An instance of a driver class has been created. * We mixin new functions: callCommand, set/get-Variable, log * @param driver * @param instance * @param device * @private */ completeDriverInstance: function (driver, instance,device) { var thiz = this; _debug &amp;&amp; console.info('complete driver instance'); var scope = instance.blockScope, store = scope.blockStore, parentId = device.path; var commandsRoot = parentId + '_commands'; var variablesRoot = parentId + '_variables'; store.on('delete',function(evt){ var _isVariable = evt.target.declaredClass.indexOf('Variable') !==-1, _parent = _isVariable ? variablesRoot : commandsRoot, referenceParent = device._store.getSync(_parent); if(referenceParent){ referenceParent.refresh(); } var referenceId = _parent + '_reference_'+evt.target.id, reference = device._store.getSync(referenceId); if(reference){ reference.refresh(); } }); function createReference(block,driver,title,icon){ var _isVariable = block.declaredClass.indexOf('Variable') !==-1; var _parent = _isVariable ? variablesRoot : commandsRoot; if(block.declaredClass.indexOf( _isVariable? 'Variable' : 'Command')==-1){ return; } var reference = new Reference({ enabled:true, path: _parent + '_reference_'+block.id, name: title, id: block.id, parentId: _parent, _mayHaveChildren: false, virtual: true, tooltip: true, icon:icon, ref: { driver: driver, item: block, device:device }, type: types.ITEM_TYPE.BLOCK }); reference = device._store.putSync(reference); block.addReference(reference,{ properties: { &quot;name&quot;:true, &quot;enabled&quot;:true, &quot;value&quot;:true }, onDelete:true },true); reference.refresh(); } store.on('added',function(block){ createReference(block,driver,block.name,block.icon || 'fa-exclamation'); }); /** * Add 'callCommand' * @param title */ instance.callCommand = function (title) { var _block = this.blockScope.getBlockByName(title); if (_block) { _block.solve(this.blockScope); } }; /** * Add 'setVariable' * @param title * @param value */ instance.setVariable = function (title, value, save) { var _variable = this.blockScope.getVariable(title); if (_variable) { _variable.value = value; _variable.set('value',value); } else { _debug &amp;&amp; console.log('no such variable : ' + title); return; } thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, { item: _variable, scope: this.blockScope, driver: driver, owner: thiz, save: save === true }); }; /** * Add getVariable * @param title */ instance.getVariable = function (title) { var _variable = this.blockScope.getVariable(title); if (_variable) { return _variable.value; } return ''; }; instance.log = function (level, type, message, data) { data = data || {}; var oriData = lang.clone(data); data.type = data.type || type || 'Driver'; if (instance.options) { data.device = instance.options; } thiz.publish(types.EVENTS.ON_SERVER_LOG_MESSAGE, { data: data, level: level || 'info', message: message, details:oriData }); }; for (var i in driver) { if (i === 'constructor' || i === 'inherited' || i == 'getInherited' || i == 'isInstanceOf' || i == '__inherited' || i == 'onModuleReloaded' || i == 'start' || i == 'publish' || i == 'subscribe' || i == 'getInherited' || i == 'getInherited' ) { continue; } if (lang.isFunction(driver[i]) &amp;&amp; !instance[i] /*&amp;&amp; lang.isFunction(target[i])*/) { instance[i] = driver[i];//swap } } }, /** * Callback when we are connected to a device. * We use this to fire all looping blocks * @param driverInstance {module:xcf/driver/DriverBase} the instance of the driver * @param deviceStoreItem {module:xcf/model/Device} the device model item * @param driver {module:xcf/model/Driver} the driver model item */ onDeviceStarted: function (driverInstance, deviceStoreItem, driver) { _debug &amp;&amp; console.log('onDeviceStarted'); if (!driverInstance || !deviceStoreItem || !driver) { _debug &amp;&amp; console.log('onDeviceStarted failed, invalid params'); return; } var info = this.toDeviceControlInfo(deviceStoreItem), serverSide = info.serverSide; /** * Post work : * 1. Start all commands with the 'startup' flag! * 2. Todo : update last variables from Atomize server * 3. Establish long polling */ //1. fire startup blocks var blockScope = driverInstance.blockScope;// ctx.getBlockManager().getScope(driver.id); if( (isServer &amp;&amp; serverSide) || (!serverSide &amp;&amp; !isServer)) { var autoBlocks = []; var initBlocks = blockScope.getBlocks({ group: types.COMMAND_TYPES.INIT_COMMAND }); _.invoke(initBlocks,'solve',blockScope); autoBlocks = autoBlocks.concat(blockScope.getBlocks({ group: types.COMMAND_TYPES.BASIC_COMMAND, startup: true })); autoBlocks = autoBlocks.concat(blockScope.getBlocks({ group: types.COMMAND_TYPES.CONDITIONAL_COMMAND, startup: true })); for (var i = 0; i &lt; autoBlocks.length; i++) { _debug &amp;&amp; console.log('fire command ' + autoBlocks[i].name); autoBlocks[i].solve(blockScope); } //2. fire long polling commands var pollingBlocks = autoBlocks.concat(blockScope.getBlocks({ group: types.COMMAND_TYPES.BASIC_COMMAND, auto: /^[1-9][0-9]*$/ })); pollingBlocks = pollingBlocks.concat(blockScope.getBlocks({ group: types.COMMAND_TYPES.CONDITIONAL_COMMAND, auto: /^[1-9][0-9]*$/ })); for (var i = 0; i &lt; pollingBlocks.length; i++) { var _block = pollingBlocks[i]; if (_block.auto == true &amp;&amp; _block.interval &gt; 1) { blockScope.loopBlock(_block); } } this.publish(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, { device: deviceStoreItem, instance: driverInstance, driver: driver, blockScope: blockScope }); } driverInstance.__didStartBlocks = true; this.ctx.getDriverManager().addDeviceInstance(deviceStoreItem,driver); }, /** * Creates a driver instance per device * @param deviceInfo {module:xide/types~DeviceInfo} The device info * @param driverBase {module:xcf/driver/DriverBase} The driver base class * @param device {module:xcf/model/Device} The device model item */ createDriverInstance: function (deviceInfo, driverBase, device) { var hash = MD5(JSON.stringify(deviceInfo), 1), driverPrefix = this.driverScopes[deviceInfo.scope], requirePath = driverPrefix + deviceInfo.driver;//xcfnode/data/driver/system/Marantz/MyMarantz.js requirePath = requirePath.replace('.js', ''); var thiz = this, ctx = thiz.ctx, meta = device['user'], driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER), driverManager = ctx.getDriverManager(), driver = driverManager.getItemById(driverId), dfd = new Deferred(), enabled = device.getMetaValue(DEVICE_PROPERTY.CF_DEVICE_ENABLED), serverSide = deviceInfo.serverSide; if(device.isEnabled()===false){ _debug &amp;&amp; console.warn('device not enabled, abort ' + deviceInfo.toString()); setTimeout(function(){ dfd.reject(); }); return dfd; } if(isServer &amp;&amp; !device.isServerSide()){ dfd.reject(); return dfd; } _debugConnect &amp;&amp; console.info('------create driver instance with DriverBase at '+requirePath + ' with driver prefix : ' + driverPrefix,this.driverScopes); try { require([requirePath], function (driverProtoInstance) { var baseClass = driverBase, baseClasses = [baseClass], driverProto = declare([baseClass, EventedMixin, ReloadMixin], driverProtoInstance.prototype), driverInstance = new driverProto(); driverInstance.declaredClass = requirePath; driverInstance.options = deviceInfo; driverInstance.baseClass = baseClass.prototype.declaredClass; driverInstance.modulePath = utils.replaceAll('//', '/', requirePath); driverInstance.delegate = thiz; driverInstance.driver = driver; driverInstance.serverSide = deviceInfo.serverSide; try { driverInstance.start(); driverInstance.initReload(); } catch (e) { console.error('crash in driver instance startup! ' + device.toString()); } //console.log('add instances'); thiz.deviceInstances[hash] = driverInstance; // Build an id basing on : driver id + driver path // &quot;235eb680-cb87-11e3-9c1a-....ab5_Marantz/Marantz.20.meta.json&quot; var scopeId = driverId + '_' + hash + '_' + device.path; if (!driver.blox || !driver.blox.blocks) { _debugConnect &amp;&amp; console.error('Attention : INVALID driver', [device, driver]); driver.blox = { blocks: [] } } if (isServer &amp;&amp; driver.blockPath) { var newBlocks = StringUtils.getJson(xUtils.readFile(driver.blockPath)); newBlocks = driver.blox = StringUtils.getJson(xUtils.readFile(driver.blockPath)); } var scope = ctx.getBlockManager().createScope({ id: scopeId, device: device, driver: driver, instance: driverInstance, serviceObject: thiz.serviceObject, ctx: ctx, serverSide: serverSide, getContext: function () { return this.instance; } }, dojo.clone(driver.blox.blocks)); //important: driverInstance.blockScope = scope; device.blockScope = scope; device.driverInstance = driverInstance; thiz.getDriverInstance(deviceInfo, true);//triggers to resolve settings //add variable &amp;&amp; command functions: isIDE &amp;&amp; thiz.completeDriverInstance(driver, driverInstance, device); dfd.resolve(driverInstance); return driverInstance; }); }catch(e){ console.error('DeviceManager::createDriverInstance:: requiring base driver at ' + requirePath + ' failed',e); } return dfd; }, getDevice:function(mixed){ var result = mixed; if(_.isString(mixed)){ var byId = this.getItemById(mixed); if(byId){ result = byId; }else{ var byPath = this.store.getSync(mixed); if(byPath){ result = byPath; } } } return result; }, /** * Stops a device with a device model item * @param item {module:xcf/model/Device|string} */ stopDevice: function (item) { item = this.getDevice(item) || item; if(!item){ console.error('cant find device'); return; } this.checkDeviceServerConnection(); item._userStopped = true; var cInfo = this.toDeviceControlInfo(item); if(!cInfo){ console.error('cant find device::no device info',item.toString &amp;&amp; item.toString()); return; } if(isServer &amp;&amp; !cInfo.serverSide){ return; } cInfo['clientSide'] = true; var hash = MD5(JSON.stringify(cInfo), 1); if (this.deviceInstances[hash]) { this._removeInstance(this.deviceInstances[hash], hash,item); delete this.deviceInstances[hash]; _debugConnect &amp;&amp; console.log('-- stop device ' + hash,this.deviceInstances); }else{ _debugConnect &amp;&amp; console.log('cant find instance ' + hash); } !isServer &amp;&amp; this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_STOP_DRIVER, cInfo); }, /** * Get all enabled devices * @param enabledOnly * @param addDriver * @returns {module:xcf/model/Device[]} */ getDevices: function (enabledOnly,addDriver) { var store = this.getStore(); if(!store){ return []; } var items = utils.queryStore(store, { isDir: false }); if (items._S) { items = [items]; } var result = []; for (var i = 0; i &lt; items.length; i++) { var device = items[i], enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED); if ((enabledOnly === true &amp;&amp; enabled == true || enabled == null) || enabledOnly === false) { result.push(device); if(addDriver==true) { var driverId = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_DRIVER); if (!driverId) { console.error('device has no driver id!'); continue; } var driver = this.ctx.getDriverManager().getItemById(driverId); if (driver){ device['driver'] = driver; } } } } return result; }, /** * Connect to all known devices * @private */ connectToAllDevices: function () { var store = this.getStore(), thiz = this; if(!store){ console.error('have no device store'); return; } var items = utils.queryStore(store, { isDir: false }); if (items._S) { items = [items]; } var _start = function (device) { thiz.startDevice(device); }; for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var enabled = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ENABLED); if (enabled == true || enabled == null) { _start(device); } } }, /** * * @private */ _getLogText: function (str) { return moment().format(&quot;HH:mm:SSS&quot;) + ' :: ' + str + ''; }, _parse: function (scope, expression) { var str = '' + expression; if (str.indexOf('{{') &gt; 0 || str.indexOf('}}') &gt; 0) { console.time('parse expression'); var _parser = new Expression(); str = _parser.parse(types.EXPRESSION_PARSER.FILTREX, str, this, { variables: scope.getVariablesAsObject(), delimiters: { begin: '{{', end: '}}' } } ); console.timeEnd('parse expression'); }else{ var _text = scope.parseExpression(expression); if(_text){ str = _text; } } //var pattern = &quot;([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)&quot;; //pattern = &quot;(?[0-9])&quot;; //var out = str.match(new RegExp(/[d()+-*],&quot;g&quot;)); //var out = str.match(/[\\d\\(\\)\\+\\-\\*\\/\\.]+/g); //var numbers = str.match(/[0-9()+\\-*/.]/g).join(''); //console.log('out : ' + numbers ); /* var _text = scope.parseExpression(expression); if(_text){ str = _text; } */ return str; }, /** * * @param driver * @param device * @private */ runCommand: function (driver, device) {}, /** * @private */ _lastActions: null, ///////////////////////////////////////////////////////////////////////////////////// // // Data related // ///////////////////////////////////////////////////////////////////////////////////// /** * * @param rawData * @private */ onStoreReloaded: function (rawData) { this.completeDeviceStore(); }, getInstance:function(mixed){ var deviceInfo = mixed ? mixed._store ? this.toDeviceControlInfo(mixed) : mixed : null; if(!deviceInfo){ return; } return this.getDriverInstance(deviceInfo,false); }, /*** * returns driver instance! * @param deviceInfo {module:xide/types~DeviceInfo} * @param fillSettings will convert and put CI settings into the driver's instance (member variable) * @returns {module:xcf/driver/DriverBase} * @private */ getDriverInstance: function (deviceInfo, fillSettings) { if (!deviceInfo) { console.error('getDriverInstance::have no device info') return null; } for (var i in this.deviceInstances) { var instance = this.deviceInstances[i]; var instanceOptions = instance.options; if(!instanceOptions){ continue; } if (instanceOptions.port === deviceInfo.port &amp;&amp; instanceOptions.host === deviceInfo.host &amp;&amp; instanceOptions.protocol === deviceInfo.protocol) { if (fillSettings !== false) { //get settings, if not cached already if (instance &amp;&amp; !instance.sendSettings) { //pick driver var driver = this.ctx.getDriverManager().getItemById(deviceInfo.driverId);//driverStore item if (driver) { var meta = driver['user']; var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS); if (commandsCI &amp;&amp; commandsCI['params']) { instance.sendSettings = utils.getJson(commandsCI['params']); } var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES); if (responseCI &amp;&amp; responseCI['params']) { instance.responseSettings = utils.getJson(responseCI['params']); } }else{ _debug &amp;&amp; console.warn('getDriverInstance:: cant find driver'); } } } return instance; } } return null; }, _reconnectServerTimer:null, /** * @private */ onDeviceServerConnectionLost:function(){ if (this.deviceServerClient) { this.deviceServerClient.destroy(); this.deviceServerClient = null; } if(this._reconnectServerTimer){ return; } var thiz = this; if(isIDE) { thiz.ctx.getNotificationManager().postMessage({ message: 'Lost connection to device server, try reconnecting in 5 seconds', type: 'error', showCloseButton: true, duration: 3000 }); } this._reconnectServerTimer = setTimeout(function(){ thiz.checkDeviceServerConnection(); thiz._reconnectServerTimer=null; },this.reconnectDeviceServer); }, /** * * @param msg * @private */ onMQTTMessage:function(msg){ var message=utils.getJson(msg.message); var isUs =false; if(message){ var sourceHost = message.sourceHost; var sourcePort = message.sourcePort; var mqttHost = msg.host; var mqttPort = msg.port; if(sourceHost &amp;&amp; sourcePort){ if(sourceHost===mqttHost &amp;&amp; sourcePort==mqttPort){ isUs=true; } } } if(!isUs) { _debugMQTT &amp;&amp; console.error('on mqtt message ', [message, msg]); // var parts=msg.topic.split('/'); //&quot;192.168.1.20/23/Variable/Volume&quot; if(parts.length==4 &amp;&amp; parts[2]=='Variable'){ var _device = this.getDeviceByHost(parts[0],parts[1]); if(_device){ _debugMQTT &amp;&amp; console.error(' on mqtt variable topic ' + msg.topic); var _deviceInfo = this.toDeviceControlInfo(_device); if(_deviceInfo){ var driverInstance = this.getDriverInstance(_deviceInfo); if(driverInstance){ var scope = driverInstance.blockScope; var _variable = scope.getVariable(parts[3]); if(_variable){ _debugMQTT &amp;&amp; console.error(' received MQTT variable ' +_variable.name + ' = ' +message.value); _variable.set('value',message.value); _variable.refresh(); } //var variable = getVariable }else{ _debugMQTT &amp;&amp; console.error('cant find driver instance '+msg.topic); } }else{ _debugMQTT &amp;&amp; console.error('cant find device info'); } }else{ console.error('cant find device for : ' + msg.topic); } } }else{ _debugMQTT &amp;&amp; console.error('same source'); } }, /** * Find a block by url in all instances * @param url * @returns {*} */ getBlock:function(url){ for (var id in this.deviceInstances) { var instance = this.deviceInstances[id]; var scope = instance.blockScope; var block = scope.resolveBlock(url); if(block){ return block; } } return this.ctx.getDriverManager().getBlock(url); }, /*** * Callback when the NodeJS service manager initialized its service store. That may * happen multiple times as user can reload the store. * * @param evt * @private */ onNodeServiceStoreReady: function (evt) { if (this.deviceServerClient) { this.deviceServerClient.destroy(); } var store = evt.store,thiz = this; var client = this.createDeviceServerClient(store); var connect = has('drivers') &amp;&amp; has('devices'); /* if(client &amp;&amp; client.dfd){ thiz.connectToAllDevices(); client.dfd.then(function(){ thiz.connectToAllDevices(); }); }else { */ if (this.autoConnectDevices &amp;&amp; connect) { setTimeout(function () { thiz.connectToAllDevices(); }, 5000); } /*}*/ }, /** * * @param instance * @param modulePath * @private */ onDriverUpdated: function (instance, modulePath) { return; /* var scope = this.ctx.getBlockManager().getScope(instance.id); if (scope) { xlog('Did update driver code : ' + modulePath); scope.clearCache(); } */ }, /** * Some file has changed, update driver instance * @param evt * @private */ onModuleReloaded: function (evt) { if (this.deviceInstances.length == 0) {//nothing to do return; } var modulePath = utils.replaceAll('//', '/', evt.module); var newModule = evt.newModule; var found = false; for (var i in this.deviceInstances) { var instance = this.deviceInstances[i]; if (instance.modulePath === modulePath || instance.baseClass === modulePath) { this.mergeFunctions(instance, newModule.prototype); found = true; _debug &amp;&amp; console.log('Did update driver code : ' + modulePath,newModule.prototype); if (instance.blockScope) { instance.blockScope.expressionModel.expressionCache = {}; } this.onDriverUpdated(instance, modulePath); } } }, /** * * @param instance * @param hash * @param device * @private */ _removeInstance: function (instance, hash,device) { if (instance.destroy) { instance.destroy(); } instance.blockScope &amp;&amp; instance.blockScope._destroy(); delete this.deviceInstances[hash]; this.ctx.getBlockManager().removeScope(instance.options.id); this.ctx.getDriverManager().removeDriverInstance(instance,device); device.reset(); }, /** * * @param deviceInfo * @private */ removeDriverInstance: function (deviceInfo) { var instance = this.getDriverInstance(deviceInfo); if(instance){ this.ctx.getBlockManager().removeScope(instance.options.id); if(instance.blockScope){ instance.blockScope.destroy(); } instance.destroy(); }else{ _debugConnect &amp;&amp; console.error('remove instance : cant find!'); } for (var i in this.deviceInstances) { if(instance == this.deviceInstances[i]){ delete this.deviceInstances[i]; } } }, /** * * @param item {module:xcf/model/Device} the device * @param name {string} the name of the CI * @returns {string|int|object|null} */ getMetaValue: function (item, name) { var meta = item['user']; if (meta) { return utils.getCIInputValueByName(meta, name); } return null; }, /** * Return device by host and port * @param host {string} * @param port {string} * @returns {module:xcf/model/Device|null} */ getDeviceByHost: function (host,port) { var items = utils.queryStore(this.getStore(), { isDir: false }); for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var _host = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_HOST); var _port = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_PORT); if(_host ==host &amp;&amp; _port == port){ return device; } } return null; }, /** * Returns a device by id * @param id {string} * @returns {module:xcf/model/Device|null} */ getDeviceById: function (id) { var items = utils.queryStore(this.getStore(), { isDir: false }); if (items._S) { items = [items]; } for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID); if(_id == id){ return device; } } return null; }, /** * Returns all devices by driver id * @param id {string} the driver id * @returns {module:xcf/model/Device[]} */ getDevicesByDriverId: function (id) { var items = utils.queryStore(this.getStore(), { isDir: false }); if (items._S) { items = [items]; } for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var _id = this.getMetaValue(device, DEVICE_PROPERTY.CF_DEVICE_ID); if(_id == id){ return device; } } return null; }, getDeviceStoreItem: function (deviceInfo) { var store = this.getStore(); if(!store){ return; } var items = utils.queryStore(store, { isDir: false }); if (items._S) { items = [items]; } for (var i = 0; i &lt; items.length; i++) { var device = items[i], meta = device['user'], host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST), port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT), protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL); if (port === deviceInfo.port &amp;&amp; host === deviceInfo.host &amp;&amp; protocol === deviceInfo.protocol) { return device; } } }, /** * * @param ci * @param storeRef * @private */ onDriverSettingsChanged: function (ci, storeRef) { for (var i in this.deviceInstances) { var instance = this.deviceInstances[i]; //get settings, if not cached already if (instance &amp;&amp; instance.driver == storeRef) { //pick driver var driver = storeRef;// this.ctx.getDriverManager().getItemById(instance.options.id);//driverStore item var meta = driver['user']; var commandsCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_COMMANDS); if (commandsCI &amp;&amp; commandsCI['params'] &amp;&amp; commandsCI == ci) { instance.sendSettings = utils.getJson(commandsCI['params']); } var responseCI = utils.getCIByChainAndName(meta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES); if (responseCI &amp;&amp; responseCI['params']) { instance.responseSettings = utils.getJson(responseCI['params']); } break; } } }, /** * @private */ onDeviceStateChanged: function (item,silent) { if(item._userStopped !==true &amp;&amp; silent!==true &amp;&amp; item.info &amp;&amp; item.state &amp;&amp; item.state ==types.DEVICE_STATE.DISCONNECTED){ this.ctx.getNotificationManager().postMessage({ message:'Lost connection to ' + item.info.host + ', ...reconnecting', type:'error', showCloseButton: false, duration:1500 }); } if(silent!==true &amp;&amp; item.info &amp;&amp; item.state &amp;&amp; item.state ==types.DEVICE_STATE.CONNECTED){ this.ctx.getNotificationManager().postMessage({ message:'Connected to ' + item.info.host + '', type:'success', showCloseButton: false, duration:2000 }); } }, /** * * @param item * @returns {*} * @private */ connectDevice:function(item){ this.checkDeviceServerConnection(); var cInfo = this.toDeviceControlInfo(item); cInfo['clientSide'] = true; if (!cInfo) { console.error('couldnt start device, invalid control info'); return; } var hash = MD5(JSON.stringify(cInfo), 1); if (this.deviceInstances[hash]) { console.log('device already connected', cInfo); item.setState(types.DEVICE_STATE.CONNECTED); return this.deviceInstances[hash]; } item.setState(types.DEVICE_STATE.CONNECTING); this.publish(types.EVENTS.ON_STATUS_MESSAGE,{ text:'Trying to connect to ' + cInfo.toString(), type:'info' }); this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MANAGER_START_DRIVER, cInfo); }, /** * client application ready, mixin instances and block scopes * @param evt * @private */ onAppReady: function (evt) { var appContext = evt.context; appContext.deviceManager = this; appContext.driverManager = this; if (appContext.blockManager) { utils.mixin(appContext.blockManager.scopes, this.ctx.getBlockManager().scopes); } }, ///////////////////////////////////////////////////////////////////////////////////// // // Server methods (NodeJs) // ///////////////////////////////////////////////////////////////////////////////////// /** * @private */ onHaveNoDeviceServer:function(){ var thiz = this; var msg = this.ctx.getNotificationManager().postMessage({ message:'Have no device server connection', type:'error', showCloseButton: true, duration:1500, actions: { reconnect: { label: 'Reconnect', action: function() { thiz.checkDeviceServerConnection(); return msg.update({ message: 'Reconnecting...', type: 'success', actions: false, duration:1500 }); } } } }); }, ///////////////////////////////////////////////////////////////////////////////////// // // Server methods (PHP) // ///////////////////////////////////////////////////////////////////////////////////// /** * * @param options * @param readyCB * @param errorCB * @returns {*} * @private */ createItem: function (options, readyCB, errorCB) { return this.callMethodEx(null, 'createItem', [dojo.toJson(options)], readyCB, true); }, /*** * setDriverScriptContent is storing a driver's actual code in a given scope on the server * @param scope {string} * @param path {string} * @param content {string} * @param readyCB {function} * @param errorCB {function} * @returns {*} * @private */ setDriverScriptContent: function (scope, path, content, readyCB, errorCB) { return this.callMethodEx(null, 'setDriverContent', [scope, path, content], readyCB, true); }, /*** * getDriverScriptContent is receiving a driver's actual code in a given scope * @param scope {string} * @param path {string} * @param readyCB {function} * @param errorCB {function} * @returns {*} */ getDriverScriptContent: function (scope, path, readyCB, errorCB) { return this.callMethodEx(null, 'getDriverContent', [scope, path], readyCB, true); }, /** * * @param data * @returns {exports|module.exports|module:xcf/data/Store} * @private */ initStore: function (data) { var storeClass = declare('deviceStore',[TreeMemory,Trackable,ObservableStore],{}); var store = new storeClass({ data: data.items, idProperty: 'path', Model:Device, id:utils.createUUID(), observedProperties:[ &quot;name&quot;, &quot;state&quot;, &quot;iconClass&quot;, &quot;enabled&quot; ] }); this.store = store; this.onStoreReady(); return this.store; }, ///////////////////////////////////////////////////////////////////////////////////// // // Utils // ///////////////////////////////////////////////////////////////////////////////////// /** * * @param item * @private */ fixDeviceCI:function(item){ var meta = item['user']; var driverOptions= utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS); if(!driverOptions) { meta.inputs.push({ &quot;chainType&quot;: 0, &quot;class&quot;: &quot;cmx.types.ConfigurableInformation&quot;, &quot;dataRef&quot;: &quot;&quot;, &quot;dataSource&quot;: &quot;&quot;, &quot;description&quot;: null, &quot;enabled&quot;: true, &quot;enumType&quot;: &quot;-1&quot;, &quot;flags&quot;: -1, &quot;group&quot;: 'Common', &quot;id&quot;: DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS, &quot;name&quot;: DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS, &quot;order&quot;: 1, &quot;params&quot;: null, &quot;platform&quot;: null, &quot;title&quot;: &quot;Driver Options&quot;, &quot;type&quot;: 5, &quot;uid&quot;: &quot;-1&quot;, &quot;value&quot;:0, &quot;data&quot;:[ { value: 2, label: 'Runs Server Side' }, { value: 4, label: 'Show Debug Messages' }, { value: 8, label: 'Allow Multiple Device Connections' } ], &quot;visible&quot;: true, &quot;device&quot;: item }); }else{ driverOptions.data = [ { value: 2, label: 'Runs Server Side' }, { value: 4, label: 'Show Debug Messages' }, { value: 8, label: 'Allow Multiple Device Connections' } ]; driverOptions.group = 'Common' } var protocolCI = utils.getCIByChainAndName(meta, 0, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL); if(protocolCI){ protocolCI.type = 3; protocolCI.options = [ { label:&quot;TCP&quot;, value:&quot;tcp&quot; }, { label:&quot;UDP&quot;, value:&quot;tcp&quot; }, { label:&quot;Driver&quot;, value:&quot;driver&quot; }, { label:&quot;SSH&quot;, value:&quot;ssh&quot; }, { label:&quot;Serial&quot;, value:&quot;serial&quot; }, { label:&quot;MQTT&quot;, value:&quot;mqtt&quot; } ] } }, /** * Return handy info for a device * @param {module:xcf/model/Device} item * @returns {module:xide/types~DeviceInfo} */ toDeviceControlInfo: function (item) { if(!item._store &amp;&amp; item.id){ var _item = this.getItemById(item.id); if(_item){ item = _item; } } if(!item.path){ _debug &amp;&amp; console.error('not a device'); var _item = this.getDeviceStoreItem(item); if(!_item){ return null; } } _debug &amp;&amp; !item &amp;&amp; console.error('toDeviceControlInfo: invalid device item'); _debug &amp;&amp; !item.user &amp;&amp; console.error('toDeviceControlInfo: invalid device item, has no meta'); var meta = item['user']; var host = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_HOST), port = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PORT), title = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_TITLE), protocol = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_PROTOCOL), driverId = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER), options = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_OPTIONS), driverOptions = utils.getCIInputValueByName(meta, DEVICE_PROPERTY.CF_DEVICE_DRIVER_OPTIONS), serverSide = item.isServerSide(), result = null; this.fixDeviceCI(item); var driver = this.ctx.getDriverManager().getItemById(driverId); if (driver) { var driverMeta = driver['user'], script = utils.getCIInputValueByName(driverMeta, types.DRIVER_PROPERTY.CF_DRIVER_CLASS), responseCI = utils.getCIByChainAndName(driverMeta, 0, types.DRIVER_PROPERTY.CF_DRIVER_RESPONSES), responseSettings = {}, scope = driver['scope']; if (responseCI &amp;&amp; responseCI['params']) { responseSettings = utils.getJson(responseCI['params']); } result = { host: host, port: port, protocol: protocol, driver: script ? script.replace('./', '') : '', driverId:driverId, scope: scope, id: item.id, title:title, options:options, driverOptions:driverOptions, serverSide:serverSide, responseSettings:responseSettings, toString:function(){ return this.host + ':'+this.port+'@'+this.protocol; } }; }else{ _debug &amp;&amp; console.error('cant find driver ' + driverId + ' for '+ item.toString()); } item.info = result; return result; }, /** * Return the device's status icon * @param item {module:xcf/model/Device} The device * @returns {string} an icon class string */ getDeviceStatusIcon: function (item) { switch (item.state) { case types.DEVICE_STATE.DISCONNECTED: { return 'fa-unlink iconStatusOff' } case types.DEVICE_STATE.READY: case types.DEVICE_STATE.CONNECTED: { return 'fa-link iconStatusOn' } case types.DEVICE_STATE.SYNCHRONIZING: case types.DEVICE_STATE.CONNECTING: { return 'fa-spinner fa-spin' } } return 'fa-unlink iconStatusOff'; }, /** * Return device model item by device id * @param itemId * @returns {module:xcf/model/Device} The device */ getItemById: function (itemId) { if(!this.store || !this.store.data){ _debug &amp;&amp; console.error('Device Manager::getItemById : have no valid store'); return null; } var data = this.store.data, device = _.find(data,{ id: itemId }); if(!device){ _debug &amp;&amp; console.error('Device Manager::getItemById : cant find device with id: ' + itemId); return null; } return this.store.getSync(device.path); }, /** * * @param evt * @private */ onStoreCreated: function (evt) { var thiz = this, ctx = thiz.ctx, toolbar = isIDE ? ctx.mainView.getToolbar() : null, type = evt.type, data = evt.data, store = evt.store, items = store ? utils.queryStore(store, { isDir: false }) : [], owner = evt.owner, driverManager = this.ctx.getDriverManager(); if(type!==types.ITEM_TYPE.DEVICE){ return; } for (var i = 0; i &lt; items.length; i++) { var item = store.getSync(items[i].path); if (item._completed != null) { continue; } item._completed = true; var driverId = this.getMetaValue(item, DEVICE_PROPERTY.CF_DEVICE_DRIVER); if (!driverId) { console.error('device has no driver id!'); continue; } var driver = driverManager.getItemById(driverId), CIS = item.user; //complete CIS _.each(CIS.inputs,function(ci){ ci.device=item; ci.actionTarget=toolbar; ci.ctx = ctx; }); if (!_.isEmpty(driver)) { if(isIDE) { this.completeDevice(store,item,driver); item.iconClass = item.getStateIcon(); } } } //this.onNodeServiceStoreReady(evt); }, onClientMessage:function(evt){ this.checkDeviceServerConnection(); if(this.deviceServerClient){ this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.WRITE_LOG_MESSAGE, evt); } }, onClientLogMessage:function(evt){ if(!isServer){ this.onClientMessage(evt); } }, /** * * @param evt * @private */ onVariableChanged:function(evt){ var variable = evt.item, scope = evt.scope, name = variable.name; if(name==='value'){ return; } var value = variable.value, driver= scope.driver, device = scope.device; if(!name || value==null){ console.error('------------invalid params'); } if(device) { var deviceInfo = device.info, mqttTopic = deviceInfo.host + '/' + deviceInfo.port+'/Variable/' + name; _debugMQTT &amp;&amp; console.log('send mqtt message ' + mqttTopic); this.sendManagerCommand(types.SOCKET_SERVER_COMMANDS.MQTT_PUBLISH, { topic:mqttTopic, data:{ value:value, device:deviceInfo } }); } _debug &amp;&amp; console.error('on variable changed ' + device.toString()); }, /*** * Common manager function, called by the context of the application * @private */ init: function () { var thiz = this; if(this.initUI){ this.initUI(); } this.subscribe(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, this.onVariableChanged); this.subscribe([ EVENTS.ON_NODE_SERVICE_STORE_READY, EVENTS.ON_MODULE_RELOADED, EVENTS.ON_DEVICE_DISCONNECTED, EVENTS.ON_DEVICE_CONNECTED, EVENTS.ON_CLIENT_LOG_MESSAGE, EVENTS.ON_STORE_CREATED ]); this.deviceInstances = this.consoles = {}; this.driverScopes = { &quot;system_drivers&quot;: &quot;system_drivers/&quot; }; this.lastUpTime = (new Date()).getTime(); setInterval(function () { var current = (new Date()).getTime(); if (current - thiz.lastUpTime &gt; 30000) { thiz.lastUpTime = (new Date()).getTime(); } thiz.lastUpTime = current; }, 1000); }, onDeviceServerConnected:function(){}, //nulled in server mode addDeviceInstance:function(device,driver){} }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DeviceManager_Atomize.js.html":{"id":"manager_DeviceManager_Atomize.js.html","title":"Source: manager/DeviceManager_Atomize.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DeviceManager_Atomize.js /** @module xide/manager/DeviceManager */ define([ &quot;dcl/dcl&quot;, &quot;dojo/_base/declare&quot;, &quot;dojo/_base/lang&quot;, 'xide/encoding/MD5', 'xide/types', 'xide/utils', 'xide/factory', 'xide/client/AtomizeClient' ], function (dcl,declare,lang, MD5,types,utils,factory, AtomizeClient) { /*** * * Atomize only mixin */ return dcl(null, { declaredClass:&quot;xcf.manager.DeviceManager_Atomize&quot;, ///////////////////////////////////////////////////////////////////////////////////// // // Atomize-Related : @TODO // ///////////////////////////////////////////////////////////////////////////////////// onAtomizeMessage:function(msg){ console.log('atomize message'); }, onAtomizeReady:function(atomizeClient){ console.log('onAtomizeReady'); atomizeClient.get(&quot;DO.test.y&quot;,function(value) { if (value != undefined) { console.log('got value ' + value); } else { console.log('###undefined!'); atomizeClient.set(&quot;DO.test.y&quot;,'asdf'); } }); }, onAtomizeInit:function(atomizeClient){ console.log('onAtomizeInit'); console.log(' register watcher!'); atomizeClient.registerWatcher(&quot;DO.test.y&quot;,function(result) { console.log(&quot;Changed DO.test.y &quot;+result); }); // Register a watcher for the second input: update the field if the value changes atomizeClient.registerWatcher(&quot;DO.test.z&quot;,function(result) { console.log(&quot;Changed DO.test.z &quot;+result); }); }, checkAtomizeServerConnection:function(destroy){ if(this.startAtomize===false){ return; } /* // Init with options AtomizeClient.init({ host:'0.0.0.0', port:9999 }); // Register a watcher for the first input: update the field if the value changes AtomizeClient.registerWatcher(&quot;DO.test.y&quot;,function(result) { //document.getElementById('y').value = result; console.log(&quot;Changed DO.test.y &quot;+result); }); // Register a watcher for the second input: update the field if the value changes AtomizeClient.registerWatcher(&quot;DO.test.z&quot;,function(result) { //document.getElementById('z').value = result; console.log(&quot;Changed DO.test.z &quot;+result); }); // Connect AtomizeClient.connect(function () { // onConnect callback console.log('connected!'); // Loads the value for the first input. If not set, sets all the test data AtomizeClient.get(&quot;DO.test.y&quot;,function(value) { console.log('got DO.test.y ' + value); if (value != undefined) { // document.getElementById('y').value = value; } else { console.log('###undefined!'); AtomizeClient.set(&quot;DO.test&quot;,{y:0,z:1}); } }); // Loads the value for the second input AtomizeClient.get(&quot;DO.test.z&quot;,function(value) { console.log('got DO.test.z ' + value); // document.getElementById('z').value = value; }); }); */ if(destroy ===true &amp;&amp; this.atomizeClient){ this.atomizeClient.destroy(); this.atomizeClient=null; } if(!this.atomizeClient){ var store = this.ctx.getNodeServiceManager().getStore(); if(!store){ console.error('checkAtomizeServerConnection: have no service store'); return; } var thiz=this; this.atomizeClient=factory.createClientWithStore(store,'Distributed Objects',{ delegate:{ onInit:function(who){ thiz.onAtomizeInit(who); }, onConnectionReady:function(who){ thiz.onAtomizeReady(who); }, onServerResponse:function(data){ thiz.onAtomizeMessage(data); } } },AtomizeClient); } } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_DeviceManager_UI.js.html":{"id":"manager_DeviceManager_UI.js.html","title":"Source: manager/DeviceManager_UI.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/DeviceManager_UI.js /** @module xide/manager/DeviceManager */ define([ 'dcl/dcl', &quot;dojo/_base/declare&quot;, 'xide/types', 'xide/utils', 'xide/factory', 'xide/views/ActionDialog', 'xide/views/CIActionDialog', 'xide/views/CIGroupedSettingsView', 'xaction/Action', 'xide/views/ConsoleView', 'xide/registry', 'xlog/views/LogGrid', 'xide/encoding/MD5', 'xcf/views/DriverConsole', 'xide/views/_CIDialog', &quot;xide/data/Reference&quot;, &quot;dojo/Deferred&quot; ], function (dcl,declare, types, utils, factory, ActionDialog, CIActionDialog, CIGroupedSettingsView, Action,ConsoleView,registry,LogGrid,MD5,DriverConsole,_CIDialog,Reference,Deferred) { var debug = false; return dcl(null, { declaredClass:&quot;xcf.manager.DeviceManage_UI&quot;, initUI:function(){ var thiz = this, EVENTS = types.EVENTS; this.subscribe(types.EVENTS.ON_APP_READY, function (evt) { thiz.onAppReady(evt); }); this.subscribe([ EVENTS.ON_CI_UPDATE, EVENTS.ON_MAIN_VIEW_READY, EVENTS.ON_DRIVER_MODIFIED, EVENTS.ON_WIDGET_READY]); this.subscribe([types.EVENTS.ON_DEVICE_GROUP_SELECTED, types.EVENTS.ON_DEVICE_SELECTED], this.onItemSelected); }, onCIUpdate: function (evt) { var ci = evt.ci, device = ci ? ci.device : null, oldValue = evt.oldValue, newValue = evt.newValue, state = device ? device.get('state') : -1, driverManager = this.ctx.getDriverManager(), result = false; if(device){ this.updateCI(evt.ci, evt.newValue, evt.oldValue,device); var prop = types.DEVICE_PROPERTY; device.refresh(); device._store.emit('update',{}); switch (ci.id){ case prop.CF_DEVICE_ENABLED:{ device.set('enabled',newValue); if(newValue===true){ switch (state) { //ignore case types.DEVICE_STATE.READY: case types.DEVICE_STATE.CONNECTED: case types.DEVICE_STATE.CONNECTING:{ break; } case types.DEVICE_STATE.DISCONNECTED:{ result = this.startDevice(device,false); } } }else{ switch (state) { case types.DEVICE_STATE.READY: case types.DEVICE_STATE.CONNECTED: case types.DEVICE_STATE.CONNECTING:{ result = this.stopDevice(device); } } } device.set('enabled',newValue); break; } case prop.CF_DEVICE_DRIVER: case prop.CF_DEVICE_HOST: case prop.CF_DEVICE_PROTOCOL: case prop.CF_DEVICE_PORT:{ } } if(ci.id =='Driver'){ var driverOld = driverManager.getItemById(oldValue); var driverStore = driverOld._store; if(driverStore) { var driverId = oldValue; var preInstanceId = driverOld.path + '_instances' + '_instance_' + device.path; var preInstanceItem = driverStore.getSync(preInstanceId); if (preInstanceItem) { driverStore.removeSync(preInstanceId); driverOld.refresh(); } } driverId = newValue; var driver = driverManager.getItemById(driverId); this.completeDevice(device._store,device,driver,false); var devi = device._store.getSync(device.path); if(!devi){ device = device._store.putSync(device); debug &amp;&amp; console.log('- device was removed'); device.refresh(); } driver.refresh(); } } if (evt.owner &amp;&amp; evt.owner.delegate == this) { if(evt.didUpdate){ return didUpdate; } evt.didUpdate=true; //this.updateCI(evt.ci, evt.newValue, evt.oldValue, evt.storeItem); }else{ //console.log('not my owner'); } return result; }, /** * Refresh store from server */ reload: function () { var thiz = this; this.currentItem = null; this.ls('system_devices', function (data) { thiz.onStoreReloaded(data); if (thiz.treeView) { thiz.treeView.reload(thiz.store); } }); }, ///////////////////////////////////////////////////////////////////////////////////// // // UX related functions, @TODO : move it to somewhere else // ///////////////////////////////////////////////////////////////////////////////////// onItemRemoved: function (item) { this.currentItem = null; if (item) { var view = this.getView(item); if (view) { utils.destroyWidget(view); } } this.reload(); }, /** * * @param title * @param scope * @param parent * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}} */ createNewGroupItem:function(title,scope,parent){ return this.createItemStruct(title,scope,parent,title,true,types.ITEM_TYPE.DEVICE_GROUP); }, /** * * @param title * @param scope * @param parent * @returns {*|{name, isDir, parentId, path, beanType, scope}|{name: *, isDir: *, parentId: *, path: *, beanType: *, scope: *}} */ createNewItem: function (title, scope, parent) { return this.createItemStruct(title, scope, parent, parent + &quot;/&quot; + title, false, types.ITEM_TYPE.DEVICE); }, //bean manager override onItemSelected: function (item) { this.currentItem = item; }, onReloaded: function () { this.checkDeviceServerConnection(); }, openLog:function(item){ // default grid args var thiz = this, ctx = thiz.ctx, logManager = ctx.getLogManager(), store = logManager.store, info = item.info || this.toDeviceControlInfo(item), docker = ctx.mainView.getDocker(), host= utils.replaceAll('/','_',info.host), storeId = host + '_' + info.port + '_' + info.protocol; console.log('open log '+storeId);; logManager.getStore(storeId).then(function(_store){ var logGridArgs = { ctx: ctx, attachDirect: true, storeId:storeId, delegate:logManager, getRootFilter:function(){ return { show:true, host:info.host + ':' + info.port } }, collection: _store.filter({ show:true, host:info.host + ':' + info.port }).sort([{property: 'time', descending: true}]) }; var tab = docker.addTab(null,{ title: info.host, icon:'fa-calendar' }); var grid = utils.addWidget(LogGrid,logGridArgs,null,tab,true,'logGridView'); }); }, /** * Open a device console, it used the current selected device item from the tree * widget * @returns {widgetProto} */ openConsole:function(device,where,mixin){ var enabled = this.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_ENABLED); if(!enabled){ return null; } this.startDevice(device); var cInfo = this.toDeviceControlInfo(device); cInfo['clientSide'] = true; var hash = MD5(JSON.stringify(cInfo), 1), viewId = hash + '-Console', thiz = this, deviceInstance = this.deviceInstances[hash], driver = deviceInstance.driver, docker = this.ctx.mainView.getDocker(), self = this; debug &amp;&amp; console.log('open console ' + hash,cInfo); var scope = driver.blockScope, instance = scope.instance, originalScope = instance ? instance.blockScope : null, blockScope = originalScope || scope, driverInstance = this.getDriverInstance(cInfo, true), startup = where == null; where = where || docker.addTab(null,{ title: cInfo.host, icon: 'fa-terminal' }); var ConsoleViewClass = dcl(DriverConsole,{ destroy:function(){ self.consoles[viewId].remove(this); } }); var args = utils.mixin({ driver:driver, device:device, deviceInstance:deviceInstance, driverInstance:driverInstance, blockScope:blockScope, value:mixin ? mixin.value : '' },mixin); var view = utils.addWidget(ConsoleViewClass,utils.mixin({ ctx:this.ctx, type:'javascript', value:'return this.getVariable(\\'Volume\\');', editorArgs:args, owner:this, log: function (msg) { var printTemplate = '&lt;pre style=&quot;font-size:100%;padding: 0px;&quot; class=&quot;&quot;&gt; ${time} - ${result}&lt;/pre&gt;'; var out = ''; if (_.isString(msg)) { out += msg.replace(/\\n/g, '&lt;br/&gt;'); } else if (_.isObject(msg) || _.isArray(msg)) { out += JSON.stringify(msg, null, true); } var items = out.split('&lt;br/&gt;'); for (var i = 0; i &lt; items.length; i++) { this.printCommand('',items[i],this.logTemplate,true); } }, onConsoleEnter: function(command){ var consoleWidget = this.getConsole(); var thiz = this, failed = false; function expressionError(message,error){ //console.error('expression error ' + error.message); _resolved = '&lt;span class=&quot;text-primary&quot;&gt;&lt;b&gt;' + command + '&lt;/span&gt;&lt;/b&gt;&lt;span class=&quot;text-info&quot;&gt;' + ' failed: &lt;span class=&quot;text-danger&quot;&gt;' + error.message + '&lt;/span&gt;'; thiz.printCommand(_resolved,''); failed = true; //return command; return null; } var _resolved = this.parse(command,expressionError); if(failed){ return null; } this.owner.sendDeviceCommand(this.deviceInstance, _resolved); if (_resolved == command) { _resolved == ''; } else { _resolved = '&lt;span class=&quot;text-info&quot;&gt;&lt;b&gt;' + command + '&lt;/span&gt;&lt;/b&gt;&lt;span&gt;' + ' evaluates to &lt;span class=&quot;text-success&quot;&gt;' + _resolved + '&lt;/span&gt;'; } this.printCommand(_resolved,''); return _resolved; } },args),null,where,startup); where.add(view,null,false); view.consoleId = viewId; if(!this.consoles){ this.consoles = []; } if(!this.consoles[viewId]){ this.consoles[viewId] = []; } this.consoles[viewId].push(view); view._on('destroy',function(e){ thiz.consoles[viewId].remove(view); }); return view; }, completeDevice: function (store, device,driver,subscribe) { if (!driver.id) { console.error('have no id!'); } var parentId = device.path, ctx = this.ctx; device.directory=true; device.isDevice=true; var meta = device['user']; var protocolCI = utils.getCIByChainAndName(meta, 0, types.DEVICE_PROPERTY.CF_DEVICE_PROTOCOL); if(protocolCI){ protocolCI.type = 3; protocolCI.options = [ { label:&quot;TCP&quot;, value:&quot;tcp&quot; }, { label:&quot;UDP&quot;, value:&quot;tcp&quot; }, { label:&quot;Driver&quot;, value:&quot;driver&quot; }, { label:&quot;SSH&quot;, value:&quot;ssh&quot; }, { label:&quot;Serial&quot;, value:&quot;serial&quot; }, { label:&quot;MQTT&quot;, value:&quot;mqtt&quot; } ] } var optionsCI = utils.getCIByChainAndName(meta, 0, types.DEVICE_PROPERTY.CF_DEVICE_OPTIONS); if(!optionsCI){ meta.inputs.push({ &quot;chainType&quot;: 0, &quot;class&quot;: &quot;cmx.types.ConfigurableInformation&quot;, &quot;dataRef&quot;: &quot;&quot;, &quot;dataSource&quot;: &quot;&quot;, &quot;description&quot;: null, &quot;enabled&quot;: true, &quot;enumType&quot;: &quot;-1&quot;, &quot;flags&quot;: -1, &quot;group&quot;: 'Network', &quot;id&quot;: &quot;options&quot;, &quot;name&quot;: &quot;options&quot;, &quot;order&quot;: 1, &quot;params&quot;: null, &quot;platform&quot;: null, &quot;title&quot;: &quot;Options&quot;, &quot;type&quot;: 28, &quot;uid&quot;: &quot;-1&quot;, &quot;value&quot;: { }, &quot;visible&quot;: true, &quot;device&quot;:device }); }else{ optionsCI.device = device; } this.fixDeviceCI(device); var driverScope = driver.blockScope || this.ctx.getBlockManager().getScope(driver.id), commands = { path: parentId + '_commands', name: 'Commands', isDir: true, type: 'leaf', parentId: parentId, virtual: true }, blockStore = driverScope.blockStore; if(store.getSync(parentId + '_commands')){ store.removeSync(parentId + '_commands'); var subs = store.query({ parentId:parentId + '_commands' }); if(subs){ _.each(subs,function(sub){ store.removeSync(sub.path); }) } } //complete commands store.putSync(commands); device.commandsItem=commands; var variables = { path: parentId + '_variables', name: 'Variables', isDir: true, type: 'leaf', parentId: parentId, virtual: true }; device.variablesItem=variables; if(store.getSync(parentId + '_variables')){ store.removeSync(parentId + '_variables'); var subs = store.query({ parentId:parentId + '_variables' }); if(subs){ _.each(subs,function(sub){ store.removeSync(sub.path); }) } } store.putSync(variables); var commandBlocks = driverScope.getBlocks({ group: types.COMMAND_TYPES.BASIC_COMMAND }); commandBlocks = commandBlocks.concat(driverScope.getBlocks({ group: types.COMMAND_TYPES.CONDITIONAL_COMMAND })); function createReference(block,driver,title,icon){ var _isVariable = block.declaredClass.indexOf('model.Variable') !==-1 &amp;&amp; block.declaredClass.indexOf('VariableSwitch') ==-1; var _parent = _isVariable ? variables.path : commands.path; /* if(block.parentId!==null){ return; } */ if(block.isCommand!==true &amp;&amp; (block.declaredClass.indexOf( _isVariable? 'Variable' : 'Command')==-1)){ //console.log('--- not a '+ title,block); return; } //console.log('--- not a '+ title,block); var reference = new Reference({ enabled:true, path: utils.createUUID(), name: title, id: block.id, parentId: _parent, _mayHaveChildren: false, virtual: true, tooltip: true, icon:icon, command:!_isVariable, ref: { driver: driver, item: block, device:device }, type: types.ITEM_TYPE.BLOCK }); reference = store.putSync(reference); block.addReference(reference,{ properties: { &quot;name&quot;:true, &quot;enabled&quot;:true, &quot;value&quot;:true }, onDelete:true },true); reference.refresh(); } _.each(commandBlocks,function(block){ createReference(block,driver,block.name,block.icon || 'fa-exclamation'); }); subscribe !==false &amp;&amp; blockStore.on('added',function(block){ createReference(block,driver,block.name,block.icon || 'fa-exclamation'); }); subscribe !==false &amp;&amp; blockStore.on('delete',function(evt){ store.removeSync(evt.id); evt.target.refresh(); }); var basicVariables = driverScope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_BASIC_VARIABLES }); var i = _.find(basicVariables,{ id:'3403a69e-252a-30dc-b130-40a028d1cde4' }); basicVariables = basicVariables.concat(driverScope.getVariables({ group: types.BLOCK_GROUPS.CF_DRIVER_RESPONSE_VARIABLES })); _.each(basicVariables,function(variable){ createReference(variable,driver,variable.name,variable.icon || 'fa-code'); }); /* for (var i = 0; i &lt; basicVariables.length; i++) { var variable = basicVariables[i]; store.putSync({ path: utils.createUUID(), name: variable.title, id: variable.id, parentId: variables.path, _mayHaveChildren: false, virtual: true, ref: { driver: driver, item: variable, device:device }, type: types.ITEM_TYPE.BLOCK }); } */ ctx.getDriverManager().addDeviceInstance(device,driver); }, _getDevices:function(){ var store = this.getStore(); var items = utils.queryStore(store, { isDir: false }); if (items._S) { items = [items]; } return items; }, /*** * Add driver related items to each device store item. */ completeDeviceStore: function () { var driverMgr = this.ctx.getDriverManager(); var store = this.getStore(); var items = utils.queryStore(store, { isDir: false }); if (items._S) { items = [items]; } store.on('delete',function(item){ debugger; }); try { for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var enabled = this.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_ENABLED); if (device['_completed'] != null) { continue; } device['_completed'] = [true]; var driverId = this.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER); if (!driverId) { console.error('device has no driver id!'); continue; } var driver = this.ctx.getDriverManager().getItemById(driverId); if (driver) { this.completeDevice(device, driver); } else { console.error('device has no driver!'); } } } catch (e) { debugger; } }, onDeviceTreeViewCreated: function (view) { debug &amp;&amp; console.log('device tree view created'); }, /*** * Callback when a file widget has been created. We extend this widget for one more buttons: * * @param widget * @param ci * @param storeItem */ onDriverClassFileWidgetCreated: function (widget, ci, storeItem) { var thiz = this; widget.debugButton = factory.createButton( widget.getFreeExtensionSlot(),//the widget knows where to add new items &quot;el-icon-puzzle&quot;, //eluisve icon class &quot;elusiveButton&quot;, //elusive button class adjustments &quot;&quot;, //no label &quot;&quot;, //no extra dom style markup function () { //button click callback thiz.debugDriver(ci, storeItem); }, this); widget.editButton = factory.createButton( widget.getFreeExtensionSlot(),//the widget knows where to add new items &quot;el-icon-file-edit&quot;, //eluisve icon class &quot;elusiveButton&quot;, //elusive button class adjustments &quot;&quot;, //no label &quot;&quot;, //no extra dom style markup function () { //button click callback thiz.editDriver(ci, storeItem); }, this); }, /** * Somebody opened a widget * @param evt */ onWidgetReady: function (evt) { if (evt['owner'] == this // must come from us &amp;&amp; evt['ci'] != null // we need an CI &amp;&amp; utils.toString(evt['ci'].name) === types.DRIVER_PROPERTY.CF_DRIVER_CLASS // we need an CI &amp;&amp; evt['widget'] != null // we need a valid widget &amp;&amp; evt['storeItem'] != null // we need a store reference &amp;&amp; utils.toInt(evt['ci'].type) === types.ECIType.FILE) //must be a file widget { this.onDriverClassFileWidgetCreated(evt.widget, evt.ci, evt.storeItem); } }, /** * Bean UX function to create a new item by opening a dialog, followed by a server call */ newItem: function (currentItem) { var thiz = this; if (!currentItem) { currentItem = { path: &quot;&quot; } } var drivers = this.ctx.getDriverManager().getDriversAsEnumeration(); var parent = currentItem ? currentItem.isDir === true ? currentItem.path : '' : ''; var dfd = new Deferred(); var cis = [ utils.createCI('In Group', 13,parent, { widget: { disabled: true }, group: 'Common', visiable:false }), utils.createCI('Title', 13, 'MyNewDevice', { group: 'Common' }), utils.createCI('Enabled', 0, '', { group: 'Common', value: false }), utils.createCI('Scope', 3, 'system_devices', { group: 'Common', options: [ { label: 'System', value: 'system_devices' }, { label: 'User', value: 'user_devices' }, { label: 'App', value: 'app_devices' } ] }), utils.createCI('Driver', 3, drivers.length &gt; 0 ? drivers[0].value : '', { group: 'Common', options: drivers, name: types.DEVICE_PROPERTY.CF_DEVICE_DRIVER, enumType: 'Driver' }), utils.createCI('Network-Settings', types.ECIType.DEVICE_NETWORK_SETTINGS, 'no value') ]; var actionDialog = new _CIDialog({ title: 'New Device', resizable: true, onOk: function (data) { var idCi = utils.createCI('Id', 13, utils.createUUID(), { visible: false, group:&quot;Common&quot; }); data.push(idCi); var options = utils.toOptions(data); var nameCi = utils.getInputCIByName(cis, &quot;Title&quot;); var scopeCi = utils.getInputCIByName(cis, &quot;Scope&quot;); thiz.createItem(options, function (newItemData) { var newItem = thiz.createNewItem(nameCi.value, scopeCi.value, parent); newItem.path += '.meta.json'; newItem.user = { inputs:newItemData }; newItem.id = idCi.value; var device = thiz.store.putSync(newItem); _.each(device.user.inputs,function(ci){ ci.device = device; }); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: thiz.store, action: types.NEW_FILE, item: device }); device.refresh(); dfd.resolve(device); }); }, delegate: { }, cis: cis }); actionDialog.show(); return dfd; }, newGroup: function (item,scope) { var thiz = this; var currentItem = this.getItem(); var parent = currentItem ? utils.toBoolean(currentItem.isDir) === true ? utils.toString(currentItem.path) : '' : ''; var store = this.getStore(scope); var dfd = new Deferred(); var actionDialog = new _CIDialog({ title: 'New Device Group', onOk: function (dlg, data) { var title = this.getField('Title'); var scope = this.getField('Scope'); var _final = parent + '/' + title; thiz.createGroup(scope, _final, function () { var newItem = thiz.createNewGroupItem(title, scope, parent); store.putSync(newItem); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: thiz.store, action: types.NEW_DIRECTORY, item: newItem }); store.refreshItem(newItem); dfd.resolve(newItem); }); }, delegate: { }, cis: [ utils.createCI('Title', 13, ''), utils.createCI('Scope', 3, 'system_devices', { &quot;options&quot;: [ { label: 'System', value: 'system_devices' }, { label: 'User', value: 'user' }, { label: 'App', value: 'app' } ] }) ] }); actionDialog.show(); return dfd; }, onDriverModified:function(evt){ debug &amp;&amp; console.log('on driver modified',this.getStore()); var store = this.getStore(), items = store ? utils.queryStore(store, { isDir: false }) : []; var driverManager = this.ctx.getDriverManager(); for (var i = 0; i &lt; items.length; i++) { var item = items[i]; var driverId = this.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_DRIVER); if (!driverId) { console.error('device has no driver id!'); continue; } var driver = driverManager.getItemById(driverId); if(item.commandsItem) { utils.removeFromStore(store, item.commandsItem, true, 'path', 'parentId'); } if(item.variablesItem) { utils.removeFromStore(store, item.variablesItem, true, 'path', 'parentId'); } this.completeDevice(store, item, driver); } /* var store = this.getStore(); var item = evt.driver; if(item.commandsItem) { utils.removeFromStore(store, item.commandsItem, true, 'path', 'parentId'); } if(item.variablesItem) { utils.removeFromStore(store, item.variablesItem, true, 'path', 'parentId'); } item._completed=false; this.completeDevice(store,item,item);*/ }, onDeleteItem: function (item) { var isDir = utils.toBoolean(item.isDir) === true; var name = utils.toString(item['name']); //pick the right service function var removeFn = isDir ? 'removeGroup' : 'removeItem'; var thiz = this; var actionDialog = new _CIDialog({ title: 'Remove Device' + (isDir ? ' Group' : '') + ' ' + '\\&quot;' + name + '\\&quot;', style: 'max-width:400px', titleBarClass: 'text-danger', onOk: function (dlg) { var store = thiz.getStore(item.scope); thiz[removeFn]( utils.toString(item.scope), utils.toString(item.path), utils.toString(item.name), function () { store.removeSync(item.path); thiz.publish(types.EVENTS.ON_STORE_CHANGED, { owner: thiz, store: store, action: types.DELETE, item: item }); }); }, delegate: { isRemoving: false }, inserts: [{ query: '.dijitDialogPaneContent', insert: '&lt;div&gt;&lt;span class=&quot;fileManagerDialogText&quot;&gt;Do you really want to remove this item' + '?&lt;/span&gt;&lt;/div&gt;', place: 'first' }] }); actionDialog.show(); }, /*** * openItemSettings creates a new settings view for a driver * @param item * @returns {xide.views.CIGroupedSettingsView} */ openItemSettings: function (item) { //1. sanity check var userData = item.user; if (!userData || !userData.inputs) { return null; } //2. check its not open already var viewId = this.getViewId(item); var view = registry.byId(viewId); try { if (view) { if (view._parent) { view._parent.select(view); } return view; } } catch (e) { utils.destroyWidget(view); } var docker = this.ctx.mainView.getDocker(); var parent = docker.addTab(null, { title: title || utils.toString(item.name), icon: this.beanIconClass }); var title = this.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_TITLE); //var title = this.getMetaValue(item, types.DEVICE_PROPERTY.CF_DEVICE_TITLE); var meta = item['user']; this.fixDeviceCI(item); var driverOptions= utils.getCIByChainAndName(meta, 0, types.DEVICE_PROPERTY.CF_DEVICE_OPTIONS); view = utils.addWidget(CIGroupedSettingsView, { title: title || utils.toString(item.name), cis: userData.inputs, storeItem: item, id: this.getViewId(item), iconClass: &quot;fa-sliders &quot; + this.getDeviceStatusIcon(item), delegate: this, storeDelegate: this, closable: true, owner:this }, this, parent, true, 'deviceView'); this.publish(types.EVENTS.RESIZE); //this.ctx.getWindowManager().registerView(view,true); return view; }, ///////////////////////////////////////////////////////////////////////////////////// // // Bean protocol impl. // ///////////////////////////////////////////////////////////////////////////////////// _getIcon: function (item) { var state = item.state; switch (state) { case types.DEVICE_STATE.CONNECTING: return 'iconStatusBusy'; case types.DEVICE_STATE.CONNECTED: return 'fa-signal'; case types.DEVICE_STATE.DISABLED: case types.DEVICE_STATE.DISCONNECTED: return 'fa-dot-circle-o'; } return 'fa-dot-circle-o'; }, getItemActions: function () { try { var actions = []; var thiz = this; var selectedItem = this.getItem(); var isGroup = selectedItem ? selectedItem.isDir === true : false; if (selectedItem &amp;&amp; !selectedItem.ref &amp;&amp; ( selectedItem.name == 'Commands' || selectedItem.name == 'Variables')) { return actions; } if (!selectedItem || selectedItem['ref'] == null /*&amp;&amp; utils.toString(selectedItem.name)!=='Commands' &amp;&amp; utils.toString(selectedItem.name)!=='Variables'*/) { } //item actions if (selectedItem) { if (!selectedItem.ref) { } //new item if (isGroup) { } else { /** * Command or Variable selected */ if (selectedItem.ref) { return []; } var state = selectedItem.state || types.DEVICE_STATE.DISCONNECTED; var connectAction = null; if (state == types.DEVICE_STATE.DISCONNECTED || state == types.DEVICE_STATE.DISABLED) { //Connect connectAction = Action.create('Connect', 'fa-link', 'Edit/Connect', false, null, 'Device', 'deviceAction', null, true, function () { thiz.startDevice(selectedItem) }, {object: selectedItem}).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, {label: ''}); } else if (state == types.DEVICE_STATE.CONNECTED) { connectAction = Action.create('Stop', 'fa-unlink', 'Edit/Stop', false, null, 'Device', 'deviceAction', null, true, function () { thiz.stopDevice(selectedItem); }, {object: selectedItem}).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, { label: '', style: 'color:red' }); } else if (state == types.DEVICE_STATE.CONNECTING) { connectAction = Action.create('Stop', 'fa-unlink', 'Edit/Stop', false, null, 'Device', 'deviceAction', null, true, function () { thiz.stopDevice(selectedItem); }, {object: selectedItem}).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, { label: '', style: 'color:red' }); } connectAction.subscribe(types.EVENTS.ON_DEVICE_STATE_CHANGED, function (evt) { if (!evt.item || !evt.item.state) { return; } var icon, handler; switch (evt.item.state) { case types.DEVICE_STATE.DISCONNECTED: case types.DEVICE_STATE.DISABLED: { icon = &quot;fa-link&quot;; handler = function () { thiz.startDevice(selectedItem) }; break; } case types.DEVICE_STATE.CONNECTING: { icon = &quot;fa-spinner fa-spin&quot;; handler = function () { thiz.stopDevice(selectedItem) }; break; } case types.DEVICE_STATE.CONNECTED: { icon = &quot;fa-unlink&quot;; handler = function () { thiz.stopDevice(selectedItem) }; } } var visibility = this.getVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR); if (visibility.widget) { visibility.widget.set('iconClass', icon); } this.handler = handler; }); actions.push(connectAction); var _consoleAction = Action.create('Console', 'el-icon-indent-left', 'View/Console', false, null, 'Device', 'deviceAction', null, true, function () { thiz.openConsole(selectedItem); }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, {label: ''}); actions.push(_consoleAction); this._lastActions = actions; } } } catch (e) { debugger; } return actions; }, hasItemActions: function () { return true; }, onMainViewReady: function () { var thiz = this; /** * Register permanent actions */ var newDevice = Action.createDefault('New Device', 'el-icon-file-new', 'File/New/Device', '__anewAction', null, { permanent: true, handler: function () { thiz.newItem(); } }).setVisibility(types.ACTION_VISIBILITY.ACTION_TOOLBAR, null). setVisibility(types.ACTION_VISIBILITY.MAIN_MENU, {}). setVisibility(types.ACTION_VISIBILITY.CONTEXT_MENU, null); thiz.publish(types.EVENTS.REGISTER_ACTION, { owner: thiz, action: newDevice }); } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_BlockManager.js.html":{"id":"manager_BlockManager.js.html","title":"Source: manager/BlockManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/BlockManager.js define([ 'dcl/dcl', &quot;xdojo/declare&quot;, &quot;dojo/_base/lang&quot;, 'xide/types', 'xide/utils', 'xide/factory', 'xide/manager/ManagerBase', 'xblox/manager/BlockManager' ], function (dcl,declare, lang, types, utils, factory, ManagerBase, BlockManager) { return dcl([ManagerBase, BlockManager], { declaredClass:&quot;xcf.manager.BlockManager&quot;, //nulled for server mode onReady:function(){}, addDriverFunctions: function (target, source) { for (var i in source) { var o = source[i]; if (i === 'constructor' || i === 'inherited') { continue; } if (lang.isFunction(source[i]) /*&amp;&amp; lang.isFunction(target[i])*/) { target[i] = source[i];//swap } } }, /** * One time call per blox scope creation. This adds various functions * to the blox's owner object. This enables expressions to access the * object but also block specific functions like getVariable * @param obj * @param scope * @param owner */ setScriptFunctions: function (obj, scope, owner) { var thiz = owner; if (!scope.context) { scope.context = obj;//set the context of the blox scope } /*obj._scope = scope;*/ if (!obj.blockScope) { obj.blockScope = scope; } var deviceManager = this.ctx.getDeviceManager(); //add shortcuts to the device if (scope.context) { if (scope.context.instance) {//no real driver instance! scope.device = scope.context.instance;//but we have a device less instance /*scope.context = scope.context.instance;*/ /*this.addDriverFunctions(obj,scope.context.instance);*/ } else { /*this.addDriverFunctions(obj,scope.context.instance);*/ /* scope.device = {//we have a real device : add 'sendMessage' _object: obj, _scope: scope, sendMessage: function (message) { //case when we've been constructed with no real device if (this._scope &amp;&amp; this._scope.context &amp;&amp; this._scope.context.instance) { this._scope.context.instance.sendMessage(message); return; } //console.log('sending device message : ' + message); //xlog('sending message : ' + message); //xtrace('test'); //xtrace('test'); //console.trace(&quot;Device.Manager.Send.Message : &quot; + message, this);//sending device message } } */ } } else { console.error('scope has no context!'); } //add various functions /////////////////////////////////////////////////////////////////////////////// // // Commands // /////////////////////////////////////////////////////////////////////////////// /** * Add 'setVariable' * @param title * @param value */ if (!obj.callCommand) { obj.callCommand = function (title) { var _block = this.blockScope.getBlockByName(title); if (_block) { _block.solve(this.blockScope); } else { console.log('no such variable : ' + title); return; } }; } /////////////////////////////////////////////////////////////////////////////// // // Variables // /////////////////////////////////////////////////////////////////////////////// /** * Add 'setVariable' * @param title * @param value */ if (!obj.setVariable) { obj.setVariable = function (title, value, save, publish, source) { var _variable = this.blockScope.getVariable(title); if (_variable) { _variable.value = value; _variable.set('value',value); console.log('setting variable ' + title + ' to ' + value); } else { console.log('no such variable : ' + title); return; } if (publish !== false) { thiz.publish(types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, { item: _variable, scope: scope, driver: obj, owner: thiz, save: save === true, source: source || types.MESSAGE_SOURCE.BLOX //for prioritizing }); } }; } /** * Add getVariable * @param title */ if (!obj.getVariable) { obj.getVariable = function (title) { var _variable = this.blockScope.getVariable(title); if (_variable) { return _variable.value; } return ''; }; } this.inherited(arguments); }, onReloaded: function () { this.init(); }, getDeviceVariablesAsEventOptions:function(scope){ var options = []; var _item = function(label,value,intend,selected,displayValue){ var string=&quot;&lt;span style=''&gt;&quot; +label + &quot;&lt;/span&gt;&quot;; var pre = &quot;&quot;; if(intend&gt;0){ for (var i = 0; i &lt; intend; i++) { pre+=&quot;&amp;nbsp;&quot;; pre+=&quot;&amp;nbsp;&quot;; pre+=&quot;&amp;nbsp;&quot;; } } return { label:pre + string, label2:displayValue, value:value/*, selected:selected*/ }; }; var driverManager = this.ctx.getDriverManager(); var deviceManager = this.ctx.getDeviceManager(); var items = deviceManager.getDevices(false,true); for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var driver = device.driver; if(!driver){ continue; } var title = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE); options.push(_item(title,driver.id+'/' +driver.id,0,false)); var blockScope = driver.blockScope; var variables = blockScope.getVariables(); for (var j = 0; j &lt; variables.length; j++) { var variable = variables[j]; var value = driver.id + '/'+ variable.id; var selected = ci.value ===value; options.push(_item(variable.title,value,1,selected,title + '/' + variable.title)); } } }, /** * Callback for VariableSwitch::getFields('variable'). * * @param evt {object} * @param evt.CI {xide/types/ConfigurableInformation} * @param evt.owner {xblox/model/variables/Variable} The variable */ onCreateVariableCI:function(evt){ console.log('onCreateVariableCI12',evt); /** * * 1. check its a ui variable: * 2. alter CI * */ var ci = evt.CI, variable = evt.owner, scope = variable.scope, isDriverVariable = scope.device!=null; console.log('ci value ' + ci.value); if(!isDriverVariable){ return; } // create filtering select options, pseudo code: // // foreach(device in devices) // let driver in device // createSelect(device name) // foreach(variable in driver) // createSelect(variable,value = ) // // var options = []; var _item = function(label,value,intend,selected,displayValue){ var string=&quot;&lt;span style=''&gt;&quot; +label + &quot;&lt;/span&gt;&quot;; var pre = &quot;&quot;; if(intend&gt;0){ for (var i = 0; i &lt; intend; i++) { pre+=&quot;&amp;nbsp;&quot;; pre+=&quot;&amp;nbsp;&quot;; pre+=&quot;&amp;nbsp;&quot;; } } return { label:pre + string, label2:displayValue, value:value/*, selected:selected*/ }; }; var driverManager = this.ctx.getDriverManager(); var deviceManager = this.ctx.getDeviceManager(); var items = deviceManager.getDevices(false,true); for (var i = 0; i &lt; items.length; i++) { var device = items[i]; var driver = device.driver; if(!driver){ continue; } var title = deviceManager.getMetaValue(device, types.DEVICE_PROPERTY.CF_DEVICE_TITLE); options.push(_item(title,driver.id+'/' +driver.id,0,false)); var blockScope = driver.blockScope; var variables = blockScope.getVariables(); for (var j = 0; j &lt; variables.length; j++) { var variable = variables[j]; var value = driver.id + '/'+ variable.id; var selected = ci.value ===value; options.push(_item(variable.name,value,1,selected,title + '/' + variable.title)); } } ci.options = options; ci.widget = { &quot;class&quot;:&quot;xide.form.FilterSelect&quot; } } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"manager_WidgetManager.js.html":{"id":"manager_WidgetManager.js.html","title":"Source: manager/WidgetManager.js","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Source: manager/WidgetManager.js define([ 'dcl/dcl', &quot;dojo/_base/declare&quot;, &quot;dojo/_base/lang&quot;, 'dojo/dom-construct', 'xide/mixins/ReloadMixin', 'xide/types', 'xide/utils', 'xide/factory', 'xwire/Binding', 'xwire/EventSource', 'xwire/WidgetTarget', 'xwire/WidgetSource', 'xwire/DeviceTarget', 'dojo/has!xideve?xideve/manager/WidgetManager' ], function (dcl, declare, lang, domConstruct, ReloadMixin, types, utils, factory, Binding, EventSource, WidgetTarget, WidgetSource, DeviceTarget, WidgetManager) { return dcl([WidgetManager, ReloadMixin.dcl], { declaredClass: &quot;xcf/manager/WidgetManager&quot;, instances: null, _cbinding: null, options: null, _doOpenRight: false, ///////////////////////////////////////////////////////////////////////////////////// // // Public API // ///////////////////////////////////////////////////////////////////////////////////// ///////////////////////////////////////////////////////////////////////////////////// // // Storage &amp; Persistence // ///////////////////////////////////////////////////////////////////////////////////// /** * */ onReloaded: function () { //console.error('reloaded!'); /*this.init();*/ this._createBinding(); /* var _data = new dojox.wire.ml.Data(); _data.startup(); _data.setPropertyValue('tempData',''); _data.setPropertyValue('value','value'); var _action = new dojox.wire.ml.Action({ trigger:&quot;inputField&quot;, triggerEvent:&quot;onChange&quot; }); _action.startup(); var _transfer = new dojox.wire.ml.Transfer({ source:&quot;inputField.value&quot;, target:&quot;data.tempData&quot; }); _transfer.startup(); */ /* &lt;div dojoType=&quot;dojox.wire.ml.Action&quot; id=&quot;action1&quot; trigger=&quot;inputField&quot; triggerEvent=&quot;onChange&quot;&gt; &lt;div dojoType=&quot;dojox.wire.ml.Transfer&quot; source=&quot;inputField.value&quot; target=&quot;data.tempData&quot;&gt;&lt;/div&gt; &lt;div dojoType=&quot;dojox.wire.ml.Invocation&quot; id=&quot;targetCopy&quot; object=&quot;targetField1&quot; method=&quot;set&quot; parameters=&quot;data.value, data.tempData&quot;&gt;&lt;/div&gt; &lt;/div&gt; */ /* &lt;div dojoType=&quot;dojox.wire.ml.Data&quot; id=&quot;data&quot;&gt; &lt;div dojoType=&quot;dojox.wire.ml.DataProperty&quot; name=&quot;tempData&quot; value=&quot;&quot;&gt; &lt;/div&gt; &lt;div dojoType=&quot;dojox.wire.ml.DataProperty&quot; name=&quot;value&quot; value=&quot;value&quot;&gt; &lt;/div&gt; &lt;/div&gt; */ }, ///////////////////////////////////////////////////////////////////////////////////// // // UX factory and utils // ///////////////////////////////////////////////////////////////////////////////////// makeDeviceBinding: function () { var source = {} }, _createBinding: function () { return; console.log('create binding'); /* var observable = new Observable({foo: &quot;FooValue0&quot;}); var observablePath = new ObservablePath(observable, &quot;foo&quot;); */ if (!this._cbinding) { this._cbinding = []; } var editorDijit = this.currentContext.getDijit(); var editorRegistry = editorDijit.registry; var slider = editorRegistry.byId('VolumeSlider'); //destroy old bindings for (var i = 0; i &lt; this._cbinding.length; i++) { this._cbinding[i].destroy(); } this._cbinding = []; /*** * Device Variable to Widget * @type {xwire.EventSource} */ //wire to a standard event var bindingSource = new EventSource({ //listen to variable changes trigger: types.EVENTS.ON_DRIVER_VARIABLE_CHANGED, //the path to value path: 'item.value', //add an event filter filters: [{ path: 'item.title', // variable title must match : value: 'Volume' // 'value' }] }); //we map the event source to a widget var bindingTarget = new WidgetTarget({ //the path to value path: 'value', object: slider }); //construct the binding var binding = new Binding({ source: bindingSource, target: bindingTarget }); binding.start(); this._cbinding.push(binding); //////////////////////////////////////////////////////////////// // // widget to device // //////////////////////////////////////////////////////////////// var deviceData = this.instances[0]; /** * Widget to Device * @type {binding|*} * @private */ bindingSource = new WidgetSource({ trigger: 'onChange', object: slider }); //we map the event source to a widget bindingTarget = new DeviceTarget({ object: deviceData.instance, command: 'SetMasterVolume', variable: 'Volume' }); //construct the binding binding = new Binding({ source: bindingSource, target: bindingTarget }); binding.start(); //track instance this._cbinding.push(binding); //slider.bind(&quot;value&quot;, observablePath); /* var input = document.querySelector(&quot;input&quot;); input.bind(&quot;value&quot;, observablePath); */ }, /** * Callback when a device driver instance is complete and ready! * @param evt */ onDeviceReady: function (evt) { console.log('on device ready'); this.instances.push(evt); }, getXFileOptions: function (extensions) { var thiz = this; /*** * Change file picker options */ var xFileContext = window['xFileContext']; var xFileConfig = xFileContext.config; //var vfsConfigs = this.ctx.vfsConfigs; var vfsDriverConfig = factory.cloneConfig(xFileConfig); var rootStore = xFileContext.getStore('workspace', { &quot;fields&quot;: 1663, &quot;includedFileExtensions&quot;: extensions || &quot;*&quot;, &quot;excludedFileExtensions&quot;: &quot;*&quot; }); var filePanelOptions = { cookiePrefix: 'driver', sources: [ { name: 'System', path: 'system_drivers', iconClass: 'fileSelectDiscIcon' }, { name: 'User', path: 'user_drivers', iconClass: 'fileSelectDiscIcon' }, { name: 'App', path: 'app_drivers', iconClass: 'fileSelectDiscIcon' } ], delegate: xFileContext.getPanelManager() }; return { store: rootStore, config: vfsDriverConfig, title: 'Select Driver', filePanelOptions: filePanelOptions }; }, onFileSelected: function (dlg, item) { console.log('on file selected'); //dlg.custom.node.value = utils.buildPath(item.mount,item.path,false); dlg.custom.prop.value = utils.buildPath(item.mount, item.path, false); dlg.custom.prop.owner._onChange({target: dlg.custom.prop.row}); /* var evt = document.createEvent(&quot;HTMLEvents&quot;); evt.initEvent(&quot;change&quot;, false, true); dlg.custom.prop.dispatchEvent(evt); var event = new Event('change'); dlg.custom.prop.dispatchEvent(event); */ /*dlg.custom.prop.fireEvent(&quot;onchange&quot;);*/ /* dlg.custom.prop.focus(); dlg.custom.prop.onchange(); */ }, onSelectFile: function (node, prop) { var thiz = this; var ctx = window['xFileContext']; var _defaultOptions = { title: 'Select Script', owner: window['xFileContext'], dst: { name: 'Select', path: '.' }, src: '.', ctx: window['xFileContext'], custom: { node: node, prop: prop } }; var extensions = &quot;*&quot;; if (prop.data &amp;&amp; prop.data.custom &amp;&amp; prop.data.custom.extensions) { extensions = prop.data.custom.extensions; } var xFileOptions = this.getXFileOptions(extensions); if (this.options) { _defaultOptions = lang.mixin(_defaultOptions, xFileOptions); } _defaultOptions.store = xFileOptions.store; _defaultOptions.config = xFileOptions.config; _defaultOptions.filePanelOptions = xFileOptions.filePanelOptions; _defaultOptions.defaultStoreName = 'workspace'; _defaultOptions.defaultStoreOptions = { &quot;fields&quot;: 1663, &quot;includedFileExtensions&quot;: extensions || &quot;*&quot;, &quot;excludedFileExtensions&quot;: &quot;*&quot; }; ctx.defaultOptions = _defaultOptions; var dlg = factory.createFileSelectDialogLarge(_defaultOptions, function (dlg, item) { thiz.onFileSelected(dlg, item); }); console.log('on select file'); }, /** * _addXAppApplication does a require of some xapp modules * @param context * @private */ _addXAppApplication: function (context) { var global = context.getGlobal(); var _require = global[&quot;require&quot;]; var _t = _require.toUrl('xapp/manager/Application'); /* _require(['xapp/manager/Application'],function(main){ }); */ }, onShowBlockSmartInput: function (evt) { evt.input.ctx = this.ctx; }, ///////////////////////////////////////////////////////////////////////////////////// // // Main entries, called by the context. 'Managers' must have always an init function // ///////////////////////////////////////////////////////////////////////////////////// init: function () { this.instances = []; this.subscribe(types.EVENTS.ON_DEVICE_DRIVER_INSTANCE_READY, this.onDeviceReady); this.subscribe(types.EVENTS.ON_SHOW_BLOCK_SMART_INPUT, this.onShowBlockSmartInput); } }); }); × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Global Members appScope Name of the app scope Source: manager/ProtocolManager.js, line 64 beanIconClass the icon class for bean edit views Source: manager/ProtocolManager.js, line 32 beanIconClass the icon class for bean edit views Source: manager/DriverManager.js, line 141 defaultScope the default scope for new items Source: manager/DriverManager.js, line 157 defaultScope Name of the default scope for new created items Source: manager/ProtocolManager.js, line 68 driverScopes array of driver store scopes : TODO : tbr Source: manager/DriverManager.js, line 177 groupType Bean group type Source: manager/DriverManager.js, line 145 groupType Bean group type Source: manager/ProtocolManager.js, line 36 insertIfMatch :object Type: object Source: manager/ProtocolManager.js, line 478 itemMetaPath the path to the meta data within the store item Source: manager/ProtocolManager.js, line 44 itemMetaStorePath the path to the meta data within the store item when saving Source: manager/ProtocolManager.js, line 48 itemMetaTitleField The name of the CI in the meta database for the title or name. Source: manager/ProtocolManager.js, line 52 itemMetaTitleField The name of the CI in the meta database for the title or name. Source: manager/DriverManager.js, line 153 itemType Bean item type Source: manager/ProtocolManager.js, line 40 itemType Bean item type Source: manager/DriverManager.js, line 149 match :RegExp|string|function|Array.&lt;RegExp&gt;|Array.&lt;string&gt;|Array.&lt;function()&gt; Type: RegExp | string | function | Array.&lt;RegExp&gt; | Array.&lt;string&gt; | Array.&lt;function()&gt; Source: manager/ProtocolManager.js, line 456 nodeValuePath :string the path within the dom structure Type: string Source: manager/ProtocolManager.js, line 452 replaceWith :string the new value for the field specified in nodeValuePath Type: string Source: manager/ProtocolManager.js, line 460 systemScope Name of the system scope Source: manager/ProtocolManager.js, line 56 userScope Name of the user scope Source: manager/ProtocolManager.js, line 60 variables :object additional variables Type: object Source: manager/ProtocolManager.js, line 464 Methods addDeviceInstance(device, driver) Parameters: Name Type Description device driver Source: manager/DriverManager.js, line 73 completeDriver(store, device, driver) Parameters: Name Type Description store device driver Source: manager/DriverManager_UI.js, line 365 createDriverInstance(storeItem, readyCB) Parameters: Name Type Description storeItem readyCB Source: manager/DriverManager_Server.js, line 81 createLeftView(where, who, item) this goes into _designCP Parameters: Name Type Description where who item Source: manager/Application_UI.js, line 915 Returns: Type widgetProto | * | * createRightView(where, who, item) this goes into _srcCP Parameters: Name Type Description where who item Source: manager/Application_UI.js, line 948 Returns: Type widgetProto | * | * editDriver(ci, storeItem) Parameters: Name Type Description ci storeItem Source: manager/DriverManager_UI.js, line 693 newGroup() Creates new driver group dialog Source: manager/DriverManager_UI.js, line 805 newItem() Bean UX function to create a new item by opening a dialog, followed by a server call Source: manager/DriverManager_UI.js, line 870 newItem() Bean UX function to create a new item by opening a dialog, followed by a server call Source: manager/ProtocolManager.js, line 227 nodeValueTransform() a function to transform the node's dom value into something else Source: manager/ProtocolManager.js, line 469 onCreateVariableCI(evt) Callback for VariableSwitch::getFields('variable'). Parameters: Name Type Description evt object Properties Name Type Description CI xide/types/ConfigurableInformation owner xblox/model/variables/Variable The variable Source: manager/BlockManager.js, line 226 onDeviceMessage(evt) Secondary entry for incoming device messages. This is a regular callback for the system event xcf.types.EVENTS.ON_DEVICE_MESSAGE emitted by the DeviceManager. It comes with the device info, a driver instance and the unfiltered device message. This function is primarily in charge to : split the message by a delimiter (driver settings) pass the device messages to the actual driver pass the device message to blox 4. Parameters: Name Type Description evt Source: manager/DriverManager.js, line 319 onDeviceReady(evt) Callback when a device driver instance is complete and ready! Parameters: Name Type Description evt Source: manager/WidgetManager.js, line 207 onMainViewReady(clear, open) Parameters: Name Type Description clear open Source: manager/Application_UI.js, line 209 Returns: Type * onNewDriverScopeCreated(scope) Callback when a blox scope has been created. This is being used to deserialize the driver's CI meta settings into a blox scope : variables, commands Parameters: Name Type Description scope Source: manager/DriverManager.js, line 570 onReloaded() Source: manager/WidgetManager.js, line 38 onStoreReady(store) Protocol store is ready, extend each item with a file-editor CI (protocol content) Parameters: Name Type Description store Source: manager/ProtocolManager.js, line 596 onWidgetReady(evt) Callback when a CI based widget has been rendered This will may be complete xide standard widgets. Parameters: Name Type Description evt Source: manager/DriverManager_UI.js, line 526 registerEditorExtensions() Register new editors for xfile Source: manager/Application_UI.js, line 511 setScriptFunctions(obj, scope, owner) One time call per blox scope creation. This adds various functions to the blox's owner object. This enables expressions to access the object but also block specific functions like getVariable Parameters: Name Type Description obj scope owner Source: manager/BlockManager.js, line 36 start() Main entry point, does: create the main view registers custom types and enumerations loads data and adds data views initializes XFile Source: manager/Application_UI.js, line 279 toPreferenceId() Override id for pref store: know factors: IDE theme per bean description and context by container class string app / plugins | product / package or whatever this got into - Source: manager/Application_UI.js, line 71 updateItemMetaData(scope, driverMetaPath, dataPath, query, value, readyCB, errorCB) updateItemMetaData updates a CI in the drivers meta data store Parameters: Name Type Description scope string driverMetaPath string dataPath string : /inputs query value readyCB errorCB Source: manager/DriverManager_UI.js, line 91 Returns: Type * × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Modules Classes DriverBase DeviceManager_DeviceServer module:xcf/manager/BeanManager module:xcf/manager/Context module:xcf/manager/DeviceManager × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Classes Classes DriverBase DeviceManager_DeviceServer module:xcf/manager/BeanManager module:xcf/manager/Context module:xcf/manager/DeviceManager × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf.driver.DriverBase.html":{"id":"module-xcf.driver.DriverBase.html","title":"Class: DriverBase","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Class: DriverBase DriverBase new DriverBase() Driver Base Class Please read module:xide/types Online docs: http://rawgit.com/mc007/xcfnode/tree/master/out Source: driver/DriverBase.js, line 5 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf.manager.DeviceManager_DeviceServer.html":{"id":"module-xcf.manager.DeviceManager_DeviceServer.html","title":"Class: DeviceManager_DeviceServer","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Class: DeviceManager_DeviceServer DeviceManager_DeviceServer new DeviceManager_DeviceServer() Source: manager/DeviceManager_DeviceServer.js, line 47 Extends module:xcf/manager/DeviceManager module:xide/mixins/EventedMixin × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf_driver_DriverBase.html":{"id":"module-xcf_driver_DriverBase.html","title":"Module: xcf/driver/DriverBase","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Module: xcf/driver/DriverBase Source: driver/DriverBase.js, line 1 Members &lt;inner&gt; lineBreak :string Type: string Default Value: \\r Source: driver/DriverBase.js, line 59 &lt;inner&gt; options :object The information about the device in this structure: Type: object Source: driver/DriverBase.js, line 29 Example { driver:&quot;Marantz/MyMarantz.js&quot;, host:&quot;102.123.23.23&quot; port:23, protocol:&quot;tcp&quot; scope:&quot;system_drivers&quot; } &lt;inner&gt; responseSettings :object responseSettings contains the constants for receiving data from a device its being set at initialization time and has this structure: Type: object Source: driver/DriverBase.js, line 98 Example { start:false, startString:'' cTypeByte:false, //construction type 'Per Byte' cTypePacket:false, //construction type 'Per Packet' cTypeDelimiter:true, //construction type 'Per Delimiter' cTypeCount:false, //construction type 'Per Count' delimiter:'', //the delimiter count:10 //packet count } &lt;inner&gt; sendSettings :object sendSettings contains the constants for receiving and sending data to a device its being set at initialization time and has this structure: Type: object Source: driver/DriverBase.js, line 81 Example { constants:{ end:'\\r', start:'', }, send:{ interval:500, mode:true|false, //true=onReply | false=Interval onReply:'\\n', timeout:500 } } Methods &lt;inner&gt; getLineBreak() Deal with Javascript special characters, indexOf(&quot;\\n&quot;) fails otherwise Source: driver/DriverBase.js, line 363 Returns: Type string &lt;inner&gt; getLineBreakSend() Deal with Javascript special characters, indexOf(&quot;\\n&quot;) fails otherwise Source: driver/DriverBase.js, line 351 Returns: Type string &lt;inner&gt; getVariable(title) Return a variable's value Parameters: Name Type Description title string the name of the variable Source: driver/DriverBase.js, line 484 Returns: the value of the variable Type string &lt;inner&gt; log(level, type, message, data) Method to add a logging message. Parameters: Name Type Description level string This can be error, warning, info, trace or custom type string An additional string, by default this is set to &quot;Device&quot; message string The message it self data object An optional object/data you want to include Source: driver/DriverBase.js, line 145 Example // for instance you want to log any incoming message in a custom way, you need to overwrite 'sendMessage' in // your base class like this: onMessage: function (data) { this.log('info', 'my marantz', 'Marantz Driver Message: ' + data.message, { some: 'extra', message: data }); this.inherited(arguments); //important, call BaseDriver::onMessage! } &lt;inner&gt; onMessage(data) Standard callback when we have a message from the device we're bound to (specified in profile). put the message in the incoming queue, tag it as 'unread' in case we have messages to send and we are in 'onReply' mode, trigger outgoing queue Parameters: Name Type Description data Object : Message Struct build by the device manager Properties Name Type Description device Object : Device info Properties Name Type Description host String : The host port String : The host's port protocol String : The host's protocol message String : RAW message, untreated Source: driver/DriverBase.js, line 444 Example // for instance you might update the &quot;Volume&quot; Variable within onMessage: onMessage:function(data){ var value = data.message; var volume = 0; if (value.indexOf('MV') != -1 &amp;&amp; value.indexOf('MVMAX') == -1) { var _volume = value.substring(2, value.length); _volume = parseInt(_volume.substring(0, 2)); if (!isNaN(_volume)) { this.setVariable('Volume', _volume); volume = _volume; } } // do something else with volume: this.log('info',null,'Did update volume to ' + volume); //important, call BaseDriver::onMessage! this.inherited(arguments); } &lt;inner&gt; prepareMessage(msg) Surround command with 'start' and 'end' constant, specified in the command settings of the driver. Parameters: Name Type Description msg Source: driver/DriverBase.js, line 176 Returns: Type * | string | String &lt;inner&gt; sendMessage(msg, now, src, id) Send message send a string to the device. Basing on the send settings this message will be queued or send on reply. Parameters: Name Type Description msg string the string to send now string force sending now! src string the id of the source block id string the id of the send job Source: driver/DriverBase.js, line 279 &lt;inner&gt; setVariable(title, value) Set a variable's value Parameters: Name Type Description title string the name of the variable value string the new value Source: driver/DriverBase.js, line 478 &lt;inner&gt; split(str) Splits a message string from the device server into an array of messages. Its using 'responseSettings' Parameters: Name Type Description str Source: driver/DriverBase.js, line 377 Returns: Type Array.&lt;string&gt; &lt;inner&gt; start() Main entry when this instance is started Source: driver/DriverBase.js, line 469 Returns: Type boolean × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf_manager_BeanManager.html":{"id":"module-xcf_manager_BeanManager.html","title":"Module: xcf/manager/BeanManager","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Module: xcf/manager/BeanManager new (require(&quot;xcf/manager/BeanManager&quot;))() Source: manager/BeanManager.js, line 13 Methods &lt;inner&gt; newGroup() Creates new group item dialog Source: manager/BeanManager.js, line 123 &lt;inner&gt; toUrl(device, driver, block, prefix) Url generator for device/driver/[command|block|variable] Parameters: Name Type Description device driver block prefix Source: manager/BeanManager.js, line 28 Returns: Type * × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf_manager_Context.html":{"id":"module-xcf_manager_Context.html","title":"Class: module:xcf/manager/Context","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Class: module:xcf/manager/Context module:xcf/manager/Context new module:xcf/manager/Context() Source: manager/Context.js, line 23 Extends module:xide/manager/Context × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf_manager_DeviceManager.html":{"id":"module-xcf_manager_DeviceManager.html","title":"Module: xcf/manager/DeviceManager","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Module: xcf/manager/DeviceManager new (require(&quot;xcf/manager/DeviceManager&quot;))() Common base class, for server and client. Source: manager/DeviceManager.js, line 63 Methods &lt;inner&gt; createDriverInstance(deviceInfo, driverBase, device) Creates a driver instance per device Parameters: Name Type Description deviceInfo module:xide/types~DeviceInfo The device info driverBase module:xcf/driver/DriverBase The driver base class device module:xcf/model/Device The device model item Source: manager/DeviceManager.js, line 510 &lt;inner&gt; getBlock(url) Find a block by url in all instances Parameters: Name Type Description url Source: manager/DeviceManager.js, line 980 Returns: Type * &lt;inner&gt; getDeviceByHost(host, port) Return device by host and port Parameters: Name Type Description host string port string Source: manager/DeviceManager.js, line 1127 Returns: Type module:xcf/model/Device | null &lt;inner&gt; getDeviceById(id) Returns a device by id Parameters: Name Type Description id string Source: manager/DeviceManager.js, line 1148 Returns: Type module:xcf/model/Device | null &lt;inner&gt; getDevices(enabledOnly, addDriver) Get all enabled devices Parameters: Name Type Description enabledOnly addDriver Source: manager/DeviceManager.js, line 683 Returns: Type Array.&lt;module:xcf/model/Device&gt; &lt;inner&gt; getDevicesByDriverId(id) Returns all devices by driver id Parameters: Name Type Description id string the driver id Source: manager/DeviceManager.js, line 1170 Returns: Type Array.&lt;module:xcf/model/Device&gt; &lt;inner&gt; getDeviceStatusIcon(item) Return the device's status icon Parameters: Name Type Description item module:xcf/model/Device The device Source: manager/DeviceManager.js, line 1592 Returns: an icon class string Type string &lt;inner&gt; getItemById(itemId) Return device model item by device id Parameters: Name Type Description itemId Source: manager/DeviceManager.js, line 1619 Returns: The device Type module:xcf/model/Device &lt;inner&gt; getMetaValue(item, name) Parameters: Name Type Description item module:xcf/model/Device the device name string the name of the CI Source: manager/DeviceManager.js, line 1114 Returns: Type string | int | object | null &lt;inner&gt; onDeviceStarted(driverInstance, deviceStoreItem, driver) Callback when we are connected to a device. We use this to fire all looping blocks Parameters: Name Type Description driverInstance module:xcf/driver/DriverBase the instance of the driver deviceStoreItem module:xcf/model/Device the device model item driver module:xcf/model/Driver the driver model item Source: manager/DeviceManager.js, line 425 &lt;inner&gt; stopDevice(item) Stops a device with a device model item Parameters: Name Type Description item module:xcf/model/Device | string Source: manager/DeviceManager.js, line 642 &lt;inner&gt; toDeviceControlInfo(item) Return handy info for a device Parameters: Name Type Description item module:xcf/model/Device Source: manager/DeviceManager.js, line 1518 Returns: Type module:xide/types~DeviceInfo × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xcf_manager_DeviceManager_DeviceServer.html":{"id":"module-xcf_manager_DeviceManager_DeviceServer.html","title":"Module: xcf/manager/DeviceManager_DeviceServer","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Module: xcf/manager/DeviceManager_DeviceServer Source: manager/DeviceManager_DeviceServer.js, line 1 Methods &lt;inner&gt; onDeviceServerMessage(evt) Primary callback when the device server has received a message from a device. Parameters: Name Type Description evt Source: manager/DeviceManager_DeviceServer.js, line 401 &lt;inner&gt; onSetDeviceServerVariables(data) Callback when server returns the variables of a device Parameters: Name Type Description data Source: manager/DeviceManager_DeviceServer.js, line 60 &lt;inner&gt; sendManagerCommand(cmd, data) Device Server managment interface Parameters: Name Type Description cmd data Source: manager/DeviceManager_DeviceServer.js, line 563 &lt;inner&gt; startDevice(item) Starts a device with a device store item Parameters: Name Type Description item Source: manager/DeviceManager_DeviceServer.js, line 268 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "},"module-xide_manager_DeviceManager.html":{"id":"module-xide_manager_DeviceManager.html","title":"Module: xide/manager/DeviceManager","body":" Documentation Modules xcf/driver/DriverBasexcf/manager/BeanManagerxcf/manager/DeviceManagerxcf/manager/DeviceManager_DeviceServerxide/manager/DeviceManager Classes xcf.driver.DriverBasexcf.manager.DeviceManager_DeviceServerxcf/manager/Context Global addDeviceInstanceappScopebeanIconClasscompleteDrivercreateDriverInstancecreateLeftViewcreateRightViewdefaultScopedriverScopeseditDrivergroupTypeinsertIfMatchitemMetaPathitemMetaStorePathitemMetaTitleFielditemTypematchnewGroupnewItemnodeValuePathnodeValueTransformonCreateVariableCIonDeviceMessageonDeviceReadyonMainViewReadyonNewDriverScopeCreatedonReloadedonStoreReadyonWidgetReadyregisterEditorExtensionsreplaceWithsetScriptFunctionsstartsystemScopetoPreferenceIdupdateItemMetaDatauserScopevariables Module: xide/manager/DeviceManager Source: manager/DeviceManager_Atomize.js, line 1 Methods &lt;inner&gt; createNewGroupItem(title, scope, parent) Parameters: Name Type Description title scope parent Source: manager/DeviceManager_UI.js, line 187 Returns: Type * | Object | Object &lt;inner&gt; createNewItem(title, scope, parent) Parameters: Name Type Description title scope parent Source: manager/DeviceManager_UI.js, line 197 Returns: Type * | Object | Object &lt;inner&gt; newItem() Bean UX function to create a new item by opening a dialog, followed by a server call Source: manager/DeviceManager_UI.js, line 754 &lt;inner&gt; onWidgetReady(evt) Somebody opened a widget Parameters: Name Type Description evt Source: manager/DeviceManager_UI.js, line 740 &lt;inner&gt; openConsole() Open a device console, it used the current selected device item from the tree widget Source: manager/DeviceManager_UI.js, line 252 Returns: Type widgetProto &lt;inner&gt; reload() Refresh store from server Source: manager/DeviceManager_UI.js, line 153 Module: xide/manager/DeviceManager Source: manager/DeviceManager_UI.js, line 1 Methods &lt;inner&gt; createNewGroupItem(title, scope, parent) Parameters: Name Type Description title scope parent Source: manager/DeviceManager_UI.js, line 187 Returns: Type * | Object | Object &lt;inner&gt; createNewItem(title, scope, parent) Parameters: Name Type Description title scope parent Source: manager/DeviceManager_UI.js, line 197 Returns: Type * | Object | Object &lt;inner&gt; newItem() Bean UX function to create a new item by opening a dialog, followed by a server call Source: manager/DeviceManager_UI.js, line 754 &lt;inner&gt; onWidgetReady(evt) Somebody opened a widget Parameters: Name Type Description evt Source: manager/DeviceManager_UI.js, line 740 &lt;inner&gt; openConsole() Open a device console, it used the current selected device item from the tree widget Source: manager/DeviceManager_UI.js, line 252 Returns: Type widgetProto &lt;inner&gt; reload() Refresh store from server Source: manager/DeviceManager_UI.js, line 153 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-06-02T17:42:36+02:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
